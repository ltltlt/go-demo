TEXT internal/cpu.Initialize(SB) /usr/local/go/src/internal/cpu/cpu.go
func Initialize(env string) {
  0x401000		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401009		483b6110		CMPQ 0x10(CX), SP	
  0x40100d		7635			JBE 0x401044		
  0x40100f		4883ec18		SUBQ $0x18, SP		
  0x401013		48896c2410		MOVQ BP, 0x10(SP)	
  0x401018		488d6c2410		LEAQ 0x10(SP), BP	
	doinit()
  0x40101d		e8fe060000		CALL internal/cpu.doinit(SB)	
	processOptions(env)
  0x401022		488b442420		MOVQ 0x20(SP), AX			
  0x401027		48890424		MOVQ AX, 0(SP)				
  0x40102b		488b442428		MOVQ 0x28(SP), AX			
  0x401030		4889442408		MOVQ AX, 0x8(SP)			
  0x401035		e816000000		CALL internal/cpu.processOptions(SB)	
}
  0x40103a		488b6c2410		MOVQ 0x10(SP), BP	
  0x40103f		4883c418		ADDQ $0x18, SP		
  0x401043		c3			RET			
func Initialize(env string) {
  0x401044		e837680400		CALL runtime.morestack_noctxt(SB)	
  0x401049		ebb5			JMP internal/cpu.Initialize(SB)		

TEXT internal/cpu.processOptions(SB) /usr/local/go/src/internal/cpu/cpu.go
func processOptions(env string) {
  0x401050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401059		488d4424b8		LEAQ -0x48(SP), AX	
  0x40105e		483b4110		CMPQ 0x10(CX), AX	
  0x401062		0f866e060000		JBE 0x4016d6		
  0x401068		4881ecc8000000		SUBQ $0xc8, SP		
  0x40106f		4889ac24c0000000	MOVQ BP, 0xc0(SP)	
  0x401077		488dac24c0000000	LEAQ 0xc0(SP), BP	
	for env != "" {
  0x40107f		488b8424d8000000	MOVQ 0xd8(SP), AX	
  0x401087		488b8c24d0000000	MOVQ 0xd0(SP), CX	
  0x40108f		eb09			JMP 0x40109a		
  0x401091		4889c2			MOVQ AX, DX		
  0x401094		4889c8			MOVQ CX, AX		
  0x401097		4889d1			MOVQ DX, CX		
  0x40109a		4885c0			TESTQ AX, AX		
  0x40109d		0f843e040000		JE 0x4014e1		
  0x4010a3		4889442428		MOVQ AX, 0x28(SP)	
  0x4010a8		48894c2468		MOVQ CX, 0x68(SP)	
		i := indexByte(env, ',')
  0x4010ad		48890c24		MOVQ CX, 0(SP)			
  0x4010b1		4889442408		MOVQ AX, 0x8(SP)		
  0x4010b6		c64424102c		MOVB $0x2c, 0x10(SP)		
  0x4010bb		e820060000		CALL internal/cpu.indexByte(SB)	
  0x4010c0		488b442418		MOVQ 0x18(SP), AX		
		if i < 0 {
  0x4010c5		4885c0			TESTQ AX, AX		
  0x4010c8		0f8dd1030000		JGE 0x40149f		
  0x4010ce		31c0			XORL AX, AX		
  0x4010d0		31c9			XORL CX, CX		
		if len(field) < 4 || field[:4] != "cpu." {
  0x4010d2		488b542428		MOVQ 0x28(SP), DX	
  0x4010d7		4883fa04		CMPQ $0x4, DX		
  0x4010db		7cb4			JL 0x401091		
  0x4010dd		488b5c2468		MOVQ 0x68(SP), BX	
  0x4010e2		813b6370752e		CMPL $0x2e757063, 0(BX)	
  0x4010e8		75a7			JNE 0x401091		
	for env != "" {
  0x4010ea		4889442478		MOVQ AX, 0x78(SP)	
  0x4010ef		48894c2450		MOVQ CX, 0x50(SP)	
		if len(field) < 4 || field[:4] != "cpu." {
  0x4010f4		4889542428		MOVQ DX, 0x28(SP)	
		i = indexByte(field, '=')
  0x4010f9		48891c24		MOVQ BX, 0(SP)			
  0x4010fd		4889542408		MOVQ DX, 0x8(SP)		
  0x401102		c64424103d		MOVB $0x3d, 0x10(SP)		
  0x401107		e8d4050000		CALL internal/cpu.indexByte(SB)	
  0x40110c		488b442418		MOVQ 0x18(SP), AX		
		if i < 0 {
  0x401111		4885c0			TESTQ AX, AX		
  0x401114		0f8c22030000		JL 0x40143c		
		key, value := field[4:i], field[i+1:] // e.g. "SSE2", "on"
  0x40111a		4883f804		CMPQ $0x4, AX		
  0x40111e		0f82a4050000		JB 0x4016c8		
  0x401124		488b4c2428		MOVQ 0x28(SP), CX	
  0x401129		4839c8			CMPQ CX, AX		
  0x40112c		0f8796050000		JA 0x4016c8		
  0x401132		488d50fc		LEAQ -0x4(AX), DX	
  0x401136		4889d3			MOVQ DX, BX		
  0x401139		48f7da			NEGQ DX			
  0x40113c		48c1fa3f		SARQ $0x3f, DX		
  0x401140		4883e204		ANDQ $0x4, DX		
  0x401144		488b742468		MOVQ 0x68(SP), SI	
  0x401149		488d3c16		LEAQ 0(SI)(DX*1), DI	
  0x40114d		4c8d4001		LEAQ 0x1(AX), R8	
  0x401151		4939c8			CMPQ CX, R8		
  0x401154		0f876e050000		JA 0x4016c8		
  0x40115a		48895c2448		MOVQ BX, 0x48(SP)	
  0x40115f		48897c2460		MOVQ DI, 0x60(SP)	
  0x401164		4c29c1			SUBQ R8, CX		
  0x401167		4989c9			MOVQ CX, R9		
  0x40116a		48f7d9			NEGQ CX			
  0x40116d		48c1f93f		SARQ $0x3f, CX		
  0x401171		4921c8			ANDQ CX, R8		
  0x401174		4a8d0c06		LEAQ 0(SI)(R8*1), CX	
		case "on":
  0x401178		4983f902		CMPQ $0x2, R9		
  0x40117c		0f85f6010000		JNE 0x401378		
  0x401182		460fb71406		MOVZX 0(SI)(R8*1), R10	
  0x401187		664181fa6f6e		CMPW $0x6e6f, R10	
  0x40118d		0f85e5010000		JNE 0x401378		
  0x401193		b901000000		MOVL $0x1, CX		
		if key == "all" {
  0x401198		4883f807		CMPQ $0x7, AX		
  0x40119c		0f859b000000		JNE 0x40123d		
  0x4011a2		0fb70416		MOVZX 0(SI)(DX*1), AX	
  0x4011a6		663d616c		CMPW $0x6c61, AX	
  0x4011aa		0f858d000000		JNE 0x40123d		
  0x4011b0		0fb6441602		MOVZX 0x2(SI)(DX*1), AX	
  0x4011b5		3c6c			CMPL $0x6c, AL		
  0x4011b7		0f8580000000		JNE 0x40123d		
			for i := range options {
  0x4011bd		488b0524080c00		MOVQ internal/cpu.options+8(SB), AX	
  0x4011c4		31d2			XORL DX, DX				
  0x4011c6		eb08			JMP 0x4011d0				
				options[i].Enable = enable || options[i].Required
  0x4011c8		885c1719		MOVB BL, 0x19(DI)(DX*1)	
			for i := range options {
  0x4011cc		488d5601		LEAQ 0x1(SI), DX	
  0x4011d0		4839c2			CMPQ AX, DX		
  0x4011d3		7d59			JGE 0x40122e		
				options[i].Specified = true
  0x4011d5		488b1d04080c00		MOVQ internal/cpu.options(SB), BX	
  0x4011dc		48391505080c00		CMPQ DX, internal/cpu.options+8(SB)	
  0x4011e3		0f86d8040000		JBE 0x4016c1				
  0x4011e9		4889d6			MOVQ DX, SI				
  0x4011ec		48c1e205		SHLQ $0x5, DX				
  0x4011f0		c644131801		MOVB $0x1, 0x18(BX)(DX*1)		
				options[i].Enable = enable
  0x4011f5		84c9			TESTL CL, CL		
				options[i].Enable = enable || options[i].Required
  0x4011f7		741a			JE 0x401213				
  0x4011f9		bb01000000		MOVL $0x1, BX				
  0x4011fe		488b3ddb070c00		MOVQ internal/cpu.options(SB), DI	
  0x401205		483935dc070c00		CMPQ SI, internal/cpu.options+8(SB)	
  0x40120c		77ba			JA 0x4011c8				
  0x40120e		e9a7040000		JMP 0x4016ba				
  0x401213		488b1dc6070c00		MOVQ internal/cpu.options(SB), BX	
  0x40121a		483935c7070c00		CMPQ SI, internal/cpu.options+8(SB)	
  0x401221		0f8693040000		JBE 0x4016ba				
  0x401227		0fb65c131a		MOVZX 0x1a(BX)(DX*1), BX		
  0x40122c		ebd0			JMP 0x4011fe				
	for env != "" {
  0x40122e		488b442478		MOVQ 0x78(SP), AX	
  0x401233		488b4c2450		MOVQ 0x50(SP), CX	
			continue field
  0x401238		e954feffff		JMP 0x401091		
				options[i].Enable = enable
  0x40123d		884c2427		MOVB CL, 0x27(SP)	
		for i := range options {
  0x401241		488b05a0070c00		MOVQ internal/cpu.options+8(SB), AX	
  0x401248		4889442440		MOVQ AX, 0x40(SP)			
  0x40124d		31d2			XORL DX, DX				
  0x40124f		eb04			JMP 0x401255				
  0x401251		498d5001		LEAQ 0x1(R8), DX			
  0x401255		4839c2			CMPQ AX, DX				
  0x401258		0f8db7000000		JGE 0x401315				
			if options[i].Name == key {
  0x40125e		488b357b070c00		MOVQ internal/cpu.options(SB), SI	
  0x401265		4839157c070c00		CMPQ DX, internal/cpu.options+8(SB)	
  0x40126c		0f8641040000		JBE 0x4016b3				
  0x401272		4989d0			MOVQ DX, R8				
  0x401275		48c1e205		SHLQ $0x5, DX				
  0x401279		4c8b4c1608		MOVQ 0x8(SI)(DX*1), R9			
  0x40127e		488b3416		MOVQ 0(SI)(DX*1), SI			
  0x401282		4939d9			CMPQ BX, R9				
  0x401285		75ca			JNE 0x401251				
  0x401287		4889542438		MOVQ DX, 0x38(SP)			
		for i := range options {
  0x40128c		4c89442430		MOVQ R8, 0x30(SP)	
			if options[i].Name == key {
  0x401291		48893424		MOVQ SI, 0(SP)			
  0x401295		48897c2408		MOVQ DI, 0x8(SP)		
  0x40129a		4c894c2410		MOVQ R9, 0x10(SP)		
  0x40129f		e87c0f0000		CALL runtime.memequal(SB)	
  0x4012a4		807c241800		CMPB $0x0, 0x18(SP)		
  0x4012a9		751b			JNE 0x4012c6			
		for i := range options {
  0x4012ab		488b442440		MOVQ 0x40(SP), AX	
				options[i].Enable = enable
  0x4012b0		0fb64c2427		MOVZX 0x27(SP), CX	
			if options[i].Name == key {
  0x4012b5		488b5c2448		MOVQ 0x48(SP), BX	
  0x4012ba		488b7c2460		MOVQ 0x60(SP), DI	
		for i := range options {
  0x4012bf		4c8b442430		MOVQ 0x30(SP), R8	
			if options[i].Name == key {
  0x4012c4		eb8b			JMP 0x401251		
				options[i].Specified = true
  0x4012c6		488b0513070c00		MOVQ internal/cpu.options(SB), AX	
  0x4012cd		488b4c2430		MOVQ 0x30(SP), CX			
  0x4012d2		48390d0f070c00		CMPQ CX, internal/cpu.options+8(SB)	
  0x4012d9		0f86cd030000		JBE 0x4016ac				
  0x4012df		488b542438		MOVQ 0x38(SP), DX			
  0x4012e4		c644101801		MOVB $0x1, 0x18(AX)(DX*1)		
				options[i].Enable = enable
  0x4012e9		488b05f0060c00		MOVQ internal/cpu.options(SB), AX	
  0x4012f0		48390df1060c00		CMPQ CX, internal/cpu.options+8(SB)	
  0x4012f7		0f86a8030000		JBE 0x4016a5				
  0x4012fd		0fb65c2427		MOVZX 0x27(SP), BX			
  0x401302		885c1019		MOVB BL, 0x19(AX)(DX*1)			
	for env != "" {
  0x401306		488b442478		MOVQ 0x78(SP), AX	
  0x40130b		488b4c2450		MOVQ 0x50(SP), CX	
				continue field
  0x401310		e97cfdffff		JMP 0x401091		
		print("GODEBUG: unknown cpu feature \"", key, "\"\n")
  0x401315		e8a62b0200		CALL runtime.printlock(SB)	
  0x40131a		488d0581070700		LEAQ 0x70781(IP), AX		
  0x401321		48890424		MOVQ AX, 0(SP)			
  0x401325		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x40132e		e8bd340200		CALL runtime.printstring(SB)	
  0x401333		488b442460		MOVQ 0x60(SP), AX		
  0x401338		48890424		MOVQ AX, 0(SP)			
  0x40133c		488b442448		MOVQ 0x48(SP), AX		
  0x401341		4889442408		MOVQ AX, 0x8(SP)		
  0x401346		e8a5340200		CALL runtime.printstring(SB)	
  0x40134b		488d0552dd0600		LEAQ 0x6dd52(IP), AX		
  0x401352		48890424		MOVQ AX, 0(SP)			
  0x401356		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40135f		e88c340200		CALL runtime.printstring(SB)	
  0x401364		e8d72b0200		CALL runtime.printunlock(SB)	
	for env != "" {
  0x401369		488b442478		MOVQ 0x78(SP), AX	
  0x40136e		488b4c2450		MOVQ 0x50(SP), CX	
		print("GODEBUG: unknown cpu feature \"", key, "\"\n")
  0x401373		e919fdffff		JMP 0x401091		
		key, value := field[4:i], field[i+1:] // e.g. "SSE2", "on"
  0x401378		4c894c2440		MOVQ R9, 0x40(SP)	
  0x40137d		48894c2458		MOVQ CX, 0x58(SP)	
		case "off":
  0x401382		4983f903		CMPQ $0x3, R9		
  0x401386		7520			JNE 0x4013a8		
  0x401388		460fb71406		MOVZX 0(SI)(R8*1), R10	
  0x40138d		664181fa6f66		CMPW $0x666f, R10	
  0x401393		7513			JNE 0x4013a8		
  0x401395		460fb6440602		MOVZX 0x2(SI)(R8*1), R8	
  0x40139b		4180f866		CMPL $0x66, R8		
  0x40139f		7507			JNE 0x4013a8		
  0x4013a1		31c9			XORL CX, CX		
		switch value {
  0x4013a3		e9f0fdffff		JMP 0x401198		
			print("GODEBUG: value \"", value, "\" not supported for cpu option \"", key, "\"\n")
  0x4013a8		e8132b0200		CALL runtime.printlock(SB)	
  0x4013ad		488d05c3eb0600		LEAQ 0x6ebc3(IP), AX		
  0x4013b4		48890424		MOVQ AX, 0(SP)			
  0x4013b8		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4013c1		e82a340200		CALL runtime.printstring(SB)	
  0x4013c6		488b442458		MOVQ 0x58(SP), AX		
  0x4013cb		48890424		MOVQ AX, 0(SP)			
  0x4013cf		488b442440		MOVQ 0x40(SP), AX		
  0x4013d4		4889442408		MOVQ AX, 0x8(SP)		
  0x4013d9		e812340200		CALL runtime.printstring(SB)	
  0x4013de		488d05ec0a0700		LEAQ 0x70aec(IP), AX		
  0x4013e5		48890424		MOVQ AX, 0(SP)			
  0x4013e9		48c744240820000000	MOVQ $0x20, 0x8(SP)		
  0x4013f2		e8f9330200		CALL runtime.printstring(SB)	
  0x4013f7		488b442460		MOVQ 0x60(SP), AX		
  0x4013fc		48890424		MOVQ AX, 0(SP)			
  0x401400		488b442448		MOVQ 0x48(SP), AX		
  0x401405		4889442408		MOVQ AX, 0x8(SP)		
  0x40140a		e8e1330200		CALL runtime.printstring(SB)	
  0x40140f		488d058edc0600		LEAQ 0x6dc8e(IP), AX		
  0x401416		48890424		MOVQ AX, 0(SP)			
  0x40141a		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x401423		e8c8330200		CALL runtime.printstring(SB)	
  0x401428		e8132b0200		CALL runtime.printunlock(SB)	
	for env != "" {
  0x40142d		488b442478		MOVQ 0x78(SP), AX	
  0x401432		488b4c2450		MOVQ 0x50(SP), CX	
			continue field
  0x401437		e955fcffff		JMP 0x401091		
			print("GODEBUG: no value specified for \"", field, "\"\n")
  0x40143c		e87f2a0200		CALL runtime.printlock(SB)	
  0x401441		488d05090c0700		LEAQ 0x70c09(IP), AX		
  0x401448		48890424		MOVQ AX, 0(SP)			
  0x40144c		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x401455		e896330200		CALL runtime.printstring(SB)	
  0x40145a		488b442468		MOVQ 0x68(SP), AX		
  0x40145f		48890424		MOVQ AX, 0(SP)			
  0x401463		488b442428		MOVQ 0x28(SP), AX		
  0x401468		4889442408		MOVQ AX, 0x8(SP)		
  0x40146d		e87e330200		CALL runtime.printstring(SB)	
  0x401472		488d052bdc0600		LEAQ 0x6dc2b(IP), AX		
  0x401479		48890424		MOVQ AX, 0(SP)			
  0x40147d		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x401486		e865330200		CALL runtime.printstring(SB)	
  0x40148b		e8b02a0200		CALL runtime.printunlock(SB)	
	for env != "" {
  0x401490		488b442478		MOVQ 0x78(SP), AX	
  0x401495		488b4c2450		MOVQ 0x50(SP), CX	
			continue
  0x40149a		e9f2fbffff		JMP 0x401091		
			field, env = env[:i], env[i+1:]
  0x40149f		488b4c2428		MOVQ 0x28(SP), CX	
  0x4014a4		4839c8			CMPQ CX, AX		
  0x4014a7		0f8722020000		JA 0x4016cf		
  0x4014ad		488d5001		LEAQ 0x1(AX), DX	
  0x4014b1		4839ca			CMPQ CX, DX		
  0x4014b4		0f8715020000		JA 0x4016cf		
  0x4014ba		4829d1			SUBQ DX, CX		
  0x4014bd		4889cb			MOVQ CX, BX		
  0x4014c0		48f7d9			NEGQ CX			
  0x4014c3		48c1f93f		SARQ $0x3f, CX		
  0x4014c7		4821ca			ANDQ CX, DX		
  0x4014ca		488b742468		MOVQ 0x68(SP), SI	
  0x4014cf		488d3c16		LEAQ 0(SI)(DX*1), DI	
	for env != "" {
  0x4014d3		4889d9			MOVQ BX, CX		
		if len(field) < 4 || field[:4] != "cpu." {
  0x4014d6		4889c2			MOVQ AX, DX		
	for env != "" {
  0x4014d9		4889f8			MOVQ DI, AX		
			field, env = env[:i], env[i+1:]
  0x4014dc		e9f6fbffff		JMP 0x4010d7		
	for _, o := range options {
  0x4014e1		488b0500050c00		MOVQ internal/cpu.options+8(SB), AX	
  0x4014e8		488b0df1040c00		MOVQ internal/cpu.options(SB), CX	
  0x4014ef		4885c0			TESTQ AX, AX				
  0x4014f2		0f8e8f000000		JLE 0x401587				
  0x4014f8		4889442450		MOVQ AX, 0x50(SP)			
  0x4014fd		31d2			XORL DX, DX				
  0x4014ff		eb04			JMP 0x401505				
  0x401501		4883c120		ADDQ $0x20, CX				
  0x401505		0f1001			MOVUPS 0(CX), X0			
  0x401508		0f118424a0000000	MOVUPS X0, 0xa0(SP)			
  0x401510		0f104110		MOVUPS 0x10(CX), X0			
  0x401514		0f118424b0000000	MOVUPS X0, 0xb0(SP)			
  0x40151c		0f108424a0000000	MOVUPS 0xa0(SP), X0			
  0x401524		0f11842480000000	MOVUPS X0, 0x80(SP)			
  0x40152c		0f108424b0000000	MOVUPS 0xb0(SP), X0			
  0x401534		0f11842490000000	MOVUPS X0, 0x90(SP)			
		if !o.Specified {
  0x40153c		80bc249800000000	CMPB $0x0, 0x98(SP)	
  0x401544		7435			JE 0x40157b		
	for _, o := range options {
  0x401546		48894c2470		MOVQ CX, 0x70(SP)	
  0x40154b		4889542448		MOVQ DX, 0x48(SP)	
		if o.Enable && !*o.Feature {
  0x401550		0fb69c2499000000	MOVZX 0x99(SP), BX	
  0x401558		84db			TESTL BL, BL		
  0x40155a		7413			JE 0x40156f		
  0x40155c		488bb42490000000	MOVQ 0x90(SP), SI	
  0x401564		803e00			CMPB $0x0, 0(SI)	
  0x401567		0f84b6000000		JE 0x401623		
  0x40156d		84db			TESTL BL, BL		
		if !o.Enable && o.Required {
  0x40156f		7426			JE 0x401597		
		*o.Feature = o.Enable
  0x401571		488bb42490000000	MOVQ 0x90(SP), SI	
  0x401579		881e			MOVB BL, 0(SI)		
	for _, o := range options {
  0x40157b		48ffc2			INCQ DX			
  0x40157e		4839c2			CMPQ AX, DX		
  0x401581		0f8c7affffff		JL 0x401501		
  0x401587		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x40158f		4881c4c8000000		ADDQ $0xc8, SP		
  0x401596		c3			RET			
		if !o.Enable && o.Required {
  0x401597		80bc249a00000000	CMPB $0x0, 0x9a(SP)	
  0x40159f		74d0			JE 0x401571		
			print("GODEBUG: can not disable \"", o.Name, "\", required CPU feature\n")
  0x4015a1		488b842488000000	MOVQ 0x88(SP), AX		
  0x4015a9		4889442440		MOVQ AX, 0x40(SP)		
  0x4015ae		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x4015b6		48894c2478		MOVQ CX, 0x78(SP)		
  0x4015bb		e800290200		CALL runtime.printlock(SB)	
  0x4015c0		488d05c9fb0600		LEAQ 0x6fbc9(IP), AX		
  0x4015c7		48890424		MOVQ AX, 0(SP)			
  0x4015cb		48c74424081a000000	MOVQ $0x1a, 0x8(SP)		
  0x4015d4		e817320200		CALL runtime.printstring(SB)	
  0x4015d9		488b442478		MOVQ 0x78(SP), AX		
  0x4015de		48890424		MOVQ AX, 0(SP)			
  0x4015e2		488b442440		MOVQ 0x40(SP), AX		
  0x4015e7		4889442408		MOVQ AX, 0x8(SP)		
  0x4015ec		e8ff310200		CALL runtime.printstring(SB)	
  0x4015f1		488d050af80600		LEAQ 0x6f80a(IP), AX		
  0x4015f8		48890424		MOVQ AX, 0(SP)			
  0x4015fc		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x401605		e8e6310200		CALL runtime.printstring(SB)	
  0x40160a		e831290200		CALL runtime.printunlock(SB)	
	for _, o := range options {
  0x40160f		488b442450		MOVQ 0x50(SP), AX	
  0x401614		488b4c2470		MOVQ 0x70(SP), CX	
  0x401619		488b542448		MOVQ 0x48(SP), DX	
			continue
  0x40161e		e958ffffff		JMP 0x40157b		
			print("GODEBUG: can not enable \"", o.Name, "\", missing CPU support\n")
  0x401623		488b842488000000	MOVQ 0x88(SP), AX		
  0x40162b		4889442440		MOVQ AX, 0x40(SP)		
  0x401630		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x401638		48894c2478		MOVQ CX, 0x78(SP)		
  0x40163d		e87e280200		CALL runtime.printlock(SB)	
  0x401642		488d053af90600		LEAQ 0x6f93a(IP), AX		
  0x401649		48890424		MOVQ AX, 0(SP)			
  0x40164d		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x401656		e895310200		CALL runtime.printstring(SB)	
  0x40165b		488b442478		MOVQ 0x78(SP), AX		
  0x401660		48890424		MOVQ AX, 0(SP)			
  0x401664		488b442440		MOVQ 0x40(SP), AX		
  0x401669		4889442408		MOVQ AX, 0x8(SP)		
  0x40166e		e87d310200		CALL runtime.printstring(SB)	
  0x401673		488d0549f50600		LEAQ 0x6f549(IP), AX		
  0x40167a		48890424		MOVQ AX, 0(SP)			
  0x40167e		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x401687		e864310200		CALL runtime.printstring(SB)	
  0x40168c		e8af280200		CALL runtime.printunlock(SB)	
	for _, o := range options {
  0x401691		488b442450		MOVQ 0x50(SP), AX	
  0x401696		488b4c2470		MOVQ 0x70(SP), CX	
  0x40169b		488b542448		MOVQ 0x48(SP), DX	
			continue
  0x4016a0		e9d6feffff		JMP 0x40157b		
				options[i].Enable = enable
  0x4016a5		e876080200		CALL runtime.panicindex(SB)	
  0x4016aa		0f0b			UD2				
				options[i].Specified = true
  0x4016ac		e86f080200		CALL runtime.panicindex(SB)	
  0x4016b1		0f0b			UD2				
			if options[i].Name == key {
  0x4016b3		e868080200		CALL runtime.panicindex(SB)	
  0x4016b8		0f0b			UD2				
				options[i].Enable = enable || options[i].Required
  0x4016ba		e861080200		CALL runtime.panicindex(SB)	
  0x4016bf		0f0b			UD2				
				options[i].Specified = true
  0x4016c1		e85a080200		CALL runtime.panicindex(SB)	
  0x4016c6		0f0b			UD2				
		key, value := field[4:i], field[i+1:] // e.g. "SSE2", "on"
  0x4016c8		e883090200		CALL runtime.panicslice(SB)	
  0x4016cd		0f0b			UD2				
			field, env = env[:i], env[i+1:]
  0x4016cf		e87c090200		CALL runtime.panicslice(SB)	
  0x4016d4		0f0b			UD2				
func processOptions(env string) {
  0x4016d6		e8a5610400		CALL runtime.morestack_noctxt(SB)	
  0x4016db		e970f9ffff		JMP internal/cpu.processOptions(SB)	

TEXT internal/cpu.indexByte(SB) /usr/local/go/src/internal/cpu/cpu.go
	for i := 0; i < len(s); i++ {
  0x4016e0		488b442410		MOVQ 0x10(SP), AX	
  0x4016e5		0fb64c2418		MOVZX 0x18(SP), CX	
  0x4016ea		488b542408		MOVQ 0x8(SP), DX	
  0x4016ef		31db			XORL BX, BX		
  0x4016f1		eb03			JMP 0x4016f6		
  0x4016f3		48ffc3			INCQ BX			
  0x4016f6		4839c3			CMPQ AX, BX		
  0x4016f9		7d0f			JGE 0x40170a		
		if s[i] == c {
  0x4016fb		0fb6341a		MOVZX 0(DX)(BX*1), SI	
  0x4016ff		4038ce			CMPL CL, SI		
  0x401702		75ef			JNE 0x4016f3		
			return i
  0x401704		48895c2420		MOVQ BX, 0x20(SP)	
  0x401709		c3			RET			
	return -1
  0x40170a		48c7442420ffffffff	MOVQ $-0x1, 0x20(SP)	
  0x401713		c3			RET			

TEXT internal/cpu.doinit(SB) /usr/local/go/src/internal/cpu/cpu_x86.go
func doinit() {
  0x401720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x401729		483b6110		CMPQ 0x10(CX), SP	
  0x40172d		0f86e3030000		JBE 0x401b16		
  0x401733		4883ec38		SUBQ $0x38, SP		
  0x401737		48896c2430		MOVQ BP, 0x30(SP)	
  0x40173c		488d6c2430		LEAQ 0x30(SP), BP	
		{Name: "sse2", Feature: &X86.HasSSE2, Required: GOARCH == "amd64" || GOARCH == "amd64p32"},
  0x401741		488d05b8a30500		LEAQ 0x5a3b8(IP), AX			
  0x401748		48890424		MOVQ AX, 0(SP)				
  0x40174c		e8ff8f0000		CALL runtime.newobject(SB)		
  0x401751		488b7c2408		MOVQ 0x8(SP), DI			
  0x401756		48897c2428		MOVQ DI, 0x28(SP)			
  0x40175b		488d351ecc0700		LEAQ internal/cpu.statictmp_0(SB), SI	
  0x401762		48896c24f0		MOVQ BP, -0x10(SP)			
  0x401767		488d6c24f0		LEAQ -0x10(SP), BP			
  0x40176c		e89b8b0400		CALL 0x44a30c				
  0x401771		488b6d00		MOVQ 0(BP), BP				
		{Name: "adx", Feature: &X86.HasADX},
  0x401775		833da4b60d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40177c		0f8576020000		JNE 0x4019f8				
  0x401782		488d0df8b80d00		LEAQ internal/cpu.X86+65(SB), CX	
  0x401789		488b442428		MOVQ 0x28(SP), AX			
  0x40178e		48894810		MOVQ CX, 0x10(AX)			
		{Name: "aes", Feature: &X86.HasAES},
  0x401792		488d0de7b80d00		LEAQ internal/cpu.X86+64(SB), CX	
  0x401799		48894830		MOVQ CX, 0x30(AX)			
		{Name: "avx", Feature: &X86.HasAVX},
  0x40179d		488d0ddeb80d00		LEAQ internal/cpu.X86+66(SB), CX	
  0x4017a4		48894850		MOVQ CX, 0x50(AX)			
		{Name: "avx2", Feature: &X86.HasAVX2},
  0x4017a8		488d0dd4b80d00		LEAQ internal/cpu.X86+67(SB), CX	
  0x4017af		48894870		MOVQ CX, 0x70(AX)			
		{Name: "bmi1", Feature: &X86.HasBMI1},
  0x4017b3		488d0dcab80d00		LEAQ internal/cpu.X86+68(SB), CX	
  0x4017ba		48898890000000		MOVQ CX, 0x90(AX)			
		{Name: "bmi2", Feature: &X86.HasBMI2},
  0x4017c1		488d0dbdb80d00		LEAQ internal/cpu.X86+69(SB), CX	
  0x4017c8		488988b0000000		MOVQ CX, 0xb0(AX)			
		{Name: "erms", Feature: &X86.HasERMS},
  0x4017cf		488d0db0b80d00		LEAQ internal/cpu.X86+70(SB), CX	
  0x4017d6		488988d0000000		MOVQ CX, 0xd0(AX)			
		{Name: "fma", Feature: &X86.HasFMA},
  0x4017dd		488d0da3b80d00		LEAQ internal/cpu.X86+71(SB), CX	
  0x4017e4		488988f0000000		MOVQ CX, 0xf0(AX)			
		{Name: "pclmulqdq", Feature: &X86.HasPCLMULQDQ},
  0x4017eb		488d0d97b80d00		LEAQ internal/cpu.X86+73(SB), CX	
  0x4017f2		48898810010000		MOVQ CX, 0x110(AX)			
		{Name: "popcnt", Feature: &X86.HasPOPCNT},
  0x4017f9		488d0d8ab80d00		LEAQ internal/cpu.X86+74(SB), CX	
  0x401800		48898830010000		MOVQ CX, 0x130(AX)			
		{Name: "sse3", Feature: &X86.HasSSE3},
  0x401807		488d0d7eb80d00		LEAQ internal/cpu.X86+76(SB), CX	
  0x40180e		48898850010000		MOVQ CX, 0x150(AX)			
		{Name: "sse41", Feature: &X86.HasSSE41},
  0x401815		488d0d72b80d00		LEAQ internal/cpu.X86+78(SB), CX	
  0x40181c		48898870010000		MOVQ CX, 0x170(AX)			
		{Name: "sse42", Feature: &X86.HasSSE42},
  0x401823		488d0d65b80d00		LEAQ internal/cpu.X86+79(SB), CX	
  0x40182a		48898890010000		MOVQ CX, 0x190(AX)			
		{Name: "ssse3", Feature: &X86.HasSSSE3},
  0x401831		488d0d55b80d00		LEAQ internal/cpu.X86+77(SB), CX	
  0x401838		488988b0010000		MOVQ CX, 0x1b0(AX)			
		{Name: "sse2", Feature: &X86.HasSSE2, Required: GOARCH == "amd64" || GOARCH == "amd64p32"},
  0x40183f		488d0d45b80d00		LEAQ internal/cpu.X86+75(SB), CX	
  0x401846		488988d0010000		MOVQ CX, 0x1d0(AX)			
	options = []option{
  0x40184d		48c70590010c000f000000	MOVQ $0xf, internal/cpu.options+8(SB)	
  0x401858		48c7058d010c000f000000	MOVQ $0xf, internal/cpu.options+16(SB)	
  0x401863		833db6b50d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40186a		0f8577010000		JNE 0x4019e7				
  0x401870		48890569010c00		MOVQ AX, internal/cpu.options(SB)	
	maxID, _, _, _ := cpuid(0, 0)
  0x401877		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x40187f		e89c020000		CALL internal/cpu.cpuid(SB)	
  0x401884		8b442408		MOVL 0x8(SP), AX		
	if maxID < 1 {
  0x401888		83f801			CMPL $0x1, AX		
  0x40188b		0f824c010000		JB 0x4019dd		
	maxID, _, _, _ := cpuid(0, 0)
  0x401891		89442420		MOVL AX, 0x20(SP)	
	_, _, ecx1, edx1 := cpuid(1, 0)
  0x401895		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x40189d		e87e020000		CALL internal/cpu.cpuid(SB)	
  0x4018a2		8b442410		MOVL 0x10(SP), AX		
  0x4018a6		8b4c2414		MOVL 0x14(SP), CX		
	X86.HasSSE2 = isSet(edx1, cpuid_SSE2)
  0x4018aa		90			NOPL			
	return hwc&value != 0
  0x4018ab		0fbae11a		BTL $0x1a, CX		
	X86.HasSSE2 = isSet(edx1, cpuid_SSE2)
  0x4018af		0f9205d5b70d00		SETB internal/cpu.X86+75(SB)	
	X86.HasSSE3 = isSet(ecx1, cpuid_SSE3)
  0x4018b6		90			NOPL			
	return hwc&value != 0
  0x4018b7		0fbae000		BTL $0x0, AX		
	X86.HasSSE3 = isSet(ecx1, cpuid_SSE3)
  0x4018bb		0f9205cab70d00		SETB internal/cpu.X86+76(SB)	
	X86.HasPCLMULQDQ = isSet(ecx1, cpuid_PCLMULQDQ)
  0x4018c2		90			NOPL			
	return hwc&value != 0
  0x4018c3		0fbae001		BTL $0x1, AX		
	X86.HasPCLMULQDQ = isSet(ecx1, cpuid_PCLMULQDQ)
  0x4018c7		0f9205bbb70d00		SETB internal/cpu.X86+73(SB)	
	X86.HasSSSE3 = isSet(ecx1, cpuid_SSSE3)
  0x4018ce		90			NOPL			
	return hwc&value != 0
  0x4018cf		0fbae009		BTL $0x9, AX		
	X86.HasSSSE3 = isSet(ecx1, cpuid_SSSE3)
  0x4018d3		0f9205b3b70d00		SETB internal/cpu.X86+77(SB)	
	X86.HasFMA = isSet(ecx1, cpuid_FMA)
  0x4018da		90			NOPL			
	return hwc&value != 0
  0x4018db		0fbae00c		BTL $0xc, AX		
	X86.HasFMA = isSet(ecx1, cpuid_FMA)
  0x4018df		0f9205a1b70d00		SETB internal/cpu.X86+71(SB)	
	X86.HasSSE41 = isSet(ecx1, cpuid_SSE41)
  0x4018e6		90			NOPL			
	return hwc&value != 0
  0x4018e7		0fbae013		BTL $0x13, AX		
	X86.HasSSE41 = isSet(ecx1, cpuid_SSE41)
  0x4018eb		0f92059cb70d00		SETB internal/cpu.X86+78(SB)	
	X86.HasSSE42 = isSet(ecx1, cpuid_SSE42)
  0x4018f2		90			NOPL			
	return hwc&value != 0
  0x4018f3		0fbae014		BTL $0x14, AX		
	X86.HasSSE42 = isSet(ecx1, cpuid_SSE42)
  0x4018f7		0f920591b70d00		SETB internal/cpu.X86+79(SB)	
	X86.HasPOPCNT = isSet(ecx1, cpuid_POPCNT)
  0x4018fe		90			NOPL			
	return hwc&value != 0
  0x4018ff		0fbae017		BTL $0x17, AX		
	X86.HasPOPCNT = isSet(ecx1, cpuid_POPCNT)
  0x401903		0f920580b70d00		SETB internal/cpu.X86+74(SB)	
	X86.HasAES = isSet(ecx1, cpuid_AES)
  0x40190a		90			NOPL				
  0x40190b		0fbae019		BTL $0x19, AX			
  0x40190f		0f92056ab70d00		SETB internal/cpu.X86+64(SB)	
	X86.HasOSXSAVE = isSet(ecx1, cpuid_OSXSAVE)
  0x401916		90			NOPL			
	return hwc&value != 0
  0x401917		0fbae01b		BTL $0x1b, AX		
  0x40191b		0f92c1			SETB CL			
	X86.HasOSXSAVE = isSet(ecx1, cpuid_OSXSAVE)
  0x40191e		880d64b70d00		MOVB CL, internal/cpu.X86+72(SB)	
	if X86.HasOSXSAVE {
  0x401924		0f8289000000		JB 0x4019b3		
  0x40192a		31c9			XORL CX, CX		
	return hwc&value != 0
  0x40192c		0fbae01c		BTL $0x1c, AX		
  0x401930		0f92c0			SETB AL			
	X86.HasAVX = isSet(ecx1, cpuid_AVX) && osSupportsAVX
  0x401933		21c8			ANDL CX, AX				
  0x401935		90			NOPL					
  0x401936		880546b70d00		MOVB AL, internal/cpu.X86+66(SB)	
	if maxID < 7 {
  0x40193c		8b442420		MOVL 0x20(SP), AX	
  0x401940		83f807			CMPL $0x7, AX		
  0x401943		730a			JAE 0x40194f		
		return
  0x401945		488b6c2430		MOVQ 0x30(SP), BP	
  0x40194a		4883c438		ADDQ $0x38, SP		
  0x40194e		c3			RET			
	X86.HasAVX2 = isSet(ebx7, cpuid_AVX2) && osSupportsAVX
  0x40194f		884c241f		MOVB CL, 0x1f(SP)	
	_, ebx7, _, _ := cpuid(7, 0)
  0x401953		48c7042407000000	MOVQ $0x7, 0(SP)		
  0x40195b		e8c0010000		CALL internal/cpu.cpuid(SB)	
  0x401960		8b44240c		MOVL 0xc(SP), AX		
	X86.HasBMI1 = isSet(ebx7, cpuid_BMI1)
  0x401964		90			NOPL			
	return hwc&value != 0
  0x401965		0fbae003		BTL $0x3, AX		
	X86.HasBMI1 = isSet(ebx7, cpuid_BMI1)
  0x401969		0f920514b70d00		SETB internal/cpu.X86+68(SB)	
	return hwc&value != 0
  0x401970		0fbae005		BTL $0x5, AX		
  0x401974		0f92c1			SETB CL			
	X86.HasAVX2 = isSet(ebx7, cpuid_AVX2) && osSupportsAVX
  0x401977		0fb654241f		MOVZX 0x1f(SP), DX			
  0x40197c		21ca			ANDL CX, DX				
  0x40197e		90			NOPL					
  0x40197f		8815feb60d00		MOVB DL, internal/cpu.X86+67(SB)	
	X86.HasBMI2 = isSet(ebx7, cpuid_BMI2)
  0x401985		90			NOPL			
	return hwc&value != 0
  0x401986		0fbae008		BTL $0x8, AX		
	X86.HasBMI2 = isSet(ebx7, cpuid_BMI2)
  0x40198a		0f9205f4b60d00		SETB internal/cpu.X86+69(SB)	
	X86.HasERMS = isSet(ebx7, cpuid_ERMS)
  0x401991		90			NOPL				
  0x401992		0fbae009		BTL $0x9, AX			
  0x401996		0f9205e9b60d00		SETB internal/cpu.X86+70(SB)	
	X86.HasADX = isSet(ebx7, cpuid_ADX)
  0x40199d		90			NOPL				
  0x40199e		0fbae013		BTL $0x13, AX			
  0x4019a2		0f9205d8b60d00		SETB internal/cpu.X86+65(SB)	
}
  0x4019a9		488b6c2430		MOVQ 0x30(SP), BP	
  0x4019ae		4883c438		ADDQ $0x38, SP		
  0x4019b2		c3			RET			
	_, _, ecx1, edx1 := cpuid(1, 0)
  0x4019b3		89442424		MOVL AX, 0x24(SP)	
		eax, _ := xgetbv()
  0x4019b7		e884010000		CALL internal/cpu.xgetbv(SB)	
  0x4019bc		8b0424			MOVL 0(SP), AX			
		osSupportsAVX = isSet(eax, 1<<1) && isSet(eax, 1<<2)
  0x4019bf		90			NOPL			
	return hwc&value != 0
  0x4019c0		0fbae001		BTL $0x1, AX		
		osSupportsAVX = isSet(eax, 1<<1) && isSet(eax, 1<<2)
  0x4019c4		7313			JAE 0x4019d9		
	return hwc&value != 0
  0x4019c6		0fbae002		BTL $0x2, AX		
  0x4019ca		0f92c0			SETB AL			
		osSupportsAVX = isSet(eax, 1<<1) && isSet(eax, 1<<2)
  0x4019cd		90			NOPL			
	X86.HasAVX2 = isSet(ebx7, cpuid_AVX2) && osSupportsAVX
  0x4019ce		89c1			MOVL AX, CX		
	return hwc&value != 0
  0x4019d0		8b442424		MOVL 0x24(SP), AX	
		osSupportsAVX = isSet(eax, 1<<1) && isSet(eax, 1<<2)
  0x4019d4		e953ffffff		JMP 0x40192c		
  0x4019d9		31c0			XORL AX, AX		
  0x4019db		ebf1			JMP 0x4019ce		
		return
  0x4019dd		488b6c2430		MOVQ 0x30(SP), BP	
  0x4019e2		4883c438		ADDQ $0x38, SP		
  0x4019e6		c3			RET			
	options = []option{
  0x4019e7		488d3df2ff0b00		LEAQ internal/cpu.options(SB), DI	
  0x4019ee		e88d7c0400		CALL runtime.gcWriteBarrier(SB)		
  0x4019f3		e97ffeffff		JMP 0x401877				
		{Name: "adx", Feature: &X86.HasADX},
  0x4019f8		488b4c2428		MOVQ 0x28(SP), CX			
  0x4019fd		488d7910		LEAQ 0x10(CX), DI			
  0x401a01		488d0579b60d00		LEAQ internal/cpu.X86+65(SB), AX	
  0x401a08		e8737c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "aes", Feature: &X86.HasAES},
  0x401a0d		488d7930		LEAQ 0x30(CX), DI			
  0x401a11		488d0568b60d00		LEAQ internal/cpu.X86+64(SB), AX	
  0x401a18		e8637c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "avx", Feature: &X86.HasAVX},
  0x401a1d		488d7950		LEAQ 0x50(CX), DI			
  0x401a21		488d055ab60d00		LEAQ internal/cpu.X86+66(SB), AX	
  0x401a28		e8537c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "avx2", Feature: &X86.HasAVX2},
  0x401a2d		488d7970		LEAQ 0x70(CX), DI			
  0x401a31		488d054bb60d00		LEAQ internal/cpu.X86+67(SB), AX	
  0x401a38		e8437c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "bmi1", Feature: &X86.HasBMI1},
  0x401a3d		488db990000000		LEAQ 0x90(CX), DI			
  0x401a44		488d0539b60d00		LEAQ internal/cpu.X86+68(SB), AX	
  0x401a4b		e8307c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "bmi2", Feature: &X86.HasBMI2},
  0x401a50		488db9b0000000		LEAQ 0xb0(CX), DI			
  0x401a57		488d0527b60d00		LEAQ internal/cpu.X86+69(SB), AX	
  0x401a5e		e81d7c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "erms", Feature: &X86.HasERMS},
  0x401a63		488db9d0000000		LEAQ 0xd0(CX), DI			
  0x401a6a		488d0515b60d00		LEAQ internal/cpu.X86+70(SB), AX	
  0x401a71		e80a7c0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "fma", Feature: &X86.HasFMA},
  0x401a76		488db9f0000000		LEAQ 0xf0(CX), DI			
  0x401a7d		488d0503b60d00		LEAQ internal/cpu.X86+71(SB), AX	
  0x401a84		e8f77b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "pclmulqdq", Feature: &X86.HasPCLMULQDQ},
  0x401a89		488db910010000		LEAQ 0x110(CX), DI			
  0x401a90		488d05f2b50d00		LEAQ internal/cpu.X86+73(SB), AX	
  0x401a97		e8e47b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "popcnt", Feature: &X86.HasPOPCNT},
  0x401a9c		488db930010000		LEAQ 0x130(CX), DI			
  0x401aa3		488d05e0b50d00		LEAQ internal/cpu.X86+74(SB), AX	
  0x401aaa		e8d17b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "sse3", Feature: &X86.HasSSE3},
  0x401aaf		488db950010000		LEAQ 0x150(CX), DI			
  0x401ab6		488d05cfb50d00		LEAQ internal/cpu.X86+76(SB), AX	
  0x401abd		e8be7b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "sse41", Feature: &X86.HasSSE41},
  0x401ac2		488db970010000		LEAQ 0x170(CX), DI			
  0x401ac9		488d05beb50d00		LEAQ internal/cpu.X86+78(SB), AX	
  0x401ad0		e8ab7b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "sse42", Feature: &X86.HasSSE42},
  0x401ad5		488db990010000		LEAQ 0x190(CX), DI			
  0x401adc		488d05acb50d00		LEAQ internal/cpu.X86+79(SB), AX	
  0x401ae3		e8987b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "ssse3", Feature: &X86.HasSSSE3},
  0x401ae8		488db9b0010000		LEAQ 0x1b0(CX), DI			
  0x401aef		488d0597b50d00		LEAQ internal/cpu.X86+77(SB), AX	
  0x401af6		e8857b0400		CALL runtime.gcWriteBarrier(SB)		
		{Name: "sse2", Feature: &X86.HasSSE2, Required: GOARCH == "amd64" || GOARCH == "amd64p32"},
  0x401afb		488db9d0010000		LEAQ 0x1d0(CX), DI			
  0x401b02		488d0582b50d00		LEAQ internal/cpu.X86+75(SB), AX	
  0x401b09		e8727b0400		CALL runtime.gcWriteBarrier(SB)		
	options = []option{
  0x401b0e		4889c8			MOVQ CX, AX		
		{Name: "adx", Feature: &X86.HasADX},
  0x401b11		e937fdffff		JMP 0x40184d		
func doinit() {
  0x401b16		e8655d0400		CALL runtime.morestack_noctxt(SB)	
  0x401b1b		e900fcffff		JMP internal/cpu.doinit(SB)		

TEXT internal/cpu.cpuid(SB) /usr/local/go/src/internal/cpu/cpu_x86.s

  0x401b20		8b442408		MOVL 0x8(SP), AX	

  0x401b24		8b4c240c		MOVL 0xc(SP), CX	

  0x401b28		0fa2			CPUID			

  0x401b2a		89442410		MOVL AX, 0x10(SP)	

  0x401b2e		895c2414		MOVL BX, 0x14(SP)	

  0x401b32		894c2418		MOVL CX, 0x18(SP)	

  0x401b36		8954241c		MOVL DX, 0x1c(SP)	

  0x401b3a		c3			RET			

TEXT internal/cpu.xgetbv(SB) /usr/local/go/src/internal/cpu/cpu_x86.s

  0x401b40		b900000000		MOVL $0x0, CX		

  0x401b45		0f01d0			XGETBV			

  0x401b48		89442408		MOVL AX, 0x8(SP)	

  0x401b4c		8954240c		MOVL DX, 0xc(SP)	

  0x401b50		c3			RET			

TEXT type..hash.internal/cpu.CacheLinePad(SB) <autogenerated>

  0x401b60		488b442410		MOVQ 0x10(SP), AX	
  0x401b65		4889442418		MOVQ AX, 0x18(SP)	
  0x401b6a		c3			RET			

TEXT type..eq.internal/cpu.CacheLinePad(SB) <autogenerated>

  0x401b70		c644241801		MOVB $0x1, 0x18(SP)	
  0x401b75		c3			RET			

TEXT type..hash.internal/cpu.arm64(SB) <autogenerated>

  0x401b80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401b89		483b6110		CMPQ 0x10(CX), SP			
  0x401b8d		7647			JBE 0x401bd6				
  0x401b8f		4883ec28		SUBQ $0x28, SP				
  0x401b93		48896c2420		MOVQ BP, 0x20(SP)			
  0x401b98		488d6c2420		LEAQ 0x20(SP), BP			
  0x401b9d		488b442430		MOVQ 0x30(SP), AX			
  0x401ba2		4883c040		ADDQ $0x40, AX				
  0x401ba6		48890424		MOVQ AX, 0(SP)				
  0x401baa		488b442438		MOVQ 0x38(SP), AX			
  0x401baf		4889442408		MOVQ AX, 0x8(SP)			
  0x401bb4		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x401bbd		e8fe560000		CALL runtime.memhash(SB)		
  0x401bc2		488b442418		MOVQ 0x18(SP), AX			
  0x401bc7		4889442440		MOVQ AX, 0x40(SP)			
  0x401bcc		488b6c2420		MOVQ 0x20(SP), BP			
  0x401bd1		4883c428		ADDQ $0x28, SP				
  0x401bd5		c3			RET					
  0x401bd6		e8a55c0400		CALL runtime.morestack_noctxt(SB)	
  0x401bdb		eba3			JMP type..hash.internal/cpu.arm64(SB)	

TEXT type..eq.internal/cpu.arm64(SB) <autogenerated>

  0x401be0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401be9		483b6110		CMPQ 0x10(CX), SP			
  0x401bed		764a			JBE 0x401c39				
  0x401bef		4883ec28		SUBQ $0x28, SP				
  0x401bf3		48896c2420		MOVQ BP, 0x20(SP)			
  0x401bf8		488d6c2420		LEAQ 0x20(SP), BP			
  0x401bfd		488b442430		MOVQ 0x30(SP), AX			
  0x401c02		4883c040		ADDQ $0x40, AX				
  0x401c06		48890424		MOVQ AX, 0(SP)				
  0x401c0a		488b442438		MOVQ 0x38(SP), AX			
  0x401c0f		4883c040		ADDQ $0x40, AX				
  0x401c13		4889442408		MOVQ AX, 0x8(SP)			
  0x401c18		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x401c21		e8fa050000		CALL runtime.memequal(SB)		
  0x401c26		0fb6442418		MOVZX 0x18(SP), AX			
  0x401c2b		88442440		MOVB AL, 0x40(SP)			
  0x401c2f		488b6c2420		MOVQ 0x20(SP), BP			
  0x401c34		4883c428		ADDQ $0x28, SP				
  0x401c38		c3			RET					
  0x401c39		e8425c0400		CALL runtime.morestack_noctxt(SB)	
  0x401c3e		eba0			JMP type..eq.internal/cpu.arm64(SB)	

TEXT type..hash.internal/cpu.option(SB) <autogenerated>

  0x401c40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401c49		483b6110		CMPQ 0x10(CX), SP			
  0x401c4d		765f			JBE 0x401cae				
  0x401c4f		4883ec28		SUBQ $0x28, SP				
  0x401c53		48896c2420		MOVQ BP, 0x20(SP)			
  0x401c58		488d6c2420		LEAQ 0x20(SP), BP			
  0x401c5d		488b442430		MOVQ 0x30(SP), AX			
  0x401c62		48890424		MOVQ AX, 0(SP)				
  0x401c66		488b4c2438		MOVQ 0x38(SP), CX			
  0x401c6b		48894c2408		MOVQ CX, 0x8(SP)			
  0x401c70		e80b0a0000		CALL runtime.strhash(SB)		
  0x401c75		488b442410		MOVQ 0x10(SP), AX			
  0x401c7a		488b4c2430		MOVQ 0x30(SP), CX			
  0x401c7f		4883c110		ADDQ $0x10, CX				
  0x401c83		48890c24		MOVQ CX, 0(SP)				
  0x401c87		4889442408		MOVQ AX, 0x8(SP)			
  0x401c8c		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x401c95		e826560000		CALL runtime.memhash(SB)		
  0x401c9a		488b442418		MOVQ 0x18(SP), AX			
  0x401c9f		4889442440		MOVQ AX, 0x40(SP)			
  0x401ca4		488b6c2420		MOVQ 0x20(SP), BP			
  0x401ca9		4883c428		ADDQ $0x28, SP				
  0x401cad		c3			RET					
  0x401cae		e8cd5b0400		CALL runtime.morestack_noctxt(SB)	
  0x401cb3		eb8b			JMP type..hash.internal/cpu.option(SB)	

TEXT type..eq.internal/cpu.option(SB) <autogenerated>

  0x401cc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401cc9		483b6110		CMPQ 0x10(CX), SP			
  0x401ccd		0f8688000000		JBE 0x401d5b				
  0x401cd3		4883ec28		SUBQ $0x28, SP				
  0x401cd7		48896c2420		MOVQ BP, 0x20(SP)			
  0x401cdc		488d6c2420		LEAQ 0x20(SP), BP			
  0x401ce1		488b442438		MOVQ 0x38(SP), AX			
  0x401ce6		488b08			MOVQ 0(AX), CX				
  0x401ce9		488b542430		MOVQ 0x30(SP), DX			
  0x401cee		488b1a			MOVQ 0(DX), BX				
  0x401cf1		488b7208		MOVQ 0x8(DX), SI			
  0x401cf5		48397008		CMPQ SI, 0x8(AX)			
  0x401cf9		743c			JE 0x401d37				
  0x401cfb		31c9			XORL CX, CX				
  0x401cfd		84c9			TESTL CL, CL				
  0x401cff		7510			JNE 0x401d11				
  0x401d01		31c0			XORL AX, AX				
  0x401d03		88442440		MOVB AL, 0x40(SP)			
  0x401d07		488b6c2420		MOVQ 0x20(SP), BP			
  0x401d0c		4883c428		ADDQ $0x28, SP				
  0x401d10		c3			RET					
  0x401d11		488d4a10		LEAQ 0x10(DX), CX			
  0x401d15		48890c24		MOVQ CX, 0(SP)				
  0x401d19		4883c010		ADDQ $0x10, AX				
  0x401d1d		4889442408		MOVQ AX, 0x8(SP)			
  0x401d22		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x401d2b		e8f0040000		CALL runtime.memequal(SB)		
  0x401d30		0fb6442418		MOVZX 0x18(SP), AX			
  0x401d35		ebcc			JMP 0x401d03				
  0x401d37		48891c24		MOVQ BX, 0(SP)				
  0x401d3b		48894c2408		MOVQ CX, 0x8(SP)			
  0x401d40		4889742410		MOVQ SI, 0x10(SP)			
  0x401d45		e8d6040000		CALL runtime.memequal(SB)		
  0x401d4a		0fb64c2418		MOVZX 0x18(SP), CX			
  0x401d4f		488b442438		MOVQ 0x38(SP), AX			
  0x401d54		488b542430		MOVQ 0x30(SP), DX			
  0x401d59		eba2			JMP 0x401cfd				
  0x401d5b		e8205b0400		CALL runtime.morestack_noctxt(SB)	
  0x401d60		e95bffffff		JMP type..eq.internal/cpu.option(SB)	

TEXT type..hash.internal/cpu.x86(SB) <autogenerated>

  0x401d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401d79		483b6110		CMPQ 0x10(CX), SP			
  0x401d7d		7647			JBE 0x401dc6				
  0x401d7f		4883ec28		SUBQ $0x28, SP				
  0x401d83		48896c2420		MOVQ BP, 0x20(SP)			
  0x401d88		488d6c2420		LEAQ 0x20(SP), BP			
  0x401d8d		488b442430		MOVQ 0x30(SP), AX			
  0x401d92		4883c040		ADDQ $0x40, AX				
  0x401d96		48890424		MOVQ AX, 0(SP)				
  0x401d9a		488b442438		MOVQ 0x38(SP), AX			
  0x401d9f		4889442408		MOVQ AX, 0x8(SP)			
  0x401da4		48c744241010000000	MOVQ $0x10, 0x10(SP)			
  0x401dad		e80e550000		CALL runtime.memhash(SB)		
  0x401db2		488b442418		MOVQ 0x18(SP), AX			
  0x401db7		4889442440		MOVQ AX, 0x40(SP)			
  0x401dbc		488b6c2420		MOVQ 0x20(SP), BP			
  0x401dc1		4883c428		ADDQ $0x28, SP				
  0x401dc5		c3			RET					
  0x401dc6		e8b55a0400		CALL runtime.morestack_noctxt(SB)	
  0x401dcb		eba3			JMP type..hash.internal/cpu.x86(SB)	

TEXT type..eq.internal/cpu.x86(SB) <autogenerated>

  0x401dd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x401dd9		483b6110		CMPQ 0x10(CX), SP			
  0x401ddd		7641			JBE 0x401e20				
  0x401ddf		4883ec20		SUBQ $0x20, SP				
  0x401de3		48896c2418		MOVQ BP, 0x18(SP)			
  0x401de8		488d6c2418		LEAQ 0x18(SP), BP			
  0x401ded		488b442428		MOVQ 0x28(SP), AX			
  0x401df2		4883c040		ADDQ $0x40, AX				
  0x401df6		48890424		MOVQ AX, 0(SP)				
  0x401dfa		488b442430		MOVQ 0x30(SP), AX			
  0x401dff		4883c040		ADDQ $0x40, AX				
  0x401e03		4889442408		MOVQ AX, 0x8(SP)			
  0x401e08		e8630f0000		CALL runtime.memequal128(SB)		
  0x401e0d		0fb6442410		MOVZX 0x10(SP), AX			
  0x401e12		88442438		MOVB AL, 0x38(SP)			
  0x401e16		488b6c2418		MOVQ 0x18(SP), BP			
  0x401e1b		4883c420		ADDQ $0x20, SP				
  0x401e1f		c3			RET					
  0x401e20		e85b5a0400		CALL runtime.morestack_noctxt(SB)	
  0x401e25		eba9			JMP type..eq.internal/cpu.x86(SB)	

TEXT type..hash.[15]internal/cpu.option(SB) <autogenerated>

  0x401e30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x401e39		483b6110		CMPQ 0x10(CX), SP				
  0x401e3d		7658			JBE 0x401e97					
  0x401e3f		4883ec28		SUBQ $0x28, SP					
  0x401e43		48896c2420		MOVQ BP, 0x20(SP)				
  0x401e48		488d6c2420		LEAQ 0x20(SP), BP				
  0x401e4d		31c0			XORL AX, AX					
  0x401e4f		488b4c2438		MOVQ 0x38(SP), CX				
  0x401e54		eb2c			JMP 0x401e82					
  0x401e56		4889442418		MOVQ AX, 0x18(SP)				
  0x401e5b		48c1e005		SHLQ $0x5, AX					
  0x401e5f		488b5c2430		MOVQ 0x30(SP), BX				
  0x401e64		4801d8			ADDQ BX, AX					
  0x401e67		48890424		MOVQ AX, 0(SP)					
  0x401e6b		48894c2408		MOVQ CX, 0x8(SP)				
  0x401e70		e8cbfdffff		CALL type..hash.internal/cpu.option(SB)		
  0x401e75		488b4c2410		MOVQ 0x10(SP), CX				
  0x401e7a		488b442418		MOVQ 0x18(SP), AX				
  0x401e7f		48ffc0			INCQ AX						
  0x401e82		4883f80f		CMPQ $0xf, AX					
  0x401e86		7cce			JL 0x401e56					
  0x401e88		48894c2440		MOVQ CX, 0x40(SP)				
  0x401e8d		488b6c2420		MOVQ 0x20(SP), BP				
  0x401e92		4883c428		ADDQ $0x28, SP					
  0x401e96		c3			RET						
  0x401e97		e8e4590400		CALL runtime.morestack_noctxt(SB)		
  0x401e9c		eb92			JMP type..hash.[15]internal/cpu.option(SB)	

TEXT type..eq.[15]internal/cpu.option(SB) <autogenerated>

  0x401ea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x401ea9		483b6110		CMPQ 0x10(CX), SP				
  0x401ead		766e			JBE 0x401f1d					
  0x401eaf		4883ec28		SUBQ $0x28, SP					
  0x401eb3		48896c2420		MOVQ BP, 0x20(SP)				
  0x401eb8		488d6c2420		LEAQ 0x20(SP), BP				
  0x401ebd		31c0			XORL AX, AX					
  0x401ebf		eb09			JMP 0x401eca					
  0x401ec1		488b4c2418		MOVQ 0x18(SP), CX				
  0x401ec6		488d4101		LEAQ 0x1(CX), AX				
  0x401eca		4883f80f		CMPQ $0xf, AX					
  0x401ece		7d3e			JGE 0x401f0e					
  0x401ed0		4889442418		MOVQ AX, 0x18(SP)				
  0x401ed5		48c1e005		SHLQ $0x5, AX					
  0x401ed9		488b542430		MOVQ 0x30(SP), DX				
  0x401ede		488d1c10		LEAQ 0(AX)(DX*1), BX				
  0x401ee2		48891c24		MOVQ BX, 0(SP)					
  0x401ee6		488b5c2438		MOVQ 0x38(SP), BX				
  0x401eeb		4801d8			ADDQ BX, AX					
  0x401eee		4889442408		MOVQ AX, 0x8(SP)				
  0x401ef3		e8c8fdffff		CALL type..eq.internal/cpu.option(SB)		
  0x401ef8		807c241000		CMPB $0x0, 0x10(SP)				
  0x401efd		75c2			JNE 0x401ec1					
  0x401eff		c644244000		MOVB $0x0, 0x40(SP)				
  0x401f04		488b6c2420		MOVQ 0x20(SP), BP				
  0x401f09		4883c428		ADDQ $0x28, SP					
  0x401f0d		c3			RET						
  0x401f0e		c644244001		MOVB $0x1, 0x40(SP)				
  0x401f13		488b6c2420		MOVQ 0x20(SP), BP				
  0x401f18		4883c428		ADDQ $0x28, SP					
  0x401f1c		c3			RET						
  0x401f1d		e85e590400		CALL runtime.morestack_noctxt(SB)		
  0x401f22		e979ffffff		JMP type..eq.[15]internal/cpu.option(SB)	

TEXT internal/bytealg.init.0(SB) /usr/local/go/src/internal/bytealg/index_amd64.go
	if cpu.X86.HasAVX2 {
  0x401f30		803d4cb10d0000		CMPB $0x0, internal/cpu.X86+67(SB)	
  0x401f37		740c			JE 0x401f45				
		MaxLen = 63
  0x401f39		48c705ccad0d003f000000	MOVQ $0x3f, internal/bytealg.MaxLen(SB)	
  0x401f44		c3			RET					
		MaxLen = 31
  0x401f45		48c705c0ad0d001f000000	MOVQ $0x1f, internal/bytealg.MaxLen(SB)	
  0x401f50		ebf2			JMP 0x401f44				

TEXT internal/bytealg.init(SB) <autogenerated>

  0x401f60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x401f69		483b6110		CMPQ 0x10(CX), SP				
  0x401f6d		7646			JBE 0x401fb5					
  0x401f6f		4883ec08		SUBQ $0x8, SP					
  0x401f73		48892c24		MOVQ BP, 0(SP)					
  0x401f77		488d2c24		LEAQ 0(SP), BP					
  0x401f7b		0fb6051ead0d00		MOVZX internal/bytealg.initdone.(SB), AX	
  0x401f82		80f801			CMPL $0x1, AL					
  0x401f85		7609			JBE 0x401f90					
  0x401f87		488b2c24		MOVQ 0(SP), BP					
  0x401f8b		4883c408		ADDQ $0x8, SP					
  0x401f8f		c3			RET						
  0x401f90		7507			JNE 0x401f99					
  0x401f92		e859020200		CALL runtime.throwinit(SB)			
  0x401f97		0f0b			UD2						
  0x401f99		c60500ad0d0001		MOVB $0x1, internal/bytealg.initdone.(SB)	
  0x401fa0		e88bffffff		CALL internal/bytealg.init.0(SB)		
  0x401fa5		c605f4ac0d0002		MOVB $0x2, internal/bytealg.initdone.(SB)	
  0x401fac		488b2c24		MOVQ 0(SP), BP					
  0x401fb0		4883c408		ADDQ $0x8, SP					
  0x401fb4		c3			RET						
  0x401fb5		e8c6580400		CALL runtime.morestack_noctxt(SB)		
  0x401fba		eba4			JMP internal/bytealg.init(SB)			

TEXT runtime.cmpstring(SB) /usr/local/go/src/internal/bytealg/compare_amd64.s

  0x401fc0		488b742408		MOVQ 0x8(SP), SI	

  0x401fc5		488b5c2410		MOVQ 0x10(SP), BX	

  0x401fca		488b7c2418		MOVQ 0x18(SP), DI	

  0x401fcf		488b542420		MOVQ 0x20(SP), DX	

  0x401fd4		4c8d4c2428		LEAQ 0x28(SP), R9	

  0x401fd9		e902000000		JMP cmpbody(SB)		

TEXT cmpbody(SB) /usr/local/go/src/internal/bytealg/compare_amd64.s

  0x401fe0		4839fe			CMPQ DI, SI		

  0x401fe3		0f842b010000		JE 0x402114		

  0x401fe9		4839d3			CMPQ DX, BX		

  0x401fec		4989d0			MOVQ DX, R8		

  0x401fef		4c0f4cc3		CMOVL BX, R8		

  0x401ff3		4983f808		CMPQ $0x8, R8		

  0x401ff7		0f82bc000000		JB 0x4020b9		

  0x401ffd		4983f83f		CMPQ $0x3f, R8		

  0x402001		7612			JBE 0x402015		

  0x402003		803d79b00d0001		CMPB $0x1, internal/cpu.X86+67(SB)	

  0x40200a		0f84ad010000		JE 0x4021bd		

  0x402010		e917010000		JMP 0x40212c		

  0x402015		4983f810		CMPQ $0x10, R8		

  0x402019		765e			JBE 0x402079		

  0x40201b		f30f6f06		MOVDQU 0(SI), X0	

  0x40201f		f30f6f0f		MOVDQU 0(DI), X1	

  0x402023		660f74c8		PCMPEQB X0, X1		

  0x402027		660fd7c1		PMOVMSKB X1, AX		

  0x40202b		4835ffff0000		XORQ $0xffff, AX	

  0x402031		752a			JNE 0x40205d		

  0x402033		4883c610		ADDQ $0x10, SI		

  0x402037		4883c710		ADDQ $0x10, DI		

  0x40203b		4983e810		SUBQ $0x10, R8		

  0x40203f		ebd4			JMP 0x402015		

  0x402041		4883c630		ADDQ $0x30, SI		

  0x402045		4883c730		ADDQ $0x30, DI		

  0x402049		eb12			JMP 0x40205d		

  0x40204b		4883c620		ADDQ $0x20, SI		

  0x40204f		4883c720		ADDQ $0x20, DI		

  0x402053		eb08			JMP 0x40205d		

  0x402055		4883c610		ADDQ $0x10, SI		

  0x402059		4883c710		ADDQ $0x10, DI		

  0x40205d		480fbcd8		BSFQ AX, BX		

  0x402061		4831c0			XORQ AX, AX		

  0x402064		8a0c1e			MOVB 0(SI)(BX*1), CL	

  0x402067		3a0c1f			CMPB 0(DI)(BX*1), CL	

  0x40206a		0f97c0			SETA AL			

  0x40206d		488d0445ffffffff	LEAQ 0xffffffff(AX*2), AX	

  0x402075		498901			MOVQ AX, 0(R9)		

  0x402078		c3			RET			

  0x402079		4983f808		CMPQ $0x8, R8		

  0x40207d		760b			JBE 0x40208a		

  0x40207f		488b06			MOVQ 0(SI), AX		

  0x402082		488b0f			MOVQ 0(DI), CX		

  0x402085		4839c8			CMPQ CX, AX		

  0x402088		750f			JNE 0x402099		

  0x40208a		4a8b4406f8		MOVQ -0x8(SI)(R8*1), AX	

  0x40208f		4a8b4c07f8		MOVQ -0x8(DI)(R8*1), CX	

  0x402094		4839c8			CMPQ CX, AX		

  0x402097		747b			JE 0x402114		

  0x402099		480fc8			BSWAP AX		

  0x40209c		480fc9			BSWAP CX		

  0x40209f		4831c1			XORQ AX, CX		

  0x4020a2		480fbdc9		BSRQ CX, CX		

  0x4020a6		48d3e8			SHRQ CL, AX		

  0x4020a9		4883e001		ANDQ $0x1, AX		

  0x4020ad		488d0445ffffffff	LEAQ 0xffffffff(AX*2), AX	

  0x4020b5		498901			MOVQ AX, 0(R9)		

  0x4020b8		c3			RET			

  0x4020b9		4a8d0cc500000000	LEAQ 0(R8*8), CX	

  0x4020c1		48f7d9			NEGQ CX			

  0x4020c4		744e			JE 0x402114		

  0x4020c6		4080fef8		CMPL $0xf8, SI		

  0x4020ca		7705			JA 0x4020d1		

  0x4020cc		488b36			MOVQ 0(SI), SI		

  0x4020cf		eb08			JMP 0x4020d9		

  0x4020d1		4a8b7406f8		MOVQ -0x8(SI)(R8*1), SI	

  0x4020d6		48d3ee			SHRQ CL, SI		

  0x4020d9		48d3e6			SHLQ CL, SI		

  0x4020dc		4080fff8		CMPL $0xf8, DI		

  0x4020e0		7705			JA 0x4020e7		

  0x4020e2		488b3f			MOVQ 0(DI), DI		

  0x4020e5		eb08			JMP 0x4020ef		

  0x4020e7		4a8b7c07f8		MOVQ -0x8(DI)(R8*1), DI	

  0x4020ec		48d3ef			SHRQ CL, DI		

  0x4020ef		48d3e7			SHLQ CL, DI		

  0x4020f2		480fce			BSWAP SI		

  0x4020f5		480fcf			BSWAP DI		

  0x4020f8		4831f7			XORQ SI, DI		

  0x4020fb		7417			JE 0x402114		

  0x4020fd		480fbdcf		BSRQ DI, CX		

  0x402101		48d3ee			SHRQ CL, SI		

  0x402104		4883e601		ANDQ $0x1, SI		

  0x402108		488d0475ffffffff	LEAQ 0xffffffff(SI*2), AX	

  0x402110		498901			MOVQ AX, 0(R9)		

  0x402113		c3			RET			

  0x402114		4831c0			XORQ AX, AX		

  0x402117		4831c9			XORQ CX, CX		

  0x40211a		4839d3			CMPQ DX, BX		

  0x40211d		0f9fc0			SETG AL			

  0x402120		0f94c1			SETE CL			

  0x402123		488d4441ff		LEAQ -0x1(CX)(AX*2), AX	

  0x402128		498901			MOVQ AX, 0(R9)		

  0x40212b		c3			RET			

  0x40212c		f30f6f06		MOVDQU 0(SI), X0	

  0x402130		f30f6f0f		MOVDQU 0(DI), X1	

  0x402134		660f74c8		PCMPEQB X0, X1		

  0x402138		660fd7c1		PMOVMSKB X1, AX		

  0x40213c		4835ffff0000		XORQ $0xffff, AX	

  0x402142		0f8515ffffff		JNE 0x40205d		

  0x402148		f30f6f4610		MOVDQU 0x10(SI), X0	

  0x40214d		f30f6f4f10		MOVDQU 0x10(DI), X1	

  0x402152		660f74c8		PCMPEQB X0, X1		

  0x402156		660fd7c1		PMOVMSKB X1, AX		

  0x40215a		4835ffff0000		XORQ $0xffff, AX	

  0x402160		0f85effeffff		JNE 0x402055		

  0x402166		f30f6f4620		MOVDQU 0x20(SI), X0	

  0x40216b		f30f6f4f20		MOVDQU 0x20(DI), X1	

  0x402170		660f74c8		PCMPEQB X0, X1		

  0x402174		660fd7c1		PMOVMSKB X1, AX		

  0x402178		4835ffff0000		XORQ $0xffff, AX	

  0x40217e		0f85c7feffff		JNE 0x40204b		

  0x402184		f30f6f4630		MOVDQU 0x30(SI), X0	

  0x402189		f30f6f4f30		MOVDQU 0x30(DI), X1	

  0x40218e		660f74c8		PCMPEQB X0, X1		

  0x402192		660fd7c1		PMOVMSKB X1, AX		

  0x402196		4835ffff0000		XORQ $0xffff, AX	

  0x40219c		0f859ffeffff		JNE 0x402041		

  0x4021a2		4883c640		ADDQ $0x40, SI		

  0x4021a6		4883c740		ADDQ $0x40, DI		

  0x4021aa		4983e840		SUBQ $0x40, R8		

  0x4021ae		4983f840		CMPQ $0x40, R8		

  0x4021b2		0f865dfeffff		JBE 0x402015		

  0x4021b8		e96fffffff		JMP 0x40212c		

  0x4021bd		c5fe6f16		VMOVDQU 0(SI), X2	

  0x4021c1		c5fe6f1f		VMOVDQU 0(DI), X3	

  0x4021c5		c5fe6f6620		VMOVDQU 0x20(SI), X4	

  0x4021ca		c5fe6f6f20		VMOVDQU 0x20(DI), X5	

  0x4021cf		c5e574c2		JE 0x402195		

  0x4021d3		c5fdd7			XLATB DS:0(BX)		
  0x4021d6		c0			?			

  0x4021d7		35ffffffff		XORL $-0x1, AX		

  0x4021dc		7523			JNE 0x402201		

  0x4021de		c5d574f4		JE 0x4021d6		

  0x4021e2		c5fdd7			XLATB DS:0(BX)		
  0x4021e5		c6			?			

  0x4021e6		35ffffffff		XORL $-0x1, AX		

  0x4021eb		751c			JNE 0x402209		

  0x4021ed		4883c640		ADDQ $0x40, SI		

  0x4021f1		4883c740		ADDQ $0x40, DI		

  0x4021f5		4983e840		SUBQ $0x40, R8		

  0x4021f9		4983f840		CMPQ $0x40, R8		

  0x4021fd		7212			JB 0x402211		

  0x4021ff		ebbc			JMP 0x4021bd		

  0x402201		c5f877			VZEROUPPER		

  0x402204		e954feffff		JMP 0x40205d		

  0x402209		c5f877			VZEROUPPER		

  0x40220c		e93afeffff		JMP 0x40204b		

  0x402211		c5f877			VZEROUPPER		

  0x402214		e9fcfdffff		JMP 0x402015		

TEXT runtime.memequal(SB) /usr/local/go/src/internal/bytealg/equal_amd64.s

  0x402220		488b742408		MOVQ 0x8(SP), SI	

  0x402225		488b7c2410		MOVQ 0x10(SP), DI	

  0x40222a		4839fe			CMPQ DI, SI		

  0x40222d		740f			JE 0x40223e		

  0x40222f		488b5c2418		MOVQ 0x18(SP), BX	

  0x402234		488d442420		LEAQ 0x20(SP), AX	

  0x402239		e942000000		JMP memeqbody(SB)	

  0x40223e		c644242001		MOVB $0x1, 0x20(SP)	

  0x402243		c3			RET			

TEXT runtime.memequal_varlen(SB) /usr/local/go/src/internal/bytealg/equal_amd64.s

  0x402250		488b742408		MOVQ 0x8(SP), SI	

  0x402255		488b7c2410		MOVQ 0x10(SP), DI	

  0x40225a		4839fe			CMPQ DI, SI		

  0x40225d		740e			JE 0x40226d		

  0x40225f		488b5a08		MOVQ 0x8(DX), BX	

  0x402263		488d442418		LEAQ 0x18(SP), AX	

  0x402268		e913000000		JMP memeqbody(SB)	

  0x40226d		c644241801		MOVB $0x1, 0x18(SP)	

  0x402272		c3			RET			

TEXT memeqbody(SB) /usr/local/go/src/internal/bytealg/equal_amd64.s

  0x402280		4883fb08		CMPQ $0x8, BX		

  0x402284		0f82f3000000		JB 0x40237d		

  0x40228a		4883fb40		CMPQ $0x40, BX		

  0x40228e		0f82b7000000		JB 0x40234b		

  0x402294		803de8ad0d0001		CMPB $0x1, internal/cpu.X86+67(SB)	

  0x40229b		7468			JE 0x402305		

  0x40229d		4883fb40		CMPQ $0x40, BX		

  0x4022a1		0f82a4000000		JB 0x40234b		

  0x4022a7		f30f6f06		MOVDQU 0(SI), X0	

  0x4022ab		f30f6f0f		MOVDQU 0(DI), X1	

  0x4022af		f30f6f5610		MOVDQU 0x10(SI), X2	

  0x4022b4		f30f6f5f10		MOVDQU 0x10(DI), X3	

  0x4022b9		f30f6f6620		MOVDQU 0x20(SI), X4	

  0x4022be		f30f6f6f20		MOVDQU 0x20(DI), X5	

  0x4022c3		f30f6f7630		MOVDQU 0x30(SI), X6	

  0x4022c8		f30f6f7f30		MOVDQU 0x30(DI), X7	

  0x4022cd		660f74c1		PCMPEQB X1, X0		

  0x4022d1		660f74d3		PCMPEQB X3, X2		

  0x4022d5		660f74e5		PCMPEQB X5, X4		

  0x4022d9		660f74f7		PCMPEQB X7, X6		

  0x4022dd		660fdbc2		PAND X2, X0		

  0x4022e1		660fdbe6		PAND X6, X4		

  0x4022e5		660fdbc4		PAND X4, X0		

  0x4022e9		660fd7d0		PMOVMSKB X0, DX		

  0x4022ed		4883c640		ADDQ $0x40, SI		

  0x4022f1		4883c740		ADDQ $0x40, DI		

  0x4022f5		4883eb40		SUBQ $0x40, BX		

  0x4022f9		81faffff0000		CMPL $0xffff, DX	

  0x4022ff		749c			JE 0x40229d		

  0x402301		c60000			MOVB $0x0, 0(AX)	

  0x402304		c3			RET			

  0x402305		4883fb40		CMPQ $0x40, BX		

  0x402309		723d			JB 0x402348		

  0x40230b		c5fe6f06		VMOVDQU 0(SI), X0	

  0x40230f		c5fe6f0f		VMOVDQU 0(DI), X1	

  0x402313		c5fe6f5620		VMOVDQU 0x20(SI), X2	

  0x402318		c5fe6f5f20		VMOVDQU 0x20(DI), X3	

  0x40231d		c5fd74e1		JE 0x402302		

  0x402321		c5e574ea		JE 0x40230f		

  0x402325		c5d5dbf4		FCOMI F4, F0		

  0x402329		c5fdd7			XLATB DS:0(BX)		
  0x40232c		d6			?			

  0x40232d		4883c640		ADDQ $0x40, SI		

  0x402331		4883c740		ADDQ $0x40, DI		

  0x402335		4883eb40		SUBQ $0x40, BX		

  0x402339		81faffffffff		CMPL $-0x1, DX		

  0x40233f		74c4			JE 0x402305		

  0x402341		c5f877			VZEROUPPER		

  0x402344		c60000			MOVB $0x0, 0(AX)	

  0x402347		c3			RET			

  0x402348		c5f877			VZEROUPPER		

  0x40234b		4883fb08		CMPQ $0x8, BX		

  0x40234f		761b			JBE 0x40236c		

  0x402351		488b0e			MOVQ 0(SI), CX		

  0x402354		488b17			MOVQ 0(DI), DX		

  0x402357		4883c608		ADDQ $0x8, SI		

  0x40235b		4883c708		ADDQ $0x8, DI		

  0x40235f		4883eb08		SUBQ $0x8, BX		

  0x402363		4839d1			CMPQ DX, CX		

  0x402366		74e3			JE 0x40234b		

  0x402368		c60000			MOVB $0x0, 0(AX)	

  0x40236b		c3			RET			

  0x40236c		488b4c1ef8		MOVQ -0x8(SI)(BX*1), CX	

  0x402371		488b541ff8		MOVQ -0x8(DI)(BX*1), DX	

  0x402376		4839d1			CMPQ DX, CX		

  0x402379		0f9400			SETE 0(AX)		

  0x40237c		c3			RET			

  0x40237d		4883fb00		CMPQ $0x0, BX		

  0x402381		7437			JE 0x4023ba		

  0x402383		488d0cdd00000000	LEAQ 0(BX*8), CX	

  0x40238b		48f7d9			NEGQ CX			

  0x40238e		4080fef8		CMPL $0xf8, SI		

  0x402392		7705			JA 0x402399		

  0x402394		488b36			MOVQ 0(SI), SI		

  0x402397		eb08			JMP 0x4023a1		

  0x402399		488b741ef8		MOVQ -0x8(SI)(BX*1), SI	

  0x40239e		48d3ee			SHRQ CL, SI		

  0x4023a1		4080fff8		CMPL $0xf8, DI		

  0x4023a5		7705			JA 0x4023ac		

  0x4023a7		488b3f			MOVQ 0(DI), DI		

  0x4023aa		eb08			JMP 0x4023b4		

  0x4023ac		488b7c1ff8		MOVQ -0x8(DI)(BX*1), DI	

  0x4023b1		48d3ef			SHRQ CL, DI		

  0x4023b4		4829f7			SUBQ SI, DI		

  0x4023b7		48d3e7			SHLQ CL, DI		

  0x4023ba		0f9400			SETE 0(AX)		

  0x4023bd		c3			RET			

TEXT internal/bytealg.IndexByteString(SB) /usr/local/go/src/internal/bytealg/indexbyte_amd64.s

  0x4023c0		488b742408		MOVQ 0x8(SP), SI	

  0x4023c5		488b5c2410		MOVQ 0x10(SP), BX	

  0x4023ca		8a442418		MOVB 0x18(SP), AL	

  0x4023ce		4c8d442420		LEAQ 0x20(SP), R8	

  0x4023d3		e908000000		JMP indexbytebody(SB)	

TEXT indexbytebody(SB) /usr/local/go/src/internal/bytealg/indexbyte_amd64.s

  0x4023e0		66480f6ec0		MOVQ AX, X0		

  0x4023e5		660f60c0		PUNPCKLBW X0, X0	

  0x4023e9		660f60c0		PUNPCKLBW X0, X0	

  0x4023ed		660f70c000		PSHUFD $0x0, X0, X0	

  0x4023f2		4883fb10		CMPQ $0x10, BX		

  0x4023f6		7c54			JL 0x40244c		

  0x4023f8		4889f7			MOVQ SI, DI		

  0x4023fb		4883fb20		CMPQ $0x20, BX		

  0x4023ff		0f878d000000		JA 0x402492		

  0x402405		488d441ef0		LEAQ -0x10(SI)(BX*1), AX	

  0x40240a		eb15			JMP 0x402421		

  0x40240c		f30f6f0f		MOVDQU 0(DI), X1	

  0x402410		660f74c8		PCMPEQB X0, X1		

  0x402414		660fd7d1		PMOVMSKB X1, DX		

  0x402418		0fbcd2			BSFL DX, DX		

  0x40241b		7525			JNE 0x402442		

  0x40241d		4883c710		ADDQ $0x10, DI		

  0x402421		4839c7			CMPQ AX, DI		

  0x402424		72e6			JB 0x40240c		

  0x402426		4889c7			MOVQ AX, DI		

  0x402429		f30f6f08		MOVDQU 0(AX), X1	

  0x40242d		660f74c8		PCMPEQB X0, X1		

  0x402431		660fd7d1		PMOVMSKB X1, DX		

  0x402435		0fbcd2			BSFL DX, DX		

  0x402438		7508			JNE 0x402442		

  0x40243a		49c700ffffffff		MOVQ $-0x1, 0(R8)	

  0x402441		c3			RET			

  0x402442		4829f7			SUBQ SI, DI		

  0x402445		4801d7			ADDQ DX, DI		

  0x402448		498938			MOVQ DI, 0(R8)		

  0x40244b		c3			RET			

  0x40244c		4885db			TESTQ BX, BX		

  0x40244f		74e9			JE 0x40243a		

  0x402451		488d4610		LEAQ 0x10(SI), AX	

  0x402455		66a9f00f		TESTW $0xff0, AX	

  0x402459		7419			JE 0x402474		

  0x40245b		f30f6f0e		MOVDQU 0(SI), X1	

  0x40245f		660f74c8		PCMPEQB X0, X1		

  0x402463		660fd7d1		PMOVMSKB X1, DX		

  0x402467		0fbcd2			BSFL DX, DX		

  0x40246a		74ce			JE 0x40243a		

  0x40246c		39da			CMPL BX, DX		

  0x40246e		73ca			JAE 0x40243a		

  0x402470		498910			MOVQ DX, 0(R8)		

  0x402473		c3			RET			

  0x402474		f30f6f4c1ef0		MOVDQU -0x10(SI)(BX*1), X1	

  0x40247a		660f74c8		PCMPEQB X0, X1		

  0x40247e		660fd7d1		PMOVMSKB X1, DX		

  0x402482		89d9			MOVL BX, CX		

  0x402484		d3e2			SHLL CL, DX		

  0x402486		c1ea10			SHRL $0x10, DX		

  0x402489		0fbcd2			BSFL DX, DX		

  0x40248c		74ac			JE 0x40243a		

  0x40248e		498910			MOVQ DX, 0(R8)		

  0x402491		c3			RET			

  0x402492		803deaab0d0001		CMPB $0x1, internal/cpu.X86+67(SB)	

  0x402499		0f8566ffffff		JNE 0x402405		

  0x40249f		66480f6ec0		MOVQ AX, X0		

  0x4024a4		4c8d5c1ee0		LEAQ -0x20(SI)(BX*1), R11	

  0x4024a9		c4e27d78c8		JS 0x402476		

  0x4024ae		c5fe6f17		VMOVDQU 0(DI), X2	

  0x4024b2		c5ed74d9		JE 0x40248f		

  0x4024b6		c4			?			
  0x4024b7		e27d			LOOP 0x402536		
  0x4024b9		17			?			
  0x4024ba		db			?			

  0x4024bb		7526			JNE 0x4024e3		

  0x4024bd		4883c720		ADDQ $0x20, DI		

  0x4024c1		4c39df			CMPQ R11, DI		

  0x4024c4		7ce8			JL 0x4024ae		

  0x4024c6		4c89df			MOVQ R11, DI		

  0x4024c9		c5fe6f17		VMOVDQU 0(DI), X2	

  0x4024cd		c5ed74d9		JE 0x4024aa		

  0x4024d1		c4			?			
  0x4024d2		e27d			LOOP 0x402551		
  0x4024d4		17			?			
  0x4024d5		db			?			

  0x4024d6		750b			JNE 0x4024e3		

  0x4024d8		c5f877			VZEROUPPER		

  0x4024db		49c700ffffffff		MOVQ $-0x1, 0(R8)	

  0x4024e2		c3			RET			

  0x4024e3		c5fdd7			XLATB DS:0(BX)		
  0x4024e6		d30f			RORL CL, 0(DI)		

  0x4024e8		bcd24829f7		MOVL $-0x8d6b72e, SP	

  0x4024ed		4801fa			ADDQ DI, DX		

  0x4024f0		498910			MOVQ DX, 0(R8)		

  0x4024f3		c5f877			VZEROUPPER		

  0x4024f6		c3			RET			

TEXT runtime.memhash0(SB) /usr/local/go/src/runtime/alg.go
	return h
  0x402500		488b442410		MOVQ 0x10(SP), AX	
  0x402505		4889442418		MOVQ AX, 0x18(SP)	
  0x40250a		c3			RET			

TEXT runtime.memhash8(SB) /usr/local/go/src/runtime/alg.go
func memhash8(p unsafe.Pointer, h uintptr) uintptr {
  0x402510		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402519		483b6110		CMPQ 0x10(CX), SP	
  0x40251d		7643			JBE 0x402562		
  0x40251f		4883ec28		SUBQ $0x28, SP		
  0x402523		48896c2420		MOVQ BP, 0x20(SP)	
  0x402528		488d6c2420		LEAQ 0x20(SP), BP	
	return memhash(p, h, 1)
  0x40252d		488b442430		MOVQ 0x30(SP), AX		
  0x402532		48890424		MOVQ AX, 0(SP)			
  0x402536		488b442438		MOVQ 0x38(SP), AX		
  0x40253b		4889442408		MOVQ AX, 0x8(SP)		
  0x402540		48c744241001000000	MOVQ $0x1, 0x10(SP)		
  0x402549		e8724d0000		CALL runtime.memhash(SB)	
  0x40254e		488b442418		MOVQ 0x18(SP), AX		
  0x402553		4889442440		MOVQ AX, 0x40(SP)		
  0x402558		488b6c2420		MOVQ 0x20(SP), BP		
  0x40255d		4883c428		ADDQ $0x28, SP			
  0x402561		c3			RET				
func memhash8(p unsafe.Pointer, h uintptr) uintptr {
  0x402562		e819530400		CALL runtime.morestack_noctxt(SB)	
  0x402567		eba7			JMP runtime.memhash8(SB)		

TEXT runtime.memhash16(SB) /usr/local/go/src/runtime/alg.go
func memhash16(p unsafe.Pointer, h uintptr) uintptr {
  0x402570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402579		483b6110		CMPQ 0x10(CX), SP	
  0x40257d		7643			JBE 0x4025c2		
  0x40257f		4883ec28		SUBQ $0x28, SP		
  0x402583		48896c2420		MOVQ BP, 0x20(SP)	
  0x402588		488d6c2420		LEAQ 0x20(SP), BP	
	return memhash(p, h, 2)
  0x40258d		488b442430		MOVQ 0x30(SP), AX		
  0x402592		48890424		MOVQ AX, 0(SP)			
  0x402596		488b442438		MOVQ 0x38(SP), AX		
  0x40259b		4889442408		MOVQ AX, 0x8(SP)		
  0x4025a0		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x4025a9		e8124d0000		CALL runtime.memhash(SB)	
  0x4025ae		488b442418		MOVQ 0x18(SP), AX		
  0x4025b3		4889442440		MOVQ AX, 0x40(SP)		
  0x4025b8		488b6c2420		MOVQ 0x20(SP), BP		
  0x4025bd		4883c428		ADDQ $0x28, SP			
  0x4025c1		c3			RET				
func memhash16(p unsafe.Pointer, h uintptr) uintptr {
  0x4025c2		e8b9520400		CALL runtime.morestack_noctxt(SB)	
  0x4025c7		eba7			JMP runtime.memhash16(SB)		

TEXT runtime.memhash128(SB) /usr/local/go/src/runtime/alg.go
func memhash128(p unsafe.Pointer, h uintptr) uintptr {
  0x4025d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4025d9		483b6110		CMPQ 0x10(CX), SP	
  0x4025dd		7643			JBE 0x402622		
  0x4025df		4883ec28		SUBQ $0x28, SP		
  0x4025e3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4025e8		488d6c2420		LEAQ 0x20(SP), BP	
	return memhash(p, h, 16)
  0x4025ed		488b442430		MOVQ 0x30(SP), AX		
  0x4025f2		48890424		MOVQ AX, 0(SP)			
  0x4025f6		488b442438		MOVQ 0x38(SP), AX		
  0x4025fb		4889442408		MOVQ AX, 0x8(SP)		
  0x402600		48c744241010000000	MOVQ $0x10, 0x10(SP)		
  0x402609		e8b24c0000		CALL runtime.memhash(SB)	
  0x40260e		488b442418		MOVQ 0x18(SP), AX		
  0x402613		4889442440		MOVQ AX, 0x40(SP)		
  0x402618		488b6c2420		MOVQ 0x20(SP), BP		
  0x40261d		4883c428		ADDQ $0x28, SP			
  0x402621		c3			RET				
func memhash128(p unsafe.Pointer, h uintptr) uintptr {
  0x402622		e859520400		CALL runtime.morestack_noctxt(SB)	
  0x402627		eba7			JMP runtime.memhash128(SB)		

TEXT runtime.memhash_varlen(SB) /usr/local/go/src/runtime/alg.go
func memhash_varlen(p unsafe.Pointer, h uintptr) uintptr {
  0x402630		4883ec28		SUBQ $0x28, SP		
  0x402634		48896c2420		MOVQ BP, 0x20(SP)	
  0x402639		488d6c2420		LEAQ 0x20(SP), BP	
	size := *(*uintptr)(unsafe.Pointer(ptr + unsafe.Sizeof(h)))
  0x40263e		488d4208		LEAQ 0x8(DX), AX	
  0x402642		488b00			MOVQ 0(AX), AX		
	return memhash(p, h, size)
  0x402645		488b4c2430		MOVQ 0x30(SP), CX		
  0x40264a		48890c24		MOVQ CX, 0(SP)			
  0x40264e		488b4c2438		MOVQ 0x38(SP), CX		
  0x402653		48894c2408		MOVQ CX, 0x8(SP)		
  0x402658		4889442410		MOVQ AX, 0x10(SP)		
  0x40265d		e85e4c0000		CALL runtime.memhash(SB)	
  0x402662		488b442418		MOVQ 0x18(SP), AX		
  0x402667		4889442440		MOVQ AX, 0x40(SP)		
  0x40266c		488b6c2420		MOVQ 0x20(SP), BP		
  0x402671		4883c428		ADDQ $0x28, SP			
  0x402675		c3			RET				

TEXT runtime.strhash(SB) /usr/local/go/src/runtime/alg.go
func strhash(a unsafe.Pointer, h uintptr) uintptr {
  0x402680		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402689		483b6110		CMPQ 0x10(CX), SP	
  0x40268d		7646			JBE 0x4026d5		
  0x40268f		4883ec28		SUBQ $0x28, SP		
  0x402693		48896c2420		MOVQ BP, 0x20(SP)	
  0x402698		488d6c2420		LEAQ 0x20(SP), BP	
	return memhash(x.str, h, uintptr(x.len))
  0x40269d		488b442430		MOVQ 0x30(SP), AX		
  0x4026a2		488b08			MOVQ 0(AX), CX			
  0x4026a5		488b4008		MOVQ 0x8(AX), AX		
  0x4026a9		48890c24		MOVQ CX, 0(SP)			
  0x4026ad		488b4c2438		MOVQ 0x38(SP), CX		
  0x4026b2		48894c2408		MOVQ CX, 0x8(SP)		
  0x4026b7		4889442410		MOVQ AX, 0x10(SP)		
  0x4026bc		e8ff4b0000		CALL runtime.memhash(SB)	
  0x4026c1		488b442418		MOVQ 0x18(SP), AX		
  0x4026c6		4889442440		MOVQ AX, 0x40(SP)		
  0x4026cb		488b6c2420		MOVQ 0x20(SP), BP		
  0x4026d0		4883c428		ADDQ $0x28, SP			
  0x4026d4		c3			RET				
func strhash(a unsafe.Pointer, h uintptr) uintptr {
  0x4026d5		e8a6510400		CALL runtime.morestack_noctxt(SB)	
  0x4026da		eba4			JMP runtime.strhash(SB)			

TEXT runtime.f32hash(SB) /usr/local/go/src/runtime/alg.go
func f32hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4026e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4026e9		483b6110		CMPQ 0x10(CX), SP	
  0x4026ed		0f86fd000000		JBE 0x4027f0		
  0x4026f3		4883ec28		SUBQ $0x28, SP		
  0x4026f7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4026fc		488d6c2420		LEAQ 0x20(SP), BP	
	f := *(*float32)(p)
  0x402701		488b442430		MOVQ 0x30(SP), AX	
  0x402706		f30f1000		MOVSS 0(AX), X0		
	case f == 0:
  0x40270a		0f57c9			XORPS X1, X1		
  0x40270d		0f2ec1			UCOMISS X1, X0		
  0x402710		7506			JNE 0x402718		
  0x402712		0f8ba9000000		JNP 0x4027c1		
	case f != f:
  0x402718		0f2ec0			UCOMISS X0, X0		
  0x40271b		7502			JNE 0x40271f		
  0x40271d		7b72			JNP 0x402791		
	mp := getg().m
  0x40271f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x402728		488b4030		MOVQ 0x30(AX), AX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x40272c		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40272d		8b8820010000		MOVL 0x120(AX), CX	
  0x402733		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x402739		899020010000		MOVL DX, 0x120(AX)	
	s1 ^= s1 << 17
  0x40273f		89cb			MOVL CX, BX		
  0x402741		c1e111			SHLL $0x11, CX		
  0x402744		31cb			XORL CX, BX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x402746		89d1			MOVL DX, CX		
  0x402748		31da			XORL BX, DX		
  0x40274a		c1eb07			SHRL $0x7, BX		
  0x40274d		31d3			XORL DX, BX		
  0x40274f		89ca			MOVL CX, DX		
  0x402751		c1e910			SHRL $0x10, CX		
  0x402754		31d9			XORL BX, CX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x402756		898824010000		MOVL CX, 0x124(AX)	
	return s0 + s1
  0x40275c		8d040a			LEAL 0(DX)(CX*1), AX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x40275f		488b4c2438		MOVQ 0x38(SP), CX		
  0x402764		4831c8			XORQ CX, AX			
  0x402767		48b921a6566aa16e7500	MOVQ $0x756ea16a56a621, CX	
  0x402771		4831c1			XORQ AX, CX			
  0x402774		48b8bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, AX	
  0x40277e		480fafc8		IMULQ AX, CX			
  0x402782		48894c2440		MOVQ CX, 0x40(SP)		
  0x402787		488b6c2420		MOVQ 0x20(SP), BP		
  0x40278c		4883c428		ADDQ $0x28, SP			
  0x402790		c3			RET				
		return memhash(p, h, 4)
  0x402791		48890424		MOVQ AX, 0(SP)			
  0x402795		488b442438		MOVQ 0x38(SP), AX		
  0x40279a		4889442408		MOVQ AX, 0x8(SP)		
  0x40279f		48c744241004000000	MOVQ $0x4, 0x10(SP)		
  0x4027a8		e8134b0000		CALL runtime.memhash(SB)	
  0x4027ad		488b442418		MOVQ 0x18(SP), AX		
  0x4027b2		4889442440		MOVQ AX, 0x40(SP)		
  0x4027b7		488b6c2420		MOVQ 0x20(SP), BP		
  0x4027bc		4883c428		ADDQ $0x28, SP			
  0x4027c0		c3			RET				
		return c1 * (c0 ^ h) // +0, -0
  0x4027c1		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4027cb		488b4c2438		MOVQ 0x38(SP), CX		
  0x4027d0		4831c8			XORQ CX, AX			
  0x4027d3		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4027dd		480fafc1		IMULQ CX, AX			
  0x4027e1		4889442440		MOVQ AX, 0x40(SP)		
  0x4027e6		488b6c2420		MOVQ 0x20(SP), BP		
  0x4027eb		4883c428		ADDQ $0x28, SP			
  0x4027ef		c3			RET				
func f32hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4027f0		e88b500400		CALL runtime.morestack_noctxt(SB)	
  0x4027f5		e9e6feffff		JMP runtime.f32hash(SB)			

TEXT runtime.f64hash(SB) /usr/local/go/src/runtime/alg.go
func f64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x402800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402809		483b6110		CMPQ 0x10(CX), SP	
  0x40280d		0f86ff000000		JBE 0x402912		
  0x402813		4883ec28		SUBQ $0x28, SP		
  0x402817		48896c2420		MOVQ BP, 0x20(SP)	
  0x40281c		488d6c2420		LEAQ 0x20(SP), BP	
	f := *(*float64)(p)
  0x402821		488b442430		MOVQ 0x30(SP), AX	
  0x402826		f20f1000		MOVSD_XMM 0(AX), X0	
	case f == 0:
  0x40282a		0f57c9			XORPS X1, X1		
  0x40282d		660f2ec1		UCOMISD X1, X0		
  0x402831		7506			JNE 0x402839		
  0x402833		0f8baa000000		JNP 0x4028e3		
	case f != f:
  0x402839		660f2ec0		UCOMISD X0, X0		
  0x40283d		7502			JNE 0x402841		
  0x40283f		7b72			JNP 0x4028b3		
	mp := getg().m
  0x402841		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40284a		488b4030		MOVQ 0x30(AX), AX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x40284e		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40284f		8b8820010000		MOVL 0x120(AX), CX	
  0x402855		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40285b		899020010000		MOVL DX, 0x120(AX)	
	s1 ^= s1 << 17
  0x402861		89cb			MOVL CX, BX		
  0x402863		c1e111			SHLL $0x11, CX		
  0x402866		31cb			XORL CX, BX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x402868		89d1			MOVL DX, CX		
  0x40286a		31da			XORL BX, DX		
  0x40286c		c1eb07			SHRL $0x7, BX		
  0x40286f		31d3			XORL DX, BX		
  0x402871		89ca			MOVL CX, DX		
  0x402873		c1e910			SHRL $0x10, CX		
  0x402876		31d9			XORL BX, CX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x402878		898824010000		MOVL CX, 0x124(AX)	
	return s0 + s1
  0x40287e		8d040a			LEAL 0(DX)(CX*1), AX	
		return c1 * (c0 ^ h ^ uintptr(fastrand())) // any kind of NaN
  0x402881		488b4c2438		MOVQ 0x38(SP), CX		
  0x402886		4831c8			XORQ CX, AX			
  0x402889		48b921a6566aa16e7500	MOVQ $0x756ea16a56a621, CX	
  0x402893		4831c1			XORQ AX, CX			
  0x402896		48b8bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, AX	
  0x4028a0		480fafc8		IMULQ AX, CX			
  0x4028a4		48894c2440		MOVQ CX, 0x40(SP)		
  0x4028a9		488b6c2420		MOVQ 0x20(SP), BP		
  0x4028ae		4883c428		ADDQ $0x28, SP			
  0x4028b2		c3			RET				
		return memhash(p, h, 8)
  0x4028b3		48890424		MOVQ AX, 0(SP)			
  0x4028b7		488b442438		MOVQ 0x38(SP), AX		
  0x4028bc		4889442408		MOVQ AX, 0x8(SP)		
  0x4028c1		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x4028ca		e8f1490000		CALL runtime.memhash(SB)	
  0x4028cf		488b442418		MOVQ 0x18(SP), AX		
  0x4028d4		4889442440		MOVQ AX, 0x40(SP)		
  0x4028d9		488b6c2420		MOVQ 0x20(SP), BP		
  0x4028de		4883c428		ADDQ $0x28, SP			
  0x4028e2		c3			RET				
		return c1 * (c0 ^ h) // +0, -0
  0x4028e3		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x4028ed		488b4c2438		MOVQ 0x38(SP), CX		
  0x4028f2		4831c8			XORQ CX, AX			
  0x4028f5		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x4028ff		480fafc1		IMULQ CX, AX			
  0x402903		4889442440		MOVQ AX, 0x40(SP)		
  0x402908		488b6c2420		MOVQ 0x20(SP), BP		
  0x40290d		4883c428		ADDQ $0x28, SP			
  0x402911		c3			RET				
func f64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x402912		e8694f0400		CALL runtime.morestack_noctxt(SB)	
  0x402917		e9e4feffff		JMP runtime.f64hash(SB)			

TEXT runtime.c64hash(SB) /usr/local/go/src/runtime/alg.go
func c64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x402920		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402929		483b6110		CMPQ 0x10(CX), SP	
  0x40292d		7658			JBE 0x402987		
  0x40292f		4883ec20		SUBQ $0x20, SP		
  0x402933		48896c2418		MOVQ BP, 0x18(SP)	
  0x402938		488d6c2418		LEAQ 0x18(SP), BP	
	return f32hash(unsafe.Pointer(&x[1]), f32hash(unsafe.Pointer(&x[0]), h))
  0x40293d		488b442428		MOVQ 0x28(SP), AX		
  0x402942		8400			TESTB AL, 0(AX)			
  0x402944		48890424		MOVQ AX, 0(SP)			
  0x402948		488b4c2430		MOVQ 0x30(SP), CX		
  0x40294d		48894c2408		MOVQ CX, 0x8(SP)		
  0x402952		e889fdffff		CALL runtime.f32hash(SB)	
  0x402957		488b442428		MOVQ 0x28(SP), AX		
  0x40295c		4883c004		ADDQ $0x4, AX			
  0x402960		488b4c2410		MOVQ 0x10(SP), CX		
  0x402965		48890424		MOVQ AX, 0(SP)			
  0x402969		48894c2408		MOVQ CX, 0x8(SP)		
  0x40296e		e86dfdffff		CALL runtime.f32hash(SB)	
  0x402973		488b442410		MOVQ 0x10(SP), AX		
  0x402978		4889442438		MOVQ AX, 0x38(SP)		
  0x40297d		488b6c2418		MOVQ 0x18(SP), BP		
  0x402982		4883c420		ADDQ $0x20, SP			
  0x402986		c3			RET				
func c64hash(p unsafe.Pointer, h uintptr) uintptr {
  0x402987		e8f44e0400		CALL runtime.morestack_noctxt(SB)	
  0x40298c		eb92			JMP runtime.c64hash(SB)			

TEXT runtime.c128hash(SB) /usr/local/go/src/runtime/alg.go
func c128hash(p unsafe.Pointer, h uintptr) uintptr {
  0x402990		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402999		483b6110		CMPQ 0x10(CX), SP	
  0x40299d		7658			JBE 0x4029f7		
  0x40299f		4883ec20		SUBQ $0x20, SP		
  0x4029a3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4029a8		488d6c2418		LEAQ 0x18(SP), BP	
	return f64hash(unsafe.Pointer(&x[1]), f64hash(unsafe.Pointer(&x[0]), h))
  0x4029ad		488b442428		MOVQ 0x28(SP), AX		
  0x4029b2		8400			TESTB AL, 0(AX)			
  0x4029b4		48890424		MOVQ AX, 0(SP)			
  0x4029b8		488b4c2430		MOVQ 0x30(SP), CX		
  0x4029bd		48894c2408		MOVQ CX, 0x8(SP)		
  0x4029c2		e839feffff		CALL runtime.f64hash(SB)	
  0x4029c7		488b442428		MOVQ 0x28(SP), AX		
  0x4029cc		4883c008		ADDQ $0x8, AX			
  0x4029d0		488b4c2410		MOVQ 0x10(SP), CX		
  0x4029d5		48890424		MOVQ AX, 0(SP)			
  0x4029d9		48894c2408		MOVQ CX, 0x8(SP)		
  0x4029de		e81dfeffff		CALL runtime.f64hash(SB)	
  0x4029e3		488b442410		MOVQ 0x10(SP), AX		
  0x4029e8		4889442438		MOVQ AX, 0x38(SP)		
  0x4029ed		488b6c2418		MOVQ 0x18(SP), BP		
  0x4029f2		4883c420		ADDQ $0x20, SP			
  0x4029f6		c3			RET				
func c128hash(p unsafe.Pointer, h uintptr) uintptr {
  0x4029f7		e8844e0400		CALL runtime.morestack_noctxt(SB)	
  0x4029fc		eb92			JMP runtime.c128hash(SB)		

TEXT runtime.interhash(SB) /usr/local/go/src/runtime/alg.go
func interhash(p unsafe.Pointer, h uintptr) uintptr {
  0x402a00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402a09		483b6110		CMPQ 0x10(CX), SP	
  0x402a0d		0f8650010000		JBE 0x402b63		
  0x402a13		4883ec40		SUBQ $0x40, SP		
  0x402a17		48896c2438		MOVQ BP, 0x38(SP)	
  0x402a1c		488d6c2438		LEAQ 0x38(SP), BP	
	tab := a.tab
  0x402a21		488b442448		MOVQ 0x48(SP), AX	
  0x402a26		488b08			MOVQ 0(AX), CX		
	if tab == nil {
  0x402a29		4885c9			TESTQ CX, CX		
  0x402a2c		0f84aa000000		JE 0x402adc		
	t := tab._type
  0x402a32		488b4908		MOVQ 0x8(CX), CX	
	fn := t.alg.hash
  0x402a36		488b5918		MOVQ 0x18(CX), BX	
  0x402a3a		488b13			MOVQ 0(BX), DX		
	if fn == nil {
  0x402a3d		4885d2			TESTQ DX, DX		
  0x402a40		0f84aa000000		JE 0x402af0		
	if isDirectIface(t) {
  0x402a46		90			NOPL			
	return t.kind&kindDirectIface != 0
  0x402a47		0fb64917		MOVZX 0x17(CX), CX	
  0x402a4b		f6c120			TESTL $0x20, CL		
	if isDirectIface(t) {
  0x402a4e		7446			JE 0x402a96		
		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
  0x402a50		4883c008		ADDQ $0x8, AX			
  0x402a54		48890424		MOVQ AX, 0(SP)			
  0x402a58		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x402a62		488b4c2450		MOVQ 0x50(SP), CX		
  0x402a67		4831c8			XORQ CX, AX			
  0x402a6a		4889442408		MOVQ AX, 0x8(SP)		
  0x402a6f		488b02			MOVQ 0(DX), AX			
  0x402a72		ffd0			CALL AX				
  0x402a74		488b442410		MOVQ 0x10(SP), AX		
  0x402a79		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x402a83		480fafc8		IMULQ AX, CX			
  0x402a87		48894c2458		MOVQ CX, 0x58(SP)		
  0x402a8c		488b6c2438		MOVQ 0x38(SP), BP		
  0x402a91		4883c440		ADDQ $0x40, SP			
  0x402a95		c3			RET				
		return c1 * fn(a.data, h^c0)
  0x402a96		488b4008		MOVQ 0x8(AX), AX		
  0x402a9a		48890424		MOVQ AX, 0(SP)			
  0x402a9e		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x402aa8		488b4c2450		MOVQ 0x50(SP), CX		
  0x402aad		4831c8			XORQ CX, AX			
  0x402ab0		4889442408		MOVQ AX, 0x8(SP)		
  0x402ab5		488b02			MOVQ 0(DX), AX			
  0x402ab8		ffd0			CALL AX				
  0x402aba		488b442410		MOVQ 0x10(SP), AX		
  0x402abf		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x402ac9		480fafc1		IMULQ CX, AX			
  0x402acd		4889442458		MOVQ AX, 0x58(SP)		
  0x402ad2		488b6c2438		MOVQ 0x38(SP), BP		
  0x402ad7		4883c440		ADDQ $0x40, SP			
  0x402adb		c3			RET				
		return h
  0x402adc		488b442450		MOVQ 0x50(SP), AX	
  0x402ae1		4889442458		MOVQ AX, 0x58(SP)	
  0x402ae6		488b6c2438		MOVQ 0x38(SP), BP	
  0x402aeb		4883c440		ADDQ $0x40, SP		
  0x402aef		c3			RET			
		panic(errorString("hash of unhashable type " + t.string()))
  0x402af0		48890c24		MOVQ CX, 0(SP)				
  0x402af4		e8f7eb0300		CALL runtime.(*_type).string(SB)	
  0x402af9		488b442410		MOVQ 0x10(SP), AX			
  0x402afe		488b4c2408		MOVQ 0x8(SP), CX			
  0x402b03		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x402b0b		488d1598e30600		LEAQ 0x6e398(IP), DX			
  0x402b12		4889542408		MOVQ DX, 0x8(SP)			
  0x402b17		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x402b20		48894c2418		MOVQ CX, 0x18(SP)			
  0x402b25		4889442420		MOVQ AX, 0x20(SP)			
  0x402b2a		e8b16e0300		CALL runtime.concatstring2(SB)		
  0x402b2f		488b442430		MOVQ 0x30(SP), AX			
  0x402b34		488b4c2428		MOVQ 0x28(SP), CX			
  0x402b39		48890c24		MOVQ CX, 0(SP)				
  0x402b3d		4889442408		MOVQ AX, 0x8(SP)			
  0x402b42		e879570000		CALL runtime.convTstring(SB)		
  0x402b47		488b442410		MOVQ 0x10(SP), AX			
  0x402b4c		488d0d8dc40500		LEAQ 0x5c48d(IP), CX			
  0x402b53		48890c24		MOVQ CX, 0(SP)				
  0x402b57		4889442408		MOVQ AX, 0x8(SP)			
  0x402b5c		e84f030200		CALL runtime.gopanic(SB)		
  0x402b61		0f0b			UD2					
func interhash(p unsafe.Pointer, h uintptr) uintptr {
  0x402b63		e8184d0400		CALL runtime.morestack_noctxt(SB)	
  0x402b68		e993feffff		JMP runtime.interhash(SB)		

TEXT runtime.nilinterhash(SB) /usr/local/go/src/runtime/alg.go
func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {
  0x402b70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402b79		483b6110		CMPQ 0x10(CX), SP	
  0x402b7d		0f864c010000		JBE 0x402ccf		
  0x402b83		4883ec40		SUBQ $0x40, SP		
  0x402b87		48896c2438		MOVQ BP, 0x38(SP)	
  0x402b8c		488d6c2438		LEAQ 0x38(SP), BP	
	t := a._type
  0x402b91		488b442448		MOVQ 0x48(SP), AX	
  0x402b96		488b08			MOVQ 0(AX), CX		
	if t == nil {
  0x402b99		4885c9			TESTQ CX, CX		
  0x402b9c		0f84a6000000		JE 0x402c48		
	fn := t.alg.hash
  0x402ba2		488b5918		MOVQ 0x18(CX), BX	
  0x402ba6		488b13			MOVQ 0(BX), DX		
	if fn == nil {
  0x402ba9		4885d2			TESTQ DX, DX		
  0x402bac		0f84aa000000		JE 0x402c5c		
	if isDirectIface(t) {
  0x402bb2		90			NOPL			
	return t.kind&kindDirectIface != 0
  0x402bb3		0fb64917		MOVZX 0x17(CX), CX	
  0x402bb7		f6c120			TESTL $0x20, CL		
	if isDirectIface(t) {
  0x402bba		7446			JE 0x402c02		
		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
  0x402bbc		4883c008		ADDQ $0x8, AX			
  0x402bc0		48890424		MOVQ AX, 0(SP)			
  0x402bc4		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x402bce		488b4c2450		MOVQ 0x50(SP), CX		
  0x402bd3		4831c8			XORQ CX, AX			
  0x402bd6		4889442408		MOVQ AX, 0x8(SP)		
  0x402bdb		488b02			MOVQ 0(DX), AX			
  0x402bde		ffd0			CALL AX				
  0x402be0		488b442410		MOVQ 0x10(SP), AX		
  0x402be5		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x402bef		480fafc8		IMULQ AX, CX			
  0x402bf3		48894c2458		MOVQ CX, 0x58(SP)		
  0x402bf8		488b6c2438		MOVQ 0x38(SP), BP		
  0x402bfd		4883c440		ADDQ $0x40, SP			
  0x402c01		c3			RET				
		return c1 * fn(a.data, h^c0)
  0x402c02		488b4008		MOVQ 0x8(AX), AX		
  0x402c06		48890424		MOVQ AX, 0(SP)			
  0x402c0a		48b821a6566aa16e7500	MOVQ $0x756ea16a56a621, AX	
  0x402c14		488b4c2450		MOVQ 0x50(SP), CX		
  0x402c19		4831c8			XORQ CX, AX			
  0x402c1c		4889442408		MOVQ AX, 0x8(SP)		
  0x402c21		488b02			MOVQ 0(DX), AX			
  0x402c24		ffd0			CALL AX				
  0x402c26		488b442410		MOVQ 0x10(SP), AX		
  0x402c2b		48b9bf638fbb6bef5200	MOVQ $0x52ef6bbb8f63bf, CX	
  0x402c35		480fafc1		IMULQ CX, AX			
  0x402c39		4889442458		MOVQ AX, 0x58(SP)		
  0x402c3e		488b6c2438		MOVQ 0x38(SP), BP		
  0x402c43		4883c440		ADDQ $0x40, SP			
  0x402c47		c3			RET				
		return h
  0x402c48		488b442450		MOVQ 0x50(SP), AX	
  0x402c4d		4889442458		MOVQ AX, 0x58(SP)	
  0x402c52		488b6c2438		MOVQ 0x38(SP), BP	
  0x402c57		4883c440		ADDQ $0x40, SP		
  0x402c5b		c3			RET			
		panic(errorString("hash of unhashable type " + t.string()))
  0x402c5c		48890c24		MOVQ CX, 0(SP)				
  0x402c60		e88bea0300		CALL runtime.(*_type).string(SB)	
  0x402c65		488b442410		MOVQ 0x10(SP), AX			
  0x402c6a		488b4c2408		MOVQ 0x8(SP), CX			
  0x402c6f		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x402c77		488d152ce20600		LEAQ 0x6e22c(IP), DX			
  0x402c7e		4889542408		MOVQ DX, 0x8(SP)			
  0x402c83		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x402c8c		48894c2418		MOVQ CX, 0x18(SP)			
  0x402c91		4889442420		MOVQ AX, 0x20(SP)			
  0x402c96		e8456d0300		CALL runtime.concatstring2(SB)		
  0x402c9b		488b442430		MOVQ 0x30(SP), AX			
  0x402ca0		488b4c2428		MOVQ 0x28(SP), CX			
  0x402ca5		48890c24		MOVQ CX, 0(SP)				
  0x402ca9		4889442408		MOVQ AX, 0x8(SP)			
  0x402cae		e80d560000		CALL runtime.convTstring(SB)		
  0x402cb3		488b442410		MOVQ 0x10(SP), AX			
  0x402cb8		488d0d21c30500		LEAQ 0x5c321(IP), CX			
  0x402cbf		48890c24		MOVQ CX, 0(SP)				
  0x402cc3		4889442408		MOVQ AX, 0x8(SP)			
  0x402cc8		e8e3010200		CALL runtime.gopanic(SB)		
  0x402ccd		0f0b			UD2					
func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {
  0x402ccf		e8ac4b0400		CALL runtime.morestack_noctxt(SB)	
  0x402cd4		e997feffff		JMP runtime.nilinterhash(SB)		

TEXT runtime.memequal0(SB) /usr/local/go/src/runtime/alg.go
	return true
  0x402ce0		c644241801		MOVB $0x1, 0x18(SP)	
  0x402ce5		c3			RET			

TEXT runtime.memequal8(SB) /usr/local/go/src/runtime/alg.go
	return *(*int8)(p) == *(*int8)(q)
  0x402cf0		488b442410		MOVQ 0x10(SP), AX	
  0x402cf5		0fb600			MOVZX 0(AX), AX		
  0x402cf8		488b4c2408		MOVQ 0x8(SP), CX	
  0x402cfd		3801			CMPB AL, 0(CX)		
  0x402cff		0f94442418		SETE 0x18(SP)		
  0x402d04		c3			RET			

TEXT runtime.memequal16(SB) /usr/local/go/src/runtime/alg.go
	return *(*int16)(p) == *(*int16)(q)
  0x402d10		488b442410		MOVQ 0x10(SP), AX	
  0x402d15		0fb700			MOVZX 0(AX), AX		
  0x402d18		488b4c2408		MOVQ 0x8(SP), CX	
  0x402d1d		663901			CMPW AX, 0(CX)		
  0x402d20		0f94442418		SETE 0x18(SP)		
  0x402d25		c3			RET			

TEXT runtime.memequal32(SB) /usr/local/go/src/runtime/alg.go
	return *(*int32)(p) == *(*int32)(q)
  0x402d30		488b442410		MOVQ 0x10(SP), AX	
  0x402d35		8b00			MOVL 0(AX), AX		
  0x402d37		488b4c2408		MOVQ 0x8(SP), CX	
  0x402d3c		3901			CMPL AX, 0(CX)		
  0x402d3e		0f94442418		SETE 0x18(SP)		
  0x402d43		c3			RET			

TEXT runtime.memequal64(SB) /usr/local/go/src/runtime/alg.go
	return *(*int64)(p) == *(*int64)(q)
  0x402d50		488b442410		MOVQ 0x10(SP), AX	
  0x402d55		488b00			MOVQ 0(AX), AX		
  0x402d58		488b4c2408		MOVQ 0x8(SP), CX	
  0x402d5d		483901			CMPQ AX, 0(CX)		
  0x402d60		0f94442418		SETE 0x18(SP)		
  0x402d65		c3			RET			

TEXT runtime.memequal128(SB) /usr/local/go/src/runtime/alg.go
	return *(*[2]int64)(p) == *(*[2]int64)(q)
  0x402d70		488b442410		MOVQ 0x10(SP), AX	
  0x402d75		488b08			MOVQ 0(AX), CX		
  0x402d78		488b542408		MOVQ 0x8(SP), DX	
  0x402d7d		48390a			CMPQ CX, 0(DX)		
  0x402d80		7510			JNE 0x402d92		
  0x402d82		488b4a08		MOVQ 0x8(DX), CX	
  0x402d86		48394808		CMPQ CX, 0x8(AX)	
  0x402d8a		0f94c0			SETE AL			
  0x402d8d		88442418		MOVB AL, 0x18(SP)	
  0x402d91		c3			RET			
  0x402d92		31c0			XORL AX, AX		
  0x402d94		ebf7			JMP 0x402d8d		

TEXT runtime.f32equal(SB) /usr/local/go/src/runtime/alg.go
	return *(*float32)(p) == *(*float32)(q)
  0x402da0		488b442408		MOVQ 0x8(SP), AX	
  0x402da5		f30f1000		MOVSS 0(AX), X0		
  0x402da9		488b442410		MOVQ 0x10(SP), AX	
  0x402dae		f30f1008		MOVSS 0(AX), X1		
  0x402db2		0f2ec1			UCOMISS X1, X0		
  0x402db5		0f94c1			SETE CL			
  0x402db8		0f9bc0			SETNP AL		
  0x402dbb		21c1			ANDL AX, CX		
  0x402dbd		884c2418		MOVB CL, 0x18(SP)	
  0x402dc1		c3			RET			

TEXT runtime.f64equal(SB) /usr/local/go/src/runtime/alg.go
	return *(*float64)(p) == *(*float64)(q)
  0x402dd0		488b442408		MOVQ 0x8(SP), AX	
  0x402dd5		f20f1000		MOVSD_XMM 0(AX), X0	
  0x402dd9		488b442410		MOVQ 0x10(SP), AX	
  0x402dde		f20f1008		MOVSD_XMM 0(AX), X1	
  0x402de2		660f2ec1		UCOMISD X1, X0		
  0x402de6		0f94c1			SETE CL			
  0x402de9		0f9bc0			SETNP AL		
  0x402dec		21c1			ANDL AX, CX		
  0x402dee		884c2418		MOVB CL, 0x18(SP)	
  0x402df2		c3			RET			

TEXT runtime.c64equal(SB) /usr/local/go/src/runtime/alg.go
	return *(*complex64)(p) == *(*complex64)(q)
  0x402e00		488b442408		MOVQ 0x8(SP), AX	
  0x402e05		f30f104004		MOVSS 0x4(AX), X0	
  0x402e0a		f30f1008		MOVSS 0(AX), X1		
  0x402e0e		488b442410		MOVQ 0x10(SP), AX	
  0x402e13		f30f105004		MOVSS 0x4(AX), X2	
  0x402e18		f30f1018		MOVSS 0(AX), X3		
  0x402e1c		0f2ecb			UCOMISS X3, X1		
  0x402e1f		0f94c1			SETE CL			
  0x402e22		0f9bc0			SETNP AL		
  0x402e25		21c1			ANDL AX, CX		
  0x402e27		0f2ec2			UCOMISS X2, X0		
  0x402e2a		0f94c2			SETE DL			
  0x402e2d		0f9bc0			SETNP AL		
  0x402e30		21c2			ANDL AX, DX		
  0x402e32		21d1			ANDL DX, CX		
  0x402e34		884c2418		MOVB CL, 0x18(SP)	
  0x402e38		c3			RET			

TEXT runtime.c128equal(SB) /usr/local/go/src/runtime/alg.go
	return *(*complex128)(p) == *(*complex128)(q)
  0x402e40		488b442408		MOVQ 0x8(SP), AX	
  0x402e45		f20f104008		MOVSD_XMM 0x8(AX), X0	
  0x402e4a		f20f1008		MOVSD_XMM 0(AX), X1	
  0x402e4e		488b442410		MOVQ 0x10(SP), AX	
  0x402e53		f20f105008		MOVSD_XMM 0x8(AX), X2	
  0x402e58		f20f1018		MOVSD_XMM 0(AX), X3	
  0x402e5c		660f2ecb		UCOMISD X3, X1		
  0x402e60		0f94c1			SETE CL			
  0x402e63		0f9bc0			SETNP AL		
  0x402e66		21c1			ANDL AX, CX		
  0x402e68		660f2ec2		UCOMISD X2, X0		
  0x402e6c		0f94c2			SETE DL			
  0x402e6f		0f9bc0			SETNP AL		
  0x402e72		21c2			ANDL AX, DX		
  0x402e74		21d1			ANDL DX, CX		
  0x402e76		884c2418		MOVB CL, 0x18(SP)	
  0x402e7a		c3			RET			

TEXT runtime.strequal(SB) /usr/local/go/src/runtime/alg.go
func strequal(p, q unsafe.Pointer) bool {
  0x402e80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402e89		483b6110		CMPQ 0x10(CX), SP	
  0x402e8d		7652			JBE 0x402ee1		
  0x402e8f		4883ec28		SUBQ $0x28, SP		
  0x402e93		48896c2420		MOVQ BP, 0x20(SP)	
  0x402e98		488d6c2420		LEAQ 0x20(SP), BP	
	return *(*string)(p) == *(*string)(q)
  0x402e9d		488b442430		MOVQ 0x30(SP), AX		
  0x402ea2		488b4808		MOVQ 0x8(AX), CX		
  0x402ea6		488b00			MOVQ 0(AX), AX			
  0x402ea9		488b542438		MOVQ 0x38(SP), DX		
  0x402eae		488b1a			MOVQ 0(DX), BX			
  0x402eb1		48394a08		CMPQ CX, 0x8(DX)		
  0x402eb5		7410			JE 0x402ec7			
  0x402eb7		31c0			XORL AX, AX			
  0x402eb9		88442440		MOVB AL, 0x40(SP)		
  0x402ebd		488b6c2420		MOVQ 0x20(SP), BP		
  0x402ec2		4883c428		ADDQ $0x28, SP			
  0x402ec6		c3			RET				
  0x402ec7		48890424		MOVQ AX, 0(SP)			
  0x402ecb		48895c2408		MOVQ BX, 0x8(SP)		
  0x402ed0		48894c2410		MOVQ CX, 0x10(SP)		
  0x402ed5		e846f3ffff		CALL runtime.memequal(SB)	
  0x402eda		0fb6442418		MOVZX 0x18(SP), AX		
  0x402edf		ebd8			JMP 0x402eb9			
func strequal(p, q unsafe.Pointer) bool {
  0x402ee1		e89a490400		CALL runtime.morestack_noctxt(SB)	
  0x402ee6		eb98			JMP runtime.strequal(SB)		

TEXT runtime.interequal(SB) /usr/local/go/src/runtime/alg.go
func interequal(p, q unsafe.Pointer) bool {
  0x402ef0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402ef9		483b6110		CMPQ 0x10(CX), SP	
  0x402efd		7652			JBE 0x402f51		
  0x402eff		4883ec28		SUBQ $0x28, SP		
  0x402f03		48896c2420		MOVQ BP, 0x20(SP)	
  0x402f08		488d6c2420		LEAQ 0x20(SP), BP	
	x := *(*iface)(p)
  0x402f0d		488b442430		MOVQ 0x30(SP), AX	
  0x402f12		488b4808		MOVQ 0x8(AX), CX	
  0x402f16		488b00			MOVQ 0(AX), AX		
	y := *(*iface)(q)
  0x402f19		488b542438		MOVQ 0x38(SP), DX	
  0x402f1e		488b5a08		MOVQ 0x8(DX), BX	
  0x402f22		483902			CMPQ AX, 0(DX)		
	return x.tab == y.tab && ifaceeq(x.tab, x.data, y.data)
  0x402f25		7410			JE 0x402f37			
  0x402f27		31c0			XORL AX, AX			
  0x402f29		88442440		MOVB AL, 0x40(SP)		
  0x402f2d		488b6c2420		MOVQ 0x20(SP), BP		
  0x402f32		4883c428		ADDQ $0x28, SP			
  0x402f36		c3			RET				
  0x402f37		48890424		MOVQ AX, 0(SP)			
  0x402f3b		48894c2408		MOVQ CX, 0x8(SP)		
  0x402f40		48895c2410		MOVQ BX, 0x10(SP)		
  0x402f45		e8b6010000		CALL runtime.ifaceeq(SB)	
  0x402f4a		0fb6442418		MOVZX 0x18(SP), AX		
  0x402f4f		ebd8			JMP 0x402f29			
func interequal(p, q unsafe.Pointer) bool {
  0x402f51		e82a490400		CALL runtime.morestack_noctxt(SB)	
  0x402f56		eb98			JMP runtime.interequal(SB)		

TEXT runtime.nilinterequal(SB) /usr/local/go/src/runtime/alg.go
func nilinterequal(p, q unsafe.Pointer) bool {
  0x402f60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402f69		483b6110		CMPQ 0x10(CX), SP	
  0x402f6d		7652			JBE 0x402fc1		
  0x402f6f		4883ec28		SUBQ $0x28, SP		
  0x402f73		48896c2420		MOVQ BP, 0x20(SP)	
  0x402f78		488d6c2420		LEAQ 0x20(SP), BP	
	x := *(*eface)(p)
  0x402f7d		488b442430		MOVQ 0x30(SP), AX	
  0x402f82		488b4808		MOVQ 0x8(AX), CX	
  0x402f86		488b00			MOVQ 0(AX), AX		
	y := *(*eface)(q)
  0x402f89		488b542438		MOVQ 0x38(SP), DX	
  0x402f8e		488b5a08		MOVQ 0x8(DX), BX	
  0x402f92		483902			CMPQ AX, 0(DX)		
	return x._type == y._type && efaceeq(x._type, x.data, y.data)
  0x402f95		7410			JE 0x402fa7			
  0x402f97		31c0			XORL AX, AX			
  0x402f99		88442440		MOVB AL, 0x40(SP)		
  0x402f9d		488b6c2420		MOVQ 0x20(SP), BP		
  0x402fa2		4883c428		ADDQ $0x28, SP			
  0x402fa6		c3			RET				
  0x402fa7		48890424		MOVQ AX, 0(SP)			
  0x402fab		48894c2408		MOVQ CX, 0x8(SP)		
  0x402fb0		48895c2410		MOVQ BX, 0x10(SP)		
  0x402fb5		e816000000		CALL runtime.efaceeq(SB)	
  0x402fba		0fb6442418		MOVZX 0x18(SP), AX		
  0x402fbf		ebd8			JMP 0x402f99			
func nilinterequal(p, q unsafe.Pointer) bool {
  0x402fc1		e8ba480400		CALL runtime.morestack_noctxt(SB)	
  0x402fc6		eb98			JMP runtime.nilinterequal(SB)		

TEXT runtime.efaceeq(SB) /usr/local/go/src/runtime/alg.go
func efaceeq(t *_type, x, y unsafe.Pointer) bool {
  0x402fd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x402fd9		483b6110		CMPQ 0x10(CX), SP	
  0x402fdd		0f8608010000		JBE 0x4030eb		
  0x402fe3		4883ec40		SUBQ $0x40, SP		
  0x402fe7		48896c2438		MOVQ BP, 0x38(SP)	
  0x402fec		488d6c2438		LEAQ 0x38(SP), BP	
	if t == nil {
  0x402ff1		488b442448		MOVQ 0x48(SP), AX	
  0x402ff6		4885c0			TESTQ AX, AX		
  0x402ff9		746e			JE 0x403069		
	eq := t.alg.equal
  0x402ffb		488b4818		MOVQ 0x18(AX), CX	
  0x402fff		488b5108		MOVQ 0x8(CX), DX	
	if eq == nil {
  0x403003		4885d2			TESTQ DX, DX		
  0x403006		7470			JE 0x403078		
	if isDirectIface(t) {
  0x403008		90			NOPL			
	return t.kind&kindDirectIface != 0
  0x403009		0fb64017		MOVZX 0x17(AX), AX	
  0x40300d		a820			TESTL $0x20, AL		
	if isDirectIface(t) {
  0x40300f		742d			JE 0x40303e		
		return eq(noescape(unsafe.Pointer(&x)), noescape(unsafe.Pointer(&y)))
  0x403011		90			NOPL			
  0x403012		90			NOPL			
  0x403013		488d442450		LEAQ 0x50(SP), AX	
  0x403018		48890424		MOVQ AX, 0(SP)		
  0x40301c		488d442458		LEAQ 0x58(SP), AX	
  0x403021		4889442408		MOVQ AX, 0x8(SP)	
  0x403026		488b02			MOVQ 0(DX), AX		
  0x403029		ffd0			CALL AX			
  0x40302b		0fb6442410		MOVZX 0x10(SP), AX	
  0x403030		88442460		MOVB AL, 0x60(SP)	
  0x403034		488b6c2438		MOVQ 0x38(SP), BP	
  0x403039		4883c440		ADDQ $0x40, SP		
  0x40303d		c3			RET			
	return eq(x, y)
  0x40303e		488b442450		MOVQ 0x50(SP), AX	
  0x403043		48890424		MOVQ AX, 0(SP)		
  0x403047		488b442458		MOVQ 0x58(SP), AX	
  0x40304c		4889442408		MOVQ AX, 0x8(SP)	
  0x403051		488b02			MOVQ 0(DX), AX		
  0x403054		ffd0			CALL AX			
  0x403056		0fb6442410		MOVZX 0x10(SP), AX	
  0x40305b		88442460		MOVB AL, 0x60(SP)	
  0x40305f		488b6c2438		MOVQ 0x38(SP), BP	
  0x403064		4883c440		ADDQ $0x40, SP		
  0x403068		c3			RET			
		return true
  0x403069		c644246001		MOVB $0x1, 0x60(SP)	
  0x40306e		488b6c2438		MOVQ 0x38(SP), BP	
  0x403073		4883c440		ADDQ $0x40, SP		
  0x403077		c3			RET			
		panic(errorString("comparing uncomparable type " + t.string()))
  0x403078		48890424		MOVQ AX, 0(SP)				
  0x40307c		e86fe60300		CALL runtime.(*_type).string(SB)	
  0x403081		488b442410		MOVQ 0x10(SP), AX			
  0x403086		488b4c2408		MOVQ 0x8(SP), CX			
  0x40308b		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x403093		488d15c8e50600		LEAQ 0x6e5c8(IP), DX			
  0x40309a		4889542408		MOVQ DX, 0x8(SP)			
  0x40309f		48c74424101c000000	MOVQ $0x1c, 0x10(SP)			
  0x4030a8		48894c2418		MOVQ CX, 0x18(SP)			
  0x4030ad		4889442420		MOVQ AX, 0x20(SP)			
  0x4030b2		e829690300		CALL runtime.concatstring2(SB)		
  0x4030b7		488b442430		MOVQ 0x30(SP), AX			
  0x4030bc		488b4c2428		MOVQ 0x28(SP), CX			
  0x4030c1		48890c24		MOVQ CX, 0(SP)				
  0x4030c5		4889442408		MOVQ AX, 0x8(SP)			
  0x4030ca		e8f1510000		CALL runtime.convTstring(SB)		
  0x4030cf		488b442410		MOVQ 0x10(SP), AX			
  0x4030d4		488d0d05bf0500		LEAQ 0x5bf05(IP), CX			
  0x4030db		48890c24		MOVQ CX, 0(SP)				
  0x4030df		4889442408		MOVQ AX, 0x8(SP)			
  0x4030e4		e8c7fd0100		CALL runtime.gopanic(SB)		
  0x4030e9		0f0b			UD2					
func efaceeq(t *_type, x, y unsafe.Pointer) bool {
  0x4030eb		e890470400		CALL runtime.morestack_noctxt(SB)	
  0x4030f0		e9dbfeffff		JMP runtime.efaceeq(SB)			

TEXT runtime.ifaceeq(SB) /usr/local/go/src/runtime/alg.go
func ifaceeq(tab *itab, x, y unsafe.Pointer) bool {
  0x403100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403109		483b6110		CMPQ 0x10(CX), SP	
  0x40310d		0f860c010000		JBE 0x40321f		
  0x403113		4883ec40		SUBQ $0x40, SP		
  0x403117		48896c2438		MOVQ BP, 0x38(SP)	
  0x40311c		488d6c2438		LEAQ 0x38(SP), BP	
	if tab == nil {
  0x403121		488b442448		MOVQ 0x48(SP), AX	
  0x403126		4885c0			TESTQ AX, AX		
  0x403129		7472			JE 0x40319d		
	t := tab._type
  0x40312b		488b4008		MOVQ 0x8(AX), AX	
	eq := t.alg.equal
  0x40312f		488b4818		MOVQ 0x18(AX), CX	
  0x403133		488b5108		MOVQ 0x8(CX), DX	
	if eq == nil {
  0x403137		4885d2			TESTQ DX, DX		
  0x40313a		7470			JE 0x4031ac		
	if isDirectIface(t) {
  0x40313c		90			NOPL			
	return t.kind&kindDirectIface != 0
  0x40313d		0fb64017		MOVZX 0x17(AX), AX	
  0x403141		a820			TESTL $0x20, AL		
	if isDirectIface(t) {
  0x403143		742d			JE 0x403172		
		return eq(noescape(unsafe.Pointer(&x)), noescape(unsafe.Pointer(&y)))
  0x403145		90			NOPL			
  0x403146		90			NOPL			
  0x403147		488d442450		LEAQ 0x50(SP), AX	
  0x40314c		48890424		MOVQ AX, 0(SP)		
  0x403150		488d442458		LEAQ 0x58(SP), AX	
  0x403155		4889442408		MOVQ AX, 0x8(SP)	
  0x40315a		488b02			MOVQ 0(DX), AX		
  0x40315d		ffd0			CALL AX			
  0x40315f		0fb6442410		MOVZX 0x10(SP), AX	
  0x403164		88442460		MOVB AL, 0x60(SP)	
  0x403168		488b6c2438		MOVQ 0x38(SP), BP	
  0x40316d		4883c440		ADDQ $0x40, SP		
  0x403171		c3			RET			
	return eq(x, y)
  0x403172		488b442450		MOVQ 0x50(SP), AX	
  0x403177		48890424		MOVQ AX, 0(SP)		
  0x40317b		488b442458		MOVQ 0x58(SP), AX	
  0x403180		4889442408		MOVQ AX, 0x8(SP)	
  0x403185		488b02			MOVQ 0(DX), AX		
  0x403188		ffd0			CALL AX			
  0x40318a		0fb6442410		MOVZX 0x10(SP), AX	
  0x40318f		88442460		MOVB AL, 0x60(SP)	
  0x403193		488b6c2438		MOVQ 0x38(SP), BP	
  0x403198		4883c440		ADDQ $0x40, SP		
  0x40319c		c3			RET			
		return true
  0x40319d		c644246001		MOVB $0x1, 0x60(SP)	
  0x4031a2		488b6c2438		MOVQ 0x38(SP), BP	
  0x4031a7		4883c440		ADDQ $0x40, SP		
  0x4031ab		c3			RET			
		panic(errorString("comparing uncomparable type " + t.string()))
  0x4031ac		48890424		MOVQ AX, 0(SP)				
  0x4031b0		e83be50300		CALL runtime.(*_type).string(SB)	
  0x4031b5		488b442410		MOVQ 0x10(SP), AX			
  0x4031ba		488b4c2408		MOVQ 0x8(SP), CX			
  0x4031bf		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x4031c7		488d1594e40600		LEAQ 0x6e494(IP), DX			
  0x4031ce		4889542408		MOVQ DX, 0x8(SP)			
  0x4031d3		48c74424101c000000	MOVQ $0x1c, 0x10(SP)			
  0x4031dc		48894c2418		MOVQ CX, 0x18(SP)			
  0x4031e1		4889442420		MOVQ AX, 0x20(SP)			
  0x4031e6		e8f5670300		CALL runtime.concatstring2(SB)		
  0x4031eb		488b442430		MOVQ 0x30(SP), AX			
  0x4031f0		488b4c2428		MOVQ 0x28(SP), CX			
  0x4031f5		48890c24		MOVQ CX, 0(SP)				
  0x4031f9		4889442408		MOVQ AX, 0x8(SP)			
  0x4031fe		e8bd500000		CALL runtime.convTstring(SB)		
  0x403203		488b442410		MOVQ 0x10(SP), AX			
  0x403208		488d0dd1bd0500		LEAQ 0x5bdd1(IP), CX			
  0x40320f		48890c24		MOVQ CX, 0(SP)				
  0x403213		4889442408		MOVQ AX, 0x8(SP)			
  0x403218		e893fc0100		CALL runtime.gopanic(SB)		
  0x40321d		0f0b			UD2					
func ifaceeq(tab *itab, x, y unsafe.Pointer) bool {
  0x40321f		e85c460400		CALL runtime.morestack_noctxt(SB)	
  0x403224		e9d7feffff		JMP runtime.ifaceeq(SB)			

TEXT runtime.alginit(SB) /usr/local/go/src/runtime/alg.go
func alginit() {
  0x403230		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403239		483b6110		CMPQ 0x10(CX), SP	
  0x40323d		0f8684000000		JBE 0x4032c7		
  0x403243		4883ec20		SUBQ $0x20, SP		
  0x403247		48896c2418		MOVQ BP, 0x18(SP)	
  0x40324c		488d6c2418		LEAQ 0x18(SP), BP	
		cpu.X86.HasAES && // AESENC
  0x403251		803d289e0d0000		CMPB $0x0, internal/cpu.X86+64(SB)	
  0x403258		7412			JE 0x40326c				
		cpu.X86.HasSSSE3 && // PSHUFB
  0x40325a		803d2c9e0d0000		CMPB $0x0, internal/cpu.X86+77(SB)	
  0x403261		7409			JE 0x40326c				
		cpu.X86.HasSSE41 { // PINSR{D,Q}
  0x403263		803d249e0d0000		CMPB $0x0, internal/cpu.X86+78(SB)	
	if (GOARCH == "386" || GOARCH == "amd64") &&
  0x40326a		754c			JNE 0x4032b8		
	getRandomData((*[len(hashkey) * sys.PtrSize]byte)(unsafe.Pointer(&hashkey))[:])
  0x40326c		488d05cd9b0d00		LEAQ runtime.hashkey(SB), AX	
  0x403273		48890424		MOVQ AX, 0(SP)			
  0x403277		48c744240820000000	MOVQ $0x20, 0x8(SP)		
  0x403280		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x403289		e882e80100		CALL runtime.getRandomData(SB)	
	hashkey[0] |= 1 // make sure these numbers are odd
  0x40328e		48830daa9b0d0001	ORQ $0x1, runtime.hashkey(SB)	
	hashkey[1] |= 1
  0x403296		48830daa9b0d0001	ORQ $0x1, runtime.hashkey+8(SB)	
	hashkey[2] |= 1
  0x40329e		48830daa9b0d0001	ORQ $0x1, runtime.hashkey+16(SB)	
	hashkey[3] |= 1
  0x4032a6		48830daa9b0d0001	ORQ $0x1, runtime.hashkey+24(SB)	
}
  0x4032ae		488b6c2418		MOVQ 0x18(SP), BP	
  0x4032b3		4883c420		ADDQ $0x20, SP		
  0x4032b7		c3			RET			
		initAlgAES()
  0x4032b8		e823000000		CALL runtime.initAlgAES(SB)	
		return
  0x4032bd		488b6c2418		MOVQ 0x18(SP), BP	
  0x4032c2		4883c420		ADDQ $0x20, SP		
  0x4032c6		c3			RET			
func alginit() {
  0x4032c7		e8b4450400		CALL runtime.morestack_noctxt(SB)	
  0x4032cc		e95fffffff		JMP runtime.alginit(SB)			

TEXT runtime.initAlgAES(SB) /usr/local/go/src/runtime/alg.go
func initAlgAES() {
  0x4032e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4032e9		483b6110		CMPQ 0x10(CX), SP	
  0x4032ed		0f86af000000		JBE 0x4033a2		
  0x4032f3		4883ec20		SUBQ $0x20, SP		
  0x4032f7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4032fc		488d6c2418		LEAQ 0x18(SP), BP	
	useAeshash = true
  0x403301		c605ad990d0001		MOVB $0x1, runtime.useAeshash(SB)	
	algarray[alg_MEM32].hash = aeshash32
  0x403308		833d119b0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40330f		7556			JNE 0x403367				
  0x403311		488d0510040700		LEAQ 0x70410(IP), AX			
  0x403318		488905c1cb0b00		MOVQ AX, runtime.algarray+64(SB)	
	algarray[alg_MEM64].hash = aeshash64
  0x40331f		488d050a040700		LEAQ 0x7040a(IP), AX			
  0x403326		488905c3cb0b00		MOVQ AX, runtime.algarray+80(SB)	
	algarray[alg_STRING].hash = aeshashstr
  0x40332d		488d0504040700		LEAQ 0x70404(IP), AX			
  0x403334		488905d5cb0b00		MOVQ AX, runtime.algarray+112(SB)	
	getRandomData(aeskeysched[:])
  0x40333b		488d057e9c0d00		LEAQ runtime.aeskeysched(SB), AX	
  0x403342		48890424		MOVQ AX, 0(SP)				
  0x403346		48c744240880000000	MOVQ $0x80, 0x8(SP)			
  0x40334f		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x403358		e8b3e70100		CALL runtime.getRandomData(SB)		
}
  0x40335d		488b6c2418		MOVQ 0x18(SP), BP	
  0x403362		4883c420		ADDQ $0x20, SP		
  0x403366		c3			RET			
	algarray[alg_MEM32].hash = aeshash32
  0x403367		488d3d72cb0b00		LEAQ runtime.algarray+64(SB), DI	
  0x40336e		488d05b3030700		LEAQ 0x703b3(IP), AX			
  0x403375		e806630400		CALL runtime.gcWriteBarrier(SB)		
	algarray[alg_MEM64].hash = aeshash64
  0x40337a		488d3d6fcb0b00		LEAQ runtime.algarray+80(SB), DI	
  0x403381		488d05a8030700		LEAQ 0x703a8(IP), AX			
  0x403388		e8f3620400		CALL runtime.gcWriteBarrier(SB)		
	algarray[alg_STRING].hash = aeshashstr
  0x40338d		488d3d7ccb0b00		LEAQ runtime.algarray+112(SB), DI	
  0x403394		488d059d030700		LEAQ 0x7039d(IP), AX			
  0x40339b		e8e0620400		CALL runtime.gcWriteBarrier(SB)		
	algarray[alg_MEM32].hash = aeshash32
  0x4033a0		eb99			JMP 0x40333b		
func initAlgAES() {
  0x4033a2		e8d9440400		CALL runtime.morestack_noctxt(SB)	
  0x4033a7		e934ffffff		JMP runtime.initAlgAES(SB)		

TEXT runtime.atomicwb(SB) /usr/local/go/src/runtime/atomic_pointer.go
func atomicwb(ptr *unsafe.Pointer, new unsafe.Pointer) {
  0x4033b0		4883ec18		SUBQ $0x18, SP		
  0x4033b4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4033b9		488d6c2410		LEAQ 0x10(SP), BP	
	if !getg().m.p.ptr().wbBuf.putFast(*slot, uintptr(new)) {
  0x4033be		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4033c7		488b4030		MOVQ 0x30(AX), AX	
  0x4033cb		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x4033d2		8400			TESTB AL, 0(AX)		
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x4033d4		488b8820130000		MOVQ 0x1320(AX), CX	
	if !getg().m.p.ptr().wbBuf.putFast(*slot, uintptr(new)) {
  0x4033db		90			NOPL			
  0x4033dc		90			NOPL			
  0x4033dd		488b542420		MOVQ 0x20(SP), DX	
  0x4033e2		488b1a			MOVQ 0(DX), BX		
  0x4033e5		488b742428		MOVQ 0x28(SP), SI	
  0x4033ea		4889f7			MOVQ SI, DI		
	p[0] = old
  0x4033ed		488919			MOVQ BX, 0(CX)		
	p[1] = new
  0x4033f0		48897108		MOVQ SI, 0x8(CX)	
	b.next += 2 * sys.PtrSize
  0x4033f4		488b8820130000		MOVQ 0x1320(AX), CX	
  0x4033fb		4883c110		ADDQ $0x10, CX		
  0x4033ff		48898820130000		MOVQ CX, 0x1320(AX)	
	return b.next != b.end
  0x403406		48398828130000		CMPQ CX, 0x1328(AX)	
	if !getg().m.p.ptr().wbBuf.putFast(*slot, uintptr(new)) {
  0x40340d		740a			JE 0x403419		
  0x40340f		488b6c2410		MOVQ 0x10(SP), BP	
  0x403414		4883c418		ADDQ $0x18, SP		
  0x403418		c3			RET			
		wbBufFlush(slot, uintptr(new))
  0x403419		48891424		MOVQ DX, 0(SP)			
  0x40341d		48897c2408		MOVQ DI, 0x8(SP)		
  0x403422		e8d9d70100		CALL runtime.wbBufFlush(SB)	
  0x403427		ebe6			JMP 0x40340f			

TEXT runtime.atomicstorep(SB) /usr/local/go/src/runtime/atomic_pointer.go
func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {
  0x403430		4883ec18		SUBQ $0x18, SP		
  0x403434		48896c2410		MOVQ BP, 0x10(SP)	
  0x403439		488d6c2410		LEAQ 0x10(SP), BP	
	if writeBarrier.enabled {
  0x40343e		803ddb990d0000		CMPB $0x0, runtime.writeBarrier(SB)	
  0x403445		7518			JNE 0x40345f				
	atomic.StorepNoWB(noescape(ptr), new)
  0x403447		90			NOPL			
  0x403448		488b442428		MOVQ 0x28(SP), AX	
  0x40344d		488b4c2420		MOVQ 0x20(SP), CX	
  0x403452		488701			XCHGQ AX, 0(CX)		
}
  0x403455		488b6c2410		MOVQ 0x10(SP), BP	
  0x40345a		4883c418		ADDQ $0x18, SP		
  0x40345e		c3			RET			
		atomicwb((*unsafe.Pointer)(ptr), new)
  0x40345f		488b442420		MOVQ 0x20(SP), AX		
  0x403464		48890424		MOVQ AX, 0(SP)			
  0x403468		488b4c2428		MOVQ 0x28(SP), CX		
  0x40346d		48894c2408		MOVQ CX, 0x8(SP)		
  0x403472		e839ffffff		CALL runtime.atomicwb(SB)	
  0x403477		ebce			JMP 0x403447			

TEXT runtime.mmap(SB) /usr/local/go/src/runtime/cgo_mmap.go
func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {
  0x403480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x403489		483b6110		CMPQ 0x10(CX), SP	
  0x40348d		0f8652010000		JBE 0x4035e5		
  0x403493		4883ec70		SUBQ $0x70, SP		
  0x403497		48896c2468		MOVQ BP, 0x68(SP)	
  0x40349c		488d6c2468		LEAQ 0x68(SP), BP	
	if _cgo_mmap != nil {
  0x4034a1		48833d27e40b0000	CMPQ $0x0, _cgo_mmap(SB)	
  0x4034a9		0f84cb000000		JE 0x40357a			
		var ret uintptr
  0x4034af		48c744243000000000	MOVQ $0x0, 0x30(SP)	
		systemstack(func() {
  0x4034b8		0f57c0			XORPS X0, X0			
  0x4034bb		0f11442438		MOVUPS X0, 0x38(SP)		
  0x4034c0		0f11442448		MOVUPS X0, 0x48(SP)		
  0x4034c5		0f11442458		MOVUPS X0, 0x58(SP)		
  0x4034ca		488d05bf100400		LEAQ runtime.mmap.func1(SB), AX	
  0x4034d1		4889442438		MOVQ AX, 0x38(SP)		
  0x4034d6		488b442478		MOVQ 0x78(SP), AX		
  0x4034db		4889442440		MOVQ AX, 0x40(SP)		
  0x4034e0		488b842480000000	MOVQ 0x80(SP), AX		
  0x4034e8		4889442448		MOVQ AX, 0x48(SP)		
  0x4034ed		8b842488000000		MOVL 0x88(SP), AX		
  0x4034f4		89442450		MOVL AX, 0x50(SP)		
  0x4034f8		8b84248c000000		MOVL 0x8c(SP), AX		
  0x4034ff		89442454		MOVL AX, 0x54(SP)		
  0x403503		8b842490000000		MOVL 0x90(SP), AX		
  0x40350a		89442458		MOVL AX, 0x58(SP)		
  0x40350e		8b842494000000		MOVL 0x94(SP), AX		
  0x403515		8944245c		MOVL AX, 0x5c(SP)		
  0x403519		488d442430		LEAQ 0x30(SP), AX		
  0x40351e		4889442460		MOVQ AX, 0x60(SP)		
  0x403523		488d442438		LEAQ 0x38(SP), AX		
  0x403528		48890424		MOVQ AX, 0(SP)			
  0x40352c		e8ff410400		CALL runtime.systemstack(SB)	
		if ret < 4096 {
  0x403531		488b442430		MOVQ 0x30(SP), AX	
  0x403536		483d00100000		CMPQ $0x1000, AX	
  0x40353c		731e			JAE 0x40355c		
			return nil, int(ret)
  0x40353e		48c784249800000000000000	MOVQ $0x0, 0x98(SP)	
  0x40354a		48898424a0000000		MOVQ AX, 0xa0(SP)	
  0x403552		488b6c2468			MOVQ 0x68(SP), BP	
  0x403557		4883c470			ADDQ $0x70, SP		
  0x40355b		c3				RET			
		return unsafe.Pointer(ret), 0
  0x40355c		4889842498000000		MOVQ AX, 0x98(SP)	
  0x403564		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
  0x403570		488b6c2468			MOVQ 0x68(SP), BP	
  0x403575		4883c470			ADDQ $0x70, SP		
  0x403579		c3				RET			
	return sysMmap(addr, n, prot, flags, fd, off)
  0x40357a		488b442478		MOVQ 0x78(SP), AX		
  0x40357f		48890424		MOVQ AX, 0(SP)			
  0x403583		488b842480000000	MOVQ 0x80(SP), AX		
  0x40358b		4889442408		MOVQ AX, 0x8(SP)		
  0x403590		8b842488000000		MOVL 0x88(SP), AX		
  0x403597		89442410		MOVL AX, 0x10(SP)		
  0x40359b		8b84248c000000		MOVL 0x8c(SP), AX		
  0x4035a2		89442414		MOVL AX, 0x14(SP)		
  0x4035a6		8b842490000000		MOVL 0x90(SP), AX		
  0x4035ad		89442418		MOVL AX, 0x18(SP)		
  0x4035b1		8b842494000000		MOVL 0x94(SP), AX		
  0x4035b8		8944241c		MOVL AX, 0x1c(SP)		
  0x4035bc		e8af7d0400		CALL runtime.sysMmap(SB)	
  0x4035c1		488b442420		MOVQ 0x20(SP), AX		
  0x4035c6		488b4c2428		MOVQ 0x28(SP), CX		
  0x4035cb		4889842498000000	MOVQ AX, 0x98(SP)		
  0x4035d3		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x4035db		488b6c2468		MOVQ 0x68(SP), BP		
  0x4035e0		4883c470		ADDQ $0x70, SP			
  0x4035e4		c3			RET				
func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {
  0x4035e5		e896420400		CALL runtime.morestack_noctxt(SB)	
  0x4035ea		e991feffff		JMP runtime.mmap(SB)			

TEXT runtime.munmap(SB) /usr/local/go/src/runtime/cgo_mmap.go
func munmap(addr unsafe.Pointer, n uintptr) {
  0x4035f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4035f9		483b6110		CMPQ 0x10(CX), SP	
  0x4035fd		0f8683000000		JBE 0x403686		
  0x403603		4883ec30		SUBQ $0x30, SP		
  0x403607		48896c2428		MOVQ BP, 0x28(SP)	
  0x40360c		488d6c2428		LEAQ 0x28(SP), BP	
	if _cgo_munmap != nil {
  0x403611		48833dbfe20b0000	CMPQ $0x0, _cgo_munmap(SB)	
  0x403619		7449			JE 0x403664			
		systemstack(func() { callCgoMunmap(addr, n) })
  0x40361b		0f57c0			XORPS X0, X0				
  0x40361e		0f11442410		MOVUPS X0, 0x10(SP)			
  0x403623		48c744242000000000	MOVQ $0x0, 0x20(SP)			
  0x40362c		488d05dd0f0400		LEAQ runtime.munmap.func1(SB), AX	
  0x403633		4889442410		MOVQ AX, 0x10(SP)			
  0x403638		488b442438		MOVQ 0x38(SP), AX			
  0x40363d		4889442418		MOVQ AX, 0x18(SP)			
  0x403642		488b442440		MOVQ 0x40(SP), AX			
  0x403647		4889442420		MOVQ AX, 0x20(SP)			
  0x40364c		488d442410		LEAQ 0x10(SP), AX			
  0x403651		48890424		MOVQ AX, 0(SP)				
  0x403655		e8d6400400		CALL runtime.systemstack(SB)		
		return
  0x40365a		488b6c2428		MOVQ 0x28(SP), BP	
  0x40365f		4883c430		ADDQ $0x30, SP		
  0x403663		c3			RET			
	sysMunmap(addr, n)
  0x403664		488b442438		MOVQ 0x38(SP), AX		
  0x403669		48890424		MOVQ AX, 0(SP)			
  0x40366d		488b442440		MOVQ 0x40(SP), AX		
  0x403672		4889442408		MOVQ AX, 0x8(SP)		
  0x403677		e8a47d0400		CALL runtime.sysMunmap(SB)	
}
  0x40367c		488b6c2428		MOVQ 0x28(SP), BP	
  0x403681		4883c430		ADDQ $0x30, SP		
  0x403685		c3			RET			
func munmap(addr unsafe.Pointer, n uintptr) {
  0x403686		e8f5410400		CALL runtime.morestack_noctxt(SB)	
  0x40368b		e960ffffff		JMP runtime.munmap(SB)			

TEXT runtime.sigaction(SB) /usr/local/go/src/runtime/cgo_sigaction.go
func sigaction(sig uint32, new, old *sigactiont) {
  0x403690		4883ec58		SUBQ $0x58, SP		
  0x403694		48896c2450		MOVQ BP, 0x50(SP)	
  0x403699		488d6c2450		LEAQ 0x50(SP), BP	
	if _cgo_sigaction == nil || inForkedChild {
  0x40369e		48833d42e20b0000	CMPQ $0x0, _cgo_sigaction(SB)		
  0x4036a6		7409			JE 0x4036b1				
  0x4036a8		803dfb950d0000		CMPB $0x0, runtime.inForkedChild(SB)	
  0x4036af		742a			JE 0x4036db				
		sysSigaction(sig, new, old)
  0x4036b1		8b442460		MOVL 0x60(SP), AX		
  0x4036b5		890424			MOVL AX, 0(SP)			
  0x4036b8		488b442468		MOVQ 0x68(SP), AX		
  0x4036bd		4889442408		MOVQ AX, 0x8(SP)		
  0x4036c2		488b442470		MOVQ 0x70(SP), AX		
  0x4036c7		4889442410		MOVQ AX, 0x10(SP)		
  0x4036cc		e82fe70100		CALL runtime.sysSigaction(SB)	
  0x4036d1		488b6c2450		MOVQ 0x50(SP), BP		
  0x4036d6		4883c458		ADDQ $0x58, SP			
  0x4036da		c3			RET				
		var ret int32
  0x4036db		c744242400000000	MOVL $0x0, 0x24(SP)	
		g := getg()
  0x4036e3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
		sp := uintptr(unsafe.Pointer(&sig))
  0x4036ec		488d4c2460		LEAQ 0x60(SP), CX	
		case g == nil:
  0x4036f1		4885c0			TESTQ AX, AX		
  0x4036f4		0f84ba000000		JE 0x4037b4		
		case sp < g.stack.lo || sp >= g.stack.hi:
  0x4036fa		483908			CMPQ CX, 0(AX)		
  0x4036fd		7652			JBE 0x403751		
			ret = callCgoSigaction(uintptr(sig), new, old)
  0x4036ff		8b442460		MOVL 0x60(SP), AX			
  0x403703		48890424		MOVQ AX, 0(SP)				
  0x403707		488b442468		MOVQ 0x68(SP), AX			
  0x40370c		4889442408		MOVQ AX, 0x8(SP)			
  0x403711		488b4c2470		MOVQ 0x70(SP), CX			
  0x403716		48894c2410		MOVQ CX, 0x10(SP)			
  0x40371b		e8a07a0400		CALL runtime.callCgoSigaction(SB)	
  0x403720		8b442418		MOVL 0x18(SP), AX			
  0x403724		89442424		MOVL AX, 0x24(SP)			
		if ret == EINVAL {
  0x403728		837c242416		CMPL $0x16, 0x24(SP)	
  0x40372d		75a2			JNE 0x4036d1		
			sysSigaction(sig, new, old)
  0x40372f		8b442460		MOVL 0x60(SP), AX		
  0x403733		890424			MOVL AX, 0(SP)			
  0x403736		488b442468		MOVQ 0x68(SP), AX		
  0x40373b		4889442408		MOVQ AX, 0x8(SP)		
  0x403740		488b442470		MOVQ 0x70(SP), AX		
  0x403745		4889442410		MOVQ AX, 0x10(SP)		
  0x40374a		e8b1e60100		CALL runtime.sysSigaction(SB)	
  0x40374f		eb80			JMP 0x4036d1			
		case sp < g.stack.lo || sp >= g.stack.hi:
  0x403751		48394808		CMPQ CX, 0x8(AX)	
		switch {
  0x403755		76a8			JBE 0x4036ff		
			systemstack(func() {
  0x403757		48c744242800000000	MOVQ $0x0, 0x28(SP)			
  0x403760		0f57c0			XORPS X0, X0				
  0x403763		0f11442430		MOVUPS X0, 0x30(SP)			
  0x403768		0f11442440		MOVUPS X0, 0x40(SP)			
  0x40376d		488d05ec0e0400		LEAQ runtime.sigaction.func1(SB), AX	
  0x403774		4889442428		MOVQ AX, 0x28(SP)			
  0x403779		488d442460		LEAQ 0x60(SP), AX			
  0x40377e		4889442430		MOVQ AX, 0x30(SP)			
  0x403783		488b442468		MOVQ 0x68(SP), AX			
  0x403788		4889442438		MOVQ AX, 0x38(SP)			
  0x40378d		488b4c2470		MOVQ 0x70(SP), CX			
  0x403792		48894c2440		MOVQ CX, 0x40(SP)			
  0x403797		488d542424		LEAQ 0x24(SP), DX			
  0x40379c		4889542448		MOVQ DX, 0x48(SP)			
  0x4037a1		488d542428		LEAQ 0x28(SP), DX			
  0x4037a6		48891424		MOVQ DX, 0(SP)				
  0x4037aa		e8813f0400		CALL runtime.systemstack(SB)		
		switch {
  0x4037af		e974ffffff		JMP 0x403728		
			ret = callCgoSigaction(uintptr(sig), new, old)
  0x4037b4		8b442460		MOVL 0x60(SP), AX			
  0x4037b8		48890424		MOVQ AX, 0(SP)				
  0x4037bc		488b442468		MOVQ 0x68(SP), AX			
  0x4037c1		4889442408		MOVQ AX, 0x8(SP)			
  0x4037c6		488b4c2470		MOVQ 0x70(SP), CX			
  0x4037cb		48894c2410		MOVQ CX, 0x10(SP)			
  0x4037d0		e8eb790400		CALL runtime.callCgoSigaction(SB)	
  0x4037d5		8b442418		MOVL 0x18(SP), AX			
  0x4037d9		89442424		MOVL AX, 0x24(SP)			
		switch {
  0x4037dd		e946ffffff		JMP 0x403728		

TEXT runtime.cgocall(SB) /usr/local/go/src/runtime/cgocall.go
func cgocall(fn, arg unsafe.Pointer) int32 {
  0x4037f0		4883ec30		SUBQ $0x30, SP		
  0x4037f4		48896c2428		MOVQ BP, 0x28(SP)	
  0x4037f9		488d6c2428		LEAQ 0x28(SP), BP	
	if !iscgo && GOOS != "solaris" && GOOS != "windows" {
  0x4037fe		803da9940d0000		CMPB $0x0, runtime.iscgo(SB)	
  0x403805		0f84b0000000		JE 0x4038bb			
	if fn == nil {
  0x40380b		488b442438		MOVQ 0x38(SP), AX	
  0x403810		4885c0			TESTQ AX, AX		
  0x403813		0f8487000000		JE 0x4038a0		
	mp := getg().m
  0x403819		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x403822		488b4030		MOVQ 0x30(AX), AX	
  0x403826		4889442420		MOVQ AX, 0x20(SP)	
	mp.ncgocall++
  0x40382b		48ff8030010000		INCQ 0x130(AX)		
	mp.ncgo++
  0x403832		ff8038010000		INCL 0x138(AX)		
	mp.cgoCallers[0] = 0
  0x403838		488b8840010000		MOVQ 0x140(AX), CX	
  0x40383f		48c70100000000		MOVQ $0x0, 0(CX)	
	entersyscall()
  0x403846		e875810200		CALL runtime.entersyscall(SB)	
	mp.incgo = true
  0x40384b		488b442420		MOVQ 0x20(SP), AX	
  0x403850		c6801901000001		MOVB $0x1, 0x119(AX)	
	errno := asmcgocall(fn, arg)
  0x403857		488b4c2438		MOVQ 0x38(SP), CX		
  0x40385c		48890c24		MOVQ CX, 0(SP)			
  0x403860		488b542440		MOVQ 0x40(SP), DX		
  0x403865		4889542408		MOVQ DX, 0x8(SP)		
  0x40386a		e891560400		CALL runtime.asmcgocall(SB)	
  0x40386f		8b442410		MOVL 0x10(SP), AX		
  0x403873		8944241c		MOVL AX, 0x1c(SP)		
	mp.incgo = false
  0x403877		488b4c2420		MOVQ 0x20(SP), CX	
  0x40387c		c6811901000000		MOVB $0x0, 0x119(CX)	
	mp.ncgo--
  0x403883		ff8938010000		DECL 0x138(CX)		
	exitsyscall()
  0x403889		e812850200		CALL runtime.exitsyscall(SB)	
	return errno
  0x40388e		8b44241c		MOVL 0x1c(SP), AX	
  0x403892		89442448		MOVL AX, 0x48(SP)	
  0x403896		488b6c2428		MOVQ 0x28(SP), BP	
  0x40389b		4883c430		ADDQ $0x30, SP		
  0x40389f		c3			RET			
		throw("cgocall nil")
  0x4038a0		488d0540c00600		LEAQ 0x6c040(IP), AX	
  0x4038a7		48890424		MOVQ AX, 0(SP)		
  0x4038ab		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x4038b4		e8c7fb0100		CALL runtime.throw(SB)	
  0x4038b9		0f0b			UD2			
		throw("cgocall unavailable")
  0x4038bb		488d051acb0600		LEAQ 0x6cb1a(IP), AX	
  0x4038c2		48890424		MOVQ AX, 0(SP)		
  0x4038c6		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x4038cf		e8acfb0100		CALL runtime.throw(SB)	
  0x4038d4		0f0b			UD2			

TEXT runtime.cgoIsGoPointer(SB) /usr/local/go/src/runtime/cgocall.go
func cgoIsGoPointer(p unsafe.Pointer) bool {
  0x4038e0		4883ec18		SUBQ $0x18, SP		
  0x4038e4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4038e9		488d6c2410		LEAQ 0x10(SP), BP	
	if p == nil {
  0x4038ee		488b442420		MOVQ 0x20(SP), AX	
  0x4038f3		4885c0			TESTQ AX, AX		
  0x4038f6		0f84ba000000		JE 0x4039b6		
	if inHeapOrStack(uintptr(p)) {
  0x4038fc		48890424		MOVQ AX, 0(SP)			
  0x403900		e87b8d0100		CALL runtime.inHeapOrStack(SB)	
  0x403905		807c240800		CMPB $0x0, 0x8(SP)		
  0x40390a		0f8597000000		JNE 0x4039a7			
	for _, datap := range activeModules() {
  0x403910		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x403911		488b0560e00b00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x403918		4885c0			TESTQ AX, AX		
  0x40391b		0f8480000000		JE 0x4039a1		
	return *p
  0x403921		488b4808		MOVQ 0x8(AX), CX	
  0x403925		488b00			MOVQ 0(AX), AX		
	for _, datap := range activeModules() {
  0x403928		488b542420		MOVQ 0x20(SP), DX	
  0x40392d		31db			XORL BX, BX		
  0x40392f		eb06			JMP 0x403937		
  0x403931		48ffc3			INCQ BX			
	return start <= uintptr(p) && uintptr(p) < end
  0x403934		4c89c2			MOVQ R8, DX		
	for _, datap := range activeModules() {
  0x403937		4839cb			CMPQ CX, BX		
  0x40393a		7d56			JGE 0x403992		
  0x40393c		488b34d8		MOVQ 0(AX)(BX*8), SI	
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x403940		90			NOPL			
  0x403941		488bbe88000000		MOVQ 0x88(SI), DI	
	return start <= uintptr(p) && uintptr(p) < end
  0x403948		4989d0			MOVQ DX, R8		
  0x40394b		48399680000000		CMPQ DX, 0x80(SI)	
  0x403952		773a			JA 0x40398e		
  0x403954		4839fa			CMPQ DI, DX		
  0x403957		400f92c7		SETB DI			
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x40395b		4084ff			TESTL DI, DI		
  0x40395e		751b			JNE 0x40397b		
  0x403960		90			NOPL			
  0x403961		488bbe98000000		MOVQ 0x98(SI), DI	
	return start <= uintptr(p) && uintptr(p) < end
  0x403968		48399690000000		CMPQ DX, 0x90(SI)	
  0x40396f		7719			JA 0x40398a		
  0x403971		4839fa			CMPQ DI, DX		
  0x403974		0f92c2			SETB DL			
		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {
  0x403977		84d2			TESTL DL, DL		
  0x403979		74b6			JE 0x403931		
			return true
  0x40397b		c644242801		MOVB $0x1, 0x28(SP)	
  0x403980		488b6c2410		MOVQ 0x10(SP), BP	
  0x403985		4883c418		ADDQ $0x18, SP		
  0x403989		c3			RET			
  0x40398a		31d2			XORL DX, DX		
	return start <= uintptr(p) && uintptr(p) < end
  0x40398c		ebe9			JMP 0x403977		
  0x40398e		31ff			XORL DI, DI		
  0x403990		ebc9			JMP 0x40395b		
	return false
  0x403992		c644242800		MOVB $0x0, 0x28(SP)	
  0x403997		488b6c2410		MOVQ 0x10(SP), BP	
  0x40399c		4883c418		ADDQ $0x18, SP		
  0x4039a0		c3			RET			
  0x4039a1		31c9			XORL CX, CX		
  0x4039a3		31c0			XORL AX, AX		
	for _, datap := range activeModules() {
  0x4039a5		eb81			JMP 0x403928		
		return true
  0x4039a7		c644242801		MOVB $0x1, 0x28(SP)	
  0x4039ac		488b6c2410		MOVQ 0x10(SP), BP	
  0x4039b1		4883c418		ADDQ $0x18, SP		
  0x4039b5		c3			RET			
		return false
  0x4039b6		c644242800		MOVB $0x0, 0x28(SP)	
  0x4039bb		488b6c2410		MOVQ 0x10(SP), BP	
  0x4039c0		4883c418		ADDQ $0x18, SP		
  0x4039c4		c3			RET			

TEXT runtime.cgoCheckWriteBarrier(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckWriteBarrier(dst *uintptr, src uintptr) {
  0x4039d0		4883ec30		SUBQ $0x30, SP		
  0x4039d4		48896c2428		MOVQ BP, 0x28(SP)	
  0x4039d9		488d6c2428		LEAQ 0x28(SP), BP	
	if !cgoIsGoPointer(unsafe.Pointer(src)) {
  0x4039de		488b442440		MOVQ 0x40(SP), AX		
  0x4039e3		48890424		MOVQ AX, 0(SP)			
  0x4039e7		e8f4feffff		CALL runtime.cgoIsGoPointer(SB)	
  0x4039ec		807c240800		CMPB $0x0, 0x8(SP)		
  0x4039f1		0f84c0000000		JE 0x403ab7			
	if cgoIsGoPointer(unsafe.Pointer(dst)) {
  0x4039f7		488b442438		MOVQ 0x38(SP), AX		
  0x4039fc		48890424		MOVQ AX, 0(SP)			
  0x403a00		e8dbfeffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403a05		807c240800		CMPB $0x0, 0x8(SP)		
  0x403a0a		0f859d000000		JNE 0x403aad			
	g := getg()
  0x403a10		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g == g.m.g0 || g == g.m.gsignal {
  0x403a19		488b4830		MOVQ 0x30(AX), CX	
  0x403a1d		483901			CMPQ AX, 0(CX)		
  0x403a20		750a			JNE 0x403a2c		
		return
  0x403a22		488b6c2428		MOVQ 0x28(SP), BP	
  0x403a27		4883c430		ADDQ $0x30, SP		
  0x403a2b		c3			RET			
	if g == g.m.g0 || g == g.m.gsignal {
  0x403a2c		48394150		CMPQ AX, 0x50(CX)	
  0x403a30		74f0			JE 0x403a22		
	if g.m.mallocing != 0 {
  0x403a32		83b9f000000000		CMPL $0x0, 0xf0(CX)	
  0x403a39		7568			JNE 0x403aa3		
	if inPersistentAlloc(uintptr(unsafe.Pointer(dst))) {
  0x403a3b		488b442438		MOVQ 0x38(SP), AX			
  0x403a40		48890424		MOVQ AX, 0(SP)				
  0x403a44		e8e7730000		CALL runtime.inPersistentAlloc(SB)	
  0x403a49		807c240800		CMPB $0x0, 0x8(SP)			
  0x403a4e		740a			JE 0x403a5a				
		return
  0x403a50		488b6c2428		MOVQ 0x28(SP), BP	
  0x403a55		4883c430		ADDQ $0x30, SP		
  0x403a59		c3			RET			
	systemstack(func() {
  0x403a5a		0f57c0			XORPS X0, X0					
  0x403a5d		0f11442410		MOVUPS X0, 0x10(SP)				
  0x403a62		48c744242000000000	MOVQ $0x0, 0x20(SP)				
  0x403a6b		488d055e0c0400		LEAQ runtime.cgoCheckWriteBarrier.func1(SB), AX	
  0x403a72		4889442410		MOVQ AX, 0x10(SP)				
  0x403a77		488b442440		MOVQ 0x40(SP), AX				
  0x403a7c		4889442418		MOVQ AX, 0x18(SP)				
  0x403a81		488b442438		MOVQ 0x38(SP), AX				
  0x403a86		4889442420		MOVQ AX, 0x20(SP)				
  0x403a8b		488d442410		LEAQ 0x10(SP), AX				
  0x403a90		48890424		MOVQ AX, 0(SP)					
  0x403a94		e8973c0400		CALL runtime.systemstack(SB)			
}
  0x403a99		488b6c2428		MOVQ 0x28(SP), BP	
  0x403a9e		4883c430		ADDQ $0x30, SP		
  0x403aa2		c3			RET			
		return
  0x403aa3		488b6c2428		MOVQ 0x28(SP), BP	
  0x403aa8		4883c430		ADDQ $0x30, SP		
  0x403aac		c3			RET			
		return
  0x403aad		488b6c2428		MOVQ 0x28(SP), BP	
  0x403ab2		4883c430		ADDQ $0x30, SP		
  0x403ab6		c3			RET			
		return
  0x403ab7		488b6c2428		MOVQ 0x28(SP), BP	
  0x403abc		4883c430		ADDQ $0x30, SP		
  0x403ac0		c3			RET			

TEXT runtime.cgoCheckMemmove(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckMemmove(typ *_type, dst, src unsafe.Pointer, off, size uintptr) {
  0x403ad0		4883ec28		SUBQ $0x28, SP		
  0x403ad4		48896c2420		MOVQ BP, 0x20(SP)	
  0x403ad9		488d6c2420		LEAQ 0x20(SP), BP	
	if typ.kind&kindNoPointers != 0 {
  0x403ade		488b442430		MOVQ 0x30(SP), AX	
  0x403ae3		0fb64817		MOVZX 0x17(AX), CX	
  0x403ae7		f6c180			TESTL $0x80, CL		
  0x403aea		7574			JNE 0x403b60		
	if !cgoIsGoPointer(src) {
  0x403aec		488b442440		MOVQ 0x40(SP), AX		
  0x403af1		48890424		MOVQ AX, 0(SP)			
  0x403af5		e8e6fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403afa		807c240800		CMPB $0x0, 0x8(SP)		
  0x403aff		7455			JE 0x403b56			
	if cgoIsGoPointer(dst) {
  0x403b01		488b442438		MOVQ 0x38(SP), AX		
  0x403b06		48890424		MOVQ AX, 0(SP)			
  0x403b0a		e8d1fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403b0f		807c240800		CMPB $0x0, 0x8(SP)		
  0x403b14		740a			JE 0x403b20			
		return
  0x403b16		488b6c2420		MOVQ 0x20(SP), BP	
  0x403b1b		4883c428		ADDQ $0x28, SP		
  0x403b1f		c3			RET			
	cgoCheckTypedBlock(typ, src, off, size)
  0x403b20		488b442430		MOVQ 0x30(SP), AX			
  0x403b25		48890424		MOVQ AX, 0(SP)				
  0x403b29		488b442440		MOVQ 0x40(SP), AX			
  0x403b2e		4889442408		MOVQ AX, 0x8(SP)			
  0x403b33		488b442448		MOVQ 0x48(SP), AX			
  0x403b38		4889442410		MOVQ AX, 0x10(SP)			
  0x403b3d		488b442450		MOVQ 0x50(SP), AX			
  0x403b42		4889442418		MOVQ AX, 0x18(SP)			
  0x403b47		e804010000		CALL runtime.cgoCheckTypedBlock(SB)	
}
  0x403b4c		488b6c2420		MOVQ 0x20(SP), BP	
  0x403b51		4883c428		ADDQ $0x28, SP		
  0x403b55		c3			RET			
		return
  0x403b56		488b6c2420		MOVQ 0x20(SP), BP	
  0x403b5b		4883c428		ADDQ $0x28, SP		
  0x403b5f		c3			RET			
		return
  0x403b60		488b6c2420		MOVQ 0x20(SP), BP	
  0x403b65		4883c428		ADDQ $0x28, SP		
  0x403b69		c3			RET			

TEXT runtime.cgoCheckSliceCopy(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckSliceCopy(typ *_type, dst, src slice, n int) {
  0x403b70		4883ec38		SUBQ $0x38, SP		
  0x403b74		48896c2430		MOVQ BP, 0x30(SP)	
  0x403b79		488d6c2430		LEAQ 0x30(SP), BP	
	if typ.kind&kindNoPointers != 0 {
  0x403b7e		488b442440		MOVQ 0x40(SP), AX	
  0x403b83		0fb64817		MOVZX 0x17(AX), CX	
  0x403b87		f6c180			TESTL $0x80, CL		
  0x403b8a		0f85a9000000		JNE 0x403c39		
	if !cgoIsGoPointer(src.array) {
  0x403b90		488b442460		MOVQ 0x60(SP), AX		
  0x403b95		48890424		MOVQ AX, 0(SP)			
  0x403b99		e842fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403b9e		807c240800		CMPB $0x0, 0x8(SP)		
  0x403ba3		0f8486000000		JE 0x403c2f			
	if cgoIsGoPointer(dst.array) {
  0x403ba9		488b442448		MOVQ 0x48(SP), AX		
  0x403bae		48890424		MOVQ AX, 0(SP)			
  0x403bb2		e829fdffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403bb7		807c240800		CMPB $0x0, 0x8(SP)		
  0x403bbc		7567			JNE 0x403c25			
  0x403bbe		31c0			XORL AX, AX			
		cgoCheckTypedBlock(typ, p, 0, typ.size)
  0x403bc0		488b4c2460		MOVQ 0x60(SP), CX	
	for i := 0; i < n; i++ {
  0x403bc5		eb4a			JMP 0x403c11		
  0x403bc7		4889442420		MOVQ AX, 0x20(SP)	
		cgoCheckTypedBlock(typ, p, 0, typ.size)
  0x403bcc		48894c2428		MOVQ CX, 0x28(SP)			
  0x403bd1		488b442440		MOVQ 0x40(SP), AX			
  0x403bd6		488b10			MOVQ 0(AX), DX				
  0x403bd9		48890424		MOVQ AX, 0(SP)				
  0x403bdd		48894c2408		MOVQ CX, 0x8(SP)			
  0x403be2		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x403beb		4889542418		MOVQ DX, 0x18(SP)			
  0x403bf0		e85b000000		CALL runtime.cgoCheckTypedBlock(SB)	
	for i := 0; i < n; i++ {
  0x403bf5		488b442420		MOVQ 0x20(SP), AX	
  0x403bfa		48ffc0			INCQ AX			
		p = add(p, typ.size)
  0x403bfd		90			NOPL			
  0x403bfe		488b4c2440		MOVQ 0x40(SP), CX	
  0x403c03		488b11			MOVQ 0(CX), DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x403c06		488b5c2428		MOVQ 0x28(SP), BX	
  0x403c0b		4801da			ADDQ BX, DX		
		cgoCheckTypedBlock(typ, p, 0, typ.size)
  0x403c0e		4889d1			MOVQ DX, CX		
	for i := 0; i < n; i++ {
  0x403c11		488b542478		MOVQ 0x78(SP), DX	
  0x403c16		4839d0			CMPQ DX, AX		
  0x403c19		7cac			JL 0x403bc7		
  0x403c1b		488b6c2430		MOVQ 0x30(SP), BP	
  0x403c20		4883c438		ADDQ $0x38, SP		
  0x403c24		c3			RET			
		return
  0x403c25		488b6c2430		MOVQ 0x30(SP), BP	
  0x403c2a		4883c438		ADDQ $0x38, SP		
  0x403c2e		c3			RET			
		return
  0x403c2f		488b6c2430		MOVQ 0x30(SP), BP	
  0x403c34		4883c438		ADDQ $0x38, SP		
  0x403c38		c3			RET			
		return
  0x403c39		488b6c2430		MOVQ 0x30(SP), BP	
  0x403c3e		4883c438		ADDQ $0x38, SP		
  0x403c42		c3			RET			

TEXT runtime.cgoCheckTypedBlock(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckTypedBlock(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x403c50		4881ec80000000		SUBQ $0x80, SP		
  0x403c57		48896c2478		MOVQ BP, 0x78(SP)	
  0x403c5c		488d6c2478		LEAQ 0x78(SP), BP	
	if typ.ptrdata <= off {
  0x403c61		488b842488000000	MOVQ 0x88(SP), AX	
  0x403c69		488b4808		MOVQ 0x8(AX), CX	
  0x403c6d		488b942498000000	MOVQ 0x98(SP), DX	
  0x403c75		4839d1			CMPQ DX, CX		
  0x403c78		0f862f030000		JBE 0x403fad		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x403c7e		4829d1			SUBQ DX, CX		
  0x403c81		488b9c24a0000000	MOVQ 0xa0(SP), BX	
  0x403c89		4839cb			CMPQ CX, BX		
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403c8c		480f47d9		CMOVA CX, BX		
	if typ.kind&kindGCProg == 0 {
  0x403c90		0fb64817		MOVZX 0x17(AX), CX	
  0x403c94		f6c140			TESTL $0x40, CL		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x403c97		0f84df020000		JE 0x403f7c		
	for _, datap := range activeModules() {
  0x403c9d		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x403c9e		488b0dd3dc0b00		MOVQ runtime.modulesSlice(SB), CX	
	if p == nil {
  0x403ca5		4885c9			TESTQ CX, CX		
  0x403ca8		0f84c5020000		JE 0x403f73		
	return *p
  0x403cae		488b7108		MOVQ 0x8(CX), SI	
  0x403cb2		488b09			MOVQ 0(CX), CX		
	for _, datap := range activeModules() {
  0x403cb5		488bbc2490000000	MOVQ 0x90(SP), DI	
  0x403cbd		4531c0			XORL R8, R8		
  0x403cc0		eb06			JMP 0x403cc8		
  0x403cc2		49ffc0			INCQ R8			
	return start <= uintptr(p) && uintptr(p) < end
  0x403cc5		4c89e7			MOVQ R12, DI		
	for _, datap := range activeModules() {
  0x403cc8		4939f0			CMPQ SI, R8		
  0x403ccb		0f8dd4000000		JGE 0x403da5		
  0x403cd1		4e8b0cc1		MOVQ 0(CX)(R8*8), R9	
		if cgoInRange(src, datap.data, datap.edata) {
  0x403cd5		90			NOPL			
  0x403cd6		4d8b9180000000		MOVQ 0x80(R9), R10	
  0x403cdd		4d8b9988000000		MOVQ 0x88(R9), R11	
	return start <= uintptr(p) && uintptr(p) < end
  0x403ce4		4989fc			MOVQ DI, R12		
  0x403ce7		4939fa			CMPQ DI, R10		
  0x403cea		0f87ad000000		JA 0x403d9d		
  0x403cf0		4c39df			CMPQ R11, DI		
  0x403cf3		410f92c3		SETB R11		
		if cgoInRange(src, datap.data, datap.edata) {
  0x403cf7		4584db			TESTL R11, R11		
  0x403cfa		7563			JNE 0x403d5f		
		if cgoInRange(src, datap.bss, datap.ebss) {
  0x403cfc		90			NOPL			
  0x403cfd		4d8b9190000000		MOVQ 0x90(R9), R10	
  0x403d04		4d8b9998000000		MOVQ 0x98(R9), R11	
	return start <= uintptr(p) && uintptr(p) < end
  0x403d0b		4939fa			CMPQ DI, R10		
  0x403d0e		774a			JA 0x403d5a		
  0x403d10		4c39df			CMPQ R11, DI		
  0x403d13		410f92c3		SETB R11		
		if cgoInRange(src, datap.bss, datap.ebss) {
  0x403d17		4584db			TESTL R11, R11		
  0x403d1a		74a6			JE 0x403cc2		
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x403d1c		90			NOPL			
  0x403d1d		4c89d0			MOVQ R10, AX		
  0x403d20		4929fa			SUBQ DI, R10		
  0x403d23		498b89a8010000		MOVQ 0x1a8(R9), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x403d2a		4b8d3422		LEAQ 0(R10)(R12*1), SI	
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x403d2e		48893424		MOVQ SI, 0(SP)		
  0x403d32		48894c2408		MOVQ CX, 0x8(SP)	
			boff := uintptr(src) - datap.bss
  0x403d37		4829c7			SUBQ AX, DI		
			cgoCheckBits(add(src, -boff), datap.gcbssmask.bytedata, off+boff, size)
  0x403d3a		488d0417		LEAQ 0(DI)(DX*1), AX		
  0x403d3e		4889442410		MOVQ AX, 0x10(SP)		
  0x403d43		48895c2418		MOVQ BX, 0x18(SP)		
  0x403d48		e893020000		CALL runtime.cgoCheckBits(SB)	
			return
  0x403d4d		488b6c2478		MOVQ 0x78(SP), BP	
  0x403d52		4881c480000000		ADDQ $0x80, SP		
  0x403d59		c3			RET			
  0x403d5a		4531db			XORL R11, R11		
	return start <= uintptr(p) && uintptr(p) < end
  0x403d5d		ebb8			JMP 0x403d17		
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x403d5f		90			NOPL			
  0x403d60		4c89d0			MOVQ R10, AX		
  0x403d63		4929fa			SUBQ DI, R10		
  0x403d66		498b8998010000		MOVQ 0x198(R9), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x403d6d		4b8d3422		LEAQ 0(R10)(R12*1), SI	
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x403d71		48893424		MOVQ SI, 0(SP)		
  0x403d75		48894c2408		MOVQ CX, 0x8(SP)	
			doff := uintptr(src) - datap.data
  0x403d7a		4829c7			SUBQ AX, DI		
			cgoCheckBits(add(src, -doff), datap.gcdatamask.bytedata, off+doff, size)
  0x403d7d		488d0417		LEAQ 0(DI)(DX*1), AX		
  0x403d81		4889442410		MOVQ AX, 0x10(SP)		
  0x403d86		48895c2418		MOVQ BX, 0x18(SP)		
  0x403d8b		e850020000		CALL runtime.cgoCheckBits(SB)	
			return
  0x403d90		488b6c2478		MOVQ 0x78(SP), BP	
  0x403d95		4881c480000000		ADDQ $0x80, SP		
  0x403d9c		c3			RET			
  0x403d9d		4531db			XORL R11, R11		
	return start <= uintptr(p) && uintptr(p) < end
  0x403da0		e952ffffff		JMP 0x403cf7		
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x403da5		488b0da42b0c00		MOVQ runtime.mheap_+784(SB), CX	
  0x403dac		8401			TESTB AL, 0(CX)			
	s := spanOfUnchecked(uintptr(src))
  0x403dae		90			NOPL			
  0x403daf		4889fe			MOVQ DI, SI		
	ai := arenaIndex(p)
  0x403db2		90			NOPL			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x403db3		90			NOPL			
  0x403db4		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x403db5		49b80000000000800000	MOVQ $0x800000000000, R8	
  0x403dbf		4901f8			ADDQ DI, R8			
  0x403dc2		49c1e81a		SHRQ $0x1a, R8			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x403dc6		4981f800004000		CMPQ $0x400000, R8		
  0x403dcd		0f8302020000		JAE 0x403fd5			
  0x403dd3		4a8b0cc1		MOVQ 0(CX)(R8*8), CX		
  0x403dd7		4989f9			MOVQ DI, R9			
  0x403dda		48c1ef0d		SHRQ $0xd, DI			
  0x403dde		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x403de5		488bbcf900002000	MOVQ 0x200000(CX)(DI*8), DI	
  0x403ded		8401			TESTB AL, 0(CX)			
	if s.state == mSpanManual {
  0x403def		807f6302		CMPB $0x2, 0x63(DI)	
  0x403df3		0f8429010000		JE 0x403f22		
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403df9		48899c24a0000000	MOVQ BX, 0xa0(SP)	
	hbits := heapBitsForAddr(uintptr(src))
  0x403e01		90			NOPL			
	arena := arenaIndex(addr)
  0x403e02		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x403e03		90			NOPL			
  0x403e04		90			NOPL			
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x403e05		4c89c8			MOVQ R9, AX		
  0x403e08		49c1e905		SHRQ $0x5, R9		
  0x403e0c		4981e1ffff1f00		ANDQ $0x1fffff, R9	
  0x403e13		4a8d3c09		LEAQ 0(CX)(R9*1), DI	
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x403e17		48c1e803		SHRQ $0x3, AX		
  0x403e1b		4883e003		ANDQ $0x3, AX		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x403e1f		4881c1ffff1f00		ADDQ $0x1fffff, CX	
  0x403e26		4531c9			XORL R9, R9		
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403e29		eb04			JMP 0x403e2f		
  0x403e2b		4983c108		ADDQ $0x8, R9		
  0x403e2f		4c8d1413		LEAQ 0(BX)(DX*1), R10	
  0x403e33		4d39d1			CMPQ R10, R9		
  0x403e36		0f83d9000000		JAE 0x403f15		
  0x403e3c		4c894c2438		MOVQ R9, 0x38(SP)	
		bits := hbits.bits()
  0x403e41		90			NOPL			
	return uint32(*h.bitp) >> (h.shift & 31)
  0x403e42		440fb617		MOVZX 0(DI), R10	
		if i >= off && bits&bitPointer != 0 {
  0x403e46		4939d1			CMPQ DX, R9		
  0x403e49		7206			JB 0x403e51		
  0x403e4b		410fa3c2		BTL AX, R10		
  0x403e4f		7263			JB 0x403eb4		
		hbits = hbits.next()
  0x403e51		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x403e52		83f803			CMPL $0x3, AX		
  0x403e55		7304			JAE 0x403e5b		
		h.shift += heapBitsShift
  0x403e57		ffc0			INCL AX			
  0x403e59		ebd0			JMP 0x403e2b		
	} else if h.bitp != h.last {
  0x403e5b		4839cf			CMPQ CX, DI		
  0x403e5e		7408			JE 0x403e68		
		h.bitp, h.shift = add1(h.bitp), 0
  0x403e60		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x403e61		48ffc7			INCQ DI			
  0x403e64		31c0			XORL AX, AX		
		hbits = hbits.next()
  0x403e66		ebc3			JMP 0x403e2b		
		return h.nextArena()
  0x403e68		48893c24		MOVQ DI, 0(SP)				
  0x403e6c		89442408		MOVL AX, 0x8(SP)			
  0x403e70		448944240c		MOVL R8, 0xc(SP)			
  0x403e75		48894c2410		MOVQ CX, 0x10(SP)			
  0x403e7a		e8f1a00000		CALL runtime.heapBits.nextArena(SB)	
  0x403e7f		488b4c2428		MOVQ 0x28(SP), CX			
  0x403e84		448b442424		MOVL 0x24(SP), R8			
  0x403e89		8b442420		MOVL 0x20(SP), AX			
  0x403e8d		488b7c2418		MOVQ 0x18(SP), DI			
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403e92		488b942498000000	MOVQ 0x98(SP), DX	
  0x403e9a		488b9c24a0000000	MOVQ 0xa0(SP), BX	
			v := *(*unsafe.Pointer)(add(src, i))
  0x403ea2		488bb42490000000	MOVQ 0x90(SP), SI	
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403eaa		4c8b4c2438		MOVQ 0x38(SP), R9	
		hbits = hbits.next()
  0x403eaf		e977ffffff		JMP 0x403e2b		
		bits := hbits.bits()
  0x403eb4		4489442434		MOVL R8, 0x34(SP)	
  0x403eb9		89442430		MOVL AX, 0x30(SP)	
  0x403ebd		48897c2448		MOVQ DI, 0x48(SP)	
  0x403ec2		48894c2440		MOVQ CX, 0x40(SP)	
			v := *(*unsafe.Pointer)(add(src, i))
  0x403ec7		498b0431		MOVQ 0(R9)(SI*1), AX	
  0x403ecb		90			NOPL			
			if cgoIsGoPointer(v) {
  0x403ecc		48890424		MOVQ AX, 0(SP)			
  0x403ed0		e80bfaffff		CALL runtime.cgoIsGoPointer(SB)	
  0x403ed5		807c240800		CMPB $0x0, 0x8(SP)		
  0x403eda		0f85da000000		JNE 0x403fba			
	if h.shift < 3*heapBitsShift {
  0x403ee0		8b442430		MOVL 0x30(SP), AX	
	} else if h.bitp != h.last {
  0x403ee4		488b4c2440		MOVQ 0x40(SP), CX	
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403ee9		488b942498000000	MOVQ 0x98(SP), DX	
  0x403ef1		488b9c24a0000000	MOVQ 0xa0(SP), BX	
			v := *(*unsafe.Pointer)(add(src, i))
  0x403ef9		488bb42490000000	MOVQ 0x90(SP), SI	
	} else if h.bitp != h.last {
  0x403f01		488b7c2448		MOVQ 0x48(SP), DI	
		hbits = hbits.next()
  0x403f06		448b442434		MOVL 0x34(SP), R8	
	for i := uintptr(0); i < off+size; i += sys.PtrSize {
  0x403f0b		4c8b4c2438		MOVQ 0x38(SP), R9	
		hbits = hbits.next()
  0x403f10		e93cffffff		JMP 0x403e51		
  0x403f15		488b6c2478		MOVQ 0x78(SP), BP	
  0x403f1a		4881c480000000		ADDQ $0x80, SP		
  0x403f21		c3			RET			
		systemstack(func() {
  0x403f22		48c744245000000000	MOVQ $0x0, 0x50(SP)				
  0x403f2b		0f57c0			XORPS X0, X0					
  0x403f2e		0f11442458		MOVUPS X0, 0x58(SP)				
  0x403f33		0f11442468		MOVUPS X0, 0x68(SP)				
  0x403f38		488d0d51080400		LEAQ runtime.cgoCheckTypedBlock.func1(SB), CX	
  0x403f3f		48894c2450		MOVQ CX, 0x50(SP)				
  0x403f44		4889442458		MOVQ AX, 0x58(SP)				
  0x403f49		4889742460		MOVQ SI, 0x60(SP)				
  0x403f4e		4889542468		MOVQ DX, 0x68(SP)				
  0x403f53		48895c2470		MOVQ BX, 0x70(SP)				
  0x403f58		488d442450		LEAQ 0x50(SP), AX				
  0x403f5d		48890424		MOVQ AX, 0(SP)					
  0x403f61		e8ca370400		CALL runtime.systemstack(SB)			
		return
  0x403f66		488b6c2478		MOVQ 0x78(SP), BP	
  0x403f6b		4881c480000000		ADDQ $0x80, SP		
  0x403f72		c3			RET			
  0x403f73		31c9			XORL CX, CX		
  0x403f75		31f6			XORL SI, SI		
	for _, datap := range activeModules() {
  0x403f77		e939fdffff		JMP 0x403cb5		
		cgoCheckBits(src, typ.gcdata, off, size)
  0x403f7c		488b4020		MOVQ 0x20(AX), AX		
  0x403f80		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x403f88		48890c24		MOVQ CX, 0(SP)			
  0x403f8c		4889442408		MOVQ AX, 0x8(SP)		
  0x403f91		4889542410		MOVQ DX, 0x10(SP)		
  0x403f96		48895c2418		MOVQ BX, 0x18(SP)		
  0x403f9b		e840000000		CALL runtime.cgoCheckBits(SB)	
		return
  0x403fa0		488b6c2478		MOVQ 0x78(SP), BP	
  0x403fa5		4881c480000000		ADDQ $0x80, SP		
  0x403fac		c3			RET			
		return
  0x403fad		488b6c2478		MOVQ 0x78(SP), BP	
  0x403fb2		4881c480000000		ADDQ $0x80, SP		
  0x403fb9		c3			RET			
				throw(cgoWriteBarrierFail)
  0x403fba		488d054ae50600		LEAQ 0x6e54a(IP), AX	
  0x403fc1		48890424		MOVQ AX, 0(SP)		
  0x403fc5		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x403fce		e8adf40100		CALL runtime.throw(SB)	
  0x403fd3		0f0b			UD2			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x403fd5		e846df0100		CALL runtime.panicindex(SB)	
  0x403fda		0f0b			UD2				

TEXT runtime.cgoCheckBits(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckBits(src unsafe.Pointer, gcbits *byte, off, size uintptr) {
  0x403fe0		4883ec40		SUBQ $0x40, SP		
  0x403fe4		48896c2438		MOVQ BP, 0x38(SP)	
  0x403fe9		488d6c2438		LEAQ 0x38(SP), BP	
	skipMask := off / sys.PtrSize / 8
  0x403fee		488b442458		MOVQ 0x58(SP), AX	
  0x403ff3		4889c1			MOVQ AX, CX		
  0x403ff6		48c1e806		SHRQ $0x6, AX		
	skipBytes := skipMask * sys.PtrSize * 8
  0x403ffa		4889c2			MOVQ AX, DX		
  0x403ffd		48c1e006		SHLQ $0x6, AX		
	ptrmask := addb(gcbits, skipMask)
  0x404001		90			NOPL			
	src = add(src, skipBytes)
  0x404002		90			NOPL			
	off -= skipBytes
  0x404003		4829c1			SUBQ AX, CX		
	size += off
  0x404006		488b5c2460		MOVQ 0x60(SP), BX	
  0x40400b		4801cb			ADDQ CX, BX		
  0x40400e		48895c2460		MOVQ BX, 0x60(SP)	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x404013		488b742450		MOVQ 0x50(SP), SI	
  0x404018		4801f2			ADDQ SI, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x40401b		488b742448		MOVQ 0x48(SP), SI	
  0x404020		4801f0			ADDQ SI, AX		
  0x404023		4889442430		MOVQ AX, 0x30(SP)	
  0x404028		31f6			XORL SI, SI		
  0x40402a		31ff			XORL DI, DI		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40402c		eb04			JMP 0x404032		
  0x40402e		4883c608		ADDQ $0x8, SI		
  0x404032		4839de			CMPQ BX, SI		
  0x404035		736c			JAE 0x4040a3		
		if i&(sys.PtrSize*8-1) == 0 {
  0x404037		48f7c63f000000		TESTQ $0x3f, SI		
  0x40403e		755f			JNE 0x40409f		
			bits = uint32(*ptrmask)
  0x404040		0fb63a			MOVZX 0(DX), DI		
			ptrmask = addb(ptrmask, 1)
  0x404043		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x404044		48ffc2			INCQ DX			
		if off > 0 {
  0x404047		4885c9			TESTQ CX, CX		
  0x40404a		7606			JBE 0x404052		
			off -= sys.PtrSize
  0x40404c		4883c1f8		ADDQ $-0x8, CX		
  0x404050		ebdc			JMP 0x40402e		
			if bits&1 != 0 {
  0x404052		0fbae700		BTL $0x0, DI		
  0x404056		73d6			JAE 0x40402e		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x404058		4889742418		MOVQ SI, 0x18(SP)	
			if bits&1 != 0 {
  0x40405d		897c2414		MOVL DI, 0x14(SP)	
			bits = uint32(*ptrmask)
  0x404061		4889542428		MOVQ DX, 0x28(SP)	
		if off > 0 {
  0x404066		48894c2420		MOVQ CX, 0x20(SP)	
				v := *(*unsafe.Pointer)(add(src, i))
  0x40406b		488b0c06		MOVQ 0(SI)(AX*1), CX	
  0x40406f		90			NOPL			
				if cgoIsGoPointer(v) {
  0x404070		48890c24		MOVQ CX, 0(SP)			
  0x404074		e867f8ffff		CALL runtime.cgoIsGoPointer(SB)	
  0x404079		807c240800		CMPB $0x0, 0x8(SP)		
  0x40407e		752d			JNE 0x4040ad			
				v := *(*unsafe.Pointer)(add(src, i))
  0x404080		488b442430		MOVQ 0x30(SP), AX	
		if off > 0 {
  0x404085		488b4c2420		MOVQ 0x20(SP), CX	
			bits = uint32(*ptrmask)
  0x40408a		488b542428		MOVQ 0x28(SP), DX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40408f		488b5c2460		MOVQ 0x60(SP), BX	
  0x404094		488b742418		MOVQ 0x18(SP), SI	
			bits >>= 1
  0x404099		8b7c2414		MOVL 0x14(SP), DI	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40409d		eb8f			JMP 0x40402e		
			bits >>= 1
  0x40409f		d1ef			SHRL $0x1, DI		
  0x4040a1		eba4			JMP 0x404047		
  0x4040a3		488b6c2438		MOVQ 0x38(SP), BP	
  0x4040a8		4883c440		ADDQ $0x40, SP		
  0x4040ac		c3			RET			
					throw(cgoWriteBarrierFail)
  0x4040ad		488d0557e40600		LEAQ 0x6e457(IP), AX	
  0x4040b4		48890424		MOVQ AX, 0(SP)		
  0x4040b8		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x4040c1		e8baf30100		CALL runtime.throw(SB)	
  0x4040c6		0f0b			UD2			

TEXT runtime.cgoCheckUsingType(SB) /usr/local/go/src/runtime/cgocheck.go
func cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x4040d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4040d9		483b6118		CMPQ 0x18(CX), SP	
  0x4040dd		0f863a020000		JBE 0x40431d		
  0x4040e3		4883ec70		SUBQ $0x70, SP		
  0x4040e7		48896c2468		MOVQ BP, 0x68(SP)	
  0x4040ec		488d6c2468		LEAQ 0x68(SP), BP	
	if typ.kind&kindNoPointers != 0 {
  0x4040f1		488b442478		MOVQ 0x78(SP), AX	
  0x4040f6		0fb64817		MOVZX 0x17(AX), CX	
  0x4040fa		f6c180			TESTL $0x80, CL		
  0x4040fd		0f85f5010000		JNE 0x4042f8		
	if typ.ptrdata <= off {
  0x404103		488b5008		MOVQ 0x8(AX), DX	
  0x404107		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40410f		4839da			CMPQ BX, DX		
  0x404112		0f86d6010000		JBE 0x4042ee		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x404118		4829da			SUBQ BX, DX		
  0x40411b		488bb42490000000	MOVQ 0x90(SP), SI	
  0x404123		4839d6			CMPQ DX, SI		
			if size <= checked {
  0x404126		480f47f2		CMOVA DX, SI		
	if typ.kind&kindGCProg == 0 {
  0x40412a		f6c140			TESTL $0x40, CL		
	if ptrdataSize := typ.ptrdata - off; size > ptrdataSize {
  0x40412d		0f848d010000		JE 0x4042c0		
	switch typ.kind & kindMask {
  0x404133		83e11f			ANDL $0x1f, CX		
	case kindArray:
  0x404136		80f911			CMPL $0x11, CL		
  0x404139		0f85ac000000		JNE 0x4041eb		
		for i := uintptr(0); i < at.len; i++ {
  0x40413f		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x404147		31d2			XORL DX, DX		
  0x404149		eb09			JMP 0x404154		
  0x40414b		48ffc2			INCQ DX			
			size -= checked
  0x40414e		4829fe			SUBQ DI, SI		
			if off < at.elem.size {
  0x404151		4c89c3			MOVQ R8, BX		
		for i := uintptr(0); i < at.len; i++ {
  0x404154		48395040		CMPQ DX, 0x40(AX)	
  0x404158		0f8683000000		JBE 0x4041e1		
			if off < at.elem.size {
  0x40415e		488b7830		MOVQ 0x30(AX), DI	
  0x404162		48391f			CMPQ BX, 0(DI)		
  0x404165		772d			JA 0x404194		
			src = add(src, at.elem.size)
  0x404167		488b7830		MOVQ 0x30(AX), DI	
  0x40416b		488b3f			MOVQ 0(DI), DI		
			if skipped > at.elem.size {
  0x40416e		4839fb			CMPQ DI, BX		
			checked := at.elem.size - skipped
  0x404171		4989d8			MOVQ BX, R8		
  0x404174		480f47df		CMOVA DI, BX		
			src = add(src, at.elem.size)
  0x404178		90			NOPL			
			checked := at.elem.size - skipped
  0x404179		4989f9			MOVQ DI, R9		
  0x40417c		4829df			SUBQ BX, DI		
			off -= skipped
  0x40417f		4929d8			SUBQ BX, R8		
	return unsafe.Pointer(uintptr(p) + x)
  0x404182		4c01c9			ADDQ R9, CX		
			if size <= checked {
  0x404185		4839fe			CMPQ DI, SI		
			if skipped > at.elem.size {
  0x404188		77c1			JA 0x40414b		
				return
  0x40418a		488b6c2468		MOVQ 0x68(SP), BP	
  0x40418f		4883c470		ADDQ $0x70, SP		
  0x404193		c3			RET			
		for i := uintptr(0); i < at.len; i++ {
  0x404194		4889542430		MOVQ DX, 0x30(SP)	
			if size <= checked {
  0x404199		4889b42490000000	MOVQ SI, 0x90(SP)	
				cgoCheckUsingType(at.elem, src, off, size)
  0x4041a1		48894c2450		MOVQ CX, 0x50(SP)	
			if off < at.elem.size {
  0x4041a6		48895c2428		MOVQ BX, 0x28(SP)	
				cgoCheckUsingType(at.elem, src, off, size)
  0x4041ab		48893c24		MOVQ DI, 0(SP)				
  0x4041af		48894c2408		MOVQ CX, 0x8(SP)			
  0x4041b4		48895c2410		MOVQ BX, 0x10(SP)			
  0x4041b9		4889742418		MOVQ SI, 0x18(SP)			
  0x4041be		e80dffffff		CALL runtime.cgoCheckUsingType(SB)	
			src = add(src, at.elem.size)
  0x4041c3		488b442478		MOVQ 0x78(SP), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x4041c8		488b4c2450		MOVQ 0x50(SP), CX	
		for i := uintptr(0); i < at.len; i++ {
  0x4041cd		488b542430		MOVQ 0x30(SP), DX	
			if skipped > at.elem.size {
  0x4041d2		488b5c2428		MOVQ 0x28(SP), BX	
			if size <= checked {
  0x4041d7		488bb42490000000	MOVQ 0x90(SP), SI	
				cgoCheckUsingType(at.elem, src, off, size)
  0x4041df		eb86			JMP 0x404167		
  0x4041e1		488b6c2468		MOVQ 0x68(SP), BP	
  0x4041e6		4883c470		ADDQ $0x70, SP		
  0x4041ea		c3			RET			
	case kindStruct:
  0x4041eb		80f919			CMPL $0x19, CL		
  0x4041ee		0f850e010000		JNE 0x404302		
		for _, f := range st.fields {
  0x4041f4		488b4838		MOVQ 0x38(AX), CX	
  0x4041f8		488b4040		MOVQ 0x40(AX), AX	
  0x4041fc		4885c0			TESTQ AX, AX		
  0x4041ff		7ee0			JLE 0x4041e1		
  0x404201		4889442440		MOVQ AX, 0x40(SP)	
  0x404206		488b942480000000	MOVQ 0x80(SP), DX	
  0x40420e		31ff			XORL DI, DI		
  0x404210		eb0a			JMP 0x40421c		
  0x404212		4883c118		ADDQ $0x18, CX		
  0x404216		4889df			MOVQ BX, DI		
			if off < f.typ.size {
  0x404219		4c89cb			MOVQ R9, BX		
		for _, f := range st.fields {
  0x40421c		4c8b4108		MOVQ 0x8(CX), R8	
			if off < f.typ.size {
  0x404220		493918			CMPQ BX, 0(R8)		
  0x404223		7737			JA 0x40425c		
			src = add(src, f.typ.size)
  0x404225		4d8b00			MOVQ 0(R8), R8		
			if skipped > f.typ.size {
  0x404228		4c39c3			CMPQ R8, BX		
			checked := f.typ.size - skipped
  0x40422b		4989d9			MOVQ BX, R9		
  0x40422e		490f47d8		CMOVA R8, BX		
			src = add(src, f.typ.size)
  0x404232		90			NOPL			
			checked := f.typ.size - skipped
  0x404233		4d89c2			MOVQ R8, R10		
  0x404236		4929d8			SUBQ BX, R8		
			off -= skipped
  0x404239		4929d9			SUBQ BX, R9		
	return unsafe.Pointer(uintptr(p) + x)
  0x40423c		4c01d2			ADDQ R10, DX		
			if size <= checked {
  0x40423f		4c39c6			CMPQ R8, SI		
			if skipped > f.typ.size {
  0x404242		760e			JBE 0x404252		
		for _, f := range st.fields {
  0x404244		488d5f01		LEAQ 0x1(DI), BX	
			size -= checked
  0x404248		4c29c6			SUBQ R8, SI		
		for _, f := range st.fields {
  0x40424b		4839c3			CMPQ AX, BX		
  0x40424e		7cc2			JL 0x404212		
  0x404250		eb8f			JMP 0x4041e1		
				return
  0x404252		488b6c2468		MOVQ 0x68(SP), BP	
  0x404257		4883c470		ADDQ $0x70, SP		
  0x40425b		c3			RET			
		for _, f := range st.fields {
  0x40425c		48894c2460		MOVQ CX, 0x60(SP)	
  0x404261		48897c2438		MOVQ DI, 0x38(SP)	
			if off < f.typ.size {
  0x404266		48895c2420		MOVQ BX, 0x20(SP)	
			if size <= checked {
  0x40426b		4889b42490000000	MOVQ SI, 0x90(SP)	
				cgoCheckUsingType(f.typ, src, off, size)
  0x404273		4889542448		MOVQ DX, 0x48(SP)	
		for _, f := range st.fields {
  0x404278		4c89442458		MOVQ R8, 0x58(SP)	
				cgoCheckUsingType(f.typ, src, off, size)
  0x40427d		4c890424		MOVQ R8, 0(SP)				
  0x404281		4889542408		MOVQ DX, 0x8(SP)			
  0x404286		48895c2410		MOVQ BX, 0x10(SP)			
  0x40428b		4889742418		MOVQ SI, 0x18(SP)			
  0x404290		e83bfeffff		CALL runtime.cgoCheckUsingType(SB)	
		for _, f := range st.fields {
  0x404295		488b442440		MOVQ 0x40(SP), AX	
  0x40429a		488b4c2460		MOVQ 0x60(SP), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40429f		488b542448		MOVQ 0x48(SP), DX	
			if skipped > f.typ.size {
  0x4042a4		488b5c2420		MOVQ 0x20(SP), BX	
			if size <= checked {
  0x4042a9		488bb42490000000	MOVQ 0x90(SP), SI	
		for _, f := range st.fields {
  0x4042b1		488b7c2438		MOVQ 0x38(SP), DI	
			src = add(src, f.typ.size)
  0x4042b6		4c8b442458		MOVQ 0x58(SP), R8	
				cgoCheckUsingType(f.typ, src, off, size)
  0x4042bb		e965ffffff		JMP 0x404225		
		cgoCheckBits(src, typ.gcdata, off, size)
  0x4042c0		488b4020		MOVQ 0x20(AX), AX		
  0x4042c4		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x4042cc		48890c24		MOVQ CX, 0(SP)			
  0x4042d0		4889442408		MOVQ AX, 0x8(SP)		
  0x4042d5		48895c2410		MOVQ BX, 0x10(SP)		
  0x4042da		4889742418		MOVQ SI, 0x18(SP)		
  0x4042df		e8fcfcffff		CALL runtime.cgoCheckBits(SB)	
		return
  0x4042e4		488b6c2468		MOVQ 0x68(SP), BP	
  0x4042e9		4883c470		ADDQ $0x70, SP		
  0x4042ed		c3			RET			
		return
  0x4042ee		488b6c2468		MOVQ 0x68(SP), BP	
  0x4042f3		4883c470		ADDQ $0x70, SP		
  0x4042f7		c3			RET			
		return
  0x4042f8		488b6c2468		MOVQ 0x68(SP), BP	
  0x4042fd		4883c470		ADDQ $0x70, SP		
  0x404301		c3			RET			
		throw("can't happen")
  0x404302		488d05b0b70600		LEAQ 0x6b7b0(IP), AX	
  0x404309		48890424		MOVQ AX, 0(SP)		
  0x40430d		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x404316		e865f10100		CALL runtime.throw(SB)	
  0x40431b		0f0b			UD2			
func cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr) {
  0x40431d		e8ae530300		CALL runtime.morestackc(SB)		
  0x404322		e9a9fdffff		JMP runtime.cgoCheckUsingType(SB)	

TEXT runtime.makechan(SB) /usr/local/go/src/runtime/chan.go
func makechan(t *chantype, size int) *hchan {
  0x404330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404339		483b6110		CMPQ 0x10(CX), SP	
  0x40433d		0f8612020000		JBE 0x404555		
  0x404343		4883ec40		SUBQ $0x40, SP		
  0x404347		48896c2438		MOVQ BP, 0x38(SP)	
  0x40434c		488d6c2438		LEAQ 0x38(SP), BP	
	elem := t.elem
  0x404351		488b4c2448		MOVQ 0x48(SP), CX	
  0x404356		488b4930		MOVQ 0x30(CX), CX	
	if elem.size >= 1<<16 {
  0x40435a		488b01			MOVQ 0(CX), AX		
  0x40435d		483d00000100		CMPQ $0x10000, AX	
  0x404363		0f83d1010000		JAE 0x40453a		
	if hchanSize%maxAlign != 0 || elem.align > maxAlign {
  0x404369		80791508		CMPB $0x8, 0x15(CX)	
  0x40436d		0f87ac010000		JA 0x40451f		
	mem, overflow := math.MulUintptr(elem.size, uintptr(size))
  0x404373		488b542450		MOVQ 0x50(SP), DX	
  0x404378		48f7e2			MULQ DX			
	if overflow || mem > maxAlloc-hchanSize || size < 0 {
  0x40437b		0f8080010000		JO 0x404501			
  0x404381		48baa0ffffffffff0000	MOVQ $0xffffffffffa0, DX	
  0x40438b		4839d0			CMPQ DX, AX			
  0x40438e		0f876d010000		JA 0x404501			
  0x404394		488b542450		MOVQ 0x50(SP), DX		
  0x404399		4885d2			TESTQ DX, DX			
  0x40439c		0f8c5f010000		JL 0x404501			
	elem := t.elem
  0x4043a2		48894c2428		MOVQ CX, 0x28(SP)	
	case mem == 0:
  0x4043a7		4885c0			TESTQ AX, AX		
  0x4043aa		0f8405010000		JE 0x4044b5		
	case elem.kind&kindNoPointers != 0:
  0x4043b0		0fb65917		MOVZX 0x17(CX), BX	
  0x4043b4		f6c380			TESTL $0x80, BL		
  0x4043b7		0f848d000000		JE 0x40444a		
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
  0x4043bd		4883c060		ADDQ $0x60, AX			
  0x4043c1		48890424		MOVQ AX, 0(SP)			
  0x4043c5		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4043ce		c644241001		MOVB $0x1, 0x10(SP)		
  0x4043d3		e838580000		CALL runtime.mallocgc(SB)	
  0x4043d8		488b442418		MOVQ 0x18(SP), AX		
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x4043dd		8400			TESTB AL, 0(AX)		
  0x4043df		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x4043e0		488d4860		LEAQ 0x60(AX), CX	
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x4043e4		833d358a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4043eb		7549			JNE 0x404436				
  0x4043ed		48894810		MOVQ CX, 0x10(AX)			
	c.elemsize = uint16(elem.size)
  0x4043f1		488b4c2428		MOVQ 0x28(SP), CX	
  0x4043f6		488b11			MOVQ 0(CX), DX		
  0x4043f9		66895018		MOVW DX, 0x18(AX)	
	c.elemtype = elem
  0x4043fd		833d1c8a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404404		751c			JNE 0x404422				
  0x404406		48894820		MOVQ CX, 0x20(AX)			
	c.dataqsiz = uint(size)
  0x40440a		488b4c2450		MOVQ 0x50(SP), CX	
  0x40440f		48894808		MOVQ CX, 0x8(AX)	
	return c
  0x404413		4889442458		MOVQ AX, 0x58(SP)	
  0x404418		488b6c2438		MOVQ 0x38(SP), BP	
  0x40441d		4883c440		ADDQ $0x40, SP		
  0x404421		c3			RET			
	c.elemtype = elem
  0x404422		488d7820		LEAQ 0x20(AX), DI	
	c.elemsize = uint16(elem.size)
  0x404426		4889c2			MOVQ AX, DX		
	c.elemtype = elem
  0x404429		4889c8			MOVQ CX, AX			
  0x40442c		e84f520400		CALL runtime.gcWriteBarrier(SB)	
	c.dataqsiz = uint(size)
  0x404431		4889d0			MOVQ DX, AX		
	c.elemtype = elem
  0x404434		ebd4			JMP 0x40440a		
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x404436		488d7810		LEAQ 0x10(AX), DI	
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
  0x40443a		4889c2			MOVQ AX, DX		
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x40443d		4889c8			MOVQ CX, AX			
  0x404440		e83b520400		CALL runtime.gcWriteBarrier(SB)	
	c.elemsize = uint16(elem.size)
  0x404445		4889d0			MOVQ DX, AX		
		c.buf = add(unsafe.Pointer(c), hchanSize)
  0x404448		eba7			JMP 0x4043f1		
	mem, overflow := math.MulUintptr(elem.size, uintptr(size))
  0x40444a		4889442420		MOVQ AX, 0x20(SP)	
		c = new(hchan)
  0x40444f		488d056a660600		LEAQ 0x6666a(IP), AX		
  0x404456		48890424		MOVQ AX, 0(SP)			
  0x40445a		e8f1620000		CALL runtime.newobject(SB)	
  0x40445f		488b442408		MOVQ 0x8(SP), AX		
  0x404464		4889442430		MOVQ AX, 0x30(SP)		
		c.buf = mallocgc(mem, elem, true)
  0x404469		488b4c2420		MOVQ 0x20(SP), CX			
  0x40446e		48890c24		MOVQ CX, 0(SP)				
  0x404472		488b4c2428		MOVQ 0x28(SP), CX			
  0x404477		48894c2408		MOVQ CX, 0x8(SP)			
  0x40447c		c644241001		MOVB $0x1, 0x10(SP)			
  0x404481		e88a570000		CALL runtime.mallocgc(SB)		
  0x404486		488b442418		MOVQ 0x18(SP), AX			
  0x40448b		833d8e890d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404492		7511			JNE 0x4044a5				
  0x404494		488b4c2430		MOVQ 0x30(SP), CX			
  0x404499		48894110		MOVQ AX, 0x10(CX)			
	c.elemsize = uint16(elem.size)
  0x40449d		4889c8			MOVQ CX, AX		
	switch {
  0x4044a0		e94cffffff		JMP 0x4043f1		
		c.buf = mallocgc(mem, elem, true)
  0x4044a5		488b4c2430		MOVQ 0x30(SP), CX		
  0x4044aa		488d7910		LEAQ 0x10(CX), DI		
  0x4044ae		e8cd510400		CALL runtime.gcWriteBarrier(SB)	
  0x4044b3		ebe8			JMP 0x40449d			
		c = (*hchan)(mallocgc(hchanSize, nil, true))
  0x4044b5		48c7042460000000	MOVQ $0x60, 0(SP)		
  0x4044bd		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4044c6		c644241001		MOVB $0x1, 0x10(SP)		
  0x4044cb		e840570000		CALL runtime.mallocgc(SB)	
  0x4044d0		488b442418		MOVQ 0x18(SP), AX		
	return unsafe.Pointer(&c.buf)
  0x4044d5		8400			TESTB AL, 0(AX)		
		c.buf = c.raceaddr()
  0x4044d7		90			NOPL			
	return unsafe.Pointer(&c.buf)
  0x4044d8		488d7810		LEAQ 0x10(AX), DI	
		c.buf = c.raceaddr()
  0x4044dc		833d3d890d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4044e3		7509			JNE 0x4044ee				
  0x4044e5		48897810		MOVQ DI, 0x10(AX)			
  0x4044e9		e903ffffff		JMP 0x4043f1				
		c = (*hchan)(mallocgc(hchanSize, nil, true))
  0x4044ee		4889c1			MOVQ AX, CX		
		c.buf = c.raceaddr()
  0x4044f1		4889f8			MOVQ DI, AX			
  0x4044f4		e887510400		CALL runtime.gcWriteBarrier(SB)	
	c.elemsize = uint16(elem.size)
  0x4044f9		4889c8			MOVQ CX, AX		
		c.buf = c.raceaddr()
  0x4044fc		e9f0feffff		JMP 0x4043f1		
		panic(plainError("makechan: size out of range"))
  0x404501		488d05f8ab0500		LEAQ 0x5abf8(IP), AX			
  0x404508		48890424		MOVQ AX, 0(SP)				
  0x40450c		488d053d8a0700		LEAQ runtime.statictmp_1(SB), AX	
  0x404513		4889442408		MOVQ AX, 0x8(SP)			
  0x404518		e893e90100		CALL runtime.gopanic(SB)		
  0x40451d		0f0b			UD2					
		throw("makechan: bad alignment")
  0x40451f		488d0555c70600		LEAQ 0x6c755(IP), AX	
  0x404526		48890424		MOVQ AX, 0(SP)		
  0x40452a		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x404533		e848ef0100		CALL runtime.throw(SB)	
  0x404538		0f0b			UD2			
		throw("makechan: invalid channel element type")
  0x40453a		488d055de20600		LEAQ 0x6e25d(IP), AX	
  0x404541		48890424		MOVQ AX, 0(SP)		
  0x404545		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x40454e		e82def0100		CALL runtime.throw(SB)	
  0x404553		0f0b			UD2			
func makechan(t *chantype, size int) *hchan {
  0x404555		e826330400		CALL runtime.morestack_noctxt(SB)	
  0x40455a		e9d1fdffff		JMP runtime.makechan(SB)		

TEXT runtime.chansend1(SB) /usr/local/go/src/runtime/chan.go
func chansend1(c *hchan, elem unsafe.Pointer) {
  0x404560		4883ec30		SUBQ $0x30, SP		
  0x404564		48896c2428		MOVQ BP, 0x28(SP)	
  0x404569		488d6c2428		LEAQ 0x28(SP), BP	
	chansend(c, elem, true, getcallerpc())
  0x40456e		488b442438		MOVQ 0x38(SP), AX		
  0x404573		48890424		MOVQ AX, 0(SP)			
  0x404577		488b442440		MOVQ 0x40(SP), AX		
  0x40457c		4889442408		MOVQ AX, 0x8(SP)		
  0x404581		c644241001		MOVB $0x1, 0x10(SP)		
  0x404586		488b442430		MOVQ 0x30(SP), AX		
  0x40458b		4889442418		MOVQ AX, 0x18(SP)		
  0x404590		e80b000000		CALL runtime.chansend(SB)	
}
  0x404595		488b6c2428		MOVQ 0x28(SP), BP	
  0x40459a		4883c430		ADDQ $0x30, SP		
  0x40459e		c3			RET			

TEXT runtime.chansend(SB) /usr/local/go/src/runtime/chan.go
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4045a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4045a9		483b6110		CMPQ 0x10(CX), SP	
  0x4045ad		0f861b060000		JBE 0x404bce		
  0x4045b3		4883ec78		SUBQ $0x78, SP		
  0x4045b7		48896c2470		MOVQ BP, 0x70(SP)	
  0x4045bc		488d6c2470		LEAQ 0x70(SP), BP	
	if c == nil {
  0x4045c1		488b842480000000	MOVQ 0x80(SP), AX	
  0x4045c9		4885c0			TESTQ AX, AX		
  0x4045cc		0f8423050000		JE 0x404af5		
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4045d2		0fb68c2490000000	MOVZX 0x90(SP), CX	
  0x4045da		84c9			TESTL CL, CL		
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
  0x4045dc		753f			JNE 0x40461d		
  0x4045de		83781c00		CMPL $0x0, 0x1c(AX)	
  0x4045e2		7539			JNE 0x40461d		
  0x4045e4		488b5008		MOVQ 0x8(AX), DX	
  0x4045e8		4885d2			TESTQ DX, DX		
  0x4045eb		750e			JNE 0x4045fb		
  0x4045ed		4883783800		CMPQ $0x0, 0x38(AX)	
  0x4045f2		0f84f3040000		JE 0x404aeb		
  0x4045f8		4885d2			TESTQ DX, DX		
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
  0x4045fb		0f86e3040000		JBE 0x404ae4		
  0x404601		483910			CMPQ DX, 0(AX)		
  0x404604		0f94c2			SETE DL			
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
  0x404607		84d2			TESTL DL, DL		
  0x404609		7412			JE 0x40461d		
		return false
  0x40460b		c68424a000000000	MOVB $0x0, 0xa0(SP)	
  0x404613		488b6c2470		MOVQ 0x70(SP), BP	
  0x404618		4883c478		ADDQ $0x78, SP		
  0x40461c		c3			RET			
	if blockprofilerate > 0 {
  0x40461d		48833d0b870d0000	CMPQ $0x0, runtime.blockprofilerate(SB)	
  0x404625		0f87a3040000		JA 0x404ace				
  0x40462b		31d2			XORL DX, DX				
	if t0 != 0 {
  0x40462d		4889542428		MOVQ DX, 0x28(SP)	
	lock(&c.lock)
  0x404632		488d4858		LEAQ 0x58(AX), CX	
  0x404636		48894c2458		MOVQ CX, 0x58(SP)	
  0x40463b		48890c24		MOVQ CX, 0(SP)		
  0x40463f		e89c400000		CALL runtime.lock(SB)	
	if c.closed != 0 {
  0x404644		488b842480000000	MOVQ 0x80(SP), AX	
  0x40464c		83781c00		CMPL $0x0, 0x1c(AX)	
  0x404650		0f8515050000		JNE 0x404b6b		
	if sg := c.recvq.dequeue(); sg != nil {
  0x404656		488d4838		LEAQ 0x38(AX), CX			
  0x40465a		48890c24		MOVQ CX, 0(SP)				
  0x40465e		e8fd120000		CALL runtime.(*waitq).dequeue(SB)	
  0x404663		488b442408		MOVQ 0x8(SP), AX			
  0x404668		4885c0			TESTQ AX, AX				
  0x40466b		0f85fc030000		JNE 0x404a6d				
	if c.qcount < c.dataqsiz {
  0x404671		488b842480000000	MOVQ 0x80(SP), AX	
  0x404679		488b4808		MOVQ 0x8(AX), CX	
  0x40467d		483908			CMPQ CX, 0(AX)		
  0x404680		0f8272030000		JB 0x4049f8		
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x404686		0fb68c2490000000	MOVZX 0x90(SP), CX	
  0x40468e		84c9			TESTL CL, CL		
	if !block {
  0x404690		7520			JNE 0x4046b2		
		unlock(&c.lock)
  0x404692		488b442458		MOVQ 0x58(SP), AX	
  0x404697		48890424		MOVQ AX, 0(SP)		
  0x40469b		e8f0410000		CALL runtime.unlock(SB)	
		return false
  0x4046a0		c68424a000000000	MOVB $0x0, 0xa0(SP)	
  0x4046a8		488b6c2470		MOVQ 0x70(SP), BP	
  0x4046ad		4883c478		ADDQ $0x78, SP		
  0x4046b1		c3			RET			
	gp := getg()
  0x4046b2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4046bb		4889442438		MOVQ AX, 0x38(SP)	
	mysg := acquireSudog()
  0x4046c0		e84b0c0200		CALL runtime.acquireSudog(SB)	
  0x4046c5		488b0424		MOVQ 0(SP), AX			
	mysg.releasetime = 0
  0x4046c9		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	if t0 != 0 {
  0x4046d1		488b4c2428		MOVQ 0x28(SP), CX	
  0x4046d6		4885c9			TESTQ CX, CX		
  0x4046d9		7408			JE 0x4046e3		
		mysg.releasetime = -1
  0x4046db		48c74030ffffffff	MOVQ $-0x1, 0x30(AX)	
	mysg.elem = ep
  0x4046e3		833d36870d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4046ea		0f85c9020000		JNE 0x4049b9				
  0x4046f0		488b942488000000	MOVQ 0x88(SP), DX			
  0x4046f8		48895020		MOVQ DX, 0x20(AX)			
	mysg.waitlink = nil
  0x4046fc		48c7404800000000	MOVQ $0x0, 0x48(AX)	
	mysg.g = gp
  0x404704		488b5c2438		MOVQ 0x38(SP), BX	
  0x404709		488918			MOVQ BX, 0(AX)		
	mysg.isSelect = false
  0x40470c		c6400800		MOVB $0x0, 0x8(AX)	
	mysg.c = c
  0x404710		488d7858		LEAQ 0x58(AX), DI			
  0x404714		833d05870d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40471b		0f8578020000		JNE 0x404999				
  0x404721		488bb42480000000	MOVQ 0x80(SP), SI			
  0x404729		48897058		MOVQ SI, 0x58(AX)			
	gp.waiting = mysg
  0x40472d		8403			TESTB AL, 0(BX)		
  0x40472f		4c8d8338010000		LEAQ 0x138(BX), R8	
	gp.param = nil
  0x404736		4c8d8b88000000		LEAQ 0x88(BX), R9	
	gp.waiting = mysg
  0x40473d		833ddc860d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404744		0f852c020000		JNE 0x404976				
  0x40474a		48898338010000		MOVQ AX, 0x138(BX)			
	gp.param = nil
  0x404751		48c7838800000000000000	MOVQ $0x0, 0x88(BX)	
	c.sendq.enqueue(mysg)
  0x40475c		90			NOPL			
	sgp.next = nil
  0x40475d		833dbc860d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404764		0f85ed010000		JNE 0x404957				
  0x40476a		48c7401000000000	MOVQ $0x0, 0x10(AX)			
	mysg := acquireSudog()
  0x404772		4889442430		MOVQ AX, 0x30(SP)	
	mysg.c = c
  0x404777		48897c2450		MOVQ DI, 0x50(SP)	
	gp.waiting = mysg
  0x40477c		4c89442448		MOVQ R8, 0x48(SP)	
	gp.param = nil
  0x404781		4c894c2440		MOVQ R9, 0x40(SP)	
	x := q.last
  0x404786		4c8d5650		LEAQ 0x50(SI), R10	
  0x40478a		4c8b5e50		MOVQ 0x50(SI), R11	
	if x == nil {
  0x40478e		4d85db			TESTQ R11, R11		
  0x404791		0f8472010000		JE 0x404909		
	sgp.prev = x
  0x404797		833d82860d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40479e		0f8534010000		JNE 0x4048d8				
  0x4047a4		4c895818		MOVQ R11, 0x18(AX)			
	x.next = sgp
  0x4047a8		49894310		MOVQ AX, 0x10(R11)	
	q.last = sgp
  0x4047ac		48894650		MOVQ AX, 0x50(SI)	
	goparkunlock(&c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)
  0x4047b0		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x4047b1		488d0578f10600		LEAQ 0x6f178(IP), AX	
  0x4047b8		48890424		MOVQ AX, 0(SP)		
  0x4047bc		488b442458		MOVQ 0x58(SP), AX	
  0x4047c1		4889442408		MOVQ AX, 0x8(SP)	
  0x4047c6		66c74424100e16		MOVW $0x160e, 0x10(SP)	
  0x4047cd		48c744241803000000	MOVQ $0x3, 0x18(SP)	
  0x4047d6		e875090200		CALL runtime.gopark(SB)	
	if mysg != gp.waiting {
  0x4047db		488b442430		MOVQ 0x30(SP), AX	
  0x4047e0		488b4c2438		MOVQ 0x38(SP), CX	
  0x4047e5		48398138010000		CMPQ AX, 0x138(CX)	
  0x4047ec		0f855e030000		JNE 0x404b50		
	gp.waiting = nil
  0x4047f2		833d27860d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4047f9		0f85c2000000		JNE 0x4048c1				
  0x4047ff		48c7813801000000000000	MOVQ $0x0, 0x138(CX)			
	if gp.param == nil {
  0x40480a		4883b98800000000	CMPQ $0x0, 0x88(CX)	
  0x404812		0f8492000000		JE 0x4048aa		
	gp.param = nil
  0x404818		833d01860d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40481f		7575			JNE 0x404896				
  0x404821		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
	if mysg.releasetime > 0 {
  0x40482c		488b4830		MOVQ 0x30(AX), CX	
  0x404830		4885c9			TESTQ CX, CX		
  0x404833		7f40			JG 0x404875		
	mysg.c = nil
  0x404835		833de4850d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40483c		7523			JNE 0x404861				
  0x40483e		48c7405800000000	MOVQ $0x0, 0x58(AX)			
	releaseSudog(mysg)
  0x404846		48890424		MOVQ AX, 0(SP)			
  0x40484a		e8610e0200		CALL runtime.releaseSudog(SB)	
	return true
  0x40484f		c68424a000000001	MOVB $0x1, 0xa0(SP)	
  0x404857		488b6c2470		MOVQ 0x70(SP), BP	
  0x40485c		4883c478		ADDQ $0x78, SP		
  0x404860		c3			RET			
	mysg.c = nil
  0x404861		488b7c2450		MOVQ 0x50(SP), DI	
	mysg := acquireSudog()
  0x404866		4889c1			MOVQ AX, CX		
	mysg.c = nil
  0x404869		31c0			XORL AX, AX			
  0x40486b		e8104e0400		CALL runtime.gcWriteBarrier(SB)	
	releaseSudog(mysg)
  0x404870		4889c8			MOVQ CX, AX		
	mysg.c = nil
  0x404873		ebd1			JMP 0x404846		
		blockevent(mysg.releasetime-t0, 2)
  0x404875		488b442428		MOVQ 0x28(SP), AX		
  0x40487a		4829c1			SUBQ AX, CX			
  0x40487d		48890c24		MOVQ CX, 0(SP)			
  0x404881		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40488a		e8b1b60100		CALL runtime.blockevent(SB)	
	mysg.c = nil
  0x40488f		488b442430		MOVQ 0x30(SP), AX	
		blockevent(mysg.releasetime-t0, 2)
  0x404894		eb9f			JMP 0x404835		
	gp.param = nil
  0x404896		488b7c2440		MOVQ 0x40(SP), DI	
	mysg := acquireSudog()
  0x40489b		4889c1			MOVQ AX, CX		
	gp.param = nil
  0x40489e		31c0			XORL AX, AX			
  0x4048a0		e8db4d0400		CALL runtime.gcWriteBarrier(SB)	
	if mysg.releasetime > 0 {
  0x4048a5		4889c8			MOVQ CX, AX		
	gp.param = nil
  0x4048a8		eb82			JMP 0x40482c		
		if c.closed == 0 {
  0x4048aa		488b842480000000	MOVQ 0x80(SP), AX	
  0x4048b2		83781c00		CMPL $0x0, 0x1c(AX)	
  0x4048b6		0f845b020000		JE 0x404b17		
  0x4048bc		e971020000		JMP 0x404b32		
	gp.waiting = nil
  0x4048c1		488b7c2448		MOVQ 0x48(SP), DI	
	mysg := acquireSudog()
  0x4048c6		4889c2			MOVQ AX, DX		
	gp.waiting = nil
  0x4048c9		31c0			XORL AX, AX			
  0x4048cb		e8b04d0400		CALL runtime.gcWriteBarrier(SB)	
	if mysg.releasetime > 0 {
  0x4048d0		4889d0			MOVQ DX, AX		
	gp.waiting = nil
  0x4048d3		e932ffffff		JMP 0x40480a		
	sgp.prev = x
  0x4048d8		4c8d6018		LEAQ 0x18(AX), R12	
	mysg.c = c
  0x4048dc		4989fd			MOVQ DI, R13		
	sgp.prev = x
  0x4048df		4c89e7			MOVQ R12, DI		
	mysg := acquireSudog()
  0x4048e2		4989c6			MOVQ AX, R14		
	sgp.prev = x
  0x4048e5		4c89d8			MOVQ R11, AX			
  0x4048e8		e8934d0400		CALL runtime.gcWriteBarrier(SB)	
	x.next = sgp
  0x4048ed		488d7810		LEAQ 0x10(AX), DI		
  0x4048f1		4c89f0			MOVQ R14, AX			
  0x4048f4		e8874d0400		CALL runtime.gcWriteBarrier(SB)	
	q.last = sgp
  0x4048f9		4c89d7			MOVQ R10, DI			
  0x4048fc		e87f4d0400		CALL runtime.gcWriteBarrier(SB)	
	mysg.c = nil
  0x404901		4c89ef			MOVQ R13, DI		
	sgp.prev = x
  0x404904		e9a7feffff		JMP 0x4047b0		
		sgp.prev = nil
  0x404909		833d10850d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404910		7515			JNE 0x404927				
  0x404912		48c7401800000000	MOVQ $0x0, 0x18(AX)			
		q.first = sgp
  0x40491a		48894648		MOVQ AX, 0x48(SI)	
		q.last = sgp
  0x40491e		48894650		MOVQ AX, 0x50(SI)	
		sgp.prev = nil
  0x404922		e989feffff		JMP 0x4047b0		
  0x404927		4c8d5818		LEAQ 0x18(AX), R11	
	mysg.c = c
  0x40492b		4989fc			MOVQ DI, R12		
		sgp.prev = nil
  0x40492e		4c89df			MOVQ R11, DI		
	mysg := acquireSudog()
  0x404931		4989c5			MOVQ AX, R13		
		sgp.prev = nil
  0x404934		31c0			XORL AX, AX			
  0x404936		e8454d0400		CALL runtime.gcWriteBarrier(SB)	
		q.first = sgp
  0x40493b		488d7e48		LEAQ 0x48(SI), DI		
  0x40493f		4c89e8			MOVQ R13, AX			
  0x404942		e8394d0400		CALL runtime.gcWriteBarrier(SB)	
		q.last = sgp
  0x404947		4c89d7			MOVQ R10, DI			
  0x40494a		e8314d0400		CALL runtime.gcWriteBarrier(SB)	
	mysg.c = nil
  0x40494f		4c89e7			MOVQ R12, DI		
		sgp.prev = nil
  0x404952		e959feffff		JMP 0x4047b0		
	sgp.next = nil
  0x404957		4c8d5010		LEAQ 0x10(AX), R10	
	mysg.c = c
  0x40495b		4989fb			MOVQ DI, R11		
	sgp.next = nil
  0x40495e		4c89d7			MOVQ R10, DI		
	mysg := acquireSudog()
  0x404961		4989c4			MOVQ AX, R12		
	sgp.next = nil
  0x404964		31c0			XORL AX, AX			
  0x404966		e8154d0400		CALL runtime.gcWriteBarrier(SB)	
	sgp.prev = x
  0x40496b		4c89e0			MOVQ R12, AX		
	mysg.c = nil
  0x40496e		4c89df			MOVQ R11, DI		
	sgp.next = nil
  0x404971		e9fcfdffff		JMP 0x404772		
	mysg.c = c
  0x404976		4989fa			MOVQ DI, R10		
	gp.waiting = mysg
  0x404979		4c89c7			MOVQ R8, DI			
  0x40497c		e8ff4c0400		CALL runtime.gcWriteBarrier(SB)	
	gp.param = nil
  0x404981		4c89cf			MOVQ R9, DI		
	mysg := acquireSudog()
  0x404984		4989c3			MOVQ AX, R11		
	gp.param = nil
  0x404987		31c0			XORL AX, AX			
  0x404989		e8f24c0400		CALL runtime.gcWriteBarrier(SB)	
	sgp.next = nil
  0x40498e		4c89d8			MOVQ R11, AX		
	mysg.c = nil
  0x404991		4c89d7			MOVQ R10, DI		
	gp.waiting = mysg
  0x404994		e9c3fdffff		JMP 0x40475c		
	mysg := acquireSudog()
  0x404999		4889c6			MOVQ AX, SI		
	mysg.c = c
  0x40499c		488b842480000000	MOVQ 0x80(SP), AX		
  0x4049a4		e8d74c0400		CALL runtime.gcWriteBarrier(SB)	
	gp.waiting = mysg
  0x4049a9		4889f0			MOVQ SI, AX		
	x := q.last
  0x4049ac		488bb42480000000	MOVQ 0x80(SP), SI	
	mysg.c = c
  0x4049b4		e974fdffff		JMP 0x40472d		
	mysg.elem = ep
  0x4049b9		488d7820		LEAQ 0x20(AX), DI	
	mysg := acquireSudog()
  0x4049bd		4889c2			MOVQ AX, DX		
	mysg.elem = ep
  0x4049c0		488b842488000000	MOVQ 0x88(SP), AX		
  0x4049c8		e8b34c0400		CALL runtime.gcWriteBarrier(SB)	
	mysg.waitlink = nil
  0x4049cd		488d7a48		LEAQ 0x48(DX), DI	
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x4049d1		4889c3			MOVQ AX, BX		
	mysg.waitlink = nil
  0x4049d4		31c0			XORL AX, AX			
  0x4049d6		e8a54c0400		CALL runtime.gcWriteBarrier(SB)	
	mysg.g = gp
  0x4049db		4889d7			MOVQ DX, DI			
  0x4049de		488b442438		MOVQ 0x38(SP), AX		
  0x4049e3		e8984c0400		CALL runtime.gcWriteBarrier(SB)	
	mysg.isSelect = false
  0x4049e8		4889f8			MOVQ DI, AX		
	KeepAlive(ep)
  0x4049eb		4889da			MOVQ BX, DX		
	gp.waiting = mysg
  0x4049ee		488b5c2438		MOVQ 0x38(SP), BX	
	mysg.elem = ep
  0x4049f3		e914fdffff		JMP 0x40470c		
		qp := chanbuf(c, c.sendx)
  0x4049f8		90			NOPL			
  0x4049f9		488b4828		MOVQ 0x28(AX), CX	
		typedmemmove(c.elemtype, qp, ep)
  0x4049fd		488b5020		MOVQ 0x20(AX), DX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x404a01		90			NOPL			
  0x404a02		0fb75818		MOVZX 0x18(AX), BX	
  0x404a06		480fafcb		IMULQ BX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x404a0a		48034810		ADDQ 0x10(AX), CX	
		typedmemmove(c.elemtype, qp, ep)
  0x404a0e		48891424		MOVQ DX, 0(SP)			
  0x404a12		48894c2408		MOVQ CX, 0x8(SP)		
  0x404a17		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x404a1f		48894c2410		MOVQ CX, 0x10(SP)		
  0x404a24		e8678b0000		CALL runtime.typedmemmove(SB)	
		c.sendx++
  0x404a29		488b842480000000	MOVQ 0x80(SP), AX	
  0x404a31		488b4828		MOVQ 0x28(AX), CX	
  0x404a35		48ffc1			INCQ CX			
  0x404a38		48894828		MOVQ CX, 0x28(AX)	
		if c.sendx == c.dataqsiz {
  0x404a3c		48394808		CMPQ CX, 0x8(AX)	
  0x404a40		7508			JNE 0x404a4a		
			c.sendx = 0
  0x404a42		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		c.qcount++
  0x404a4a		48ff00			INCQ 0(AX)		
		unlock(&c.lock)
  0x404a4d		488b442458		MOVQ 0x58(SP), AX	
  0x404a52		48890424		MOVQ AX, 0(SP)		
  0x404a56		e8353e0000		CALL runtime.unlock(SB)	
		return true
  0x404a5b		c68424a000000001	MOVB $0x1, 0xa0(SP)	
  0x404a63		488b6c2470		MOVQ 0x70(SP), BP	
  0x404a68		4883c478		ADDQ $0x78, SP		
  0x404a6c		c3			RET			
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x404a6d		0f57c0			XORPS X0, X0				
  0x404a70		0f11442460		MOVUPS X0, 0x60(SP)			
  0x404a75		488d0d74fd0300		LEAQ runtime.chansend.func1(SB), CX	
  0x404a7c		48894c2460		MOVQ CX, 0x60(SP)			
  0x404a81		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x404a89		48894c2468		MOVQ CX, 0x68(SP)			
  0x404a8e		48890c24		MOVQ CX, 0(SP)				
  0x404a92		4889442408		MOVQ AX, 0x8(SP)			
  0x404a97		488b842488000000	MOVQ 0x88(SP), AX			
  0x404a9f		4889442410		MOVQ AX, 0x10(SP)			
  0x404aa4		488d442460		LEAQ 0x60(SP), AX			
  0x404aa9		4889442418		MOVQ AX, 0x18(SP)			
  0x404aae		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x404ab7		e824010000		CALL runtime.send(SB)			
		return true
  0x404abc		c68424a000000001	MOVB $0x1, 0xa0(SP)	
  0x404ac4		488b6c2470		MOVQ 0x70(SP), BP	
  0x404ac9		4883c478		ADDQ $0x78, SP		
  0x404acd		c3			RET			
		t0 = cputicks()
  0x404ace		e83d450400		CALL runtime.cputicks(SB)	
  0x404ad3		488b1424		MOVQ 0(SP), DX			
	lock(&c.lock)
  0x404ad7		488b842480000000	MOVQ 0x80(SP), AX	
		t0 = cputicks()
  0x404adf		e949fbffff		JMP 0x40462d		
  0x404ae4		31d2			XORL DX, DX		
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
  0x404ae6		e91cfbffff		JMP 0x404607		
  0x404aeb		ba01000000		MOVL $0x1, DX		
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
  0x404af0		e912fbffff		JMP 0x404607		
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x404af5		0fb6842490000000	MOVZX 0x90(SP), AX	
  0x404afd		84c0			TESTL AL, AL		
		if !block {
  0x404aff		0f8592000000		JNE 0x404b97		
			return false
  0x404b05		c68424a000000000	MOVB $0x0, 0xa0(SP)	
  0x404b0d		488b6c2470		MOVQ 0x70(SP), BP	
  0x404b12		4883c478		ADDQ $0x78, SP		
  0x404b16		c3			RET			
			throw("chansend: spurious wakeup")
  0x404b17		488d05e2c40600		LEAQ 0x6c4e2(IP), AX	
  0x404b1e		48890424		MOVQ AX, 0(SP)		
  0x404b22		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x404b2b		e850e90100		CALL runtime.throw(SB)	
  0x404b30		0f0b			UD2			
		panic(plainError("send on closed channel"))
  0x404b32		488d05c7a50500		LEAQ 0x5a5c7(IP), AX			
  0x404b39		48890424		MOVQ AX, 0(SP)				
  0x404b3d		488d05ac840700		LEAQ runtime.statictmp_3(SB), AX	
  0x404b44		4889442408		MOVQ AX, 0x8(SP)			
  0x404b49		e862e30100		CALL runtime.gopanic(SB)		
  0x404b4e		0f0b			UD2					
		throw("G waiting list is corrupted")
  0x404b50		488d05a5c70600		LEAQ 0x6c7a5(IP), AX	
  0x404b57		48890424		MOVQ AX, 0(SP)		
  0x404b5b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x404b64		e817e90100		CALL runtime.throw(SB)	
  0x404b69		0f0b			UD2			
		unlock(&c.lock)
  0x404b6b		488b442458		MOVQ 0x58(SP), AX	
  0x404b70		48890424		MOVQ AX, 0(SP)		
  0x404b74		e8173d0000		CALL runtime.unlock(SB)	
		panic(plainError("send on closed channel"))
  0x404b79		488d0580a50500		LEAQ 0x5a580(IP), AX			
  0x404b80		48890424		MOVQ AX, 0(SP)				
  0x404b84		488d0515840700		LEAQ runtime.statictmp_2(SB), AX	
  0x404b8b		4889442408		MOVQ AX, 0x8(SP)			
  0x404b90		e81be30100		CALL runtime.gopanic(SB)		
  0x404b95		0f0b			UD2					
		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
  0x404b97		0f57c0			XORPS X0, X0		
  0x404b9a		0f110424		MOVUPS X0, 0(SP)	
  0x404b9e		66c74424100410		MOVW $0x1004, 0x10(SP)	
  0x404ba5		48c744241802000000	MOVQ $0x2, 0x18(SP)	
  0x404bae		e89d050200		CALL runtime.gopark(SB)	
		throw("unreachable")
  0x404bb3		488d05bcad0600		LEAQ 0x6adbc(IP), AX	
  0x404bba		48890424		MOVQ AX, 0(SP)		
  0x404bbe		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x404bc7		e8b4e80100		CALL runtime.throw(SB)	
  0x404bcc		0f0b			UD2			
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
  0x404bce		e8ad2c0400		CALL runtime.morestack_noctxt(SB)	
  0x404bd3		e9c8f9ffff		JMP runtime.chansend(SB)		

TEXT runtime.send(SB) /usr/local/go/src/runtime/chan.go
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x404be0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404be9		483b6110		CMPQ 0x10(CX), SP	
  0x404bed		0f86fe000000		JBE 0x404cf1		
  0x404bf3		4883ec28		SUBQ $0x28, SP		
  0x404bf7		48896c2420		MOVQ BP, 0x20(SP)	
  0x404bfc		488d6c2420		LEAQ 0x20(SP), BP	
	if sg.elem != nil {
  0x404c01		488b442438		MOVQ 0x38(SP), AX	
  0x404c06		4883782000		CMPQ $0x0, 0x20(AX)	
  0x404c0b		0f858c000000		JNE 0x404c9d		
	gp := sg.g
  0x404c11		488b08			MOVQ 0(AX), CX		
  0x404c14		48894c2418		MOVQ CX, 0x18(SP)	
	unlockf()
  0x404c19		488b542448		MOVQ 0x48(SP), DX	
  0x404c1e		488b1a			MOVQ 0(DX), BX		
  0x404c21		ffd3			CALL BX			
	gp.param = unsafe.Pointer(sg)
  0x404c23		488b442418		MOVQ 0x18(SP), AX			
  0x404c28		8400			TESTB AL, 0(AX)				
  0x404c2a		833def810d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404c31		754c			JNE 0x404c7f				
  0x404c33		488b4c2438		MOVQ 0x38(SP), CX			
  0x404c38		48898888000000		MOVQ CX, 0x88(AX)			
	if sg.releasetime != 0 {
  0x404c3f		4883793000		CMPQ $0x0, 0x30(CX)	
  0x404c44		7520			JNE 0x404c66		
	goready(gp, skip+1)
  0x404c46		48890424		MOVQ AX, 0(SP)			
  0x404c4a		488b442450		MOVQ 0x50(SP), AX		
  0x404c4f		48ffc0			INCQ AX				
  0x404c52		4889442408		MOVQ AX, 0x8(SP)		
  0x404c57		e844060200		CALL runtime.goready(SB)	
}
  0x404c5c		488b6c2420		MOVQ 0x20(SP), BP	
  0x404c61		4883c428		ADDQ $0x28, SP		
  0x404c65		c3			RET			
		sg.releasetime = cputicks()
  0x404c66		e8a5430400		CALL runtime.cputicks(SB)	
  0x404c6b		488b0424		MOVQ 0(SP), AX			
  0x404c6f		488b4c2438		MOVQ 0x38(SP), CX		
  0x404c74		48894130		MOVQ AX, 0x30(CX)		
	goready(gp, skip+1)
  0x404c78		488b442418		MOVQ 0x18(SP), AX	
		sg.releasetime = cputicks()
  0x404c7d		ebc7			JMP 0x404c46		
	gp.param = unsafe.Pointer(sg)
  0x404c7f		488db888000000		LEAQ 0x88(AX), DI	
	gp := sg.g
  0x404c86		4889c1			MOVQ AX, CX		
	gp.param = unsafe.Pointer(sg)
  0x404c89		488b442438		MOVQ 0x38(SP), AX		
  0x404c8e		e8ed490400		CALL runtime.gcWriteBarrier(SB)	
	goready(gp, skip+1)
  0x404c93		4889c8			MOVQ CX, AX		
	if sg.releasetime != 0 {
  0x404c96		488b4c2438		MOVQ 0x38(SP), CX	
	gp.param = unsafe.Pointer(sg)
  0x404c9b		eba2			JMP 0x404c3f		
		sendDirect(c.elemtype, sg, ep)
  0x404c9d		488b4c2430		MOVQ 0x30(SP), CX		
  0x404ca2		488b4920		MOVQ 0x20(CX), CX		
  0x404ca6		48890c24		MOVQ CX, 0(SP)			
  0x404caa		4889442408		MOVQ AX, 0x8(SP)		
  0x404caf		488b4c2440		MOVQ 0x40(SP), CX		
  0x404cb4		48894c2410		MOVQ CX, 0x10(SP)		
  0x404cb9		e842000000		CALL runtime.sendDirect(SB)	
		sg.elem = nil
  0x404cbe		833d5b810d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404cc5		7512			JNE 0x404cd9				
  0x404cc7		488b442438		MOVQ 0x38(SP), AX			
  0x404ccc		48c7402000000000	MOVQ $0x0, 0x20(AX)			
  0x404cd4		e938ffffff		JMP 0x404c11				
	if sg.elem != nil {
  0x404cd9		488b4c2438		MOVQ 0x38(SP), CX	
  0x404cde		488d7920		LEAQ 0x20(CX), DI	
		sg.elem = nil
  0x404ce2		31c0			XORL AX, AX			
  0x404ce4		e897490400		CALL runtime.gcWriteBarrier(SB)	
	gp := sg.g
  0x404ce9		4889c8			MOVQ CX, AX		
		sg.elem = nil
  0x404cec		e920ffffff		JMP 0x404c11		
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x404cf1		e88a2b0400		CALL runtime.morestack_noctxt(SB)	
  0x404cf6		e9e5feffff		JMP runtime.send(SB)			

TEXT runtime.sendDirect(SB) /usr/local/go/src/runtime/chan.go
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
  0x404d00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404d09		483b6110		CMPQ 0x10(CX), SP	
  0x404d0d		7670			JBE 0x404d7f		
  0x404d0f		4883ec30		SUBQ $0x30, SP		
  0x404d13		48896c2428		MOVQ BP, 0x28(SP)	
  0x404d18		488d6c2428		LEAQ 0x28(SP), BP	
	dst := sg.elem
  0x404d1d		488b442440		MOVQ 0x40(SP), AX	
  0x404d22		488b4020		MOVQ 0x20(AX), AX	
  0x404d26		4889442420		MOVQ AX, 0x20(SP)	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x404d2b		488b4c2438		MOVQ 0x38(SP), CX			
  0x404d30		488b11			MOVQ 0(CX), DX				
  0x404d33		48890c24		MOVQ CX, 0(SP)				
  0x404d37		4889442408		MOVQ AX, 0x8(SP)			
  0x404d3c		488b442448		MOVQ 0x48(SP), AX			
  0x404d41		4889442410		MOVQ AX, 0x10(SP)			
  0x404d46		4889542418		MOVQ DX, 0x18(SP)			
  0x404d4b		e8709c0000		CALL runtime.typeBitsBulkBarrier(SB)	
	memmove(dst, src, t.size)
  0x404d50		488b442438		MOVQ 0x38(SP), AX		
  0x404d55		488b00			MOVQ 0(AX), AX			
  0x404d58		488b4c2420		MOVQ 0x20(SP), CX		
  0x404d5d		48890c24		MOVQ CX, 0(SP)			
  0x404d61		488b4c2448		MOVQ 0x48(SP), CX		
  0x404d66		48894c2408		MOVQ CX, 0x8(SP)		
  0x404d6b		4889442410		MOVQ AX, 0x10(SP)		
  0x404d70		e8db590400		CALL runtime.memmove(SB)	
}
  0x404d75		488b6c2428		MOVQ 0x28(SP), BP	
  0x404d7a		4883c430		ADDQ $0x30, SP		
  0x404d7e		c3			RET			
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {
  0x404d7f		e8fc2a0400		CALL runtime.morestack_noctxt(SB)	
  0x404d84		e977ffffff		JMP runtime.sendDirect(SB)		

TEXT runtime.recvDirect(SB) /usr/local/go/src/runtime/chan.go
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
  0x404d90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404d99		483b6110		CMPQ 0x10(CX), SP	
  0x404d9d		7670			JBE 0x404e0f		
  0x404d9f		4883ec30		SUBQ $0x30, SP		
  0x404da3		48896c2428		MOVQ BP, 0x28(SP)	
  0x404da8		488d6c2428		LEAQ 0x28(SP), BP	
	src := sg.elem
  0x404dad		488b442440		MOVQ 0x40(SP), AX	
  0x404db2		488b4020		MOVQ 0x20(AX), AX	
  0x404db6		4889442420		MOVQ AX, 0x20(SP)	
	typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)
  0x404dbb		488b4c2438		MOVQ 0x38(SP), CX			
  0x404dc0		488b11			MOVQ 0(CX), DX				
  0x404dc3		48890c24		MOVQ CX, 0(SP)				
  0x404dc7		488b5c2448		MOVQ 0x48(SP), BX			
  0x404dcc		48895c2408		MOVQ BX, 0x8(SP)			
  0x404dd1		4889442410		MOVQ AX, 0x10(SP)			
  0x404dd6		4889542418		MOVQ DX, 0x18(SP)			
  0x404ddb		e8e09b0000		CALL runtime.typeBitsBulkBarrier(SB)	
	memmove(dst, src, t.size)
  0x404de0		488b442438		MOVQ 0x38(SP), AX		
  0x404de5		488b00			MOVQ 0(AX), AX			
  0x404de8		488b4c2448		MOVQ 0x48(SP), CX		
  0x404ded		48890c24		MOVQ CX, 0(SP)			
  0x404df1		488b4c2420		MOVQ 0x20(SP), CX		
  0x404df6		48894c2408		MOVQ CX, 0x8(SP)		
  0x404dfb		4889442410		MOVQ AX, 0x10(SP)		
  0x404e00		e84b590400		CALL runtime.memmove(SB)	
}
  0x404e05		488b6c2428		MOVQ 0x28(SP), BP	
  0x404e0a		4883c430		ADDQ $0x30, SP		
  0x404e0e		c3			RET			
func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {
  0x404e0f		e86c2a0400		CALL runtime.morestack_noctxt(SB)	
  0x404e14		e977ffffff		JMP runtime.recvDirect(SB)		

TEXT runtime.closechan(SB) /usr/local/go/src/runtime/chan.go
func closechan(c *hchan) {
  0x404e20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x404e29		483b6110		CMPQ 0x10(CX), SP	
  0x404e2d		0f865f020000		JBE 0x405092		
  0x404e33		4883ec38		SUBQ $0x38, SP		
  0x404e37		48896c2430		MOVQ BP, 0x30(SP)	
  0x404e3c		488d6c2430		LEAQ 0x30(SP), BP	
	if c == nil {
  0x404e41		488b442440		MOVQ 0x40(SP), AX	
  0x404e46		4885c0			TESTQ AX, AX		
  0x404e49		0f8425020000		JE 0x405074		
	lock(&c.lock)
  0x404e4f		488d4858		LEAQ 0x58(AX), CX	
  0x404e53		48894c2428		MOVQ CX, 0x28(SP)	
  0x404e58		48890c24		MOVQ CX, 0(SP)		
  0x404e5c		e87f380000		CALL runtime.lock(SB)	
	if c.closed != 0 {
  0x404e61		488b442440		MOVQ 0x40(SP), AX	
  0x404e66		83781c00		CMPL $0x0, 0x1c(AX)	
  0x404e6a		0f85d8010000		JNE 0x405048		
	c.closed = 1
  0x404e70		c7401c01000000		MOVL $0x1, 0x1c(AX)	
	var glist gList
  0x404e77		48c744241000000000	MOVQ $0x0, 0x10(SP)	
	for {
  0x404e80		eb18			JMP 0x404e9a		
		glist.push(gp)
  0x404e82		90			NOPL			
	gp.schedlink = l.head
  0x404e83		488b542410		MOVQ 0x10(SP), DX	
  0x404e88		488991a0000000		MOVQ DX, 0xa0(CX)	
	l.head.set(gp)
  0x404e8f		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x404e90		48894c2410		MOVQ CX, 0x10(SP)	
		sg := c.recvq.dequeue()
  0x404e95		488b442440		MOVQ 0x40(SP), AX			
  0x404e9a		488d4838		LEAQ 0x38(AX), CX			
  0x404e9e		48890c24		MOVQ CX, 0(SP)				
  0x404ea2		e8b90a0000		CALL runtime.(*waitq).dequeue(SB)	
  0x404ea7		488b442408		MOVQ 0x8(SP), AX			
		if sg == nil {
  0x404eac		4885c0			TESTQ AX, AX		
  0x404eaf		0f84ae000000		JE 0x404f63		
		sg := c.recvq.dequeue()
  0x404eb5		4889442420		MOVQ AX, 0x20(SP)	
		if sg.elem != nil {
  0x404eba		488b4820		MOVQ 0x20(AX), CX	
  0x404ebe		4885c9			TESTQ CX, CX		
  0x404ec1		7549			JNE 0x404f0c		
		if sg.releasetime != 0 {
  0x404ec3		4883783000		CMPQ $0x0, 0x30(AX)	
  0x404ec8		752b			JNE 0x404ef5		
		gp := sg.g
  0x404eca		488b08			MOVQ 0(AX), CX		
		gp.param = nil
  0x404ecd		8401			TESTB AL, 0(CX)				
  0x404ecf		833d4a7f0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404ed6		750d			JNE 0x404ee5				
  0x404ed8		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
  0x404ee3		eb9d			JMP 0x404e82				
  0x404ee5		488db988000000		LEAQ 0x88(CX), DI			
  0x404eec		31c0			XORL AX, AX				
  0x404eee		e88d470400		CALL runtime.gcWriteBarrier(SB)		
  0x404ef3		eb8d			JMP 0x404e82				
			sg.releasetime = cputicks()
  0x404ef5		e816410400		CALL runtime.cputicks(SB)	
  0x404efa		488b0424		MOVQ 0(SP), AX			
  0x404efe		488b4c2420		MOVQ 0x20(SP), CX		
  0x404f03		48894130		MOVQ AX, 0x30(CX)		
		gp := sg.g
  0x404f07		4889c8			MOVQ CX, AX		
			sg.releasetime = cputicks()
  0x404f0a		ebbe			JMP 0x404eca		
			typedmemclr(c.elemtype, sg.elem)
  0x404f0c		488b442440		MOVQ 0x40(SP), AX		
  0x404f11		488b5020		MOVQ 0x20(AX), DX		
  0x404f15		48891424		MOVQ DX, 0(SP)			
  0x404f19		48894c2408		MOVQ CX, 0x8(SP)		
  0x404f1e		e81d890000		CALL runtime.typedmemclr(SB)	
			sg.elem = nil
  0x404f23		833df67e0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404f2a		7512			JNE 0x404f3e				
  0x404f2c		488b4c2420		MOVQ 0x20(SP), CX			
  0x404f31		48c7412000000000	MOVQ $0x0, 0x20(CX)			
		if sg.releasetime != 0 {
  0x404f39		4889c8			MOVQ CX, AX		
			sg.elem = nil
  0x404f3c		eb85			JMP 0x404ec3		
		if sg.elem != nil {
  0x404f3e		488b4c2420		MOVQ 0x20(SP), CX	
  0x404f43		488d7920		LEAQ 0x20(CX), DI	
			sg.elem = nil
  0x404f47		31c0			XORL AX, AX			
  0x404f49		e832470400		CALL runtime.gcWriteBarrier(SB)	
  0x404f4e		ebe9			JMP 0x404f39			
		glist.push(gp)
  0x404f50		90			NOPL			
	gp.schedlink = l.head
  0x404f51		488b442410		MOVQ 0x10(SP), AX	
  0x404f56		488981a0000000		MOVQ AX, 0xa0(CX)	
	l.head.set(gp)
  0x404f5d		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x404f5e		48894c2410		MOVQ CX, 0x10(SP)	
		sg := c.sendq.dequeue()
  0x404f63		488b442440		MOVQ 0x40(SP), AX			
  0x404f68		488d4848		LEAQ 0x48(AX), CX			
  0x404f6c		48890c24		MOVQ CX, 0(SP)				
  0x404f70		e8eb090000		CALL runtime.(*waitq).dequeue(SB)	
  0x404f75		488b442408		MOVQ 0x8(SP), AX			
		if sg == nil {
  0x404f7a		4885c0			TESTQ AX, AX		
  0x404f7d		7472			JE 0x404ff1		
		sg.elem = nil
  0x404f7f		833d9a7e0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404f86		7556			JNE 0x404fde				
  0x404f88		48c7402000000000	MOVQ $0x0, 0x20(AX)			
		if sg.releasetime != 0 {
  0x404f90		4883783000		CMPQ $0x0, 0x30(AX)	
  0x404f95		752b			JNE 0x404fc2		
		gp := sg.g
  0x404f97		488b08			MOVQ 0(AX), CX		
		gp.param = nil
  0x404f9a		8401			TESTB AL, 0(CX)				
  0x404f9c		833d7d7e0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x404fa3		750d			JNE 0x404fb2				
  0x404fa5		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
  0x404fb0		eb9e			JMP 0x404f50				
  0x404fb2		488db988000000		LEAQ 0x88(CX), DI			
  0x404fb9		31c0			XORL AX, AX				
  0x404fbb		e8c0460400		CALL runtime.gcWriteBarrier(SB)		
  0x404fc0		eb8e			JMP 0x404f50				
		sg := c.sendq.dequeue()
  0x404fc2		4889442418		MOVQ AX, 0x18(SP)	
			sg.releasetime = cputicks()
  0x404fc7		e844400400		CALL runtime.cputicks(SB)	
  0x404fcc		488b0424		MOVQ 0(SP), AX			
  0x404fd0		488b4c2418		MOVQ 0x18(SP), CX		
  0x404fd5		48894130		MOVQ AX, 0x30(CX)		
		gp := sg.g
  0x404fd9		4889c8			MOVQ CX, AX		
			sg.releasetime = cputicks()
  0x404fdc		ebb9			JMP 0x404f97		
		sg.elem = nil
  0x404fde		488d7820		LEAQ 0x20(AX), DI	
		sg := c.sendq.dequeue()
  0x404fe2		4889c1			MOVQ AX, CX		
		sg.elem = nil
  0x404fe5		31c0			XORL AX, AX			
  0x404fe7		e894460400		CALL runtime.gcWriteBarrier(SB)	
		if sg.releasetime != 0 {
  0x404fec		4889c8			MOVQ CX, AX		
		sg.elem = nil
  0x404fef		eb9f			JMP 0x404f90		
	unlock(&c.lock)
  0x404ff1		488b442428		MOVQ 0x28(SP), AX	
  0x404ff6		48890424		MOVQ AX, 0(SP)		
  0x404ffa		e891380000		CALL runtime.unlock(SB)	
	for !glist.empty() {
  0x404fff		eb1d			JMP 0x40501e		
		gp.schedlink = 0
  0x405001		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
		goready(gp, 3)
  0x40500c		48890424		MOVQ AX, 0(SP)			
  0x405010		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x405019		e882020200		CALL runtime.goready(SB)	
	for !glist.empty() {
  0x40501e		90			NOPL			
	return l.head == 0
  0x40501f		488b442410		MOVQ 0x10(SP), AX	
  0x405024		4885c0			TESTQ AX, AX		
	for !glist.empty() {
  0x405027		7415			JE 0x40503e		
		gp := glist.pop()
  0x405029		90			NOPL			
	gp := l.head.ptr()
  0x40502a		90			NOPL			
	if gp != nil {
  0x40502b		4885c0			TESTQ AX, AX		
  0x40502e		74d1			JE 0x405001		
		l.head = gp.schedlink
  0x405030		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x405037		48894c2410		MOVQ CX, 0x10(SP)	
  0x40503c		ebc3			JMP 0x405001		
  0x40503e		488b6c2430		MOVQ 0x30(SP), BP	
  0x405043		4883c438		ADDQ $0x38, SP		
  0x405047		c3			RET			
		unlock(&c.lock)
  0x405048		488b442428		MOVQ 0x28(SP), AX	
  0x40504d		48890424		MOVQ AX, 0(SP)		
  0x405051		e83a380000		CALL runtime.unlock(SB)	
		panic(plainError("close of closed channel"))
  0x405056		488d05a3a00500		LEAQ 0x5a0a3(IP), AX			
  0x40505d		48890424		MOVQ AX, 0(SP)				
  0x405061		488d05c87f0700		LEAQ runtime.statictmp_5(SB), AX	
  0x405068		4889442408		MOVQ AX, 0x8(SP)			
  0x40506d		e83ede0100		CALL runtime.gopanic(SB)		
  0x405072		0f0b			UD2					
		panic(plainError("close of nil channel"))
  0x405074		488d0585a00500		LEAQ 0x5a085(IP), AX			
  0x40507b		48890424		MOVQ AX, 0(SP)				
  0x40507f		488d059a7f0700		LEAQ runtime.statictmp_4(SB), AX	
  0x405086		4889442408		MOVQ AX, 0x8(SP)			
  0x40508b		e820de0100		CALL runtime.gopanic(SB)		
  0x405090		0f0b			UD2					
func closechan(c *hchan) {
  0x405092		e8e9270400		CALL runtime.morestack_noctxt(SB)	
  0x405097		e984fdffff		JMP runtime.closechan(SB)		

TEXT runtime.chanrecv1(SB) /usr/local/go/src/runtime/chan.go
func chanrecv1(c *hchan, elem unsafe.Pointer) {
  0x4050a0		4883ec28		SUBQ $0x28, SP		
  0x4050a4		48896c2420		MOVQ BP, 0x20(SP)	
  0x4050a9		488d6c2420		LEAQ 0x20(SP), BP	
	chanrecv(c, elem, true)
  0x4050ae		488b442430		MOVQ 0x30(SP), AX		
  0x4050b3		48890424		MOVQ AX, 0(SP)			
  0x4050b7		488b442438		MOVQ 0x38(SP), AX		
  0x4050bc		4889442408		MOVQ AX, 0x8(SP)		
  0x4050c1		c644241001		MOVB $0x1, 0x10(SP)		
  0x4050c6		e815000000		CALL runtime.chanrecv(SB)	
}
  0x4050cb		488b6c2420		MOVQ 0x20(SP), BP	
  0x4050d0		4883c428		ADDQ $0x28, SP		
  0x4050d4		c3			RET			

TEXT runtime.chanrecv(SB) /usr/local/go/src/runtime/chan.go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x4050e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4050e9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4050ee		483b4110		CMPQ 0x10(CX), AX	
  0x4050f2		0f8691060000		JBE 0x405789		
  0x4050f8		4881ec88000000		SUBQ $0x88, SP		
  0x4050ff		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x405107		488dac2480000000	LEAQ 0x80(SP), BP	
	if c == nil {
  0x40510f		488b842490000000	MOVQ 0x90(SP), AX	
  0x405117		4885c0			TESTQ AX, AX		
  0x40511a		0f84eb050000		JE 0x40570b		
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x405120		0fb68c24a0000000	MOVZX 0xa0(SP), CX	
  0x405128		84c9			TESTL CL, CL		
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x40512a		0f84a7050000		JE 0x4056d7		
  0x405130		31d2			XORL DX, DX		
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
  0x405132		84d2			TESTL DL, DL		
  0x405134		0f8496050000		JE 0x4056d0		
		atomic.Load(&c.closed) == 0 {
  0x40513a		8b501c			MOVL 0x1c(AX), DX	
  0x40513d		85d2			TESTL DX, DX		
  0x40513f		0f94c2			SETE DL			
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x405142		84d2			TESTL DL, DL		
  0x405144		0f8566050000		JNE 0x4056b0		
	if blockprofilerate > 0 {
  0x40514a		48833dde7b0d0000	CMPQ $0x0, runtime.blockprofilerate(SB)	
  0x405152		0f8742050000		JA 0x40569a				
  0x405158		31d2			XORL DX, DX				
	if t0 != 0 {
  0x40515a		4889542428		MOVQ DX, 0x28(SP)	
	lock(&c.lock)
  0x40515f		488d4858		LEAQ 0x58(AX), CX	
  0x405163		48894c2468		MOVQ CX, 0x68(SP)	
  0x405168		48890c24		MOVQ CX, 0(SP)		
  0x40516c		e86f350000		CALL runtime.lock(SB)	
	if c.closed != 0 && c.qcount == 0 {
  0x405171		488b842490000000	MOVQ 0x90(SP), AX	
  0x405179		83781c00		CMPL $0x0, 0x1c(AX)	
  0x40517d		740a			JE 0x405189		
  0x40517f		48833800		CMPQ $0x0, 0(AX)	
  0x405183		0f84ba040000		JE 0x405643		
	if sg := c.sendq.dequeue(); sg != nil {
  0x405189		488d4848		LEAQ 0x48(AX), CX			
  0x40518d		48890c24		MOVQ CX, 0(SP)				
  0x405191		e8ca070000		CALL runtime.(*waitq).dequeue(SB)	
  0x405196		488b442408		MOVQ 0x8(SP), AX			
  0x40519b		4885c0			TESTQ AX, AX				
  0x40519e		0f8530040000		JNE 0x4055d4				
	if c.qcount > 0 {
  0x4051a4		488b842490000000	MOVQ 0x90(SP), AX	
  0x4051ac		48833800		CMPQ $0x0, 0(AX)	
  0x4051b0		0f86b1000000		JBE 0x405267		
		qp := chanbuf(c, c.recvx)
  0x4051b6		90			NOPL			
  0x4051b7		488b4830		MOVQ 0x30(AX), CX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x4051bb		90			NOPL			
  0x4051bc		0fb75018		MOVZX 0x18(AX), DX	
  0x4051c0		480fafca		IMULQ DX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4051c4		48034810		ADDQ 0x10(AX), CX	
		if ep != nil {
  0x4051c8		488b942498000000	MOVQ 0x98(SP), DX	
  0x4051d0		4885d2			TESTQ DX, DX		
  0x4051d3		7564			JNE 0x405239		
		typedmemclr(c.elemtype, qp)
  0x4051d5		488b5020		MOVQ 0x20(AX), DX		
  0x4051d9		48891424		MOVQ DX, 0(SP)			
  0x4051dd		48894c2408		MOVQ CX, 0x8(SP)		
  0x4051e2		e859860000		CALL runtime.typedmemclr(SB)	
		c.recvx++
  0x4051e7		488b842490000000	MOVQ 0x90(SP), AX	
  0x4051ef		488b4830		MOVQ 0x30(AX), CX	
  0x4051f3		48ffc1			INCQ CX			
  0x4051f6		48894830		MOVQ CX, 0x30(AX)	
		if c.recvx == c.dataqsiz {
  0x4051fa		48394808		CMPQ CX, 0x8(AX)	
  0x4051fe		7508			JNE 0x405208		
			c.recvx = 0
  0x405200		48c7403000000000	MOVQ $0x0, 0x30(AX)	
		c.qcount--
  0x405208		48ff08			DECQ 0(AX)		
		unlock(&c.lock)
  0x40520b		488b442468		MOVQ 0x68(SP), AX	
  0x405210		48890424		MOVQ AX, 0(SP)		
  0x405214		e877360000		CALL runtime.unlock(SB)	
		return true, true
  0x405219		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x405221		c68424a900000001	MOVB $0x1, 0xa9(SP)	
  0x405229		488bac2480000000	MOVQ 0x80(SP), BP	
  0x405231		4881c488000000		ADDQ $0x88, SP		
  0x405238		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x405239		48894c2440		MOVQ CX, 0x40(SP)	
			typedmemmove(c.elemtype, ep, qp)
  0x40523e		488b5820		MOVQ 0x20(AX), BX		
  0x405242		48891c24		MOVQ BX, 0(SP)			
  0x405246		4889542408		MOVQ DX, 0x8(SP)		
  0x40524b		48894c2410		MOVQ CX, 0x10(SP)		
  0x405250		e83b830000		CALL runtime.typedmemmove(SB)	
		typedmemclr(c.elemtype, qp)
  0x405255		488b842490000000	MOVQ 0x90(SP), AX	
  0x40525d		488b4c2440		MOVQ 0x40(SP), CX	
			typedmemmove(c.elemtype, ep, qp)
  0x405262		e96effffff		JMP 0x4051d5		
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x405267		0fb68c24a0000000	MOVZX 0xa0(SP), CX	
  0x40526f		84c9			TESTL CL, CL		
	if !block {
  0x405271		752e			JNE 0x4052a1		
		unlock(&c.lock)
  0x405273		488b442468		MOVQ 0x68(SP), AX	
  0x405278		48890424		MOVQ AX, 0(SP)		
  0x40527c		e80f360000		CALL runtime.unlock(SB)	
		return false, false
  0x405281		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x405289		c68424a900000000	MOVB $0x0, 0xa9(SP)	
  0x405291		488bac2480000000	MOVQ 0x80(SP), BP	
  0x405299		4881c488000000		ADDQ $0x88, SP		
  0x4052a0		c3			RET			
	gp := getg()
  0x4052a1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4052aa		4889442448		MOVQ AX, 0x48(SP)	
	mysg := acquireSudog()
  0x4052af		e85c000200		CALL runtime.acquireSudog(SB)	
  0x4052b4		488b0424		MOVQ 0(SP), AX			
	mysg.releasetime = 0
  0x4052b8		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	if t0 != 0 {
  0x4052c0		488b4c2428		MOVQ 0x28(SP), CX	
  0x4052c5		4885c9			TESTQ CX, CX		
  0x4052c8		7408			JE 0x4052d2		
		mysg.releasetime = -1
  0x4052ca		48c74030ffffffff	MOVQ $-0x1, 0x30(AX)	
	mysg.elem = ep
  0x4052d2		833d477b0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4052d9		0f85ce020000		JNE 0x4055ad				
  0x4052df		488b942498000000	MOVQ 0x98(SP), DX			
  0x4052e7		48895020		MOVQ DX, 0x20(AX)			
	mysg.waitlink = nil
  0x4052eb		48c7404800000000	MOVQ $0x0, 0x48(AX)	
	gp.waiting = mysg
  0x4052f3		488b542448		MOVQ 0x48(SP), DX			
  0x4052f8		8402			TESTB AL, 0(DX)				
  0x4052fa		488dba38010000		LEAQ 0x138(DX), DI			
  0x405301		833d187b0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x405308		0f8581020000		JNE 0x40558f				
  0x40530e		48898238010000		MOVQ AX, 0x138(DX)			
	mysg.g = gp
  0x405315		488910			MOVQ DX, 0(AX)		
	mysg.isSelect = false
  0x405318		c6400800		MOVB $0x0, 0x8(AX)	
	mysg.c = c
  0x40531c		488d5858		LEAQ 0x58(AX), BX	
	gp.param = nil
  0x405320		488db288000000		LEAQ 0x88(DX), SI	
	mysg.c = c
  0x405327		833df27a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40532e		0f852a020000		JNE 0x40555e				
  0x405334		4c8b842490000000	MOVQ 0x90(SP), R8			
  0x40533c		4c894058		MOVQ R8, 0x58(AX)			
	gp.param = nil
  0x405340		48c7828800000000000000	MOVQ $0x0, 0x88(DX)	
	c.recvq.enqueue(mysg)
  0x40534b		90			NOPL			
	sgp.next = nil
  0x40534c		833dcd7a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x405353		0f85e6010000		JNE 0x40553f				
  0x405359		48c7401000000000	MOVQ $0x0, 0x10(AX)			
	mysg := acquireSudog()
  0x405361		4889442438		MOVQ AX, 0x38(SP)	
	gp.waiting = mysg
  0x405366		48897c2460		MOVQ DI, 0x60(SP)	
	mysg.c = c
  0x40536b		48895c2458		MOVQ BX, 0x58(SP)	
	gp.param = nil
  0x405370		4889742450		MOVQ SI, 0x50(SP)	
	x := q.last
  0x405375		4d8d4840		LEAQ 0x40(R8), R9	
  0x405379		4d8b5040		MOVQ 0x40(R8), R10	
	if x == nil {
  0x40537d		4d85d2			TESTQ R10, R10		
  0x405380		0f846b010000		JE 0x4054f1		
	sgp.prev = x
  0x405386		833d937a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40538d		0f852d010000		JNE 0x4054c0				
  0x405393		4c895018		MOVQ R10, 0x18(AX)			
	x.next = sgp
  0x405397		49894210		MOVQ AX, 0x10(R10)	
	q.last = sgp
  0x40539b		49894040		MOVQ AX, 0x40(R8)	
	goparkunlock(&c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)
  0x40539f		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x4053a0		488d0589e50600		LEAQ 0x6e589(IP), AX	
  0x4053a7		48890424		MOVQ AX, 0(SP)		
  0x4053ab		488b442468		MOVQ 0x68(SP), AX	
  0x4053b0		4889442408		MOVQ AX, 0x8(SP)	
  0x4053b5		66c74424100d17		MOVW $0x170d, 0x10(SP)	
  0x4053bc		48c744241803000000	MOVQ $0x3, 0x18(SP)	
  0x4053c5		e886fd0100		CALL runtime.gopark(SB)	
	if mysg != gp.waiting {
  0x4053ca		488b442438		MOVQ 0x38(SP), AX	
  0x4053cf		488b4c2448		MOVQ 0x48(SP), CX	
  0x4053d4		48398138010000		CMPQ AX, 0x138(CX)	
  0x4053db		0f8556030000		JNE 0x405737		
	gp.waiting = nil
  0x4053e1		833d387a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4053e8		0f85bb000000		JNE 0x4054a9				
  0x4053ee		48c7813801000000000000	MOVQ $0x0, 0x138(CX)			
	if mysg.releasetime > 0 {
  0x4053f9		488b5030		MOVQ 0x30(AX), DX	
  0x4053fd		4885d2			TESTQ DX, DX		
  0x405400		7f7e			JG 0x405480		
	closed := gp.param == nil
  0x405402		488b9188000000		MOVQ 0x88(CX), DX	
  0x405409		4889542430		MOVQ DX, 0x30(SP)	
  0x40540e		4883fa00		CMPQ $0x0, DX		
	gp.param = nil
  0x405412		833d077a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x405419		7545			JNE 0x405460				
  0x40541b		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
	mysg.c = nil
  0x405426		48c7405800000000	MOVQ $0x0, 0x58(AX)	
	releaseSudog(mysg)
  0x40542e		48890424		MOVQ AX, 0(SP)			
  0x405432		e879020200		CALL runtime.releaseSudog(SB)	
	return true, !closed
  0x405437		c68424a800000001	MOVB $0x1, 0xa8(SP)	
	closed := gp.param == nil
  0x40543f		488b442430		MOVQ 0x30(SP), AX	
  0x405444		4883f800		CMPQ $0x0, AX		
	return true, !closed
  0x405448		0f958424a9000000	SETNE 0xa9(SP)		
  0x405450		488bac2480000000	MOVQ 0x80(SP), BP	
  0x405458		4881c488000000		ADDQ $0x88, SP		
  0x40545f		c3			RET			
	gp.param = nil
  0x405460		488b7c2450		MOVQ 0x50(SP), DI	
	mysg := acquireSudog()
  0x405465		4889c1			MOVQ AX, CX		
	gp.param = nil
  0x405468		31c0			XORL AX, AX			
  0x40546a		e811420400		CALL runtime.gcWriteBarrier(SB)	
	mysg.c = nil
  0x40546f		488b7c2458		MOVQ 0x58(SP), DI		
  0x405474		31c0			XORL AX, AX			
  0x405476		e805420400		CALL runtime.gcWriteBarrier(SB)	
	releaseSudog(mysg)
  0x40547b		4889c8			MOVQ CX, AX		
	gp.param = nil
  0x40547e		ebae			JMP 0x40542e		
		blockevent(mysg.releasetime-t0, 2)
  0x405480		488b442428		MOVQ 0x28(SP), AX		
  0x405485		4829c2			SUBQ AX, DX			
  0x405488		48891424		MOVQ DX, 0(SP)			
  0x40548c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x405495		e8a6aa0100		CALL runtime.blockevent(SB)	
	mysg.c = nil
  0x40549a		488b442438		MOVQ 0x38(SP), AX	
	closed := gp.param == nil
  0x40549f		488b4c2448		MOVQ 0x48(SP), CX	
		blockevent(mysg.releasetime-t0, 2)
  0x4054a4		e959ffffff		JMP 0x405402		
	gp.waiting = nil
  0x4054a9		488b7c2460		MOVQ 0x60(SP), DI	
	mysg := acquireSudog()
  0x4054ae		4889c2			MOVQ AX, DX		
	gp.waiting = nil
  0x4054b1		31c0			XORL AX, AX			
  0x4054b3		e8c8410400		CALL runtime.gcWriteBarrier(SB)	
	if mysg.releasetime > 0 {
  0x4054b8		4889d0			MOVQ DX, AX		
	gp.waiting = nil
  0x4054bb		e939ffffff		JMP 0x4053f9		
	sgp.prev = x
  0x4054c0		4c8d4018		LEAQ 0x18(AX), R8	
	gp.waiting = mysg
  0x4054c4		4989fb			MOVQ DI, R11		
	sgp.prev = x
  0x4054c7		4c89c7			MOVQ R8, DI		
	mysg := acquireSudog()
  0x4054ca		4989c4			MOVQ AX, R12		
	sgp.prev = x
  0x4054cd		4c89d0			MOVQ R10, AX			
  0x4054d0		e8ab410400		CALL runtime.gcWriteBarrier(SB)	
	x.next = sgp
  0x4054d5		488d7810		LEAQ 0x10(AX), DI		
  0x4054d9		4c89e0			MOVQ R12, AX			
  0x4054dc		e89f410400		CALL runtime.gcWriteBarrier(SB)	
	q.last = sgp
  0x4054e1		4c89cf			MOVQ R9, DI			
  0x4054e4		e897410400		CALL runtime.gcWriteBarrier(SB)	
	gp.waiting = nil
  0x4054e9		4c89df			MOVQ R11, DI		
	sgp.prev = x
  0x4054ec		e9aefeffff		JMP 0x40539f		
		sgp.prev = nil
  0x4054f1		833d28790d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4054f8		7515			JNE 0x40550f				
  0x4054fa		48c7401800000000	MOVQ $0x0, 0x18(AX)			
		q.first = sgp
  0x405502		49894038		MOVQ AX, 0x38(R8)	
		q.last = sgp
  0x405506		49894040		MOVQ AX, 0x40(R8)	
		sgp.prev = nil
  0x40550a		e990feffff		JMP 0x40539f		
  0x40550f		4c8d5018		LEAQ 0x18(AX), R10	
	gp.waiting = mysg
  0x405513		4989fb			MOVQ DI, R11		
		sgp.prev = nil
  0x405516		4c89d7			MOVQ R10, DI		
	mysg := acquireSudog()
  0x405519		4989c4			MOVQ AX, R12		
		sgp.prev = nil
  0x40551c		31c0			XORL AX, AX			
  0x40551e		e85d410400		CALL runtime.gcWriteBarrier(SB)	
		q.first = sgp
  0x405523		498d7838		LEAQ 0x38(R8), DI		
  0x405527		4c89e0			MOVQ R12, AX			
  0x40552a		e851410400		CALL runtime.gcWriteBarrier(SB)	
		q.last = sgp
  0x40552f		4c89cf			MOVQ R9, DI			
  0x405532		e849410400		CALL runtime.gcWriteBarrier(SB)	
	gp.waiting = nil
  0x405537		4c89df			MOVQ R11, DI		
		sgp.prev = nil
  0x40553a		e960feffff		JMP 0x40539f		
	sgp.next = nil
  0x40553f		4c8d4810		LEAQ 0x10(AX), R9	
	gp.waiting = mysg
  0x405543		4989fa			MOVQ DI, R10		
	sgp.next = nil
  0x405546		4c89cf			MOVQ R9, DI		
	mysg := acquireSudog()
  0x405549		4989c3			MOVQ AX, R11		
	sgp.next = nil
  0x40554c		31c0			XORL AX, AX			
  0x40554e		e82d410400		CALL runtime.gcWriteBarrier(SB)	
	sgp.prev = x
  0x405553		4c89d8			MOVQ R11, AX		
	gp.waiting = nil
  0x405556		4c89d7			MOVQ R10, DI		
	sgp.next = nil
  0x405559		e903feffff		JMP 0x405361		
	gp.waiting = mysg
  0x40555e		4989f8			MOVQ DI, R8		
	mysg.c = c
  0x405561		4889df			MOVQ BX, DI		
	mysg := acquireSudog()
  0x405564		4989c1			MOVQ AX, R9		
	mysg.c = c
  0x405567		488b842490000000	MOVQ 0x90(SP), AX		
  0x40556f		e80c410400		CALL runtime.gcWriteBarrier(SB)	
	gp.param = nil
  0x405574		4889f7			MOVQ SI, DI		
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x405577		4989c2			MOVQ AX, R10		
	gp.param = nil
  0x40557a		31c0			XORL AX, AX			
  0x40557c		e8ff400400		CALL runtime.gcWriteBarrier(SB)	
	sgp.next = nil
  0x405581		4c89c8			MOVQ R9, AX		
	gp.waiting = nil
  0x405584		4c89c7			MOVQ R8, DI		
	x := q.last
  0x405587		4d89d0			MOVQ R10, R8		
	mysg.c = c
  0x40558a		e9bcfdffff		JMP 0x40534b		
	gp.waiting = mysg
  0x40558f		e8ec400400		CALL runtime.gcWriteBarrier(SB)	
  0x405594		4889fb			MOVQ DI, BX			
	mysg.g = gp
  0x405597		4889c7			MOVQ AX, DI			
  0x40559a		4889d0			MOVQ DX, AX			
  0x40559d		e8de400400		CALL runtime.gcWriteBarrier(SB)	
	mysg.isSelect = false
  0x4055a2		4889f8			MOVQ DI, AX		
	gp.waiting = nil
  0x4055a5		4889df			MOVQ BX, DI		
	gp.waiting = mysg
  0x4055a8		e96bfdffff		JMP 0x405318		
	mysg.elem = ep
  0x4055ad		488d7820		LEAQ 0x20(AX), DI	
	mysg := acquireSudog()
  0x4055b1		4889c2			MOVQ AX, DX		
	mysg.elem = ep
  0x4055b4		488b842498000000	MOVQ 0x98(SP), AX		
  0x4055bc		e8bf400400		CALL runtime.gcWriteBarrier(SB)	
	mysg.waitlink = nil
  0x4055c1		488d7a48		LEAQ 0x48(DX), DI		
  0x4055c5		31c0			XORL AX, AX			
  0x4055c7		e8b4400400		CALL runtime.gcWriteBarrier(SB)	
	gp.waiting = mysg
  0x4055cc		4889d0			MOVQ DX, AX		
	mysg.elem = ep
  0x4055cf		e91ffdffff		JMP 0x4052f3		
		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x4055d4		0f57c0			XORPS X0, X0				
  0x4055d7		0f11442470		MOVUPS X0, 0x70(SP)			
  0x4055dc		488d0d5df20300		LEAQ runtime.chanrecv.func1(SB), CX	
  0x4055e3		48894c2470		MOVQ CX, 0x70(SP)			
  0x4055e8		488b8c2490000000	MOVQ 0x90(SP), CX			
  0x4055f0		48894c2478		MOVQ CX, 0x78(SP)			
  0x4055f5		48890c24		MOVQ CX, 0(SP)				
  0x4055f9		4889442408		MOVQ AX, 0x8(SP)			
  0x4055fe		488b842498000000	MOVQ 0x98(SP), AX			
  0x405606		4889442410		MOVQ AX, 0x10(SP)			
  0x40560b		488d442470		LEAQ 0x70(SP), AX			
  0x405610		4889442418		MOVQ AX, 0x18(SP)			
  0x405615		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x40561e		e87d010000		CALL runtime.recv(SB)			
		return true, true
  0x405623		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x40562b		c68424a900000001	MOVB $0x1, 0xa9(SP)	
  0x405633		488bac2480000000	MOVQ 0x80(SP), BP	
  0x40563b		4881c488000000		ADDQ $0x88, SP		
  0x405642		c3			RET			
		unlock(&c.lock)
  0x405643		488b442468		MOVQ 0x68(SP), AX	
  0x405648		48890424		MOVQ AX, 0(SP)		
  0x40564c		e83f320000		CALL runtime.unlock(SB)	
		if ep != nil {
  0x405651		488b842498000000	MOVQ 0x98(SP), AX	
  0x405659		4885c0			TESTQ AX, AX		
  0x40565c		7520			JNE 0x40567e		
		return true, false
  0x40565e		c68424a800000001	MOVB $0x1, 0xa8(SP)	
  0x405666		c68424a900000000	MOVB $0x0, 0xa9(SP)	
  0x40566e		488bac2480000000	MOVQ 0x80(SP), BP	
  0x405676		4881c488000000		ADDQ $0x88, SP		
  0x40567d		c3			RET			
			typedmemclr(c.elemtype, ep)
  0x40567e		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x405686		488b4920		MOVQ 0x20(CX), CX		
  0x40568a		48890c24		MOVQ CX, 0(SP)			
  0x40568e		4889442408		MOVQ AX, 0x8(SP)		
  0x405693		e8a8810000		CALL runtime.typedmemclr(SB)	
  0x405698		ebc4			JMP 0x40565e			
		t0 = cputicks()
  0x40569a		e871390400		CALL runtime.cputicks(SB)	
  0x40569f		488b1424		MOVQ 0(SP), DX			
	lock(&c.lock)
  0x4056a3		488b842490000000	MOVQ 0x90(SP), AX	
		t0 = cputicks()
  0x4056ab		e9aafaffff		JMP 0x40515a		
		return
  0x4056b0		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x4056b8		c68424a900000000	MOVB $0x0, 0xa9(SP)	
  0x4056c0		488bac2480000000	MOVQ 0x80(SP), BP	
  0x4056c8		4881c488000000		ADDQ $0x88, SP		
  0x4056cf		c3			RET			
  0x4056d0		31d2			XORL DX, DX		
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
  0x4056d2		e96bfaffff		JMP 0x405142		
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x4056d7		488b5008		MOVQ 0x8(AX), DX	
  0x4056db		4885d2			TESTQ DX, DX		
  0x4056de		750a			JNE 0x4056ea		
  0x4056e0		4883784800		CMPQ $0x0, 0x48(AX)	
  0x4056e5		741a			JE 0x405701		
  0x4056e7		4885d2			TESTQ DX, DX		
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
  0x4056ea		760e			JBE 0x4056fa		
  0x4056ec		488b10			MOVQ 0(AX), DX		
  0x4056ef		4885d2			TESTQ DX, DX		
  0x4056f2		0f94c2			SETE DL			
  0x4056f5		e938faffff		JMP 0x405132		
  0x4056fa		31d2			XORL DX, DX		
  0x4056fc		e931faffff		JMP 0x405132		
  0x405701		ba01000000		MOVL $0x1, DX		
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
  0x405706		e927faffff		JMP 0x405132		
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x40570b		0fb68424a0000000	MOVZX 0xa0(SP), AX	
  0x405713		84c0			TESTL AL, AL		
		if !block {
  0x405715		753b			JNE 0x405752		
			return
  0x405717		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x40571f		c68424a900000000	MOVB $0x0, 0xa9(SP)	
  0x405727		488bac2480000000	MOVQ 0x80(SP), BP	
  0x40572f		4881c488000000		ADDQ $0x88, SP		
  0x405736		c3			RET			
		throw("G waiting list is corrupted")
  0x405737		488d05bebb0600		LEAQ 0x6bbbe(IP), AX	
  0x40573e		48890424		MOVQ AX, 0(SP)		
  0x405742		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x40574b		e830dd0100		CALL runtime.throw(SB)	
  0x405750		0f0b			UD2			
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
  0x405752		0f57c0			XORPS X0, X0		
  0x405755		0f110424		MOVUPS X0, 0(SP)	
  0x405759		66c74424100310		MOVW $0x1003, 0x10(SP)	
  0x405760		48c744241802000000	MOVQ $0x2, 0x18(SP)	
  0x405769		e8e2f90100		CALL runtime.gopark(SB)	
		throw("unreachable")
  0x40576e		488d0501a20600		LEAQ 0x6a201(IP), AX	
  0x405775		48890424		MOVQ AX, 0(SP)		
  0x405779		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x405782		e8f9dc0100		CALL runtime.throw(SB)	
  0x405787		0f0b			UD2			
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
  0x405789		e8f2200400		CALL runtime.morestack_noctxt(SB)	
  0x40578e		e94df9ffff		JMP runtime.chanrecv(SB)		

TEXT runtime.recv(SB) /usr/local/go/src/runtime/chan.go
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x4057a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4057a9		483b6110		CMPQ 0x10(CX), SP	
  0x4057ad		0f8694010000		JBE 0x405947		
  0x4057b3		4883ec30		SUBQ $0x30, SP		
  0x4057b7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4057bc		488d6c2428		LEAQ 0x28(SP), BP	
	if c.dataqsiz == 0 {
  0x4057c1		488b4c2438		MOVQ 0x38(SP), CX	
  0x4057c6		4883790800		CMPQ $0x0, 0x8(CX)	
  0x4057cb		0f85e7000000		JNE 0x4058b8		
		if ep != nil {
  0x4057d1		488b5c2448		MOVQ 0x48(SP), BX	
  0x4057d6		4885db			TESTQ BX, BX		
  0x4057d9		0f85b8000000		JNE 0x405897		
	sg.elem = nil
  0x4057df		488b4c2440		MOVQ 0x40(SP), CX			
  0x4057e4		8401			TESTB AL, 0(CX)				
  0x4057e6		833d33760d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4057ed		0f8594000000		JNE 0x405887				
  0x4057f3		48c7412000000000	MOVQ $0x0, 0x20(CX)			
	gp := sg.g
  0x4057fb		488b01			MOVQ 0(CX), AX		
  0x4057fe		4889442420		MOVQ AX, 0x20(SP)	
	unlockf()
  0x405803		488b542450		MOVQ 0x50(SP), DX	
  0x405808		488b1a			MOVQ 0(DX), BX		
  0x40580b		ffd3			CALL BX			
	gp.param = unsafe.Pointer(sg)
  0x40580d		488b442420		MOVQ 0x20(SP), AX			
  0x405812		8400			TESTB AL, 0(AX)				
  0x405814		833d05760d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40581b		754c			JNE 0x405869				
  0x40581d		488b4c2440		MOVQ 0x40(SP), CX			
  0x405822		48898888000000		MOVQ CX, 0x88(AX)			
	if sg.releasetime != 0 {
  0x405829		4883793000		CMPQ $0x0, 0x30(CX)	
  0x40582e		7520			JNE 0x405850		
	goready(gp, skip+1)
  0x405830		48890424		MOVQ AX, 0(SP)			
  0x405834		488b442458		MOVQ 0x58(SP), AX		
  0x405839		48ffc0			INCQ AX				
  0x40583c		4889442408		MOVQ AX, 0x8(SP)		
  0x405841		e85afa0100		CALL runtime.goready(SB)	
}
  0x405846		488b6c2428		MOVQ 0x28(SP), BP	
  0x40584b		4883c430		ADDQ $0x30, SP		
  0x40584f		c3			RET			
		sg.releasetime = cputicks()
  0x405850		e8bb370400		CALL runtime.cputicks(SB)	
  0x405855		488b0424		MOVQ 0(SP), AX			
  0x405859		488b4c2440		MOVQ 0x40(SP), CX		
  0x40585e		48894130		MOVQ AX, 0x30(CX)		
	goready(gp, skip+1)
  0x405862		488b442420		MOVQ 0x20(SP), AX	
		sg.releasetime = cputicks()
  0x405867		ebc7			JMP 0x405830		
	gp.param = unsafe.Pointer(sg)
  0x405869		488db888000000		LEAQ 0x88(AX), DI	
	gp := sg.g
  0x405870		4889c1			MOVQ AX, CX		
	gp.param = unsafe.Pointer(sg)
  0x405873		488b442440		MOVQ 0x40(SP), AX		
  0x405878		e8033e0400		CALL runtime.gcWriteBarrier(SB)	
	goready(gp, skip+1)
  0x40587d		4889c8			MOVQ CX, AX		
	if sg.releasetime != 0 {
  0x405880		488b4c2440		MOVQ 0x40(SP), CX	
	gp.param = unsafe.Pointer(sg)
  0x405885		eba2			JMP 0x405829		
	sg.elem = nil
  0x405887		488d7920		LEAQ 0x20(CX), DI		
  0x40588b		31c0			XORL AX, AX			
  0x40588d		e8ee3d0400		CALL runtime.gcWriteBarrier(SB)	
  0x405892		e964ffffff		JMP 0x4057fb			
			recvDirect(c.elemtype, sg, ep)
  0x405897		488b4120		MOVQ 0x20(CX), AX		
  0x40589b		48890424		MOVQ AX, 0(SP)			
  0x40589f		488b442440		MOVQ 0x40(SP), AX		
  0x4058a4		4889442408		MOVQ AX, 0x8(SP)		
  0x4058a9		48895c2410		MOVQ BX, 0x10(SP)		
  0x4058ae		e8ddf4ffff		CALL runtime.recvDirect(SB)	
  0x4058b3		e927ffffff		JMP 0x4057df			
		qp := chanbuf(c, c.recvx)
  0x4058b8		90			NOPL			
  0x4058b9		488b4130		MOVQ 0x30(CX), AX	
	return add(c.buf, uintptr(i)*uintptr(c.elemsize))
  0x4058bd		90			NOPL			
  0x4058be		0fb75118		MOVZX 0x18(CX), DX	
  0x4058c2		480fafc2		IMULQ DX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4058c6		48034110		ADDQ 0x10(CX), AX	
		if ep != nil {
  0x4058ca		488b542448		MOVQ 0x48(SP), DX	
  0x4058cf		4885d2			TESTQ DX, DX		
  0x4058d2		754b			JNE 0x40591f		
		typedmemmove(c.elemtype, qp, sg.elem)
  0x4058d4		488b5120		MOVQ 0x20(CX), DX		
  0x4058d8		488b5c2440		MOVQ 0x40(SP), BX		
  0x4058dd		488b7320		MOVQ 0x20(BX), SI		
  0x4058e1		48891424		MOVQ DX, 0(SP)			
  0x4058e5		4889442408		MOVQ AX, 0x8(SP)		
  0x4058ea		4889742410		MOVQ SI, 0x10(SP)		
  0x4058ef		e89c7c0000		CALL runtime.typedmemmove(SB)	
		c.recvx++
  0x4058f4		488b442438		MOVQ 0x38(SP), AX	
  0x4058f9		488b4830		MOVQ 0x30(AX), CX	
  0x4058fd		48ffc1			INCQ CX			
  0x405900		48894830		MOVQ CX, 0x30(AX)	
		if c.recvx == c.dataqsiz {
  0x405904		48394808		CMPQ CX, 0x8(AX)	
  0x405908		7508			JNE 0x405912		
			c.recvx = 0
  0x40590a		48c7403000000000	MOVQ $0x0, 0x30(AX)	
		c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
  0x405912		488b4830		MOVQ 0x30(AX), CX	
  0x405916		48894828		MOVQ CX, 0x28(AX)	
  0x40591a		e9c0feffff		JMP 0x4057df		
	return unsafe.Pointer(uintptr(p) + x)
  0x40591f		4889442418		MOVQ AX, 0x18(SP)	
			typedmemmove(c.elemtype, ep, qp)
  0x405924		488b5920		MOVQ 0x20(CX), BX		
  0x405928		48891c24		MOVQ BX, 0(SP)			
  0x40592c		4889542408		MOVQ DX, 0x8(SP)		
  0x405931		4889442410		MOVQ AX, 0x10(SP)		
  0x405936		e8557c0000		CALL runtime.typedmemmove(SB)	
		typedmemmove(c.elemtype, qp, sg.elem)
  0x40593b		488b442418		MOVQ 0x18(SP), AX	
  0x405940		488b4c2438		MOVQ 0x38(SP), CX	
			typedmemmove(c.elemtype, ep, qp)
  0x405945		eb8d			JMP 0x4058d4		
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
  0x405947		e8341f0400		CALL runtime.morestack_noctxt(SB)	
  0x40594c		e94ffeffff		JMP runtime.recv(SB)			

TEXT runtime.(*waitq).dequeue(SB) /usr/local/go/src/runtime/chan.go
func (q *waitq) dequeue() *sudog {
  0x405960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405969		483b6110		CMPQ 0x10(CX), SP	
  0x40596d		0f86d0000000		JBE 0x405a43		
  0x405973		4883ec08		SUBQ $0x8, SP		
  0x405977		48892c24		MOVQ BP, 0(SP)		
  0x40597b		488d2c24		LEAQ 0(SP), BP		
	for {
  0x40597f		488b4c2410		MOVQ 0x10(SP), CX	
		sgp := q.first
  0x405984		488b11			MOVQ 0(CX), DX		
		if sgp == nil {
  0x405987		4885d2			TESTQ DX, DX		
  0x40598a		0f84a1000000		JE 0x405a31		
		y := sgp.next
  0x405990		488b5a10		MOVQ 0x10(DX), BX	
		if y == nil {
  0x405994		4885db			TESTQ BX, BX		
  0x405997		746f			JE 0x405a08		
			y.prev = nil
  0x405999		833d80740d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4059a0		7540			JNE 0x4059e2				
  0x4059a2		48c7431800000000	MOVQ $0x0, 0x18(BX)			
			q.first = y
  0x4059aa		488919			MOVQ BX, 0(CX)		
			sgp.next = nil // mark as removed (see dequeueSudog)
  0x4059ad		48c7421000000000	MOVQ $0x0, 0x10(DX)	
		if sgp.isSelect {
  0x4059b5		807a0800		CMPB $0x0, 0x8(DX)	
  0x4059b9		7419			JE 0x4059d4		
			if !atomic.Cas(&sgp.g.selectDone, 0, 1) {
  0x4059bb		488b1a			MOVQ 0(DX), BX			
  0x4059be		31c0			XORL AX, AX			
  0x4059c0		be01000000		MOVL $0x1, SI			
  0x4059c5		f00fb1b368010000	LOCK CMPXCHGL SI, 0x168(BX)	
  0x4059cd		0f94c3			SETE BL				
  0x4059d0		84db			TESTL BL, BL			
  0x4059d2		74b0			JE 0x405984			
		return sgp
  0x4059d4		4889542418		MOVQ DX, 0x18(SP)	
  0x4059d9		488b2c24		MOVQ 0(SP), BP		
  0x4059dd		4883c408		ADDQ $0x8, SP		
  0x4059e1		c3			RET			
			y.prev = nil
  0x4059e2		488d7b18		LEAQ 0x18(BX), DI		
  0x4059e6		31c0			XORL AX, AX			
  0x4059e8		e8933c0400		CALL runtime.gcWriteBarrier(SB)	
			q.first = y
  0x4059ed		4889cf			MOVQ CX, DI			
  0x4059f0		4889d8			MOVQ BX, AX			
  0x4059f3		e8883c0400		CALL runtime.gcWriteBarrier(SB)	
		y := sgp.next
  0x4059f8		488d5a10		LEAQ 0x10(DX), BX	
			sgp.next = nil // mark as removed (see dequeueSudog)
  0x4059fc		4889df			MOVQ BX, DI			
  0x4059ff		31c0			XORL AX, AX			
  0x405a01		e87a3c0400		CALL runtime.gcWriteBarrier(SB)	
			y.prev = nil
  0x405a06		ebad			JMP 0x4059b5		
			q.first = nil
  0x405a08		833d11740d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x405a0f		7508			JNE 0x405a19				
			q.last = nil
  0x405a11		0f57c0			XORPS X0, X0		
  0x405a14		0f1101			MOVUPS X0, 0(CX)	
			q.first = nil
  0x405a17		eb9c			JMP 0x4059b5			
  0x405a19		4889cf			MOVQ CX, DI			
  0x405a1c		31c0			XORL AX, AX			
  0x405a1e		e85d3c0400		CALL runtime.gcWriteBarrier(SB)	
			q.last = nil
  0x405a23		488d5908		LEAQ 0x8(CX), BX		
  0x405a27		4889df			MOVQ BX, DI			
  0x405a2a		e8513c0400		CALL runtime.gcWriteBarrier(SB)	
			q.first = nil
  0x405a2f		eb84			JMP 0x4059b5		
			return nil
  0x405a31		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x405a3a		488b2c24		MOVQ 0(SP), BP		
  0x405a3e		4883c408		ADDQ $0x8, SP		
  0x405a42		c3			RET			
func (q *waitq) dequeue() *sudog {
  0x405a43		e8381e0400		CALL runtime.morestack_noctxt(SB)	
  0x405a48		e913ffffff		JMP runtime.(*waitq).dequeue(SB)	

TEXT runtime.init.0(SB) /usr/local/go/src/runtime/cpuflags_amd64.go
	processor := processorVersionInfo & 0x0FFF3FF0
  0x405a50		8b05a2720d00		MOVL runtime.processorVersionInfo(SB), AX	
  0x405a56		25f03fff0f		ANDL $0xfff3ff0, AX				
	isIntelBridgeFamily := isIntel &&
  0x405a5b		803d4a720d0000		CMPB $0x0, runtime.isIntel(SB)	
  0x405a62		7423			JE 0x405a87			
		processor == 0x206A0 ||
  0x405a64		3da0060200		CMPL $0x206a0, AX	
  0x405a69		751c			JNE 0x405a87		
  0x405a6b		b801000000		MOVL $0x1, AX		
	useAVXmemmove = cpu.X86.HasAVX && !isIntelBridgeFamily
  0x405a70		803d0b760d0000		CMPB $0x0, internal/cpu.X86+66(SB)	
  0x405a77		740a			JE 0x405a83				
  0x405a79		83f001			XORL $0x1, AX				
  0x405a7c		880532720d00		MOVB AL, runtime.useAVXmemmove(SB)	
}
  0x405a82		c3			RET			
  0x405a83		31c0			XORL AX, AX		
	useAVXmemmove = cpu.X86.HasAVX && !isIntelBridgeFamily
  0x405a85		ebf5			JMP 0x405a7c		
		processor == 0x206D0 ||
  0x405a87		3dd0060200		CMPL $0x206d0, AX	
  0x405a8c		7507			JNE 0x405a95		
  0x405a8e		b801000000		MOVL $0x1, AX		
  0x405a93		ebdb			JMP 0x405a70		
		processor == 0x306A0 ||
  0x405a95		3da0060300		CMPL $0x306a0, AX	
  0x405a9a		7507			JNE 0x405aa3		
  0x405a9c		b801000000		MOVL $0x1, AX		
  0x405aa1		ebcd			JMP 0x405a70		
		processor == 0x306E0
  0x405aa3		3de0060300		CMPL $0x306e0, AX	
  0x405aa8		0f94c0			SETE AL			
  0x405aab		ebc3			JMP 0x405a70		

TEXT runtime.(*cpuProfile).add(SB) /usr/local/go/src/runtime/cpuprof.go
func (p *cpuProfile) add(gp *g, stk []uintptr) {
  0x405ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405ab9		483b6110		CMPQ 0x10(CX), SP	
  0x405abd		0f8600010000		JBE 0x405bc3		
  0x405ac3		4883ec58		SUBQ $0x58, SP		
  0x405ac7		48896c2450		MOVQ BP, 0x50(SP)	
  0x405acc		488d6c2450		LEAQ 0x50(SP), BP	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x405ad1		eb05			JMP 0x405ad8		
		osyield()
  0x405ad3		e8185b0400		CALL runtime.osyield(SB)	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x405ad8		31c0			XORL AX, AX			
  0x405ada		488d0dd7720d00		LEAQ runtime.prof(SB), CX	
  0x405ae1		ba01000000		MOVL $0x1, DX			
  0x405ae6		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x405aea		0f94c3			SETE BL				
  0x405aed		84db			TESTL BL, BL			
  0x405aef		74e2			JE 0x405ad3			
	if prof.hz != 0 { // implies cpuprof.log != nil
  0x405af1		833dc4720d0000		CMPL $0x0, runtime.prof+4(SB)	
  0x405af8		0f849d000000		JE 0x405b9b			
		if p.numExtra > 0 || p.lostExtra > 0 {
  0x405afe		488b442460		MOVQ 0x60(SP), AX	
  0x405b03		8400			TESTB AL, 0(AX)		
  0x405b05		4883b8581f000000	CMPQ $0x0, 0x1f58(AX)	
  0x405b0d		0f8e9d000000		JLE 0x405bb0		
			p.addExtra()
  0x405b13		48890424		MOVQ AX, 0(SP)				
  0x405b17		e8b4010000		CALL runtime.(*cpuProfile).addExtra(SB)	
		hdr := [1]uint64{1}
  0x405b1c		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x405b25		48c744244801000000	MOVQ $0x1, 0x48(SP)	
		cpuprof.log.write(&gp.labels, nanotime(), hdr[:], stk)
  0x405b2e		e87d550400		CALL runtime.nanotime(SB)		
  0x405b33		488b442468		MOVQ 0x68(SP), AX			
  0x405b38		8400			TESTB AL, 0(AX)				
  0x405b3a		488b0d8fcb0b00		MOVQ runtime.cpuprof+16(SB), CX		
  0x405b41		488b1424		MOVQ 0(SP), DX				
  0x405b45		48890c24		MOVQ CX, 0(SP)				
  0x405b49		480558010000		ADDQ $0x158, AX				
  0x405b4f		4889442408		MOVQ AX, 0x8(SP)			
  0x405b54		4889542410		MOVQ DX, 0x10(SP)			
  0x405b59		488d442448		LEAQ 0x48(SP), AX			
  0x405b5e		4889442418		MOVQ AX, 0x18(SP)			
  0x405b63		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x405b6c		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x405b75		488b442470		MOVQ 0x70(SP), AX			
  0x405b7a		4889442430		MOVQ AX, 0x30(SP)			
  0x405b7f		488b442478		MOVQ 0x78(SP), AX			
  0x405b84		4889442438		MOVQ AX, 0x38(SP)			
  0x405b89		488b842480000000	MOVQ 0x80(SP), AX			
  0x405b91		4889442440		MOVQ AX, 0x40(SP)			
  0x405b96		e885b20200		CALL runtime.(*profBuf).write(SB)	
	atomic.Store(&prof.signalLock, 0)
  0x405b9b		31c0			XORL AX, AX			
  0x405b9d		488d0d14720d00		LEAQ runtime.prof(SB), CX	
  0x405ba4		8701			XCHGL AX, 0(CX)			
}
  0x405ba6		488b6c2450		MOVQ 0x50(SP), BP	
  0x405bab		4883c458		ADDQ $0x58, SP		
  0x405baf		c3			RET			
		if p.numExtra > 0 || p.lostExtra > 0 {
  0x405bb0		4883b8601f000000	CMPQ $0x0, 0x1f60(AX)	
  0x405bb8		0f8755ffffff		JA 0x405b13		
  0x405bbe		e959ffffff		JMP 0x405b1c		
func (p *cpuProfile) add(gp *g, stk []uintptr) {
  0x405bc3		e8b81c0400		CALL runtime.morestack_noctxt(SB)	
  0x405bc8		e9e3feffff		JMP runtime.(*cpuProfile).add(SB)	

TEXT runtime.(*cpuProfile).addNonGo(SB) /usr/local/go/src/runtime/cpuprof.go
func (p *cpuProfile) addNonGo(stk []uintptr) {
  0x405bd0		4883ec20		SUBQ $0x20, SP		
  0x405bd4		48896c2418		MOVQ BP, 0x18(SP)	
  0x405bd9		488d6c2418		LEAQ 0x18(SP), BP	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x405bde		eb05			JMP 0x405be5		
		osyield()
  0x405be0		e80b5a0400		CALL runtime.osyield(SB)	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x405be5		31c0			XORL AX, AX			
  0x405be7		488d0dca710d00		LEAQ runtime.prof(SB), CX	
  0x405bee		ba01000000		MOVL $0x1, DX			
  0x405bf3		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x405bf7		0f94c3			SETE BL				
  0x405bfa		84db			TESTL BL, BL			
  0x405bfc		74e2			JE 0x405be0			
	if cpuprof.numExtra+1+len(stk) < len(cpuprof.extra) {
  0x405bfe		488b0513ea0b00		MOVQ runtime.cpuprof+8024(SB), AX	
  0x405c05		488b542438		MOVQ 0x38(SP), DX			
  0x405c0a		488d1c02		LEAQ 0(DX)(AX*1), BX			
  0x405c0e		488d5b01		LEAQ 0x1(BX), BX			
  0x405c12		4881fbe8030000		CMPQ $0x3e8, BX				
  0x405c19		0f8d93000000		JGE 0x405cb2				
		cpuprof.extra[i] = uintptr(1 + len(stk))
  0x405c1f		483de8030000		CMPQ $0x3e8, AX			
  0x405c25		0f8390000000		JAE 0x405cbb			
  0x405c2b		488d5a01		LEAQ 0x1(DX), BX		
  0x405c2f		488d35a2ca0b00		LEAQ runtime.cpuprof+24(SB), SI	
  0x405c36		48891cc6		MOVQ BX, 0(SI)(AX*8)		
		copy(cpuprof.extra[i+1:], stk)
  0x405c3a		488d9819fcffff		LEAQ 0xfffffc19(AX), BX	
  0x405c41		4889df			MOVQ BX, DI		
  0x405c44		48f7db			NEGQ BX			
  0x405c47		4839d3			CMPQ DX, BX		
  0x405c4a		480f4fda		CMOVG DX, BX		
  0x405c4e		48ffc0			INCQ AX			
  0x405c51		48c1e003		SHLQ $0x3, AX		
  0x405c55		48c1ff3f		SARQ $0x3f, DI		
  0x405c59		4821f8			ANDQ DI, AX		
  0x405c5c		4801f0			ADDQ SI, AX		
  0x405c5f		488b742430		MOVQ 0x30(SP), SI	
  0x405c64		4839f0			CMPQ SI, AX		
  0x405c67		7524			JNE 0x405c8d		
		cpuprof.numExtra += 1 + len(stk)
  0x405c69		488b05a8e90b00		MOVQ runtime.cpuprof+8024(SB), AX	
  0x405c70		488d0410		LEAQ 0(AX)(DX*1), AX			
  0x405c74		488d4001		LEAQ 0x1(AX), AX			
  0x405c78		48890599e90b00		MOVQ AX, runtime.cpuprof+8024(SB)	
	atomic.Store(&prof.signalLock, 0)
  0x405c7f		31c0			XORL AX, AX		
  0x405c81		8701			XCHGL AX, 0(CX)		
}
  0x405c83		488b6c2418		MOVQ 0x18(SP), BP	
  0x405c88		4883c420		ADDQ $0x20, SP		
  0x405c8c		c3			RET			
		copy(cpuprof.extra[i+1:], stk)
  0x405c8d		48890424		MOVQ AX, 0(SP)			
  0x405c91		4889742408		MOVQ SI, 0x8(SP)		
  0x405c96		48c1e303		SHLQ $0x3, BX			
  0x405c9a		48895c2410		MOVQ BX, 0x10(SP)		
  0x405c9f		e8ac4a0400		CALL runtime.memmove(SB)	
	for !atomic.Cas(&prof.signalLock, 0, 1) {
  0x405ca4		488d0d0d710d00		LEAQ runtime.prof(SB), CX	
		cpuprof.numExtra += 1 + len(stk)
  0x405cab		488b542438		MOVQ 0x38(SP), DX	
		copy(cpuprof.extra[i+1:], stk)
  0x405cb0		ebb7			JMP 0x405c69		
		cpuprof.lostExtra++
  0x405cb2		48ff0567e90b00		INCQ runtime.cpuprof+8032(SB)	
  0x405cb9		ebc4			JMP 0x405c7f			
		cpuprof.extra[i] = uintptr(1 + len(stk))
  0x405cbb		e860c20100		CALL runtime.panicindex(SB)	
  0x405cc0		0f0b			UD2				

TEXT runtime.(*cpuProfile).addExtra(SB) /usr/local/go/src/runtime/cpuprof.go
func (p *cpuProfile) addExtra() {
  0x405cd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405cd9		483b6110		CMPQ 0x10(CX), SP	
  0x405cdd		0f86e6010000		JBE 0x405ec9		
  0x405ce3		4883ec78		SUBQ $0x78, SP		
  0x405ce7		48896c2470		MOVQ BP, 0x70(SP)	
  0x405cec		488d6c2470		LEAQ 0x70(SP), BP	
	hdr := [1]uint64{1}
  0x405cf1		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x405cfa		48c744245001000000	MOVQ $0x1, 0x50(SP)	
	for i := 0; i < p.numExtra; {
  0x405d03		488b842480000000	MOVQ 0x80(SP), AX	
  0x405d0b		31c9			XORL CX, CX		
  0x405d0d		e98b000000		JMP 0x405d9d		
  0x405d12		48894c2448		MOVQ CX, 0x48(SP)	
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x405d17		488b7010		MOVQ 0x10(AX), SI			
  0x405d1b		48893424		MOVQ SI, 0(SP)				
  0x405d1f		0f57c0			XORPS X0, X0				
  0x405d22		0f11442408		MOVUPS X0, 0x8(SP)			
  0x405d27		488d742450		LEAQ 0x50(SP), SI			
  0x405d2c		4889742418		MOVQ SI, 0x18(SP)			
  0x405d31		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x405d3a		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x405d43		488db919fcffff		LEAQ 0xfffffc19(CX), DI			
  0x405d4a		4989f8			MOVQ DI, R8				
  0x405d4d		48c1ff3f		SARQ $0x3f, DI				
  0x405d51		4989d9			MOVQ BX, R9				
  0x405d54		48c1e303		SHLQ $0x3, BX				
  0x405d58		4821fb			ANDQ DI, BX				
  0x405d5b		488d1c18		LEAQ 0(AX)(BX*1), BX			
  0x405d5f		488d5b18		LEAQ 0x18(BX), BX			
  0x405d63		48895c2430		MOVQ BX, 0x30(SP)			
  0x405d68		4c29ca			SUBQ R9, DX				
  0x405d6b		4889542438		MOVQ DX, 0x38(SP)			
  0x405d70		49f7d8			NEGQ R8					
  0x405d73		4c89442440		MOVQ R8, 0x40(SP)			
  0x405d78		e8a3b00200		CALL runtime.(*profBuf).write(SB)	
		i += int(p.extra[i])
  0x405d7d		488b442448		MOVQ 0x48(SP), AX	
  0x405d82		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x405d8a		488b54c118		MOVQ 0x18(CX)(AX*8), DX	
  0x405d8f		4801d0			ADDQ DX, AX		
	for i := 0; i < p.numExtra; {
  0x405d92		4889c1			MOVQ AX, CX		
  0x405d95		488b842480000000	MOVQ 0x80(SP), AX	
  0x405d9d		8400			TESTB AL, 0(AX)		
  0x405d9f		483988581f0000		CMPQ CX, 0x1f58(AX)	
  0x405da6		7e3d			JLE 0x405de5		
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x405da8		4881f9e8030000		CMPQ $0x3e8, CX		
  0x405daf		0f8306010000		JAE 0x405ebb		
  0x405db5		488b54c818		MOVQ 0x18(AX)(CX*8), DX	
  0x405dba		4801ca			ADDQ CX, DX		
  0x405dbd		4885d2			TESTQ DX, DX		
  0x405dc0		0f8cfc000000		JL 0x405ec2		
  0x405dc6		488d5901		LEAQ 0x1(CX), BX	
  0x405dca		4839d3			CMPQ DX, BX		
  0x405dcd		0f87ef000000		JA 0x405ec2		
  0x405dd3		4881fae8030000		CMPQ $0x3e8, DX		
  0x405dda		0f8632ffffff		JBE 0x405d12		
  0x405de0		e9dd000000		JMP 0x405ec2		
	p.numExtra = 0
  0x405de5		48c780581f000000000000	MOVQ $0x0, 0x1f58(AX)	
	if p.lostExtra > 0 {
  0x405df0		4883b8601f000000	CMPQ $0x0, 0x1f60(AX)	
  0x405df8		770a			JA 0x405e04		
  0x405dfa		488b6c2470		MOVQ 0x70(SP), BP	
  0x405dff		4883c478		ADDQ $0x78, SP		
  0x405e03		c3			RET			
		hdr := [1]uint64{p.lostExtra}
  0x405e04		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x405e0d		488b88601f0000		MOVQ 0x1f60(AX), CX	
  0x405e14		48894c2458		MOVQ CX, 0x58(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x405e19		488d0de0d80600		LEAQ 0x6d8e0(IP), CX	
  0x405e20		8401			TESTB AL, 0(CX)		
  0x405e22		488d0dc7d80600		LEAQ 0x6d8c7(IP), CX	
  0x405e29		8401			TESTB AL, 0(CX)		
			funcPC(_LostExternalCode) + sys.PCQuantum,
  0x405e2b		90			NOPL			
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x405e2c		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x405e2d		488b0dccd80600		MOVQ 0x6d8cc(IP), CX	
  0x405e34		90			NOPL			
  0x405e35		488b15b4d80600		MOVQ 0x6d8b4(IP), DX	
  0x405e3c		90			NOPL			
		lostStk := [2]uintptr{
  0x405e3d		0f57c0			XORPS X0, X0		
  0x405e40		0f11442460		MOVUPS X0, 0x60(SP)	
			funcPC(_LostExternalCode) + sys.PCQuantum,
  0x405e45		48ffc1			INCQ CX			
  0x405e48		48894c2460		MOVQ CX, 0x60(SP)	
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x405e4d		488d4a01		LEAQ 0x1(DX), CX	
  0x405e51		48894c2468		MOVQ CX, 0x68(SP)	
		cpuprof.log.write(nil, 0, hdr[:], lostStk[:])
  0x405e56		488b0d73c80b00		MOVQ runtime.cpuprof+16(SB), CX		
  0x405e5d		48890c24		MOVQ CX, 0(SP)				
  0x405e61		0f11442408		MOVUPS X0, 0x8(SP)			
  0x405e66		488d4c2458		LEAQ 0x58(SP), CX			
  0x405e6b		48894c2418		MOVQ CX, 0x18(SP)			
  0x405e70		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x405e79		48c744242801000000	MOVQ $0x1, 0x28(SP)			
  0x405e82		488d4c2460		LEAQ 0x60(SP), CX			
  0x405e87		48894c2430		MOVQ CX, 0x30(SP)			
  0x405e8c		48c744243802000000	MOVQ $0x2, 0x38(SP)			
  0x405e95		48c744244002000000	MOVQ $0x2, 0x40(SP)			
  0x405e9e		e87daf0200		CALL runtime.(*profBuf).write(SB)	
		p.lostExtra = 0
  0x405ea3		488b842480000000	MOVQ 0x80(SP), AX	
  0x405eab		48c780601f000000000000	MOVQ $0x0, 0x1f60(AX)	
  0x405eb6		e93fffffff		JMP 0x405dfa		
		p.log.write(nil, 0, hdr[:], p.extra[i+1:i+int(p.extra[i])])
  0x405ebb		e860c00100		CALL runtime.panicindex(SB)	
  0x405ec0		0f0b			UD2				
  0x405ec2		e889c10100		CALL runtime.panicslice(SB)	
  0x405ec7		0f0b			UD2				
func (p *cpuProfile) addExtra() {
  0x405ec9		e8b2190400		CALL runtime.morestack_noctxt(SB)	
  0x405ece		e9fdfdffff		JMP runtime.(*cpuProfile).addExtra(SB)	

TEXT runtime.debugCallCheck(SB) /usr/local/go/src/runtime/debugcall.go
func debugCallCheck(pc uintptr) string {
  0x405ee0		4883ec38		SUBQ $0x38, SP		
  0x405ee4		48896c2430		MOVQ BP, 0x30(SP)	
  0x405ee9		488d6c2430		LEAQ 0x30(SP), BP	
	if getg() != getg().m.curg {
  0x405eee		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x405ef7		488b4830		MOVQ 0x30(AX), CX	
  0x405efb		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x405f02		0f8591000000		JNE 0x405f99		
	if sp := getcallersp(); !(getg().stack.lo < sp && sp <= getg().stack.hi) {
  0x405f08		488d4c2440		LEAQ 0x40(SP), CX	
  0x405f0d		483908			CMPQ CX, 0(AX)		
  0x405f10		7306			JAE 0x405f18		
  0x405f12		48394808		CMPQ CX, 0x8(AX)	
  0x405f16		731f			JAE 0x405f37		
		return debugCallSystemStack
  0x405f18		488d0576b90600		LEAQ 0x6b976(IP), AX	
  0x405f1f		4889442448		MOVQ AX, 0x48(SP)	
  0x405f24		48c74424501d000000	MOVQ $0x1d, 0x50(SP)	
  0x405f2d		488b6c2430		MOVQ 0x30(SP), BP	
  0x405f32		4883c438		ADDQ $0x38, SP		
  0x405f36		c3			RET			
	var ret string
  0x405f37		0f57c0			XORPS X0, X0		
  0x405f3a		0f11442408		MOVUPS X0, 0x8(SP)	
	systemstack(func() {
  0x405f3f		0f11442418		MOVUPS X0, 0x18(SP)				
  0x405f44		48c744242800000000	MOVQ $0x0, 0x28(SP)				
  0x405f4d		488d053ce90300		LEAQ runtime.debugCallCheck.func1(SB), AX	
  0x405f54		4889442418		MOVQ AX, 0x18(SP)				
  0x405f59		488d442440		LEAQ 0x40(SP), AX				
  0x405f5e		4889442420		MOVQ AX, 0x20(SP)				
  0x405f63		488d442408		LEAQ 0x8(SP), AX				
  0x405f68		4889442428		MOVQ AX, 0x28(SP)				
  0x405f6d		488d442418		LEAQ 0x18(SP), AX				
  0x405f72		48890424		MOVQ AX, 0(SP)					
  0x405f76		e8b5170400		CALL runtime.systemstack(SB)			
	return ret
  0x405f7b		488b442408		MOVQ 0x8(SP), AX	
  0x405f80		488b4c2410		MOVQ 0x10(SP), CX	
  0x405f85		4889442448		MOVQ AX, 0x48(SP)	
  0x405f8a		48894c2450		MOVQ CX, 0x50(SP)	
  0x405f8f		488b6c2430		MOVQ 0x30(SP), BP	
  0x405f94		4883c438		ADDQ $0x38, SP		
  0x405f98		c3			RET			
		return debugCallSystemStack
  0x405f99		488d05f5b80600		LEAQ 0x6b8f5(IP), AX	
  0x405fa0		4889442448		MOVQ AX, 0x48(SP)	
  0x405fa5		48c74424501d000000	MOVQ $0x1d, 0x50(SP)	
  0x405fae		488b6c2430		MOVQ 0x30(SP), BP	
  0x405fb3		4883c438		ADDQ $0x38, SP		
  0x405fb7		c3			RET			

TEXT runtime.debugCallWrap(SB) /usr/local/go/src/runtime/debugcall.go
func debugCallWrap(dispatch uintptr) {
  0x405fc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x405fc9		483b6110		CMPQ 0x10(CX), SP	
  0x405fcd		0f868f000000		JBE 0x406062		
  0x405fd3		4883ec38		SUBQ $0x38, SP		
  0x405fd7		48896c2430		MOVQ BP, 0x30(SP)	
  0x405fdc		488d6c2430		LEAQ 0x30(SP), BP	
	var dispatchF func()
  0x405fe1		48c744242800000000	MOVQ $0x0, 0x28(SP)	
	dispatchFV := funcval{dispatch}
  0x405fea		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x405ff3		488b442440		MOVQ 0x40(SP), AX	
  0x405ff8		4889442420		MOVQ AX, 0x20(SP)	
	*(*unsafe.Pointer)(unsafe.Pointer(&dispatchF)) = noescape(unsafe.Pointer(&dispatchFV))
  0x405ffd		90			NOPL			
  0x405ffe		488d442420		LEAQ 0x20(SP), AX	
  0x406003		4889442428		MOVQ AX, 0x28(SP)	
	var ok bool
  0x406008		c644241f00		MOVB $0x0, 0x1f(SP)	
	defer func() {
  0x40600d		c7042408000000		MOVL $0x8, 0(SP)		
  0x406014		488d057dd70600		LEAQ 0x6d77d(IP), AX		
  0x40601b		4889442408		MOVQ AX, 0x8(SP)		
  0x406020		488d44241f		LEAQ 0x1f(SP), AX		
  0x406025		4889442410		MOVQ AX, 0x10(SP)		
  0x40602a		e801c20100		CALL runtime.deferproc(SB)	
  0x40602f		85c0			TESTL AX, AX			
  0x406031		751f			JNE 0x406052			
	dispatchF()
  0x406033		488b542428		MOVQ 0x28(SP), DX	
  0x406038		488b02			MOVQ 0(DX), AX		
  0x40603b		ffd0			CALL AX			
	ok = true
  0x40603d		c644241f01		MOVB $0x1, 0x1f(SP)	
}
  0x406042		90			NOPL				
  0x406043		e878ca0100		CALL runtime.deferreturn(SB)	
  0x406048		488b6c2430		MOVQ 0x30(SP), BP		
  0x40604d		4883c438		ADDQ $0x38, SP			
  0x406051		c3			RET				
	defer func() {
  0x406052		90			NOPL				
  0x406053		e868ca0100		CALL runtime.deferreturn(SB)	
  0x406058		488b6c2430		MOVQ 0x30(SP), BP		
  0x40605d		4883c438		ADDQ $0x38, SP			
  0x406061		c3			RET				
func debugCallWrap(dispatch uintptr) {
  0x406062		e819180400		CALL runtime.morestack_noctxt(SB)	
  0x406067		e954ffffff		JMP runtime.debugCallWrap(SB)		

TEXT runtime.gogetenv(SB) /usr/local/go/src/runtime/env_posix.go
func gogetenv(key string) string {
  0x406070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406079		483b6110		CMPQ 0x10(CX), SP	
  0x40607d		0f862e010000		JBE 0x4061b1		
  0x406083		4883ec50		SUBQ $0x50, SP		
  0x406087		48896c2448		MOVQ BP, 0x48(SP)	
  0x40608c		488d6c2448		LEAQ 0x48(SP), BP	
	env := environ()
  0x406091		488b05d0b90b00		MOVQ runtime.envs+8(SB), AX	
  0x406098		488b0dc1b90b00		MOVQ runtime.envs(SB), CX	
  0x40609f		90			NOPL				
	if env == nil {
  0x4060a0		4885c9			TESTQ CX, CX		
  0x4060a3		0f84ed000000		JE 0x406196		
	for _, s := range env {
  0x4060a9		4885c0			TESTQ AX, AX		
  0x4060ac		7e3d			JLE 0x4060eb		
	env := environ()
  0x4060ae		4889442428		MOVQ AX, 0x28(SP)	
	for _, s := range env {
  0x4060b3		488b542460		MOVQ 0x60(SP), DX	
  0x4060b8		31db			XORL BX, BX		
  0x4060ba		eb04			JMP 0x4060c0		
  0x4060bc		4883c110		ADDQ $0x10, CX		
  0x4060c0		488b31			MOVQ 0(CX), SI		
  0x4060c3		488b7908		MOVQ 0x8(CX), DI	
		if len(s) > len(key) && s[len(key)] == '=' && envKeyEqual(s[:len(key)], key) {
  0x4060c7		4839d7			CMPQ DX, DI		
  0x4060ca		0f8eb7000000		JLE 0x406187		
  0x4060d0		440fb60416		MOVZX 0(SI)(DX*1), R8	
  0x4060d5		4180f83d		CMPL $0x3d, R8		
  0x4060d9		7456			JE 0x406131		
  0x4060db		4531c0			XORL R8, R8		
  0x4060de		4584c0			TESTL R8, R8		
  0x4060e1		751a			JNE 0x4060fd		
	for _, s := range env {
  0x4060e3		48ffc3			INCQ BX			
  0x4060e6		4839c3			CMPQ AX, BX		
  0x4060e9		7cd1			JL 0x4060bc		
	return ""
  0x4060eb		0f57c0			XORPS X0, X0		
  0x4060ee		0f11442468		MOVUPS X0, 0x68(SP)	
  0x4060f3		488b6c2448		MOVQ 0x48(SP), BP	
  0x4060f8		4883c450		ADDQ $0x50, SP		
  0x4060fc		c3			RET			
			return s[len(key)+1:]
  0x4060fd		488d4201		LEAQ 0x1(DX), AX	
  0x406101		4839f8			CMPQ DI, AX		
  0x406104		0f8785000000		JA 0x40618f		
  0x40610a		4829c7			SUBQ AX, DI		
  0x40610d		4889f9			MOVQ DI, CX		
  0x406110		48f7df			NEGQ DI			
  0x406113		48c1ff3f		SARQ $0x3f, DI		
  0x406117		4821f8			ANDQ DI, AX		
  0x40611a		4801f0			ADDQ SI, AX		
  0x40611d		4889442468		MOVQ AX, 0x68(SP)	
  0x406122		48894c2470		MOVQ CX, 0x70(SP)	
  0x406127		488b6c2448		MOVQ 0x48(SP), BP	
  0x40612c		4883c450		ADDQ $0x50, SP		
  0x406130		c3			RET			
	for _, s := range env {
  0x406131		48894c2440		MOVQ CX, 0x40(SP)	
  0x406136		48895c2430		MOVQ BX, 0x30(SP)	
  0x40613b		4889742438		MOVQ SI, 0x38(SP)	
  0x406140		48897c2420		MOVQ DI, 0x20(SP)	
		if len(s) > len(key) && s[len(key)] == '=' && envKeyEqual(s[:len(key)], key) {
  0x406145		90			NOPL			
	return a == b
  0x406146		48893424		MOVQ SI, 0(SP)			
  0x40614a		488b442458		MOVQ 0x58(SP), AX		
  0x40614f		4889442408		MOVQ AX, 0x8(SP)		
  0x406154		4889542410		MOVQ DX, 0x10(SP)		
  0x406159		e8c2c0ffff		CALL runtime.memequal(SB)	
  0x40615e		440fb6442418		MOVZX 0x18(SP), R8		
	for _, s := range env {
  0x406164		488b442428		MOVQ 0x28(SP), AX	
  0x406169		488b4c2440		MOVQ 0x40(SP), CX	
		if len(s) > len(key) && s[len(key)] == '=' && envKeyEqual(s[:len(key)], key) {
  0x40616e		488b542460		MOVQ 0x60(SP), DX	
	for _, s := range env {
  0x406173		488b5c2430		MOVQ 0x30(SP), BX	
			return s[len(key)+1:]
  0x406178		488b742438		MOVQ 0x38(SP), SI	
  0x40617d		488b7c2420		MOVQ 0x20(SP), DI	
		if len(s) > len(key) && s[len(key)] == '=' && envKeyEqual(s[:len(key)], key) {
  0x406182		e957ffffff		JMP 0x4060de		
  0x406187		4531c0			XORL R8, R8		
  0x40618a		e94fffffff		JMP 0x4060de		
			return s[len(key)+1:]
  0x40618f		e8bcbe0100		CALL runtime.panicslice(SB)	
  0x406194		0f0b			UD2				
		throw("getenv before env init")
  0x406196		488d0528a80600		LEAQ 0x6a828(IP), AX	
  0x40619d		48890424		MOVQ AX, 0(SP)		
  0x4061a1		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x4061aa		e8d1d20100		CALL runtime.throw(SB)	
  0x4061af		0f0b			UD2			
func gogetenv(key string) string {
  0x4061b1		e8ca160400		CALL runtime.morestack_noctxt(SB)	
  0x4061b6		e9b5feffff		JMP runtime.gogetenv(SB)		

TEXT runtime.(*TypeAssertionError).Error(SB) /usr/local/go/src/runtime/error.go
func (e *TypeAssertionError) Error() string {
  0x4061c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4061c9		488d842470ffffff	LEAQ 0xffffff70(SP), AX	
  0x4061d1		483b4110		CMPQ 0x10(CX), AX	
  0x4061d5		0f8626040000		JBE 0x406601		
  0x4061db		4881ec10010000		SUBQ $0x110, SP		
  0x4061e2		4889ac2408010000	MOVQ BP, 0x108(SP)	
  0x4061ea		488dac2408010000	LEAQ 0x108(SP), BP	
	if e._interface != nil {
  0x4061f2		488b842418010000	MOVQ 0x118(SP), AX	
  0x4061fa		488b08			MOVQ 0(AX), CX		
  0x4061fd		4885c9			TESTQ CX, CX		
  0x406200		0f85db030000		JNE 0x4065e1		
  0x406206		488d0d76930600		LEAQ 0x69376(IP), CX	
  0x40620d		ba09000000		MOVL $0x9, DX		
		msg := "interface conversion: " + inter + " is " + cs + ", not " + as
  0x406212		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x40621a		4889542460		MOVQ DX, 0x60(SP)	
	as := e.asserted.string()
  0x40621f		488b5810		MOVQ 0x10(AX), BX			
  0x406223		48891c24		MOVQ BX, 0(SP)				
  0x406227		e8c4b40300		CALL runtime.(*_type).string(SB)	
  0x40622c		488b442408		MOVQ 0x8(SP), AX			
  0x406231		488b4c2410		MOVQ 0x10(SP), CX			
	if e.concrete == nil {
  0x406236		488b942418010000	MOVQ 0x118(SP), DX	
  0x40623e		488b5a08		MOVQ 0x8(DX), BX	
  0x406242		4885db			TESTQ BX, BX		
  0x406245		0f8414030000		JE 0x40655f		
	as := e.asserted.string()
  0x40624b		4889842498000000	MOVQ AX, 0x98(SP)	
  0x406253		48894c2470		MOVQ CX, 0x70(SP)	
	cs := e.concrete.string()
  0x406258		48891c24		MOVQ BX, 0(SP)				
  0x40625c		e88fb40300		CALL runtime.(*_type).string(SB)	
  0x406261		488b442410		MOVQ 0x10(SP), AX			
  0x406266		488b4c2408		MOVQ 0x8(SP), CX			
	if e.missingMethod == "" {
  0x40626b		488b942418010000	MOVQ 0x118(SP), DX	
  0x406273		48837a2000		CMPQ $0x0, 0x20(DX)	
  0x406278		0f8524020000		JNE 0x4064a2		
	cs := e.concrete.string()
  0x40627e		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x406286		4889442468		MOVQ AX, 0x68(SP)	
		msg := "interface conversion: " + inter + " is " + cs + ", not " + as
  0x40628b		488dbc24a8000000	LEAQ 0xa8(SP), DI			
  0x406293		488d35867d0700		LEAQ runtime.statictmp_7(SB), SI	
  0x40629a		48896c24f0		MOVQ BP, -0x10(SP)			
  0x40629f		488d6c24f0		LEAQ -0x10(SP), BP			
  0x4062a4		e8b3410400		CALL 0x44a45c				
  0x4062a9		488b6d00		MOVQ 0(BP), BP				
  0x4062ad		488b942488000000	MOVQ 0x88(SP), DX			
  0x4062b5		48899424b8000000	MOVQ DX, 0xb8(SP)			
  0x4062bd		488b542460		MOVQ 0x60(SP), DX			
  0x4062c2		48899424c0000000	MOVQ DX, 0xc0(SP)			
  0x4062ca		48898c24d8000000	MOVQ CX, 0xd8(SP)			
  0x4062d2		48898424e0000000	MOVQ AX, 0xe0(SP)			
  0x4062da		488b942498000000	MOVQ 0x98(SP), DX			
  0x4062e2		48899424f8000000	MOVQ DX, 0xf8(SP)			
  0x4062ea		488b5c2470		MOVQ 0x70(SP), BX			
  0x4062ef		48899c2400010000	MOVQ BX, 0x100(SP)			
  0x4062f7		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x4062ff		4c8d8424a8000000	LEAQ 0xa8(SP), R8			
  0x406307		4c89442408		MOVQ R8, 0x8(SP)			
  0x40630c		48c744241006000000	MOVQ $0x6, 0x10(SP)			
  0x406315		48c744241806000000	MOVQ $0x6, 0x18(SP)			
  0x40631e		e8dd330300		CALL runtime.concatstrings(SB)		
  0x406323		488b442428		MOVQ 0x28(SP), AX			
  0x406328		488b4c2420		MOVQ 0x20(SP), CX			
		if cs == as {
  0x40632d		488b542468		MOVQ 0x68(SP), DX	
  0x406332		488b5c2470		MOVQ 0x70(SP), BX	
  0x406337		4839da			CMPQ BX, DX		
  0x40633a		7420			JE 0x40635c		
		return msg
  0x40633c		48898c2420010000	MOVQ CX, 0x120(SP)	
  0x406344		4889842428010000	MOVQ AX, 0x128(SP)	
  0x40634c		488bac2408010000	MOVQ 0x108(SP), BP	
  0x406354		4881c410010000		ADDQ $0x110, SP		
  0x40635b		c3			RET			
		msg := "interface conversion: " + inter + " is " + cs + ", not " + as
  0x40635c		4889442458		MOVQ AX, 0x58(SP)	
  0x406361		48898c2480000000	MOVQ CX, 0x80(SP)	
		if cs == as {
  0x406369		488b842490000000	MOVQ 0x90(SP), AX		
  0x406371		48890424		MOVQ AX, 0(SP)			
  0x406375		488b842498000000	MOVQ 0x98(SP), AX		
  0x40637d		4889442408		MOVQ AX, 0x8(SP)		
  0x406382		4889542410		MOVQ DX, 0x10(SP)		
  0x406387		e894beffff		CALL runtime.memequal(SB)	
  0x40638c		807c241800		CMPB $0x0, 0x18(SP)		
  0x406391		750f			JNE 0x4063a2			
		return msg
  0x406393		488b442458		MOVQ 0x58(SP), AX	
  0x406398		488b8c2480000000	MOVQ 0x80(SP), CX	
		if cs == as {
  0x4063a0		eb9a			JMP 0x40633c		
			if e.concrete.pkgpath() != e.asserted.pkgpath() {
  0x4063a2		488b842418010000	MOVQ 0x118(SP), AX			
  0x4063aa		488b4808		MOVQ 0x8(AX), CX			
  0x4063ae		48890c24		MOVQ CX, 0(SP)				
  0x4063b2		e899b40300		CALL runtime.(*_type).pkgpath(SB)	
  0x4063b7		488b442408		MOVQ 0x8(SP), AX			
  0x4063bc		48898424a0000000	MOVQ AX, 0xa0(SP)			
  0x4063c4		488b4c2410		MOVQ 0x10(SP), CX			
  0x4063c9		48894c2478		MOVQ CX, 0x78(SP)			
  0x4063ce		488b942418010000	MOVQ 0x118(SP), DX			
  0x4063d6		488b5210		MOVQ 0x10(DX), DX			
  0x4063da		48891424		MOVQ DX, 0(SP)				
  0x4063de		e86db40300		CALL runtime.(*_type).pkgpath(SB)	
  0x4063e3		488b442478		MOVQ 0x78(SP), AX			
  0x4063e8		4839442410		CMPQ AX, 0x10(SP)			
  0x4063ed		7451			JE 0x406440				
				msg += " (types from different packages)"
  0x4063ef		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4063f7		488b842480000000	MOVQ 0x80(SP), AX		
  0x4063ff		4889442408		MOVQ AX, 0x8(SP)		
  0x406404		488b442458		MOVQ 0x58(SP), AX		
  0x406409		4889442410		MOVQ AX, 0x10(SP)		
  0x40640e		488d055cba0600		LEAQ 0x6ba5c(IP), AX		
  0x406415		4889442418		MOVQ AX, 0x18(SP)		
  0x40641a		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x406423		e8b8350300		CALL runtime.concatstring2(SB)	
  0x406428		488b442428		MOVQ 0x28(SP), AX		
  0x40642d		488b4c2430		MOVQ 0x30(SP), CX		
		return msg
  0x406432		4889c2			MOVQ AX, DX		
  0x406435		4889c8			MOVQ CX, AX		
  0x406438		4889d1			MOVQ DX, CX		
  0x40643b		e9fcfeffff		JMP 0x40633c		
			if e.concrete.pkgpath() != e.asserted.pkgpath() {
  0x406440		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x406448		48890c24		MOVQ CX, 0(SP)			
  0x40644c		4889442410		MOVQ AX, 0x10(SP)		
  0x406451		e8cabdffff		CALL runtime.memequal(SB)	
  0x406456		807c241800		CMPB $0x0, 0x18(SP)		
  0x40645b		7492			JE 0x4063ef			
				msg += " (types from different scopes)"
  0x40645d		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x406465		488b842480000000	MOVQ 0x80(SP), AX		
  0x40646d		4889442408		MOVQ AX, 0x8(SP)		
  0x406472		488b442458		MOVQ 0x58(SP), AX		
  0x406477		4889442410		MOVQ AX, 0x10(SP)		
  0x40647c		488d05c5b50600		LEAQ 0x6b5c5(IP), AX		
  0x406483		4889442418		MOVQ AX, 0x18(SP)		
  0x406488		48c74424201e000000	MOVQ $0x1e, 0x20(SP)		
  0x406491		e84a350300		CALL runtime.concatstring2(SB)	
  0x406496		488b442428		MOVQ 0x28(SP), AX		
  0x40649b		488b4c2430		MOVQ 0x30(SP), CX		
  0x4064a0		eb90			JMP 0x406432			
		": missing method " + e.missingMethod
  0x4064a2		488dbc24a8000000	LEAQ 0xa8(SP), DI			
  0x4064aa		488d35cf7b0700		LEAQ runtime.statictmp_8(SB), SI	
  0x4064b1		48896c24f0		MOVQ BP, -0x10(SP)			
  0x4064b6		488d6c24f0		LEAQ -0x10(SP), BP			
  0x4064bb		e89c3f0400		CALL 0x44a45c				
  0x4064c0		488b6d00		MOVQ 0(BP), BP				
  0x4064c4		48898c24b8000000	MOVQ CX, 0xb8(SP)			
  0x4064cc		48898424c0000000	MOVQ AX, 0xc0(SP)			
  0x4064d4		488b842498000000	MOVQ 0x98(SP), AX			
  0x4064dc		48898424d8000000	MOVQ AX, 0xd8(SP)			
  0x4064e4		488b442470		MOVQ 0x70(SP), AX			
  0x4064e9		48898424e0000000	MOVQ AX, 0xe0(SP)			
  0x4064f1		488b4218		MOVQ 0x18(DX), AX			
  0x4064f5		488b4a20		MOVQ 0x20(DX), CX			
  0x4064f9		48898424f8000000	MOVQ AX, 0xf8(SP)			
  0x406501		48898c2400010000	MOVQ CX, 0x100(SP)			
  0x406509		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x406511		488d8424a8000000	LEAQ 0xa8(SP), AX			
  0x406519		4889442408		MOVQ AX, 0x8(SP)			
  0x40651e		48c744241006000000	MOVQ $0x6, 0x10(SP)			
  0x406527		48c744241806000000	MOVQ $0x6, 0x18(SP)			
  0x406530		e8cb310300		CALL runtime.concatstrings(SB)		
  0x406535		488b442428		MOVQ 0x28(SP), AX			
  0x40653a		488b4c2420		MOVQ 0x20(SP), CX			
	return "interface conversion: " + cs + " is not " + as +
  0x40653f		48898c2420010000	MOVQ CX, 0x120(SP)	
  0x406547		4889842428010000	MOVQ AX, 0x128(SP)	
		": missing method " + e.missingMethod
  0x40654f		488bac2408010000	MOVQ 0x108(SP), BP	
  0x406557		4881c410010000		ADDQ $0x110, SP		
  0x40655e		c3			RET			
		return "interface conversion: " + inter + " is nil, not " + as
  0x40655f		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x406567		488d1583a40600		LEAQ 0x6a483(IP), DX		
  0x40656e		4889542408		MOVQ DX, 0x8(SP)		
  0x406573		48c744241016000000	MOVQ $0x16, 0x10(SP)		
  0x40657c		488b942488000000	MOVQ 0x88(SP), DX		
  0x406584		4889542418		MOVQ DX, 0x18(SP)		
  0x406589		488b542460		MOVQ 0x60(SP), DX		
  0x40658e		4889542420		MOVQ DX, 0x20(SP)		
  0x406593		488d1524960600		LEAQ 0x69624(IP), DX		
  0x40659a		4889542428		MOVQ DX, 0x28(SP)		
  0x40659f		48c74424300d000000	MOVQ $0xd, 0x30(SP)		
  0x4065a8		4889442438		MOVQ AX, 0x38(SP)		
  0x4065ad		48894c2440		MOVQ CX, 0x40(SP)		
  0x4065b2		e899340300		CALL runtime.concatstring4(SB)	
  0x4065b7		488b442448		MOVQ 0x48(SP), AX		
  0x4065bc		488b4c2450		MOVQ 0x50(SP), CX		
  0x4065c1		4889842420010000	MOVQ AX, 0x120(SP)		
  0x4065c9		48898c2428010000	MOVQ CX, 0x128(SP)		
  0x4065d1		488bac2408010000	MOVQ 0x108(SP), BP		
  0x4065d9		4881c410010000		ADDQ $0x110, SP			
  0x4065e0		c3			RET				
		inter = e._interface.string()
  0x4065e1		48890c24		MOVQ CX, 0(SP)				
  0x4065e5		e806b10300		CALL runtime.(*_type).string(SB)	
  0x4065ea		488b4c2408		MOVQ 0x8(SP), CX			
  0x4065ef		488b542410		MOVQ 0x10(SP), DX			
	as := e.asserted.string()
  0x4065f4		488b842418010000	MOVQ 0x118(SP), AX	
		inter = e._interface.string()
  0x4065fc		e911fcffff		JMP 0x406212		
func (e *TypeAssertionError) Error() string {
  0x406601		e87a120400		CALL runtime.morestack_noctxt(SB)		
  0x406606		e9b5fbffff		JMP runtime.(*TypeAssertionError).Error(SB)	

TEXT runtime.errorString.Error(SB) /usr/local/go/src/runtime/error.go
func (e errorString) Error() string {
  0x406610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406619		483b6110		CMPQ 0x10(CX), SP	
  0x40661d		7662			JBE 0x406681		
  0x40661f		4883ec40		SUBQ $0x40, SP		
  0x406623		48896c2438		MOVQ BP, 0x38(SP)	
  0x406628		488d6c2438		LEAQ 0x38(SP), BP	
	return "runtime error: " + string(e)
  0x40662d		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x406635		488d0590980600		LEAQ 0x69890(IP), AX		
  0x40663c		4889442408		MOVQ AX, 0x8(SP)		
  0x406641		48c74424100f000000	MOVQ $0xf, 0x10(SP)		
  0x40664a		488b442448		MOVQ 0x48(SP), AX		
  0x40664f		4889442418		MOVQ AX, 0x18(SP)		
  0x406654		488b442450		MOVQ 0x50(SP), AX		
  0x406659		4889442420		MOVQ AX, 0x20(SP)		
  0x40665e		e87d330300		CALL runtime.concatstring2(SB)	
  0x406663		488b442428		MOVQ 0x28(SP), AX		
  0x406668		488b4c2430		MOVQ 0x30(SP), CX		
  0x40666d		4889442458		MOVQ AX, 0x58(SP)		
  0x406672		48894c2460		MOVQ CX, 0x60(SP)		
  0x406677		488b6c2438		MOVQ 0x38(SP), BP		
  0x40667c		4883c440		ADDQ $0x40, SP			
  0x406680		c3			RET				
func (e errorString) Error() string {
  0x406681		e8fa110400		CALL runtime.morestack_noctxt(SB)	
  0x406686		eb88			JMP runtime.errorString.Error(SB)	

TEXT runtime.plainError.Error(SB) /usr/local/go/src/runtime/error.go
	return string(e)
  0x406690		488b442408		MOVQ 0x8(SP), AX	
  0x406695		4889442418		MOVQ AX, 0x18(SP)	
  0x40669a		488b442410		MOVQ 0x10(SP), AX	
  0x40669f		4889442420		MOVQ AX, 0x20(SP)	
  0x4066a4		c3			RET			

TEXT runtime.printany(SB) /usr/local/go/src/runtime/error.go
func printany(i interface{}) {
  0x4066b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4066b9		488d4424d0		LEAQ -0x30(SP), AX	
  0x4066be		483b4110		CMPQ 0x10(CX), AX	
  0x4066c2		0f86d5070000		JBE 0x406e9d		
  0x4066c8		4881ecb0000000		SUBQ $0xb0, SP		
  0x4066cf		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x4066d7		488dac24a8000000	LEAQ 0xa8(SP), BP	
	switch v := i.(type) {
  0x4066df		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4066e7		4885c0			TESTQ AX, AX		
  0x4066ea		0f8485070000		JE 0x406e75		
  0x4066f0		8b4810			MOVL 0x10(AX), CX	
  0x4066f3		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x4066f9		0f8713040000		JA 0x406b12		
  0x4066ff		81f98c022579		CMPL $0x7925028c, CX	
  0x406705		0f876c020000		JA 0x406977		
  0x40670b		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x406711		0f8780010000		JA 0x406897		
  0x406717		81f9c506ff13		CMPL $0x13ff06c5, CX	
  0x40671d		0f8561010000		JNE 0x406884		
  0x406723		488d1516410500		LEAQ 0x54116(IP), DX	
  0x40672a		4839c2			CMPQ AX, DX		
  0x40672d		0f853f010000		JNE 0x406872		
  0x406733		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x40673b		0fb61a			MOVZX 0(DX), BX		
  0x40673e		0f8411010000		JE 0x406855		
  0x406744		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x40674a		751a			JNE 0x406766		
  0x40674c		488d0d6d420500		LEAQ 0x5426d(IP), CX	
  0x406753		4839c1			CMPQ AX, CX		
  0x406756		0f85f1000000		JNE 0x40684d		
  0x40675c		f20f1002		MOVSD_XMM 0(DX), X0	
  0x406760		0f84bf000000		JE 0x406825		
		print("(", typestring(i), ") ", i)
  0x406766		4889842498000000	MOVQ AX, 0x98(SP)	
  0x40676e		48899424a0000000	MOVQ DX, 0xa0(SP)	
  0x406776		90			NOPL			
	e := efaceOf(&x)
  0x406777		90			NOPL			
	return e._type.string()
  0x406778		488b8c2498000000	MOVQ 0x98(SP), CX			
  0x406780		48890c24		MOVQ CX, 0(SP)				
  0x406784		e867af0300		CALL runtime.(*_type).string(SB)	
  0x406789		488b442410		MOVQ 0x10(SP), AX			
  0x40678e		4889442438		MOVQ AX, 0x38(SP)			
  0x406793		488b4c2408		MOVQ 0x8(SP), CX			
  0x406798		48898c2488000000	MOVQ CX, 0x88(SP)			
		print("(", typestring(i), ") ", i)
  0x4067a0		e81bd70100		CALL runtime.printlock(SB)	
  0x4067a5		488d05d5880600		LEAQ 0x688d5(IP), AX		
  0x4067ac		48890424		MOVQ AX, 0(SP)			
  0x4067b0		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4067b9		e832e00100		CALL runtime.printstring(SB)	
  0x4067be		488b842488000000	MOVQ 0x88(SP), AX		
  0x4067c6		48890424		MOVQ AX, 0(SP)			
  0x4067ca		488b442438		MOVQ 0x38(SP), AX		
  0x4067cf		4889442408		MOVQ AX, 0x8(SP)		
  0x4067d4		e817e00100		CALL runtime.printstring(SB)	
  0x4067d9		488d05b8880600		LEAQ 0x688b8(IP), AX		
  0x4067e0		48890424		MOVQ AX, 0(SP)			
  0x4067e4		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4067ed		e8fedf0100		CALL runtime.printstring(SB)	
  0x4067f2		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x4067fa		48890424		MOVQ AX, 0(SP)			
  0x4067fe		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x406806		4889442408		MOVQ AX, 0x8(SP)		
  0x40680b		e840e10100		CALL runtime.printeface(SB)	
  0x406810		e82bd70100		CALL runtime.printunlock(SB)	
  0x406815		488bac24a8000000	MOVQ 0xa8(SP), BP		
  0x40681d		4881c4b0000000		ADDQ $0xb0, SP			
  0x406824		c3			RET				
	switch v := i.(type) {
  0x406825		f20f11842480000000	MOVSD_XMM X0, 0x80(SP)	
		print(v)
  0x40682e		e88dd60100		CALL runtime.printlock(SB)	
  0x406833		f20f10842480000000	MOVSD_XMM 0x80(SP), X0		
  0x40683c		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x406841		e8cad90100		CALL runtime.printfloat(SB)	
  0x406846		e8f5d60100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x40684b		ebc8			JMP 0x406815		
  0x40684d		0f57c0			XORPS X0, X0		
  0x406850		e90bffffff		JMP 0x406760		
  0x406855		885c241d		MOVB BL, 0x1d(SP)	
		print(v)
  0x406859		e862d60100		CALL runtime.printlock(SB)	
  0x40685e		0fb644241d		MOVZX 0x1d(SP), AX		
  0x406863		880424			MOVB AL, 0(SP)			
  0x406866		e835d90100		CALL runtime.printbool(SB)	
  0x40686b		e8d0d60100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406870		eba3			JMP 0x406815		
  0x406872		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x40687a		bb00000000		MOVL $0x0, BX		
  0x40687f		e9bafeffff		JMP 0x40673e		
  0x406884		81f9fb7fa22e		CMPL $0x2ea27ffb, CX	
  0x40688a		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406892		e9b3feffff		JMP 0x40674a		
  0x406897		81f95f423e66		CMPL $0x663e425f, CX	
  0x40689d		0f85c1000000		JNE 0x406964		
  0x4068a3		488d15564a0500		LEAQ 0x54a56(IP), DX	
  0x4068aa		4839c2			CMPQ AX, DX		
  0x4068ad		0f859f000000		JNE 0x406952		
  0x4068b3		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x4068bb		0fb61a			MOVZX 0(DX), BX		
  0x4068be		746e			JE 0x40692e		
  0x4068c0		81f98c022579		CMPL $0x7925028c, CX	
  0x4068c6		0f859afeffff		JNE 0x406766		
  0x4068cc		488d0d6d400500		LEAQ 0x5406d(IP), CX	
  0x4068d3		4839c1			CMPQ AX, CX		
  0x4068d6		754e			JNE 0x406926		
  0x4068d8		f30f104204		MOVSS 0x4(DX), X0	
  0x4068dd		f30f100a		MOVSS 0(DX), X1		
  0x4068e1		0f857ffeffff		JNE 0x406766		
  0x4068e7		f30f11442428		MOVSS X0, 0x28(SP)	
  0x4068ed		f30f114c2424		MOVSS X1, 0x24(SP)	
		print(v)
  0x4068f3		e8c8d50100		CALL runtime.printlock(SB)	
  0x4068f8		f30f10442424		MOVSS 0x24(SP), X0		
  0x4068fe		f30f5ac0		CVTSS2SD X0, X0			
  0x406902		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x406907		f30f10442428		MOVSS 0x28(SP), X0		
  0x40690d		f30f5ac0		CVTSS2SD X0, X0			
  0x406911		f20f11442408		MOVSD_XMM X0, 0x8(SP)		
  0x406917		e894db0100		CALL runtime.printcomplex(SB)	
  0x40691c		e81fd60100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406921		e9effeffff		JMP 0x406815		
  0x406926		0f57c0			XORPS X0, X0		
  0x406929		0f57c9			XORPS X1, X1		
  0x40692c		ebb3			JMP 0x4068e1		
  0x40692e		885c241e		MOVB BL, 0x1e(SP)	
		print(v)
  0x406932		e889d50100		CALL runtime.printlock(SB)	
  0x406937		0fb644241e		MOVZX 0x1e(SP), AX		
  0x40693c		0fb6c0			MOVZX AL, AX			
  0x40693f		48890424		MOVQ AX, 0(SP)			
  0x406943		e8f8db0100		CALL runtime.printuint(SB)	
  0x406948		e8f3d50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x40694d		e9c3feffff		JMP 0x406815		
  0x406952		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x40695a		bb00000000		MOVL $0x0, BX		
  0x40695f		e95affffff		JMP 0x4068be		
  0x406964		81f98c022579		CMPL $0x7925028c, CX	
  0x40696a		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406972		e94fffffff		JMP 0x4068c6		
  0x406977		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x40697d		0f87b3000000		JA 0x406a36		
  0x406983		81f92e8d3186		CMPL $-0x79ce72d2, CX	
  0x406989		0f8594000000		JNE 0x406a23		
  0x40698f		488d152a490500		LEAQ 0x5492a(IP), DX	
  0x406996		4839c2			CMPQ AX, DX		
  0x406999		7579			JNE 0x406a14		
  0x40699b		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x4069a3		488b1a			MOVQ 0(DX), BX		
  0x4069a6		744a			JE 0x4069f2		
  0x4069a8		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x4069ae		0f85b2fdffff		JNE 0x406766		
  0x4069b4		488d0d45420500		LEAQ 0x54245(IP), CX	
  0x4069bb		4839c1			CMPQ AX, CX		
  0x4069be		752b			JNE 0x4069eb		
  0x4069c0		488b0a			MOVQ 0(DX), CX		
  0x4069c3		0f859dfdffff		JNE 0x406766		
  0x4069c9		48894c2468		MOVQ CX, 0x68(SP)	
		print(v)
  0x4069ce		e8edd40100		CALL runtime.printlock(SB)	
  0x4069d3		488b442468		MOVQ 0x68(SP), AX		
  0x4069d8		48890424		MOVQ AX, 0(SP)			
  0x4069dc		e85fdc0100		CALL runtime.printint(SB)	
  0x4069e1		e85ad50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x4069e6		e92afeffff		JMP 0x406815		
  0x4069eb		b900000000		MOVL $0x0, CX		
  0x4069f0		ebd1			JMP 0x4069c3		
  0x4069f2		48895c2470		MOVQ BX, 0x70(SP)	
		print(v)
  0x4069f7		e8c4d40100		CALL runtime.printlock(SB)	
  0x4069fc		488b442470		MOVQ 0x70(SP), AX		
  0x406a01		48890424		MOVQ AX, 0(SP)			
  0x406a05		e836db0100		CALL runtime.printuint(SB)	
  0x406a0a		e831d50100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406a0f		e901feffff		JMP 0x406815		
  0x406a14		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406a1c		bb00000000		MOVL $0x0, BX		
  0x406a21		eb83			JMP 0x4069a6		
  0x406a23		81f9ff9b3f96		CMPL $-0x69c06401, CX	
  0x406a29		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406a31		e978ffffff		JMP 0x4069ae		
  0x406a36		81f9d33ec2b0		CMPL $-0x4f3dc12d, CX	
  0x406a3c		0f85bd000000		JNE 0x406aff		
  0x406a42		488d15373f0500		LEAQ 0x53f37(IP), DX	
  0x406a49		4839c2			CMPQ AX, DX		
  0x406a4c		0f859d000000		JNE 0x406aef		
  0x406a52		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406a5a		f30f1002		MOVSS 0(DX), X0		
  0x406a5e		7466			JE 0x406ac6		
  0x406a60		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x406a66		0f85fafcffff		JNE 0x406766		
  0x406a6c		488d0d8d3e0500		LEAQ 0x53e8d(IP), CX	
  0x406a73		4839c1			CMPQ AX, CX		
  0x406a76		7546			JNE 0x406abe		
  0x406a78		f20f104208		MOVSD_XMM 0x8(DX), X0	
  0x406a7d		f20f100a		MOVSD_XMM 0(DX), X1	
  0x406a81		0f85dffcffff		JNE 0x406766		
  0x406a87		f20f11442450		MOVSD_XMM X0, 0x50(SP)	
  0x406a8d		f20f114c2440		MOVSD_XMM X1, 0x40(SP)	
		print(v)
  0x406a93		e828d40100		CALL runtime.printlock(SB)	
  0x406a98		f20f10442440		MOVSD_XMM 0x40(SP), X0		
  0x406a9e		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x406aa3		f20f10442450		MOVSD_XMM 0x50(SP), X0		
  0x406aa9		f20f11442408		MOVSD_XMM X0, 0x8(SP)		
  0x406aaf		e8fcd90100		CALL runtime.printcomplex(SB)	
  0x406ab4		e887d40100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406ab9		e957fdffff		JMP 0x406815		
  0x406abe		0f57c0			XORPS X0, X0		
  0x406ac1		0f57c9			XORPS X1, X1		
  0x406ac4		ebbb			JMP 0x406a81		
  0x406ac6		f30f1144242c		MOVSS X0, 0x2c(SP)	
		print(v)
  0x406acc		e8efd30100		CALL runtime.printlock(SB)	
  0x406ad1		f30f1044242c		MOVSS 0x2c(SP), X0		
  0x406ad7		f30f5ac0		CVTSS2SD X0, X0			
  0x406adb		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x406ae0		e82bd70100		CALL runtime.printfloat(SB)	
  0x406ae5		e856d40100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406aea		e926fdffff		JMP 0x406815		
  0x406aef		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406af7		0f57c0			XORPS X0, X0		
  0x406afa		e95fffffff		JMP 0x406a5e		
  0x406aff		81f96d541ab3		CMPL $-0x4ce5ab93, CX	
  0x406b05		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406b0d		e954ffffff		JMP 0x406a66		
  0x406b12		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x406b18		0f8772010000		JA 0x406c90		
  0x406b1e		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x406b24		0f87b3000000		JA 0x406bdd		
  0x406b2a		81f90241adbb		CMPL $-0x4452befe, CX	
  0x406b30		0f8594000000		JNE 0x406bca		
  0x406b36		488d1583400500		LEAQ 0x54083(IP), DX	
  0x406b3d		4839c2			CMPQ AX, DX		
  0x406b40		7579			JNE 0x406bbb		
  0x406b42		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406b4a		8b1a			MOVL 0(DX), BX		
  0x406b4c		744a			JE 0x406b98		
  0x406b4e		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x406b54		0f850cfcffff		JNE 0x406766		
  0x406b5a		488d0ddf470500		LEAQ 0x547df(IP), CX	
  0x406b61		4839c1			CMPQ AX, CX		
  0x406b64		752b			JNE 0x406b91		
  0x406b66		488b0a			MOVQ 0(DX), CX		
  0x406b69		0f85f7fbffff		JNE 0x406766		
  0x406b6f		48894c2478		MOVQ CX, 0x78(SP)	
		print(v)
  0x406b74		e847d30100		CALL runtime.printlock(SB)	
  0x406b79		488b442478		MOVQ 0x78(SP), AX		
  0x406b7e		48890424		MOVQ AX, 0(SP)			
  0x406b82		e8b9d90100		CALL runtime.printuint(SB)	
  0x406b87		e8b4d30100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406b8c		e984fcffff		JMP 0x406815		
  0x406b91		b900000000		MOVL $0x0, CX		
  0x406b96		ebd1			JMP 0x406b69		
  0x406b98		895c2430		MOVL BX, 0x30(SP)	
		print(v)
  0x406b9c		e81fd30100		CALL runtime.printlock(SB)	
  0x406ba1		8b442430		MOVL 0x30(SP), AX		
  0x406ba5		4863c0			MOVSXD AX, AX			
  0x406ba8		48890424		MOVQ AX, 0(SP)			
  0x406bac		e88fda0100		CALL runtime.printint(SB)	
  0x406bb1		e88ad30100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406bb6		e95afcffff		JMP 0x406815		
  0x406bbb		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406bc3		bb00000000		MOVL $0x0, BX		
  0x406bc8		eb82			JMP 0x406b4c		
  0x406bca		81f992d74abd		CMPL $-0x42b5286e, CX	
  0x406bd0		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406bd8		e977ffffff		JMP 0x406b54		
  0x406bdd		81f927c006cc		CMPL $-0x33f93fd9, CX	
  0x406be3		0f8594000000		JNE 0x406c7d		
  0x406be9		488d1550400500		LEAQ 0x54050(IP), DX	
  0x406bf0		4839c2			CMPQ AX, DX		
  0x406bf3		7579			JNE 0x406c6e		
  0x406bf5		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406bfd		0fb61a			MOVZX 0(DX), BX		
  0x406c00		7447			JE 0x406c49		
  0x406c02		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x406c08		0f8558fbffff		JNE 0x406766		
  0x406c0e		488d0d6b460500		LEAQ 0x5466b(IP), CX	
  0x406c15		4839c1			CMPQ AX, CX		
  0x406c18		7528			JNE 0x406c42		
  0x406c1a		8b0a			MOVL 0(DX), CX		
  0x406c1c		0f8544fbffff		JNE 0x406766		
  0x406c22		894c2434		MOVL CX, 0x34(SP)	
		print(v)
  0x406c26		e895d20100		CALL runtime.printlock(SB)	
  0x406c2b		8b442434		MOVL 0x34(SP), AX		
  0x406c2f		48890424		MOVQ AX, 0(SP)			
  0x406c33		e808d90100		CALL runtime.printuint(SB)	
  0x406c38		e803d30100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406c3d		e9d3fbffff		JMP 0x406815		
  0x406c42		b900000000		MOVL $0x0, CX		
  0x406c47		ebd3			JMP 0x406c1c		
  0x406c49		885c241f		MOVB BL, 0x1f(SP)	
		print(v)
  0x406c4d		e86ed20100		CALL runtime.printlock(SB)	
  0x406c52		0fb644241f		MOVZX 0x1f(SP), AX		
  0x406c57		480fbec0		MOVSX AL, AX			
  0x406c5b		48890424		MOVQ AX, 0(SP)			
  0x406c5f		e8dcd90100		CALL runtime.printint(SB)	
  0x406c64		e8d7d20100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406c69		e9a7fbffff		JMP 0x406815		
  0x406c6e		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406c76		bb00000000		MOVL $0x0, BX		
  0x406c7b		eb83			JMP 0x406c00		
  0x406c7d		81f93de84ad0		CMPL $-0x2fb517c3, CX	
  0x406c83		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406c8b		e978ffffff		JMP 0x406c08		
  0x406c90		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x406c96		0f87d8000000		JA 0x406d74		
  0x406c9c		81f91277b8d5		CMPL $-0x2a4788ee, CX	
  0x406ca2		0f85b9000000		JNE 0x406d61		
  0x406ca8		488d1551450500		LEAQ 0x54551(IP), DX	
  0x406caf		4839c2			CMPQ AX, DX		
  0x406cb2		0f8597000000		JNE 0x406d4f		
  0x406cb8		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406cc0		488b1a			MOVQ 0(DX), BX		
  0x406cc3		7468			JE 0x406d2d		
  0x406cc5		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x406ccb		0f8595faffff		JNE 0x406766		
  0x406cd1		488d0de8440500		LEAQ 0x544e8(IP), CX	
  0x406cd8		4839c1			CMPQ AX, CX		
  0x406cdb		7544			JNE 0x406d21		
  0x406cdd		488b0a			MOVQ 0(DX), CX		
  0x406ce0		488b5a08		MOVQ 0x8(DX), BX	
  0x406ce4		0f857cfaffff		JNE 0x406766		
  0x406cea		48895c2448		MOVQ BX, 0x48(SP)	
  0x406cef		48898c2490000000	MOVQ CX, 0x90(SP)	
		print(v)
  0x406cf7		e8c4d10100		CALL runtime.printlock(SB)	
  0x406cfc		488b842490000000	MOVQ 0x90(SP), AX		
  0x406d04		48890424		MOVQ AX, 0(SP)			
  0x406d08		488b442448		MOVQ 0x48(SP), AX		
  0x406d0d		4889442408		MOVQ AX, 0x8(SP)		
  0x406d12		e8d9da0100		CALL runtime.printstring(SB)	
  0x406d17		e824d20100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406d1c		e9f4faffff		JMP 0x406815		
  0x406d21		bb00000000		MOVL $0x0, BX		
  0x406d26		b900000000		MOVL $0x0, CX		
  0x406d2b		ebb7			JMP 0x406ce4		
  0x406d2d		48895c2460		MOVQ BX, 0x60(SP)	
		print(v)
  0x406d32		e889d10100		CALL runtime.printlock(SB)	
  0x406d37		488b442460		MOVQ 0x60(SP), AX		
  0x406d3c		48890424		MOVQ AX, 0(SP)			
  0x406d40		e8fbd70100		CALL runtime.printuint(SB)	
  0x406d45		e8f6d10100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406d4a		e9c6faffff		JMP 0x406815		
  0x406d4f		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406d57		bb00000000		MOVL $0x0, BX		
  0x406d5c		e962ffffff		JMP 0x406cc3		
  0x406d61		81f9b45cffe0		CMPL $-0x1f00a34c, CX	
  0x406d67		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406d6f		e957ffffff		JMP 0x406ccb		
  0x406d74		81f9ce80d5ec		CMPL $-0x132a7f32, CX	
  0x406d7a		0f85e8000000		JNE 0x406e68		
  0x406d80		488d15f93d0500		LEAQ 0x53df9(IP), DX	
  0x406d87		4839c2			CMPQ AX, DX		
  0x406d8a		0f85c6000000		JNE 0x406e56		
  0x406d90		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406d98		0fb71a			MOVZX 0(DX), BX		
  0x406d9b		0f848f000000		JE 0x406e30		
  0x406da1		81f9a00ef2ef		CMPL $-0x100df160, CX	
  0x406da7		7511			JNE 0x406dba		
  0x406da9		488d1d90440500		LEAQ 0x54490(IP), BX	
  0x406db0		4839c3			CMPQ AX, BX		
  0x406db3		7574			JNE 0x406e29		
  0x406db5		0fb71a			MOVZX 0(DX), BX		
  0x406db8		744a			JE 0x406e04		
  0x406dba		81f9fa7153f7		CMPL $-0x8ac8e06, CX	
  0x406dc0		0f85a0f9ffff		JNE 0x406766		
  0x406dc6		488d0d733d0500		LEAQ 0x53d73(IP), CX	
  0x406dcd		4839c1			CMPQ AX, CX		
  0x406dd0		752b			JNE 0x406dfd		
  0x406dd2		488b0a			MOVQ 0(DX), CX		
  0x406dd5		0f858bf9ffff		JNE 0x406766		
  0x406ddb		48894c2458		MOVQ CX, 0x58(SP)	
		print(v)
  0x406de0		e8dbd00100		CALL runtime.printlock(SB)	
  0x406de5		488b442458		MOVQ 0x58(SP), AX		
  0x406dea		48890424		MOVQ AX, 0(SP)			
  0x406dee		e84dd80100		CALL runtime.printint(SB)	
  0x406df3		e848d10100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406df8		e918faffff		JMP 0x406815		
  0x406dfd		b900000000		MOVL $0x0, CX		
  0x406e02		ebd1			JMP 0x406dd5		
  0x406e04		66895c2422		MOVW BX, 0x22(SP)	
		print(v)
  0x406e09		e8b2d00100		CALL runtime.printlock(SB)	
  0x406e0e		0fb7442422		MOVZX 0x22(SP), AX		
  0x406e13		0fb7c0			MOVZX AX, AX			
  0x406e16		48890424		MOVQ AX, 0(SP)			
  0x406e1a		e821d70100		CALL runtime.printuint(SB)	
  0x406e1f		e81cd10100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406e24		e9ecf9ffff		JMP 0x406815		
  0x406e29		bb00000000		MOVL $0x0, BX		
  0x406e2e		eb88			JMP 0x406db8		
  0x406e30		66895c2420		MOVW BX, 0x20(SP)	
		print(v)
  0x406e35		e886d00100		CALL runtime.printlock(SB)	
  0x406e3a		0fb7442420		MOVZX 0x20(SP), AX		
  0x406e3f		480fbfc0		MOVSX AX, AX			
  0x406e43		48890424		MOVQ AX, 0(SP)			
  0x406e47		e8f4d70100		CALL runtime.printint(SB)	
  0x406e4c		e8efd00100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406e51		e9bff9ffff		JMP 0x406815		
  0x406e56		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406e5e		bb00000000		MOVL $0x0, BX		
  0x406e63		e933ffffff		JMP 0x406d9b		
  0x406e68		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x406e70		e92cffffff		JMP 0x406da1		
		print("nil")
  0x406e75		e846d00100		CALL runtime.printlock(SB)	
  0x406e7a		488d056b820600		LEAQ 0x6826b(IP), AX		
  0x406e81		48890424		MOVQ AX, 0(SP)			
  0x406e85		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x406e8e		e85dd90100		CALL runtime.printstring(SB)	
  0x406e93		e8a8d00100		CALL runtime.printunlock(SB)	
	switch v := i.(type) {
  0x406e98		e978f9ffff		JMP 0x406815		
func printany(i interface{}) {
  0x406e9d		e8de090400		CALL runtime.morestack_noctxt(SB)	
  0x406ea2		e909f8ffff		JMP runtime.printany(SB)		

TEXT runtime.panicwrap(SB) /usr/local/go/src/runtime/error.go
func panicwrap() {
  0x406eb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x406eb9		488d842450ffffff	LEAQ 0xffffff50(SP), AX	
  0x406ec1		483b4110		CMPQ 0x10(CX), AX	
  0x406ec5		0f86d4030000		JBE 0x40729f		
  0x406ecb		4881ec30010000		SUBQ $0x130, SP		
  0x406ed2		4889ac2428010000	MOVQ BP, 0x128(SP)	
  0x406eda		488dac2428010000	LEAQ 0x128(SP), BP	
	name := funcname(findfunc(pc))
  0x406ee2		488b842430010000	MOVQ 0x130(SP), AX		
  0x406eea		48890424		MOVQ AX, 0(SP)			
  0x406eee		e80d3c0300		CALL runtime.findfunc(SB)	
  0x406ef3		488b442410		MOVQ 0x10(SP), AX		
  0x406ef8		488b4c2408		MOVQ 0x8(SP), CX		
  0x406efd		48890c24		MOVQ CX, 0(SP)			
  0x406f01		4889442408		MOVQ AX, 0x8(SP)		
  0x406f06		e835430300		CALL runtime.funcname(SB)	
  0x406f0b		488b442410		MOVQ 0x10(SP), AX		
  0x406f10		4889842490000000	MOVQ AX, 0x90(SP)		
  0x406f18		488b4c2418		MOVQ 0x18(SP), CX		
  0x406f1d		48894c2440		MOVQ CX, 0x40(SP)		
	i := bytealg.IndexByteString(name, '(')
  0x406f22		48890424		MOVQ AX, 0(SP)					
  0x406f26		48894c2408		MOVQ CX, 0x8(SP)				
  0x406f2b		c644241028		MOVB $0x28, 0x10(SP)				
  0x406f30		e88bb4ffff		CALL internal/bytealg.IndexByteString(SB)	
  0x406f35		488b442418		MOVQ 0x18(SP), AX				
	if i < 0 {
  0x406f3a		4885c0			TESTQ AX, AX		
  0x406f3d		0f8c08030000		JL 0x40724b		
	pkg := name[:i-1]
  0x406f43		488d48ff		LEAQ -0x1(AX), CX	
  0x406f47		4885c9			TESTQ CX, CX		
  0x406f4a		0f8cf4020000		JL 0x407244		
  0x406f50		488b542440		MOVQ 0x40(SP), DX	
  0x406f55		4839d1			CMPQ DX, CX		
  0x406f58		0f87e6020000		JA 0x407244		
	if i+2 >= len(name) || name[i-1:i+2] != ".(*" {
  0x406f5e		4883c002		ADDQ $0x2, AX		
  0x406f62		4839d0			CMPQ DX, AX		
  0x406f65		0f8d84020000		JGE 0x4071ef		
  0x406f6b		4885c0			TESTQ AX, AX		
  0x406f6e		0f8cc9020000		JL 0x40723d		
  0x406f74		4839c1			CMPQ AX, CX		
  0x406f77		0f87c0020000		JA 0x40723d		
  0x406f7d		4889c3			MOVQ AX, BX		
  0x406f80		4829c8			SUBQ CX, AX		
  0x406f83		4889c6			MOVQ AX, SI		
  0x406f86		48f7d8			NEGQ AX			
  0x406f89		48c1f83f		SARQ $0x3f, AX		
  0x406f8d		4821c8			ANDQ CX, AX		
  0x406f90		4883fe03		CMPQ $0x3, SI		
  0x406f94		0f84a4000000		JE 0x40703e		
  0x406f9a		b801000000		MOVL $0x1, AX		
  0x406f9f		84c0			TESTL AL, AL		
  0x406fa1		0f8548020000		JNE 0x4071ef		
	pkg := name[:i-1]
  0x406fa7		48894c2438		MOVQ CX, 0x38(SP)	
	name = name[i+2:]
  0x406fac		4829da			SUBQ BX, DX		
  0x406faf		4889542440		MOVQ DX, 0x40(SP)	
  0x406fb4		4889d0			MOVQ DX, AX		
  0x406fb7		48f7da			NEGQ DX			
  0x406fba		48c1fa3f		SARQ $0x3f, DX		
  0x406fbe		4821d3			ANDQ DX, BX		
  0x406fc1		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x406fc9		488d1419		LEAQ 0(CX)(BX*1), DX	
  0x406fcd		4889942488000000	MOVQ DX, 0x88(SP)	
	i = bytealg.IndexByteString(name, ')')
  0x406fd5		48891424		MOVQ DX, 0(SP)					
  0x406fd9		4889442408		MOVQ AX, 0x8(SP)				
  0x406fde		c644241029		MOVB $0x29, 0x10(SP)				
  0x406fe3		e8d8b3ffff		CALL internal/bytealg.IndexByteString(SB)	
  0x406fe8		488b442418		MOVQ 0x18(SP), AX				
	if i < 0 {
  0x406fed		4885c0			TESTQ AX, AX		
  0x406ff0		0f8ca5010000		JL 0x40719b		
	if i+2 >= len(name) || name[i:i+2] != ")." {
  0x406ff6		488d4802		LEAQ 0x2(AX), CX	
  0x406ffa		488b542440		MOVQ 0x40(SP), DX	
  0x406fff		4839d1			CMPQ DX, CX		
  0x407002		7c0d			JL 0x407011		
		throw("panicwrap: unexpected string after type name: " + name)
  0x407004		488b9c2488000000	MOVQ 0x88(SP), BX	
	if i+2 >= len(name) || name[i:i+2] != ")." {
  0x40700c		e93d010000		JMP 0x40714e		
  0x407011		4885c9			TESTQ CX, CX		
  0x407014		0f8c7a010000		JL 0x407194		
  0x40701a		4839c8			CMPQ CX, AX		
  0x40701d		0f8771010000		JA 0x407194		
  0x407023		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40702b		440fb70418		MOVZX 0(AX)(BX*1), R8	
  0x407030		664181f8292e		CMPW $0x2e29, R8	
  0x407036		0f8512010000		JNE 0x40714e		
  0x40703c		eb2e			JMP 0x40706c		
	if i+2 >= len(name) || name[i-1:i+2] != ".(*" {
  0x40703e		488bb42490000000	MOVQ 0x90(SP), SI	
  0x407046		0fb73c06		MOVZX 0(SI)(AX*1), DI	
  0x40704a		6681ff2e28		CMPW $0x282e, DI	
  0x40704f		740a			JE 0x40705b		
  0x407051		b801000000		MOVL $0x1, AX		
  0x407056		e944ffffff		JMP 0x406f9f		
  0x40705b		0fb67c0602		MOVZX 0x2(SI)(AX*1), DI	
  0x407060		4080ff2a		CMPL $0x2a, DI		
  0x407064		0f95c0			SETNE AL		
  0x407067		e933ffffff		JMP 0x406f9f		
	panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"))
  0x40706c		488dbc2498000000	LEAQ 0x98(SP), DI			
  0x407074		488d3565700700		LEAQ runtime.statictmp_9(SB), SI	
  0x40707b		48896c24f0		MOVQ BP, -0x10(SP)			
  0x407080		488d6c24f0		LEAQ -0x10(SP), BP			
  0x407085		e8a8330400		CALL 0x44a432				
  0x40708a		488b6d00		MOVQ 0(BP), BP				
  0x40708e		4c8b842490000000	MOVQ 0x90(SP), R8			
  0x407096		4c898424a8000000	MOVQ R8, 0xa8(SP)			
  0x40709e		4c8b442438		MOVQ 0x38(SP), R8			
  0x4070a3		4c898424b0000000	MOVQ R8, 0xb0(SP)			
  0x4070ab		48899c24c8000000	MOVQ BX, 0xc8(SP)			
  0x4070b3		48898424d0000000	MOVQ AX, 0xd0(SP)			
	meth := name[i+2:]
  0x4070bb		4829ca			SUBQ CX, DX		
  0x4070be		4989d0			MOVQ DX, R8		
  0x4070c1		48f7da			NEGQ DX			
  0x4070c4		48c1fa3f		SARQ $0x3f, DX		
  0x4070c8		4821d1			ANDQ DX, CX		
  0x4070cb		4801d9			ADDQ BX, CX		
	panic(plainError("value method " + pkg + "." + typ + "." + meth + " called using nil *" + typ + " pointer"))
  0x4070ce		48898c24e8000000	MOVQ CX, 0xe8(SP)		
  0x4070d6		4c898424f0000000	MOVQ R8, 0xf0(SP)		
  0x4070de		48899c2408010000	MOVQ BX, 0x108(SP)		
  0x4070e6		4889842410010000	MOVQ AX, 0x110(SP)		
  0x4070ee		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4070f6		488d842498000000	LEAQ 0x98(SP), AX		
  0x4070fe		4889442408		MOVQ AX, 0x8(SP)		
  0x407103		48c744241009000000	MOVQ $0x9, 0x10(SP)		
  0x40710c		48c744241809000000	MOVQ $0x9, 0x18(SP)		
  0x407115		e8e6250300		CALL runtime.concatstrings(SB)	
  0x40711a		488b442420		MOVQ 0x20(SP), AX		
  0x40711f		488b4c2428		MOVQ 0x28(SP), CX		
  0x407124		48890424		MOVQ AX, 0(SP)			
  0x407128		48894c2408		MOVQ CX, 0x8(SP)		
  0x40712d		e88e110000		CALL runtime.convTstring(SB)	
  0x407132		488b442410		MOVQ 0x10(SP), AX		
  0x407137		488d0dc27f0500		LEAQ 0x57fc2(IP), CX		
  0x40713e		48890c24		MOVQ CX, 0(SP)			
  0x407142		4889442408		MOVQ AX, 0x8(SP)		
  0x407147		e864bd0100		CALL runtime.gopanic(SB)	
  0x40714c		0f0b			UD2				
		throw("panicwrap: unexpected string after type name: " + name)
  0x40714e		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x407156		488d05b3bd0600		LEAQ 0x6bdb3(IP), AX		
  0x40715d		4889442408		MOVQ AX, 0x8(SP)		
  0x407162		48c74424102e000000	MOVQ $0x2e, 0x10(SP)		
  0x40716b		48895c2418		MOVQ BX, 0x18(SP)		
  0x407170		4889542420		MOVQ DX, 0x20(SP)		
  0x407175		e866280300		CALL runtime.concatstring2(SB)	
  0x40717a		488b442430		MOVQ 0x30(SP), AX		
  0x40717f		488b4c2428		MOVQ 0x28(SP), CX		
  0x407184		48890c24		MOVQ CX, 0(SP)			
  0x407188		4889442408		MOVQ AX, 0x8(SP)		
  0x40718d		e8eec20100		CALL runtime.throw(SB)		
  0x407192		0f0b			UD2				
	if i+2 >= len(name) || name[i:i+2] != ")." {
  0x407194		e8b7ae0100		CALL runtime.panicslice(SB)	
  0x407199		0f0b			UD2				
		throw("panicwrap: no ) in " + name)
  0x40719b		488d442448		LEAQ 0x48(SP), AX		
  0x4071a0		48890424		MOVQ AX, 0(SP)			
  0x4071a4		488d0502930600		LEAQ 0x69302(IP), AX		
  0x4071ab		4889442408		MOVQ AX, 0x8(SP)		
  0x4071b0		48c744241013000000	MOVQ $0x13, 0x10(SP)		
  0x4071b9		488b842488000000	MOVQ 0x88(SP), AX		
  0x4071c1		4889442418		MOVQ AX, 0x18(SP)		
  0x4071c6		488b442440		MOVQ 0x40(SP), AX		
  0x4071cb		4889442420		MOVQ AX, 0x20(SP)		
  0x4071d0		e80b280300		CALL runtime.concatstring2(SB)	
  0x4071d5		488b442430		MOVQ 0x30(SP), AX		
  0x4071da		488b4c2428		MOVQ 0x28(SP), CX		
  0x4071df		48890c24		MOVQ CX, 0(SP)			
  0x4071e3		4889442408		MOVQ AX, 0x8(SP)		
  0x4071e8		e893c20100		CALL runtime.throw(SB)		
  0x4071ed		0f0b			UD2				
		throw("panicwrap: unexpected string after package name: " + name)
  0x4071ef		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4071f7		488d0543bf0600		LEAQ 0x6bf43(IP), AX		
  0x4071fe		4889442408		MOVQ AX, 0x8(SP)		
  0x407203		48c744241031000000	MOVQ $0x31, 0x10(SP)		
  0x40720c		488b842490000000	MOVQ 0x90(SP), AX		
  0x407214		4889442418		MOVQ AX, 0x18(SP)		
  0x407219		4889542420		MOVQ DX, 0x20(SP)		
  0x40721e		e8bd270300		CALL runtime.concatstring2(SB)	
  0x407223		488b442428		MOVQ 0x28(SP), AX		
  0x407228		488b4c2430		MOVQ 0x30(SP), CX		
  0x40722d		48890424		MOVQ AX, 0(SP)			
  0x407231		48894c2408		MOVQ CX, 0x8(SP)		
  0x407236		e845c20100		CALL runtime.throw(SB)		
  0x40723b		0f0b			UD2				
	if i+2 >= len(name) || name[i-1:i+2] != ".(*" {
  0x40723d		e80eae0100		CALL runtime.panicslice(SB)	
  0x407242		0f0b			UD2				
	pkg := name[:i-1]
  0x407244		e807ae0100		CALL runtime.panicslice(SB)	
  0x407249		0f0b			UD2				
		throw("panicwrap: no ( in " + name)
  0x40724b		488d442468		LEAQ 0x68(SP), AX		
  0x407250		48890424		MOVQ AX, 0(SP)			
  0x407254		488d053f920600		LEAQ 0x6923f(IP), AX		
  0x40725b		4889442408		MOVQ AX, 0x8(SP)		
  0x407260		48c744241013000000	MOVQ $0x13, 0x10(SP)		
  0x407269		488b842490000000	MOVQ 0x90(SP), AX		
  0x407271		4889442418		MOVQ AX, 0x18(SP)		
  0x407276		488b442440		MOVQ 0x40(SP), AX		
  0x40727b		4889442420		MOVQ AX, 0x20(SP)		
  0x407280		e85b270300		CALL runtime.concatstring2(SB)	
  0x407285		488b442428		MOVQ 0x28(SP), AX		
  0x40728a		488b4c2430		MOVQ 0x30(SP), CX		
  0x40728f		48890424		MOVQ AX, 0(SP)			
  0x407293		48894c2408		MOVQ CX, 0x8(SP)		
  0x407298		e8e3c10100		CALL runtime.throw(SB)		
  0x40729d		0f0b			UD2				
func panicwrap() {
  0x40729f		e8dc050400		CALL runtime.morestack_noctxt(SB)	
  0x4072a4		e907fcffff		JMP runtime.panicwrap(SB)		

TEXT runtime.float64frombits(SB) /usr/local/go/src/runtime/float.go
	return *(*float64)(unsafe.Pointer(&b))
  0x4072b0		f20f10442408		MOVSD_XMM 0x8(SP), X0	
  0x4072b6		f20f11442410		MOVSD_XMM X0, 0x10(SP)	
  0x4072bc		c3			RET			

TEXT runtime.memhash(SB) /usr/local/go/src/runtime/hash64.go
func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {
  0x4072c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4072c9		483b6110		CMPQ 0x10(CX), SP	
  0x4072cd		0f86ee020000		JBE 0x4075c1		
  0x4072d3		4883ec28		SUBQ $0x28, SP		
  0x4072d7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4072dc		488d6c2420		LEAQ 0x20(SP), BP	
	if (GOARCH == "amd64" || GOARCH == "arm64") &&
  0x4072e1		803dcd590d0000		CMPB $0x0, runtime.useAeshash(SB)	
  0x4072e8		0f859d020000		JNE 0x40758b				
	h := uint64(seed + s*hashkey[0])
  0x4072ee		488b054b5b0d00		MOVQ runtime.hashkey(SB), AX	
  0x4072f5		488b4c2440		MOVQ 0x40(SP), CX		
  0x4072fa		480fafc1		IMULQ CX, AX			
  0x4072fe		488b542438		MOVQ 0x38(SP), DX		
  0x407303		4801d0			ADDQ DX, AX			
tail:
  0x407306		488b5c2430		MOVQ 0x30(SP), BX	
  0x40730b		e99a000000		JMP 0x4073aa		
	return *(*uint64)(p)
  0x407310		4c8b0b			MOVQ 0(BX), R9		
			v1 ^= readUnaligned64(p)
  0x407313		4c31c8			XORQ R9, AX		
  0x407316		90			NOPL			
			v1 = rotl_31(v1*m1) * m2
  0x407317		90			NOPL				
  0x407318		49b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, R9	
  0x407322		490fafc1		IMULQ R9, AX			
	return (x << 31) | (x >> (64 - 31))
  0x407326		48c1c01f		ROLQ $0x1f, AX		
			v1 = rotl_31(v1*m1) * m2
  0x40732a		49ba9913da960da32327	MOVQ $0x2723a30d96da1399, R10	
  0x407334		490fafc2		IMULQ R10, AX			
			p = add(p, 8)
  0x407338		90			NOPL			
	return *(*uint64)(p)
  0x407339		4c8b5b08		MOVQ 0x8(BX), R11	
			v2 ^= readUnaligned64(p)
  0x40733d		4c31de			XORQ R11, SI		
  0x407340		90			NOPL			
			v2 = rotl_31(v2*m2) * m3
  0x407341		90			NOPL			
  0x407342		490faff2		IMULQ R10, SI		
	return (x << 31) | (x >> (64 - 31))
  0x407346		48c1c61f		ROLQ $0x1f, SI		
			v2 = rotl_31(v2*m2) * m3
  0x40734a		49bbd7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, R11	
  0x407354		490faff3		IMULQ R11, SI			
			p = add(p, 8)
  0x407358		90			NOPL			
	return *(*uint64)(p)
  0x407359		4c8b6310		MOVQ 0x10(BX), R12	
			v3 ^= readUnaligned64(p)
  0x40735d		4c31e7			XORQ R12, DI		
  0x407360		90			NOPL			
			v3 = rotl_31(v3*m3) * m4
  0x407361		90			NOPL			
  0x407362		490faffb		IMULQ R11, DI		
	return (x << 31) | (x >> (64 - 31))
  0x407366		48c1c71f		ROLQ $0x1f, DI		
			v3 = rotl_31(v3*m3) * m4
  0x40736a		49bc93f63d647bc2cfdb	MOVQ $0xdbcfc27b643df693, R12	
  0x407374		490faffc		IMULQ R12, DI			
			p = add(p, 8)
  0x407378		90			NOPL			
	return *(*uint64)(p)
  0x407379		4c8b6b18		MOVQ 0x18(BX), R13	
			v4 ^= readUnaligned64(p)
  0x40737d		4d31e8			XORQ R13, R8		
  0x407380		90			NOPL			
			v4 = rotl_31(v4*m4) * m1
  0x407381		90			NOPL			
  0x407382		4d0fafc4		IMULQ R12, R8		
	return (x << 31) | (x >> (64 - 31))
  0x407386		49c1c01f		ROLQ $0x1f, R8		
			v4 = rotl_31(v4*m4) * m1
  0x40738a		4d0fafc1		IMULQ R9, R8		
			p = add(p, 8)
  0x40738e		90			NOPL			
			s -= 32
  0x40738f		4883c1e0		ADDQ $-0x20, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x407393		4883c320		ADDQ $0x20, BX		
		for s >= 32 {
  0x407397		4883f920		CMPQ $0x20, CX		
  0x40739b		0f836fffffff		JAE 0x407310		
		h = v1 ^ v2 ^ v3 ^ v4
  0x4073a1		4831f0			XORQ SI, AX		
  0x4073a4		4831f8			XORQ DI, AX		
  0x4073a7		4c31c0			XORQ R8, AX		
	case s == 0:
  0x4073aa		4885c9			TESTQ CX, CX		
  0x4073ad		0f84cd000000		JE 0x407480		
	case s < 4:
  0x4073b3		4883f904		CMPQ $0x4, CX		
  0x4073b7		0f827d010000		JB 0x40753a		
	case s <= 8:
  0x4073bd		4883f908		CMPQ $0x8, CX		
  0x4073c1		0f8631010000		JBE 0x4074f8		
	case s <= 16:
  0x4073c7		4883f910		CMPQ $0x10, CX		
  0x4073cb		0f86e0000000		JBE 0x4074b1		
	case s <= 32:
  0x4073d1		4883f920		CMPQ $0x20, CX		
  0x4073d5		7623			JBE 0x4073fa		
		v2 := uint64(seed * hashkey[1])
  0x4073d7		488b356a5a0d00		MOVQ runtime.hashkey+8(SB), SI	
  0x4073de		480faff2		IMULQ DX, SI			
		v3 := uint64(seed * hashkey[2])
  0x4073e2		488b3d675a0d00		MOVQ runtime.hashkey+16(SB), DI	
  0x4073e9		480faffa		IMULQ DX, DI			
		v4 := uint64(seed * hashkey[3])
  0x4073ed		4c8b05645a0d00		MOVQ runtime.hashkey+24(SB), R8	
  0x4073f4		4c0fafc2		IMULQ DX, R8			
		for s >= 32 {
  0x4073f8		eb9d			JMP 0x407397		
	return unsafe.Pointer(uintptr(p) + x)
  0x4073fa		4889da			MOVQ BX, DX		
  0x4073fd		488d3419		LEAQ 0(CX)(BX*1), SI	
  0x407401		488d76f0		LEAQ -0x10(SI), SI	
  0x407405		488d0c19		LEAQ 0(CX)(BX*1), CX	
  0x407409		488d49f8		LEAQ -0x8(CX), CX	
	return *(*uint64)(p)
  0x40740d		488b1a			MOVQ 0(DX), BX		
		h ^= readUnaligned64(p)
  0x407410		4831d8			XORQ BX, AX		
  0x407413		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x407414		90			NOPL				
  0x407415		48bb4115f07990ec38ea	MOVQ $0xea38ec9079f01541, BX	
  0x40741f		480fafd8		IMULQ AX, BX			
	return (x << 31) | (x >> (64 - 31))
  0x407423		48c1c31f		ROLQ $0x1f, BX		
		h = rotl_31(h*m1) * m2
  0x407427		48b89913da960da32327	MOVQ $0x2723a30d96da1399, AX	
  0x407431		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, 8))
  0x407435		48334208		XORQ 0x8(DX), AX	
  0x407439		90			NOPL			
  0x40743a		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x40743b		90			NOPL				
  0x40743c		48ba4115f07990ec38ea	MOVQ $0xea38ec9079f01541, DX	
  0x407446		480fafc2		IMULQ DX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x40744a		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x40744e		48bb9913da960da32327	MOVQ $0x2723a30d96da1399, BX	
  0x407458		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, s-16))
  0x40745c		483306			XORQ 0(SI), AX		
  0x40745f		90			NOPL			
  0x407460		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x407461		90			NOPL			
  0x407462		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x407466		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x40746a		480fafc3		IMULQ BX, AX		
		h ^= readUnaligned64(add(p, s-8))
  0x40746e		483301			XORQ 0(CX), AX		
  0x407471		90			NOPL			
  0x407472		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x407473		90			NOPL			
  0x407474		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x407478		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x40747c		480fafc3		IMULQ BX, AX		
	h ^= h >> 29
  0x407480		4889c1			MOVQ AX, CX		
  0x407483		48c1e81d		SHRQ $0x1d, AX		
  0x407487		4831c1			XORQ AX, CX		
	h *= m3
  0x40748a		48b8d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, AX	
  0x407494		480fafc8		IMULQ AX, CX			
	h ^= h >> 32
  0x407498		4889c8			MOVQ CX, AX		
  0x40749b		48c1e920		SHRQ $0x20, CX		
  0x40749f		4831c1			XORQ AX, CX		
	return uintptr(h)
  0x4074a2		48894c2448		MOVQ CX, 0x48(SP)	
  0x4074a7		488b6c2420		MOVQ 0x20(SP), BP	
  0x4074ac		4883c428		ADDQ $0x28, SP		
  0x4074b0		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x4074b1		4889da			MOVQ BX, DX		
  0x4074b4		488d0c19		LEAQ 0(CX)(BX*1), CX	
  0x4074b8		488d49f8		LEAQ -0x8(CX), CX	
	return *(*uint64)(p)
  0x4074bc		488b12			MOVQ 0(DX), DX		
		h ^= readUnaligned64(p)
  0x4074bf		4831d0			XORQ DX, AX		
  0x4074c2		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x4074c3		90			NOPL				
  0x4074c4		48ba4115f07990ec38ea	MOVQ $0xea38ec9079f01541, DX	
  0x4074ce		480fafc2		IMULQ DX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x4074d2		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x4074d6		48bb9913da960da32327	MOVQ $0x2723a30d96da1399, BX	
  0x4074e0		480fafc3		IMULQ BX, AX			
		h ^= readUnaligned64(add(p, s-8))
  0x4074e4		483301			XORQ 0(CX), AX		
  0x4074e7		90			NOPL			
  0x4074e8		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x4074e9		90			NOPL			
  0x4074ea		480fafc2		IMULQ DX, AX		
	return (x << 31) | (x >> (64 - 31))
  0x4074ee		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x4074f2		480fafc3		IMULQ BX, AX		
	switch {
  0x4074f6		eb88			JMP 0x407480		
	return unsafe.Pointer(uintptr(p) + x)
  0x4074f8		4889da			MOVQ BX, DX		
  0x4074fb		488d0c19		LEAQ 0(CX)(BX*1), CX	
  0x4074ff		488d49fc		LEAQ -0x4(CX), CX	
	return *(*uint32)(p)
  0x407503		8b12			MOVL 0(DX), DX		
		h ^= uint64(readUnaligned32(p))
  0x407505		4831d0			XORQ DX, AX		
  0x407508		90			NOPL			
	return *(*uint32)(p)
  0x407509		8b09			MOVL 0(CX), CX		
		h ^= uint64(readUnaligned32(add(p, s-4))) << 32
  0x40750b		48c1e120		SHLQ $0x20, CX		
  0x40750f		4831c8			XORQ CX, AX		
  0x407512		90			NOPL			
  0x407513		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x407514		90			NOPL				
  0x407515		48b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, CX	
  0x40751f		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x407523		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x407527		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x407531		480fafc1		IMULQ CX, AX			
	switch {
  0x407535		e946ffffff		JMP 0x407480		
	return unsafe.Pointer(uintptr(p) + x)
  0x40753a		4889da			MOVQ BX, DX		
  0x40753d		488d1c19		LEAQ 0(CX)(BX*1), BX	
  0x407541		488d5bff		LEAQ -0x1(BX), BX	
		h ^= uint64(*(*byte)(p))
  0x407545		0fb632			MOVZX 0(DX), SI		
  0x407548		4831f0			XORQ SI, AX		
		h ^= uint64(*(*byte)(add(p, s>>1))) << 8
  0x40754b		48d1e9			SHRQ $0x1, CX		
  0x40754e		0fb60c0a		MOVZX 0(DX)(CX*1), CX	
  0x407552		48c1e108		SHLQ $0x8, CX		
  0x407556		4831c8			XORQ CX, AX		
  0x407559		90			NOPL			
		h ^= uint64(*(*byte)(add(p, s-1))) << 16
  0x40755a		0fb60b			MOVZX 0(BX), CX		
  0x40755d		48c1e110		SHLQ $0x10, CX		
  0x407561		4831c8			XORQ CX, AX		
  0x407564		90			NOPL			
		h = rotl_31(h*m1) * m2
  0x407565		90			NOPL				
  0x407566		48b94115f07990ec38ea	MOVQ $0xea38ec9079f01541, CX	
  0x407570		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x407574		48c1c01f		ROLQ $0x1f, AX		
		h = rotl_31(h*m1) * m2
  0x407578		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x407582		480fafc1		IMULQ CX, AX			
	switch {
  0x407586		e9f5feffff		JMP 0x407480		
		return aeshash(p, seed, s)
  0x40758b		488b442430		MOVQ 0x30(SP), AX		
  0x407590		48890424		MOVQ AX, 0(SP)			
  0x407594		488b442438		MOVQ 0x38(SP), AX		
  0x407599		4889442408		MOVQ AX, 0x8(SP)		
  0x40759e		488b442440		MOVQ 0x40(SP), AX		
  0x4075a3		4889442410		MOVQ AX, 0x10(SP)		
  0x4075a8		e8831a0400		CALL runtime.aeshash(SB)	
  0x4075ad		488b442418		MOVQ 0x18(SP), AX		
  0x4075b2		4889442448		MOVQ AX, 0x48(SP)		
  0x4075b7		488b6c2420		MOVQ 0x20(SP), BP		
  0x4075bc		4883c428		ADDQ $0x28, SP			
  0x4075c0		c3			RET				
func memhash(p unsafe.Pointer, seed, s uintptr) uintptr {
  0x4075c1		e8ba020400		CALL runtime.morestack_noctxt(SB)	
  0x4075c6		e9f5fcffff		JMP runtime.memhash(SB)			

TEXT runtime.memhash32(SB) /usr/local/go/src/runtime/hash64.go
	h := uint64(seed + 4*hashkey[0])
  0x4075d0		488b0569580d00		MOVQ runtime.hashkey(SB), AX	
	v := uint64(readUnaligned32(p))
  0x4075d7		90			NOPL			
	h = rotl_31(h*m1) * m2
  0x4075d8		90			NOPL			
	return *(*uint32)(p)
  0x4075d9		488b4c2408		MOVQ 0x8(SP), CX	
  0x4075de		8b09			MOVL 0(CX), CX		
	h := uint64(seed + 4*hashkey[0])
  0x4075e0		488b542410		MOVQ 0x10(SP), DX	
  0x4075e5		488d0482		LEAQ 0(DX)(AX*4), AX	
	h ^= v
  0x4075e9		4831c8			XORQ CX, AX		
	h ^= v << 32
  0x4075ec		48c1e120		SHLQ $0x20, CX		
  0x4075f0		4831c1			XORQ AX, CX		
	h = rotl_31(h*m1) * m2
  0x4075f3		48b84115f07990ec38ea	MOVQ $0xea38ec9079f01541, AX	
  0x4075fd		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x407601		48c1c01f		ROLQ $0x1f, AX		
	h = rotl_31(h*m1) * m2
  0x407605		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x40760f		480fafc8		IMULQ AX, CX			
	h ^= h >> 29
  0x407613		4889c8			MOVQ CX, AX		
  0x407616		48c1e91d		SHRQ $0x1d, CX		
  0x40761a		4831c8			XORQ CX, AX		
	h *= m3
  0x40761d		48b9d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, CX	
  0x407627		480fafc8		IMULQ AX, CX			
	h ^= h >> 32
  0x40762b		4889c8			MOVQ CX, AX		
  0x40762e		48c1e920		SHRQ $0x20, CX		
  0x407632		4831c8			XORQ CX, AX		
	return uintptr(h)
  0x407635		4889442418		MOVQ AX, 0x18(SP)	
  0x40763a		c3			RET			

TEXT runtime.memhash64(SB) /usr/local/go/src/runtime/hash64.go
	h := uint64(seed + 8*hashkey[0])
  0x407640		488b05f9570d00		MOVQ runtime.hashkey(SB), AX	
	h ^= uint64(readUnaligned32(p)) | uint64(readUnaligned32(add(p, 4)))<<32
  0x407647		90			NOPL			
  0x407648		90			NOPL			
  0x407649		90			NOPL			
	h = rotl_31(h*m1) * m2
  0x40764a		90			NOPL			
	return *(*uint32)(p)
  0x40764b		488b4c2408		MOVQ 0x8(SP), CX	
  0x407650		488b09			MOVQ 0(CX), CX		
	h := uint64(seed + 8*hashkey[0])
  0x407653		488b542410		MOVQ 0x10(SP), DX	
  0x407658		488d04c2		LEAQ 0(DX)(AX*8), AX	
	h ^= uint64(readUnaligned32(p)) | uint64(readUnaligned32(add(p, 4)))<<32
  0x40765c		4831c1			XORQ AX, CX		
	h = rotl_31(h*m1) * m2
  0x40765f		48b84115f07990ec38ea	MOVQ $0xea38ec9079f01541, AX	
  0x407669		480fafc1		IMULQ CX, AX			
	return (x << 31) | (x >> (64 - 31))
  0x40766d		48c1c01f		ROLQ $0x1f, AX		
	h = rotl_31(h*m1) * m2
  0x407671		48b99913da960da32327	MOVQ $0x2723a30d96da1399, CX	
  0x40767b		480fafc8		IMULQ AX, CX			
	h ^= h >> 29
  0x40767f		4889c8			MOVQ CX, AX		
  0x407682		48c1e91d		SHRQ $0x1d, CX		
  0x407686		4831c8			XORQ CX, AX		
	h *= m3
  0x407689		48b9d7d276f8ad8ecf83	MOVQ $0x83cf8eadf876d2d7, CX	
  0x407693		480fafc8		IMULQ AX, CX			
	h ^= h >> 32
  0x407697		4889c8			MOVQ CX, AX		
  0x40769a		48c1e920		SHRQ $0x20, CX		
  0x40769e		4831c8			XORQ CX, AX		
	return uintptr(h)
  0x4076a1		4889442418		MOVQ AX, 0x18(SP)	
  0x4076a6		c3			RET			

TEXT runtime.getitab(SB) /usr/local/go/src/runtime/iface.go
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x4076b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4076b9		483b6110		CMPQ 0x10(CX), SP	
  0x4076bd		0f8669030000		JBE 0x407a2c		
  0x4076c3		4883ec48		SUBQ $0x48, SP		
  0x4076c7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4076cc		488d6c2440		LEAQ 0x40(SP), BP	
	if len(inter.mhdr) == 0 {
  0x4076d1		488b442450		MOVQ 0x50(SP), AX	
  0x4076d6		488b4838		MOVQ 0x38(AX), CX	
  0x4076da		4883784000		CMPQ $0x0, 0x40(AX)	
  0x4076df		0f842c030000		JE 0x407a11		
	if typ.tflag&tflagUncommon == 0 {
  0x4076e5		488b542458		MOVQ 0x58(SP), DX	
  0x4076ea		0fb65a14		MOVZX 0x14(DX), BX	
  0x4076ee		f6c301			TESTL $0x1, BL		
  0x4076f1		0f85db000000		JNE 0x4077d2		
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x4076f7		0fb65c2460		MOVZX 0x60(SP), BX	
  0x4076fc		84db			TESTL BL, BL		
		if canfail {
  0x4076fe		7413			JE 0x407713		
			return nil
  0x407700		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x407709		488b6c2440		MOVQ 0x40(SP), BP	
  0x40770e		4883c448		ADDQ $0x48, SP		
  0x407712		c3			RET			
		name := inter.typ.nameOff(inter.mhdr[0].name)
  0x407713		90			NOPL			
  0x407714		8b09			MOVL 0(CX), CX		
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407716		48890424		MOVQ AX, 0(SP)			
  0x40771a		894c2408		MOVL CX, 0x8(SP)		
  0x40771e		e83da20300		CALL runtime.resolveNameOff(SB)	
  0x407723		488b442410		MOVQ 0x10(SP), AX		
		panic(&TypeAssertionError{nil, typ, &inter.typ, name.name()})
  0x407728		48890424		MOVQ AX, 0(SP)				
  0x40772c		e81fac0300		CALL runtime.name.name(SB)		
  0x407731		488b442410		MOVQ 0x10(SP), AX			
  0x407736		4889442420		MOVQ AX, 0x20(SP)			
  0x40773b		488b4c2408		MOVQ 0x8(SP), CX			
  0x407740		48894c2438		MOVQ CX, 0x38(SP)			
  0x407745		488d1534ec0500		LEAQ 0x5ec34(IP), DX			
  0x40774c		48891424		MOVQ DX, 0(SP)				
  0x407750		e8fb2f0000		CALL runtime.newobject(SB)		
  0x407755		488b442408		MOVQ 0x8(SP), AX			
  0x40775a		833dbf560d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x407761		754b			JNE 0x4077ae				
  0x407763		488b4c2458		MOVQ 0x58(SP), CX			
  0x407768		48894808		MOVQ CX, 0x8(AX)			
  0x40776c		488b4c2450		MOVQ 0x50(SP), CX			
  0x407771		48894810		MOVQ CX, 0x10(AX)			
  0x407775		488b4c2420		MOVQ 0x20(SP), CX			
  0x40777a		48894820		MOVQ CX, 0x20(AX)			
  0x40777e		833d9b560d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x407785		7511			JNE 0x407798				
  0x407787		488b4c2438		MOVQ 0x38(SP), CX			
  0x40778c		48894818		MOVQ CX, 0x18(AX)			
  0x407790		4889c1			MOVQ AX, CX				
  0x407793		e962020000		JMP 0x4079fa				
  0x407798		488d7818		LEAQ 0x18(AX), DI			
  0x40779c		4889c1			MOVQ AX, CX				
  0x40779f		488b442438		MOVQ 0x38(SP), AX			
  0x4077a4		e8d71e0400		CALL runtime.gcWriteBarrier(SB)		
  0x4077a9		e94c020000		JMP 0x4079fa				
  0x4077ae		488d7808		LEAQ 0x8(AX), DI			
  0x4077b2		4889c1			MOVQ AX, CX				
  0x4077b5		488b442458		MOVQ 0x58(SP), AX			
  0x4077ba		e8c11e0400		CALL runtime.gcWriteBarrier(SB)		
  0x4077bf		488d7910		LEAQ 0x10(CX), DI			
  0x4077c3		488b442450		MOVQ 0x50(SP), AX			
  0x4077c8		e8b31e0400		CALL runtime.gcWriteBarrier(SB)		
  0x4077cd		4889c8			MOVQ CX, AX				
  0x4077d0		eba3			JMP 0x407775				
	t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))
  0x4077d2		488b0d57830b00		MOVQ runtime.itabTable(SB), CX	
	if m = t.find(inter, typ); m != nil {
  0x4077d9		48890c24		MOVQ CX, 0(SP)				
  0x4077dd		4889442408		MOVQ AX, 0x8(SP)			
  0x4077e2		4889542410		MOVQ DX, 0x10(SP)			
  0x4077e7		e854020000		CALL runtime.(*itabTableType).find(SB)	
  0x4077ec		488b442418		MOVQ 0x18(SP), AX			
  0x4077f1		4885c0			TESTQ AX, AX				
  0x4077f4		0f84e0000000		JE 0x4078da				
	if m.fun[0] != 0 {
  0x4077fa		4883781800		CMPQ $0x0, 0x18(AX)	
  0x4077ff		0f85c6000000		JNE 0x4078cb		
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x407805		0fb64c2460		MOVZX 0x60(SP), CX	
  0x40780a		84c9			TESTL CL, CL		
	if canfail {
  0x40780c		7413			JE 0x407821		
		return nil
  0x40780e		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x407817		488b6c2440		MOVQ 0x40(SP), BP	
  0x40781c		4883c448		ADDQ $0x48, SP		
  0x407820		c3			RET			
	panic(&TypeAssertionError{concrete: typ, asserted: &inter.typ, missingMethod: m.init()})
  0x407821		48890424		MOVQ AX, 0(SP)				
  0x407825		e826040000		CALL runtime.(*itab).init(SB)		
  0x40782a		488b442410		MOVQ 0x10(SP), AX			
  0x40782f		4889442420		MOVQ AX, 0x20(SP)			
  0x407834		488b4c2408		MOVQ 0x8(SP), CX			
  0x407839		48894c2438		MOVQ CX, 0x38(SP)			
  0x40783e		488d153beb0500		LEAQ 0x5eb3b(IP), DX			
  0x407845		48891424		MOVQ DX, 0(SP)				
  0x407849		e8022f0000		CALL runtime.newobject(SB)		
  0x40784e		488b442408		MOVQ 0x8(SP), AX			
  0x407853		833dc6550d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40785a		754b			JNE 0x4078a7				
  0x40785c		488b4c2458		MOVQ 0x58(SP), CX			
  0x407861		48894808		MOVQ CX, 0x8(AX)			
  0x407865		488b4c2450		MOVQ 0x50(SP), CX			
  0x40786a		48894810		MOVQ CX, 0x10(AX)			
  0x40786e		488b4c2420		MOVQ 0x20(SP), CX			
  0x407873		48894820		MOVQ CX, 0x20(AX)			
  0x407877		833da2550d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40787e		7511			JNE 0x407891				
  0x407880		488b4c2438		MOVQ 0x38(SP), CX			
  0x407885		48894818		MOVQ CX, 0x18(AX)			
  0x407889		4889c1			MOVQ AX, CX				
  0x40788c		e952010000		JMP 0x4079e3				
  0x407891		488d7818		LEAQ 0x18(AX), DI			
  0x407895		4889c1			MOVQ AX, CX				
  0x407898		488b442438		MOVQ 0x38(SP), AX			
  0x40789d		e8de1d0400		CALL runtime.gcWriteBarrier(SB)		
  0x4078a2		e93c010000		JMP 0x4079e3				
  0x4078a7		488d7808		LEAQ 0x8(AX), DI			
  0x4078ab		4889c1			MOVQ AX, CX				
  0x4078ae		488b442458		MOVQ 0x58(SP), AX			
  0x4078b3		e8c81d0400		CALL runtime.gcWriteBarrier(SB)		
  0x4078b8		488d7910		LEAQ 0x10(CX), DI			
  0x4078bc		488b442450		MOVQ 0x50(SP), AX			
  0x4078c1		e8ba1d0400		CALL runtime.gcWriteBarrier(SB)		
  0x4078c6		4889c8			MOVQ CX, AX				
  0x4078c9		eba3			JMP 0x40786e				
		return m
  0x4078cb		4889442468		MOVQ AX, 0x68(SP)	
  0x4078d0		488b6c2440		MOVQ 0x40(SP), BP	
  0x4078d5		4883c448		ADDQ $0x48, SP		
  0x4078d9		c3			RET			
	lock(&itabLock)
  0x4078da		488d05a7540d00		LEAQ runtime.itabLock(SB), AX	
  0x4078e1		48890424		MOVQ AX, 0(SP)			
  0x4078e5		e8f60d0000		CALL runtime.lock(SB)		
	if m = itabTable.find(inter, typ); m != nil {
  0x4078ea		488b053f820b00		MOVQ runtime.itabTable(SB), AX		
  0x4078f1		48890424		MOVQ AX, 0(SP)				
  0x4078f5		488b442450		MOVQ 0x50(SP), AX			
  0x4078fa		4889442408		MOVQ AX, 0x8(SP)			
  0x4078ff		488b4c2458		MOVQ 0x58(SP), CX			
  0x407904		48894c2410		MOVQ CX, 0x10(SP)			
  0x407909		e832010000		CALL runtime.(*itabTableType).find(SB)	
  0x40790e		488b442418		MOVQ 0x18(SP), AX			
  0x407913		4885c0			TESTQ AX, AX				
  0x407916		741f			JE 0x407937				
  0x407918		4889442428		MOVQ AX, 0x28(SP)			
		unlock(&itabLock)
  0x40791d		488d0564540d00		LEAQ runtime.itabLock(SB), AX	
  0x407924		48890424		MOVQ AX, 0(SP)			
  0x407928		e8630f0000		CALL runtime.unlock(SB)		
	if m.fun[0] != 0 {
  0x40792d		488b442428		MOVQ 0x28(SP), AX	
		goto finish
  0x407932		e9c3feffff		JMP 0x4077fa		
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
  0x407937		488b442450		MOVQ 0x50(SP), AX			
  0x40793c		488b4840		MOVQ 0x40(AX), CX			
  0x407940		48ffc9			DECQ CX					
  0x407943		48c1e103		SHLQ $0x3, CX				
  0x407947		4883c120		ADDQ $0x20, CX				
  0x40794b		48890c24		MOVQ CX, 0(SP)				
  0x40794f		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x407958		488d0da1630d00		LEAQ runtime.memstats+160(SB), CX	
  0x40795f		48894c2410		MOVQ CX, 0x10(SP)			
  0x407964		e807310000		CALL runtime.persistentalloc(SB)	
  0x407969		488b7c2418		MOVQ 0x18(SP), DI			
	m.inter = inter
  0x40796e		8407			TESTB AL, 0(DI)				
  0x407970		833da9540d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x407977		7547			JNE 0x4079c0				
  0x407979		488b442450		MOVQ 0x50(SP), AX			
  0x40797e		488907			MOVQ AX, 0(DI)				
	m._type = typ
  0x407981		488b4c2458		MOVQ 0x58(SP), CX	
  0x407986		48894f08		MOVQ CX, 0x8(DI)	
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
  0x40798a		48897c2430		MOVQ DI, 0x30(SP)	
	m.init()
  0x40798f		48893c24		MOVQ DI, 0(SP)			
  0x407993		e8b8020000		CALL runtime.(*itab).init(SB)	
	itabAdd(m)
  0x407998		488b442430		MOVQ 0x30(SP), AX		
  0x40799d		48890424		MOVQ AX, 0(SP)			
  0x4079a1		e8fa000000		CALL runtime.itabAdd(SB)	
	unlock(&itabLock)
  0x4079a6		488d05db530d00		LEAQ runtime.itabLock(SB), AX	
  0x4079ad		48890424		MOVQ AX, 0(SP)			
  0x4079b1		e8da0e0000		CALL runtime.unlock(SB)		
	if m.fun[0] != 0 {
  0x4079b6		488b442430		MOVQ 0x30(SP), AX	
finish:
  0x4079bb		e93afeffff		JMP 0x4077fa		
	m.inter = inter
  0x4079c0		488b442450		MOVQ 0x50(SP), AX		
  0x4079c5		e8b61c0400		CALL runtime.gcWriteBarrier(SB)	
	m._type = typ
  0x4079ca		488d4f08		LEAQ 0x8(DI), CX	
	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
  0x4079ce		4889fa			MOVQ DI, DX		
	m._type = typ
  0x4079d1		4889cf			MOVQ CX, DI			
  0x4079d4		488b442458		MOVQ 0x58(SP), AX		
  0x4079d9		e8a21c0400		CALL runtime.gcWriteBarrier(SB)	
	m.init()
  0x4079de		4889d7			MOVQ DX, DI		
	m.inter = inter
  0x4079e1		eba7			JMP 0x40798a		
	panic(&TypeAssertionError{concrete: typ, asserted: &inter.typ, missingMethod: m.init()})
  0x4079e3		488d0516790500		LEAQ 0x57916(IP), AX		
  0x4079ea		48890424		MOVQ AX, 0(SP)			
  0x4079ee		48894c2408		MOVQ CX, 0x8(SP)		
  0x4079f3		e8b8b40100		CALL runtime.gopanic(SB)	
  0x4079f8		0f0b			UD2				
		panic(&TypeAssertionError{nil, typ, &inter.typ, name.name()})
  0x4079fa		488d05ff780500		LEAQ 0x578ff(IP), AX		
  0x407a01		48890424		MOVQ AX, 0(SP)			
  0x407a05		48894c2408		MOVQ CX, 0x8(SP)		
  0x407a0a		e8a1b40100		CALL runtime.gopanic(SB)	
  0x407a0f		0f0b			UD2				
		throw("internal error - misuse of itab")
  0x407a11		488d059fa30600		LEAQ 0x6a39f(IP), AX	
  0x407a18		48890424		MOVQ AX, 0(SP)		
  0x407a1c		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x407a25		e856ba0100		CALL runtime.throw(SB)	
  0x407a2a		0f0b			UD2			
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
  0x407a2c		e84ffe0300		CALL runtime.morestack_noctxt(SB)	
  0x407a31		e97afcffff		JMP runtime.getitab(SB)			

TEXT runtime.(*itabTableType).find(SB) /usr/local/go/src/runtime/iface.go
	mask := t.size - 1
  0x407a40		488b442408		MOVQ 0x8(SP), AX	
  0x407a45		488b08			MOVQ 0(AX), CX		
  0x407a48		48ffc9			DECQ CX			
	h := itabHashFunc(inter, typ) & mask
  0x407a4b		90			NOPL			
	return uintptr(inter.typ.hash ^ typ.hash)
  0x407a4c		488b542410		MOVQ 0x10(SP), DX	
  0x407a51		8b5a10			MOVL 0x10(DX), BX	
  0x407a54		488b742418		MOVQ 0x18(SP), SI	
  0x407a59		335e10			XORL 0x10(SI), BX	
	h := itabHashFunc(inter, typ) & mask
  0x407a5c		4821cb			ANDQ CX, BX		
  0x407a5f		bf01000000		MOVL $0x1, DI		
	for i := uintptr(1); ; i++ {
  0x407a64		eb0d			JMP 0x407a73		
  0x407a66		4c8d4701		LEAQ 0x1(DI), R8	
		h += i
  0x407a6a		4801fb			ADDQ DI, BX		
		h &= mask
  0x407a6d		4821cb			ANDQ CX, BX		
		h += i
  0x407a70		4c89c7			MOVQ R8, DI		
		p := (**itab)(add(unsafe.Pointer(&t.entries), h*sys.PtrSize))
  0x407a73		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x407a74		4c8d04d8		LEAQ 0(AX)(BX*8), R8	
  0x407a78		4d8d4010		LEAQ 0x10(R8), R8	
		m := (*itab)(atomic.Loadp(unsafe.Pointer(p)))
  0x407a7c		4d8b00			MOVQ 0(R8), R8		
		if m == nil {
  0x407a7f		4d85c0			TESTQ R8, R8		
  0x407a82		7411			JE 0x407a95		
		if m.inter == inter && m._type == typ {
  0x407a84		493910			CMPQ DX, 0(R8)		
  0x407a87		75dd			JNE 0x407a66		
  0x407a89		49397008		CMPQ SI, 0x8(R8)	
  0x407a8d		75d7			JNE 0x407a66		
			return m
  0x407a8f		4c89442420		MOVQ R8, 0x20(SP)	
  0x407a94		c3			RET			
			return nil
  0x407a95		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x407a9e		c3			RET			

TEXT runtime.itabAdd(SB) /usr/local/go/src/runtime/iface.go
func itabAdd(m *itab) {
  0x407aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407aa9		483b6110		CMPQ 0x10(CX), SP	
  0x407aad		0f8632010000		JBE 0x407be5		
  0x407ab3		4883ec48		SUBQ $0x48, SP		
  0x407ab7		48896c2440		MOVQ BP, 0x40(SP)	
  0x407abc		488d6c2440		LEAQ 0x40(SP), BP	
	if getg().m.mallocing != 0 {
  0x407ac1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x407aca		488b4030		MOVQ 0x30(AX), AX	
  0x407ace		83b8f000000000		CMPL $0x0, 0xf0(AX)	
  0x407ad5		0f85ef000000		JNE 0x407bca		
	t := itabTable
  0x407adb		488b054e800b00		MOVQ runtime.itabTable(SB), AX	
	if t.count >= 3*(t.size/4) { // 75% load factor
  0x407ae2		488b08			MOVQ 0(AX), CX		
  0x407ae5		4889ca			MOVQ CX, DX		
  0x407ae8		48c1e902		SHRQ $0x2, CX		
  0x407aec		488d0c49		LEAQ 0(CX)(CX*2), CX	
  0x407af0		48394808		CMPQ CX, 0x8(AX)	
  0x407af4		731d			JAE 0x407b13		
	t.add(m)
  0x407af6		48890424		MOVQ AX, 0(SP)				
  0x407afa		488b442450		MOVQ 0x50(SP), AX			
  0x407aff		4889442408		MOVQ AX, 0x8(SP)			
  0x407b04		e8e7000000		CALL runtime.(*itabTableType).add(SB)	
}
  0x407b09		488b6c2440		MOVQ 0x40(SP), BP	
  0x407b0e		4883c448		ADDQ $0x48, SP		
  0x407b12		c3			RET			
	t := itabTable
  0x407b13		4889442420		MOVQ AX, 0x20(SP)	
		t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true))
  0x407b18		488d0412		LEAQ 0(DX)(DX*1), AX		
  0x407b1c		488d4002		LEAQ 0x2(AX), AX		
  0x407b20		48c1e003		SHLQ $0x3, AX			
  0x407b24		48890424		MOVQ AX, 0(SP)			
  0x407b28		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x407b31		c644241001		MOVB $0x1, 0x10(SP)		
  0x407b36		e8d5200000		CALL runtime.mallocgc(SB)	
  0x407b3b		488b442418		MOVQ 0x18(SP), AX		
  0x407b40		4889442428		MOVQ AX, 0x28(SP)		
		t2.size = t.size * 2
  0x407b45		488b4c2420		MOVQ 0x20(SP), CX	
  0x407b4a		488b11			MOVQ 0(CX), DX		
  0x407b4d		48d1e2			SHLQ $0x1, DX		
  0x407b50		488910			MOVQ DX, 0(AX)		
		iterate_itabs(t2.add)
  0x407b53		0f57c0			XORPS X0, X0					
  0x407b56		0f11442430		MOVUPS X0, 0x30(SP)				
  0x407b5b		488d156e590400		LEAQ runtime.(*itabTableType).add-fm(SB), DX	
  0x407b62		4889542430		MOVQ DX, 0x30(SP)				
  0x407b67		4889442438		MOVQ AX, 0x38(SP)				
  0x407b6c		488d542430		LEAQ 0x30(SP), DX				
  0x407b71		48891424		MOVQ DX, 0(SP)					
  0x407b75		e896080000		CALL runtime.iterate_itabs(SB)			
		if t2.count != t.count {
  0x407b7a		488b442420		MOVQ 0x20(SP), AX	
  0x407b7f		488b4008		MOVQ 0x8(AX), AX	
  0x407b83		488b4c2428		MOVQ 0x28(SP), CX	
  0x407b88		48394108		CMPQ AX, 0x8(CX)	
  0x407b8c		7521			JNE 0x407baf		
		atomicstorep(unsafe.Pointer(&itabTable), unsafe.Pointer(t2))
  0x407b8e		488d059b7f0b00		LEAQ runtime.itabTable(SB), AX	
  0x407b95		48890424		MOVQ AX, 0(SP)			
  0x407b99		48894c2408		MOVQ CX, 0x8(SP)		
  0x407b9e		e88db8ffff		CALL runtime.atomicstorep(SB)	
		t = itabTable
  0x407ba3		488b05867f0b00		MOVQ runtime.itabTable(SB), AX	
  0x407baa		e947ffffff		JMP 0x407af6			
			throw("mismatched count during itab table copy")
  0x407baf		488d055bac0600		LEAQ 0x6ac5b(IP), AX	
  0x407bb6		48890424		MOVQ AX, 0(SP)		
  0x407bba		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x407bc3		e8b8b80100		CALL runtime.throw(SB)	
  0x407bc8		0f0b			UD2			
		throw("malloc deadlock")
  0x407bca		488d05bf820600		LEAQ 0x682bf(IP), AX	
  0x407bd1		48890424		MOVQ AX, 0(SP)		
  0x407bd5		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x407bde		e89db80100		CALL runtime.throw(SB)	
  0x407be3		0f0b			UD2			
func itabAdd(m *itab) {
  0x407be5		e896fc0300		CALL runtime.morestack_noctxt(SB)	
  0x407bea		e9b1feffff		JMP runtime.itabAdd(SB)			

TEXT runtime.(*itabTableType).add(SB) /usr/local/go/src/runtime/iface.go
	h := itabHashFunc(m.inter, m._type) & mask
  0x407bf0		488b442410		MOVQ 0x10(SP), AX	
  0x407bf5		488b08			MOVQ 0(AX), CX		
  0x407bf8		488b5008		MOVQ 0x8(AX), DX	
	mask := t.size - 1
  0x407bfc		488b5c2408		MOVQ 0x8(SP), BX	
  0x407c01		488b33			MOVQ 0(BX), SI		
  0x407c04		48ffce			DECQ SI			
	h := itabHashFunc(m.inter, m._type) & mask
  0x407c07		90			NOPL			
	return uintptr(inter.typ.hash ^ typ.hash)
  0x407c08		8b4910			MOVL 0x10(CX), CX	
  0x407c0b		334a10			XORL 0x10(DX), CX	
	h := itabHashFunc(m.inter, m._type) & mask
  0x407c0e		4821f1			ANDQ SI, CX		
  0x407c11		ba01000000		MOVL $0x1, DX		
	for i := uintptr(1); ; i++ {
  0x407c16		eb0d			JMP 0x407c25		
  0x407c18		488d7a01		LEAQ 0x1(DX), DI	
		h += i
  0x407c1c		4801d1			ADDQ DX, CX		
		h &= mask
  0x407c1f		4821f1			ANDQ SI, CX		
		h += i
  0x407c22		4889fa			MOVQ DI, DX		
		p := (**itab)(add(unsafe.Pointer(&t.entries), h*sys.PtrSize))
  0x407c25		90			NOPL			
		m2 := *p
  0x407c26		488b7ccb10		MOVQ 0x10(BX)(CX*8), DI	
	return unsafe.Pointer(uintptr(p) + x)
  0x407c2b		4c8d04cb		LEAQ 0(BX)(CX*8), R8	
  0x407c2f		4d8d4010		LEAQ 0x10(R8), R8	
		if m2 == m {
  0x407c33		4839c7			CMPQ AX, DI		
  0x407c36		740d			JE 0x407c45		
		if m2 == nil {
  0x407c38		4885ff			TESTQ DI, DI		
  0x407c3b		75db			JNE 0x407c18		
			atomic.StorepNoWB(unsafe.Pointer(p), unsafe.Pointer(m))
  0x407c3d		498700			XCHGQ AX, 0(R8)		
			t.count++
  0x407c40		48ff4308		INCQ 0x8(BX)		
			return
  0x407c44		c3			RET			
			return
  0x407c45		c3			RET			

TEXT runtime.(*itab).init(SB) /usr/local/go/src/runtime/iface.go
func (m *itab) init() string {
  0x407c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x407c59		488d4424d8		LEAQ -0x28(SP), AX	
  0x407c5e		483b4110		CMPQ 0x10(CX), AX	
  0x407c62		0f8646040000		JBE 0x4080ae		
  0x407c68		4881eca8000000		SUBQ $0xa8, SP		
  0x407c6f		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x407c77		488dac24a0000000	LEAQ 0xa0(SP), BP	
	inter := m.inter
  0x407c7f		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x407c87		488b08			MOVQ 0(AX), CX		
  0x407c8a		48894c2470		MOVQ CX, 0x70(SP)	
	typ := m._type
  0x407c8f		488b5008		MOVQ 0x8(AX), DX	
  0x407c93		4889542458		MOVQ DX, 0x58(SP)	
	x := typ.uncommon()
  0x407c98		48891424		MOVQ DX, 0(SP)				
  0x407c9c		e8ff9a0300		CALL runtime.(*_type).uncommon(SB)	
  0x407ca1		488b442408		MOVQ 0x8(SP), AX			
	ni := len(inter.mhdr)
  0x407ca6		488b4c2470		MOVQ 0x70(SP), CX	
  0x407cab		488b5140		MOVQ 0x40(CX), DX	
	nt := int(x.mcount)
  0x407caf		0fb75804		MOVZX 0x4(AX), BX	
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x407cb3		90			NOPL			
  0x407cb4		8b7008			MOVL 0x8(AX), SI	
	return unsafe.Pointer(uintptr(p) + x)
  0x407cb7		4801c6			ADDQ AX, SI		
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x407cba		4885db			TESTQ BX, BX		
  0x407cbd		0f8ce4030000		JL 0x4080a7		
  0x407cc3		4881fb00000100		CMPQ $0x10000, BX	
  0x407cca		0f87d7030000		JA 0x4080a7		
	x := typ.uncommon()
  0x407cd0		4889842498000000	MOVQ AX, 0x98(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x407cd8		4889b42490000000	MOVQ SI, 0x90(SP)	
	ni := len(inter.mhdr)
  0x407ce0		4889542450		MOVQ DX, 0x50(SP)	
	nt := int(x.mcount)
  0x407ce5		48895c2448		MOVQ BX, 0x48(SP)	
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x407cea		31ff			XORL DI, DI		
  0x407cec		4531c0			XORL R8, R8		
	for k := 0; k < ni; k++ {
  0x407cef		e974010000		JMP 0x407e68		
		for ; j < nt; j++ {
  0x407cf4		4c8b442428		MOVQ 0x28(SP), R8	
  0x407cf9		498d7801		LEAQ 0x1(R8), DI	
  0x407cfd		4c8b442458		MOVQ 0x58(SP), R8	
  0x407d02		4c8b8c2490000000	MOVQ 0x90(SP), R9	
  0x407d0a		4c8b542448		MOVQ 0x48(SP), R10	
				if tname.isExported() || pkgPath == ipkg {
  0x407d0f		488b442430		MOVQ 0x30(SP), AX	
  0x407d14		488b4c2468		MOVQ 0x68(SP), CX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407d19		4c89c2			MOVQ R8, DX		
			tname := typ.nameOff(t.name)
  0x407d1c		4c89cb			MOVQ R9, BX		
		for ; j < nt; j++ {
  0x407d1f		4c89d6			MOVQ R10, SI		
  0x407d22		4839f7			CMPQ SI, DI		
  0x407d25		0f8de5020000		JGE 0x408010		
			t := &xmhdr[j]
  0x407d2b		0f8368030000		JAE 0x408099		
		for ; j < nt; j++ {
  0x407d31		48897c2428		MOVQ DI, 0x28(SP)	
			t := &xmhdr[j]
  0x407d36		48c1e704		SHLQ $0x4, DI		
  0x407d3a		48897c2440		MOVQ DI, 0x40(SP)	
			tname := typ.nameOff(t.name)
  0x407d3f		90			NOPL			
  0x407d40		8b0c3b			MOVL 0(BX)(DI*1), CX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407d43		48891424		MOVQ DX, 0(SP)			
  0x407d47		894c2408		MOVL CX, 0x8(SP)		
  0x407d4b		e8109c0300		CALL runtime.resolveNameOff(SB)	
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x407d50		90			NOPL			
  0x407d51		488b442440		MOVQ 0x40(SP), AX	
  0x407d56		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x407d5e		8b540104		MOVL 0x4(CX)(AX*1), DX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407d62		488b5c2410		MOVQ 0x10(SP), BX	
  0x407d67		48899c2480000000	MOVQ BX, 0x80(SP)	
	return resolveTypeOff(unsafe.Pointer(t), off)
  0x407d6f		488b742458		MOVQ 0x58(SP), SI		
  0x407d74		48893424		MOVQ SI, 0(SP)			
  0x407d78		89542408		MOVL DX, 0x8(SP)		
  0x407d7c		e8df9e0300		CALL runtime.resolveTypeOff(SB)	
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x407d81		488b442460		MOVQ 0x60(SP), AX	
  0x407d86		4839442410		CMPQ AX, 0x10(SP)	
  0x407d8b		0f8430020000		JE 0x407fc1		
  0x407d91		31c9			XORL CX, CX		
  0x407d93		84c9			TESTL CL, CL		
  0x407d95		0f8459ffffff		JE 0x407cf4		
				pkgPath := tname.pkgPath()
  0x407d9b		488b842480000000	MOVQ 0x80(SP), AX		
  0x407da3		48890424		MOVQ AX, 0(SP)			
  0x407da7		e884a60300		CALL runtime.name.pkgPath(SB)	
  0x407dac		488b442410		MOVQ 0x10(SP), AX		
  0x407db1		488b4c2408		MOVQ 0x8(SP), CX		
				if pkgPath == "" {
  0x407db6		4885c0			TESTQ AX, AX		
  0x407db9		0f84c8010000		JE 0x407f87		
				if tname.isExported() || pkgPath == ipkg {
  0x407dbf		90			NOPL			
	return (*n.bytes)&(1<<0) != 0
  0x407dc0		488b942480000000	MOVQ 0x80(SP), DX	
  0x407dc8		0fb612			MOVZX 0(DX), DX		
  0x407dcb		f6c201			TESTL $0x1, DL		
				if tname.isExported() || pkgPath == ipkg {
  0x407dce		0f847b010000		JE 0x407f4f		
  0x407dd4		b801000000		MOVL $0x1, AX		
  0x407dd9		84c0			TESTL AL, AL		
  0x407ddb		750a			JNE 0x407de7		
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x407ddd		488b442460		MOVQ 0x60(SP), AX	
		for ; j < nt; j++ {
  0x407de2		e90dffffff		JMP 0x407cf4		
						ifn := typ.textOff(t.ifn)
  0x407de7		488b442440		MOVQ 0x40(SP), AX			
  0x407dec		488b8c2490000000	MOVQ 0x90(SP), CX			
  0x407df4		8b440108		MOVL 0x8(CX)(AX*1), AX			
  0x407df8		488b542458		MOVQ 0x58(SP), DX			
  0x407dfd		48891424		MOVQ DX, 0(SP)				
  0x407e01		89442408		MOVL AX, 0x8(SP)			
  0x407e05		e8a6a10300		CALL runtime.(*_type).textOff(SB)	
  0x407e0a		488b442410		MOVQ 0x10(SP), AX			
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x407e0f		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x407e10		488b4c2420		MOVQ 0x20(SP), CX	
  0x407e15		488b9424b0000000	MOVQ 0xb0(SP), DX	
  0x407e1d		488d3cca		LEAQ 0(DX)(CX*8), DI	
  0x407e21		488d7f18		LEAQ 0x18(DI), DI	
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x407e25		833df44f0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x407e2c		0f8513010000		JNE 0x407f45				
  0x407e32		488944ca18		MOVQ AX, 0x18(DX)(CX*8)			
	for k := 0; k < ni; k++ {
  0x407e37		488d7901		LEAQ 0x1(CX), DI	
  0x407e3b		4c8b4c2470		MOVQ 0x70(SP), R9	
  0x407e40		4c8b542450		MOVQ 0x50(SP), R10	
  0x407e45		4c8b5c2428		MOVQ 0x28(SP), R11	
					pkgPath = typ.nameOff(x.pkgpath).name()
  0x407e4a		488b842498000000	MOVQ 0x98(SP), AX	
		i := &inter.mhdr[k]
  0x407e52		4c89c9			MOVQ R9, CX		
	for k := 0; k < ni; k++ {
  0x407e55		4c89d2			MOVQ R10, DX		
		for ; j < nt; j++ {
  0x407e58		488b5c2448		MOVQ 0x48(SP), BX	
			tname := typ.nameOff(t.name)
  0x407e5d		488bb42490000000	MOVQ 0x90(SP), SI	
		for ; j < nt; j++ {
  0x407e65		4d89d8			MOVQ R11, R8		
	for k := 0; k < ni; k++ {
  0x407e68		4839d7			CMPQ DX, DI		
  0x407e6b		0f8dfa010000		JGE 0x40806b		
		i := &inter.mhdr[k]
  0x407e71		4c8b4938		MOVQ 0x38(CX), R9	
  0x407e75		48397940		CMPQ DI, 0x40(CX)	
  0x407e79		0f8621020000		JBE 0x4080a0		
	for k := 0; k < ni; k++ {
  0x407e7f		48897c2420		MOVQ DI, 0x20(SP)	
		i := &inter.mhdr[k]
  0x407e84		4c898c2488000000	MOVQ R9, 0x88(SP)	
		for ; j < nt; j++ {
  0x407e8c		4c89442428		MOVQ R8, 0x28(SP)	
		itype := inter.typ.typeOff(i.ityp)
  0x407e91		90			NOPL			
  0x407e92		418b44f904		MOVL 0x4(R9)(DI*8), AX	
	return resolveTypeOff(unsafe.Pointer(t), off)
  0x407e97		48890c24		MOVQ CX, 0(SP)			
  0x407e9b		89442408		MOVL AX, 0x8(SP)		
  0x407e9f		e8bc9d0300		CALL runtime.resolveTypeOff(SB)	
		name := inter.typ.nameOff(i.name)
  0x407ea4		90			NOPL			
  0x407ea5		488b442420		MOVQ 0x20(SP), AX	
  0x407eaa		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x407eb2		8b0cc1			MOVL 0(CX)(AX*8), CX	
	return resolveTypeOff(unsafe.Pointer(t), off)
  0x407eb5		488b542410		MOVQ 0x10(SP), DX	
  0x407eba		4889542460		MOVQ DX, 0x60(SP)	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407ebf		488b5c2470		MOVQ 0x70(SP), BX		
  0x407ec4		48891c24		MOVQ BX, 0(SP)			
  0x407ec8		894c2408		MOVL CX, 0x8(SP)		
  0x407ecc		e88f9a0300		CALL runtime.resolveNameOff(SB)	
  0x407ed1		488b442410		MOVQ 0x10(SP), AX		
  0x407ed6		4889842480000000	MOVQ AX, 0x80(SP)		
		iname := name.name()
  0x407ede		48890424		MOVQ AX, 0(SP)			
  0x407ee2		e869a40300		CALL runtime.name.name(SB)	
  0x407ee7		488b442408		MOVQ 0x8(SP), AX		
  0x407eec		4889442478		MOVQ AX, 0x78(SP)		
  0x407ef1		488b4c2410		MOVQ 0x10(SP), CX		
  0x407ef6		48894c2438		MOVQ CX, 0x38(SP)		
		ipkg := name.pkgPath()
  0x407efb		488b942480000000	MOVQ 0x80(SP), DX		
  0x407f03		48891424		MOVQ DX, 0(SP)			
  0x407f07		e824a50300		CALL runtime.name.pkgPath(SB)	
  0x407f0c		488b442410		MOVQ 0x10(SP), AX		
  0x407f11		488b4c2408		MOVQ 0x8(SP), CX		
		if ipkg == "" {
  0x407f16		4885c0			TESTQ AX, AX		
  0x407f19		0f842b010000		JE 0x40804a		
				if tname.isExported() || pkgPath == ipkg {
  0x407f1f		4889442430		MOVQ AX, 0x30(SP)	
  0x407f24		48894c2468		MOVQ CX, 0x68(SP)	
		for ; j < nt; j++ {
  0x407f29		488b542458		MOVQ 0x58(SP), DX	
  0x407f2e		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x407f36		488b742448		MOVQ 0x48(SP), SI	
  0x407f3b		488b7c2428		MOVQ 0x28(SP), DI	
  0x407f40		e9ddfdffff		JMP 0x407d22		
						*(*unsafe.Pointer)(add(unsafe.Pointer(&m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
  0x407f45		e836170400		CALL runtime.gcWriteBarrier(SB)	
  0x407f4a		e9e8feffff		JMP 0x407e37			
				if tname.isExported() || pkgPath == ipkg {
  0x407f4f		488b542430		MOVQ 0x30(SP), DX		
  0x407f54		4839c2			CMPQ AX, DX			
  0x407f57		7407			JE 0x407f60			
  0x407f59		31c0			XORL AX, AX			
  0x407f5b		e979feffff		JMP 0x407dd9			
  0x407f60		48890c24		MOVQ CX, 0(SP)			
  0x407f64		488b4c2468		MOVQ 0x68(SP), CX		
  0x407f69		48894c2408		MOVQ CX, 0x8(SP)		
  0x407f6e		4889442410		MOVQ AX, 0x10(SP)		
  0x407f73		e8a8a2ffff		CALL runtime.memequal(SB)	
  0x407f78		0fb6442418		MOVZX 0x18(SP), AX		
  0x407f7d		488b542430		MOVQ 0x30(SP), DX		
  0x407f82		e952feffff		JMP 0x407dd9			
					pkgPath = typ.nameOff(x.pkgpath).name()
  0x407f87		90			NOPL			
  0x407f88		488b842498000000	MOVQ 0x98(SP), AX	
  0x407f90		8b08			MOVL 0(AX), CX		
	return resolveNameOff(unsafe.Pointer(t), off)
  0x407f92		488b542458		MOVQ 0x58(SP), DX		
  0x407f97		48891424		MOVQ DX, 0(SP)			
  0x407f9b		894c2408		MOVL CX, 0x8(SP)		
  0x407f9f		e8bc990300		CALL runtime.resolveNameOff(SB)	
  0x407fa4		488b442410		MOVQ 0x10(SP), AX		
					pkgPath = typ.nameOff(x.pkgpath).name()
  0x407fa9		48890424		MOVQ AX, 0(SP)			
  0x407fad		e89ea30300		CALL runtime.name.name(SB)	
  0x407fb2		488b4c2408		MOVQ 0x8(SP), CX		
  0x407fb7		488b442410		MOVQ 0x10(SP), AX		
  0x407fbc		e9fefdffff		JMP 0x407dbf			
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x407fc1		488b842480000000	MOVQ 0x80(SP), AX		
  0x407fc9		48890424		MOVQ AX, 0(SP)			
  0x407fcd		e87ea30300		CALL runtime.name.name(SB)	
  0x407fd2		488b442408		MOVQ 0x8(SP), AX		
  0x407fd7		488b4c2438		MOVQ 0x38(SP), CX		
  0x407fdc		48394c2410		CMPQ CX, 0x10(SP)		
  0x407fe1		740e			JE 0x407ff1			
  0x407fe3		31c0			XORL AX, AX			
  0x407fe5		89c1			MOVL AX, CX			
  0x407fe7		488b442460		MOVQ 0x60(SP), AX		
  0x407fec		e9a2fdffff		JMP 0x407d93			
  0x407ff1		48890424		MOVQ AX, 0(SP)			
  0x407ff5		488b442478		MOVQ 0x78(SP), AX		
  0x407ffa		4889442408		MOVQ AX, 0x8(SP)		
  0x407fff		e81ca2ffff		CALL runtime.memequal(SB)	
  0x408004		0fb6442418		MOVZX 0x18(SP), AX		
		return iname
  0x408009		488b4c2438		MOVQ 0x38(SP), CX	
			if typ.typeOff(t.mtyp) == itype && tname.name() == iname {
  0x40800e		ebd5			JMP 0x407fe5		
		m.fun[0] = 0
  0x408010		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x408018		48c7401800000000	MOVQ $0x0, 0x18(AX)	
		return iname
  0x408020		488b442478		MOVQ 0x78(SP), AX	
  0x408025		48898424b8000000	MOVQ AX, 0xb8(SP)	
  0x40802d		488b442438		MOVQ 0x38(SP), AX	
  0x408032		48898424c0000000	MOVQ AX, 0xc0(SP)	
  0x40803a		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x408042		4881c4a8000000		ADDQ $0xa8, SP		
  0x408049		c3			RET			
			ipkg = inter.pkgpath.name()
  0x40804a		488b442470		MOVQ 0x70(SP), AX		
  0x40804f		488b4830		MOVQ 0x30(AX), CX		
  0x408053		48890c24		MOVQ CX, 0(SP)			
  0x408057		e8f4a20300		CALL runtime.name.name(SB)	
  0x40805c		488b4c2408		MOVQ 0x8(SP), CX		
  0x408061		488b442410		MOVQ 0x10(SP), AX		
  0x408066		e9b4feffff		JMP 0x407f1f			
	m.hash = typ.hash
  0x40806b		488b442458		MOVQ 0x58(SP), AX	
  0x408070		8b4010			MOVL 0x10(AX), AX	
  0x408073		488b8c24b0000000	MOVQ 0xb0(SP), CX	
  0x40807b		894110			MOVL AX, 0x10(CX)	
	return ""
  0x40807e		0f57c0			XORPS X0, X0		
  0x408081		0f118424b8000000	MOVUPS X0, 0xb8(SP)	
  0x408089		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x408091		4881c4a8000000		ADDQ $0xa8, SP		
  0x408098		c3			RET			
			t := &xmhdr[j]
  0x408099		e8829e0100		CALL runtime.panicindex(SB)	
  0x40809e		0f0b			UD2				
		i := &inter.mhdr[k]
  0x4080a0		e87b9e0100		CALL runtime.panicindex(SB)	
  0x4080a5		0f0b			UD2				
	xmhdr := (*[1 << 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
  0x4080a7		e8a49f0100		CALL runtime.panicslice(SB)	
  0x4080ac		0f0b			UD2				
func (m *itab) init() string {
  0x4080ae		e8cdf70300		CALL runtime.morestack_noctxt(SB)	
  0x4080b3		e998fbffff		JMP runtime.(*itab).init(SB)		

TEXT runtime.itabsinit(SB) /usr/local/go/src/runtime/iface.go
func itabsinit() {
  0x4080c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4080c9		483b6110		CMPQ 0x10(CX), SP	
  0x4080cd		0f86cd000000		JBE 0x4081a0		
  0x4080d3		4883ec40		SUBQ $0x40, SP		
  0x4080d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4080dc		488d6c2438		LEAQ 0x38(SP), BP	
	lock(&itabLock)
  0x4080e1		488d05a04c0d00		LEAQ runtime.itabLock(SB), AX	
  0x4080e8		48890424		MOVQ AX, 0(SP)			
  0x4080ec		e8ef050000		CALL runtime.lock(SB)		
	for _, md := range activeModules() {
  0x4080f1		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x4080f2		488b057f980b00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x4080f9		4885c0			TESTQ AX, AX		
  0x4080fc		0f8495000000		JE 0x408197		
	return *p
  0x408102		488b4808		MOVQ 0x8(AX), CX	
  0x408106		488b00			MOVQ 0(AX), AX		
	for _, md := range activeModules() {
  0x408109		4889442430		MOVQ AX, 0x30(SP)	
  0x40810e		48894c2408		MOVQ CX, 0x8(SP)	
  0x408113		31d2			XORL DX, DX		
  0x408115		eb3c			JMP 0x408153		
		for _, i := range md.itablinks {
  0x408117		48897c2410		MOVQ DI, 0x10(SP)	
  0x40811c		488b04fb		MOVQ 0(BX)(DI*8), AX	
			itabAdd(i)
  0x408120		48890424		MOVQ AX, 0(SP)			
  0x408124		e877f9ffff		CALL runtime.itabAdd(SB)	
		for _, i := range md.itablinks {
  0x408129		488b442410		MOVQ 0x10(SP), AX	
  0x40812e		488d7801		LEAQ 0x1(AX), DI	
	for _, md := range activeModules() {
  0x408132		488b442430		MOVQ 0x30(SP), AX	
  0x408137		488b4c2408		MOVQ 0x8(SP), CX	
  0x40813c		488b542420		MOVQ 0x20(SP), DX	
		for _, i := range md.itablinks {
  0x408141		488b5c2428		MOVQ 0x28(SP), BX	
  0x408146		488b742418		MOVQ 0x18(SP), SI	
  0x40814b		4839f7			CMPQ SI, DI		
  0x40814e		7cc7			JL 0x408117		
	for _, md := range activeModules() {
  0x408150		48ffc2			INCQ DX			
  0x408153		4839ca			CMPQ CX, DX		
  0x408156		7d25			JGE 0x40817d		
  0x408158		4889542420		MOVQ DX, 0x20(SP)	
  0x40815d		488b1cd0		MOVQ 0(AX)(DX*8), BX	
		for _, i := range md.itablinks {
  0x408161		488bb310010000		MOVQ 0x110(BX), SI	
  0x408168		4889742418		MOVQ SI, 0x18(SP)	
  0x40816d		488b9b08010000		MOVQ 0x108(BX), BX	
  0x408174		48895c2428		MOVQ BX, 0x28(SP)	
  0x408179		31ff			XORL DI, DI		
  0x40817b		ebce			JMP 0x40814b		
	unlock(&itabLock)
  0x40817d		488d05044c0d00		LEAQ runtime.itabLock(SB), AX	
  0x408184		48890424		MOVQ AX, 0(SP)			
  0x408188		e803070000		CALL runtime.unlock(SB)		
}
  0x40818d		488b6c2438		MOVQ 0x38(SP), BP	
  0x408192		4883c440		ADDQ $0x40, SP		
  0x408196		c3			RET			
  0x408197		31c0			XORL AX, AX		
  0x408199		31c9			XORL CX, CX		
	for _, md := range activeModules() {
  0x40819b		e969ffffff		JMP 0x408109		
func itabsinit() {
  0x4081a0		e8dbf60300		CALL runtime.morestack_noctxt(SB)	
  0x4081a5		e916ffffff		JMP runtime.itabsinit(SB)		

TEXT runtime.panicdottypeI(SB) /usr/local/go/src/runtime/iface.go
func panicdottypeI(have *itab, want, iface *_type) {
  0x4081b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4081b9		483b6110		CMPQ 0x10(CX), SP	
  0x4081bd		0f86e4000000		JBE 0x4082a7		
  0x4081c3		4883ec20		SUBQ $0x20, SP		
  0x4081c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4081cc		488d6c2418		LEAQ 0x18(SP), BP	
	if have != nil {
  0x4081d1		488b442428		MOVQ 0x28(SP), AX	
  0x4081d6		4885c0			TESTQ AX, AX		
  0x4081d9		0f84aa000000		JE 0x408289		
		t = have._type
  0x4081df		488b4008		MOVQ 0x8(AX), AX	
	panicdottypeE(t, want, iface)
  0x4081e3		4889442410		MOVQ AX, 0x10(SP)	
  0x4081e8		90			NOPL			
	panic(&TypeAssertionError{iface, have, want, ""})
  0x4081e9		488d0d90e10500		LEAQ 0x5e190(IP), CX			
  0x4081f0		48890c24		MOVQ CX, 0(SP)				
  0x4081f4		e857250000		CALL runtime.newobject(SB)		
  0x4081f9		488b7c2408		MOVQ 0x8(SP), DI			
  0x4081fe		833d1b4c0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x408205		754e			JNE 0x408255				
  0x408207		488b4c2438		MOVQ 0x38(SP), CX			
  0x40820c		48890f			MOVQ CX, 0(DI)				
  0x40820f		488b4c2410		MOVQ 0x10(SP), CX			
  0x408214		48894f08		MOVQ CX, 0x8(DI)			
  0x408218		488b4c2430		MOVQ 0x30(SP), CX			
  0x40821d		48894f10		MOVQ CX, 0x10(DI)			
  0x408221		48c7472000000000	MOVQ $0x0, 0x20(DI)			
  0x408229		833df04b0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x408230		750d			JNE 0x40823f				
  0x408232		48c7471800000000	MOVQ $0x0, 0x18(DI)			
  0x40823a		4889fa			MOVQ DI, DX				
  0x40823d		eb51			JMP 0x408290				
  0x40823f		488d4f18		LEAQ 0x18(DI), CX			
  0x408243		4889f8			MOVQ DI, AX				
  0x408246		4889cf			MOVQ CX, DI				
  0x408249		4889c2			MOVQ AX, DX				
  0x40824c		31c0			XORL AX, AX				
  0x40824e		e82d140400		CALL runtime.gcWriteBarrier(SB)		
  0x408253		eb3b			JMP 0x408290				
  0x408255		488b442438		MOVQ 0x38(SP), AX			
  0x40825a		e821140400		CALL runtime.gcWriteBarrier(SB)		
  0x40825f		488d4f08		LEAQ 0x8(DI), CX			
  0x408263		4889f8			MOVQ DI, AX				
  0x408266		4889cf			MOVQ CX, DI				
  0x408269		4889c2			MOVQ AX, DX				
  0x40826c		488b442410		MOVQ 0x10(SP), AX			
  0x408271		e80a140400		CALL runtime.gcWriteBarrier(SB)		
  0x408276		488d7a10		LEAQ 0x10(DX), DI			
  0x40827a		488b442430		MOVQ 0x30(SP), AX			
  0x40827f		e8fc130400		CALL runtime.gcWriteBarrier(SB)		
  0x408284		4889d7			MOVQ DX, DI				
  0x408287		eb98			JMP 0x408221				
  0x408289		31c0			XORL AX, AX				
	if have != nil {
  0x40828b		e953ffffff		JMP 0x4081e3		
	panic(&TypeAssertionError{iface, have, want, ""})
  0x408290		488d0569700500		LEAQ 0x57069(IP), AX		
  0x408297		48890424		MOVQ AX, 0(SP)			
  0x40829b		4889542408		MOVQ DX, 0x8(SP)		
  0x4082a0		e80bac0100		CALL runtime.gopanic(SB)	
  0x4082a5		0f0b			UD2				
func panicdottypeI(have *itab, want, iface *_type) {
  0x4082a7		e8d4f50300		CALL runtime.morestack_noctxt(SB)	
  0x4082ac		e9fffeffff		JMP runtime.panicdottypeI(SB)		

TEXT runtime.convTstring(SB) /usr/local/go/src/runtime/iface.go
func convTstring(val string) (x unsafe.Pointer) {
  0x4082c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4082c9		483b6110		CMPQ 0x10(CX), SP	
  0x4082cd		767c			JBE 0x40834b		
  0x4082cf		4883ec28		SUBQ $0x28, SP		
  0x4082d3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4082d8		488d6c2420		LEAQ 0x20(SP), BP	
	if val == "" {
  0x4082dd		488b442438		MOVQ 0x38(SP), AX	
  0x4082e2		4885c0			TESTQ AX, AX		
  0x4082e5		7516			JNE 0x4082fd		
		x = unsafe.Pointer(&zeroVal[0])
  0x4082e7		488d0572550d00		LEAQ runtime.zeroVal(SB), AX	
	return
  0x4082ee		4889442440		MOVQ AX, 0x40(SP)	
  0x4082f3		488b6c2420		MOVQ 0x20(SP), BP	
  0x4082f8		4883c428		ADDQ $0x28, SP		
  0x4082fc		c3			RET			
		x = mallocgc(unsafe.Sizeof(val), stringType, true)
  0x4082fd		48c7042410000000	MOVQ $0x10, 0(SP)		
  0x408305		488b058c960b00		MOVQ runtime.stringType(SB), AX	
  0x40830c		4889442408		MOVQ AX, 0x8(SP)		
  0x408311		c644241001		MOVB $0x1, 0x10(SP)		
  0x408316		e8f5180000		CALL runtime.mallocgc(SB)	
  0x40831b		488b7c2418		MOVQ 0x18(SP), DI		
		*(*string)(x) = val
  0x408320		488b442438		MOVQ 0x38(SP), AX			
  0x408325		48894708		MOVQ AX, 0x8(DI)			
  0x408329		833df04a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x408330		750d			JNE 0x40833f				
  0x408332		488b442430		MOVQ 0x30(SP), AX			
  0x408337		488907			MOVQ AX, 0(DI)				
	return
  0x40833a		4889f8			MOVQ DI, AX		
		*(*string)(x) = val
  0x40833d		ebaf			JMP 0x4082ee			
  0x40833f		488b442430		MOVQ 0x30(SP), AX		
  0x408344		e837130400		CALL runtime.gcWriteBarrier(SB)	
  0x408349		ebef			JMP 0x40833a			
func convTstring(val string) (x unsafe.Pointer) {
  0x40834b		e830f50300		CALL runtime.morestack_noctxt(SB)	
  0x408350		e96bffffff		JMP runtime.convTstring(SB)		

TEXT runtime.assertE2I2(SB) /usr/local/go/src/runtime/iface.go
func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) {
  0x408360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408369		483b6110		CMPQ 0x10(CX), SP	
  0x40836d		0f8686000000		JBE 0x4083f9		
  0x408373		4883ec28		SUBQ $0x28, SP		
  0x408377		48896c2420		MOVQ BP, 0x20(SP)	
  0x40837c		488d6c2420		LEAQ 0x20(SP), BP	
	if t == nil {
  0x408381		488b442438		MOVQ 0x38(SP), AX	
  0x408386		4885c0			TESTQ AX, AX		
  0x408389		7457			JE 0x4083e2		
	tab := getitab(inter, t, true)
  0x40838b		488b4c2430		MOVQ 0x30(SP), CX		
  0x408390		48890c24		MOVQ CX, 0(SP)			
  0x408394		4889442408		MOVQ AX, 0x8(SP)		
  0x408399		c644241001		MOVB $0x1, 0x10(SP)		
  0x40839e		e80df3ffff		CALL runtime.getitab(SB)	
  0x4083a3		488b442418		MOVQ 0x18(SP), AX		
	if tab == nil {
  0x4083a8		4885c0			TESTQ AX, AX		
  0x4083ab		741e			JE 0x4083cb		
	return
  0x4083ad		4889442448		MOVQ AX, 0x48(SP)	
  0x4083b2		488b442440		MOVQ 0x40(SP), AX	
  0x4083b7		4889442450		MOVQ AX, 0x50(SP)	
  0x4083bc		c644245801		MOVB $0x1, 0x58(SP)	
  0x4083c1		488b6c2420		MOVQ 0x20(SP), BP	
  0x4083c6		4883c428		ADDQ $0x28, SP		
  0x4083ca		c3			RET			
		return
  0x4083cb		0f57c0			XORPS X0, X0		
  0x4083ce		0f11442448		MOVUPS X0, 0x48(SP)	
  0x4083d3		c644245800		MOVB $0x0, 0x58(SP)	
  0x4083d8		488b6c2420		MOVQ 0x20(SP), BP	
  0x4083dd		4883c428		ADDQ $0x28, SP		
  0x4083e1		c3			RET			
		return
  0x4083e2		0f57c0			XORPS X0, X0		
  0x4083e5		0f11442448		MOVUPS X0, 0x48(SP)	
  0x4083ea		c644245800		MOVB $0x0, 0x58(SP)	
  0x4083ef		488b6c2420		MOVQ 0x20(SP), BP	
  0x4083f4		4883c428		ADDQ $0x28, SP		
  0x4083f8		c3			RET			
func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) {
  0x4083f9		e882f40300		CALL runtime.morestack_noctxt(SB)	
  0x4083fe		e95dffffff		JMP runtime.assertE2I2(SB)		

TEXT runtime.iterate_itabs(SB) /usr/local/go/src/runtime/iface.go
func iterate_itabs(fn func(*itab)) {
  0x408410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408419		483b6110		CMPQ 0x10(CX), SP	
  0x40841d		765a			JBE 0x408479		
  0x40841f		4883ec20		SUBQ $0x20, SP		
  0x408423		48896c2418		MOVQ BP, 0x18(SP)	
  0x408428		488d6c2418		LEAQ 0x18(SP), BP	
	t := itabTable
  0x40842d		488b05fc760b00		MOVQ runtime.itabTable(SB), AX	
  0x408434		4889442410		MOVQ AX, 0x10(SP)		
  0x408439		31c9			XORL CX, CX			
	for i := uintptr(0); i < t.size; i++ {
  0x40843b		eb03			JMP 0x408440		
  0x40843d		48ffc1			INCQ CX			
  0x408440		483908			CMPQ CX, 0(AX)		
  0x408443		762a			JBE 0x40846f		
		m := *(**itab)(add(unsafe.Pointer(&t.entries), i*sys.PtrSize))
  0x408445		488b5cc810		MOVQ 0x10(AX)(CX*8), BX	
  0x40844a		90			NOPL			
		if m != nil {
  0x40844b		4885db			TESTQ BX, BX		
  0x40844e		74ed			JE 0x40843d		
	for i := uintptr(0); i < t.size; i++ {
  0x408450		48894c2408		MOVQ CX, 0x8(SP)	
			fn(m)
  0x408455		48891c24		MOVQ BX, 0(SP)		
  0x408459		488b542428		MOVQ 0x28(SP), DX	
  0x40845e		488b02			MOVQ 0(DX), AX		
  0x408461		ffd0			CALL AX			
	for i := uintptr(0); i < t.size; i++ {
  0x408463		488b442410		MOVQ 0x10(SP), AX	
  0x408468		488b4c2408		MOVQ 0x8(SP), CX	
			fn(m)
  0x40846d		ebce			JMP 0x40843d		
  0x40846f		488b6c2418		MOVQ 0x18(SP), BP	
  0x408474		4883c420		ADDQ $0x20, SP		
  0x408478		c3			RET			
func iterate_itabs(fn func(*itab)) {
  0x408479		e802f40300		CALL runtime.morestack_noctxt(SB)	
  0x40847e		eb90			JMP runtime.iterate_itabs(SB)		

TEXT runtime.(*lfstack).push(SB) /usr/local/go/src/runtime/lfstack.go
func (head *lfstack) push(node *lfnode) {
  0x408480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408489		483b6110		CMPQ 0x10(CX), SP	
  0x40848d		0f863f010000		JBE 0x4085d2		
  0x408493		4883ec30		SUBQ $0x30, SP		
  0x408497		48896c2428		MOVQ BP, 0x28(SP)	
  0x40849c		488d6c2428		LEAQ 0x28(SP), BP	
	node.pushcnt++
  0x4084a1		488b4c2440		MOVQ 0x40(SP), CX	
  0x4084a6		488b5108		MOVQ 0x8(CX), DX	
  0x4084aa		48ffc2			INCQ DX			
  0x4084ad		48895108		MOVQ DX, 0x8(CX)	
	new := lfstackPack(node, node.pushcnt)
  0x4084b1		90			NOPL			
	if node1 := lfstackUnpack(new); node1 != node {
  0x4084b2		90			NOPL			
	return uint64(uintptr(unsafe.Pointer(node)))<<(64-addrBits) | uint64(cnt&(1<<cntBits-1))
  0x4084b3		4889cb			MOVQ CX, BX		
  0x4084b6		48c1e110		SHLQ $0x10, CX		
  0x4084ba		4889d6			MOVQ DX, SI		
  0x4084bd		4881e2ffff0700		ANDQ $0x7ffff, DX	
  0x4084c4		4809d1			ORQ DX, CX		
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x4084c7		4889ca			MOVQ CX, DX		
  0x4084ca		48c1f913		SARQ $0x13, CX		
  0x4084ce		48c1e103		SHLQ $0x3, CX		
	if node1 := lfstackUnpack(new); node1 != node {
  0x4084d2		4839d9			CMPQ BX, CX		
  0x4084d5		7526			JNE 0x4084fd		
		old := atomic.Load64((*uint64)(head))
  0x4084d7		488b4c2438		MOVQ 0x38(SP), CX	
  0x4084dc		488b31			MOVQ 0(CX), SI		
		node.next = old
  0x4084df		488933			MOVQ SI, 0(BX)		
		if atomic.Cas64((*uint64)(head), old, new) {
  0x4084e2		4889f0			MOVQ SI, AX		
  0x4084e5		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x4084ea		400f94c6		SETE SI			
  0x4084ee		4084f6			TESTL SI, SI		
  0x4084f1		74e9			JE 0x4084dc		
  0x4084f3		488b6c2428		MOVQ 0x28(SP), BP	
  0x4084f8		4883c430		ADDQ $0x30, SP		
  0x4084fc		c3			RET			
	node.pushcnt++
  0x4084fd		4889742418		MOVQ SI, 0x18(SP)	
	return uint64(uintptr(unsafe.Pointer(node)))<<(64-addrBits) | uint64(cnt&(1<<cntBits-1))
  0x408502		4889542410		MOVQ DX, 0x10(SP)	
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x408507		48894c2420		MOVQ CX, 0x20(SP)	
		print("runtime: lfstack.push invalid packing: node=", node, " cnt=", hex(node.pushcnt), " packed=", hex(new), " -> node=", node1, "\n")
  0x40850c		e8afb90100		CALL runtime.printlock(SB)	
  0x408511		488d0517a90600		LEAQ 0x6a917(IP), AX		
  0x408518		48890424		MOVQ AX, 0(SP)			
  0x40851c		48c74424082c000000	MOVQ $0x2c, 0x8(SP)		
  0x408525		e8c6c20100		CALL runtime.printstring(SB)	
  0x40852a		488b442440		MOVQ 0x40(SP), AX		
  0x40852f		48890424		MOVQ AX, 0(SP)			
  0x408533		e878c20100		CALL runtime.printpointer(SB)	
  0x408538		488d056d6c0600		LEAQ 0x66c6d(IP), AX		
  0x40853f		48890424		MOVQ AX, 0(SP)			
  0x408543		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x40854c		e89fc20100		CALL runtime.printstring(SB)	
  0x408551		488b442418		MOVQ 0x18(SP), AX		
  0x408556		48890424		MOVQ AX, 0(SP)			
  0x40855a		e851c10100		CALL runtime.printhex(SB)	
  0x40855f		488d05b26e0600		LEAQ 0x66eb2(IP), AX		
  0x408566		48890424		MOVQ AX, 0(SP)			
  0x40856a		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x408573		e878c20100		CALL runtime.printstring(SB)	
  0x408578		488b442410		MOVQ 0x10(SP), AX		
  0x40857d		48890424		MOVQ AX, 0(SP)			
  0x408581		e82ac10100		CALL runtime.printhex(SB)	
  0x408586		488d050c6f0600		LEAQ 0x66f0c(IP), AX		
  0x40858d		48890424		MOVQ AX, 0(SP)			
  0x408591		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x40859a		e851c20100		CALL runtime.printstring(SB)	
  0x40859f		488b442420		MOVQ 0x20(SP), AX		
  0x4085a4		48890424		MOVQ AX, 0(SP)			
  0x4085a8		e803c20100		CALL runtime.printpointer(SB)	
  0x4085ad		e89ebb0100		CALL runtime.printnl(SB)	
  0x4085b2		e889b90100		CALL runtime.printunlock(SB)	
		throw("lfstack.push")
  0x4085b7		488d054f750600		LEAQ 0x6754f(IP), AX	
  0x4085be		48890424		MOVQ AX, 0(SP)		
  0x4085c2		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x4085cb		e8b0ae0100		CALL runtime.throw(SB)	
  0x4085d0		0f0b			UD2			
func (head *lfstack) push(node *lfnode) {
  0x4085d2		e8a9f20300		CALL runtime.morestack_noctxt(SB)	
  0x4085d7		e9a4feffff		JMP runtime.(*lfstack).push(SB)		

TEXT runtime.(*lfstack).pop(SB) /usr/local/go/src/runtime/lfstack.go
	for {
  0x4085e0		488b4c2408		MOVQ 0x8(SP), CX	
		old := atomic.Load64((*uint64)(head))
  0x4085e5		488b11			MOVQ 0(CX), DX		
		if old == 0 {
  0x4085e8		4885d2			TESTQ DX, DX		
  0x4085eb		7421			JE 0x40860e		
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x4085ed		4889d0			MOVQ DX, AX		
  0x4085f0		48c1fa13		SARQ $0x13, DX		
  0x4085f4		48c1e203		SHLQ $0x3, DX		
		node := lfstackUnpack(old)
  0x4085f8		90			NOPL			
		next := atomic.Load64(&node.next)
  0x4085f9		488b1a			MOVQ 0(DX), BX		
		if atomic.Cas64((*uint64)(head), old, next) {
  0x4085fc		f0480fb119		LOCK CMPXCHGQ BX, 0(CX)	
  0x408601		0f94c3			SETE BL			
  0x408604		84db			TESTL BL, BL		
  0x408606		74dd			JE 0x4085e5		
			return unsafe.Pointer(node)
  0x408608		4889542410		MOVQ DX, 0x10(SP)	
  0x40860d		c3			RET			
			return nil
  0x40860e		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x408617		c3			RET			

TEXT runtime.lfnodeValidate(SB) /usr/local/go/src/runtime/lfstack.go
func lfnodeValidate(node *lfnode) {
  0x408620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408629		483b6110		CMPQ 0x10(CX), SP	
  0x40862d		0f8699000000		JBE 0x4086cc		
  0x408633		4883ec20		SUBQ $0x20, SP		
  0x408637		48896c2418		MOVQ BP, 0x18(SP)	
  0x40863c		488d6c2418		LEAQ 0x18(SP), BP	
	if lfstackUnpack(lfstackPack(node, ^uintptr(0))) != node {
  0x408641		90			NOPL			
  0x408642		90			NOPL			
  0x408643		488b442428		MOVQ 0x28(SP), AX	
	return uint64(uintptr(unsafe.Pointer(node)))<<(64-addrBits) | uint64(cnt&(1<<cntBits-1))
  0x408648		4889c1			MOVQ AX, CX		
  0x40864b		48c1e010		SHLQ $0x10, AX		
  0x40864f		480dffff0700		ORQ $0x7ffff, AX	
		return (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))
  0x408655		48c1f813		SARQ $0x13, AX		
  0x408659		48c1e003		SHLQ $0x3, AX		
	if lfstackUnpack(lfstackPack(node, ^uintptr(0))) != node {
  0x40865d		4839c8			CMPQ CX, AX		
  0x408660		750a			JNE 0x40866c		
  0x408662		488b6c2418		MOVQ 0x18(SP), BP	
  0x408667		4883c420		ADDQ $0x20, SP		
  0x40866b		c3			RET			
		printlock()
  0x40866c		e84fb80100		CALL runtime.printlock(SB)	
		println("runtime: bad lfnode address", hex(uintptr(unsafe.Pointer(node))))
  0x408671		488b442428		MOVQ 0x28(SP), AX		
  0x408676		4889442410		MOVQ AX, 0x10(SP)		
  0x40867b		e840b80100		CALL runtime.printlock(SB)	
  0x408680		488d0547910600		LEAQ 0x69147(IP), AX		
  0x408687		48890424		MOVQ AX, 0(SP)			
  0x40868b		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x408694		e857c10100		CALL runtime.printstring(SB)	
  0x408699		488b442410		MOVQ 0x10(SP), AX		
  0x40869e		48890424		MOVQ AX, 0(SP)			
  0x4086a2		e809c00100		CALL runtime.printhex(SB)	
  0x4086a7		e8a4ba0100		CALL runtime.printnl(SB)	
  0x4086ac		e88fb80100		CALL runtime.printunlock(SB)	
		throw("bad lfnode address")
  0x4086b1		488d050e7c0600		LEAQ 0x67c0e(IP), AX	
  0x4086b8		48890424		MOVQ AX, 0(SP)		
  0x4086bc		48c744240812000000	MOVQ $0x12, 0x8(SP)	
  0x4086c5		e8b6ad0100		CALL runtime.throw(SB)	
  0x4086ca		0f0b			UD2			
func lfnodeValidate(node *lfnode) {
  0x4086cc		e8aff10300		CALL runtime.morestack_noctxt(SB)	
  0x4086d1		e94affffff		JMP runtime.lfnodeValidate(SB)		

TEXT runtime.lock(SB) /usr/local/go/src/runtime/lock_futex.go
func lock(l *mutex) {
  0x4086e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4086e9		483b6110		CMPQ 0x10(CX), SP	
  0x4086ed		0f8685010000		JBE 0x408878		
  0x4086f3		4883ec40		SUBQ $0x40, SP		
  0x4086f7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4086fc		488d6c2438		LEAQ 0x38(SP), BP	
	gp := getg()
  0x408701		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.m.locks < 0 {
  0x40870a		488b4930		MOVQ 0x30(CX), CX	
  0x40870e		8b9108010000		MOVL 0x108(CX), DX	
  0x408714		85d2			TESTL DX, DX		
  0x408716		0f8c41010000		JL 0x40885d		
	gp.m.locks++
  0x40871c		ffc2			INCL DX			
  0x40871e		899108010000		MOVL DX, 0x108(CX)	
	v := atomic.Xchg(key32(&l.key), mutex_locked)
  0x408724		90			NOPL			
  0x408725		b901000000		MOVL $0x1, CX		
  0x40872a		488b542448		MOVQ 0x48(SP), DX	
  0x40872f		870a			XCHGL CX, 0(DX)		
	if v == mutex_unlocked {
  0x408731		85c9			TESTL CX, CX		
  0x408733		0f841a010000		JE 0x408853		
	if ncpu > 1 {
  0x408739		833da4450d0001		CMPL $0x1, runtime.ncpu(SB)	
		for i := 0; i < spin; i++ {
  0x408740		bb00000000		MOVL $0x0, BX		
  0x408745		be04000000		MOVL $0x4, SI		
  0x40874a		480f4fde		CMOVG SI, BX		
  0x40874e		48895c2420		MOVQ BX, 0x20(SP)	
	if ncpu > 1 {
  0x408753		e9e6000000		JMP 0x40883e		
		for i := 0; i < spin; i++ {
  0x408758		4889f0			MOVQ SI, AX		
			for l.key == mutex_unlocked {
  0x40875b		48833a00		CMPQ $0x0, 0(DX)	
  0x40875f		751d			JNE 0x40877e		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x408761		90			NOPL			
		for i := 0; i < spin; i++ {
  0x408762		4889c6			MOVQ AX, SI		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x408765		31c0			XORL AX, AX		
  0x408767		f00fb10a		LOCK CMPXCHGL CX, 0(DX)	
  0x40876b		400f94c7		SETE DI			
  0x40876f		4084ff			TESTL DI, DI		
  0x408772		74e4			JE 0x408758		
					return
  0x408774		488b6c2438		MOVQ 0x38(SP), BP	
  0x408779		4883c440		ADDQ $0x40, SP		
  0x40877d		c3			RET			
		for i := 0; i < spin; i++ {
  0x40877e		4889442430		MOVQ AX, 0x30(SP)	
			procyield(active_spin_cnt)
  0x408783		c704241e000000		MOVL $0x1e, 0(SP)		
  0x40878a		e8f1060400		CALL runtime.procyield(SB)	
		for i := 0; i < spin; i++ {
  0x40878f		488b442430		MOVQ 0x30(SP), AX	
  0x408794		48ffc0			INCQ AX			
  0x408797		488b4c2448		MOVQ 0x48(SP), CX	
  0x40879c		8b54241c		MOVL 0x1c(SP), DX	
  0x4087a0		488b5c2420		MOVQ 0x20(SP), BX	
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4087a5		89d1			MOVL DX, CX		
			for l.key == mutex_unlocked {
  0x4087a7		488b542448		MOVQ 0x48(SP), DX	
		for i := 0; i < spin; i++ {
  0x4087ac		4839d8			CMPQ BX, AX		
  0x4087af		7caa			JL 0x40875b		
  0x4087b1		31c0			XORL AX, AX		
		for i := 0; i < passive_spin; i++ {
  0x4087b3		eb4d			JMP 0x408802		
  0x4087b5		4889f0			MOVQ SI, AX		
			for l.key == mutex_unlocked {
  0x4087b8		48833a00		CMPQ $0x0, 0(DX)	
  0x4087bc		751d			JNE 0x4087db		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4087be		90			NOPL			
		for i := 0; i < passive_spin; i++ {
  0x4087bf		4889c6			MOVQ AX, SI		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4087c2		31c0			XORL AX, AX		
  0x4087c4		f00fb10a		LOCK CMPXCHGL CX, 0(DX)	
  0x4087c8		400f94c7		SETE DI			
  0x4087cc		4084ff			TESTL DI, DI		
  0x4087cf		74e4			JE 0x4087b5		
					return
  0x4087d1		488b6c2438		MOVQ 0x38(SP), BP	
  0x4087d6		4883c440		ADDQ $0x40, SP		
  0x4087da		c3			RET			
		for i := 0; i < passive_spin; i++ {
  0x4087db		4889442428		MOVQ AX, 0x28(SP)	
			osyield()
  0x4087e0		e80b2e0400		CALL runtime.osyield(SB)	
		for i := 0; i < passive_spin; i++ {
  0x4087e5		488b442428		MOVQ 0x28(SP), AX	
  0x4087ea		48ffc0			INCQ AX			
  0x4087ed		488b4c2448		MOVQ 0x48(SP), CX	
  0x4087f2		8b54241c		MOVL 0x1c(SP), DX	
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x4087f6		89d1			MOVL DX, CX		
			for l.key == mutex_unlocked {
  0x4087f8		488b542448		MOVQ 0x48(SP), DX	
		for i := 0; i < spin; i++ {
  0x4087fd		488b5c2420		MOVQ 0x20(SP), BX	
		for i := 0; i < passive_spin; i++ {
  0x408802		4883f801		CMPQ $0x1, AX		
  0x408806		7cb0			JL 0x4087b8		
		v = atomic.Xchg(key32(&l.key), mutex_sleeping)
  0x408808		90			NOPL			
  0x408809		b802000000		MOVL $0x2, AX		
  0x40880e		8702			XCHGL AX, 0(DX)		
		if v == mutex_unlocked {
  0x408810		85c0			TESTL AX, AX		
  0x408812		7435			JE 0x408849		
		futexsleep(key32(&l.key), mutex_sleeping, -1)
  0x408814		90			NOPL				
  0x408815		48891424		MOVQ DX, 0(SP)			
  0x408819		c744240802000000	MOVL $0x2, 0x8(SP)		
  0x408821		48c7442410ffffffff	MOVQ $-0x1, 0x10(SP)		
  0x40882a		e8c18a0100		CALL runtime.futexsleep(SB)	
			for l.key == mutex_unlocked {
  0x40882f		488b542448		MOVQ 0x48(SP), DX	
		for i := 0; i < spin; i++ {
  0x408834		488b5c2420		MOVQ 0x20(SP), BX	
  0x408839		b902000000		MOVL $0x2, CX		
				if atomic.Cas(key32(&l.key), mutex_unlocked, wait) {
  0x40883e		894c241c		MOVL CX, 0x1c(SP)	
  0x408842		31c0			XORL AX, AX		
		for i := 0; i < spin; i++ {
  0x408844		e963ffffff		JMP 0x4087ac		
			return
  0x408849		488b6c2438		MOVQ 0x38(SP), BP	
  0x40884e		4883c440		ADDQ $0x40, SP		
  0x408852		c3			RET			
		return
  0x408853		488b6c2438		MOVQ 0x38(SP), BP	
  0x408858		4883c440		ADDQ $0x40, SP		
  0x40885c		c3			RET			
		throw("runtimelock: lock count")
  0x40885d		488d05af880600		LEAQ 0x688af(IP), AX	
  0x408864		48890424		MOVQ AX, 0(SP)		
  0x408868		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x408871		e80aac0100		CALL runtime.throw(SB)	
  0x408876		0f0b			UD2			
func lock(l *mutex) {
  0x408878		e803f00300		CALL runtime.morestack_noctxt(SB)	
  0x40887d		e95efeffff		JMP runtime.lock(SB)			

TEXT runtime.unlock(SB) /usr/local/go/src/runtime/lock_futex.go
func unlock(l *mutex) {
  0x408890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408899		483b6110		CMPQ 0x10(CX), SP	
  0x40889d		0f86a9000000		JBE 0x40894c		
  0x4088a3		4883ec18		SUBQ $0x18, SP		
  0x4088a7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4088ac		488d6c2410		LEAQ 0x10(SP), BP	
	v := atomic.Xchg(key32(&l.key), mutex_unlocked)
  0x4088b1		90			NOPL			
  0x4088b2		31c0			XORL AX, AX		
  0x4088b4		488b4c2420		MOVQ 0x20(SP), CX	
  0x4088b9		8701			XCHGL AX, 0(CX)		
	if v == mutex_unlocked {
  0x4088bb		85c0			TESTL AX, AX		
  0x4088bd		7472			JE 0x408931		
	if v == mutex_sleeping {
  0x4088bf		83f802			CMPL $0x2, AX		
  0x4088c2		743e			JE 0x408902		
	gp := getg()
  0x4088c4		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	gp.m.locks--
  0x4088cd		488b4830		MOVQ 0x30(AX), CX	
  0x4088d1		ff8908010000		DECL 0x108(CX)		
	if gp.m.locks < 0 {
  0x4088d7		488b4830		MOVQ 0x30(AX), CX	
  0x4088db		8b8908010000		MOVL 0x108(CX), CX	
  0x4088e1		85c9			TESTL CX, CX		
  0x4088e3		7c31			JL 0x408916		
	if gp.m.locks == 0 && gp.preempt { // restore the preemption request in case we've cleared it in newstack
  0x4088e5		7511			JNE 0x4088f8		
  0x4088e7		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x4088ee		7408			JE 0x4088f8		
		gp.stackguard0 = stackPreempt
  0x4088f0		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x4088f8		488b6c2410		MOVQ 0x10(SP), BP	
  0x4088fd		4883c418		ADDQ $0x18, SP		
  0x408901		c3			RET			
		futexwakeup(key32(&l.key), 1)
  0x408902		90			NOPL				
  0x408903		48890c24		MOVQ CX, 0(SP)			
  0x408907		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x40890f		e8ac8a0100		CALL runtime.futexwakeup(SB)	
  0x408914		ebae			JMP 0x4088c4			
		throw("runtimeunlock: lock count")
  0x408916		488d05e08b0600		LEAQ 0x68be0(IP), AX	
  0x40891d		48890424		MOVQ AX, 0(SP)		
  0x408921		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x40892a		e851ab0100		CALL runtime.throw(SB)	
  0x40892f		0f0b			UD2			
		throw("unlock of unlocked lock")
  0x408931		488d059c840600		LEAQ 0x6849c(IP), AX	
  0x408938		48890424		MOVQ AX, 0(SP)		
  0x40893c		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x408945		e836ab0100		CALL runtime.throw(SB)	
  0x40894a		0f0b			UD2			
func unlock(l *mutex) {
  0x40894c		e82fef0300		CALL runtime.morestack_noctxt(SB)	
  0x408951		e93affffff		JMP runtime.unlock(SB)			

TEXT runtime.notewakeup(SB) /usr/local/go/src/runtime/lock_futex.go
func notewakeup(n *note) {
  0x408960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408969		483b6110		CMPQ 0x10(CX), SP	
  0x40896d		0f86a5000000		JBE 0x408a18		
  0x408973		4883ec20		SUBQ $0x20, SP		
  0x408977		48896c2418		MOVQ BP, 0x18(SP)	
  0x40897c		488d6c2418		LEAQ 0x18(SP), BP	
	old := atomic.Xchg(key32(&n.key), 1)
  0x408981		90			NOPL			
  0x408982		b801000000		MOVL $0x1, AX		
  0x408987		488b4c2428		MOVQ 0x28(SP), CX	
  0x40898c		8701			XCHGL AX, 0(CX)		
	if old != 0 {
  0x40898e		85c0			TESTL AX, AX		
  0x408990		751c			JNE 0x4089ae		
	futexwakeup(key32(&n.key), 1)
  0x408992		90			NOPL				
  0x408993		48890c24		MOVQ CX, 0(SP)			
  0x408997		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x40899f		e81c8a0100		CALL runtime.futexwakeup(SB)	
}
  0x4089a4		488b6c2418		MOVQ 0x18(SP), BP	
  0x4089a9		4883c420		ADDQ $0x20, SP		
  0x4089ad		c3			RET			
	old := atomic.Xchg(key32(&n.key), 1)
  0x4089ae		89442414		MOVL AX, 0x14(SP)	
		print("notewakeup - double wakeup (", old, ")\n")
  0x4089b2		e809b50100		CALL runtime.printlock(SB)	
  0x4089b7		488d05d88d0600		LEAQ 0x68dd8(IP), AX		
  0x4089be		48890424		MOVQ AX, 0(SP)			
  0x4089c2		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x4089cb		e820be0100		CALL runtime.printstring(SB)	
  0x4089d0		8b442414		MOVL 0x14(SP), AX		
  0x4089d4		89c0			MOVL AX, AX			
  0x4089d6		48890424		MOVQ AX, 0(SP)			
  0x4089da		e861bb0100		CALL runtime.printuint(SB)	
  0x4089df		488d05b4660600		LEAQ 0x666b4(IP), AX		
  0x4089e6		48890424		MOVQ AX, 0(SP)			
  0x4089ea		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4089f3		e8f8bd0100		CALL runtime.printstring(SB)	
  0x4089f8		e843b50100		CALL runtime.printunlock(SB)	
		throw("notewakeup - double wakeup")
  0x4089fd		488d0576880600		LEAQ 0x68876(IP), AX	
  0x408a04		48890424		MOVQ AX, 0(SP)		
  0x408a08		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x408a11		e86aaa0100		CALL runtime.throw(SB)	
  0x408a16		0f0b			UD2			
func notewakeup(n *note) {
  0x408a18		e863ee0300		CALL runtime.morestack_noctxt(SB)	
  0x408a1d		e93effffff		JMP runtime.notewakeup(SB)		

TEXT runtime.notesleep(SB) /usr/local/go/src/runtime/lock_futex.go
func notesleep(n *note) {
  0x408a30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408a39		483b6110		CMPQ 0x10(CX), SP	
  0x408a3d		0f86d6000000		JBE 0x408b19		
  0x408a43		4883ec30		SUBQ $0x30, SP		
  0x408a47		48896c2428		MOVQ BP, 0x28(SP)	
  0x408a4c		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x408a51		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.g0 {
  0x408a5a		488b4830		MOVQ 0x30(AX), CX	
  0x408a5e		483901			CMPQ AX, 0(CX)		
  0x408a61		0f8597000000		JNE 0x408afe		
	gp := getg()
  0x408a67		4889442420		MOVQ AX, 0x20(SP)	
	if *cgo_yield != nil {
  0x408a6c		488b0db5700b00		MOVQ runtime.cgo_yield(SB), CX	
  0x408a73		48833900		CMPQ $0x0, 0(CX)		
		futexsleep(key32(&n.key), 0, ns)
  0x408a77		48c7c1ffffffff		MOVQ $-0x1, CX		
  0x408a7e		ba80969800		MOVL $0x989680, DX	
  0x408a83		480f45ca		CMOVNE DX, CX		
  0x408a87		48894c2418		MOVQ CX, 0x18(SP)	
	if *cgo_yield != nil {
  0x408a8c		eb15			JMP 0x408aa3		
		gp.m.blocked = false
  0x408a8e		488b442420		MOVQ 0x20(SP), AX	
  0x408a93		488b5030		MOVQ 0x30(AX), DX	
  0x408a97		c6821501000000		MOVB $0x0, 0x115(DX)	
		futexsleep(key32(&n.key), 0, ns)
  0x408a9e		488b4c2418		MOVQ 0x18(SP), CX	
	for atomic.Load(key32(&n.key)) == 0 {
  0x408aa3		90			NOPL			
  0x408aa4		488b542438		MOVQ 0x38(SP), DX	
  0x408aa9		8b1a			MOVL 0(DX), BX		
  0x408aab		85db			TESTL BX, BX		
  0x408aad		7545			JNE 0x408af4		
		gp.m.blocked = true
  0x408aaf		488b5830		MOVQ 0x30(AX), BX	
  0x408ab3		c6831501000001		MOVB $0x1, 0x115(BX)	
		futexsleep(key32(&n.key), 0, ns)
  0x408aba		90			NOPL				
  0x408abb		48891424		MOVQ DX, 0(SP)			
  0x408abf		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x408ac7		48894c2410		MOVQ CX, 0x10(SP)		
  0x408acc		e81f880100		CALL runtime.futexsleep(SB)	
		if *cgo_yield != nil {
  0x408ad1		488b0550700b00		MOVQ runtime.cgo_yield(SB), AX	
  0x408ad8		488b00			MOVQ 0(AX), AX			
  0x408adb		4885c0			TESTQ AX, AX			
  0x408ade		74ae			JE 0x408a8e			
			asmcgocall(*cgo_yield, nil)
  0x408ae0		48890424		MOVQ AX, 0(SP)			
  0x408ae4		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x408aed		e80e040400		CALL runtime.asmcgocall(SB)	
  0x408af2		eb9a			JMP 0x408a8e			
  0x408af4		488b6c2428		MOVQ 0x28(SP), BP		
  0x408af9		4883c430		ADDQ $0x30, SP			
  0x408afd		c3			RET				
		throw("notesleep not on g0")
  0x408afe		488d0536790600		LEAQ 0x67936(IP), AX	
  0x408b05		48890424		MOVQ AX, 0(SP)		
  0x408b09		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x408b12		e869a90100		CALL runtime.throw(SB)	
  0x408b17		0f0b			UD2			
func notesleep(n *note) {
  0x408b19		e862ed0300		CALL runtime.morestack_noctxt(SB)	
  0x408b1e		e90dffffff		JMP runtime.notesleep(SB)		

TEXT runtime.notetsleep_internal(SB) /usr/local/go/src/runtime/lock_futex.go
func notetsleep_internal(n *note, ns int64) bool {
  0x408b30		4883ec30		SUBQ $0x30, SP		
  0x408b34		48896c2428		MOVQ BP, 0x28(SP)	
  0x408b39		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x408b3e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x408b47		4889442420		MOVQ AX, 0x20(SP)	
	if ns < 0 {
  0x408b4c		488b4c2440		MOVQ 0x40(SP), CX	
  0x408b51		4885c9			TESTQ CX, CX		
  0x408b54		0f8d90000000		JGE 0x408bea		
		if *cgo_yield != nil {
  0x408b5a		488b15c76f0b00		MOVQ runtime.cgo_yield(SB), DX	
  0x408b61		48833a00		CMPQ $0x0, 0(DX)		
			futexsleep(key32(&n.key), 0, ns)
  0x408b65		ba80969800		MOVL $0x989680, DX	
  0x408b6a		480f45ca		CMOVNE DX, CX		
  0x408b6e		48894c2440		MOVQ CX, 0x40(SP)	
		if *cgo_yield != nil {
  0x408b73		eb15			JMP 0x408b8a		
			gp.m.blocked = false
  0x408b75		488b442420		MOVQ 0x20(SP), AX	
  0x408b7a		488b5030		MOVQ 0x30(AX), DX	
  0x408b7e		c6821501000000		MOVB $0x0, 0x115(DX)	
			futexsleep(key32(&n.key), 0, ns)
  0x408b85		488b4c2440		MOVQ 0x40(SP), CX	
		for atomic.Load(key32(&n.key)) == 0 {
  0x408b8a		90			NOPL			
  0x408b8b		488b542438		MOVQ 0x38(SP), DX	
  0x408b90		8b1a			MOVL 0(DX), BX		
  0x408b92		85db			TESTL BX, BX		
  0x408b94		7545			JNE 0x408bdb		
			gp.m.blocked = true
  0x408b96		488b5830		MOVQ 0x30(AX), BX	
  0x408b9a		c6831501000001		MOVB $0x1, 0x115(BX)	
			futexsleep(key32(&n.key), 0, ns)
  0x408ba1		90			NOPL				
  0x408ba2		48891424		MOVQ DX, 0(SP)			
  0x408ba6		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x408bae		48894c2410		MOVQ CX, 0x10(SP)		
  0x408bb3		e838870100		CALL runtime.futexsleep(SB)	
			if *cgo_yield != nil {
  0x408bb8		488b05696f0b00		MOVQ runtime.cgo_yield(SB), AX	
  0x408bbf		488b00			MOVQ 0(AX), AX			
  0x408bc2		4885c0			TESTQ AX, AX			
  0x408bc5		74ae			JE 0x408b75			
				asmcgocall(*cgo_yield, nil)
  0x408bc7		48890424		MOVQ AX, 0(SP)			
  0x408bcb		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x408bd4		e827030400		CALL runtime.asmcgocall(SB)	
  0x408bd9		eb9a			JMP 0x408b75			
		return true
  0x408bdb		c644244801		MOVB $0x1, 0x48(SP)	
  0x408be0		488b6c2428		MOVQ 0x28(SP), BP	
  0x408be5		4883c430		ADDQ $0x30, SP		
  0x408be9		c3			RET			
	if atomic.Load(key32(&n.key)) != 0 {
  0x408bea		90			NOPL			
  0x408beb		488b542438		MOVQ 0x38(SP), DX	
  0x408bf0		8b1a			MOVL 0(DX), BX		
  0x408bf2		85db			TESTL BX, BX		
  0x408bf4		0f85d7000000		JNE 0x408cd1		
	deadline := nanotime() + ns
  0x408bfa		e8b1240400		CALL runtime.nanotime(SB)	
  0x408bff		488b0424		MOVQ 0(SP), AX			
  0x408c03		488b4c2440		MOVQ 0x40(SP), CX		
  0x408c08		4801c8			ADDQ CX, AX			
  0x408c0b		4889442418		MOVQ AX, 0x18(SP)		
	for {
  0x408c10		eb09			JMP 0x408c1b		
		ns = deadline - now
  0x408c12		4889ca			MOVQ CX, DX		
  0x408c15		4829c1			SUBQ AX, CX		
		if now >= deadline {
  0x408c18		4889d0			MOVQ DX, AX		
		if *cgo_yield != nil && ns > 10e6 {
  0x408c1b		488b15066f0b00		MOVQ runtime.cgo_yield(SB), DX	
  0x408c22		48833a00		CMPQ $0x0, 0(DX)		
  0x408c26		740e			JE 0x408c36			
  0x408c28		4881f980969800		CMPQ $0x989680, CX		
  0x408c2f		7e05			JLE 0x408c36			
  0x408c31		b980969800		MOVL $0x989680, CX		
		gp.m.blocked = true
  0x408c36		488b442420		MOVQ 0x20(SP), AX	
  0x408c3b		488b5030		MOVQ 0x30(AX), DX	
  0x408c3f		c6821501000001		MOVB $0x1, 0x115(DX)	
		futexsleep(key32(&n.key), 0, ns)
  0x408c46		90			NOPL				
  0x408c47		488b542438		MOVQ 0x38(SP), DX		
  0x408c4c		48891424		MOVQ DX, 0(SP)			
  0x408c50		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x408c58		48894c2410		MOVQ CX, 0x10(SP)		
  0x408c5d		e88e860100		CALL runtime.futexsleep(SB)	
		if *cgo_yield != nil {
  0x408c62		488b05bf6e0b00		MOVQ runtime.cgo_yield(SB), AX	
  0x408c69		488b00			MOVQ 0(AX), AX			
  0x408c6c		4885c0			TESTQ AX, AX			
  0x408c6f		754c			JNE 0x408cbd			
		gp.m.blocked = false
  0x408c71		488b442420		MOVQ 0x20(SP), AX	
  0x408c76		488b4830		MOVQ 0x30(AX), CX	
  0x408c7a		c6811501000000		MOVB $0x0, 0x115(CX)	
		if atomic.Load(key32(&n.key)) != 0 {
  0x408c81		90			NOPL			
  0x408c82		488b4c2438		MOVQ 0x38(SP), CX	
  0x408c87		8b11			MOVL 0(CX), DX		
  0x408c89		85d2			TESTL DX, DX		
  0x408c8b		7517			JNE 0x408ca4		
		now := nanotime()
  0x408c8d		e81e240400		CALL runtime.nanotime(SB)	
  0x408c92		488b0424		MOVQ 0(SP), AX			
		if now >= deadline {
  0x408c96		488b4c2418		MOVQ 0x18(SP), CX	
  0x408c9b		4839c8			CMPQ CX, AX		
  0x408c9e		0f8c6effffff		JL 0x408c12		
	return atomic.Load(key32(&n.key)) != 0
  0x408ca4		90			NOPL			
  0x408ca5		488b442438		MOVQ 0x38(SP), AX	
  0x408caa		8b00			MOVL 0(AX), AX		
  0x408cac		85c0			TESTL AX, AX		
  0x408cae		0f95442448		SETNE 0x48(SP)		
  0x408cb3		488b6c2428		MOVQ 0x28(SP), BP	
  0x408cb8		4883c430		ADDQ $0x30, SP		
  0x408cbc		c3			RET			
			asmcgocall(*cgo_yield, nil)
  0x408cbd		48890424		MOVQ AX, 0(SP)			
  0x408cc1		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x408cca		e831020400		CALL runtime.asmcgocall(SB)	
  0x408ccf		eba0			JMP 0x408c71			
		return true
  0x408cd1		c644244801		MOVB $0x1, 0x48(SP)	
  0x408cd6		488b6c2428		MOVQ 0x28(SP), BP	
  0x408cdb		4883c430		ADDQ $0x30, SP		
  0x408cdf		c3			RET			

TEXT runtime.notetsleep(SB) /usr/local/go/src/runtime/lock_futex.go
func notetsleep(n *note, ns int64) bool {
  0x408ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408ce9		483b6110		CMPQ 0x10(CX), SP	
  0x408ced		7670			JBE 0x408d5f		
  0x408cef		4883ec20		SUBQ $0x20, SP		
  0x408cf3		48896c2418		MOVQ BP, 0x18(SP)	
  0x408cf8		488d6c2418		LEAQ 0x18(SP), BP	
	gp := getg()
  0x408cfd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.g0 && gp.m.preemptoff != "" {
  0x408d06		488b4830		MOVQ 0x30(AX), CX	
  0x408d0a		483901			CMPQ AX, 0(CX)		
  0x408d0d		740a			JE 0x408d19		
  0x408d0f		4883b90001000000	CMPQ $0x0, 0x100(CX)	
  0x408d17		752b			JNE 0x408d44		
	return notetsleep_internal(n, ns)
  0x408d19		488b442428		MOVQ 0x28(SP), AX			
  0x408d1e		48890424		MOVQ AX, 0(SP)				
  0x408d22		488b442430		MOVQ 0x30(SP), AX			
  0x408d27		4889442408		MOVQ AX, 0x8(SP)			
  0x408d2c		e8fffdffff		CALL runtime.notetsleep_internal(SB)	
  0x408d31		0fb6442410		MOVZX 0x10(SP), AX			
  0x408d36		88442438		MOVB AL, 0x38(SP)			
  0x408d3a		488b6c2418		MOVQ 0x18(SP), BP			
  0x408d3f		4883c420		ADDQ $0x20, SP				
  0x408d43		c3			RET					
		throw("notetsleep not on g0")
  0x408d44		488d058a790600		LEAQ 0x6798a(IP), AX	
  0x408d4b		48890424		MOVQ AX, 0(SP)		
  0x408d4f		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x408d58		e823a70100		CALL runtime.throw(SB)	
  0x408d5d		0f0b			UD2			
func notetsleep(n *note, ns int64) bool {
  0x408d5f		e81ceb0300		CALL runtime.morestack_noctxt(SB)	
  0x408d64		e977ffffff		JMP runtime.notetsleep(SB)		

TEXT runtime.notetsleepg(SB) /usr/local/go/src/runtime/lock_futex.go
func notetsleepg(n *note, ns int64) bool {
  0x408d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408d79		483b6110		CMPQ 0x10(CX), SP	
  0x408d7d		7679			JBE 0x408df8		
  0x408d7f		4883ec28		SUBQ $0x28, SP		
  0x408d83		48896c2420		MOVQ BP, 0x20(SP)	
  0x408d88		488d6c2420		LEAQ 0x20(SP), BP	
	gp := getg()
  0x408d8d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == gp.m.g0 {
  0x408d96		488b4830		MOVQ 0x30(AX), CX	
  0x408d9a		483901			CMPQ AX, 0(CX)		
  0x408d9d		743e			JE 0x408ddd		
	entersyscallblock()
  0x408d9f		e8bc2d0200		CALL runtime.entersyscallblock(SB)	
	ok := notetsleep_internal(n, ns)
  0x408da4		488b442430		MOVQ 0x30(SP), AX			
  0x408da9		48890424		MOVQ AX, 0(SP)				
  0x408dad		488b442438		MOVQ 0x38(SP), AX			
  0x408db2		4889442408		MOVQ AX, 0x8(SP)			
  0x408db7		e874fdffff		CALL runtime.notetsleep_internal(SB)	
  0x408dbc		0fb6442410		MOVZX 0x10(SP), AX			
  0x408dc1		8844241f		MOVB AL, 0x1f(SP)			
	exitsyscall()
  0x408dc5		e8d62f0200		CALL runtime.exitsyscall(SB)	
	return ok
  0x408dca		0fb644241f		MOVZX 0x1f(SP), AX	
  0x408dcf		88442440		MOVB AL, 0x40(SP)	
  0x408dd3		488b6c2420		MOVQ 0x20(SP), BP	
  0x408dd8		4883c428		ADDQ $0x28, SP		
  0x408ddc		c3			RET			
		throw("notetsleepg on g0")
  0x408ddd		488d05e0730600		LEAQ 0x673e0(IP), AX	
  0x408de4		48890424		MOVQ AX, 0(SP)		
  0x408de8		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x408df1		e88aa60100		CALL runtime.throw(SB)	
  0x408df6		0f0b			UD2			
func notetsleepg(n *note, ns int64) bool {
  0x408df8		e883ea0300		CALL runtime.morestack_noctxt(SB)	
  0x408dfd		e96effffff		JMP runtime.notetsleepg(SB)		

TEXT runtime.mallocinit(SB) /usr/local/go/src/runtime/malloc.go
func mallocinit() {
  0x408e10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x408e19		483b6110		CMPQ 0x10(CX), SP	
  0x408e1d		0f8633020000		JBE 0x409056		
  0x408e23		4883ec28		SUBQ $0x28, SP		
  0x408e27		48896c2420		MOVQ BP, 0x20(SP)	
  0x408e2c		488d6c2420		LEAQ 0x20(SP), BP	
	if class_to_size[_TinySizeClass] != _TinySize {
  0x408e31		66833dab630b0010	CMPW $0x10, runtime.class_to_size+4(SB)	
  0x408e39		0f85fc010000		JNE 0x40903b				
	testdefersizes()
  0x408e3f		e81c950100		CALL runtime.testdefersizes(SB)	
  0x408e44		31c0			XORL AX, AX			
	for i := range class_to_size {
  0x408e46		eb1c			JMP 0x408e64		
		memstats.by_size[i].size = uint32(class_to_size[i])
  0x408e48		488d0c40		LEAQ 0(AX)(AX*2), CX			
  0x408e4c		488d158d630b00		LEAQ runtime.class_to_size(SB), DX	
  0x408e53		0fb71c42		MOVZX 0(DX)(AX*2), BX			
  0x408e57		488d35da5e0d00		LEAQ runtime.memstats+4312(SB), SI	
  0x408e5e		891cce			MOVL BX, 0(SI)(CX*8)			
	for i := range class_to_size {
  0x408e61		48ffc0			INCQ AX			
  0x408e64		4883f843		CMPQ $0x43, AX		
  0x408e68		7cde			JL 0x408e48		
	if physPageSize == 0 {
  0x408e6a		488b05373f0d00		MOVQ runtime.physPageSize(SB), AX	
  0x408e71		4885c0			TESTQ AX, AX				
  0x408e74		0f84a6010000		JE 0x409020				
	if physPageSize < minPhysPageSize {
  0x408e7a		483d00100000		CMPQ $0x1000, AX	
  0x408e80		0f820d010000		JB 0x408f93		
	if physPageSize&(physPageSize-1) != 0 {
  0x408e86		488d48ff		LEAQ -0x1(AX), CX	
  0x408e8a		4885c8			TESTQ CX, AX		
  0x408e8d		0f8599000000		JNE 0x408f2c		
	mheap_.init()
  0x408e93		488d05a6d70b00		LEAQ runtime.mheap_(SB), AX	
  0x408e9a		48890424		MOVQ AX, 0(SP)			
  0x408e9e		e8ed380100		CALL runtime.(*mheap).init(SB)	
	_g_ := getg()
  0x408ea3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x408eac		4889442418		MOVQ AX, 0x18(SP)	
	_g_.m.mcache = allocmcache()
  0x408eb1		e85a780000		CALL runtime.allocmcache(SB)	
  0x408eb6		488b442418		MOVQ 0x18(SP), AX		
  0x408ebb		488b4030		MOVQ 0x30(AX), AX		
  0x408ebf		488b0c24		MOVQ 0(SP), CX			
  0x408ec3		48898860010000		MOVQ CX, 0x160(AX)		
  0x408eca		b87f000000		MOVL $0x7f, AX			
		for i := 0x7f; i >= 0; i-- {
  0x408ecf		eb4c			JMP 0x408f1d		
  0x408ed1		4889442410		MOVQ AX, 0x10(SP)	
			hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())
  0x408ed6		488d05d3fd0b00		LEAQ runtime.mheap_+9840(SB), AX	
  0x408edd		48890424		MOVQ AX, 0(SP)				
  0x408ee1		e8aa8c0000		CALL runtime.(*fixalloc).alloc(SB)	
  0x408ee6		488b442408		MOVQ 0x8(SP), AX			
				p = uintptr(i)<<40 | uintptrMask&(0x00c0<<32)
  0x408eeb		488b4c2410		MOVQ 0x10(SP), CX	
  0x408ef0		4889ca			MOVQ CX, DX		
  0x408ef3		48c1e128		SHLQ $0x28, CX		
  0x408ef7		48bb00000000c0000000	MOVQ $0xc000000000, BX	
  0x408f01		4809d9			ORQ BX, CX		
			hint.addr = p
  0x408f04		488908			MOVQ CX, 0(AX)		
			hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
  0x408f07		488b0d62da0b00		MOVQ runtime.mheap_+816(SB), CX	
  0x408f0e		48894810		MOVQ CX, 0x10(AX)		
  0x408f12		48890557da0b00		MOVQ AX, runtime.mheap_+816(SB)	
		for i := 0x7f; i >= 0; i-- {
  0x408f19		488d42ff		LEAQ -0x1(DX), AX	
  0x408f1d		4885c0			TESTQ AX, AX		
  0x408f20		7daf			JGE 0x408ed1		
  0x408f22		488b6c2420		MOVQ 0x20(SP), BP	
  0x408f27		4883c428		ADDQ $0x28, SP		
  0x408f2b		c3			RET			
		print("system page size (", physPageSize, ") must be a power of 2\n")
  0x408f2c		e88faf0100		CALL runtime.printlock(SB)		
  0x408f31		488d05e8730600		LEAQ 0x673e8(IP), AX			
  0x408f38		48890424		MOVQ AX, 0(SP)				
  0x408f3c		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x408f45		e8a6b80100		CALL runtime.printstring(SB)		
  0x408f4a		488b05573e0d00		MOVQ runtime.physPageSize(SB), AX	
  0x408f51		48890424		MOVQ AX, 0(SP)				
  0x408f55		e8e6b50100		CALL runtime.printuint(SB)		
  0x408f5a		488d05067c0600		LEAQ 0x67c06(IP), AX			
  0x408f61		48890424		MOVQ AX, 0(SP)				
  0x408f65		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x408f6e		e87db80100		CALL runtime.printstring(SB)		
  0x408f73		e8c8af0100		CALL runtime.printunlock(SB)		
		throw("bad system page size")
  0x408f78		488d0552760600		LEAQ 0x67652(IP), AX	
  0x408f7f		48890424		MOVQ AX, 0(SP)		
  0x408f83		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x408f8c		e8efa40100		CALL runtime.throw(SB)	
  0x408f91		0f0b			UD2			
		print("system page size (", physPageSize, ") is smaller than minimum page size (", minPhysPageSize, ")\n")
  0x408f93		e828af0100		CALL runtime.printlock(SB)		
  0x408f98		488d0581730600		LEAQ 0x67381(IP), AX			
  0x408f9f		48890424		MOVQ AX, 0(SP)				
  0x408fa3		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x408fac		e83fb80100		CALL runtime.printstring(SB)		
  0x408fb1		488b05f03d0d00		MOVQ runtime.physPageSize(SB), AX	
  0x408fb8		48890424		MOVQ AX, 0(SP)				
  0x408fbc		e87fb50100		CALL runtime.printuint(SB)		
  0x408fc1		488d0587960600		LEAQ 0x69687(IP), AX			
  0x408fc8		48890424		MOVQ AX, 0(SP)				
  0x408fcc		48c744240825000000	MOVQ $0x25, 0x8(SP)			
  0x408fd5		e816b80100		CALL runtime.printstring(SB)		
  0x408fda		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x408fe2		e859b60100		CALL runtime.printint(SB)		
  0x408fe7		488d05ac600600		LEAQ 0x660ac(IP), AX			
  0x408fee		48890424		MOVQ AX, 0(SP)				
  0x408ff2		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x408ffb		e8f0b70100		CALL runtime.printstring(SB)		
  0x409000		e83baf0100		CALL runtime.printunlock(SB)		
		throw("bad system page size")
  0x409005		488d05c5750600		LEAQ 0x675c5(IP), AX	
  0x40900c		48890424		MOVQ AX, 0(SP)		
  0x409010		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x409019		e862a40100		CALL runtime.throw(SB)	
  0x40901e		0f0b			UD2			
		throw("failed to get system page size")
  0x409020		488d056b8b0600		LEAQ 0x68b6b(IP), AX	
  0x409027		48890424		MOVQ AX, 0(SP)		
  0x40902b		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x409034		e847a40100		CALL runtime.throw(SB)	
  0x409039		0f0b			UD2			
		throw("bad TinySizeClass")
  0x40903b		488d051c710600		LEAQ 0x6711c(IP), AX	
  0x409042		48890424		MOVQ AX, 0(SP)		
  0x409046		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x40904f		e82ca40100		CALL runtime.throw(SB)	
  0x409054		0f0b			UD2			
func mallocinit() {
  0x409056		e825e80300		CALL runtime.morestack_noctxt(SB)	
  0x40905b		e9b0fdffff		JMP runtime.mallocinit(SB)		

TEXT runtime.(*mheap).sysAlloc(SB) /usr/local/go/src/runtime/malloc.go
func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {
  0x409060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409069		488d4424e0		LEAQ -0x20(SP), AX	
  0x40906e		483b4110		CMPQ 0x10(CX), AX	
  0x409072		0f86e6070000		JBE 0x40985e		
  0x409078		4881eca0000000		SUBQ $0xa0, SP		
  0x40907f		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x409087		488dac2498000000	LEAQ 0x98(SP), BP	
	v = h.arena.alloc(n, heapArenaBytes, &memstats.heap_sys)
  0x40908f		488b8424a8000000	MOVQ 0xa8(SP), AX	
  0x409097		8400			TESTB AL, 0(AX)		
	n = round(n, heapArenaBytes)
  0x409099		90			NOPL			
	v = h.arena.alloc(n, heapArenaBytes, &memstats.heap_sys)
  0x40909a		488d8838030000		LEAQ 0x338(AX), CX	
  0x4090a1		48890c24		MOVQ CX, 0(SP)		
	return (n + a - 1) &^ (a - 1)
  0x4090a5		488b8c24b0000000	MOVQ 0xb0(SP), CX	
  0x4090ad		4881c1ffffff03		ADDQ $0x3ffffff, CX	
  0x4090b4		4881e1000000fc		ANDQ $-0x4000000, CX	
  0x4090bb		48894c2448		MOVQ CX, 0x48(SP)	
	v = h.arena.alloc(n, heapArenaBytes, &memstats.heap_sys)
  0x4090c0		48894c2408		MOVQ CX, 0x8(SP)			
  0x4090c5		48c744241000000004	MOVQ $0x4000000, 0x10(SP)		
  0x4090ce		488d15c34b0d00		LEAQ runtime.memstats+56(SB), DX	
  0x4090d5		4889542418		MOVQ DX, 0x18(SP)			
  0x4090da		e8911d0000		CALL runtime.(*linearAlloc).alloc(SB)	
  0x4090df		488b442420		MOVQ 0x20(SP), AX			
	if v != nil {
  0x4090e4		4885c0			TESTQ AX, AX		
  0x4090e7		0f850e060000		JNE 0x4096fb		
	for h.arenaHints != nil {
  0x4090ed		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x4090f5		488b542448		MOVQ 0x48(SP), DX	
  0x4090fa		eb35			JMP 0x409131		
		h.arenaHints = hint.next
  0x4090fc		488b7310		MOVQ 0x10(BX), SI	
  0x409100		4889b130030000		MOVQ SI, 0x330(CX)	
		h.arenaHintAlloc.free(unsafe.Pointer(hint))
  0x409107		90			NOPL			
	f.inuse -= f.size
  0x409108		488bb1a0260000		MOVQ 0x26a0(CX), SI	
  0x40910f		482bb170260000		SUBQ 0x2670(CX), SI	
  0x409116		4889b1a0260000		MOVQ SI, 0x26a0(CX)	
	v.next = f.list
  0x40911d		488bb188260000		MOVQ 0x2688(CX), SI	
  0x409124		488933			MOVQ SI, 0(BX)		
	f.list = v
  0x409127		48899988260000		MOVQ BX, 0x2688(CX)	
		p := uintptr(v)
  0x40912e		4c89c0			MOVQ R8, AX		
	for h.arenaHints != nil {
  0x409131		488b9930030000		MOVQ 0x330(CX), BX	
  0x409138		4885db			TESTQ BX, BX		
  0x40913b		0f84ad050000		JE 0x4096ee		
  0x409141		48899c2490000000	MOVQ BX, 0x90(SP)	
		p := hint.addr
  0x409149		488b03			MOVQ 0(BX), AX		
		if hint.down {
  0x40914c		0fb67308		MOVZX 0x8(BX), SI	
			p -= n
  0x409150		4889c7			MOVQ AX, DI		
  0x409153		4829d0			SUBQ DX, AX		
		if p+n < p {
  0x409156		4885f6			TESTQ SI, SI		
  0x409159		480f45f8		CMOVNE AX, DI		
  0x40915d		488d043a		LEAQ 0(DX)(DI*1), AX	
  0x409161		4839f8			CMPQ DI, AX		
		if hint.down {
  0x409164		0f83ee040000		JAE 0x409658		
  0x40916a		31f6			XORL SI, SI		
		if p == uintptr(v) {
  0x40916c		4989f0			MOVQ SI, R8		
  0x40916f		4839f7			CMPQ SI, DI		
  0x409172		7446			JE 0x4091ba		
		if v != nil {
  0x409174		4d85c0			TESTQ R8, R8		
  0x409177		7483			JE 0x4090fc		
		if p == uintptr(v) {
  0x409179		4c89842488000000	MOVQ R8, 0x88(SP)	
			sysFree(v, n, nil)
  0x409181		4c890424		MOVQ R8, 0(SP)			
  0x409185		4889542408		MOVQ DX, 0x8(SP)		
  0x40918a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x409193		e8e8850000		CALL runtime.sysFree(SB)	
		h.arenaHints = hint.next
  0x409198		488b8c24a8000000	MOVQ 0xa8(SP), CX	
			p -= n
  0x4091a0		488b542448		MOVQ 0x48(SP), DX	
		h.arenaHints = hint.next
  0x4091a5		488b9c2490000000	MOVQ 0x90(SP), BX	
		p := uintptr(v)
  0x4091ad		4c8b842488000000	MOVQ 0x88(SP), R8	
			sysFree(v, n, nil)
  0x4091b5		e942ffffff		JMP 0x4090fc		
			if !hint.down {
  0x4091ba		0fb67308		MOVZX 0x8(BX), SI	
			hint.addr = p
  0x4091be		4885f6			TESTQ SI, SI		
  0x4091c1		480f45c7		CMOVNE DI, AX		
  0x4091c5		488903			MOVQ AX, 0(BX)		
	return (n + a - 1) &^ (a - 1)
  0x4091c8		4889d0			MOVQ DX, AX		
	if size == 0 {
  0x4091cb		4885d2			TESTQ DX, DX		
  0x4091ce		0f8490030000		JE 0x409564		
		p := uintptr(v)
  0x4091d4		4c89c0			MOVQ R8, AX		
		if p+size < p {
  0x4091d7		4a8d1c02		LEAQ 0(DX)(R8*1), BX	
  0x4091db		4c39c3			CMPQ R8, BX		
  0x4091de		0f8310030000		JAE 0x4094f4		
  0x4091e4		488d35c7850600		LEAQ 0x685c7(IP), SI	
  0x4091eb		bf1c000000		MOVL $0x1c, DI		
		if bad != "" {
  0x4091f0		4885ff			TESTQ DI, DI		
  0x4091f3		0f85a8050000		JNE 0x4097a1		
	if uintptr(v)&(heapArenaBytes-1) != 0 {
  0x4091f9		49f7c0ffffff03		TESTQ $0x3ffffff, R8	
  0x409200		0f8580050000		JNE 0x409786		
		p := uintptr(v)
  0x409206		4889842488000000	MOVQ AX, 0x88(SP)	
		if p+size < p {
  0x40920e		4889542460		MOVQ DX, 0x60(SP)	
	sysMap(v, size, &memstats.heap_sys)
  0x409213		48890424		MOVQ AX, 0(SP)				
  0x409217		4889542408		MOVQ DX, 0x8(SP)			
  0x40921c		488d0d754a0d00		LEAQ runtime.memstats+56(SB), CX	
  0x409223		48894c2410		MOVQ CX, 0x10(SP)			
  0x409228		e8a3850000		CALL runtime.sysMap(SB)			
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x40922d		488b842488000000	MOVQ 0x88(SP), AX	
  0x409235		488b4c2460		MOVQ 0x60(SP), CX	
  0x40923a		4889842488000000	MOVQ AX, 0x88(SP)	
  0x409242		48894c2460		MOVQ CX, 0x60(SP)	
  0x409247		90			NOPL			
  0x409248		4889c2			MOVQ AX, DX		
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40924b		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x409255		4801d8			ADDQ BX, AX			
  0x409258		48c1e81a		SHRQ $0x1a, AX			
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x40925c		488b9c24a8000000	MOVQ 0xa8(SP), BX	
  0x409264		eb34			JMP 0x40929a		
		h.allArenas[len(h.allArenas)-1] = ri
  0x409266		488b742458		MOVQ 0x58(SP), SI	
  0x40926b		488934da		MOVQ SI, 0(DX)(BX*8)	
		atomic.StorepNoWB(unsafe.Pointer(&l2[ri.l2()]), unsafe.Pointer(r))
  0x40926f		90			NOPL			
  0x409270		488bbc2480000000	MOVQ 0x80(SP), DI	
  0x409278		488707			XCHGQ AX, 0(DI)		
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x40927b		488d4601		LEAQ 0x1(SI), AX	
  0x40927f		488b742460		MOVQ 0x60(SP), SI	
  0x409284		488bbc2488000000	MOVQ 0x88(SP), DI	
  0x40928c		4889f1			MOVQ SI, CX		
  0x40928f		4889fa			MOVQ DI, DX		
		l2 := h.arenas[ri.l1()]
  0x409292		488b9c24a8000000	MOVQ 0xa8(SP), BX	
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x40929a		90			NOPL			
  0x40929b		4889d6			MOVQ DX, SI		
  0x40929e		4801ca			ADDQ CX, DX		
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4092a1		48bfffffffffff7f0000	MOVQ $0x7fffffffffff, DI	
  0x4092ab		4801fa			ADDQ DI, DX			
  0x4092ae		48c1ea1a		SHRQ $0x1a, DX			
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x4092b2		4839d0			CMPQ DX, AX		
  0x4092b5		0f8719020000		JA 0x4094d4		
  0x4092bb		4889442458		MOVQ AX, 0x58(SP)	
		l2 := h.arenas[ri.l1()]
  0x4092c0		488b9310030000		MOVQ 0x310(BX), DX	
  0x4092c7		90			NOPL			
		if l2 == nil {
  0x4092c8		4885d2			TESTQ DX, DX		
  0x4092cb		0f84a2010000		JE 0x409473		
		if l2[ri.l2()] != nil {
  0x4092d1		8402			TESTB AL, 0(DX)		
  0x4092d3		90			NOPL			
  0x4092d4		483d00004000		CMPQ $0x400000, AX	
  0x4092da		0f8369040000		JAE 0x409749		
  0x4092e0		4c8b04c2		MOVQ 0(DX)(AX*8), R8	
  0x4092e4		488d14c2		LEAQ 0(DX)(AX*8), DX	
  0x4092e8		4d85c0			TESTQ R8, R8		
  0x4092eb		0f855f040000		JNE 0x409750		
  0x4092f1		4889942480000000	MOVQ DX, 0x80(SP)	
		r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &memstats.gc_sys))
  0x4092f9		488d8318030000		LEAQ 0x318(BX), AX			
  0x409300		48890424		MOVQ AX, 0(SP)				
  0x409304		48c744240800082100	MOVQ $0x210800, 0x8(SP)			
  0x40930d		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x409316		488d05db490d00		LEAQ runtime.memstats+152(SB), AX	
  0x40931d		4889442418		MOVQ AX, 0x18(SP)			
  0x409322		e8491b0000		CALL runtime.(*linearAlloc).alloc(SB)	
  0x409327		488b442420		MOVQ 0x20(SP), AX			
		if r == nil {
  0x40932c		4885c0			TESTQ AX, AX		
  0x40932f		0f8409010000		JE 0x40943e		
		if len(h.allArenas) == cap(h.allArenas) {
  0x409335		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x40933d		488b9160030000		MOVQ 0x360(CX), DX	
  0x409344		48399158030000		CMPQ DX, 0x358(CX)	
  0x40934b		7440			JE 0x40938d		
		h.allArenas = h.allArenas[:len(h.allArenas)+1]
  0x40934d		488b9160030000		MOVQ 0x360(CX), DX	
  0x409354		488b9958030000		MOVQ 0x358(CX), BX	
  0x40935b		488d7301		LEAQ 0x1(BX), SI	
  0x40935f		4885f6			TESTQ SI, SI		
  0x409362		0f8ca4030000		JL 0x40970c		
  0x409368		4839d6			CMPQ DX, SI		
  0x40936b		0f879b030000		JA 0x40970c		
  0x409371		4889b158030000		MOVQ SI, 0x358(CX)	
		h.allArenas[len(h.allArenas)-1] = ri
  0x409378		488b9150030000		MOVQ 0x350(CX), DX	
  0x40937f		4839f3			CMPQ SI, BX		
  0x409382		0f82defeffff		JB 0x409266		
  0x409388		e978030000		JMP 0x409705		
		atomic.StorepNoWB(unsafe.Pointer(&l2[ri.l2()]), unsafe.Pointer(r))
  0x40938d		4889442468		MOVQ AX, 0x68(SP)	
			size := 2 * uintptr(cap(h.allArenas)) * sys.PtrSize
  0x409392		48c1e204		SHLQ $0x4, DX		
			if size == 0 {
  0x409396		4885d2			TESTQ DX, DX		
  0x409399		7507			JNE 0x4093a2		
				size = physPageSize
  0x40939b		488b15063a0d00		MOVQ runtime.physPageSize(SB), DX	
			newArray := (*notInHeap)(persistentalloc(size, sys.PtrSize, &memstats.gc_sys))
  0x4093a2		4889542430		MOVQ DX, 0x30(SP)			
  0x4093a7		48891424		MOVQ DX, 0(SP)				
  0x4093ab		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x4093b4		488d053d490d00		LEAQ runtime.memstats+152(SB), AX	
  0x4093bb		4889442410		MOVQ AX, 0x10(SP)			
  0x4093c0		e8ab160000		CALL runtime.persistentalloc(SB)	
  0x4093c5		488b442418		MOVQ 0x18(SP), AX			
			if newArray == nil {
  0x4093ca		4885c0			TESTQ AX, AX		
  0x4093cd		0f8440030000		JE 0x409713		
			*(*notInHeapSlice)(unsafe.Pointer(&h.allArenas)) = notInHeapSlice{newArray, len(h.allArenas), int(size / sys.PtrSize)}
  0x4093d3		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x4093db		488b9150030000		MOVQ 0x350(CX), DX	
  0x4093e2		488b9958030000		MOVQ 0x358(CX), BX	
  0x4093e9		488b742430		MOVQ 0x30(SP), SI	
  0x4093ee		48c1ee03		SHRQ $0x3, SI		
  0x4093f2		4889b160030000		MOVQ SI, 0x360(CX)	
  0x4093f9		48898150030000		MOVQ AX, 0x350(CX)	
			copy(h.allArenas, oldSlice)
  0x409400		488bb158030000		MOVQ 0x358(CX), SI	
  0x409407		4839de			CMPQ BX, SI		
  0x40940a		480f4ff3		CMOVG BX, SI		
  0x40940e		4839d0			CMPQ DX, AX		
  0x409411		750a			JNE 0x40941d		
		atomic.StorepNoWB(unsafe.Pointer(&l2[ri.l2()]), unsafe.Pointer(r))
  0x409413		488b442468		MOVQ 0x68(SP), AX	
		h.allArenas = h.allArenas[:len(h.allArenas)+1]
  0x409418		e930ffffff		JMP 0x40934d		
			copy(h.allArenas, oldSlice)
  0x40941d		48890424		MOVQ AX, 0(SP)			
  0x409421		4889542408		MOVQ DX, 0x8(SP)		
  0x409426		48c1e603		SHLQ $0x3, SI			
  0x40942a		4889742410		MOVQ SI, 0x10(SP)		
  0x40942f		e81c130400		CALL runtime.memmove(SB)	
		h.allArenas = h.allArenas[:len(h.allArenas)+1]
  0x409434		488b8c24a8000000	MOVQ 0xa8(SP), CX	
			copy(h.allArenas, oldSlice)
  0x40943c		ebd5			JMP 0x409413		
			r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), sys.PtrSize, &memstats.gc_sys))
  0x40943e		48c7042400082100	MOVQ $0x210800, 0(SP)			
  0x409446		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x40944f		488d05a2480d00		LEAQ runtime.memstats+152(SB), AX	
  0x409456		4889442410		MOVQ AX, 0x10(SP)			
  0x40945b		e810160000		CALL runtime.persistentalloc(SB)	
  0x409460		488b442418		MOVQ 0x18(SP), AX			
			if r == nil {
  0x409465		4885c0			TESTQ AX, AX		
  0x409468		0f85c7feffff		JNE 0x409335		
  0x40946e		e9bb020000		JMP 0x40972e		
			l2 = (*[1 << arenaL2Bits]*heapArena)(persistentalloc(unsafe.Sizeof(*l2), sys.PtrSize, nil))
  0x409473		48c7042400000002	MOVQ $0x2000000, 0(SP)			
  0x40947b		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x409484		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x40948d		e8de150000		CALL runtime.persistentalloc(SB)	
  0x409492		488b442418		MOVQ 0x18(SP), AX			
			if l2 == nil {
  0x409497		4885c0			TESTQ AX, AX		
  0x40949a		0f84cb020000		JE 0x40976b		
			atomic.StorepNoWB(unsafe.Pointer(&h.arenas[ri.l1()]), unsafe.Pointer(l2))
  0x4094a0		90			NOPL			
  0x4094a1		488b9c24a8000000	MOVQ 0xa8(SP), BX	
  0x4094a9		4889c2			MOVQ AX, DX		
  0x4094ac		48878310030000		XCHGQ AX, 0x310(BX)	
		if l2[ri.l2()] != nil {
  0x4094b3		488b442458		MOVQ 0x58(SP), AX	
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x4094b8		488b4c2460		MOVQ 0x60(SP), CX	
  0x4094bd		488bb42488000000	MOVQ 0x88(SP), SI	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4094c5		48bfffffffffff7f0000	MOVQ $0x7fffffffffff, DI	
			atomic.StorepNoWB(unsafe.Pointer(&h.arenas[ri.l1()]), unsafe.Pointer(l2))
  0x4094cf		e9fdfdffff		JMP 0x4092d1		
	return
  0x4094d4		4889b424b8000000	MOVQ SI, 0xb8(SP)	
  0x4094dc		48898c24c0000000	MOVQ CX, 0xc0(SP)	
  0x4094e4		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4094ec		4881c4a0000000		ADDQ $0xa0, SP		
  0x4094f3		c3			RET			
		} else if arenaIndex(p) >= 1<<arenaBits {
  0x4094f4		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4094f5		48be0000000000800000	MOVQ $0x800000000000, SI	
  0x4094ff		498d3c30		LEAQ 0(R8)(SI*1), DI		
  0x409503		48c1ef1a		SHRQ $0x1a, DI			
		} else if arenaIndex(p) >= 1<<arenaBits {
  0x409507		4881ff00004000		CMPQ $0x400000, DI	
  0x40950e		7218			JB 0x409528		
  0x409510		488d3dbe8b0600		LEAQ 0x68bbe(IP), DI	
  0x409517		41b921000000		MOVL $0x21, R9		
		if bad != "" {
  0x40951d		4889fe			MOVQ DI, SI		
  0x409520		4c89cf			MOVQ R9, DI		
  0x409523		e9c8fcffff		JMP 0x4091f0		
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x409528		49baffffffffff7f0000	MOVQ $0x7fffffffffff, R10	
  0x409532		4d8d1c1a		LEAQ 0(R10)(BX*1), R11		
  0x409536		49c1eb1a		SHRQ $0x1a, R11			
		} else if arenaIndex(p+size-1) >= 1<<arenaBits {
  0x40953a		4981fb00004000		CMPQ $0x400000, R11	
		if bad != "" {
  0x409541		41b900000000		MOVL $0x0, R9		
  0x409547		41bb20000000		MOVL $0x20, R11		
  0x40954d		4d0f43cb		CMOVAE R11, R9		
  0x409551		bf00000000		MOVL $0x0, DI		
  0x409556		4c8d1d94890600		LEAQ 0x68994(IP), R11	
  0x40955d		490f43fb		CMOVAE R11, DI		
		} else if arenaIndex(p+size-1) >= 1<<arenaBits {
  0x409561		90			NOPL			
  0x409562		ebb9			JMP 0x40951d		
		v, size = sysReserveAligned(nil, n, heapArenaBytes)
  0x409564		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x40956c		4889442408		MOVQ AX, 0x8(SP)			
  0x409571		48c744241000000004	MOVQ $0x4000000, 0x10(SP)		
  0x40957a		e8f1020000		CALL runtime.sysReserveAligned(SB)	
  0x40957f		488b442418		MOVQ 0x18(SP), AX			
  0x409584		488b4c2420		MOVQ 0x20(SP), CX			
		if v == nil {
  0x409589		4885c0			TESTQ AX, AX		
  0x40958c		0f849e000000		JE 0x409630		
		v, size = sysReserveAligned(nil, n, heapArenaBytes)
  0x409592		4889842488000000	MOVQ AX, 0x88(SP)	
  0x40959a		48894c2460		MOVQ CX, 0x60(SP)	
		hint := (*arenaHint)(h.arenaHintAlloc.alloc())
  0x40959f		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x4095a7		488d8870260000		LEAQ 0x2670(AX), CX			
  0x4095ae		48894c2478		MOVQ CX, 0x78(SP)			
  0x4095b3		48890c24		MOVQ CX, 0(SP)				
  0x4095b7		e8d4850000		CALL runtime.(*fixalloc).alloc(SB)	
  0x4095bc		488b442408		MOVQ 0x8(SP), AX			
		hint.addr, hint.down = uintptr(v), true
  0x4095c1		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x4095c9		488908			MOVQ CX, 0(AX)		
  0x4095cc		c6400801		MOVB $0x1, 0x8(AX)	
		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
  0x4095d0		488b0d99d30b00		MOVQ runtime.mheap_+816(SB), CX	
  0x4095d7		48894810		MOVQ CX, 0x10(AX)		
  0x4095db		4889058ed30b00		MOVQ AX, runtime.mheap_+816(SB)	
		hint = (*arenaHint)(h.arenaHintAlloc.alloc())
  0x4095e2		488b442478		MOVQ 0x78(SP), AX			
  0x4095e7		48890424		MOVQ AX, 0(SP)				
  0x4095eb		e8a0850000		CALL runtime.(*fixalloc).alloc(SB)	
  0x4095f0		488b442408		MOVQ 0x8(SP), AX			
		hint.addr = uintptr(v) + size
  0x4095f5		4c8b842488000000	MOVQ 0x88(SP), R8	
  0x4095fd		488b542460		MOVQ 0x60(SP), DX	
  0x409602		4a8d1c02		LEAQ 0(DX)(R8*1), BX	
  0x409606		488918			MOVQ BX, 0(AX)		
		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
  0x409609		488b1d60d30b00		MOVQ runtime.mheap_+816(SB), BX	
  0x409610		48895810		MOVQ BX, 0x10(AX)		
  0x409614		48890555d30b00		MOVQ AX, runtime.mheap_+816(SB)	
		l2 := h.arenas[ri.l1()]
  0x40961b		488b8c24a8000000	MOVQ 0xa8(SP), CX	
		p := uintptr(v)
  0x409623		4c8b842488000000	MOVQ 0x88(SP), R8	
		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
  0x40962b		e9a4fbffff		JMP 0x4091d4		
			return nil, 0
  0x409630		48c78424b800000000000000	MOVQ $0x0, 0xb8(SP)	
  0x40963c		48c78424c000000000000000	MOVQ $0x0, 0xc0(SP)	
  0x409648		488bac2498000000		MOVQ 0x98(SP), BP	
  0x409650		4881c4a0000000			ADDQ $0xa0, SP		
  0x409657		c3				RET			
		} else if arenaIndex(p+n-1) >= 1<<arenaBits {
  0x409658		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x409659		48beffffffffff7f0000	MOVQ $0x7fffffffffff, SI	
  0x409663		4c8d0406		LEAQ 0(SI)(AX*1), R8		
  0x409667		49c1e81a		SHRQ $0x1a, R8			
		} else if arenaIndex(p+n-1) >= 1<<arenaBits {
  0x40966b		4981f800004000		CMPQ $0x400000, R8	
  0x409672		720b			JB 0x40967f		
  0x409674		4531c0			XORL R8, R8		
		if p == uintptr(v) {
  0x409677		4c89c6			MOVQ R8, SI		
  0x40967a		e9edfaffff		JMP 0x40916c		
		if p+n < p {
  0x40967f		48897c2438		MOVQ DI, 0x38(SP)	
  0x409684		4889442460		MOVQ AX, 0x60(SP)	
			v = sysReserve(unsafe.Pointer(p), n)
  0x409689		90			NOPL			
	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x40968a		48893c24		MOVQ DI, 0(SP)		
  0x40968e		4889542408		MOVQ DX, 0x8(SP)	
  0x409693		48b90000000022000000	MOVQ $0x2200000000, CX	
  0x40969d		48894c2410		MOVQ CX, 0x10(SP)	
  0x4096a2		b9ffffffff		MOVL $-0x1, CX		
  0x4096a7		48894c2418		MOVQ CX, 0x18(SP)	
  0x4096ac		e8cf9dffff		CALL runtime.mmap(SB)	
  0x4096b1		488b442420		MOVQ 0x20(SP), AX	
  0x4096b6		48837c242800		CMPQ $0x0, 0x28(SP)	
	if err != 0 {
  0x4096bc		7402			JE 0x4096c0		
  0x4096be		31c0			XORL AX, AX		
		h.arenaHints = hint.next
  0x4096c0		488b8c24a8000000	MOVQ 0xa8(SP), CX	
			p -= n
  0x4096c8		488b542448		MOVQ 0x48(SP), DX	
		h.arenaHints = hint.next
  0x4096cd		488b9c2490000000	MOVQ 0x90(SP), BX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4096d5		48beffffffffff7f0000	MOVQ $0x7fffffffffff, SI	
		if p == uintptr(v) {
  0x4096df		488b7c2438		MOVQ 0x38(SP), DI	
  0x4096e4		4989c0			MOVQ AX, R8		
			hint.addr = p
  0x4096e7		488b442460		MOVQ 0x60(SP), AX	
			v = sysReserve(unsafe.Pointer(p), n)
  0x4096ec		eb89			JMP 0x409677		
		p := uintptr(v)
  0x4096ee		4989c0			MOVQ AX, R8		
		v, size = sysReserveAligned(nil, n, heapArenaBytes)
  0x4096f1		4889d0			MOVQ DX, AX		
  0x4096f4		31d2			XORL DX, DX		
	for h.arenaHints != nil {
  0x4096f6		e9d0faffff		JMP 0x4091cb		
	for ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {
  0x4096fb		488b4c2448		MOVQ 0x48(SP), CX	
		goto mapped
  0x409700		e935fbffff		JMP 0x40923a		
		h.allArenas[len(h.allArenas)-1] = ri
  0x409705		e816880100		CALL runtime.panicindex(SB)	
  0x40970a		0f0b			UD2				
		h.allArenas = h.allArenas[:len(h.allArenas)+1]
  0x40970c		e83f890100		CALL runtime.panicslice(SB)	
  0x409711		0f0b			UD2				
				throw("out of memory allocating allArenas")
  0x409713		488d05528c0600		LEAQ 0x68c52(IP), AX	
  0x40971a		48890424		MOVQ AX, 0(SP)		
  0x40971e		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x409727		e8549d0100		CALL runtime.throw(SB)	
  0x40972c		0f0b			UD2			
				throw("out of memory allocating heap arena metadata")
  0x40972e		488d05ce960600		LEAQ 0x696ce(IP), AX	
  0x409735		48890424		MOVQ AX, 0(SP)		
  0x409739		48c74424082c000000	MOVQ $0x2c, 0x8(SP)	
  0x409742		e8399d0100		CALL runtime.throw(SB)	
  0x409747		0f0b			UD2			
		if l2[ri.l2()] != nil {
  0x409749		e8d2870100		CALL runtime.panicindex(SB)	
  0x40974e		0f0b			UD2				
			throw("arena already initialized")
  0x409750		488d0577780600		LEAQ 0x67877(IP), AX	
  0x409757		48890424		MOVQ AX, 0(SP)		
  0x40975b		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x409764		e8179d0100		CALL runtime.throw(SB)	
  0x409769		0f0b			UD2			
				throw("out of memory allocating heap arena map")
  0x40976b		488d05ed900600		LEAQ 0x690ed(IP), AX	
  0x409772		48890424		MOVQ AX, 0(SP)		
  0x409776		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x40977f		e8fc9c0100		CALL runtime.throw(SB)	
  0x409784		0f0b			UD2			
		throw("misrounded allocation in sysAlloc")
  0x409786		488d05ed890600		LEAQ 0x689ed(IP), AX	
  0x40978d		48890424		MOVQ AX, 0(SP)		
  0x409791		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40979a		e8e19c0100		CALL runtime.throw(SB)	
  0x40979f		0f0b			UD2			
		p := uintptr(v)
  0x4097a1		4c89442440		MOVQ R8, 0x40(SP)	
		if p+size < p {
  0x4097a6		48895c2460		MOVQ BX, 0x60(SP)	
		if bad != "" {
  0x4097ab		4889742470		MOVQ SI, 0x70(SP)	
  0x4097b0		48897c2450		MOVQ DI, 0x50(SP)	
			print("runtime: memory allocated by OS [", hex(p), ", ", hex(p+size), ") not in usable address space: ", bad, "\n")
  0x4097b5		e806a70100		CALL runtime.printlock(SB)	
  0x4097ba		488d053d8a0600		LEAQ 0x68a3d(IP), AX		
  0x4097c1		48890424		MOVQ AX, 0(SP)			
  0x4097c5		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x4097ce		e81db00100		CALL runtime.printstring(SB)	
  0x4097d3		488b442440		MOVQ 0x40(SP), AX		
  0x4097d8		48890424		MOVQ AX, 0(SP)			
  0x4097dc		e8cfae0100		CALL runtime.printhex(SB)	
  0x4097e1		488d05b4580600		LEAQ 0x658b4(IP), AX		
  0x4097e8		48890424		MOVQ AX, 0(SP)			
  0x4097ec		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4097f5		e8f6af0100		CALL runtime.printstring(SB)	
  0x4097fa		488b442460		MOVQ 0x60(SP), AX		
  0x4097ff		48890424		MOVQ AX, 0(SP)			
  0x409803		e8a8ae0100		CALL runtime.printhex(SB)	
  0x409808		488d0591840600		LEAQ 0x68491(IP), AX		
  0x40980f		48890424		MOVQ AX, 0(SP)			
  0x409813		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x40981c		e8cfaf0100		CALL runtime.printstring(SB)	
  0x409821		488b442470		MOVQ 0x70(SP), AX		
  0x409826		48890424		MOVQ AX, 0(SP)			
  0x40982a		488b442450		MOVQ 0x50(SP), AX		
  0x40982f		4889442408		MOVQ AX, 0x8(SP)		
  0x409834		e8b7af0100		CALL runtime.printstring(SB)	
  0x409839		e812a90100		CALL runtime.printnl(SB)	
  0x40983e		e8fda60100		CALL runtime.printunlock(SB)	
			throw("memory reservation exceeds address space limit")
  0x409843		488d0598960600		LEAQ 0x69698(IP), AX	
  0x40984a		48890424		MOVQ AX, 0(SP)		
  0x40984e		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x409857		e8249c0100		CALL runtime.throw(SB)	
  0x40985c		0f0b			UD2			
func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {
  0x40985e		e81de00300		CALL runtime.morestack_noctxt(SB)	
  0x409863		e9f8f7ffff		JMP runtime.(*mheap).sysAlloc(SB)	

TEXT runtime.sysReserveAligned(SB) /usr/local/go/src/runtime/malloc.go
func sysReserveAligned(v unsafe.Pointer, size, align uintptr) (unsafe.Pointer, uintptr) {
  0x409870		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409879		483b6110		CMPQ 0x10(CX), SP	
  0x40987d		0f8645010000		JBE 0x4099c8		
  0x409883		4883ec50		SUBQ $0x50, SP		
  0x409887		48896c2448		MOVQ BP, 0x48(SP)	
  0x40988c		488d6c2448		LEAQ 0x48(SP), BP	
	p := uintptr(sysReserve(v, size+align))
  0x409891		90			NOPL			
  0x409892		488b442458		MOVQ 0x58(SP), AX	
	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x409897		48890424		MOVQ AX, 0(SP)		
	p := uintptr(sysReserve(v, size+align))
  0x40989b		488b442460		MOVQ 0x60(SP), AX	
  0x4098a0		488b4c2468		MOVQ 0x68(SP), CX	
  0x4098a5		488d1401		LEAQ 0(CX)(AX*1), DX	
  0x4098a9		4889542440		MOVQ DX, 0x40(SP)	
	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x4098ae		4889542408		MOVQ DX, 0x8(SP)	
  0x4098b3		48bb0000000022000000	MOVQ $0x2200000000, BX	
  0x4098bd		48895c2410		MOVQ BX, 0x10(SP)	
  0x4098c2		bbffffffff		MOVL $-0x1, BX		
  0x4098c7		48895c2418		MOVQ BX, 0x18(SP)	
  0x4098cc		e8af9bffff		CALL runtime.mmap(SB)	
  0x4098d1		488b442420		MOVQ 0x20(SP), AX	
  0x4098d6		48837c242800		CMPQ $0x0, 0x28(SP)	
	p := uintptr(sysReserve(v, size+align))
  0x4098dc		b900000000		MOVL $0x0, CX		
  0x4098e1		480f45c1		CMOVNE CX, AX		
  0x4098e5		4889c1			MOVQ AX, CX		
	case p == 0:
  0x4098e8		4885c0			TESTQ AX, AX		
	if err != 0 {
  0x4098eb		0f84bb000000		JE 0x4099ac		
	case p&(align-1) == 0:
  0x4098f1		488b542468		MOVQ 0x68(SP), DX	
  0x4098f6		488d5aff		LEAQ -0x1(DX), BX	
  0x4098fa		4885d8			TESTQ BX, AX		
  0x4098fd		0f8490000000		JE 0x409993		
	p := uintptr(sysReserve(v, size+align))
  0x409903		4889442438		MOVQ AX, 0x38(SP)	
		pAligned := round(p, align)
  0x409908		90			NOPL			
		sysFree(unsafe.Pointer(p), pAligned-p, nil)
  0x409909		48890c24		MOVQ CX, 0(SP)		
	return (n + a - 1) &^ (a - 1)
  0x40990d		488d0c10		LEAQ 0(AX)(DX*1), CX	
  0x409911		488d49ff		LEAQ -0x1(CX), CX	
  0x409915		48f7d3			NOTQ BX			
  0x409918		4821cb			ANDQ CX, BX		
  0x40991b		48895c2430		MOVQ BX, 0x30(SP)	
		sysFree(unsafe.Pointer(p), pAligned-p, nil)
  0x409920		4829c3			SUBQ AX, BX			
  0x409923		48895c2408		MOVQ BX, 0x8(SP)		
  0x409928		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x409931		e84a7e0000		CALL runtime.sysFree(SB)	
		end := pAligned + size
  0x409936		488b442430		MOVQ 0x30(SP), AX	
  0x40993b		488b4c2460		MOVQ 0x60(SP), CX	
  0x409940		488d1401		LEAQ 0(CX)(AX*1), DX	
		endLen := (p + size + align) - end
  0x409944		488b5c2438		MOVQ 0x38(SP), BX	
  0x409949		4801cb			ADDQ CX, BX		
  0x40994c		488b742468		MOVQ 0x68(SP), SI	
  0x409951		4801f3			ADDQ SI, BX		
  0x409954		4829d3			SUBQ DX, BX		
		if endLen > 0 {
  0x409957		4885db			TESTQ BX, BX		
  0x40995a		7714			JA 0x409970		
		return unsafe.Pointer(pAligned), size
  0x40995c		4889442470		MOVQ AX, 0x70(SP)	
  0x409961		48894c2478		MOVQ CX, 0x78(SP)	
  0x409966		488b6c2448		MOVQ 0x48(SP), BP	
  0x40996b		4883c450		ADDQ $0x50, SP		
  0x40996f		c3			RET			
			sysFree(unsafe.Pointer(end), endLen, nil)
  0x409970		48891424		MOVQ DX, 0(SP)			
  0x409974		48895c2408		MOVQ BX, 0x8(SP)		
  0x409979		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x409982		e8f97d0000		CALL runtime.sysFree(SB)	
		return unsafe.Pointer(pAligned), size
  0x409987		488b442430		MOVQ 0x30(SP), AX	
  0x40998c		488b4c2460		MOVQ 0x60(SP), CX	
			sysFree(unsafe.Pointer(end), endLen, nil)
  0x409991		ebc9			JMP 0x40995c		
		return unsafe.Pointer(p), size + align
  0x409993		48894c2470		MOVQ CX, 0x70(SP)	
  0x409998		488b442440		MOVQ 0x40(SP), AX	
  0x40999d		4889442478		MOVQ AX, 0x78(SP)	
  0x4099a2		488b6c2448		MOVQ 0x48(SP), BP	
  0x4099a7		4883c450		ADDQ $0x50, SP		
  0x4099ab		c3			RET			
		return nil, 0
  0x4099ac		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x4099b5		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x4099be		488b6c2448		MOVQ 0x48(SP), BP	
  0x4099c3		4883c450		ADDQ $0x50, SP		
  0x4099c7		c3			RET			
func sysReserveAligned(v unsafe.Pointer, size, align uintptr) (unsafe.Pointer, uintptr) {
  0x4099c8		e8b3de0300		CALL runtime.morestack_noctxt(SB)	
  0x4099cd		e99efeffff		JMP runtime.sysReserveAligned(SB)	

TEXT runtime.(*mcache).nextFree(SB) /usr/local/go/src/runtime/malloc.go
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
  0x4099e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4099e9		483b6110		CMPQ 0x10(CX), SP	
  0x4099ed		0f8613020000		JBE 0x409c06		
  0x4099f3		4883ec30		SUBQ $0x30, SP		
  0x4099f7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4099fc		488d6c2428		LEAQ 0x28(SP), BP	
	s = c.alloc[spc]
  0x409a01		488b442438		MOVQ 0x38(SP), AX	
  0x409a06		8400			TESTB AL, 0(AX)		
  0x409a08		0fb64c2440		MOVZX 0x40(SP), CX	
  0x409a0d		4881f986000000		CMPQ $0x86, CX		
  0x409a14		0f83e5010000		JAE 0x409bff		
  0x409a1a		488b54c828		MOVQ 0x28(AX)(CX*8), DX	
  0x409a1f		4889542420		MOVQ DX, 0x20(SP)	
	freeIndex := s.nextFreeIndex()
  0x409a24		48891424		MOVQ DX, 0(SP)				
  0x409a28		e8033f0000		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x409a2d		488b442408		MOVQ 0x8(SP), AX			
	if freeIndex == s.nelems {
  0x409a32		488b4c2420		MOVQ 0x20(SP), CX	
  0x409a37		488b5138		MOVQ 0x38(CX), DX	
  0x409a3b		4839d0			CMPQ DX, AX		
  0x409a3e		0f8595000000		JNE 0x409ad9		
		if uintptr(s.allocCount) != s.nelems {
  0x409a44		0fb74160		MOVZX 0x60(CX), AX	
  0x409a48		4839d0			CMPQ DX, AX		
  0x409a4b		0f852c010000		JNE 0x409b7d		
		c.refill(spc)
  0x409a51		488b442438		MOVQ 0x38(SP), AX			
  0x409a56		48890424		MOVQ AX, 0(SP)				
  0x409a5a		0fb64c2440		MOVZX 0x40(SP), CX			
  0x409a5f		884c2408		MOVB CL, 0x8(SP)			
  0x409a63		e8c86d0000		CALL runtime.(*mcache).refill(SB)	
		s = c.alloc[spc]
  0x409a68		0fb6442440		MOVZX 0x40(SP), AX	
  0x409a6d		488b4c2438		MOVQ 0x38(SP), CX	
  0x409a72		488b44c128		MOVQ 0x28(CX)(AX*8), AX	
  0x409a77		4889442420		MOVQ AX, 0x20(SP)	
		freeIndex = s.nextFreeIndex()
  0x409a7c		48890424		MOVQ AX, 0(SP)				
  0x409a80		e8ab3e0000		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x409a85		488b442408		MOVQ 0x8(SP), AX			
	if freeIndex >= s.nelems {
  0x409a8a		488b4c2420		MOVQ 0x20(SP), CX	
  0x409a8f		ba01000000		MOVL $0x1, DX		
  0x409a94		48394138		CMPQ AX, 0x38(CX)	
  0x409a98		0f86c4000000		JBE 0x409b62		
	v = gclinkptr(freeIndex*s.elemsize + s.base())
  0x409a9e		488b5968		MOVQ 0x68(CX), BX	
  0x409aa2		480fafc3		IMULQ BX, AX		
  0x409aa6		48034118		ADDQ 0x18(CX), AX	
  0x409aaa		90			NOPL			
	s.allocCount++
  0x409aab		0fb75960		MOVZX 0x60(CX), BX	
  0x409aaf		ffc3			INCL BX			
  0x409ab1		66895960		MOVW BX, 0x60(CX)	
	if uintptr(s.allocCount) > s.nelems {
  0x409ab5		0fb7f3			MOVZX BX, SI		
  0x409ab8		488b7938		MOVQ 0x38(CX), DI	
  0x409abc		4839fe			CMPQ DI, SI		
  0x409abf		771c			JA 0x409add		
	return
  0x409ac1		4889442448		MOVQ AX, 0x48(SP)	
  0x409ac6		48894c2450		MOVQ CX, 0x50(SP)	
  0x409acb		88542458		MOVB DL, 0x58(SP)	
  0x409acf		488b6c2428		MOVQ 0x28(SP), BP	
  0x409ad4		4883c430		ADDQ $0x30, SP		
  0x409ad8		c3			RET			
  0x409ad9		31d2			XORL DX, DX		
	if freeIndex == s.nelems {
  0x409adb		ebb7			JMP 0x409a94		
	s.allocCount++
  0x409add		66895c2416		MOVW BX, 0x16(SP)	
	if uintptr(s.allocCount) > s.nelems {
  0x409ae2		48897c2418		MOVQ DI, 0x18(SP)	
		println("s.allocCount=", s.allocCount, "s.nelems=", s.nelems)
  0x409ae7		e8d4a30100		CALL runtime.printlock(SB)	
  0x409aec		488d05ff620600		LEAQ 0x662ff(IP), AX		
  0x409af3		48890424		MOVQ AX, 0(SP)			
  0x409af7		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x409b00		e8ebac0100		CALL runtime.printstring(SB)	
  0x409b05		0fb7442416		MOVZX 0x16(SP), AX		
  0x409b0a		0fb7c0			MOVZX AX, AX			
  0x409b0d		48890424		MOVQ AX, 0(SP)			
  0x409b11		e82aaa0100		CALL runtime.printuint(SB)	
  0x409b16		488d05885d0600		LEAQ 0x65d88(IP), AX		
  0x409b1d		48890424		MOVQ AX, 0(SP)			
  0x409b21		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x409b2a		e8c1ac0100		CALL runtime.printstring(SB)	
  0x409b2f		488b442418		MOVQ 0x18(SP), AX		
  0x409b34		48890424		MOVQ AX, 0(SP)			
  0x409b38		e803aa0100		CALL runtime.printuint(SB)	
  0x409b3d		e80ea60100		CALL runtime.printnl(SB)	
  0x409b42		e8f9a30100		CALL runtime.printunlock(SB)	
		throw("s.allocCount > s.nelems")
  0x409b47		488d0513720600		LEAQ 0x67213(IP), AX	
  0x409b4e		48890424		MOVQ AX, 0(SP)		
  0x409b52		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x409b5b		e820990100		CALL runtime.throw(SB)	
  0x409b60		0f0b			UD2			
		throw("freeIndex is not valid")
  0x409b62		488d05466e0600		LEAQ 0x66e46(IP), AX	
  0x409b69		48890424		MOVQ AX, 0(SP)		
  0x409b6d		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x409b76		e805990100		CALL runtime.throw(SB)	
  0x409b7b		0f0b			UD2			
	if freeIndex == s.nelems {
  0x409b7d		4889542418		MOVQ DX, 0x18(SP)	
		if uintptr(s.allocCount) != s.nelems {
  0x409b82		6689442416		MOVW AX, 0x16(SP)	
			println("runtime: s.allocCount=", s.allocCount, "s.nelems=", s.nelems)
  0x409b87		e834a30100		CALL runtime.printlock(SB)	
  0x409b8c		488d05b7710600		LEAQ 0x671b7(IP), AX		
  0x409b93		48890424		MOVQ AX, 0(SP)			
  0x409b97		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x409ba0		e84bac0100		CALL runtime.printstring(SB)	
  0x409ba5		0fb7442416		MOVZX 0x16(SP), AX		
  0x409baa		48890424		MOVQ AX, 0(SP)			
  0x409bae		e88da90100		CALL runtime.printuint(SB)	
  0x409bb3		488d05eb5c0600		LEAQ 0x65ceb(IP), AX		
  0x409bba		48890424		MOVQ AX, 0(SP)			
  0x409bbe		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x409bc7		e824ac0100		CALL runtime.printstring(SB)	
  0x409bcc		488b442418		MOVQ 0x18(SP), AX		
  0x409bd1		48890424		MOVQ AX, 0(SP)			
  0x409bd5		e866a90100		CALL runtime.printuint(SB)	
  0x409bda		e871a50100		CALL runtime.printnl(SB)	
  0x409bdf		e85ca30100		CALL runtime.printunlock(SB)	
			throw("s.allocCount != s.nelems && freeIndex == s.nelems")
  0x409be4		488d0587950600		LEAQ 0x69587(IP), AX	
  0x409beb		48890424		MOVQ AX, 0(SP)		
  0x409bef		48c744240831000000	MOVQ $0x31, 0x8(SP)	
  0x409bf8		e883980100		CALL runtime.throw(SB)	
  0x409bfd		0f0b			UD2			
	s = c.alloc[spc]
  0x409bff		e81c830100		CALL runtime.panicindex(SB)	
  0x409c04		0f0b			UD2				
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {
  0x409c06		e875dc0300		CALL runtime.morestack_noctxt(SB)	
  0x409c0b		e9d0fdffff		JMP runtime.(*mcache).nextFree(SB)	

TEXT runtime.mallocgc(SB) /usr/local/go/src/runtime/malloc.go
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x409c10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x409c19		488d4424e8		LEAQ -0x18(SP), AX	
  0x409c1e		483b4110		CMPQ 0x10(CX), AX	
  0x409c22		0f8673090000		JBE 0x40a59b		
  0x409c28		4881ec98000000		SUBQ $0x98, SP		
  0x409c2f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x409c37		488dac2490000000	LEAQ 0x90(SP), BP	
	if gcphase == _GCmarktermination {
  0x409c3f		833d96300d0002		CMPL $0x2, runtime.gcphase(SB)	
  0x409c46		0f8434090000		JE 0x40a580			
	if size == 0 {
  0x409c4c		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x409c54		4885c0			TESTQ AX, AX		
  0x409c57		0f84b2080000		JE 0x40a50f		
	if debug.sbrk != 0 {
  0x409c5d		833da8320d0000		CMPL $0x0, runtime.debug+44(SB)	
  0x409c64		744f			JE 0x409cb5			
		if typ != nil {
  0x409c66		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x409c6e		4885c9			TESTQ CX, CX		
  0x409c71		743b			JE 0x409cae		
			align = uintptr(typ.align)
  0x409c73		0fb64915		MOVZX 0x15(CX), CX	
		return persistentalloc(size, align, &memstats.other_sys)
  0x409c77		48890424		MOVQ AX, 0(SP)				
  0x409c7b		48894c2408		MOVQ CX, 0x8(SP)			
  0x409c80		488d0579400d00		LEAQ runtime.memstats+160(SB), AX	
  0x409c87		4889442410		MOVQ AX, 0x10(SP)			
  0x409c8c		e8df0d0000		CALL runtime.persistentalloc(SB)	
  0x409c91		488b442418		MOVQ 0x18(SP), AX			
  0x409c96		48898424b8000000	MOVQ AX, 0xb8(SP)			
  0x409c9e		488bac2490000000	MOVQ 0x90(SP), BP			
  0x409ca6		4881c498000000		ADDQ $0x98, SP				
  0x409cad		c3			RET					
  0x409cae		b910000000		MOVL $0x10, CX				
		if typ != nil {
  0x409cb3		ebc2			JMP 0x409c77		
	if gcBlackenEnabled != 0 {
  0x409cb5		833d14300d0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x409cbc		0f8446080000		JE 0x40a508				
		assistG = getg()
  0x409cc2		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
		if assistG.m.curg != nil {
  0x409ccb		488b5a30		MOVQ 0x30(DX), BX	
  0x409ccf		488b9bc0000000		MOVQ 0xc0(BX), BX	
  0x409cd6		4885db			TESTQ BX, BX		
  0x409cd9		0f8421080000		JE 0x40a500		
		assistG.gcAssistBytes -= int64(size)
  0x409cdf		488b9370010000		MOVQ 0x170(BX), DX	
  0x409ce6		4829c2			SUBQ AX, DX		
  0x409ce9		48899370010000		MOVQ DX, 0x170(BX)	
		if assistG.gcAssistBytes < 0 {
  0x409cf0		4885d2			TESTQ DX, DX		
  0x409cf3		0f8cef070000		JL 0x40a4e8		
	_g_ := getg()
  0x409cf9		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x409d02		488b5030		MOVQ 0x30(AX), DX	
	mp := acquirem()
  0x409d06		90			NOPL			
	_g_.m.locks++
  0x409d07		ff8208010000		INCL 0x108(DX)		
	return _g_.m
  0x409d0d		488b5030		MOVQ 0x30(AX), DX	
  0x409d11		8400			TESTB AL, 0(AX)		
	if mp.mallocing != 0 {
  0x409d13		83baf000000000		CMPL $0x0, 0xf0(DX)	
  0x409d1a		0f8545080000		JNE 0x40a565		
	if mp.gsignal == getg() {
  0x409d20		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x409d29		48394250		CMPQ AX, 0x50(DX)	
  0x409d2d		0f8417080000		JE 0x40a54a		
	mp.mallocing = 1
  0x409d33		c782f000000001000000	MOVL $0x1, 0xf0(DX)	
	return getg().m.mcache
  0x409d3d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x409d46		488b4030		MOVQ 0x30(AX), AX	
	dataSize := size
  0x409d4a		488bb424a0000000	MOVQ 0xa0(SP), SI	
	c := gomcache()
  0x409d52		90			NOPL			
	return getg().m.mcache
  0x409d53		488b8060010000		MOVQ 0x160(AX), AX	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x409d5a		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x409d62		4885ff			TESTQ DI, DI		
  0x409d65		0f8472070000		JE 0x40a4dd		
  0x409d6b		440fb64717		MOVZX 0x17(DI), R8	
  0x409d70		41f6c080		TESTL $0x80, R8		
  0x409d74		410f95c0		SETNE R8		
	return _g_.m
  0x409d78		4889542458		MOVQ DX, 0x58(SP)	
	dataSize := size
  0x409d7d		4889742438		MOVQ SI, 0x38(SP)	
	return getg().m.mcache
  0x409d82		4889442460		MOVQ AX, 0x60(SP)	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x409d87		448844242f		MOVB R8, 0x2f(SP)	
	if assistG != nil {
  0x409d8c		48895c2468		MOVQ BX, 0x68(SP)	
	if size <= maxSmallSize {
  0x409d91		4881fe00800000		CMPQ $0x8000, SI	
  0x409d98		0f8780060000		JA 0x40a41e		
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x409d9e		4584c0			TESTL R8, R8		
		if noscan && size < maxTinySize {
  0x409da1		0f8491040000		JE 0x40a238		
  0x409da7		4883fe10		CMPQ $0x10, SI		
  0x409dab		0f8387040000		JAE 0x40a238		
			off := c.tinyoffset
  0x409db1		4c8b4818		MOVQ 0x18(AX), R9	
			if size&7 == 0 {
  0x409db5		48f7c607000000		TESTQ $0x7, SI		
  0x409dbc		0f8548040000		JNE 0x40a20a		
				off = round(off, 8)
  0x409dc2		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x409dc3		4983c107		ADDQ $0x7, R9		
  0x409dc7		4983e1f8		ANDQ $-0x8, R9		
			if off+size <= maxTinySize && c.tiny != 0 {
  0x409dcb		4d8d1431		LEAQ 0(R9)(SI*1), R10	
  0x409dcf		4983fa10		CMPQ $0x10, R10		
  0x409dd3		7766			JA 0x409e3b		
  0x409dd5		4c8b5810		MOVQ 0x10(AX), R11	
  0x409dd9		4d85db			TESTQ R11, R11		
  0x409ddc		745d			JE 0x409e3b		
				x = unsafe.Pointer(c.tiny + off)
  0x409dde		4b8d0c0b		LEAQ 0(R11)(R9*1), CX	
				c.tinyoffset = off + size
  0x409de2		4c895018		MOVQ R10, 0x18(AX)	
				c.local_tinyallocs++
  0x409de6		48ff4020		INCQ 0x20(AX)		
				mp.mallocing = 0
  0x409dea		c782f000000000000000	MOVL $0x0, 0xf0(DX)	
				releasem(mp)
  0x409df4		90			NOPL			
	_g_ := getg()
  0x409df5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x409dfe		8b9a08010000		MOVL 0x108(DX), BX	
  0x409e04		8d73ff			LEAL -0x1(BX), SI	
  0x409e07		89b208010000		MOVL SI, 0x108(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x409e0d		83fb01			CMPL $0x1, BX		
  0x409e10		7511			JNE 0x409e23		
  0x409e12		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x409e19		7408			JE 0x409e23		
		_g_.stackguard0 = stackPreempt
  0x409e1b		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
				return x
  0x409e23		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x409e2b		488bac2490000000	MOVQ 0x90(SP), BP	
  0x409e33		4881c498000000		ADDQ $0x98, SP		
  0x409e3a		c3			RET			
			span := c.alloc[tinySpanClass]
  0x409e3b		4c8b4850		MOVQ 0x50(AX), R9	
	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
  0x409e3f		4d8b5140		MOVQ 0x40(R9), R10	
  0x409e43		4d0fbcda		BSFQ R10, R11		
  0x409e47		41bc40000000		MOVL $0x40, R12		
  0x409e4d		4d0f44dc		CMOVE R12, R11		
			v := nextFreeFast(span)
  0x409e51		90			NOPL			
	if theBit < 64 {
  0x409e52		4983fb40		CMPQ $0x40, R11		
  0x409e56		0f8da7030000		JGE 0x40a203		
		result := s.freeindex + uintptr(theBit)
  0x409e5c		4d8b6130		MOVQ 0x30(R9), R12	
  0x409e60		4f8d2c1c		LEAQ 0(R12)(R11*1), R13	
		if result < s.nelems {
  0x409e64		4d8b7138		MOVQ 0x38(R9), R14	
  0x409e68		4d39f5			CMPQ R14, R13		
  0x409e6b		0f8392030000		JAE 0x40a203		
			freeidx := result + 1
  0x409e71		4f8d241c		LEAQ 0(R12)(R11*1), R12	
  0x409e75		4d8d642401		LEAQ 0x1(R12), R12	
			if freeidx%64 == 0 && freeidx != s.nelems {
  0x409e7a		49f7c43f000000		TESTQ $0x3f, R12	
  0x409e81		0f8544030000		JNE 0x40a1cb		
  0x409e87		4d39f4			CMPQ R14, R12		
  0x409e8a		0f843b030000		JE 0x40a1cb		
  0x409e90		31c9			XORL CX, CX		
			if v == 0 {
  0x409e92		4885c9			TESTQ CX, CX		
  0x409e95		0f84f0020000		JE 0x40a18b		
  0x409e9b		4531c9			XORL R9, R9		
			(*[2]uint64)(x)[1] = 0
  0x409e9e		0f57c0			XORPS X0, X0		
  0x409ea1		0f1101			MOVUPS X0, 0(CX)	
			if size < c.tinyoffset || c.tiny == 0 {
  0x409ea4		4c8b5018		MOVQ 0x18(AX), R10	
  0x409ea8		4c399424a0000000	CMPQ R10, 0xa0(SP)	
  0x409eb0		0f83c2020000		JAE 0x40a178		
				c.tiny = uintptr(x)
  0x409eb6		4989ca			MOVQ CX, R10		
  0x409eb9		48894810		MOVQ CX, 0x10(AX)	
				c.tinyoffset = size
  0x409ebd		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x409ec5		48894818		MOVQ CX, 0x18(AX)	
			size = maxTinySize
  0x409ec9		48c78424a000000010000000	MOVQ $0x10, 0xa0(SP)	
	return x
  0x409ed5		4c89542440		MOVQ R10, 0x40(SP)	
	if shouldhelpgc {
  0x409eda		44884c242e		MOVB R9, 0x2e(SP)	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x409edf		4584c0			TESTL R8, R8		
	if !noscan {
  0x409ee2		0f840f020000		JE 0x40a0f7		
  0x409ee8		31c9			XORL CX, CX		
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x409eea		4889742438		MOVQ SI, 0x38(SP)	
		gcmarknewobject(uintptr(x), size, scanSize)
  0x409eef		48894c2430		MOVQ CX, 0x30(SP)	
	publicationBarrier()
  0x409ef4		e897ef0300		CALL runtime.publicationBarrier(SB)	
	if gcphase != _GCoff {
  0x409ef9		833ddc2d0d0000		CMPL $0x0, runtime.gcphase(SB)	
  0x409f00		0f85c7010000		JNE 0x40a0cd			
	mp.mallocing = 0
  0x409f06		488b442458		MOVQ 0x58(SP), AX	
  0x409f0b		c780f000000000000000	MOVL $0x0, 0xf0(AX)	
	releasem(mp)
  0x409f15		90			NOPL			
	_g_ := getg()
  0x409f16		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	mp.locks--
  0x409f1f		8b9008010000		MOVL 0x108(AX), DX	
  0x409f25		8d5aff			LEAL -0x1(DX), BX	
  0x409f28		899808010000		MOVL BX, 0x108(AX)	
	if mp.locks == 0 && _g_.preempt {
  0x409f2e		83fa01			CMPL $0x1, DX		
  0x409f31		7511			JNE 0x409f44		
  0x409f33		80b9b100000000		CMPB $0x0, 0xb1(CX)	
  0x409f3a		7408			JE 0x409f44		
		_g_.stackguard0 = stackPreempt
  0x409f3c		48c74110defaffff	MOVQ $-0x522, 0x10(CX)	
	if debug.allocfreetrace != 0 {
  0x409f44		833d952f0d0000		CMPL $0x0, runtime.debug(SB)	
  0x409f4b		0f854f010000		JNE 0x40a0a0			
	if rate := MemProfileRate; rate > 0 {
  0x409f51		488b05d0500b00		MOVQ runtime.MemProfileRate(SB), AX	
  0x409f58		4885c0			TESTQ AX, AX				
  0x409f5b		7e25			JLE 0x409f82				
		if rate != 1 && int32(size) < c.next_sample {
  0x409f5d		4883f801		CMPQ $0x1, AX		
  0x409f61		0f84bb000000		JE 0x40a022		
  0x409f67		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x409f6f		488b4c2460		MOVQ 0x60(SP), CX	
  0x409f74		8b11			MOVL 0(CX), DX		
  0x409f76		39d0			CMPL DX, AX		
  0x409f78		0f8da4000000		JGE 0x40a022		
			c.next_sample -= int32(size)
  0x409f7e		29c2			SUBL AX, DX		
  0x409f80		8911			MOVL DX, 0(CX)		
	if assistG != nil {
  0x409f82		488b442468		MOVQ 0x68(SP), AX	
  0x409f87		4885c0			TESTQ AX, AX		
  0x409f8a		7417			JE 0x409fa3		
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x409f8c		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x409f94		488b542438		MOVQ 0x38(SP), DX	
  0x409f99		4829d1			SUBQ DX, CX		
  0x409f9c		48298870010000		SUBQ CX, 0x170(AX)	
	if shouldhelpgc {
  0x409fa3		0fb644242e		MOVZX 0x2e(SP), AX	
  0x409fa8		84c0			TESTL AL, AL		
  0x409faa		7419			JE 0x409fc5		
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x409fac		90			NOPL			
	if !memstats.enablegc || panicking != 0 {
  0x409fad		803d7c4d0d0000		CMPB $0x0, runtime.memstats+4304(SB)	
  0x409fb4		7409			JE 0x409fbf				
  0x409fb6		833d372d0d0000		CMPL $0x0, runtime.panicking(SB)	
  0x409fbd		7443			JE 0x40a002				
  0x409fbf		31c0			XORL AX, AX				
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x409fc1		84c0			TESTL AL, AL		
  0x409fc3		751d			JNE 0x409fe2		
	return x
  0x409fc5		488b442440		MOVQ 0x40(SP), AX	
  0x409fca		48898424b8000000	MOVQ AX, 0xb8(SP)	
  0x409fd2		488bac2490000000	MOVQ 0x90(SP), BP	
  0x409fda		4881c498000000		ADDQ $0x98, SP		
  0x409fe1		c3			RET			
			gcStart(t)
  0x409fe2		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x409fea		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x409ff3		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x409ffb		e8d0920000		CALL runtime.gcStart(SB)	
  0x40a000		ebc3			JMP 0x409fc5			
	if gcphase != _GCoff {
  0x40a002		833dd32c0d0000		CMPL $0x0, runtime.gcphase(SB)	
  0x40a009		7404			JE 0x40a00f			
  0x40a00b		31c0			XORL AX, AX			
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x40a00d		ebb2			JMP 0x409fc1		
		return memstats.heap_live >= memstats.gc_trigger
  0x40a00f		488b0d82530d00		MOVQ runtime.memstats+5944(SB), CX	
  0x40a016		48390d83530d00		CMPQ CX, runtime.memstats+5952(SB)	
  0x40a01d		0f93c0			SETAE AL				
		if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {
  0x40a020		eb9f			JMP 0x409fc1		
	_g_ := getg()
  0x40a022		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x40a02b		488b4830		MOVQ 0x30(AX), CX	
			mp := acquirem()
  0x40a02f		90			NOPL			
	_g_.m.locks++
  0x40a030		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x40a036		488b4030		MOVQ 0x30(AX), AX	
  0x40a03a		4889442450		MOVQ AX, 0x50(SP)	
			profilealloc(mp, x, size)
  0x40a03f		48890424		MOVQ AX, 0(SP)			
  0x40a043		488b4c2440		MOVQ 0x40(SP), CX		
  0x40a048		48894c2408		MOVQ CX, 0x8(SP)		
  0x40a04d		488b9424a0000000	MOVQ 0xa0(SP), DX		
  0x40a055		4889542410		MOVQ DX, 0x10(SP)		
  0x40a05a		e821080000		CALL runtime.profilealloc(SB)	
			releasem(mp)
  0x40a05f		90			NOPL			
	_g_ := getg()
  0x40a060		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x40a069		488b4c2450		MOVQ 0x50(SP), CX	
  0x40a06e		8b9108010000		MOVL 0x108(CX), DX	
  0x40a074		8d5aff			LEAL -0x1(DX), BX	
  0x40a077		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x40a07d		83fa01			CMPL $0x1, DX		
  0x40a080		0f85fcfeffff		JNE 0x409f82		
  0x40a086		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x40a08d		0f84effeffff		JE 0x409f82		
		_g_.stackguard0 = stackPreempt
  0x40a093		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x40a09b		e9e2feffff		JMP 0x409f82		
		tracealloc(x, size, typ)
  0x40a0a0		488b442440		MOVQ 0x40(SP), AX		
  0x40a0a5		48890424		MOVQ AX, 0(SP)			
  0x40a0a9		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x40a0b1		48894c2408		MOVQ CX, 0x8(SP)		
  0x40a0b6		488b8c24a8000000	MOVQ 0xa8(SP), CX		
  0x40a0be		48894c2410		MOVQ CX, 0x10(SP)		
  0x40a0c3		e828620100		CALL runtime.tracealloc(SB)	
  0x40a0c8		e984feffff		JMP 0x409f51			
		gcmarknewobject(uintptr(x), size, scanSize)
  0x40a0cd		488b442440		MOVQ 0x40(SP), AX			
  0x40a0d2		48890424		MOVQ AX, 0(SP)				
  0x40a0d6		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x40a0de		4889442408		MOVQ AX, 0x8(SP)			
  0x40a0e3		488b442430		MOVQ 0x30(SP), AX			
  0x40a0e8		4889442410		MOVQ AX, 0x10(SP)			
  0x40a0ed		e82ef60000		CALL runtime.gcmarknewobject(SB)	
  0x40a0f2		e90ffeffff		JMP 0x409f06				
		if typ == deferType {
  0x40a0f7		48393d4a780b00		CMPQ DI, runtime.deferType(SB)	
		heapBitsSetType(uintptr(x), size, dataSize, typ)
  0x40a0fe		4c891424		MOVQ R10, 0(SP)				
  0x40a102		488b8c24a0000000	MOVQ 0xa0(SP), CX			
  0x40a10a		48894c2408		MOVQ CX, 0x8(SP)			
  0x40a10f		b930000000		MOVL $0x30, CX				
  0x40a114		480f44f1		CMOVE CX, SI				
  0x40a118		4889742438		MOVQ SI, 0x38(SP)			
  0x40a11d		4889742410		MOVQ SI, 0x10(SP)			
  0x40a122		48897c2418		MOVQ DI, 0x18(SP)			
  0x40a127		e8d44f0000		CALL runtime.heapBitsSetType(SB)	
		if dataSize > typ.size {
  0x40a12c		488b8424a8000000	MOVQ 0xa8(SP), AX	
  0x40a134		488b08			MOVQ 0(AX), CX		
  0x40a137		488b542438		MOVQ 0x38(SP), DX	
  0x40a13c		4839ca			CMPQ CX, DX		
		if typ == deferType {
  0x40a13f		762b			JBE 0x40a16c		
			if typ.ptrdata != 0 {
  0x40a141		488b5808		MOVQ 0x8(AX), BX	
				scanSize = dataSize - typ.size + typ.ptrdata
  0x40a145		4889d6			MOVQ DX, SI		
  0x40a148		4829ca			SUBQ CX, DX		
  0x40a14b		488d0c1a		LEAQ 0(DX)(BX*1), CX	
			if typ.ptrdata != 0 {
  0x40a14f		4885db			TESTQ BX, BX		
		c.local_scan += scanSize
  0x40a152		ba00000000		MOVL $0x0, DX		
  0x40a157		480f45d1		CMOVNE CX, DX		
  0x40a15b		488b5c2460		MOVQ 0x60(SP), BX	
  0x40a160		48015308		ADDQ DX, 0x8(BX)	
		gcmarknewobject(uintptr(x), size, scanSize)
  0x40a164		4889d1			MOVQ DX, CX		
		c.local_scan += scanSize
  0x40a167		e97efdffff		JMP 0x409eea		
			scanSize = typ.ptrdata
  0x40a16c		488b4808		MOVQ 0x8(AX), CX	
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a170		4889d6			MOVQ DX, SI		
		c.local_scan += scanSize
  0x40a173		4889ca			MOVQ CX, DX		
			scanSize = typ.ptrdata
  0x40a176		ebe3			JMP 0x40a15b		
			if size < c.tinyoffset || c.tiny == 0 {
  0x40a178		4883781000		CMPQ $0x0, 0x10(AX)	
  0x40a17d		0f8433fdffff		JE 0x409eb6		
	return x
  0x40a183		4989ca			MOVQ CX, R10		
			size = maxTinySize
  0x40a186		e93efdffff		JMP 0x409ec9		
				v, _, shouldhelpgc = c.nextFree(tinySpanClass)
  0x40a18b		48890424		MOVQ AX, 0(SP)				
  0x40a18f		c644240805		MOVB $0x5, 0x8(SP)			
  0x40a194		e847f8ffff		CALL runtime.(*mcache).nextFree(SB)	
  0x40a199		488b4c2410		MOVQ 0x10(SP), CX			
  0x40a19e		440fb64c2420		MOVZX 0x20(SP), R9			
			if size < c.tinyoffset || c.tiny == 0 {
  0x40a1a4		488b442460		MOVQ 0x60(SP), AX	
	mp.mallocing = 0
  0x40a1a9		488b542458		MOVQ 0x58(SP), DX	
	if assistG != nil {
  0x40a1ae		488b5c2468		MOVQ 0x68(SP), BX	
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a1b3		488b742438		MOVQ 0x38(SP), SI	
		if typ == deferType {
  0x40a1b8		488bbc24a8000000	MOVQ 0xa8(SP), DI	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a1c0		440fb644242f		MOVZX 0x2f(SP), R8	
				v, _, shouldhelpgc = c.nextFree(tinySpanClass)
  0x40a1c6		e9d3fcffff		JMP 0x409e9e		
			s.allocCache >>= uint(theBit + 1)
  0x40a1cb		498d4b01		LEAQ 0x1(R11), CX	
  0x40a1cf		4883f940		CMPQ $0x40, CX		
  0x40a1d3		4d19db			SBBQ R11, R11		
  0x40a1d6		49d3ea			SHRQ CL, R10		
  0x40a1d9		4d21da			ANDQ R11, R10		
  0x40a1dc		4d895140		MOVQ R10, 0x40(R9)	
			s.freeindex = freeidx
  0x40a1e0		4d896130		MOVQ R12, 0x30(R9)	
			s.allocCount++
  0x40a1e4		450fb75160		MOVZX 0x60(R9), R10	
  0x40a1e9		41ffc2			INCL R10		
  0x40a1ec		6645895160		MOVW R10, 0x60(R9)	
			return gclinkptr(result*s.elemsize + s.base())
  0x40a1f1		498b4968		MOVQ 0x68(R9), CX	
  0x40a1f5		490fafcd		IMULQ R13, CX		
  0x40a1f9		49034918		ADDQ 0x18(R9), CX	
  0x40a1fd		90			NOPL			
			v := nextFreeFast(span)
  0x40a1fe		e98ffcffff		JMP 0x409e92		
  0x40a203		31c9			XORL CX, CX		
  0x40a205		e988fcffff		JMP 0x409e92		
			} else if size&3 == 0 {
  0x40a20a		48f7c603000000		TESTQ $0x3, SI		
  0x40a211		750e			JNE 0x40a221		
				off = round(off, 4)
  0x40a213		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x40a214		4983c103		ADDQ $0x3, R9		
  0x40a218		4983e1fc		ANDQ $-0x4, R9		
				off = round(off, 4)
  0x40a21c		e9aafbffff		JMP 0x409dcb		
			} else if size&1 == 0 {
  0x40a221		0fbae600		BTL $0x0, SI		
  0x40a225		0f82a0fbffff		JB 0x409dcb		
				off = round(off, 2)
  0x40a22b		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x40a22c		49ffc1			INCQ R9			
  0x40a22f		4983e1fe		ANDQ $-0x2, R9		
				off = round(off, 2)
  0x40a233		e993fbffff		JMP 0x409dcb		
			if size <= smallSizeMax-8 {
  0x40a238		4881fef8030000		CMPQ $0x3f8, SI		
  0x40a23f		0f87b0010000		JA 0x40a3f5		
				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
  0x40a245		4c8d4e07		LEAQ 0x7(SI), R9			
  0x40a249		49c1e903		SHRQ $0x3, R9				
  0x40a24d		4981f981000000		CMPQ $0x81, R9				
  0x40a254		0f83e9020000		JAE 0x40a543				
  0x40a25a		4c8d15df4e0b00		LEAQ runtime.size_to_class8(SB), R10	
  0x40a261		470fb60c11		MOVZX 0(R9)(R10*1), R9			
			size = uintptr(class_to_size[sizeclass])
  0x40a266		4983f943		CMPQ $0x43, R9				
  0x40a26a		0f83c5020000		JAE 0x40a535				
  0x40a270		4c8d15694f0b00		LEAQ runtime.class_to_size(SB), R10	
  0x40a277		470fb7144a		MOVZX 0(R10)(R9*2), R10			
  0x40a27c		4c899424a0000000	MOVQ R10, 0xa0(SP)			
			span := c.alloc[spc]
  0x40a284		8400			TESTB AL, 0(AX)		
			spc := makeSpanClass(sizeclass, noscan)
  0x40a286		90			NOPL			
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40a287		41d1e1			SHLL $0x1, R9		
	return int(uint8(*(*uint8)(unsafe.Pointer(&x))))
  0x40a28a		450fb6d0		MOVZX R8, R10		
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40a28e		4509d1			ORL R10, R9		
			span := c.alloc[spc]
  0x40a291		450fb6d1		MOVZX R9, R10		
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40a295		90			NOPL			
			span := c.alloc[spc]
  0x40a296		4981fa86000000		CMPQ $0x86, R10			
  0x40a29d		0f838b020000		JAE 0x40a52e			
  0x40a2a3		4e8b54d028		MOVQ 0x28(AX)(R10*8), R10	
	theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
  0x40a2a8		4d8b5a40		MOVQ 0x40(R10), R11	
  0x40a2ac		4d0fbce3		BSFQ R11, R12		
  0x40a2b0		41bd40000000		MOVL $0x40, R13		
  0x40a2b6		4d0f44e5		CMOVE R13, R12		
			v := nextFreeFast(span)
  0x40a2ba		90			NOPL			
	if theBit < 64 {
  0x40a2bb		4983fc40		CMPQ $0x40, R12		
  0x40a2bf		0f8d29010000		JGE 0x40a3ee		
		result := s.freeindex + uintptr(theBit)
  0x40a2c5		4d8b6a30		MOVQ 0x30(R10), R13	
  0x40a2c9		4f8d742500		LEAQ 0(R13)(R12*1), R14	
		if result < s.nelems {
  0x40a2ce		4d8b7a38		MOVQ 0x38(R10), R15	
  0x40a2d2		4d39fe			CMPQ R15, R14		
  0x40a2d5		0f8313010000		JAE 0x40a3ee		
			freeidx := result + 1
  0x40a2db		4f8d6c2500		LEAQ 0(R13)(R12*1), R13	
  0x40a2e0		4d8d6d01		LEAQ 0x1(R13), R13	
			if freeidx%64 == 0 && freeidx != s.nelems {
  0x40a2e4		49f7c53f000000		TESTQ $0x3f, R13	
  0x40a2eb		0f85c4000000		JNE 0x40a3b5		
  0x40a2f1		4d39fd			CMPQ R15, R13		
  0x40a2f4		0f84bb000000		JE 0x40a3b5		
  0x40a2fa		31c9			XORL CX, CX		
			if v == 0 {
  0x40a2fc		4885c9			TESTQ CX, CX		
  0x40a2ff		746f			JE 0x40a370		
  0x40a301		4531c9			XORL R9, R9		
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x40a304		440fb69c24b0000000	MOVZX 0xb0(SP), R11	
  0x40a30d		4584db			TESTL R11, R11		
			if needzero && span.needzero != 0 {
  0x40a310		7407			JE 0x40a319		
  0x40a312		41807a6400		CMPB $0x0, 0x64(R10)	
  0x40a317		7508			JNE 0x40a321		
	return x
  0x40a319		4989ca			MOVQ CX, R10		
	if !noscan {
  0x40a31c		e9b4fbffff		JMP 0x409ed5		
			x = unsafe.Pointer(v)
  0x40a321		48894c2440		MOVQ CX, 0x40(SP)	
	if shouldhelpgc {
  0x40a326		44884c242e		MOVB R9, 0x2e(SP)	
				memclrNoHeapPointers(unsafe.Pointer(v), size)
  0x40a32b		48890c24		MOVQ CX, 0(SP)				
  0x40a32f		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x40a337		4889442408		MOVQ AX, 0x8(SP)			
  0x40a33c		e87f010400		CALL runtime.memclrNoHeapPointers(SB)	
		if rate != 1 && int32(size) < c.next_sample {
  0x40a341		488b442460		MOVQ 0x60(SP), AX	
	return x
  0x40a346		488b4c2440		MOVQ 0x40(SP), CX	
	mp.mallocing = 0
  0x40a34b		488b542458		MOVQ 0x58(SP), DX	
	if assistG != nil {
  0x40a350		488b5c2468		MOVQ 0x68(SP), BX	
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a355		488b742438		MOVQ 0x38(SP), SI	
		if typ == deferType {
  0x40a35a		488bbc24a8000000	MOVQ 0xa8(SP), DI	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a362		440fb644242f		MOVZX 0x2f(SP), R8	
	if shouldhelpgc {
  0x40a368		440fb64c242e		MOVZX 0x2e(SP), R9	
				memclrNoHeapPointers(unsafe.Pointer(v), size)
  0x40a36e		eba9			JMP 0x40a319		
				v, span, shouldhelpgc = c.nextFree(spc)
  0x40a370		48890424		MOVQ AX, 0(SP)				
  0x40a374		44884c2408		MOVB R9, 0x8(SP)			
  0x40a379		e862f6ffff		CALL runtime.(*mcache).nextFree(SB)	
  0x40a37e		488b4c2410		MOVQ 0x10(SP), CX			
  0x40a383		4c8b542418		MOVQ 0x18(SP), R10			
  0x40a388		440fb64c2420		MOVZX 0x20(SP), R9			
		if rate != 1 && int32(size) < c.next_sample {
  0x40a38e		488b442460		MOVQ 0x60(SP), AX	
	mp.mallocing = 0
  0x40a393		488b542458		MOVQ 0x58(SP), DX	
	if assistG != nil {
  0x40a398		488b5c2468		MOVQ 0x68(SP), BX	
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a39d		488b742438		MOVQ 0x38(SP), SI	
		if typ == deferType {
  0x40a3a2		488bbc24a8000000	MOVQ 0xa8(SP), DI	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a3aa		440fb644242f		MOVZX 0x2f(SP), R8	
				v, span, shouldhelpgc = c.nextFree(spc)
  0x40a3b0		e94fffffff		JMP 0x40a304		
			s.allocCache >>= uint(theBit + 1)
  0x40a3b5		498d4c2401		LEAQ 0x1(R12), CX	
  0x40a3ba		4883f940		CMPQ $0x40, CX		
  0x40a3be		4d19e4			SBBQ R12, R12		
  0x40a3c1		49d3eb			SHRQ CL, R11		
  0x40a3c4		4d21e3			ANDQ R12, R11		
  0x40a3c7		4d895a40		MOVQ R11, 0x40(R10)	
			s.freeindex = freeidx
  0x40a3cb		4d896a30		MOVQ R13, 0x30(R10)	
			s.allocCount++
  0x40a3cf		450fb75a60		MOVZX 0x60(R10), R11	
  0x40a3d4		41ffc3			INCL R11		
  0x40a3d7		6645895a60		MOVW R11, 0x60(R10)	
			return gclinkptr(result*s.elemsize + s.base())
  0x40a3dc		498b4a68		MOVQ 0x68(R10), CX	
  0x40a3e0		490fafce		IMULQ R14, CX		
  0x40a3e4		49034a18		ADDQ 0x18(R10), CX	
  0x40a3e8		90			NOPL			
			v := nextFreeFast(span)
  0x40a3e9		e90effffff		JMP 0x40a2fc		
  0x40a3ee		31c9			XORL CX, CX		
  0x40a3f0		e907ffffff		JMP 0x40a2fc		
				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
  0x40a3f5		4c8d8e7ffcffff		LEAQ 0xfffffc7f(SI), R9			
  0x40a3fc		49c1e907		SHRQ $0x7, R9				
  0x40a400		4981f9f9000000		CMPQ $0xf9, R9				
  0x40a407		0f832f010000		JAE 0x40a53c				
  0x40a40d		4c8d156c4e0b00		LEAQ runtime.size_to_class128(SB), R10	
  0x40a414		470fb60c0a		MOVZX 0(R10)(R9*1), R9			
  0x40a419		e948feffff		JMP 0x40a266				
		var s *mspan
  0x40a41e		48c744244800000000	MOVQ $0x0, 0x48(SP)	
		systemstack(func() {
  0x40a427		0f57c0			XORPS X0, X0				
  0x40a42a		0f11442470		MOVUPS X0, 0x70(SP)			
  0x40a42f		0f11842480000000	MOVUPS X0, 0x80(SP)			
  0x40a437		488d05b2a60300		LEAQ runtime.mallocgc.func1(SB), AX	
  0x40a43e		4889442470		MOVQ AX, 0x70(SP)			
  0x40a443		488d8424a0000000	LEAQ 0xa0(SP), AX			
  0x40a44b		4889442478		MOVQ AX, 0x78(SP)			
  0x40a450		0fb68424b0000000	MOVZX 0xb0(SP), AX			
  0x40a458		88842480000000		MOVB AL, 0x80(SP)			
  0x40a45f		4488842481000000	MOVB R8, 0x81(SP)			
  0x40a467		488d442448		LEAQ 0x48(SP), AX			
  0x40a46c		4889842488000000	MOVQ AX, 0x88(SP)			
  0x40a474		488d442470		LEAQ 0x70(SP), AX			
  0x40a479		48890424		MOVQ AX, 0(SP)				
  0x40a47d		e8aed20300		CALL runtime.systemstack(SB)		
		s.freeindex = 1
  0x40a482		488b442448		MOVQ 0x48(SP), AX	
  0x40a487		48c7403001000000	MOVQ $0x1, 0x30(AX)	
		s.allocCount = 1
  0x40a48f		488b442448		MOVQ 0x48(SP), AX	
  0x40a494		66c740600100		MOVW $0x1, 0x60(AX)	
		x = unsafe.Pointer(s.base())
  0x40a49a		488b442448		MOVQ 0x48(SP), AX	
	return s.startAddr
  0x40a49f		4c8b5018		MOVQ 0x18(AX), R10	
		x = unsafe.Pointer(s.base())
  0x40a4a3		90			NOPL			
		size = s.elemsize
  0x40a4a4		488b4068		MOVQ 0x68(AX), AX	
  0x40a4a8		48898424a0000000	MOVQ AX, 0xa0(SP)	
		if rate != 1 && int32(size) < c.next_sample {
  0x40a4b0		488b442460		MOVQ 0x60(SP), AX	
	mp.mallocing = 0
  0x40a4b5		488b542458		MOVQ 0x58(SP), DX	
	if assistG != nil {
  0x40a4ba		488b5c2468		MOVQ 0x68(SP), BX	
		assistG.gcAssistBytes -= int64(size - dataSize)
  0x40a4bf		488b742438		MOVQ 0x38(SP), SI	
		if typ == deferType {
  0x40a4c4		488bbc24a8000000	MOVQ 0xa8(SP), DI	
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a4cc		440fb644242f		MOVZX 0x2f(SP), R8	
  0x40a4d2		41b901000000		MOVL $0x1, R9		
		size = s.elemsize
  0x40a4d8		e9f8f9ffff		JMP 0x409ed5		
  0x40a4dd		41b801000000		MOVL $0x1, R8		
	noscan := typ == nil || typ.kind&kindNoPointers != 0
  0x40a4e3		e990f8ffff		JMP 0x409d78		
		assistG.gcAssistBytes -= int64(size)
  0x40a4e8		48895c2468		MOVQ BX, 0x68(SP)	
			gcAssistAlloc(assistG)
  0x40a4ed		48891c24		MOVQ BX, 0(SP)			
  0x40a4f1		e86ac90000		CALL runtime.gcAssistAlloc(SB)	
	if assistG != nil {
  0x40a4f6		488b5c2468		MOVQ 0x68(SP), BX	
			gcAssistAlloc(assistG)
  0x40a4fb		e9f9f7ffff		JMP 0x409cf9		
		assistG.gcAssistBytes -= int64(size)
  0x40a500		4889d3			MOVQ DX, BX		
		if assistG.m.curg != nil {
  0x40a503		e9d7f7ffff		JMP 0x409cdf		
  0x40a508		31db			XORL BX, BX		
	if gcBlackenEnabled != 0 {
  0x40a50a		e9eaf7ffff		JMP 0x409cf9		
		return unsafe.Pointer(&zerobase)
  0x40a50f		488d05fa280d00		LEAQ runtime.zerobase(SB), AX	
  0x40a516		48898424b8000000	MOVQ AX, 0xb8(SP)		
  0x40a51e		488bac2490000000	MOVQ 0x90(SP), BP		
  0x40a526		4881c498000000		ADDQ $0x98, SP			
  0x40a52d		c3			RET				
			span := c.alloc[spc]
  0x40a52e		e8ed790100		CALL runtime.panicindex(SB)	
  0x40a533		0f0b			UD2				
			size = uintptr(class_to_size[sizeclass])
  0x40a535		e8e6790100		CALL runtime.panicindex(SB)	
  0x40a53a		0f0b			UD2				
				sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
  0x40a53c		e8df790100		CALL runtime.panicindex(SB)	
  0x40a541		0f0b			UD2				
				sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
  0x40a543		e8d8790100		CALL runtime.panicindex(SB)	
  0x40a548		0f0b			UD2				
		throw("malloc during signal")
  0x40a54a		488d055c610600		LEAQ 0x6615c(IP), AX	
  0x40a551		48890424		MOVQ AX, 0(SP)		
  0x40a555		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x40a55e		e81d8f0100		CALL runtime.throw(SB)	
  0x40a563		0f0b			UD2			
		throw("malloc deadlock")
  0x40a565		488d0524590600		LEAQ 0x65924(IP), AX	
  0x40a56c		48890424		MOVQ AX, 0(SP)		
  0x40a570		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x40a579		e8028f0100		CALL runtime.throw(SB)	
  0x40a57e		0f0b			UD2			
		throw("mallocgc called with gcphase == _GCmarktermination")
  0x40a580		488d054e8c0600		LEAQ 0x68c4e(IP), AX	
  0x40a587		48890424		MOVQ AX, 0(SP)		
  0x40a58b		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x40a594		e8e78e0100		CALL runtime.throw(SB)	
  0x40a599		0f0b			UD2			
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  0x40a59b		e8e0d20300		CALL runtime.morestack_noctxt(SB)	
  0x40a5a0		e96bf6ffff		JMP runtime.mallocgc(SB)		

TEXT runtime.largeAlloc(SB) /usr/local/go/src/runtime/malloc.go
func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {
  0x40a5b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a5b9		483b6110		CMPQ 0x10(CX), SP	
  0x40a5bd		0f8675010000		JBE 0x40a738		
  0x40a5c3		4883ec38		SUBQ $0x38, SP		
  0x40a5c7		48896c2430		MOVQ BP, 0x30(SP)	
  0x40a5cc		488d6c2430		LEAQ 0x30(SP), BP	
	if size+_PageSize < size {
  0x40a5d1		488b442440		MOVQ 0x40(SP), AX	
  0x40a5d6		488d8800200000		LEAQ 0x2000(AX), CX	
  0x40a5dd		4839c1			CMPQ AX, CX		
  0x40a5e0		0f8237010000		JB 0x40a71d		
	npages := size >> _PageShift
  0x40a5e6		4889c1			MOVQ AX, CX		
  0x40a5e9		48c1e80d		SHRQ $0xd, AX		
		npages++
  0x40a5ed		488d5001		LEAQ 0x1(AX), DX	
	if size&_PageMask != 0 {
  0x40a5f1		48f7c1ff1f0000		TESTQ $0x1fff, CX	
	deductSweepCredit(npages*_PageSize, npages)
  0x40a5f8		480f45c2		CMOVNE DX, AX				
  0x40a5fc		4889442420		MOVQ AX, 0x20(SP)			
  0x40a601		4889c2			MOVQ AX, DX				
  0x40a604		48c1e00d		SHLQ $0xd, AX				
  0x40a608		48890424		MOVQ AX, 0(SP)				
  0x40a60c		4889542408		MOVQ DX, 0x8(SP)			
  0x40a611		e89a0a0100		CALL runtime.deductSweepCredit(SB)	
	s := mheap_.alloc(npages, makeSpanClass(0, noscan), true, needzero)
  0x40a616		90			NOPL			
	return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))
  0x40a617		90			NOPL			
	s := mheap_.alloc(npages, makeSpanClass(0, noscan), true, needzero)
  0x40a618		488d0521c00b00		LEAQ runtime.mheap_(SB), AX	
  0x40a61f		48890424		MOVQ AX, 0(SP)			
  0x40a623		488b442420		MOVQ 0x20(SP), AX		
  0x40a628		4889442408		MOVQ AX, 0x8(SP)		
  0x40a62d		0fb6442449		MOVZX 0x49(SP), AX		
  0x40a632		88442410		MOVB AL, 0x10(SP)		
  0x40a636		c644241101		MOVB $0x1, 0x11(SP)		
  0x40a63b		0fb6442448		MOVZX 0x48(SP), AX		
  0x40a640		88442412		MOVB AL, 0x12(SP)		
  0x40a644		e8672e0100		CALL runtime.(*mheap).alloc(SB)	
  0x40a649		488b442418		MOVQ 0x18(SP), AX		
	if s == nil {
  0x40a64e		4885c0			TESTQ AX, AX		
	if size&_PageMask != 0 {
  0x40a651		0f84ab000000		JE 0x40a702		
	s.limit = s.base() + size
  0x40a657		90			NOPL			
	return s.startAddr
  0x40a658		488b4818		MOVQ 0x18(AX), CX	
	s.limit = s.base() + size
  0x40a65c		488b542440		MOVQ 0x40(SP), DX	
  0x40a661		4801d1			ADDQ DX, CX		
  0x40a664		48894878		MOVQ CX, 0x78(AX)	
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40a668		488b0de1c20b00		MOVQ runtime.mheap_+784(SB), CX	
  0x40a66f		8401			TESTB AL, 0(CX)			
	heapBitsForAddr(s.base()).initSpan(s)
  0x40a671		90			NOPL			
  0x40a672		90			NOPL			
	return s.startAddr
  0x40a673		488b5018		MOVQ 0x18(AX), DX	
	arena := arenaIndex(addr)
  0x40a677		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40a678		90			NOPL			
  0x40a679		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40a67a		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x40a684		4801d3			ADDQ DX, BX			
  0x40a687		48c1eb1a		SHRQ $0x1a, BX			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40a68b		4881fb00004000		CMPQ $0x400000, BX	
  0x40a692		7367			JAE 0x40a6fb		
  0x40a694		488b0cd9		MOVQ 0(CX)(BX*8), CX	
	if ha == nil {
  0x40a698		4885c9			TESTQ CX, CX		
  0x40a69b		7454			JE 0x40a6f1		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40a69d		4889d6			MOVQ DX, SI		
  0x40a6a0		48c1ea05		SHRQ $0x5, DX		
  0x40a6a4		4881e2ffff1f00		ANDQ $0x1fffff, DX	
  0x40a6ab		4801ca			ADDQ CX, DX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x40a6ae		48c1ee03		SHRQ $0x3, SI		
  0x40a6b2		4883e603		ANDQ $0x3, SI		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40a6b6		4881c1ffff1f00		ADDQ $0x1fffff, CX	
	s := mheap_.alloc(npages, makeSpanClass(0, noscan), true, needzero)
  0x40a6bd		4889442428		MOVQ AX, 0x28(SP)	
	heapBitsForAddr(s.base()).initSpan(s)
  0x40a6c2		48891424		MOVQ DX, 0(SP)				
  0x40a6c6		89742408		MOVL SI, 0x8(SP)			
  0x40a6ca		895c240c		MOVL BX, 0xc(SP)			
  0x40a6ce		48894c2410		MOVQ CX, 0x10(SP)			
  0x40a6d3		4889442418		MOVQ AX, 0x18(SP)			
  0x40a6d8		e8a3450000		CALL runtime.heapBits.initSpan(SB)	
	return s
  0x40a6dd		488b442428		MOVQ 0x28(SP), AX	
  0x40a6e2		4889442450		MOVQ AX, 0x50(SP)	
  0x40a6e7		488b6c2430		MOVQ 0x30(SP), BP	
  0x40a6ec		4883c438		ADDQ $0x38, SP		
  0x40a6f0		c3			RET			
  0x40a6f1		31c9			XORL CX, CX		
  0x40a6f3		31db			XORL BX, BX		
  0x40a6f5		31f6			XORL SI, SI		
  0x40a6f7		31d2			XORL DX, DX		
	heapBitsForAddr(s.base()).initSpan(s)
  0x40a6f9		ebc2			JMP 0x40a6bd		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40a6fb		e820780100		CALL runtime.panicindex(SB)	
  0x40a700		0f0b			UD2				
		throw("out of memory")
  0x40a702		488d0592550600		LEAQ 0x65592(IP), AX	
  0x40a709		48890424		MOVQ AX, 0(SP)		
  0x40a70d		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40a716		e8658d0100		CALL runtime.throw(SB)	
  0x40a71b		0f0b			UD2			
		throw("out of memory")
  0x40a71d		488d0577550600		LEAQ 0x65577(IP), AX	
  0x40a724		48890424		MOVQ AX, 0(SP)		
  0x40a728		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40a731		e84a8d0100		CALL runtime.throw(SB)	
  0x40a736		0f0b			UD2			
func largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {
  0x40a738		e843d10300		CALL runtime.morestack_noctxt(SB)	
  0x40a73d		e96efeffff		JMP runtime.largeAlloc(SB)		

TEXT runtime.newobject(SB) /usr/local/go/src/runtime/malloc.go
func newobject(typ *_type) unsafe.Pointer {
  0x40a750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a759		483b6110		CMPQ 0x10(CX), SP	
  0x40a75d		763d			JBE 0x40a79c		
  0x40a75f		4883ec28		SUBQ $0x28, SP		
  0x40a763		48896c2420		MOVQ BP, 0x20(SP)	
  0x40a768		488d6c2420		LEAQ 0x20(SP), BP	
	return mallocgc(typ.size, typ, true)
  0x40a76d		488b442430		MOVQ 0x30(SP), AX		
  0x40a772		488b08			MOVQ 0(AX), CX			
  0x40a775		48890c24		MOVQ CX, 0(SP)			
  0x40a779		4889442408		MOVQ AX, 0x8(SP)		
  0x40a77e		c644241001		MOVB $0x1, 0x10(SP)		
  0x40a783		e888f4ffff		CALL runtime.mallocgc(SB)	
  0x40a788		488b442418		MOVQ 0x18(SP), AX		
  0x40a78d		4889442438		MOVQ AX, 0x38(SP)		
  0x40a792		488b6c2420		MOVQ 0x20(SP), BP		
  0x40a797		4883c428		ADDQ $0x28, SP			
  0x40a79b		c3			RET				
func newobject(typ *_type) unsafe.Pointer {
  0x40a79c		e8dfd00300		CALL runtime.morestack_noctxt(SB)	
  0x40a7a1		ebad			JMP runtime.newobject(SB)		

TEXT runtime.newarray(SB) /usr/local/go/src/runtime/malloc.go
func newarray(typ *_type, n int) unsafe.Pointer {
  0x40a7b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a7b9		483b6110		CMPQ 0x10(CX), SP	
  0x40a7bd		0f86b1000000		JBE 0x40a874		
  0x40a7c3		4883ec28		SUBQ $0x28, SP		
  0x40a7c7		48896c2420		MOVQ BP, 0x20(SP)	
  0x40a7cc		488d6c2420		LEAQ 0x20(SP), BP	
	if n == 1 {
  0x40a7d1		488b442438		MOVQ 0x38(SP), AX	
  0x40a7d6		4883f801		CMPQ $0x1, AX		
  0x40a7da		744b			JE 0x40a827		
	mem, overflow := math.MulUintptr(typ.size, uintptr(n))
  0x40a7dc		488b4c2430		MOVQ 0x30(SP), CX	
  0x40a7e1		488b11			MOVQ 0(CX), DX		
func newarray(typ *_type, n int) unsafe.Pointer {
  0x40a7e4		4889c3			MOVQ AX, BX		
	mem, overflow := math.MulUintptr(typ.size, uintptr(n))
  0x40a7e7		48f7e2			MULQ DX			
	if overflow || mem > maxAlloc || n < 0 {
  0x40a7ea		706a			JO 0x40a856			
  0x40a7ec		48ba0000000000000100	MOVQ $0x1000000000000, DX	
  0x40a7f6		4839d0			CMPQ DX, AX			
  0x40a7f9		775b			JA 0x40a856			
  0x40a7fb		4885db			TESTQ BX, BX			
  0x40a7fe		7c56			JL 0x40a856			
	return mallocgc(mem, typ, true)
  0x40a800		48890424		MOVQ AX, 0(SP)			
  0x40a804		48894c2408		MOVQ CX, 0x8(SP)		
  0x40a809		c644241001		MOVB $0x1, 0x10(SP)		
  0x40a80e		e8fdf3ffff		CALL runtime.mallocgc(SB)	
  0x40a813		488b442418		MOVQ 0x18(SP), AX		
  0x40a818		4889442440		MOVQ AX, 0x40(SP)		
  0x40a81d		488b6c2420		MOVQ 0x20(SP), BP		
  0x40a822		4883c428		ADDQ $0x28, SP			
  0x40a826		c3			RET				
		return mallocgc(typ.size, typ, true)
  0x40a827		488b442430		MOVQ 0x30(SP), AX		
  0x40a82c		488b08			MOVQ 0(AX), CX			
  0x40a82f		48890c24		MOVQ CX, 0(SP)			
  0x40a833		4889442408		MOVQ AX, 0x8(SP)		
  0x40a838		c644241001		MOVB $0x1, 0x10(SP)		
  0x40a83d		e8cef3ffff		CALL runtime.mallocgc(SB)	
  0x40a842		488b442418		MOVQ 0x18(SP), AX		
  0x40a847		4889442440		MOVQ AX, 0x40(SP)		
  0x40a84c		488b6c2420		MOVQ 0x20(SP), BP		
  0x40a851		4883c428		ADDQ $0x28, SP			
  0x40a855		c3			RET				
		panic(plainError("runtime: allocation size out of range"))
  0x40a856		488d05a3480500		LEAQ 0x548a3(IP), AX			
  0x40a85d		48890424		MOVQ AX, 0(SP)				
  0x40a861		488d05f8260700		LEAQ runtime.statictmp_10(SB), AX	
  0x40a868		4889442408		MOVQ AX, 0x8(SP)			
  0x40a86d		e83e860100		CALL runtime.gopanic(SB)		
  0x40a872		0f0b			UD2					
func newarray(typ *_type, n int) unsafe.Pointer {
  0x40a874		e807d00300		CALL runtime.morestack_noctxt(SB)	
  0x40a879		e932ffffff		JMP runtime.newarray(SB)		

TEXT runtime.profilealloc(SB) /usr/local/go/src/runtime/malloc.go
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40a880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a889		483b6110		CMPQ 0x10(CX), SP	
  0x40a88d		7653			JBE 0x40a8e2		
  0x40a88f		4883ec18		SUBQ $0x18, SP		
  0x40a893		48896c2410		MOVQ BP, 0x10(SP)	
  0x40a898		488d6c2410		LEAQ 0x10(SP), BP	
	mp.mcache.next_sample = nextSample()
  0x40a89d		90			NOPL					
  0x40a89e		488b0583470b00		MOVQ runtime.MemProfileRate(SB), AX	
	return fastexprand(MemProfileRate)
  0x40a8a5		48890424		MOVQ AX, 0(SP)			
  0x40a8a9		e842000000		CALL runtime.fastexprand(SB)	
	mp.mcache.next_sample = nextSample()
  0x40a8ae		488b442420		MOVQ 0x20(SP), AX	
  0x40a8b3		488b8060010000		MOVQ 0x160(AX), AX	
	return fastexprand(MemProfileRate)
  0x40a8ba		8b4c2408		MOVL 0x8(SP), CX	
	mp.mcache.next_sample = nextSample()
  0x40a8be		8908			MOVL CX, 0(AX)		
	mProf_Malloc(x, size)
  0x40a8c0		488b442428		MOVQ 0x28(SP), AX		
  0x40a8c5		48890424		MOVQ AX, 0(SP)			
  0x40a8c9		488b442430		MOVQ 0x30(SP), AX		
  0x40a8ce		4889442408		MOVQ AX, 0x8(SP)		
  0x40a8d3		e8e8530100		CALL runtime.mProf_Malloc(SB)	
}
  0x40a8d8		488b6c2410		MOVQ 0x10(SP), BP	
  0x40a8dd		4883c418		ADDQ $0x18, SP		
  0x40a8e1		c3			RET			
func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
  0x40a8e2		e899cf0300		CALL runtime.morestack_noctxt(SB)	
  0x40a8e7		eb97			JMP runtime.profilealloc(SB)		

TEXT runtime.fastexprand(SB) /usr/local/go/src/runtime/malloc.go
func fastexprand(mean int) int32 {
  0x40a8f0		4883ec08		SUBQ $0x8, SP		
  0x40a8f4		48892c24		MOVQ BP, 0(SP)		
  0x40a8f8		488d2c24		LEAQ 0(SP), BP		
	case mean > 0x7000000:
  0x40a8fc		488b442410		MOVQ 0x10(SP), AX	
  0x40a901		483d00000007		CMPQ $0x7000000, AX	
  0x40a907		0f8e3f010000		JLE 0x40aa4c		
  0x40a90d		b800000007		MOVL $0x7000000, AX	
	mp := getg().m
  0x40a912		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40a91b		488b4930		MOVQ 0x30(CX), CX	
	q := fastrand()%(1<<randomBitCount) + 1
  0x40a91f		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40a920		8b9120010000		MOVL 0x120(CX), DX	
  0x40a926		8b9924010000		MOVL 0x124(CX), BX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40a92c		899920010000		MOVL BX, 0x120(CX)	
	s1 ^= s1 << 17
  0x40a932		89d6			MOVL DX, SI		
  0x40a934		c1e211			SHLL $0x11, DX		
  0x40a937		31f2			XORL SI, DX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x40a939		89de			MOVL BX, SI		
  0x40a93b		31d3			XORL DX, BX		
  0x40a93d		c1ea07			SHRL $0x7, DX		
  0x40a940		31da			XORL BX, DX		
  0x40a942		89f3			MOVL SI, BX		
  0x40a944		c1ee10			SHRL $0x10, SI		
  0x40a947		31d6			XORL DX, SI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40a949		89b124010000		MOVL SI, 0x124(CX)	
	return s0 + s1
  0x40a94f		8d0c1e			LEAL 0(SI)(BX*1), CX	
	q := fastrand()%(1<<randomBitCount) + 1
  0x40a952		81e1ffffff03		ANDL $0x3ffffff, CX	
  0x40a958		ffc1			INCL CX			
	qlog := fastlog2(float64(q)) - randomBitCount
  0x40a95a		90			NOPL			
  0x40a95b		0f57c0			XORPS X0, X0		
  0x40a95e		f2480f2ac1		CVTSI2SDQ CX, X0	
	xBits := float64bits(x)
  0x40a963		90			NOPL			
	return *(*uint64)(unsafe.Pointer(&f))
  0x40a964		66480f7ec1		MOVQ X0, CX		
	xManIndex := (xBits >> (52 - fastlogNumBits)) % (1 << fastlogNumBits)
  0x40a969		4889ca			MOVQ CX, DX		
  0x40a96c		48c1e92f		SHRQ $0x2f, CX		
  0x40a970		4883e11f		ANDQ $0x1f, CX		
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40a974		488d5901		LEAQ 0x1(CX), BX	
  0x40a978		4883fb21		CMPQ $0x21, BX		
  0x40a97c		0f83e4000000		JAE 0x40aa66		
	xExp := int64((xBits>>52)&0x7FF) - 1023
  0x40a982		4889d3			MOVQ DX, BX		
  0x40a985		48c1ea34		SHRQ $0x34, DX		
  0x40a989		4881e2ff070000		ANDQ $0x7ff, DX		
  0x40a990		4881c201fcffff		ADDQ $-0x3ff, DX	
	xManScale := (xBits >> (52 - fastlogNumBits - fastlogScaleBits)) % (1 << fastlogScaleBits)
  0x40a997		48c1eb1b		SHRQ $0x1b, BX		
  0x40a99b		4889de			MOVQ BX, SI		
  0x40a99e		4881e3ffff0f00		ANDQ $0xfffff, BX	
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40a9a5		488d3dd44c0b00		LEAQ runtime.fastlog2Table(SB), DI	
  0x40a9ac		f20f1004cf		MOVSD_XMM 0(DI)(CX*8), X0		
  0x40a9b1		f20f104ccf08		MOVSD_XMM 0x8(DI)(CX*8), X1		
	return float64(xExp) + low + (high-low)*float64(xManScale)*fastlogScaleRatio
  0x40a9b7		0f57d2			XORPS X2, X2				
  0x40a9ba		f2480f2ad2		CVTSI2SDQ DX, X2			
  0x40a9bf		f20f58d0		ADDSD X0, X2				
  0x40a9c3		f20f5cc8		SUBSD X0, X1				
  0x40a9c7		48f7c6ffff0f00		TESTQ $0xfffff, SI			
  0x40a9ce		7c64			JL 0x40aa34				
  0x40a9d0		0f57c0			XORPS X0, X0				
  0x40a9d3		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x40a9d8		f20f59c1		MULSD X1, X0				
  0x40a9dc		f20f100da4220700	MOVSD_XMM $f64.3eb0000000000000(SB), X1	
  0x40a9e4		f20f59c8		MULSD X0, X1				
  0x40a9e8		f20f58d1		ADDSD X1, X2				
	qlog := fastlog2(float64(q)) - randomBitCount
  0x40a9ec		f20f1005f4220700	MOVSD_XMM $f64.403a000000000000(SB), X0	
  0x40a9f4		f20f5cd0		SUBSD X0, X2				
	if qlog > 0 {
  0x40a9f8		0f57c0			XORPS X0, X0		
  0x40a9fb		660f2ed0		UCOMISD X0, X2		
  0x40a9ff		762e			JBE 0x40aa2f		
  0x40aa01		0f57c0			XORPS X0, X0		
	return int32(qlog*(minusLog2*float64(mean))) + 1
  0x40aa04		0f57c9			XORPS X1, X1				
  0x40aa07		f2480f2ac8		CVTSI2SDQ AX, X1			
  0x40aa0c		f20f101504230700	MOVSD_XMM $f64.bfe62e42fefa39ef(SB), X2	
  0x40aa14		f20f59d1		MULSD X1, X2				
  0x40aa18		f20f59c2		MULSD X2, X0				
  0x40aa1c		f20f2cc0		CVTTSD2SIL X0, AX			
  0x40aa20		ffc0			INCL AX					
  0x40aa22		89442418		MOVL AX, 0x18(SP)			
  0x40aa26		488b2c24		MOVQ 0(SP), BP				
  0x40aa2a		4883c408		ADDQ $0x8, SP				
  0x40aa2e		c3			RET					
  0x40aa2f		0f10c2			MOVUPS X2, X0				
	if qlog > 0 {
  0x40aa32		ebd0			JMP 0x40aa04		
	return float64(xExp) + low + (high-low)*float64(xManScale)*fastlogScaleRatio
  0x40aa34		48d1eb			SHRQ $0x1, BX		
  0x40aa37		4883e601		ANDQ $0x1, SI		
  0x40aa3b		4809f3			ORQ SI, BX		
  0x40aa3e		0f57c0			XORPS X0, X0		
  0x40aa41		f2480f2ac3		CVTSI2SDQ BX, X0	
  0x40aa46		f20f58c0		ADDSD X0, X0		
  0x40aa4a		eb8c			JMP 0x40a9d8		
	case mean == 0:
  0x40aa4c		4885c0			TESTQ AX, AX		
  0x40aa4f		0f85bdfeffff		JNE 0x40a912		
		return 0
  0x40aa55		c744241800000000	MOVL $0x0, 0x18(SP)	
  0x40aa5d		488b2c24		MOVQ 0(SP), BP		
  0x40aa61		4883c408		ADDQ $0x8, SP		
  0x40aa65		c3			RET			
	low, high := fastlog2Table[xManIndex], fastlog2Table[xManIndex+1]
  0x40aa66		e8b5740100		CALL runtime.panicindex(SB)	
  0x40aa6b		0f0b			UD2				

TEXT runtime.persistentalloc(SB) /usr/local/go/src/runtime/malloc.go
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40aa70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40aa79		483b6110		CMPQ 0x10(CX), SP	
  0x40aa7d		0f8683000000		JBE 0x40ab06		
  0x40aa83		4883ec40		SUBQ $0x40, SP		
  0x40aa87		48896c2438		MOVQ BP, 0x38(SP)	
  0x40aa8c		488d6c2438		LEAQ 0x38(SP), BP	
	var p *notInHeap
  0x40aa91		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	systemstack(func() {
  0x40aa9a		48c744241000000000	MOVQ $0x0, 0x10(SP)				
  0x40aaa3		0f57c0			XORPS X0, X0					
  0x40aaa6		0f11442418		MOVUPS X0, 0x18(SP)				
  0x40aaab		0f11442428		MOVUPS X0, 0x28(SP)				
  0x40aab0		488d05a9a00300		LEAQ runtime.persistentalloc.func1(SB), AX	
  0x40aab7		4889442410		MOVQ AX, 0x10(SP)				
  0x40aabc		488b442448		MOVQ 0x48(SP), AX				
  0x40aac1		4889442418		MOVQ AX, 0x18(SP)				
  0x40aac6		488b442450		MOVQ 0x50(SP), AX				
  0x40aacb		4889442420		MOVQ AX, 0x20(SP)				
  0x40aad0		488b442458		MOVQ 0x58(SP), AX				
  0x40aad5		4889442428		MOVQ AX, 0x28(SP)				
  0x40aada		488d442408		LEAQ 0x8(SP), AX				
  0x40aadf		4889442430		MOVQ AX, 0x30(SP)				
  0x40aae4		488d442410		LEAQ 0x10(SP), AX				
  0x40aae9		48890424		MOVQ AX, 0(SP)					
  0x40aaed		e83ecc0300		CALL runtime.systemstack(SB)			
	return unsafe.Pointer(p)
  0x40aaf2		488b442408		MOVQ 0x8(SP), AX	
  0x40aaf7		4889442460		MOVQ AX, 0x60(SP)	
  0x40aafc		488b6c2438		MOVQ 0x38(SP), BP	
  0x40ab01		4883c440		ADDQ $0x40, SP		
  0x40ab05		c3			RET			
func persistentalloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40ab06		e875cd0300		CALL runtime.morestack_noctxt(SB)	
  0x40ab0b		e960ffffff		JMP runtime.persistentalloc(SB)		

TEXT runtime.persistentalloc1(SB) /usr/local/go/src/runtime/malloc.go
func persistentalloc1(size, align uintptr, sysStat *uint64) *notInHeap {
  0x40ab10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ab19		483b6118		CMPQ 0x18(CX), SP	
  0x40ab1d		0f86f7020000		JBE 0x40ae1a		
  0x40ab23		4883ec48		SUBQ $0x48, SP		
  0x40ab27		48896c2440		MOVQ BP, 0x40(SP)	
  0x40ab2c		488d6c2440		LEAQ 0x40(SP), BP	
	if size == 0 {
  0x40ab31		488b442450		MOVQ 0x50(SP), AX	
  0x40ab36		4885c0			TESTQ AX, AX		
  0x40ab39		0f84c0020000		JE 0x40adff		
	if align != 0 {
  0x40ab3f		488b4c2458		MOVQ 0x58(SP), CX	
  0x40ab44		4885c9			TESTQ CX, CX		
  0x40ab47		0f8457020000		JE 0x40ada4		
		if align&(align-1) != 0 {
  0x40ab4d		488d51ff		LEAQ -0x1(CX), DX	
  0x40ab51		4885d1			TESTQ DX, CX		
  0x40ab54		0f858a020000		JNE 0x40ade4		
		if align > _PageSize {
  0x40ab5a		4881f900200000		CMPQ $0x2000, CX	
  0x40ab61		0f8762020000		JA 0x40adc9		
	if size >= maxBlock {
  0x40ab67		483d00000100		CMPQ $0x10000, AX	
  0x40ab6d		0f8305020000		JAE 0x40ad78		
	persistent.off = round(persistent.off, align)
  0x40ab73		48894c2418		MOVQ CX, 0x18(SP)	
	_g_ := getg()
  0x40ab78		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++
  0x40ab81		488b5a30		MOVQ 0x30(DX), BX	
	mp := acquirem()
  0x40ab85		90			NOPL			
	_g_.m.locks++
  0x40ab86		ff8308010000		INCL 0x108(BX)		
	return _g_.m
  0x40ab8c		488b5230		MOVQ 0x30(DX), DX	
  0x40ab90		4889542428		MOVQ DX, 0x28(SP)	
	if mp != nil && mp.p != 0 {
  0x40ab95		4885d2			TESTQ DX, DX		
  0x40ab98		0f84af010000		JE 0x40ad4d		
  0x40ab9e		488b9ad0000000		MOVQ 0xd0(DX), BX	
  0x40aba5		4885db			TESTQ BX, BX		
  0x40aba8		0f849f010000		JE 0x40ad4d		
		persistent = &mp.p.ptr().palloc
  0x40abae		8403			TESTB AL, 0(BX)		
  0x40abb0		4881c338120000		ADDQ $0x1238, BX	
  0x40abb7		90			NOPL			
	persistent.off = round(persistent.off, align)
  0x40abb8		48895c2420		MOVQ BX, 0x20(SP)	
  0x40abbd		90			NOPL			
  0x40abbe		488b7308		MOVQ 0x8(BX), SI	
	return (n + a - 1) &^ (a - 1)
  0x40abc2		488d3431		LEAQ 0(CX)(SI*1), SI	
  0x40abc6		488d76ff		LEAQ -0x1(SI), SI	
  0x40abca		48ffc9			DECQ CX			
  0x40abcd		48f7d1			NOTQ CX			
  0x40abd0		4821f1			ANDQ SI, CX		
	persistent.off = round(persistent.off, align)
  0x40abd3		48894b08		MOVQ CX, 0x8(BX)	
	if persistent.off+size > persistentChunkSize || persistent.base == nil {
  0x40abd7		4801c1			ADDQ AX, CX		
  0x40abda		4881f900000400		CMPQ $0x40000, CX	
  0x40abe1		0f8654010000		JBE 0x40ad3b		
		persistent.base = (*notInHeap)(sysAlloc(persistentChunkSize, &memstats.other_sys))
  0x40abe7		48c7042400000400	MOVQ $0x40000, 0(SP)			
  0x40abef		488d050a310d00		LEAQ runtime.memstats+160(SB), AX	
  0x40abf6		4889442408		MOVQ AX, 0x8(SP)			
  0x40abfb		e800680000		CALL runtime.sysAlloc(SB)		
  0x40ac00		488b442410		MOVQ 0x10(SP), AX			
  0x40ac05		4889442438		MOVQ AX, 0x38(SP)			
  0x40ac0a		488b4c2420		MOVQ 0x20(SP), CX			
  0x40ac0f		488901			MOVQ AX, 0(CX)				
		if persistent.base == nil {
  0x40ac12		48833900		CMPQ $0x0, 0(CX)	
  0x40ac16		7505			JNE 0x40ac1d		
  0x40ac18		e9fc000000		JMP 0x40ad19		
			*(*uintptr)(unsafe.Pointer(persistent.base)) = chunks
  0x40ac1d		488b11			MOVQ 0(CX), DX		
			chunks := uintptr(unsafe.Pointer(persistentChunks))
  0x40ac20		488b05596d0b00		MOVQ runtime.persistentChunks(SB), AX	
			*(*uintptr)(unsafe.Pointer(persistent.base)) = chunks
  0x40ac27		488902			MOVQ AX, 0(DX)		
			if atomic.Casuintptr((*uintptr)(unsafe.Pointer(&persistentChunks)), chunks, uintptr(unsafe.Pointer(persistent.base))) {
  0x40ac2a		488b11			MOVQ 0(CX), DX				
  0x40ac2d		4889542438		MOVQ DX, 0x38(SP)			
  0x40ac32		488d1d476d0b00		LEAQ runtime.persistentChunks(SB), BX	
  0x40ac39		f0480fb113		LOCK CMPXCHGQ DX, 0(BX)			
  0x40ac3e		0f94c2			SETE DL					
  0x40ac41		84d2			TESTL DL, DL				
  0x40ac43		74d8			JE 0x40ac1d				
		persistent.off = sys.PtrSize
  0x40ac45		48c7410808000000	MOVQ $0x8, 0x8(CX)	
	p := persistent.base.add(persistent.off)
  0x40ac4d		488b01			MOVQ 0(CX), AX		
  0x40ac50		90			NOPL			
  0x40ac51		488b5108		MOVQ 0x8(CX), DX	
	persistent.off += size
  0x40ac55		488b5c2450		MOVQ 0x50(SP), BX	
  0x40ac5a		488d3413		LEAQ 0(BX)(DX*1), SI	
  0x40ac5e		48897108		MOVQ SI, 0x8(CX)	
	releasem(mp)
  0x40ac62		90			NOPL			
	_g_ := getg()
  0x40ac63		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
	mp.locks--
  0x40ac6c		488b7c2428		MOVQ 0x28(SP), DI	
  0x40ac71		448b8708010000		MOVL 0x108(DI), R8	
  0x40ac78		458d48ff		LEAL -0x1(R8), R9	
  0x40ac7c		44898f08010000		MOVL R9, 0x108(DI)	
	return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes))
  0x40ac83		4801d0			ADDQ DX, AX		
	if mp.locks == 0 && _g_.preempt {
  0x40ac86		4183f801		CMPL $0x1, R8		
  0x40ac8a		7511			JNE 0x40ac9d		
  0x40ac8c		80beb100000000		CMPB $0x0, 0xb1(SI)	
  0x40ac93		7408			JE 0x40ac9d		
		_g_.stackguard0 = stackPreempt
  0x40ac95		48c74610defaffff	MOVQ $-0x522, 0x10(SI)	
	return (*notInHeap)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + bytes))
  0x40ac9d		4889442430		MOVQ AX, 0x30(SP)	
	if persistent == &globalAlloc.persistentAlloc {
  0x40aca2		488d15ff6d0b00		LEAQ runtime.globalAlloc+8(SB), DX	
  0x40aca9		4839d1			CMPQ DX, CX				
  0x40acac		744f			JE 0x40acfd				
	if sysStat != &memstats.other_sys {
  0x40acae		488b4c2460		MOVQ 0x60(SP), CX			
  0x40acb3		488d1546300d00		LEAQ runtime.memstats+160(SB), DX	
  0x40acba		4839d1			CMPQ DX, CX				
  0x40acbd		750f			JNE 0x40acce				
	return p
  0x40acbf		4889442468		MOVQ AX, 0x68(SP)	
  0x40acc4		488b6c2440		MOVQ 0x40(SP), BP	
  0x40acc9		4883c448		ADDQ $0x48, SP		
  0x40accd		c3			RET			
		mSysStatInc(sysStat, size)
  0x40acce		48890c24		MOVQ CX, 0(SP)			
  0x40acd2		48895c2408		MOVQ BX, 0x8(SP)		
  0x40acd7		e8145d0100		CALL runtime.mSysStatInc(SB)	
		mSysStatDec(&memstats.other_sys, size)
  0x40acdc		488d051d300d00		LEAQ runtime.memstats+160(SB), AX	
  0x40ace3		48890424		MOVQ AX, 0(SP)				
  0x40ace7		488b442450		MOVQ 0x50(SP), AX			
  0x40acec		4889442408		MOVQ AX, 0x8(SP)			
  0x40acf1		e8ba5d0100		CALL runtime.mSysStatDec(SB)		
	return p
  0x40acf6		488b442430		MOVQ 0x30(SP), AX	
		mSysStatDec(&memstats.other_sys, size)
  0x40acfb		ebc2			JMP 0x40acbf		
		unlock(&globalAlloc.mutex)
  0x40acfd		488d059c6d0b00		LEAQ runtime.globalAlloc(SB), AX	
  0x40ad04		48890424		MOVQ AX, 0(SP)				
  0x40ad08		e883dbffff		CALL runtime.unlock(SB)			
	return p
  0x40ad0d		488b442430		MOVQ 0x30(SP), AX	
		mSysStatInc(sysStat, size)
  0x40ad12		488b5c2450		MOVQ 0x50(SP), BX	
		unlock(&globalAlloc.mutex)
  0x40ad17		eb95			JMP 0x40acae		
			if persistent == &globalAlloc.persistentAlloc {
  0x40ad19		488d05886d0b00		LEAQ runtime.globalAlloc+8(SB), AX	
  0x40ad20		4839c1			CMPQ AX, CX				
  0x40ad23		0f8585000000		JNE 0x40adae				
				unlock(&globalAlloc.mutex)
  0x40ad29		488d05706d0b00		LEAQ runtime.globalAlloc(SB), AX	
  0x40ad30		48890424		MOVQ AX, 0(SP)				
  0x40ad34		e857dbffff		CALL runtime.unlock(SB)			
  0x40ad39		eb73			JMP 0x40adae				
	if persistent.off+size > persistentChunkSize || persistent.base == nil {
  0x40ad3b		48833b00		CMPQ $0x0, 0(BX)	
  0x40ad3f		0f84a2feffff		JE 0x40abe7		
	p := persistent.base.add(persistent.off)
  0x40ad45		4889d9			MOVQ BX, CX		
  0x40ad48		e900ffffff		JMP 0x40ac4d		
		lock(&globalAlloc.mutex)
  0x40ad4d		488d054c6d0b00		LEAQ runtime.globalAlloc(SB), AX	
  0x40ad54		48890424		MOVQ AX, 0(SP)				
  0x40ad58		e883d9ffff		CALL runtime.lock(SB)			
	if persistent.off+size > persistentChunkSize || persistent.base == nil {
  0x40ad5d		488b442450		MOVQ 0x50(SP), AX	
	return (n + a - 1) &^ (a - 1)
  0x40ad62		488b4c2418		MOVQ 0x18(SP), CX	
	mp.locks--
  0x40ad67		488b542428		MOVQ 0x28(SP), DX	
		persistent = &globalAlloc.persistentAlloc
  0x40ad6c		488d1d356d0b00		LEAQ runtime.globalAlloc+8(SB), BX	
  0x40ad73		e940feffff		JMP 0x40abb8				
		return (*notInHeap)(sysAlloc(size, sysStat))
  0x40ad78		48890424		MOVQ AX, 0(SP)			
  0x40ad7c		488b442460		MOVQ 0x60(SP), AX		
  0x40ad81		4889442408		MOVQ AX, 0x8(SP)		
  0x40ad86		e875660000		CALL runtime.sysAlloc(SB)	
  0x40ad8b		488b442410		MOVQ 0x10(SP), AX		
  0x40ad90		4889442438		MOVQ AX, 0x38(SP)		
  0x40ad95		4889442468		MOVQ AX, 0x68(SP)		
  0x40ad9a		488b6c2440		MOVQ 0x40(SP), BP		
  0x40ad9f		4883c448		ADDQ $0x48, SP			
  0x40ada3		c3			RET				
  0x40ada4		b908000000		MOVL $0x8, CX			
	if size >= maxBlock {
  0x40ada9		e9b9fdffff		JMP 0x40ab67		
			throw("runtime: cannot allocate memory")
  0x40adae		488d057e700600		LEAQ 0x6707e(IP), AX	
  0x40adb5		48890424		MOVQ AX, 0(SP)		
  0x40adb9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x40adc2		e8b9860100		CALL runtime.throw(SB)	
  0x40adc7		0f0b			UD2			
			throw("persistentalloc: align is too large")
  0x40adc9		488d05d2760600		LEAQ 0x676d2(IP), AX	
  0x40add0		48890424		MOVQ AX, 0(SP)		
  0x40add4		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x40addd		e89e860100		CALL runtime.throw(SB)	
  0x40ade2		0f0b			UD2			
			throw("persistentalloc: align is not a power of 2")
  0x40ade4		488d056b7e0600		LEAQ 0x67e6b(IP), AX	
  0x40adeb		48890424		MOVQ AX, 0(SP)		
  0x40adef		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x40adf8		e883860100		CALL runtime.throw(SB)	
  0x40adfd		0f0b			UD2			
		throw("persistentalloc: size == 0")
  0x40adff		488d05a8640600		LEAQ 0x664a8(IP), AX	
  0x40ae06		48890424		MOVQ AX, 0(SP)		
  0x40ae0a		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40ae13		e868860100		CALL runtime.throw(SB)	
  0x40ae18		0f0b			UD2			
func persistentalloc1(size, align uintptr, sysStat *uint64) *notInHeap {
  0x40ae1a		e8b1e80200		CALL runtime.morestackc(SB)		
  0x40ae1f		e9ecfcffff		JMP runtime.persistentalloc1(SB)	

TEXT runtime.inPersistentAlloc(SB) /usr/local/go/src/runtime/malloc.go
	chunk := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&persistentChunks)))
  0x40ae30		488b05496b0b00		MOVQ runtime.persistentChunks(SB), AX	
	for chunk != 0 {
  0x40ae37		488b4c2408		MOVQ 0x8(SP), CX	
  0x40ae3c		eb03			JMP 0x40ae41		
		chunk = *(*uintptr)(unsafe.Pointer(chunk))
  0x40ae3e		488b00			MOVQ 0(AX), AX		
	for chunk != 0 {
  0x40ae41		4885c0			TESTQ AX, AX		
  0x40ae44		7417			JE 0x40ae5d		
		if p >= chunk && p < chunk+persistentChunkSize {
  0x40ae46		4839c1			CMPQ AX, CX		
  0x40ae49		72f3			JB 0x40ae3e		
  0x40ae4b		488d9000000400		LEAQ 0x40000(AX), DX	
  0x40ae52		4839d1			CMPQ DX, CX		
  0x40ae55		73e7			JAE 0x40ae3e		
			return true
  0x40ae57		c644241001		MOVB $0x1, 0x10(SP)	
  0x40ae5c		c3			RET			
	return false
  0x40ae5d		c644241000		MOVB $0x0, 0x10(SP)	
  0x40ae62		c3			RET			

TEXT runtime.(*linearAlloc).alloc(SB) /usr/local/go/src/runtime/malloc.go
func (l *linearAlloc) alloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40ae70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ae79		483b6110		CMPQ 0x10(CX), SP	
  0x40ae7d		0f86bf000000		JBE 0x40af42		
  0x40ae83		4883ec30		SUBQ $0x30, SP		
  0x40ae87		48896c2428		MOVQ BP, 0x28(SP)	
  0x40ae8c		488d6c2428		LEAQ 0x28(SP), BP	
	p := round(l.next, align)
  0x40ae91		90			NOPL			
  0x40ae92		488b442438		MOVQ 0x38(SP), AX	
  0x40ae97		488b08			MOVQ 0(AX), CX		
	return (n + a - 1) &^ (a - 1)
  0x40ae9a		488b542448		MOVQ 0x48(SP), DX	
  0x40ae9f		488d0c0a		LEAQ 0(DX)(CX*1), CX	
  0x40aea3		488d49ff		LEAQ -0x1(CX), CX	
  0x40aea7		48ffca			DECQ DX			
  0x40aeaa		48f7d2			NOTQ DX			
  0x40aead		4821d1			ANDQ DX, CX		
	if p+size > l.end {
  0x40aeb0		488b542440		MOVQ 0x40(SP), DX	
  0x40aeb5		4801ca			ADDQ CX, DX		
  0x40aeb8		48395010		CMPQ DX, 0x10(AX)	
  0x40aebc		7271			JB 0x40af2f		
	l.next = p + size
  0x40aebe		488910			MOVQ DX, 0(AX)		
	if pEnd := round(l.next-1, physPageSize); pEnd > l.mapped {
  0x40aec1		90			NOPL					
  0x40aec2		488b1ddf1e0d00		MOVQ runtime.physPageSize(SB), BX	
  0x40aec9		488b7008		MOVQ 0x8(AX), SI			
	return (n + a - 1) &^ (a - 1)
  0x40aecd		488d141a		LEAQ 0(DX)(BX*1), DX	
  0x40aed1		488d52fe		LEAQ -0x2(DX), DX	
  0x40aed5		48ffcb			DECQ BX			
  0x40aed8		48f7d3			NOTQ BX			
  0x40aedb		4821da			ANDQ BX, DX		
	if pEnd := round(l.next-1, physPageSize); pEnd > l.mapped {
  0x40aede		4839f2			CMPQ SI, DX		
  0x40aee1		770f			JA 0x40aef2		
	return unsafe.Pointer(p)
  0x40aee3		48894c2458		MOVQ CX, 0x58(SP)	
  0x40aee8		488b6c2428		MOVQ 0x28(SP), BP	
  0x40aeed		4883c430		ADDQ $0x30, SP		
  0x40aef1		c3			RET			
	return (n + a - 1) &^ (a - 1)
  0x40aef2		48894c2420		MOVQ CX, 0x20(SP)	
  0x40aef7		4889542418		MOVQ DX, 0x18(SP)	
		sysMap(unsafe.Pointer(l.mapped), pEnd-l.mapped, sysStat)
  0x40aefc		4889f0			MOVQ SI, AX		
  0x40aeff		48893424		MOVQ SI, 0(SP)		
  0x40af03		4829c2			SUBQ AX, DX		
  0x40af06		4889542408		MOVQ DX, 0x8(SP)	
  0x40af0b		488b442450		MOVQ 0x50(SP), AX	
  0x40af10		4889442410		MOVQ AX, 0x10(SP)	
  0x40af15		e8b6680000		CALL runtime.sysMap(SB)	
		l.mapped = pEnd
  0x40af1a		488b442418		MOVQ 0x18(SP), AX	
  0x40af1f		488b4c2438		MOVQ 0x38(SP), CX	
  0x40af24		48894108		MOVQ AX, 0x8(CX)	
	return unsafe.Pointer(p)
  0x40af28		488b4c2420		MOVQ 0x20(SP), CX	
		l.mapped = pEnd
  0x40af2d		ebb4			JMP 0x40aee3		
		return nil
  0x40af2f		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x40af38		488b6c2428		MOVQ 0x28(SP), BP	
  0x40af3d		4883c430		ADDQ $0x30, SP		
  0x40af41		c3			RET			
func (l *linearAlloc) alloc(size, align uintptr, sysStat *uint64) unsafe.Pointer {
  0x40af42		e839c90300		CALL runtime.morestack_noctxt(SB)	
  0x40af47		e924ffffff		JMP runtime.(*linearAlloc).alloc(SB)	

TEXT runtime.(*hmap).incrnoverflow(SB) /usr/local/go/src/runtime/map.go
	if h.B < 16 {
  0x40af50		488b442408		MOVQ 0x8(SP), AX	
  0x40af55		0fb65009		MOVZX 0x9(AX), DX	
  0x40af59		80fa10			CMPL $0x10, DL		
  0x40af5c		7269			JB 0x40afc7		
	mp := getg().m
  0x40af5e		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x40af67		488b5b30		MOVQ 0x30(BX), BX	
	if fastrand()&mask == 0 {
  0x40af6b		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40af6c		8bb320010000		MOVL 0x120(BX), SI	
  0x40af72		8bbb24010000		MOVL 0x124(BX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40af78		89bb20010000		MOVL DI, 0x120(BX)	
	s1 ^= s1 << 17
  0x40af7e		4189f0			MOVL SI, R8		
  0x40af81		c1e611			SHLL $0x11, SI		
  0x40af84		4131f0			XORL SI, R8		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x40af87		89fe			MOVL DI, SI		
  0x40af89		4431c7			XORL R8, DI		
  0x40af8c		41c1e807		SHRL $0x7, R8		
  0x40af90		4131f8			XORL DI, R8		
  0x40af93		89f7			MOVL SI, DI		
  0x40af95		c1ee10			SHRL $0x10, SI		
  0x40af98		4431c6			XORL R8, SI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40af9b		89b324010000		MOVL SI, 0x124(BX)	
	mask := uint32(1)<<(h.B-15) - 1
  0x40afa1		8d4af1			LEAL -0xf(DX), CX	
  0x40afa4		80f920			CMPL $0x20, CL		
  0x40afa7		19d2			SBBL DX, DX		
  0x40afa9		bb01000000		MOVL $0x1, BX		
  0x40afae		d3e3			SHLL CL, BX		
  0x40afb0		21d3			ANDL DX, BX		
  0x40afb2		8d53ff			LEAL -0x1(BX), DX	
	return s0 + s1
  0x40afb5		8d1c3e			LEAL 0(SI)(DI*1), BX	
	if fastrand()&mask == 0 {
  0x40afb8		85da			TESTL BX, DX		
  0x40afba		750a			JNE 0x40afc6		
		h.noverflow++
  0x40afbc		0fb7480a		MOVZX 0xa(AX), CX	
  0x40afc0		ffc1			INCL CX			
  0x40afc2		6689480a		MOVW CX, 0xa(AX)	
  0x40afc6		c3			RET			
		h.noverflow++
  0x40afc7		0fb7480a		MOVZX 0xa(AX), CX	
  0x40afcb		ffc1			INCL CX			
  0x40afcd		6689480a		MOVW CX, 0xa(AX)	
		return
  0x40afd1		c3			RET			

TEXT runtime.(*hmap).newoverflow(SB) /usr/local/go/src/runtime/map.go
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x40afe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40afe9		483b6110		CMPQ 0x10(CX), SP	
  0x40afed		0f86b9020000		JBE 0x40b2ac		
  0x40aff3		4883ec58		SUBQ $0x58, SP		
  0x40aff7		48896c2450		MOVQ BP, 0x50(SP)	
  0x40affc		488d6c2450		LEAQ 0x50(SP), BP	
	if h.extra != nil && h.extra.nextOverflow != nil {
  0x40b001		488b4c2460		MOVQ 0x60(SP), CX	
  0x40b006		488b5128		MOVQ 0x28(CX), DX	
  0x40b00a		4885d2			TESTQ DX, DX		
  0x40b00d		0f846a020000		JE 0x40b27d		
  0x40b013		488b5a10		MOVQ 0x10(DX), BX	
  0x40b017		4885db			TESTQ BX, BX		
  0x40b01a		0f845d020000		JE 0x40b27d		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b020		488b742468		MOVQ 0x68(SP), SI	
  0x40b025		440fb7464a		MOVZX 0x4a(SI), R8	
	return unsafe.Pointer(uintptr(p) + x)
  0x40b02a		4989d9			MOVQ BX, R9		
  0x40b02d		498d3c18		LEAQ 0(R8)(BX*1), DI	
  0x40b031		488d7ff8		LEAQ -0x8(DI), DI	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b035		8406			TESTB AL, 0(SI)		
		if ovf.overflow(t) == nil {
  0x40b037		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b038		90			NOPL			
  0x40b039		48833f00		CMPQ $0x0, 0(DI)	
		if ovf.overflow(t) == nil {
  0x40b03d		0f8415020000		JE 0x40b258		
			ovf.setoverflow(t, nil)
  0x40b043		90			NOPL			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b044		90			NOPL					
  0x40b045		833dd41d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b04c		0f85fa010000		JNE 0x40b24c				
  0x40b052		48c70700000000		MOVQ $0x0, 0(DI)			
			h.extra.nextOverflow = nil
  0x40b059		488b5128		MOVQ 0x28(CX), DX			
  0x40b05d		8402			TESTB AL, 0(DX)				
  0x40b05f		833dba1d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b066		0f85d0010000		JNE 0x40b23c				
  0x40b06c		48c7421000000000	MOVQ $0x0, 0x10(DX)			
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b074		4c894c2440		MOVQ R9, 0x40(SP)	
	h.incrnoverflow()
  0x40b079		48890c24		MOVQ CX, 0(SP)				
  0x40b07d		e8cefeffff		CALL runtime.(*hmap).incrnoverflow(SB)	
	if t.bucket.kind&kindNoPointers != 0 {
  0x40b082		488b442468		MOVQ 0x68(SP), AX	
  0x40b087		488b4840		MOVQ 0x40(AX), CX	
  0x40b08b		0fb64917		MOVZX 0x17(CX), CX	
  0x40b08f		f6c180			TESTL $0x80, CL		
  0x40b092		0f849a010000		JE 0x40b232		
		h.createOverflow()
  0x40b098		90			NOPL			
	if h.extra == nil {
  0x40b099		488b4c2460		MOVQ 0x60(SP), CX	
  0x40b09e		4883792800		CMPQ $0x0, 0x28(CX)	
  0x40b0a3		0f8448010000		JE 0x40b1f1		
	if h.extra.overflow == nil {
  0x40b0a9		488b5128		MOVQ 0x28(CX), DX	
  0x40b0ad		48833a00		CMPQ $0x0, 0(DX)	
  0x40b0b1		0f84f1000000		JE 0x40b1a8		
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b0b7		488b4928		MOVQ 0x28(CX), CX			
  0x40b0bb		488b11			MOVQ 0(CX), DX				
  0x40b0be		8401			TESTB AL, 0(CX)				
  0x40b0c0		488b0a			MOVQ 0(DX), CX				
  0x40b0c3		488b5a08		MOVQ 0x8(DX), BX			
  0x40b0c7		488d7301		LEAQ 0x1(BX), SI			
  0x40b0cb		4c8b4210		MOVQ 0x10(DX), R8			
  0x40b0cf		4c39c6			CMPQ R8, SI				
  0x40b0d2		776d			JA 0x40b141				
  0x40b0d4		488d7301		LEAQ 0x1(BX), SI			
  0x40b0d8		48897208		MOVQ SI, 0x8(DX)			
  0x40b0dc		488d3cd9		LEAQ 0(CX)(BX*8), DI			
  0x40b0e0		833d391d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b0e7		7543			JNE 0x40b12c				
  0x40b0e9		488b542440		MOVQ 0x40(SP), DX			
  0x40b0ee		488914d9		MOVQ DX, 0(CX)(BX*8)			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b0f2		0fb7484a		MOVZX 0x4a(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40b0f6		488b5c2470		MOVQ 0x70(SP), BX	
  0x40b0fb		488d3c0b		LEAQ 0(BX)(CX*1), DI	
  0x40b0ff		488d7ff8		LEAQ -0x8(DI), DI	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b103		8407			TESTB AL, 0(DI)		
	b.setoverflow(t, ovf)
  0x40b105		90			NOPL			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b106		90			NOPL					
  0x40b107		833d121d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b10e		7512			JNE 0x40b122				
  0x40b110		488917			MOVQ DX, 0(DI)				
	return ovf
  0x40b113		4889542478		MOVQ DX, 0x78(SP)	
  0x40b118		488b6c2450		MOVQ 0x50(SP), BP	
  0x40b11d		4883c458		ADDQ $0x58, SP		
  0x40b121		c3			RET			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b122		4889d0			MOVQ DX, AX			
  0x40b125		e856e50300		CALL runtime.gcWriteBarrier(SB)	
  0x40b12a		ebe7			JMP 0x40b113			
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x40b12c		4889c1			MOVQ AX, CX		
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b12f		488b442440		MOVQ 0x40(SP), AX		
  0x40b134		e847e50300		CALL runtime.gcWriteBarrier(SB)	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b139		4889c2			MOVQ AX, DX		
  0x40b13c		4889c8			MOVQ CX, AX		
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b13f		ebb1			JMP 0x40b0f2				
  0x40b141		4889542448		MOVQ DX, 0x48(SP)			
  0x40b146		488d0533500500		LEAQ 0x55033(IP), AX			
  0x40b14d		48890424		MOVQ AX, 0(SP)				
  0x40b151		48894c2408		MOVQ CX, 0x8(SP)			
  0x40b156		48895c2410		MOVQ BX, 0x10(SP)			
  0x40b15b		4c89442418		MOVQ R8, 0x18(SP)			
  0x40b160		4889742420		MOVQ SI, 0x20(SP)			
  0x40b165		e816ac0200		CALL runtime.growslice(SB)		
  0x40b16a		488b442428		MOVQ 0x28(SP), AX			
  0x40b16f		488b4c2430		MOVQ 0x30(SP), CX			
  0x40b174		488b542438		MOVQ 0x38(SP), DX			
  0x40b179		488b7c2448		MOVQ 0x48(SP), DI			
  0x40b17e		48895710		MOVQ DX, 0x10(DI)			
  0x40b182		833d971c0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b189		7516			JNE 0x40b1a1				
  0x40b18b		488907			MOVQ AX, 0(DI)				
  0x40b18e		4889fa			MOVQ DI, DX				
  0x40b191		4889cb			MOVQ CX, BX				
  0x40b194		4889c1			MOVQ AX, CX				
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b197		488b442468		MOVQ 0x68(SP), AX	
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b19c		e933ffffff		JMP 0x40b0d4			
  0x40b1a1		e8dae40300		CALL runtime.gcWriteBarrier(SB)	
  0x40b1a6		ebe6			JMP 0x40b18e			
		h.extra.overflow = new([]*bmap)
  0x40b1a8		488d05b1e30400		LEAQ 0x4e3b1(IP), AX			
  0x40b1af		48890424		MOVQ AX, 0(SP)				
  0x40b1b3		e898f5ffff		CALL runtime.newobject(SB)		
  0x40b1b8		488b442460		MOVQ 0x60(SP), AX			
  0x40b1bd		488b7828		MOVQ 0x28(AX), DI			
  0x40b1c1		8407			TESTB AL, 0(DI)				
  0x40b1c3		488b4c2408		MOVQ 0x8(SP), CX			
  0x40b1c8		833d511c0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b1cf		7510			JNE 0x40b1e1				
  0x40b1d1		48890f			MOVQ CX, 0(DI)				
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b1d4		4889c1			MOVQ AX, CX		
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b1d7		488b442468		MOVQ 0x68(SP), AX	
		h.extra.overflow = new([]*bmap)
  0x40b1dc		e9d6feffff		JMP 0x40b0b7		
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x40b1e1		4889c2			MOVQ AX, DX		
		h.extra.overflow = new([]*bmap)
  0x40b1e4		4889c8			MOVQ CX, AX			
  0x40b1e7		e894e40300		CALL runtime.gcWriteBarrier(SB)	
		*h.extra.overflow = append(*h.extra.overflow, ovf)
  0x40b1ec		4889d0			MOVQ DX, AX		
		h.extra.overflow = new([]*bmap)
  0x40b1ef		ebe3			JMP 0x40b1d4		
		h.extra = new(mapextra)
  0x40b1f1		488d05489d0500		LEAQ 0x59d48(IP), AX			
  0x40b1f8		48890424		MOVQ AX, 0(SP)				
  0x40b1fc		e84ff5ffff		CALL runtime.newobject(SB)		
  0x40b201		488b442408		MOVQ 0x8(SP), AX			
  0x40b206		833d131c0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b20d		7513			JNE 0x40b222				
  0x40b20f		488b4c2460		MOVQ 0x60(SP), CX			
  0x40b214		48894128		MOVQ AX, 0x28(CX)			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b218		488b442468		MOVQ 0x68(SP), AX	
		h.extra = new(mapextra)
  0x40b21d		e987feffff		JMP 0x40b0a9		
	if h.extra != nil && h.extra.nextOverflow != nil {
  0x40b222		488b4c2460		MOVQ 0x60(SP), CX	
  0x40b227		488d7928		LEAQ 0x28(CX), DI	
		h.extra = new(mapextra)
  0x40b22b		e850e40300		CALL runtime.gcWriteBarrier(SB)	
  0x40b230		ebe6			JMP 0x40b218			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b232		488b542440		MOVQ 0x40(SP), DX	
	if t.bucket.kind&kindNoPointers != 0 {
  0x40b237		e9b6feffff		JMP 0x40b0f2		
			h.extra.nextOverflow = nil
  0x40b23c		488d7a10		LEAQ 0x10(DX), DI		
  0x40b240		31c0			XORL AX, AX			
  0x40b242		e839e40300		CALL runtime.gcWriteBarrier(SB)	
  0x40b247		e928feffff		JMP 0x40b074			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b24c		31c0			XORL AX, AX			
  0x40b24e		e82de40300		CALL runtime.gcWriteBarrier(SB)	
  0x40b253		e901feffff		JMP 0x40b059			
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
  0x40b258		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40b259		4b8d0401		LEAQ 0(R9)(R8*1), AX	
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
  0x40b25d		833dbc1b0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b264		7509			JNE 0x40b26f				
  0x40b266		48894210		MOVQ AX, 0x10(DX)			
  0x40b26a		e905feffff		JMP 0x40b074				
	if h.extra != nil && h.extra.nextOverflow != nil {
  0x40b26f		488d7a10		LEAQ 0x10(DX), DI	
			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
  0x40b273		e808e40300		CALL runtime.gcWriteBarrier(SB)	
  0x40b278		e9f7fdffff		JMP 0x40b074			
		ovf = (*bmap)(newobject(t.bucket))
  0x40b27d		488b442468		MOVQ 0x68(SP), AX	
  0x40b282		488b4840		MOVQ 0x40(AX), CX	
  0x40b286		90			NOPL			
	return mallocgc(typ.size, typ, true)
  0x40b287		488b11			MOVQ 0(CX), DX			
  0x40b28a		48891424		MOVQ DX, 0(SP)			
  0x40b28e		48894c2408		MOVQ CX, 0x8(SP)		
  0x40b293		c644241001		MOVB $0x1, 0x10(SP)		
  0x40b298		e873e9ffff		CALL runtime.mallocgc(SB)	
  0x40b29d		4c8b4c2418		MOVQ 0x18(SP), R9		
	h.incrnoverflow()
  0x40b2a2		488b4c2460		MOVQ 0x60(SP), CX	
		ovf = (*bmap)(newobject(t.bucket))
  0x40b2a7		e9c8fdffff		JMP 0x40b074		
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  0x40b2ac		e8cfc50300		CALL runtime.morestack_noctxt(SB)	
  0x40b2b1		e92afdffff		JMP runtime.(*hmap).newoverflow(SB)	

TEXT runtime.makemap(SB) /usr/local/go/src/runtime/map.go
func makemap(t *maptype, hint int, h *hmap) *hmap {
  0x40b2c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b2c9		483b6110		CMPQ 0x10(CX), SP	
  0x40b2cd		0f86ba010000		JBE 0x40b48d		
  0x40b2d3		4883ec40		SUBQ $0x40, SP		
  0x40b2d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x40b2dc		488d6c2438		LEAQ 0x38(SP), BP	
	mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
  0x40b2e1		488b542448		MOVQ 0x48(SP), DX	
  0x40b2e6		488b5a40		MOVQ 0x40(DX), BX	
  0x40b2ea		488b03			MOVQ 0(BX), AX		
  0x40b2ed		488b5c2450		MOVQ 0x50(SP), BX	
  0x40b2f2		48f7e3			MULQ BX			
	if overflow || mem > maxAlloc {
  0x40b2f5		0f8177010000		JNO 0x40b472		
  0x40b2fb		31c0			XORL AX, AX		
	if h == nil {
  0x40b2fd		488b542458		MOVQ 0x58(SP), DX	
  0x40b302		4885d2			TESTQ DX, DX		
  0x40b305		0f8443010000		JE 0x40b44e		
	mp := getg().m
  0x40b30b		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x40b314		488b5b30		MOVQ 0x30(BX), BX	
	h.hash0 = fastrand()
  0x40b318		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x40b319		8bb320010000		MOVL 0x120(BX), SI	
  0x40b31f		8bbb24010000		MOVL 0x124(BX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40b325		89bb20010000		MOVL DI, 0x120(BX)	
	s1 ^= s1 << 17
  0x40b32b		4189f0			MOVL SI, R8		
  0x40b32e		c1e611			SHLL $0x11, SI		
  0x40b331		4431c6			XORL R8, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x40b334		4189f8			MOVL DI, R8		
  0x40b337		31f7			XORL SI, DI		
  0x40b339		c1ee07			SHRL $0x7, SI		
  0x40b33c		31fe			XORL DI, SI		
  0x40b33e		4489c7			MOVL R8, DI		
  0x40b341		41c1e810		SHRL $0x10, R8		
  0x40b345		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x40b348		44898324010000		MOVL R8, 0x124(BX)	
	return s0 + s1
  0x40b34f		428d1c07		LEAL 0(DI)(R8*1), BX	
	h.hash0 = fastrand()
  0x40b353		895a0c			MOVL BX, 0xc(DX)	
  0x40b356		31c9			XORL CX, CX		
	for overLoadFactor(hint, B) {
  0x40b358		eb02			JMP 0x40b35c		
		B++
  0x40b35a		ffc1			INCL CX			
	for overLoadFactor(hint, B) {
  0x40b35c		90			NOPL			
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40b35d		4883f808		CMPQ $0x8, AX		
  0x40b361		0f8ee0000000		JLE 0x40b447		
	return uintptr(1) << b
  0x40b367		bb01000000		MOVL $0x1, BX		
  0x40b36c		48d3e3			SHLQ CL, BX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40b36f		48d1eb			SHRQ $0x1, BX		
  0x40b372		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x40b376		488d1cb3		LEAQ 0(BX)(SI*4), BX	
  0x40b37a		4839d8			CMPQ BX, AX		
  0x40b37d		0f97c3			SETA BL			
  0x40b380		90			NOPL			
	for overLoadFactor(hint, B) {
  0x40b381		84db			TESTL BL, BL		
  0x40b383		75d5			JNE 0x40b35a		
	h.B = B
  0x40b385		884a09			MOVB CL, 0x9(DX)	
	if h.B != 0 {
  0x40b388		84c9			TESTL CL, CL		
  0x40b38a		750f			JNE 0x40b39b		
	return h
  0x40b38c		4889542460		MOVQ DX, 0x60(SP)	
  0x40b391		488b6c2438		MOVQ 0x38(SP), BP	
  0x40b396		4883c440		ADDQ $0x40, SP		
  0x40b39a		c3			RET			
	h.hash0 = fastrand()
  0x40b39b		4889542458		MOVQ DX, 0x58(SP)	
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
  0x40b3a0		488b442448		MOVQ 0x48(SP), AX			
  0x40b3a5		48890424		MOVQ AX, 0(SP)				
  0x40b3a9		884c2408		MOVB CL, 0x8(SP)			
  0x40b3ad		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x40b3b6		e8e5000000		CALL runtime.makeBucketArray(SB)	
  0x40b3bb		488b442418		MOVQ 0x18(SP), AX			
  0x40b3c0		488b4c2420		MOVQ 0x20(SP), CX			
  0x40b3c5		833d541a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b3cc		7569			JNE 0x40b437				
  0x40b3ce		488b542458		MOVQ 0x58(SP), DX			
  0x40b3d3		48894210		MOVQ AX, 0x10(DX)			
		if nextOverflow != nil {
  0x40b3d7		4885c9			TESTQ CX, CX		
  0x40b3da		74b0			JE 0x40b38c		
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
  0x40b3dc		48894c2430		MOVQ CX, 0x30(SP)	
			h.extra = new(mapextra)
  0x40b3e1		488d05589b0500		LEAQ 0x59b58(IP), AX			
  0x40b3e8		48890424		MOVQ AX, 0(SP)				
  0x40b3ec		e85ff3ffff		CALL runtime.newobject(SB)		
  0x40b3f1		488b442408		MOVQ 0x8(SP), AX			
  0x40b3f6		833d231a0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b3fd		751a			JNE 0x40b419				
  0x40b3ff		488b4c2458		MOVQ 0x58(SP), CX			
  0x40b404		48894128		MOVQ AX, 0x28(CX)			
			h.extra.nextOverflow = nextOverflow
  0x40b408		488b542430		MOVQ 0x30(SP), DX	
  0x40b40d		48895010		MOVQ DX, 0x10(AX)	
	return h
  0x40b411		4889ca			MOVQ CX, DX		
			h.extra.nextOverflow = nextOverflow
  0x40b414		e973ffffff		JMP 0x40b38c		
			h.extra = new(mapextra)
  0x40b419		488b4c2458		MOVQ 0x58(SP), CX		
  0x40b41e		488d7928		LEAQ 0x28(CX), DI		
  0x40b422		e859e20300		CALL runtime.gcWriteBarrier(SB)	
			h.extra.nextOverflow = nextOverflow
  0x40b427		488d7810		LEAQ 0x10(AX), DI		
  0x40b42b		488b442430		MOVQ 0x30(SP), AX		
  0x40b430		e84be20300		CALL runtime.gcWriteBarrier(SB)	
			h.extra = new(mapextra)
  0x40b435		ebda			JMP 0x40b411		
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
  0x40b437		488b542458		MOVQ 0x58(SP), DX		
  0x40b43c		488d7a10		LEAQ 0x10(DX), DI		
  0x40b440		e83be20300		CALL runtime.gcWriteBarrier(SB)	
  0x40b445		eb90			JMP 0x40b3d7			
  0x40b447		31db			XORL BX, BX			
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40b449		e933ffffff		JMP 0x40b381		
	for overLoadFactor(hint, B) {
  0x40b44e		4889442428		MOVQ AX, 0x28(SP)	
		h = new(hmap)
  0x40b453		488d0526ee0500		LEAQ 0x5ee26(IP), AX		
  0x40b45a		48890424		MOVQ AX, 0(SP)			
  0x40b45e		e8edf2ffff		CALL runtime.newobject(SB)	
  0x40b463		488b542408		MOVQ 0x8(SP), DX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40b468		488b442428		MOVQ 0x28(SP), AX	
		h = new(hmap)
  0x40b46d		e999feffff		JMP 0x40b30b		
	if overflow || mem > maxAlloc {
  0x40b472		48ba0000000000000100	MOVQ $0x1000000000000, DX	
  0x40b47c		4839d0			CMPQ DX, AX			
  0x40b47f		0f8776feffff		JA 0x40b2fb			
	for overLoadFactor(hint, B) {
  0x40b485		4889d8			MOVQ BX, AX		
	if h == nil {
  0x40b488		e970feffff		JMP 0x40b2fd		
func makemap(t *maptype, hint int, h *hmap) *hmap {
  0x40b48d		e8eec30300		CALL runtime.morestack_noctxt(SB)	
  0x40b492		e929feffff		JMP runtime.makemap(SB)			

TEXT runtime.makeBucketArray(SB) /usr/local/go/src/runtime/map.go
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
  0x40b4a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b4a9		483b6110		CMPQ 0x10(CX), SP	
  0x40b4ad		0f8614020000		JBE 0x40b6c7		
  0x40b4b3		4883ec30		SUBQ $0x30, SP		
  0x40b4b7		48896c2428		MOVQ BP, 0x28(SP)	
  0x40b4bc		488d6c2428		LEAQ 0x28(SP), BP	
	base := bucketShift(b)
  0x40b4c1		90			NOPL			
  0x40b4c2		0fb64c2440		MOVZX 0x40(SP), CX	
	return uintptr(1) << b
  0x40b4c7		ba01000000		MOVL $0x1, DX		
  0x40b4cc		48d3e2			SHLQ CL, DX		
	if b >= 4 {
  0x40b4cf		80f904			CMPL $0x4, CL		
  0x40b4d2		0f82ca010000		JB 0x40b6a2		
		sz := t.bucket.size * nbuckets
  0x40b4d8		488b5c2438		MOVQ 0x38(SP), BX	
  0x40b4dd		488b7340		MOVQ 0x40(BX), SI	
		nbuckets += bucketShift(b - 4)
  0x40b4e1		83c1fc			ADDL $-0x4, CX		
	return uintptr(1) << b
  0x40b4e4		bf01000000		MOVL $0x1, DI		
  0x40b4e9		48d3e7			SHLQ CL, DI		
		nbuckets += bucketShift(b - 4)
  0x40b4ec		4801d7			ADDQ DX, DI		
  0x40b4ef		90			NOPL			
		sz := t.bucket.size * nbuckets
  0x40b4f0		488b36			MOVQ 0(SI), SI		
  0x40b4f3		4989f8			MOVQ DI, R8		
  0x40b4f6		480faffe		IMULQ SI, DI		
		up := roundupsize(sz)
  0x40b4fa		90			NOPL			
	if size < _MaxSmallSize {
  0x40b4fb		4881ff00800000		CMPQ $0x8000, DI	
  0x40b502		0f8372010000		JAE 0x40b67a		
		if size <= smallSizeMax-8 {
  0x40b508		4881fff8030000		CMPQ $0x3f8, DI		
  0x40b50f		0f872e010000		JA 0x40b643		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x40b515		488d4f07		LEAQ 0x7(DI), CX			
  0x40b519		48c1e903		SHRQ $0x3, CX				
  0x40b51d		4881f981000000		CMPQ $0x81, CX				
  0x40b524		0f8396010000		JAE 0x40b6c0				
  0x40b52a		4c8d0d0f3c0b00		LEAQ runtime.size_to_class8(SB), R9	
  0x40b531		420fb60c09		MOVZX 0(CX)(R9*1), CX			
  0x40b536		4883f943		CMPQ $0x43, CX				
  0x40b53a		0f8380010000		JAE 0x40b6c0				
  0x40b540		4c8d0d993c0b00		LEAQ runtime.class_to_size(SB), R9	
  0x40b547		410fb70c49		MOVZX 0(R9)(CX*2), CX			
		if up != sz {
  0x40b54c		4839f9			CMPQ DI, CX		
  0x40b54f		0f84e3000000		JE 0x40b638		
			nbuckets = up / t.bucket.size
  0x40b555		4885f6			TESTQ SI, SI		
  0x40b558		0f8454010000		JE 0x40b6b2		
  0x40b55e		4889c8			MOVQ CX, AX		
	return uintptr(1) << b
  0x40b561		4889d1			MOVQ DX, CX		
			nbuckets = up / t.bucket.size
  0x40b564		31d2			XORL DX, DX		
  0x40b566		48f7f6			DIVQ SI			
	return uintptr(1) << b
  0x40b569		48894c2420		MOVQ CX, 0x20(SP)	
		size := t.bucket.size * nbuckets
  0x40b56e		4889442418		MOVQ AX, 0x18(SP)	
	if dirtyalloc == nil {
  0x40b573		488b542448		MOVQ 0x48(SP), DX	
  0x40b578		4885d2			TESTQ DX, DX		
  0x40b57b		0f849b000000		JE 0x40b61c		
		size := t.bucket.size * nbuckets
  0x40b581		488b7340		MOVQ 0x40(BX), SI	
  0x40b585		488b3e			MOVQ 0(SI), DI		
  0x40b588		480faff8		IMULQ AX, DI		
		if t.bucket.kind&kindNoPointers == 0 {
  0x40b58c		0fb67617		MOVZX 0x17(SI), SI	
  0x40b590		40f6c680		TESTL $0x80, SI		
  0x40b594		7576			JNE 0x40b60c		
			memclrHasPointers(buckets, size)
  0x40b596		48891424		MOVQ DX, 0(SP)				
  0x40b59a		48897c2408		MOVQ DI, 0x8(SP)			
  0x40b59f		e80c230000		CALL runtime.memclrHasPointers(SB)	
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
  0x40b5a4		488b442448		MOVQ 0x48(SP), AX	
	if base != nbuckets {
  0x40b5a9		488b4c2418		MOVQ 0x18(SP), CX	
  0x40b5ae		488b542420		MOVQ 0x20(SP), DX	
  0x40b5b3		4839d1			CMPQ DX, CX		
  0x40b5b6		7450			JE 0x40b608		
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
  0x40b5b8		488b5c2438		MOVQ 0x38(SP), BX	
  0x40b5bd		0fb75b4a		MOVZX 0x4a(BX), BX	
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
  0x40b5c1		48ffc9			DECQ CX			
  0x40b5c4		480fafcb		IMULQ BX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x40b5c8		4801c1			ADDQ AX, CX		
  0x40b5cb		488d3c19		LEAQ 0(CX)(BX*1), DI	
  0x40b5cf		488d7ff8		LEAQ -0x8(DI), DI	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b5d3		8407			TESTB AL, 0(DI)		
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
  0x40b5d5		90			NOPL			
  0x40b5d6		480fafda		IMULQ DX, BX		
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
  0x40b5da		90			NOPL			
		last.setoverflow(t, (*bmap)(buckets))
  0x40b5db		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40b5dc		488d0c18		LEAQ 0(AX)(BX*1), CX	
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b5e0		90			NOPL					
  0x40b5e1		833d38180d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40b5e8		7517			JNE 0x40b601				
  0x40b5ea		488907			MOVQ AX, 0(DI)				
	return buckets, nextOverflow
  0x40b5ed		4889442450		MOVQ AX, 0x50(SP)	
  0x40b5f2		48894c2458		MOVQ CX, 0x58(SP)	
  0x40b5f7		488b6c2428		MOVQ 0x28(SP), BP	
  0x40b5fc		4883c430		ADDQ $0x30, SP		
  0x40b600		c3			RET			
	*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
  0x40b601		e87ae00300		CALL runtime.gcWriteBarrier(SB)	
  0x40b606		ebe5			JMP 0x40b5ed			
  0x40b608		31c9			XORL CX, CX			
	if base != nbuckets {
  0x40b60a		ebe1			JMP 0x40b5ed		
			memclrNoHeapPointers(buckets, size)
  0x40b60c		48891424		MOVQ DX, 0(SP)				
  0x40b610		48897c2408		MOVQ DI, 0x8(SP)			
  0x40b615		e8a6ee0300		CALL runtime.memclrNoHeapPointers(SB)	
  0x40b61a		eb88			JMP 0x40b5a4				
		buckets = newarray(t.bucket, int(nbuckets))
  0x40b61c		488b4b40		MOVQ 0x40(BX), CX		
  0x40b620		48890c24		MOVQ CX, 0(SP)			
  0x40b624		4889442408		MOVQ AX, 0x8(SP)		
  0x40b629		e882f1ffff		CALL runtime.newarray(SB)	
  0x40b62e		488b442410		MOVQ 0x10(SP), AX		
  0x40b633		e971ffffff		JMP 0x40b5a9			
	if base != nbuckets {
  0x40b638		4889d1			MOVQ DX, CX		
		size := t.bucket.size * nbuckets
  0x40b63b		4c89c0			MOVQ R8, AX		
		if up != sz {
  0x40b63e		e926ffffff		JMP 0x40b569		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x40b643		488d8f7ffcffff		LEAQ 0xfffffc7f(DI), CX			
  0x40b64a		48c1e907		SHRQ $0x7, CX				
  0x40b64e		4881f9f9000000		CMPQ $0xf9, CX				
  0x40b655		7362			JAE 0x40b6b9				
  0x40b657		4c8d0d223c0b00		LEAQ runtime.size_to_class128(SB), R9	
  0x40b65e		420fb60c09		MOVZX 0(CX)(R9*1), CX			
  0x40b663		4883f943		CMPQ $0x43, CX				
  0x40b667		7350			JAE 0x40b6b9				
  0x40b669		4c8d0d703b0b00		LEAQ runtime.class_to_size(SB), R9	
  0x40b670		410fb70c49		MOVZX 0(R9)(CX*2), CX			
		up := roundupsize(sz)
  0x40b675		e9d2feffff		JMP 0x40b54c		
	if size+_PageSize < size {
  0x40b67a		488d8f00200000		LEAQ 0x2000(DI), CX	
  0x40b681		4839f9			CMPQ DI, CX		
  0x40b684		7308			JAE 0x40b68e		
		up := roundupsize(sz)
  0x40b686		4889f9			MOVQ DI, CX		
  0x40b689		e9befeffff		JMP 0x40b54c		
	return round(size, _PageSize)
  0x40b68e		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x40b68f		488d8fff1f0000		LEAQ 0x1fff(DI), CX	
  0x40b696		4881e100e0ffff		ANDQ $-0x2000, CX	
		up := roundupsize(sz)
  0x40b69d		e9aafeffff		JMP 0x40b54c		
	if base != nbuckets {
  0x40b6a2		4889d1			MOVQ DX, CX		
		size := t.bucket.size * nbuckets
  0x40b6a5		488b5c2438		MOVQ 0x38(SP), BX	
  0x40b6aa		4889c8			MOVQ CX, AX		
	if b >= 4 {
  0x40b6ad		e9b7feffff		JMP 0x40b569		
			nbuckets = up / t.bucket.size
  0x40b6b2		e8c96a0100		CALL runtime.panicdivide(SB)	
  0x40b6b7		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x40b6b9		e862680100		CALL runtime.panicindex(SB)	
  0x40b6be		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x40b6c0		e85b680100		CALL runtime.panicindex(SB)	
  0x40b6c5		0f0b			UD2				
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
  0x40b6c7		e8b4c10300		CALL runtime.morestack_noctxt(SB)	
  0x40b6cc		e9cffdffff		JMP runtime.makeBucketArray(SB)		

TEXT runtime.mapaccess2(SB) /usr/local/go/src/runtime/map.go
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
  0x40b6e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b6e9		483b6110		CMPQ 0x10(CX), SP	
  0x40b6ed		0f8673020000		JBE 0x40b966		
  0x40b6f3		4883ec40		SUBQ $0x40, SP		
  0x40b6f7		48896c2438		MOVQ BP, 0x38(SP)	
  0x40b6fc		488d6c2438		LEAQ 0x38(SP), BP	
	if h == nil || h.count == 0 {
  0x40b701		488b442450		MOVQ 0x50(SP), AX	
  0x40b706		4885c0			TESTQ AX, AX		
  0x40b709		0f84ee010000		JE 0x40b8fd		
  0x40b70f		48833800		CMPQ $0x0, 0(AX)	
  0x40b713		0f84e4010000		JE 0x40b8fd		
	if h.flags&hashWriting != 0 {
  0x40b719		0fb64808		MOVZX 0x8(AX), CX	
  0x40b71d		f6c104			TESTL $0x4, CL		
  0x40b720		0f8525020000		JNE 0x40b94b		
	alg := t.key.alg
  0x40b726		488b4c2448		MOVQ 0x48(SP), CX	
  0x40b72b		488b5930		MOVQ 0x30(CX), BX	
  0x40b72f		488b5b18		MOVQ 0x18(BX), BX	
  0x40b733		48895c2428		MOVQ BX, 0x28(SP)	
	hash := alg.hash(key, uintptr(h.hash0))
  0x40b738		488b13			MOVQ 0(BX), DX		
  0x40b73b		8b700c			MOVL 0xc(AX), SI	
  0x40b73e		488b7c2458		MOVQ 0x58(SP), DI	
  0x40b743		48893c24		MOVQ DI, 0(SP)		
  0x40b747		4889742408		MOVQ SI, 0x8(SP)	
  0x40b74c		488b32			MOVQ 0(DX), SI		
  0x40b74f		ffd6			CALL SI			
  0x40b751		488b442410		MOVQ 0x10(SP), AX	
	m := bucketMask(h.B)
  0x40b756		90			NOPL			
  0x40b757		488b4c2450		MOVQ 0x50(SP), CX	
  0x40b75c		0fb65909		MOVZX 0x9(CX), BX	
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
  0x40b760		4889ca			MOVQ CX, DX		
	return uintptr(1) << b
  0x40b763		89d9			MOVL BX, CX		
  0x40b765		be01000000		MOVL $0x1, SI		
  0x40b76a		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x40b76d		488d4eff		LEAQ -0x1(SI), CX	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))
  0x40b771		4889cb			MOVQ CX, BX		
  0x40b774		4821c1			ANDQ AX, CX		
  0x40b777		488b742448		MOVQ 0x48(SP), SI	
  0x40b77c		0fb77e4a		MOVZX 0x4a(SI), DI	
  0x40b780		480fafcf		IMULQ DI, CX		
  0x40b784		48034a10		ADDQ 0x10(DX), CX	
	if c := h.oldbuckets; c != nil {
  0x40b788		4c8b4218		MOVQ 0x18(DX), R8	
	return bucketShift(b) - 1
  0x40b78c		90			NOPL			
	if c := h.oldbuckets; c != nil {
  0x40b78d		4d85c0			TESTQ R8, R8		
  0x40b790		7438			JE 0x40b7ca		
		if !h.sameSizeGrow() {
  0x40b792		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40b793		440fb64a08		MOVZX 0x8(DX), R9	
  0x40b798		41f6c108		TESTL $0x8, R9		
		if !h.sameSizeGrow() {
  0x40b79c		0f8453010000		JE 0x40b8f5		
		oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&m)*uintptr(t.bucketsize)))
  0x40b7a2		4821c3			ANDQ AX, BX		
  0x40b7a5		480fafdf		IMULQ DI, BX		
  0x40b7a9		498d3c18		LEAQ 0(R8)(BX*1), DI	
		if !evacuated(oldb) {
  0x40b7ad		90			NOPL			
	h := b.tophash[0]
  0x40b7ae		420fb61c03		MOVZX 0(BX)(R8*1), BX	
	return h > emptyOne && h < minTopHash
  0x40b7b3		80fb01			CMPL $0x1, BL		
  0x40b7b6		0f8632010000		JBE 0x40b8ee		
  0x40b7bc		80fb05			CMPL $0x5, BL		
  0x40b7bf		0f92c3			SETB BL			
		if !evacuated(oldb) {
  0x40b7c2		84db			TESTL BL, BL		
  0x40b7c4		0f841c010000		JE 0x40b8e6		
	top := tophash(hash)
  0x40b7ca		90			NOPL			
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40b7cb		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x40b7cf		3c05			CMPL $0x5, AL		
  0x40b7d1		7303			JAE 0x40b7d6		
		top += minTopHash
  0x40b7d3		83c005			ADDL $0x5, AX		
	top := tophash(hash)
  0x40b7d6		8844241f		MOVB AL, 0x1f(SP)	
	for ; b != nil; b = b.overflow(t) {
  0x40b7da		e9f2000000		JMP 0x40b8d1		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40b7df		48ffc2			INCQ DX			
  0x40b7e2		4883fa08		CMPQ $0x8, DX		
  0x40b7e6		0f83d4000000		JAE 0x40b8c0		
			if b.tophash[i] != top {
  0x40b7ec		0fb61c0a		MOVZX 0(DX)(CX*1), BX	
  0x40b7f0		38d8			CMPL BL, AL		
  0x40b7f2		741f			JE 0x40b813		
				if b.tophash[i] == emptyRest {
  0x40b7f4		84db			TESTL BL, BL		
  0x40b7f6		75e7			JNE 0x40b7df		
	return unsafe.Pointer(&zeroVal[0]), false
  0x40b7f8		488d0561200d00		LEAQ runtime.zeroVal(SB), AX	
  0x40b7ff		4889442460		MOVQ AX, 0x60(SP)		
  0x40b804		c644246800		MOVB $0x0, 0x68(SP)		
  0x40b809		488b6c2438		MOVQ 0x38(SP), BP		
  0x40b80e		4883c440		ADDQ $0x40, SP			
  0x40b812		c3			RET				
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40b813		4889542420		MOVQ DX, 0x20(SP)	
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x40b818		90			NOPL			
  0x40b819		0fb65e48		MOVZX 0x48(SI), BX	
  0x40b81d		480fafda		IMULQ DX, BX		
			if t.indirectkey() {
  0x40b821		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40b822		488d0c0b		LEAQ 0(BX)(CX*1), CX	
  0x40b826		488d4908		LEAQ 0x8(CX), CX	
	return mt.flags&1 != 0
  0x40b82a		8b5e4c			MOVL 0x4c(SI), BX	
  0x40b82d		0fbae300		BTL $0x0, BX		
			if t.indirectkey() {
  0x40b831		7303			JAE 0x40b836		
				k = *((*unsafe.Pointer)(k))
  0x40b833		488b09			MOVQ 0(CX), CX		
			if alg.equal(key, k) {
  0x40b836		488b442428		MOVQ 0x28(SP), AX	
  0x40b83b		488b5008		MOVQ 0x8(AX), DX	
  0x40b83f		488b5c2458		MOVQ 0x58(SP), BX	
  0x40b844		48891c24		MOVQ BX, 0(SP)		
  0x40b848		48894c2408		MOVQ CX, 0x8(SP)	
  0x40b84d		488b0a			MOVQ 0(DX), CX		
  0x40b850		ffd1			CALL CX			
  0x40b852		807c241000		CMPB $0x0, 0x10(SP)	
  0x40b857		7519			JNE 0x40b872		
			if b.tophash[i] != top {
  0x40b859		0fb644241f		MOVZX 0x1f(SP), AX	
  0x40b85e		488b4c2430		MOVQ 0x30(SP), CX	
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40b863		488b542420		MOVQ 0x20(SP), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b868		488b742448		MOVQ 0x48(SP), SI	
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40b86d		e96dffffff		JMP 0x40b7df		
				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40b872		90			NOPL			
  0x40b873		488b442448		MOVQ 0x48(SP), AX	
  0x40b878		0fb64848		MOVZX 0x48(AX), CX	
  0x40b87c		0fb65049		MOVZX 0x49(AX), DX	
  0x40b880		488b5c2420		MOVQ 0x20(SP), BX	
  0x40b885		480fafda		IMULQ DX, BX		
  0x40b889		488d0ccb		LEAQ 0(BX)(CX*8), CX	
				if t.indirectvalue() {
  0x40b88d		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40b88e		488b542430		MOVQ 0x30(SP), DX	
  0x40b893		488d0c0a		LEAQ 0(DX)(CX*1), CX	
  0x40b897		488d4908		LEAQ 0x8(CX), CX	
	return mt.flags&2 != 0
  0x40b89b		8b404c			MOVL 0x4c(AX), AX	
  0x40b89e		0fbae001		BTL $0x1, AX		
				if t.indirectvalue() {
  0x40b8a2		7317			JAE 0x40b8bb		
					v = *((*unsafe.Pointer)(v))
  0x40b8a4		488b01			MOVQ 0(CX), AX		
				return v, true
  0x40b8a7		4889442460		MOVQ AX, 0x60(SP)	
  0x40b8ac		c644246801		MOVB $0x1, 0x68(SP)	
  0x40b8b1		488b6c2438		MOVQ 0x38(SP), BP	
  0x40b8b6		4883c440		ADDQ $0x40, SP		
  0x40b8ba		c3			RET			
  0x40b8bb		4889c8			MOVQ CX, AX		
				if t.indirectvalue() {
  0x40b8be		ebe7			JMP 0x40b8a7		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b8c0		0fb75e4a		MOVZX 0x4a(SI), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40b8c4		488d1c19		LEAQ 0(CX)(BX*1), BX	
  0x40b8c8		488d5bf8		LEAQ -0x8(BX), BX	
	for ; b != nil; b = b.overflow(t) {
  0x40b8cc		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40b8cd		488b0b			MOVQ 0(BX), CX		
  0x40b8d0		90			NOPL			
	for ; b != nil; b = b.overflow(t) {
  0x40b8d1		4885c9			TESTQ CX, CX		
  0x40b8d4		0f841effffff		JE 0x40b7f8		
  0x40b8da		48894c2430		MOVQ CX, 0x30(SP)	
  0x40b8df		31d2			XORL DX, DX		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40b8e1		e9fcfeffff		JMP 0x40b7e2		
	for ; b != nil; b = b.overflow(t) {
  0x40b8e6		4889f9			MOVQ DI, CX		
			b = oldb
  0x40b8e9		e9dcfeffff		JMP 0x40b7ca		
  0x40b8ee		31db			XORL BX, BX		
	return h > emptyOne && h < minTopHash
  0x40b8f0		e9cdfeffff		JMP 0x40b7c2		
			m >>= 1
  0x40b8f5		48d1eb			SHRQ $0x1, BX		
  0x40b8f8		e9a5feffff		JMP 0x40b7a2		
		if t.hashMightPanic() {
  0x40b8fd		90			NOPL			
	return mt.flags&16 != 0
  0x40b8fe		488b442448		MOVQ 0x48(SP), AX	
  0x40b903		8b484c			MOVL 0x4c(AX), CX	
  0x40b906		0fbae104		BTL $0x4, CX		
		if t.hashMightPanic() {
  0x40b90a		721b			JB 0x40b927		
		return unsafe.Pointer(&zeroVal[0]), false
  0x40b90c		488d054d1f0d00		LEAQ runtime.zeroVal(SB), AX	
  0x40b913		4889442460		MOVQ AX, 0x60(SP)		
  0x40b918		c644246800		MOVB $0x0, 0x68(SP)		
  0x40b91d		488b6c2438		MOVQ 0x38(SP), BP		
  0x40b922		4883c440		ADDQ $0x40, SP			
  0x40b926		c3			RET				
			t.key.alg.hash(key, 0) // see issue 23734
  0x40b927		488b4030		MOVQ 0x30(AX), AX	
  0x40b92b		488b4018		MOVQ 0x18(AX), AX	
  0x40b92f		488b10			MOVQ 0(AX), DX		
  0x40b932		488b442458		MOVQ 0x58(SP), AX	
  0x40b937		48890424		MOVQ AX, 0(SP)		
  0x40b93b		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x40b944		488b02			MOVQ 0(DX), AX		
  0x40b947		ffd0			CALL AX			
  0x40b949		ebc1			JMP 0x40b90c		
		throw("concurrent map read and map write")
  0x40b94b		488d05a4670600		LEAQ 0x667a4(IP), AX	
  0x40b952		48890424		MOVQ AX, 0(SP)		
  0x40b956		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40b95f		e81c7b0100		CALL runtime.throw(SB)	
  0x40b964		0f0b			UD2			
func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {
  0x40b966		e815bf0300		CALL runtime.morestack_noctxt(SB)	
  0x40b96b		e970fdffff		JMP runtime.mapaccess2(SB)		

TEXT runtime.mapassign(SB) /usr/local/go/src/runtime/map.go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  0x40b970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40b979		483b6110		CMPQ 0x10(CX), SP	
  0x40b97d		0f86f0050000		JBE 0x40bf73		
  0x40b983		4881ec80000000		SUBQ $0x80, SP		
  0x40b98a		48896c2478		MOVQ BP, 0x78(SP)	
  0x40b98f		488d6c2478		LEAQ 0x78(SP), BP	
	if h == nil {
  0x40b994		488b842490000000	MOVQ 0x90(SP), AX	
  0x40b99c		4885c0			TESTQ AX, AX		
  0x40b99f		0f84b0050000		JE 0x40bf55		
	if h.flags&hashWriting != 0 {
  0x40b9a5		0fb64808		MOVZX 0x8(AX), CX	
  0x40b9a9		f6c104			TESTL $0x4, CL		
  0x40b9ac		0f8588050000		JNE 0x40bf3a		
	alg := t.key.alg
  0x40b9b2		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x40b9ba		488b5930		MOVQ 0x30(CX), BX	
  0x40b9be		488b5b18		MOVQ 0x18(BX), BX	
  0x40b9c2		48895c2460		MOVQ BX, 0x60(SP)	
	hash := alg.hash(key, uintptr(h.hash0))
  0x40b9c7		488b13			MOVQ 0(BX), DX		
  0x40b9ca		8b700c			MOVL 0xc(AX), SI	
  0x40b9cd		488bbc2498000000	MOVQ 0x98(SP), DI	
  0x40b9d5		48893c24		MOVQ DI, 0(SP)		
  0x40b9d9		4889742408		MOVQ SI, 0x8(SP)	
  0x40b9de		488b32			MOVQ 0(DX), SI		
  0x40b9e1		ffd6			CALL SI			
  0x40b9e3		488b442410		MOVQ 0x10(SP), AX	
  0x40b9e8		4889442430		MOVQ AX, 0x30(SP)	
	h.flags ^= hashWriting
  0x40b9ed		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x40b9f5		0fb65908		MOVZX 0x8(CX), BX	
  0x40b9f9		83f304			XORL $0x4, BX		
  0x40b9fc		885908			MOVB BL, 0x8(CX)	
	if h.buckets == nil {
  0x40b9ff		4883791000		CMPQ $0x0, 0x10(CX)	
  0x40ba04		0f84b8040000		JE 0x40bec2		
	bucket := hash & bucketMask(h.B)
  0x40ba0a		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40ba12		e9c8000000		JMP 0x40badf		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40ba17		49ffc2			INCQ R10		
  0x40ba1a		4983fa08		CMPQ $0x8, R10		
  0x40ba1e		0f8338040000		JAE 0x40be5c		
			if b.tophash[i] != top {
  0x40ba24		8406			TESTB AL, 0(SI)		
  0x40ba26		460fb61c16		MOVZX 0(SI)(R10*1), R11	
  0x40ba2b		4e8d2416		LEAQ 0(SI)(R10*1), R12	
  0x40ba2f		4438d8			CMPL R11, AL		
  0x40ba32		0f841c030000		JE 0x40bd54		
				if isEmpty(b.tophash[i]) && inserti == nil {
  0x40ba38		90			NOPL			
	return x <= emptyOne
  0x40ba39		4180fb01		CMPL $0x1, R11		
				if isEmpty(b.tophash[i]) && inserti == nil {
  0x40ba3d		7709			JA 0x40ba48		
  0x40ba3f		4885c9			TESTQ CX, CX		
  0x40ba42		0f84cf020000		JE 0x40bd17		
				if b.tophash[i] == emptyRest {
  0x40ba48		4584db			TESTL R11, R11		
  0x40ba4b		75ca			JNE 0x40ba17		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40ba4d		90			NOPL			
	return h.oldbuckets != nil
  0x40ba4e		48837a1800		CMPQ $0x0, 0x18(DX)	
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40ba53		0f85b6020000		JNE 0x40bd0f		
  0x40ba59		90			NOPL			
  0x40ba5a		4c8b12			MOVQ 0(DX), R10		
  0x40ba5d		49ffc2			INCQ R10		
  0x40ba60		440fb65a09		MOVZX 0x9(DX), R11	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40ba65		4983fa08		CMPQ $0x8, R10		
  0x40ba69		0f8e92020000		JLE 0x40bd01		
	if inserti == nil {
  0x40ba6f		4989cc			MOVQ CX, R12		
	return uintptr(1) << b
  0x40ba72		4489d9			MOVL R11, CX		
  0x40ba75		41bd01000000		MOVL $0x1, R13		
  0x40ba7b		49d3e5			SHLQ CL, R13		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40ba7e		49d1ed			SHRQ $0x1, R13		
  0x40ba81		4f8d746d00		LEAQ 0(R13)(R13*2), R14	
  0x40ba86		4f8d6cb500		LEAQ 0(R13)(R14*4), R13	
  0x40ba8b		4d39ea			CMPQ R13, R10		
  0x40ba8e		410f97c2		SETA R10		
  0x40ba92		90			NOPL			
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40ba93		4584d2			TESTL R10, R10		
  0x40ba96		0f843d020000		JE 0x40bcd9		
  0x40ba9c		b901000000		MOVL $0x1, CX		
  0x40baa1		84c9			TESTL CL, CL		
  0x40baa3		0f8488000000		JE 0x40bb31		
		hashGrow(t, h)
  0x40baa9		48891c24		MOVQ BX, 0(SP)			
  0x40baad		4889542408		MOVQ DX, 0x8(SP)		
  0x40bab2		e8c9040000		CALL runtime.hashGrow(SB)	
		goto again // Growing the table invalidates everything, so try again
  0x40bab7		488b842490000000	MOVQ 0x90(SP), AX	
  0x40babf		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x40bac7		488b542430		MOVQ 0x30(SP), DX	
	bucket := hash & bucketMask(h.B)
  0x40bacc		4889d0			MOVQ DX, AX		
  0x40bacf		488b8c2490000000	MOVQ 0x90(SP), CX	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40bad7		488b9c2488000000	MOVQ 0x88(SP), BX	
	bucket := hash & bucketMask(h.B)
  0x40badf		0fb67109		MOVZX 0x9(CX), SI	
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  0x40bae3		4889ca			MOVQ CX, DX		
	return uintptr(1) << b
  0x40bae6		89f1			MOVL SI, CX		
  0x40bae8		bf01000000		MOVL $0x1, DI		
  0x40baed		48d3e7			SHLQ CL, DI		
	return bucketShift(b) - 1
  0x40baf0		488d77ff		LEAQ -0x1(DI), SI	
	bucket := hash & bucketMask(h.B)
  0x40baf4		4821c6			ANDQ AX, SI		
  0x40baf7		90			NOPL			
	if h.growing() {
  0x40baf8		90			NOPL			
	return bucketShift(b) - 1
  0x40baf9		90			NOPL			
	return h.oldbuckets != nil
  0x40bafa		48837a1800		CMPQ $0x0, 0x18(DX)	
	if h.growing() {
  0x40baff		0f8586030000		JNE 0x40be8b		
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40bb05		0fb77b4a		MOVZX 0x4a(BX), DI	
  0x40bb09		480faff7		IMULQ DI, SI		
  0x40bb0d		48037210		ADDQ 0x10(DX), SI	
	top := tophash(hash)
  0x40bb11		90			NOPL			
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40bb12		4889c7			MOVQ AX, DI		
  0x40bb15		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x40bb19		3c05			CMPL $0x5, AL		
  0x40bb1b		7303			JAE 0x40bb20		
		top += minTopHash
  0x40bb1d		83c005			ADDL $0x5, AX		
	top := tophash(hash)
  0x40bb20		88442427		MOVB AL, 0x27(SP)	
  0x40bb24		31c9			XORL CX, CX		
  0x40bb26		4531c0			XORL R8, R8		
  0x40bb29		4531c9			XORL R9, R9		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40bb2c		e945030000		JMP 0x40be76		
	if inserti == nil {
  0x40bb31		4d85e4			TESTQ R12, R12		
  0x40bb34		0f8456010000		JE 0x40bc90		
		val = *((*unsafe.Pointer)(val))
  0x40bb3a		4c894c2440		MOVQ R9, 0x40(SP)	
	*inserti = top
  0x40bb3f		4c89642458		MOVQ R12, 0x58(SP)	
	if t.indirectkey() {
  0x40bb44		90			NOPL			
	return mt.flags&1 != 0
  0x40bb45		8b4b4c			MOVL 0x4c(BX), CX	
  0x40bb48		0fbae100		BTL $0x0, CX		
	if t.indirectkey() {
  0x40bb4c		0f82d8000000		JB 0x40bc2a		
	if t.indirectvalue() {
  0x40bb52		90			NOPL			
	return mt.flags&2 != 0
  0x40bb53		8b4b4c			MOVL 0x4c(BX), CX	
  0x40bb56		0fbae101		BTL $0x1, CX		
	if t.indirectvalue() {
  0x40bb5a		727d			JB 0x40bbd9		
	typedmemmove(t.key, insertk, key)
  0x40bb5c		488b4330		MOVQ 0x30(BX), AX		
  0x40bb60		48890424		MOVQ AX, 0(SP)			
  0x40bb64		4c89442408		MOVQ R8, 0x8(SP)		
  0x40bb69		488b842498000000	MOVQ 0x98(SP), AX		
  0x40bb71		4889442410		MOVQ AX, 0x10(SP)		
  0x40bb76		e8151a0000		CALL runtime.typedmemmove(SB)	
	*inserti = top
  0x40bb7b		0fb6442427		MOVZX 0x27(SP), AX	
  0x40bb80		488b4c2458		MOVQ 0x58(SP), CX	
  0x40bb85		8801			MOVB AL, 0(CX)		
	h.count++
  0x40bb87		488b842490000000	MOVQ 0x90(SP), AX	
  0x40bb8f		48ff00			INCQ 0(AX)		
		val = *((*unsafe.Pointer)(val))
  0x40bb92		488b4c2440		MOVQ 0x40(SP), CX	
	if h.flags&hashWriting == 0 {
  0x40bb97		0fb65008		MOVZX 0x8(AX), DX	
  0x40bb9b		f6c204			TESTL $0x4, DL		
  0x40bb9e		0f847b030000		JE 0x40bf1f		
	h.flags &^= hashWriting
  0x40bba4		83e2fb			ANDL $-0x5, DX		
  0x40bba7		885008			MOVB DL, 0x8(AX)	
	if t.indirectvalue() {
  0x40bbaa		90			NOPL			
	return mt.flags&2 != 0
  0x40bbab		488b842488000000	MOVQ 0x88(SP), AX	
  0x40bbb3		8b404c			MOVL 0x4c(AX), AX	
  0x40bbb6		0fbae001		BTL $0x1, AX		
	if t.indirectvalue() {
  0x40bbba		7318			JAE 0x40bbd4		
		val = *((*unsafe.Pointer)(val))
  0x40bbbc		488b01			MOVQ 0(CX), AX		
	return val
  0x40bbbf		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x40bbc7		488b6c2478		MOVQ 0x78(SP), BP	
  0x40bbcc		4881c480000000		ADDQ $0x80, SP		
  0x40bbd3		c3			RET			
  0x40bbd4		4889c8			MOVQ CX, AX		
	if t.indirectvalue() {
  0x40bbd7		ebe6			JMP 0x40bbbf		
	typedmemmove(t.key, insertk, key)
  0x40bbd9		4c89442450		MOVQ R8, 0x50(SP)	
		vmem := newobject(t.elem)
  0x40bbde		488b4338		MOVQ 0x38(BX), AX	
  0x40bbe2		90			NOPL			
	return mallocgc(typ.size, typ, true)
  0x40bbe3		488b08			MOVQ 0(AX), CX			
  0x40bbe6		48890c24		MOVQ CX, 0(SP)			
  0x40bbea		4889442408		MOVQ AX, 0x8(SP)		
  0x40bbef		c644241001		MOVB $0x1, 0x10(SP)		
  0x40bbf4		e817e0ffff		CALL runtime.mallocgc(SB)	
		*(*unsafe.Pointer)(val) = vmem
  0x40bbf9		488b7c2440		MOVQ 0x40(SP), DI	
  0x40bbfe		8407			TESTB AL, 0(DI)		
	return mallocgc(typ.size, typ, true)
  0x40bc00		488b442418		MOVQ 0x18(SP), AX	
		*(*unsafe.Pointer)(val) = vmem
  0x40bc05		833d14120d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40bc0c		7515			JNE 0x40bc23				
  0x40bc0e		488907			MOVQ AX, 0(DI)				
	typedmemmove(t.key, insertk, key)
  0x40bc11		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40bc19		4c8b442450		MOVQ 0x50(SP), R8	
		*(*unsafe.Pointer)(val) = vmem
  0x40bc1e		e939ffffff		JMP 0x40bb5c			
  0x40bc23		e858da0300		CALL runtime.gcWriteBarrier(SB)	
  0x40bc28		ebe7			JMP 0x40bc11			
	typedmemmove(t.key, insertk, key)
  0x40bc2a		4c89442450		MOVQ R8, 0x50(SP)	
		kmem := newobject(t.key)
  0x40bc2f		488b4330		MOVQ 0x30(BX), AX	
  0x40bc33		90			NOPL			
	return mallocgc(typ.size, typ, true)
  0x40bc34		488b08			MOVQ 0(AX), CX			
  0x40bc37		48890c24		MOVQ CX, 0(SP)			
  0x40bc3b		4889442408		MOVQ AX, 0x8(SP)		
  0x40bc40		c644241001		MOVB $0x1, 0x10(SP)		
  0x40bc45		e8c6dfffff		CALL runtime.mallocgc(SB)	
		*(*unsafe.Pointer)(insertk) = kmem
  0x40bc4a		488b7c2450		MOVQ 0x50(SP), DI	
  0x40bc4f		8407			TESTB AL, 0(DI)		
	return mallocgc(typ.size, typ, true)
  0x40bc51		488b442418		MOVQ 0x18(SP), AX	
		*(*unsafe.Pointer)(insertk) = kmem
  0x40bc56		833dc3110d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40bc5d		752a			JNE 0x40bc89				
  0x40bc5f		488907			MOVQ AX, 0(DI)				
	h.count++
  0x40bc62		488b942490000000	MOVQ 0x90(SP), DX	
	return mt.flags&2 != 0
  0x40bc6a		488b9c2488000000	MOVQ 0x88(SP), BX	
		val = *((*unsafe.Pointer)(val))
  0x40bc72		4c8b4c2440		MOVQ 0x40(SP), R9	
	*inserti = top
  0x40bc77		4c8b642458		MOVQ 0x58(SP), R12	
	typedmemmove(t.key, insertk, key)
  0x40bc7c		4989c0			MOVQ AX, R8		
	*inserti = top
  0x40bc7f		0fb6442427		MOVZX 0x27(SP), AX	
		insertk = kmem
  0x40bc84		e9c9feffff		JMP 0x40bb52		
		*(*unsafe.Pointer)(insertk) = kmem
  0x40bc89		e8f2d90300		CALL runtime.gcWriteBarrier(SB)	
  0x40bc8e		ebd2			JMP 0x40bc62			
		newb := h.newoverflow(t, b)
  0x40bc90		48891424		MOVQ DX, 0(SP)				
  0x40bc94		48895c2408		MOVQ BX, 0x8(SP)			
  0x40bc99		4889742410		MOVQ SI, 0x10(SP)			
  0x40bc9e		e83df3ffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x40bca3		4c8b642418		MOVQ 0x18(SP), R12			
		inserti = &newb.tophash[0]
  0x40bca8		41840424		TESTB AL, 0(R12)	
		insertk = add(unsafe.Pointer(newb), dataOffset)
  0x40bcac		90			NOPL			
		val = add(insertk, bucketCnt*uintptr(t.keysize))
  0x40bcad		90			NOPL			
  0x40bcae		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40bcb6		0fb64348		MOVZX 0x48(BX), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40bcba		4d8d442408		LEAQ 0x8(R12), R8	
  0x40bcbf		4d8d0cc4		LEAQ 0(R12)(AX*8), R9	
  0x40bcc3		4d8d4908		LEAQ 0x8(R9), R9	
	*inserti = top
  0x40bcc7		0fb6442427		MOVZX 0x27(SP), AX	
	h.count++
  0x40bccc		488b942490000000	MOVQ 0x90(SP), DX	
		val = add(insertk, bucketCnt*uintptr(t.keysize))
  0x40bcd4		e961feffff		JMP 0x40bb3a		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40bcd9		90			NOPL			
  0x40bcda		440fb7520a		MOVZX 0xa(DX), R10	
	if B > 15 {
  0x40bcdf		80f90f			CMPL $0xf, CL		
  0x40bce2		7605			JBE 0x40bce9		
  0x40bce4		b90f000000		MOVL $0xf, CX		
	return noverflow >= uint16(1)<<(B&15)
  0x40bce9		83e10f			ANDL $0xf, CX		
  0x40bcec		41bb01000000		MOVL $0x1, R11		
  0x40bcf2		41d3e3			SHLL CL, R11		
  0x40bcf5		664539da		CMPW R11, R10		
  0x40bcf9		0f93c1			SETAE CL		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40bcfc		e9a0fdffff		JMP 0x40baa1		
	if inserti == nil {
  0x40bd01		4989cc			MOVQ CX, R12		
  0x40bd04		4531d2			XORL R10, R10		
	if B > 15 {
  0x40bd07		4489d9			MOVL R11, CX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40bd0a		e984fdffff		JMP 0x40ba93		
	if inserti == nil {
  0x40bd0f		4989cc			MOVQ CX, R12		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40bd12		e91afeffff		JMP 0x40bb31		
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x40bd17		90			NOPL			
  0x40bd18		440fb66b48		MOVZX 0x48(BX), R13	
  0x40bd1d		4d89d6			MOVQ R10, R14		
  0x40bd20		4d0fafd5		IMULQ R13, R10		
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40bd24		90			NOPL			
  0x40bd25		440fb67b49		MOVZX 0x49(BX), R15	
  0x40bd2a		4d0faffe		IMULQ R14, R15		
  0x40bd2e		4f8d2cef		LEAQ 0(R15)(R13*8), R13	
	return unsafe.Pointer(uintptr(p) + x)
  0x40bd32		4989f7			MOVQ SI, R15		
  0x40bd35		4d8d0432		LEAQ 0(R10)(SI*1), R8	
  0x40bd39		4d8d4008		LEAQ 0x8(R8), R8	
  0x40bd3d		4d8d4c3500		LEAQ 0(R13)(SI*1), R9	
  0x40bd42		4d8d4908		LEAQ 0x8(R9), R9	
			if b.tophash[i] != top {
  0x40bd46		4c89fe			MOVQ R15, SI		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40bd49		4d89f2			MOVQ R14, R10		
	if inserti == nil {
  0x40bd4c		4c89e1			MOVQ R12, CX		
					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40bd4f		e9f4fcffff		JMP 0x40ba48		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40bd54		4c89542428		MOVQ R10, 0x28(SP)	
		val = *((*unsafe.Pointer)(val))
  0x40bd59		4c894c2440		MOVQ R9, 0x40(SP)	
	typedmemmove(t.key, insertk, key)
  0x40bd5e		4c89442468		MOVQ R8, 0x68(SP)	
	if inserti == nil {
  0x40bd63		48894c2458		MOVQ CX, 0x58(SP)	
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x40bd68		90			NOPL			
  0x40bd69		440fb65b48		MOVZX 0x48(BX), R11	
  0x40bd6e		4d0fafda		IMULQ R10, R11		
			if t.indirectkey() {
  0x40bd72		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40bd73		498d3433		LEAQ 0(R11)(SI*1), SI	
  0x40bd77		488d7608		LEAQ 0x8(SI), SI	
	return mt.flags&1 != 0
  0x40bd7b		448b5b4c		MOVL 0x4c(BX), R11	
  0x40bd7f		410fbae300		BTL $0x0, R11		
			if t.indirectkey() {
  0x40bd84		7303			JAE 0x40bd89		
				k = *((*unsafe.Pointer)(k))
  0x40bd86		488b36			MOVQ 0(SI), SI		
			if !alg.equal(key, k) {
  0x40bd89		4889742448		MOVQ SI, 0x48(SP)	
  0x40bd8e		488b442460		MOVQ 0x60(SP), AX	
  0x40bd93		488b5008		MOVQ 0x8(AX), DX	
  0x40bd97		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x40bd9f		48890c24		MOVQ CX, 0(SP)		
  0x40bda3		4889742408		MOVQ SI, 0x8(SP)	
  0x40bda8		488b1a			MOVQ 0(DX), BX		
  0x40bdab		ffd3			CALL BX			
  0x40bdad		807c241000		CMPB $0x0, 0x10(SP)	
  0x40bdb2		7538			JNE 0x40bdec		
			if b.tophash[i] != top {
  0x40bdb4		0fb6442427		MOVZX 0x27(SP), AX	
	return h.oldbuckets != nil
  0x40bdb9		488b942490000000	MOVQ 0x90(SP), DX	
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
  0x40bdc1		488b9c2488000000	MOVQ 0x88(SP), BX	
			if b.tophash[i] != top {
  0x40bdc9		488b742470		MOVQ 0x70(SP), SI	
	bucket := hash & bucketMask(h.B)
  0x40bdce		488b7c2430		MOVQ 0x30(SP), DI	
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40bdd3		4c8b542428		MOVQ 0x28(SP), R10	
	if inserti == nil {
  0x40bdd8		488b4c2458		MOVQ 0x58(SP), CX	
	typedmemmove(t.key, insertk, key)
  0x40bddd		4c8b442468		MOVQ 0x68(SP), R8	
		val = *((*unsafe.Pointer)(val))
  0x40bde2		4c8b4c2440		MOVQ 0x40(SP), R9	
				continue
  0x40bde7		e92bfcffff		JMP 0x40ba17		
			if t.needkeyupdate() {
  0x40bdec		90			NOPL			
	return mt.flags&8 != 0
  0x40bded		488b842488000000	MOVQ 0x88(SP), AX	
  0x40bdf5		8b484c			MOVL 0x4c(AX), CX	
  0x40bdf8		0fbae103		BTL $0x3, CX		
			if t.needkeyupdate() {
  0x40bdfc		7230			JB 0x40be2e		
			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40bdfe		90			NOPL			
  0x40bdff		0fb65048		MOVZX 0x48(AX), DX	
  0x40be03		0fb65849		MOVZX 0x49(AX), BX	
  0x40be07		488b742428		MOVQ 0x28(SP), SI	
  0x40be0c		480fafde		IMULQ SI, BX		
  0x40be10		488d14d3		LEAQ 0(BX)(DX*8), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40be14		488b5c2470		MOVQ 0x70(SP), BX	
  0x40be19		488d0c13		LEAQ 0(BX)(DX*1), CX	
  0x40be1d		488d4908		LEAQ 0x8(CX), CX	
	if h.flags&hashWriting == 0 {
  0x40be21		488b842490000000	MOVQ 0x90(SP), AX	
			goto done
  0x40be29		e969fdffff		JMP 0x40bb97		
				typedmemmove(t.key, k, key)
  0x40be2e		488b4830		MOVQ 0x30(AX), CX		
  0x40be32		48890c24		MOVQ CX, 0(SP)			
  0x40be36		488b4c2448		MOVQ 0x48(SP), CX		
  0x40be3b		48894c2408		MOVQ CX, 0x8(SP)		
  0x40be40		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x40be48		48894c2410		MOVQ CX, 0x10(SP)		
  0x40be4d		e83e170000		CALL runtime.typedmemmove(SB)	
			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
  0x40be52		488b842488000000	MOVQ 0x88(SP), AX	
				typedmemmove(t.key, k, key)
  0x40be5a		eba2			JMP 0x40bdfe		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40be5c		440fb7534a		MOVZX 0x4a(BX), R10	
	return unsafe.Pointer(uintptr(p) + x)
  0x40be61		4989f3			MOVQ SI, R11		
  0x40be64		4a8d3416		LEAQ 0(SI)(R10*1), SI	
  0x40be68		488d76f8		LEAQ -0x8(SI), SI	
		ovf := b.overflow(t)
  0x40be6c		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40be6d		488b36			MOVQ 0(SI), SI		
  0x40be70		90			NOPL			
		if ovf == nil {
  0x40be71		4885f6			TESTQ SI, SI		
  0x40be74		740d			JE 0x40be83		
		ovf := b.overflow(t)
  0x40be76		4889742470		MOVQ SI, 0x70(SP)	
  0x40be7b		4531d2			XORL R10, R10		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40be7e		e997fbffff		JMP 0x40ba1a		
		newb := h.newoverflow(t, b)
  0x40be83		4c89de			MOVQ R11, SI		
			break
  0x40be86		e9c2fbffff		JMP 0x40ba4d		
	bucket := hash & bucketMask(h.B)
  0x40be8b		4889742438		MOVQ SI, 0x38(SP)	
		growWork(t, h, bucket)
  0x40be90		48891c24		MOVQ BX, 0(SP)			
  0x40be94		4889542408		MOVQ DX, 0x8(SP)		
  0x40be99		4889742410		MOVQ SI, 0x10(SP)		
  0x40be9e		e80d030000		CALL runtime.growWork(SB)	
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40bea3		488b442430		MOVQ 0x30(SP), AX	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40bea8		488b942490000000	MOVQ 0x90(SP), DX	
  0x40beb0		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x40beb8		488b742438		MOVQ 0x38(SP), SI	
		growWork(t, h, bucket)
  0x40bebd		e943fcffff		JMP 0x40bb05		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40bec2		488b842488000000	MOVQ 0x88(SP), AX	
  0x40beca		488b4840		MOVQ 0x40(AX), CX	
  0x40bece		90			NOPL			
	return mallocgc(typ.size, typ, true)
  0x40becf		488b11			MOVQ 0(CX), DX			
  0x40bed2		48891424		MOVQ DX, 0(SP)			
  0x40bed6		48894c2408		MOVQ CX, 0x8(SP)		
  0x40bedb		c644241001		MOVB $0x1, 0x10(SP)		
  0x40bee0		e82bddffff		CALL runtime.mallocgc(SB)	
  0x40bee5		488b442418		MOVQ 0x18(SP), AX		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40beea		833d2f0f0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40bef1		7519			JNE 0x40bf0c				
  0x40bef3		488b9c2490000000	MOVQ 0x90(SP), BX			
  0x40befb		48894310		MOVQ AX, 0x10(BX)			
	bucket := hash & bucketMask(h.B)
  0x40beff		488b442430		MOVQ 0x30(SP), AX	
  0x40bf04		4889d9			MOVQ BX, CX		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40bf07		e9fefaffff		JMP 0x40ba0a		
	if h.buckets == nil {
  0x40bf0c		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x40bf14		488d7b10		LEAQ 0x10(BX), DI	
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40bf18		e863d70300		CALL runtime.gcWriteBarrier(SB)	
  0x40bf1d		ebe0			JMP 0x40beff			
		throw("concurrent map writes")
  0x40bf1f		488d05f3480600		LEAQ 0x648f3(IP), AX	
  0x40bf26		48890424		MOVQ AX, 0(SP)		
  0x40bf2a		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x40bf33		e848750100		CALL runtime.throw(SB)	
  0x40bf38		0f0b			UD2			
		throw("concurrent map writes")
  0x40bf3a		488d05d8480600		LEAQ 0x648d8(IP), AX	
  0x40bf41		48890424		MOVQ AX, 0(SP)		
  0x40bf45		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x40bf4e		e82d750100		CALL runtime.throw(SB)	
  0x40bf53		0f0b			UD2			
		panic(plainError("assignment to entry in nil map"))
  0x40bf55		488d05a4310500		LEAQ 0x531a4(IP), AX			
  0x40bf5c		48890424		MOVQ AX, 0(SP)				
  0x40bf60		488d0509100700		LEAQ runtime.statictmp_11(SB), AX	
  0x40bf67		4889442408		MOVQ AX, 0x8(SP)			
  0x40bf6c		e83f6f0100		CALL runtime.gopanic(SB)		
  0x40bf71		0f0b			UD2					
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  0x40bf73		e808b90300		CALL runtime.morestack_noctxt(SB)	
  0x40bf78		e9f3f9ffff		JMP runtime.mapassign(SB)		

TEXT runtime.hashGrow(SB) /usr/local/go/src/runtime/map.go
func hashGrow(t *maptype, h *hmap) {
  0x40bf80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40bf89		483b6110		CMPQ 0x10(CX), SP	
  0x40bf8d		0f8606020000		JBE 0x40c199		
  0x40bf93		4883ec48		SUBQ $0x48, SP		
  0x40bf97		48896c2440		MOVQ BP, 0x40(SP)	
  0x40bf9c		488d6c2440		LEAQ 0x40(SP), BP	
	if !overLoadFactor(h.count+1, h.B) {
  0x40bfa1		90			NOPL			
  0x40bfa2		488b442458		MOVQ 0x58(SP), AX	
  0x40bfa7		488b10			MOVQ 0(AX), DX		
  0x40bfaa		48ffc2			INCQ DX			
  0x40bfad		0fb64809		MOVZX 0x9(AX), CX	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40bfb1		4883fa08		CMPQ $0x8, DX		
  0x40bfb5		0f8ebc010000		JLE 0x40c177		
	return uintptr(1) << b
  0x40bfbb		bb01000000		MOVL $0x1, BX		
  0x40bfc0		48d3e3			SHLQ CL, BX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40bfc3		48d1eb			SHRQ $0x1, BX		
  0x40bfc6		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x40bfca		488d1cb3		LEAQ 0(BX)(SI*4), BX	
  0x40bfce		4839da			CMPQ BX, DX		
  0x40bfd1		0f97c2			SETA DL			
  0x40bfd4		90			NOPL			
	if !overLoadFactor(h.count+1, h.B) {
  0x40bfd5		84d2			TESTL DL, DL		
  0x40bfd7		0f848b010000		JE 0x40c168		
  0x40bfdd		8854242f		MOVB DL, 0x2f(SP)	
	oldbuckets := h.buckets
  0x40bfe1		488b4810		MOVQ 0x10(AX), CX	
  0x40bfe5		48894c2430		MOVQ CX, 0x30(SP)	
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
  0x40bfea		0fb65809		MOVZX 0x9(AX), BX			
  0x40bfee		488b742450		MOVQ 0x50(SP), SI			
  0x40bff3		48893424		MOVQ SI, 0(SP)				
  0x40bff7		01d3			ADDL DX, BX				
  0x40bff9		885c2408		MOVB BL, 0x8(SP)			
  0x40bffd		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x40c006		e895f4ffff		CALL runtime.makeBucketArray(SB)	
  0x40c00b		488b442418		MOVQ 0x18(SP), AX			
  0x40c010		488b4c2420		MOVQ 0x20(SP), CX			
	flags := h.flags &^ (iterator | oldIterator)
  0x40c015		488b542458		MOVQ 0x58(SP), DX	
  0x40c01a		0fb65a08		MOVZX 0x8(DX), BX	
  0x40c01e		89de			MOVL BX, SI		
  0x40c020		83e3fc			ANDL $-0x4, BX		
	if h.flags&iterator != 0 {
  0x40c023		40f6c601		TESTL $0x1, SI		
  0x40c027		7403			JE 0x40c02c		
		flags |= oldIterator
  0x40c029		83cb02			ORL $0x2, BX		
	h.B += bigger
  0x40c02c		0fb67209		MOVZX 0x9(DX), SI	
  0x40c030		440fb644242f		MOVZX 0x2f(SP), R8	
  0x40c036		4401c6			ADDL R8, SI		
  0x40c039		40887209		MOVB SI, 0x9(DX)	
	h.flags = flags
  0x40c03d		885a08			MOVB BL, 0x8(DX)	
	h.oldbuckets = oldbuckets
  0x40c040		833dd90d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c047		0f85f9000000		JNE 0x40c146				
  0x40c04d		488b5c2430		MOVQ 0x30(SP), BX			
  0x40c052		48895a18		MOVQ BX, 0x18(DX)			
	h.buckets = newbuckets
  0x40c056		48894210		MOVQ AX, 0x10(DX)	
	h.nevacuate = 0
  0x40c05a		48c7422000000000	MOVQ $0x0, 0x20(DX)	
	h.noverflow = 0
  0x40c062		66c7420a0000		MOVW $0x0, 0xa(DX)	
	if h.extra != nil && h.extra.overflow != nil {
  0x40c068		488b5a28		MOVQ 0x28(DX), BX	
  0x40c06c		4885db			TESTQ BX, BX		
  0x40c06f		743e			JE 0x40c0af		
  0x40c071		488b03			MOVQ 0(BX), AX		
  0x40c074		4885c0			TESTQ AX, AX		
  0x40c077		7436			JE 0x40c0af		
		if h.extra.oldoverflow != nil {
  0x40c079		48837b0800		CMPQ $0x0, 0x8(BX)	
  0x40c07e		0f85fa000000		JNE 0x40c17e		
		h.extra.oldoverflow = h.extra.overflow
  0x40c084		833d950d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c08b		0f85a7000000		JNE 0x40c138				
  0x40c091		48894308		MOVQ AX, 0x8(BX)			
		h.extra.overflow = nil
  0x40c095		488b7a28		MOVQ 0x28(DX), DI			
  0x40c099		8407			TESTB AL, 0(DI)				
  0x40c09b		833d7e0d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c0a2		0f8584000000		JNE 0x40c12c				
  0x40c0a8		48c70700000000		MOVQ $0x0, 0(DI)			
	if nextOverflow != nil {
  0x40c0af		4885c9			TESTQ CX, CX		
  0x40c0b2		741a			JE 0x40c0ce		
		if h.extra == nil {
  0x40c0b4		48837a2800		CMPQ $0x0, 0x28(DX)	
  0x40c0b9		742b			JE 0x40c0e6		
		h.extra.nextOverflow = nextOverflow
  0x40c0bb		488b5228		MOVQ 0x28(DX), DX			
  0x40c0bf		8402			TESTB AL, 0(DX)				
  0x40c0c1		833d580d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c0c8		750e			JNE 0x40c0d8				
  0x40c0ca		48894a10		MOVQ CX, 0x10(DX)			
  0x40c0ce		488b6c2440		MOVQ 0x40(SP), BP			
  0x40c0d3		4883c448		ADDQ $0x48, SP				
  0x40c0d7		c3			RET					
  0x40c0d8		488d7a10		LEAQ 0x10(DX), DI			
  0x40c0dc		4889c8			MOVQ CX, AX				
  0x40c0df		e89cd50300		CALL runtime.gcWriteBarrier(SB)		
  0x40c0e4		ebe8			JMP 0x40c0ce				
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
  0x40c0e6		48894c2438		MOVQ CX, 0x38(SP)	
			h.extra = new(mapextra)
  0x40c0eb		488d054e8e0500		LEAQ 0x58e4e(IP), AX			
  0x40c0f2		48890424		MOVQ AX, 0(SP)				
  0x40c0f6		e855e6ffff		CALL runtime.newobject(SB)		
  0x40c0fb		488b442408		MOVQ 0x8(SP), AX			
  0x40c100		833d190d0d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c107		7513			JNE 0x40c11c				
  0x40c109		488b4c2458		MOVQ 0x58(SP), CX			
  0x40c10e		48894128		MOVQ AX, 0x28(CX)			
		h.extra.nextOverflow = nextOverflow
  0x40c112		4889ca			MOVQ CX, DX		
  0x40c115		488b4c2438		MOVQ 0x38(SP), CX	
			h.extra = new(mapextra)
  0x40c11a		eb9f			JMP 0x40c0bb		
	if h.extra != nil && h.extra.overflow != nil {
  0x40c11c		488b4c2458		MOVQ 0x58(SP), CX	
  0x40c121		488d7928		LEAQ 0x28(CX), DI	
			h.extra = new(mapextra)
  0x40c125		e856d50300		CALL runtime.gcWriteBarrier(SB)	
  0x40c12a		ebe6			JMP 0x40c112			
		h.extra.overflow = nil
  0x40c12c		31c0			XORL AX, AX			
  0x40c12e		e84dd50300		CALL runtime.gcWriteBarrier(SB)	
  0x40c133		e977ffffff		JMP 0x40c0af			
		if h.extra.oldoverflow != nil {
  0x40c138		488d7b08		LEAQ 0x8(BX), DI	
		h.extra.oldoverflow = h.extra.overflow
  0x40c13c		e83fd50300		CALL runtime.gcWriteBarrier(SB)	
  0x40c141		e94fffffff		JMP 0x40c095			
	h.oldbuckets = oldbuckets
  0x40c146		488d7a18		LEAQ 0x18(DX), DI	
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)
  0x40c14a		4889c3			MOVQ AX, BX		
	h.oldbuckets = oldbuckets
  0x40c14d		488b442430		MOVQ 0x30(SP), AX		
  0x40c152		e829d50300		CALL runtime.gcWriteBarrier(SB)	
	oldbuckets := h.buckets
  0x40c157		488d7a10		LEAQ 0x10(DX), DI	
	h.buckets = newbuckets
  0x40c15b		4889d8			MOVQ BX, AX			
  0x40c15e		e81dd50300		CALL runtime.gcWriteBarrier(SB)	
	h.oldbuckets = oldbuckets
  0x40c163		e9f2feffff		JMP 0x40c05a		
		h.flags |= sameSizeGrow
  0x40c168		0fb64808		MOVZX 0x8(AX), CX	
  0x40c16c		83c908			ORL $0x8, CX		
  0x40c16f		884808			MOVB CL, 0x8(AX)	
  0x40c172		e966feffff		JMP 0x40bfdd		
  0x40c177		31d2			XORL DX, DX		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40c179		e957feffff		JMP 0x40bfd5		
			throw("oldoverflow is not nil")
  0x40c17e		488d05ae480600		LEAQ 0x648ae(IP), AX	
  0x40c185		48890424		MOVQ AX, 0(SP)		
  0x40c189		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40c192		e8e9720100		CALL runtime.throw(SB)	
  0x40c197		0f0b			UD2			
func hashGrow(t *maptype, h *hmap) {
  0x40c199		e8e2b60300		CALL runtime.morestack_noctxt(SB)	
  0x40c19e		e9ddfdffff		JMP runtime.hashGrow(SB)		

TEXT runtime.growWork(SB) /usr/local/go/src/runtime/map.go
func growWork(t *maptype, h *hmap, bucket uintptr) {
  0x40c1b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c1b9		483b6110		CMPQ 0x10(CX), SP	
  0x40c1bd		0f868b000000		JBE 0x40c24e		
  0x40c1c3		4883ec20		SUBQ $0x20, SP		
  0x40c1c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x40c1cc		488d6c2418		LEAQ 0x18(SP), BP	
	evacuate(t, h, bucket&h.oldbucketmask())
  0x40c1d1		90			NOPL			
	return h.noldbuckets() - 1
  0x40c1d2		90			NOPL			
	evacuate(t, h, bucket&h.oldbucketmask())
  0x40c1d3		488b442430		MOVQ 0x30(SP), AX	
	oldB := h.B
  0x40c1d8		0fb65009		MOVZX 0x9(AX), DX	
	if !h.sameSizeGrow() {
  0x40c1dc		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40c1dd		0fb65808		MOVZX 0x8(AX), BX	
  0x40c1e1		f6c308			TESTL $0x8, BL		
	if !h.sameSizeGrow() {
  0x40c1e4		7464			JE 0x40c24a		
	return bucketShift(oldB)
  0x40c1e6		90			NOPL			
	evacuate(t, h, bucket&h.oldbucketmask())
  0x40c1e7		488b5c2428		MOVQ 0x28(SP), BX	
  0x40c1ec		48891c24		MOVQ BX, 0(SP)		
  0x40c1f0		4889442408		MOVQ AX, 0x8(SP)	
	return uintptr(1) << b
  0x40c1f5		89d1			MOVL DX, CX		
  0x40c1f7		be01000000		MOVL $0x1, SI		
  0x40c1fc		48d3e6			SHLQ CL, SI		
	return h.noldbuckets() - 1
  0x40c1ff		488d56ff		LEAQ -0x1(SI), DX	
	evacuate(t, h, bucket&h.oldbucketmask())
  0x40c203		488b742438		MOVQ 0x38(SP), SI		
  0x40c208		4821d6			ANDQ DX, SI			
  0x40c20b		4889742410		MOVQ SI, 0x10(SP)		
  0x40c210		e84b000000		CALL runtime.evacuate(SB)	
	if h.growing() {
  0x40c215		90			NOPL			
	return h.oldbuckets != nil
  0x40c216		488b442430		MOVQ 0x30(SP), AX	
  0x40c21b		4883781800		CMPQ $0x0, 0x18(AX)	
	if h.growing() {
  0x40c220		750a			JNE 0x40c22c		
  0x40c222		488b6c2418		MOVQ 0x18(SP), BP	
  0x40c227		4883c420		ADDQ $0x20, SP		
  0x40c22b		c3			RET			
		evacuate(t, h, h.nevacuate)
  0x40c22c		488b4820		MOVQ 0x20(AX), CX		
  0x40c230		488b542428		MOVQ 0x28(SP), DX		
  0x40c235		48891424		MOVQ DX, 0(SP)			
  0x40c239		4889442408		MOVQ AX, 0x8(SP)		
  0x40c23e		48894c2410		MOVQ CX, 0x10(SP)		
  0x40c243		e818000000		CALL runtime.evacuate(SB)	
  0x40c248		ebd8			JMP 0x40c222			
		oldB--
  0x40c24a		ffca			DECL DX			
  0x40c24c		eb98			JMP 0x40c1e6		
func growWork(t *maptype, h *hmap, bucket uintptr) {
  0x40c24e		e82db60300		CALL runtime.morestack_noctxt(SB)	
  0x40c253		e958ffffff		JMP runtime.growWork(SB)		

TEXT runtime.evacuate(SB) /usr/local/go/src/runtime/map.go
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
  0x40c260		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c269		488d4424d0		LEAQ -0x30(SP), AX	
  0x40c26e		483b4110		CMPQ 0x10(CX), AX	
  0x40c272		0f8615060000		JBE 0x40c88d		
  0x40c278		4881ecb0000000		SUBQ $0xb0, SP		
  0x40c27f		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x40c287		488dac24a8000000	LEAQ 0xa8(SP), BP	
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
  0x40c28f		90			NOPL			
  0x40c290		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x40c298		0fb7734a		MOVZX 0x4a(BX), SI	
  0x40c29c		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
  0x40c2a4		490faff0		IMULQ R8, SI		
	newbit := h.noldbuckets()
  0x40c2a8		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c2a9		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
  0x40c2b1		49037118		ADDQ 0x18(R9), SI	
	oldB := h.B
  0x40c2b5		450fb65109		MOVZX 0x9(R9), R10	
	if !h.sameSizeGrow() {
  0x40c2ba		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40c2bb		450fb65908		MOVZX 0x8(R9), R11	
  0x40c2c0		41f6c308		TESTL $0x8, R11		
	if !h.sameSizeGrow() {
  0x40c2c4		0f8499050000		JE 0x40c863		
	if !evacuated(b) {
  0x40c2ca		90			NOPL			
	return bucketShift(oldB)
  0x40c2cb		90			NOPL			
	h := b.tophash[0]
  0x40c2cc		440fb61e		MOVZX 0(SI), R11	
	return h > emptyOne && h < minTopHash
  0x40c2d0		4180fb01		CMPL $0x1, R11		
  0x40c2d4		0f8681050000		JBE 0x40c85b		
  0x40c2da		4180fb05		CMPL $0x5, R11		
  0x40c2de		410f92c3		SETB R11		
	return uintptr(1) << b
  0x40c2e2		4489d1			MOVL R10, CX		
  0x40c2e5		41bc01000000		MOVL $0x1, R12		
  0x40c2eb		49d3e4			SHLQ CL, R12		
	if !evacuated(b) {
  0x40c2ee		4584db			TESTL R11, R11		
  0x40c2f1		0f85b1040000		JNE 0x40c7a8		
		var xy [2]evacDst
  0x40c2f7		0f57c0			XORPS X0, X0		
  0x40c2fa		0f11442468		MOVUPS X0, 0x68(SP)	
  0x40c2ff		0f11442478		MOVUPS X0, 0x78(SP)	
  0x40c304		0f11842488000000	MOVUPS X0, 0x88(SP)	
  0x40c30c		0f11842498000000	MOVUPS X0, 0x98(SP)	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x40c314		90			NOPL			
  0x40c315		440fb75b4a		MOVZX 0x4a(BX), R11	
  0x40c31a		4d0fafd8		IMULQ R8, R11		
	return unsafe.Pointer(uintptr(p) + x)
  0x40c31e		4d035910		ADDQ 0x10(R9), R11	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x40c322		4c895c2468		MOVQ R11, 0x68(SP)	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x40c327		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c328		4d8d6b08		LEAQ 0x8(R11), R13	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x40c32c		4c896c2478		MOVQ R13, 0x78(SP)	
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))
  0x40c331		90			NOPL			
  0x40c332		440fb66b48		MOVZX 0x48(BX), R13	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c337		4f8d1ceb		LEAQ 0(R11)(R13*8), R11	
  0x40c33b		4d8d5b08		LEAQ 0x8(R11), R11	
		x.v = add(x.k, bucketCnt*uintptr(t.keysize))
  0x40c33f		4c899c2480000000	MOVQ R11, 0x80(SP)	
		if !h.sameSizeGrow() {
  0x40c347		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40c348		450fb65908		MOVZX 0x8(R9), R11	
  0x40c34d		41f6c308		TESTL $0x8, R11		
		if !h.sameSizeGrow() {
  0x40c351		0f84c2040000		JE 0x40c819		
	return bucketShift(oldB)
  0x40c357		884c2427		MOVB CL, 0x27(SP)	
	return uintptr(1) << b
  0x40c35b		4c89642440		MOVQ R12, 0x40(SP)	
		for ; b != nil; b = b.overflow(t) {
  0x40c360		e90a040000		JMP 0x40c76f		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c365		48ffc0			INCQ AX			
  0x40c368		90			NOPL			
  0x40c369		440fb67348		MOVZX 0x48(BX), R14	
  0x40c36e		90			NOPL			
  0x40c36f		440fb67b49		MOVZX 0x49(BX), R15	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c374		4d01f5			ADDQ R14, R13		
  0x40c377		4d01fb			ADDQ R15, R11		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c37a		4883f808		CMPQ $0x8, AX		
  0x40c37e		0f8dd9030000		JGE 0x40c75d		
				top := b.tophash[i]
  0x40c384		440fb63406		MOVZX 0(SI)(AX*1), R14	
				if isEmpty(top) {
  0x40c389		90			NOPL			
	return x <= emptyOne
  0x40c38a		4180fe01		CMPL $0x1, R14		
				if isEmpty(top) {
  0x40c38e		7706			JA 0x40c396		
					b.tophash[i] = evacuatedEmpty
  0x40c390		c6040604		MOVB $0x4, 0(SI)(AX*1)	
					continue
  0x40c394		ebcf			JMP 0x40c365		
				if top < minTopHash {
  0x40c396		4180fe05		CMPL $0x5, R14		
  0x40c39a		0f82d2040000		JB 0x40c872		
				if t.indirectkey() {
  0x40c3a0		90			NOPL			
	return mt.flags&1 != 0
  0x40c3a1		448b7b4c		MOVL 0x4c(BX), R15	
  0x40c3a5		410fbae700		BTL $0x0, R15		
				if t.indirectkey() {
  0x40c3aa		0f83a5030000		JAE 0x40c755		
					k2 = *((*unsafe.Pointer)(k2))
  0x40c3b0		4d8b7d00		MOVQ 0(R13), R15	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c3b4		4889442428		MOVQ AX, 0x28(SP)	
  0x40c3b9		4c895c2448		MOVQ R11, 0x48(SP)	
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c3be		4c897c2458		MOVQ R15, 0x58(SP)	
				k2 := k
  0x40c3c3		4c896c2450		MOVQ R13, 0x50(SP)	
				if !h.sameSizeGrow() {
  0x40c3c8		90			NOPL			
	return uintptr(1) << b
  0x40c3c9		4c89e2			MOVQ R12, DX		
	return h.flags&sameSizeGrow != 0
  0x40c3cc		450fb66108		MOVZX 0x8(R9), R12	
  0x40c3d1		41f6c408		TESTL $0x8, R12		
				if !h.sameSizeGrow() {
  0x40c3d5		0f8460020000		JE 0x40c63b		
  0x40c3db		31ff			XORL DI, DI		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
  0x40c3dd		448d6702		LEAL 0x2(DI), R12	
  0x40c3e1		44882406		MOVB R12, 0(SI)(AX*1)	
				dst := &xy[useY]                 // evacuation destination
  0x40c3e5		440fb6e7		MOVZX DI, R12		
  0x40c3e9		4983fc02		CMPQ $0x2, R12		
  0x40c3ed		0f8378040000		JAE 0x40c86b		
  0x40c3f3		49c1e405		SHLQ $0x5, R12		
  0x40c3f7		4c89642438		MOVQ R12, 0x38(SP)	
				if dst.i == bucketCnt {
  0x40c3fc		4a8b4c2470		MOVQ 0x70(SP)(R12*1), CX	
  0x40c401		4883f908		CMPQ $0x8, CX			
  0x40c405		0f8495010000		JE 0x40c5a0			
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c40b		4a8b4c2468		MOVQ 0x68(SP)(R12*1), CX	
  0x40c410		8401			TESTB AL, 0(CX)			
	return bucketShift(oldB)
  0x40c412		4489d7			MOVL R10, DI		
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c415		4e8b542470		MOVQ 0x70(SP)(R12*1), R10	
  0x40c41a		4983e207		ANDQ $0x7, R10			
  0x40c41e		46883411		MOVB R14, 0(CX)(R10*1)		
				if t.indirectkey() {
  0x40c422		90			NOPL			
	return mt.flags&1 != 0
  0x40c423		8b4b4c			MOVL 0x4c(BX), CX	
  0x40c426		0fbae100		BTL $0x0, CX		
				if t.indirectkey() {
  0x40c42a		0f8314010000		JAE 0x40c544		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c430		4a8b4c2478		MOVQ 0x78(SP)(R12*1), CX		
  0x40c435		8401			TESTB AL, 0(CX)				
  0x40c437		833de2090d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c43e		0f85e4000000		JNE 0x40c528				
  0x40c444		4c8939			MOVQ R15, 0(CX)				
				if t.indirectvalue() {
  0x40c447		90			NOPL			
	return mt.flags&2 != 0
  0x40c448		8b4b4c			MOVL 0x4c(BX), CX	
  0x40c44b		0fbae101		BTL $0x1, CX		
				if t.indirectvalue() {
  0x40c44f		7378			JAE 0x40c4c9		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c451		4a8b8c2480000000	MOVQ 0x80(SP)(R12*1), CX		
  0x40c459		8401			TESTB AL, 0(CX)				
  0x40c45b		4d8b13			MOVQ 0(R11), R10			
  0x40c45e		833dbb090d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c465		7549			JNE 0x40c4b0				
  0x40c467		4c8911			MOVQ R10, 0(CX)				
				dst.i++
  0x40c46a		4e8b742470		MOVQ 0x70(SP)(R12*1), R14	
  0x40c46f		49ffc6			INCQ R14			
  0x40c472		4e89742470		MOVQ R14, 0x70(SP)(R12*1)	
				dst.k = add(dst.k, uintptr(t.keysize))
  0x40c477		90			NOPL				
  0x40c478		4e8b742478		MOVQ 0x78(SP)(R12*1), R14	
  0x40c47d		440fb67b48		MOVZX 0x48(BX), R15		
	return unsafe.Pointer(uintptr(p) + x)
  0x40c482		4d01fe			ADDQ R15, R14		
				dst.k = add(dst.k, uintptr(t.keysize))
  0x40c485		4e89742478		MOVQ R14, 0x78(SP)(R12*1)	
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40c48a		90			NOPL				
  0x40c48b		4e8bb42480000000	MOVQ 0x80(SP)(R12*1), R14	
  0x40c493		440fb67b49		MOVZX 0x49(BX), R15		
	return unsafe.Pointer(uintptr(p) + x)
  0x40c498		4d01fe			ADDQ R15, R14		
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40c49b		4e89b42480000000	MOVQ R14, 0x80(SP)(R12*1)	
						if hash&newbit != 0 {
  0x40c4a3		89f9			MOVL DI, CX		
  0x40c4a5		4189ca			MOVL CX, R10		
		advanceEvacuationMark(h, t, newbit)
  0x40c4a8		4989d4			MOVQ DX, R12		
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40c4ab		e9b5feffff		JMP 0x40c365		
	return bucketShift(oldB)
  0x40c4b0		4189fe			MOVL DI, R14		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c4b3		4889cf			MOVQ CX, DI		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c4b6		4989c7			MOVQ AX, R15		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c4b9		4c89d0			MOVQ R10, AX			
  0x40c4bc		e8bfd10300		CALL runtime.gcWriteBarrier(SB)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c4c1		4c89f8			MOVQ R15, AX		
						if hash&newbit != 0 {
  0x40c4c4		4489f7			MOVL R14, DI		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c4c7		eba1			JMP 0x40c46a		
					typedmemmove(t.elem, dst.v, v)
  0x40c4c9		488b4338		MOVQ 0x38(BX), AX		
  0x40c4cd		4a8b8c2480000000	MOVQ 0x80(SP)(R12*1), CX	
  0x40c4d5		48890424		MOVQ AX, 0(SP)			
  0x40c4d9		48894c2408		MOVQ CX, 0x8(SP)		
  0x40c4de		4c895c2410		MOVQ R11, 0x10(SP)		
  0x40c4e3		e8a8100000		CALL runtime.typedmemmove(SB)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c4e8		488b442428		MOVQ 0x28(SP), AX	
		advanceEvacuationMark(h, t, newbit)
  0x40c4ed		488b542440		MOVQ 0x40(SP), DX	
				dst.k = add(dst.k, uintptr(t.keysize))
  0x40c4f2		488b9c24b8000000	MOVQ 0xb8(SP), BX	
				top := b.tophash[i]
  0x40c4fa		488b742460		MOVQ 0x60(SP), SI	
						if hash&newbit != 0 {
  0x40c4ff		0fb67c2427		MOVZX 0x27(SP), DI	
	if oldbucket == h.nevacuate {
  0x40c504		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
	return h.flags&sameSizeGrow != 0
  0x40c50c		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c514		4c8b5c2448		MOVQ 0x48(SP), R11	
				dst.i++
  0x40c519		4c8b642438		MOVQ 0x38(SP), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c51e		4c8b6c2450		MOVQ 0x50(SP), R13	
					typedmemmove(t.elem, dst.v, v)
  0x40c523		e942ffffff		JMP 0x40c46a		
	return bucketShift(oldB)
  0x40c528		4189fa			MOVL DI, R10		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c52b		4889cf			MOVQ CX, DI		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c52e		4989c6			MOVQ AX, R14		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c531		4c89f8			MOVQ R15, AX			
  0x40c534		e847d10300		CALL runtime.gcWriteBarrier(SB)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c539		4c89f0			MOVQ R14, AX		
						if hash&newbit != 0 {
  0x40c53c		4489d7			MOVL R10, DI		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c53f		e903ffffff		JMP 0x40c447		
					typedmemmove(t.key, dst.k, k) // copy value
  0x40c544		488b4330		MOVQ 0x30(BX), AX		
  0x40c548		4a8b4c2478		MOVQ 0x78(SP)(R12*1), CX	
  0x40c54d		48890424		MOVQ AX, 0(SP)			
  0x40c551		48894c2408		MOVQ CX, 0x8(SP)		
  0x40c556		4c896c2410		MOVQ R13, 0x10(SP)		
  0x40c55b		e830100000		CALL runtime.typedmemmove(SB)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c560		488b442428		MOVQ 0x28(SP), AX	
		advanceEvacuationMark(h, t, newbit)
  0x40c565		488b542440		MOVQ 0x40(SP), DX	
	return mt.flags&2 != 0
  0x40c56a		488b9c24b8000000	MOVQ 0xb8(SP), BX	
				top := b.tophash[i]
  0x40c572		488b742460		MOVQ 0x60(SP), SI	
						if hash&newbit != 0 {
  0x40c577		0fb67c2427		MOVZX 0x27(SP), DI	
	if oldbucket == h.nevacuate {
  0x40c57c		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
	return h.flags&sameSizeGrow != 0
  0x40c584		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c58c		4c8b5c2448		MOVQ 0x48(SP), R11	
  0x40c591		4c8b642438		MOVQ 0x38(SP), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c596		4c8b6c2450		MOVQ 0x50(SP), R13	
					typedmemmove(t.key, dst.k, k) // copy value
  0x40c59b		e9a7feffff		JMP 0x40c447		
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c5a0		4488742426		MOVB R14, 0x26(SP)	
					dst.b = h.newoverflow(t, dst.b)
  0x40c5a5		4a8b442468		MOVQ 0x68(SP)(R12*1), AX		
  0x40c5aa		4c890c24		MOVQ R9, 0(SP)				
  0x40c5ae		48895c2408		MOVQ BX, 0x8(SP)			
  0x40c5b3		4889442410		MOVQ AX, 0x10(SP)			
  0x40c5b8		e823eaffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x40c5bd		488b442418		MOVQ 0x18(SP), AX			
  0x40c5c2		4c8b642438		MOVQ 0x38(SP), R12			
  0x40c5c7		4a89442468		MOVQ AX, 0x68(SP)(R12*1)		
					dst.i = 0
  0x40c5cc		4ac744247000000000	MOVQ $0x0, 0x70(SP)(R12*1)	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x40c5d5		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c5d6		488d4808		LEAQ 0x8(AX), CX	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x40c5da		4a894c2478		MOVQ CX, 0x78(SP)(R12*1)	
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
  0x40c5df		90			NOPL			
  0x40c5e0		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x40c5e8		0fb64b48		MOVZX 0x48(BX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c5ec		488d04c8		LEAQ 0(AX)(CX*8), AX	
  0x40c5f0		488d4008		LEAQ 0x8(AX), AX	
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
  0x40c5f4		4a89842480000000	MOVQ AX, 0x80(SP)(R12*1)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c5fc		488b442428		MOVQ 0x28(SP), AX	
		advanceEvacuationMark(h, t, newbit)
  0x40c601		488b542440		MOVQ 0x40(SP), DX	
				top := b.tophash[i]
  0x40c606		488b742460		MOVQ 0x60(SP), SI	
	if oldbucket == h.nevacuate {
  0x40c60b		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
	return h.flags&sameSizeGrow != 0
  0x40c613		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
						if hash&newbit != 0 {
  0x40c61b		440fb6542427		MOVZX 0x27(SP), R10	
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c621		4c8b5c2448		MOVQ 0x48(SP), R11	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c626		4c8b6c2450		MOVQ 0x50(SP), R13	
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c62b		440fb6742426		MOVZX 0x26(SP), R14	
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c631		4c8b7c2458		MOVQ 0x58(SP), R15	
					dst.v = add(dst.k, bucketCnt*uintptr(t.keysize))
  0x40c636		e9d0fdffff		JMP 0x40c40b		
				top := b.tophash[i]
  0x40c63b		4488742425		MOVB R14, 0x25(SP)	
					hash := t.key.alg.hash(k2, uintptr(h.hash0))
  0x40c640		488b4330		MOVQ 0x30(BX), AX	
  0x40c644		488b4018		MOVQ 0x18(AX), AX	
  0x40c648		488b10			MOVQ 0(AX), DX		
  0x40c64b		418b410c		MOVL 0xc(R9), AX	
  0x40c64f		4c893c24		MOVQ R15, 0(SP)		
  0x40c653		4889442408		MOVQ AX, 0x8(SP)	
  0x40c658		488b02			MOVQ 0(DX), AX		
  0x40c65b		ffd0			CALL AX			
  0x40c65d		488b442410		MOVQ 0x10(SP), AX	
					if h.flags&iterator != 0 && !t.reflexivekey() && !t.key.alg.equal(k2, k2) {
  0x40c662		488b8c24c0000000	MOVQ 0xc0(SP), CX	
  0x40c66a		0fb65908		MOVZX 0x8(CX), BX	
  0x40c66e		f6c301			TESTL $0x1, BL		
  0x40c671		0f84cf000000		JE 0x40c746		
  0x40c677		90			NOPL			
	return mt.flags&4 != 0
  0x40c678		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x40c680		8b734c			MOVL 0x4c(BX), SI	
  0x40c683		0fbae602		BTL $0x2, SI		
					if h.flags&iterator != 0 && !t.reflexivekey() && !t.key.alg.equal(k2, k2) {
  0x40c687		7377			JAE 0x40c700		
  0x40c689		31d2			XORL DX, DX		
  0x40c68b		84d2			TESTL DL, DL		
  0x40c68d		745c			JE 0x40c6eb		
						top = tophash(hash)
  0x40c68f		90			NOPL			
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40c690		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x40c694		3c05			CMPL $0x5, AL		
  0x40c696		734e			JAE 0x40c6e6		
		top += minTopHash
  0x40c698		8d7005			LEAL 0x5(AX), SI	
						useY = top & 1
  0x40c69b		440fb6442425		MOVZX 0x25(SP), R8	
  0x40c6a1		4183e001		ANDL $0x1, R8		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
  0x40c6a5		488b442428		MOVQ 0x28(SP), AX	
						if hash&newbit != 0 {
  0x40c6aa		0fb64c2427		MOVZX 0x27(SP), CX	
		advanceEvacuationMark(h, t, newbit)
  0x40c6af		488b542440		MOVQ 0x40(SP), DX	
					dst.b = h.newoverflow(t, dst.b)
  0x40c6b4		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
						if hash&newbit != 0 {
  0x40c6bc		4189ca			MOVL CX, R10		
					*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)
  0x40c6bf		4c8b5c2448		MOVQ 0x48(SP), R11	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c6c4		4c8b6c2450		MOVQ 0x50(SP), R13	
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c6c9		4c8b7c2458		MOVQ 0x58(SP), R15	
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
  0x40c6ce		4489c7			MOVL R8, DI		
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c6d1		4189f6			MOVL SI, R14		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY
  0x40c6d4		488b742460		MOVQ 0x60(SP), SI	
	if oldbucket == h.nevacuate {
  0x40c6d9		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
  0x40c6e1		e9f7fcffff		JMP 0x40c3dd		
						top = tophash(hash)
  0x40c6e6		4889c6			MOVQ AX, SI		
	if top < minTopHash {
  0x40c6e9		ebb0			JMP 0x40c69b		
						if hash&newbit != 0 {
  0x40c6eb		440fb64c2427		MOVZX 0x27(SP), R9	
  0x40c6f1		4c0fa3c8		BTQ R9, AX		
  0x40c6f5		410f92c0		SETB R8			
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40c6f9		0fb6742425		MOVZX 0x25(SP), SI	
  0x40c6fe		eba5			JMP 0x40c6a5		
					hash := t.key.alg.hash(k2, uintptr(h.hash0))
  0x40c700		4889442430		MOVQ AX, 0x30(SP)	
					if h.flags&iterator != 0 && !t.reflexivekey() && !t.key.alg.equal(k2, k2) {
  0x40c705		488b4330		MOVQ 0x30(BX), AX	
  0x40c709		488b4018		MOVQ 0x18(AX), AX	
  0x40c70d		488b5008		MOVQ 0x8(AX), DX	
  0x40c711		488b442458		MOVQ 0x58(SP), AX	
  0x40c716		48890424		MOVQ AX, 0(SP)		
  0x40c71a		4889442408		MOVQ AX, 0x8(SP)	
  0x40c71f		488b0a			MOVQ 0(DX), CX		
  0x40c722		ffd1			CALL CX			
  0x40c724		0fb6542410		MOVZX 0x10(SP), DX	
  0x40c729		83f201			XORL $0x1, DX		
						if hash&newbit != 0 {
  0x40c72c		488b442430		MOVQ 0x30(SP), AX	
					dst.b = h.newoverflow(t, dst.b)
  0x40c731		488b8c24c0000000	MOVQ 0xc0(SP), CX	
	return mt.flags&1 != 0
  0x40c739		488b9c24b8000000	MOVQ 0xb8(SP), BX	
					if h.flags&iterator != 0 && !t.reflexivekey() && !t.key.alg.equal(k2, k2) {
  0x40c741		e945ffffff		JMP 0x40c68b		
	return mt.flags&1 != 0
  0x40c746		488b9c24b8000000	MOVQ 0xb8(SP), BX	
  0x40c74e		31d2			XORL DX, DX		
					if h.flags&iterator != 0 && !t.reflexivekey() && !t.key.alg.equal(k2, k2) {
  0x40c750		e936ffffff		JMP 0x40c68b		
					*(*unsafe.Pointer)(dst.k) = k2 // copy pointer
  0x40c755		4d89ef			MOVQ R13, R15		
				if t.indirectkey() {
  0x40c758		e957fcffff		JMP 0x40c3b4		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40c75d		440fb75b4a		MOVZX 0x4a(BX), R11	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c762		4e8d1c1e		LEAQ 0(SI)(R11*1), R11	
  0x40c766		4d8d5bf8		LEAQ -0x8(R11), R11	
		for ; b != nil; b = b.overflow(t) {
  0x40c76a		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40c76b		498b33			MOVQ 0(R11), SI		
  0x40c76e		90			NOPL			
		for ; b != nil; b = b.overflow(t) {
  0x40c76f		4885f6			TESTQ SI, SI		
  0x40c772		741f			JE 0x40c793		
  0x40c774		4889742460		MOVQ SI, 0x60(SP)	
			k := add(unsafe.Pointer(b), dataOffset)
  0x40c779		90			NOPL			
			v := add(k, bucketCnt*uintptr(t.keysize))
  0x40c77a		90			NOPL			
  0x40c77b		440fb65b48		MOVZX 0x48(BX), R11	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c780		4c8d6e08		LEAQ 0x8(SI), R13	
  0x40c784		4e8d1cde		LEAQ 0(SI)(R11*8), R11	
  0x40c788		4d8d5b08		LEAQ 0x8(R11), R11	
  0x40c78c		31c0			XORL AX, AX		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {
  0x40c78e		e9e7fbffff		JMP 0x40c37a		
		if h.flags&oldIterator == 0 && t.bucket.kind&kindNoPointers == 0 {
  0x40c793		410fb64108		MOVZX 0x8(R9), AX	
  0x40c798		a802			TESTL $0x2, AL		
  0x40c79a		750c			JNE 0x40c7a8		
  0x40c79c		488b4340		MOVQ 0x40(BX), AX	
  0x40c7a0		0fb64017		MOVZX 0x17(AX), AX	
  0x40c7a4		a880			TESTL $0x80, AL		
  0x40c7a6		742b			JE 0x40c7d3		
	if oldbucket == h.nevacuate {
  0x40c7a8		4d394120		CMPQ R8, 0x20(R9)	
  0x40c7ac		7410			JE 0x40c7be		
  0x40c7ae		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x40c7b6		4881c4b0000000		ADDQ $0xb0, SP		
  0x40c7bd		c3			RET			
		advanceEvacuationMark(h, t, newbit)
  0x40c7be		4c890c24		MOVQ R9, 0(SP)				
  0x40c7c2		48895c2408		MOVQ BX, 0x8(SP)			
  0x40c7c7		4c89642410		MOVQ R12, 0x10(SP)			
  0x40c7cc		e8cf000000		CALL runtime.advanceEvacuationMark(SB)	
  0x40c7d1		ebdb			JMP 0x40c7ae				
			b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
  0x40c7d3		90			NOPL			
  0x40c7d4		0fb7434a		MOVZX 0x4a(BX), AX	
  0x40c7d8		4889c1			MOVQ AX, CX		
  0x40c7db		490fafc0		IMULQ R8, AX		
			ptr := add(b, dataOffset)
  0x40c7df		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c7e0		49034118		ADDQ 0x18(R9), AX	
  0x40c7e4		4883c008		ADDQ $0x8, AX		
			memclrHasPointers(ptr, n)
  0x40c7e8		48890424		MOVQ AX, 0(SP)		
			n := uintptr(t.bucketsize) - dataOffset
  0x40c7ec		488d41f8		LEAQ -0x8(CX), AX	
			memclrHasPointers(ptr, n)
  0x40c7f0		4889442408		MOVQ AX, 0x8(SP)			
  0x40c7f5		e8b6100000		CALL runtime.memclrHasPointers(SB)	
		advanceEvacuationMark(h, t, newbit)
  0x40c7fa		488b9c24b8000000	MOVQ 0xb8(SP), BX	
	if oldbucket == h.nevacuate {
  0x40c802		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
  0x40c80a		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
		advanceEvacuationMark(h, t, newbit)
  0x40c812		4c8b642440		MOVQ 0x40(SP), R12	
			memclrHasPointers(ptr, n)
  0x40c817		eb8f			JMP 0x40c7a8		
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x40c819		90			NOPL			
  0x40c81a		4f8d1c04		LEAQ 0(R12)(R8*1), R11	
  0x40c81e		440fb76b4a		MOVZX 0x4a(BX), R13	
  0x40c823		4d0fafdd		IMULQ R13, R11		
	return unsafe.Pointer(uintptr(p) + x)
  0x40c827		4d035910		ADDQ 0x10(R9), R11	
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x40c82b		4c899c2488000000	MOVQ R11, 0x88(SP)	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x40c833		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c834		4d8d6b08		LEAQ 0x8(R11), R13	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x40c838		4c89ac2498000000	MOVQ R13, 0x98(SP)	
			y.v = add(y.k, bucketCnt*uintptr(t.keysize))
  0x40c840		90			NOPL			
  0x40c841		440fb66b48		MOVZX 0x48(BX), R13	
	return unsafe.Pointer(uintptr(p) + x)
  0x40c846		4f8d1ceb		LEAQ 0(R11)(R13*8), R11	
  0x40c84a		4d8d5b08		LEAQ 0x8(R11), R11	
			y.v = add(y.k, bucketCnt*uintptr(t.keysize))
  0x40c84e		4c899c24a0000000	MOVQ R11, 0xa0(SP)	
  0x40c856		e9fcfaffff		JMP 0x40c357		
  0x40c85b		4531db			XORL R11, R11		
	return h > emptyOne && h < minTopHash
  0x40c85e		e97ffaffff		JMP 0x40c2e2		
		oldB--
  0x40c863		41ffca			DECL R10		
  0x40c866		e95ffaffff		JMP 0x40c2ca		
				dst := &xy[useY]                 // evacuation destination
  0x40c86b		e8b0560100		CALL runtime.panicindex(SB)	
  0x40c870		0f0b			UD2				
					throw("bad map state")
  0x40c872		488d05ee330600		LEAQ 0x633ee(IP), AX	
  0x40c879		48890424		MOVQ AX, 0(SP)		
  0x40c87d		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40c886		e8f56b0100		CALL runtime.throw(SB)	
  0x40c88b		0f0b			UD2			
func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
  0x40c88d		e8eeaf0300		CALL runtime.morestack_noctxt(SB)	
  0x40c892		e9c9f9ffff		JMP runtime.evacuate(SB)		

TEXT runtime.advanceEvacuationMark(SB) /usr/local/go/src/runtime/map.go
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
  0x40c8a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c8a9		483b6110		CMPQ 0x10(CX), SP	
  0x40c8ad		0f86d0000000		JBE 0x40c983		
  0x40c8b3		4883ec08		SUBQ $0x8, SP		
  0x40c8b7		48892c24		MOVQ BP, 0(SP)		
  0x40c8bb		488d2c24		LEAQ 0(SP), BP		
	h.nevacuate++
  0x40c8bf		488b4c2410		MOVQ 0x10(SP), CX	
  0x40c8c4		488b5120		MOVQ 0x20(CX), DX	
  0x40c8c8		488d5a01		LEAQ 0x1(DX), BX	
  0x40c8cc		48895920		MOVQ BX, 0x20(CX)	
	stop := h.nevacuate + 1024
  0x40c8d0		4881c201040000		ADDQ $0x401, DX		
	if stop > newbit {
  0x40c8d7		488b5c2420		MOVQ 0x20(SP), BX	
  0x40c8dc		4839da			CMPQ BX, DX		
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x40c8df		480f47d3		CMOVA BX, DX		
	if stop > newbit {
  0x40c8e3		488b742418		MOVQ 0x18(SP), SI	
  0x40c8e8		eb07			JMP 0x40c8f1		
		h.nevacuate++
  0x40c8ea		49ffc0			INCQ R8			
  0x40c8ed		4c894120		MOVQ R8, 0x20(CX)	
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x40c8f1		4c8b4120		MOVQ 0x20(CX), R8	
  0x40c8f5		4939d0			CMPQ DX, R8		
  0x40c8f8		7427			JE 0x40c921		
  0x40c8fa		90			NOPL			
	b := (*bmap)(add(h.oldbuckets, bucket*uintptr(t.bucketsize)))
  0x40c8fb		90			NOPL			
  0x40c8fc		440fb74e4a		MOVZX 0x4a(SI), R9	
  0x40c901		4d0fafc8		IMULQ R8, R9		
	return evacuated(b)
  0x40c905		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c906		4c034918		ADDQ 0x18(CX), R9	
	h := b.tophash[0]
  0x40c90a		450fb609		MOVZX 0(R9), R9		
	return h > emptyOne && h < minTopHash
  0x40c90e		4180f901		CMPL $0x1, R9		
  0x40c912		766a			JBE 0x40c97e		
  0x40c914		4180f905		CMPL $0x5, R9		
  0x40c918		410f92c1		SETB R9			
	return evacuated(b)
  0x40c91c		4584c9			TESTL R9, R9		
	for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) {
  0x40c91f		75c9			JNE 0x40c8ea		
	if h.nevacuate == newbit { // newbit == # of oldbuckets
  0x40c921		4939d8			CMPQ BX, R8		
  0x40c924		7535			JNE 0x40c95b		
		h.oldbuckets = nil
  0x40c926		833df3040d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c92d		7542			JNE 0x40c971				
  0x40c92f		48c7411800000000	MOVQ $0x0, 0x18(CX)			
		if h.extra != nil {
  0x40c937		488b5128		MOVQ 0x28(CX), DX	
  0x40c93b		4885d2			TESTQ DX, DX		
  0x40c93e		7411			JE 0x40c951		
			h.extra.oldoverflow = nil
  0x40c940		833dd9040d0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40c947		751b			JNE 0x40c964				
  0x40c949		48c7420800000000	MOVQ $0x0, 0x8(DX)			
		h.flags &^= sameSizeGrow
  0x40c951		0fb64108		MOVZX 0x8(CX), AX	
  0x40c955		83e0f7			ANDL $-0x9, AX		
  0x40c958		884108			MOVB AL, 0x8(CX)	
  0x40c95b		488b2c24		MOVQ 0(SP), BP		
  0x40c95f		4883c408		ADDQ $0x8, SP		
  0x40c963		c3			RET			
			h.extra.oldoverflow = nil
  0x40c964		488d7a08		LEAQ 0x8(DX), DI		
  0x40c968		31c0			XORL AX, AX			
  0x40c96a		e811cd0300		CALL runtime.gcWriteBarrier(SB)	
  0x40c96f		ebe0			JMP 0x40c951			
		h.oldbuckets = nil
  0x40c971		488d7918		LEAQ 0x18(CX), DI		
  0x40c975		31c0			XORL AX, AX			
  0x40c977		e804cd0300		CALL runtime.gcWriteBarrier(SB)	
  0x40c97c		ebb9			JMP 0x40c937			
  0x40c97e		4531c9			XORL R9, R9			
	return h > emptyOne && h < minTopHash
  0x40c981		eb99			JMP 0x40c91c		
func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {
  0x40c983		e8f8ae0300		CALL runtime.morestack_noctxt(SB)	
  0x40c988		e913ffffff		JMP runtime.advanceEvacuationMark(SB)	

TEXT runtime.mapaccess1_fast32(SB) /usr/local/go/src/runtime/map_fast32.go
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40c990		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40c999		483b6110		CMPQ 0x10(CX), SP	
  0x40c99d		0f86a0010000		JBE 0x40cb43		
  0x40c9a3		4883ec20		SUBQ $0x20, SP		
  0x40c9a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x40c9ac		488d6c2418		LEAQ 0x18(SP), BP	
	if h == nil || h.count == 0 {
  0x40c9b1		488b442430		MOVQ 0x30(SP), AX	
  0x40c9b6		4885c0			TESTQ AX, AX		
  0x40c9b9		0f8453010000		JE 0x40cb12		
  0x40c9bf		48833800		CMPQ $0x0, 0(AX)	
  0x40c9c3		0f8449010000		JE 0x40cb12		
	if h.flags&hashWriting != 0 {
  0x40c9c9		0fb64808		MOVZX 0x8(AX), CX	
  0x40c9cd		f6c104			TESTL $0x4, CL		
  0x40c9d0		0f8552010000		JNE 0x40cb28		
	if h.B == 0 {
  0x40c9d6		80780900		CMPB $0x0, 0x9(AX)	
  0x40c9da		0f8588000000		JNE 0x40ca68		
		b = (*bmap)(h.buckets)
  0x40c9e0		488b4010		MOVQ 0x10(AX), AX	
  0x40c9e4		eb5d			JMP 0x40ca43		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40c9e6		48ffc2			INCQ DX			
  0x40c9e9		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40c9ea		4883c104		ADDQ $0x4, CX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40c9ee		4883fa08		CMPQ $0x8, DX		
  0x40c9f2		7337			JAE 0x40ca2b		
			if *(*uint32)(k) == key && !isEmpty(b.tophash[i]) {
  0x40c9f4		8b5c2438		MOVL 0x38(SP), BX	
  0x40c9f8		3919			CMPL BX, 0(CX)		
  0x40c9fa		75ea			JNE 0x40c9e6		
  0x40c9fc		90			NOPL			
  0x40c9fd		0fb61c02		MOVZX 0(DX)(AX*1), BX	
	return x <= emptyOne
  0x40ca01		80fb01			CMPL $0x1, BL		
			if *(*uint32)(k) == key && !isEmpty(b.tophash[i]) {
  0x40ca04		76e0			JBE 0x40c9e6		
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))
  0x40ca06		90			NOPL			
  0x40ca07		488b4c2428		MOVQ 0x28(SP), CX	
  0x40ca0c		0fb64949		MOVZX 0x49(CX), CX	
  0x40ca10		480fafca		IMULQ DX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x40ca14		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x40ca18		488d4028		LEAQ 0x28(AX), AX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))
  0x40ca1c		4889442440		MOVQ AX, 0x40(SP)	
  0x40ca21		488b6c2418		MOVQ 0x18(SP), BP	
  0x40ca26		4883c420		ADDQ $0x20, SP		
  0x40ca2a		c3			RET			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40ca2b		488b4c2428		MOVQ 0x28(SP), CX	
  0x40ca30		0fb7514a		MOVZX 0x4a(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40ca34		488d1410		LEAQ 0(AX)(DX*1), DX	
  0x40ca38		488d52f8		LEAQ -0x8(DX), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40ca3c		8401			TESTB AL, 0(CX)		
	for ; b != nil; b = b.overflow(t) {
  0x40ca3e		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40ca3f		488b02			MOVQ 0(DX), AX		
  0x40ca42		90			NOPL			
	for ; b != nil; b = b.overflow(t) {
  0x40ca43		4885c0			TESTQ AX, AX		
  0x40ca46		740a			JE 0x40ca52		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40ca48		90			NOPL			
	return add(unsafe.Pointer(b), dataOffset)
  0x40ca49		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40ca4a		488d4808		LEAQ 0x8(AX), CX	
  0x40ca4e		31d2			XORL DX, DX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40ca50		eb9c			JMP 0x40c9ee		
	return unsafe.Pointer(&zeroVal[0])
  0x40ca52		488d05070e0d00		LEAQ runtime.zeroVal(SB), AX	
  0x40ca59		4889442440		MOVQ AX, 0x40(SP)		
  0x40ca5e		488b6c2418		MOVQ 0x18(SP), BP		
  0x40ca63		4883c420		ADDQ $0x20, SP			
  0x40ca67		c3			RET				
		hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x40ca68		488b4c2428		MOVQ 0x28(SP), CX	
  0x40ca6d		488b5930		MOVQ 0x30(CX), BX	
  0x40ca71		488b5b18		MOVQ 0x18(BX), BX	
  0x40ca75		488b13			MOVQ 0(BX), DX		
  0x40ca78		90			NOPL			
  0x40ca79		8b580c			MOVL 0xc(AX), BX	
  0x40ca7c		488d742438		LEAQ 0x38(SP), SI	
  0x40ca81		48893424		MOVQ SI, 0(SP)		
  0x40ca85		48895c2408		MOVQ BX, 0x8(SP)	
  0x40ca8a		488b1a			MOVQ 0(DX), BX		
  0x40ca8d		ffd3			CALL BX			
  0x40ca8f		488b442410		MOVQ 0x10(SP), AX	
		m := bucketMask(h.B)
  0x40ca94		90			NOPL			
  0x40ca95		488b4c2430		MOVQ 0x30(SP), CX	
  0x40ca9a		0fb65909		MOVZX 0x9(CX), BX	
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x40ca9e		90			NOPL			
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40ca9f		4889ca			MOVQ CX, DX		
	return uintptr(1) << b
  0x40caa2		89d9			MOVL BX, CX		
  0x40caa4		be01000000		MOVL $0x1, SI		
  0x40caa9		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x40caac		488d4eff		LEAQ -0x1(SI), CX	
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x40cab0		4889cb			MOVQ CX, BX		
  0x40cab3		4821c1			ANDQ AX, CX		
  0x40cab6		488b742428		MOVQ 0x28(SP), SI	
  0x40cabb		0fb77e4a		MOVZX 0x4a(SI), DI	
  0x40cabf		480fafcf		IMULQ DI, CX		
		if c := h.oldbuckets; c != nil {
  0x40cac3		4c8b4218		MOVQ 0x18(DX), R8	
	return bucketShift(b) - 1
  0x40cac7		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40cac8		48034a10		ADDQ 0x10(DX), CX	
		if c := h.oldbuckets; c != nil {
  0x40cacc		4d85c0			TESTQ R8, R8		
  0x40cacf		742b			JE 0x40cafc		
			if !h.sameSizeGrow() {
  0x40cad1		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40cad2		0fb65208		MOVZX 0x8(DX), DX	
  0x40cad6		f6c208			TESTL $0x8, DL		
			if !h.sameSizeGrow() {
  0x40cad9		7432			JE 0x40cb0d		
			oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
  0x40cadb		90			NOPL			
  0x40cadc		4821c3			ANDQ AX, BX		
  0x40cadf		480fafdf		IMULQ DI, BX		
			if !evacuated(oldb) {
  0x40cae3		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40cae4		498d0418		LEAQ 0(R8)(BX*1), AX	
	h := b.tophash[0]
  0x40cae8		420fb61403		MOVZX 0(BX)(R8*1), DX	
	return h > emptyOne && h < minTopHash
  0x40caed		80fa01			CMPL $0x1, DL		
  0x40caf0		7617			JBE 0x40cb09		
  0x40caf2		80fa05			CMPL $0x5, DL		
  0x40caf5		0f92c2			SETB DL			
			if !evacuated(oldb) {
  0x40caf8		84d2			TESTL DL, DL		
  0x40cafa		7408			JE 0x40cb04		
	for ; b != nil; b = b.overflow(t) {
  0x40cafc		4889c8			MOVQ CX, AX		
  0x40caff		e93fffffff		JMP 0x40ca43		
  0x40cb04		4889c1			MOVQ AX, CX		
				b = oldb
  0x40cb07		ebf3			JMP 0x40cafc		
  0x40cb09		31d2			XORL DX, DX		
	return h > emptyOne && h < minTopHash
  0x40cb0b		ebeb			JMP 0x40caf8		
				m >>= 1
  0x40cb0d		48d1eb			SHRQ $0x1, BX		
  0x40cb10		ebc9			JMP 0x40cadb		
		return unsafe.Pointer(&zeroVal[0])
  0x40cb12		488d05470d0d00		LEAQ runtime.zeroVal(SB), AX	
  0x40cb19		4889442440		MOVQ AX, 0x40(SP)		
  0x40cb1e		488b6c2418		MOVQ 0x18(SP), BP		
  0x40cb23		4883c420		ADDQ $0x20, SP			
  0x40cb27		c3			RET				
		throw("concurrent map read and map write")
  0x40cb28		488d05c7550600		LEAQ 0x655c7(IP), AX	
  0x40cb2f		48890424		MOVQ AX, 0(SP)		
  0x40cb33		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40cb3c		e83f690100		CALL runtime.throw(SB)	
  0x40cb41		0f0b			UD2			
func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40cb43		e838ad0300		CALL runtime.morestack_noctxt(SB)	
  0x40cb48		e943feffff		JMP runtime.mapaccess1_fast32(SB)	

TEXT runtime.mapaccess2_fast32(SB) /usr/local/go/src/runtime/map_fast32.go
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {
  0x40cb50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40cb59		483b6110		CMPQ 0x10(CX), SP	
  0x40cb5d		0f86af010000		JBE 0x40cd12		
  0x40cb63		4883ec20		SUBQ $0x20, SP		
  0x40cb67		48896c2418		MOVQ BP, 0x18(SP)	
  0x40cb6c		488d6c2418		LEAQ 0x18(SP), BP	
	if h == nil || h.count == 0 {
  0x40cb71		488b442430		MOVQ 0x30(SP), AX	
  0x40cb76		4885c0			TESTQ AX, AX		
  0x40cb79		0f845d010000		JE 0x40ccdc		
  0x40cb7f		48833800		CMPQ $0x0, 0(AX)	
  0x40cb83		0f8453010000		JE 0x40ccdc		
	if h.flags&hashWriting != 0 {
  0x40cb89		0fb64808		MOVZX 0x8(AX), CX	
  0x40cb8d		f6c104			TESTL $0x4, CL		
  0x40cb90		0f8561010000		JNE 0x40ccf7		
	if h.B == 0 {
  0x40cb96		80780900		CMPB $0x0, 0x9(AX)	
  0x40cb9a		0f8592000000		JNE 0x40cc32		
		b = (*bmap)(h.buckets)
  0x40cba0		488b4010		MOVQ 0x10(AX), AX	
  0x40cba4		eb62			JMP 0x40cc08		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40cba6		48ffc2			INCQ DX			
  0x40cba9		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40cbaa		4883c104		ADDQ $0x4, CX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40cbae		4883fa08		CMPQ $0x8, DX		
  0x40cbb2		733c			JAE 0x40cbf0		
			if *(*uint32)(k) == key && !isEmpty(b.tophash[i]) {
  0x40cbb4		8b5c2438		MOVL 0x38(SP), BX	
  0x40cbb8		3919			CMPL BX, 0(CX)		
  0x40cbba		75ea			JNE 0x40cba6		
  0x40cbbc		90			NOPL			
  0x40cbbd		0fb61c02		MOVZX 0(DX)(AX*1), BX	
	return x <= emptyOne
  0x40cbc1		80fb01			CMPL $0x1, BL		
			if *(*uint32)(k) == key && !isEmpty(b.tophash[i]) {
  0x40cbc4		76e0			JBE 0x40cba6		
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true
  0x40cbc6		90			NOPL			
  0x40cbc7		488b4c2428		MOVQ 0x28(SP), CX	
  0x40cbcc		0fb64949		MOVZX 0x49(CX), CX	
  0x40cbd0		480fafca		IMULQ DX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x40cbd4		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x40cbd8		488d4028		LEAQ 0x28(AX), AX	
				return add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true
  0x40cbdc		4889442440		MOVQ AX, 0x40(SP)	
  0x40cbe1		c644244801		MOVB $0x1, 0x48(SP)	
  0x40cbe6		488b6c2418		MOVQ 0x18(SP), BP	
  0x40cbeb		4883c420		ADDQ $0x20, SP		
  0x40cbef		c3			RET			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40cbf0		488b4c2428		MOVQ 0x28(SP), CX	
  0x40cbf5		0fb7514a		MOVZX 0x4a(CX), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40cbf9		488d1410		LEAQ 0(AX)(DX*1), DX	
  0x40cbfd		488d52f8		LEAQ -0x8(DX), DX	
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40cc01		8401			TESTB AL, 0(CX)		
	for ; b != nil; b = b.overflow(t) {
  0x40cc03		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40cc04		488b02			MOVQ 0(DX), AX		
  0x40cc07		90			NOPL			
	for ; b != nil; b = b.overflow(t) {
  0x40cc08		4885c0			TESTQ AX, AX		
  0x40cc0b		740a			JE 0x40cc17		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40cc0d		90			NOPL			
	return add(unsafe.Pointer(b), dataOffset)
  0x40cc0e		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40cc0f		488d4808		LEAQ 0x8(AX), CX	
  0x40cc13		31d2			XORL DX, DX		
		for i, k := uintptr(0), b.keys(); i < bucketCnt; i, k = i+1, add(k, 4) {
  0x40cc15		eb97			JMP 0x40cbae		
	return unsafe.Pointer(&zeroVal[0]), false
  0x40cc17		488d05420c0d00		LEAQ runtime.zeroVal(SB), AX	
  0x40cc1e		4889442440		MOVQ AX, 0x40(SP)		
  0x40cc23		c644244800		MOVB $0x0, 0x48(SP)		
  0x40cc28		488b6c2418		MOVQ 0x18(SP), BP		
  0x40cc2d		4883c420		ADDQ $0x20, SP			
  0x40cc31		c3			RET				
		hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x40cc32		488b4c2428		MOVQ 0x28(SP), CX	
  0x40cc37		488b5930		MOVQ 0x30(CX), BX	
  0x40cc3b		488b5b18		MOVQ 0x18(BX), BX	
  0x40cc3f		488b13			MOVQ 0(BX), DX		
  0x40cc42		90			NOPL			
  0x40cc43		8b580c			MOVL 0xc(AX), BX	
  0x40cc46		488d742438		LEAQ 0x38(SP), SI	
  0x40cc4b		48893424		MOVQ SI, 0(SP)		
  0x40cc4f		48895c2408		MOVQ BX, 0x8(SP)	
  0x40cc54		488b1a			MOVQ 0(DX), BX		
  0x40cc57		ffd3			CALL BX			
  0x40cc59		488b442410		MOVQ 0x10(SP), AX	
		m := bucketMask(h.B)
  0x40cc5e		90			NOPL			
  0x40cc5f		488b4c2430		MOVQ 0x30(SP), CX	
  0x40cc64		0fb65909		MOVZX 0x9(CX), BX	
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x40cc68		90			NOPL			
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {
  0x40cc69		4889ca			MOVQ CX, DX		
	return uintptr(1) << b
  0x40cc6c		89d9			MOVL BX, CX		
  0x40cc6e		be01000000		MOVL $0x1, SI		
  0x40cc73		48d3e6			SHLQ CL, SI		
	return bucketShift(b) - 1
  0x40cc76		488d4eff		LEAQ -0x1(SI), CX	
		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
  0x40cc7a		4889cb			MOVQ CX, BX		
  0x40cc7d		4821c1			ANDQ AX, CX		
  0x40cc80		488b742428		MOVQ 0x28(SP), SI	
  0x40cc85		0fb77e4a		MOVZX 0x4a(SI), DI	
  0x40cc89		480fafcf		IMULQ DI, CX		
		if c := h.oldbuckets; c != nil {
  0x40cc8d		4c8b4218		MOVQ 0x18(DX), R8	
	return bucketShift(b) - 1
  0x40cc91		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40cc92		48034a10		ADDQ 0x10(DX), CX	
		if c := h.oldbuckets; c != nil {
  0x40cc96		4d85c0			TESTQ R8, R8		
  0x40cc99		742b			JE 0x40ccc6		
			if !h.sameSizeGrow() {
  0x40cc9b		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40cc9c		0fb65208		MOVZX 0x8(DX), DX	
  0x40cca0		f6c208			TESTL $0x8, DL		
			if !h.sameSizeGrow() {
  0x40cca3		7432			JE 0x40ccd7		
			oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize)))
  0x40cca5		90			NOPL			
  0x40cca6		4821c3			ANDQ AX, BX		
  0x40cca9		480fafdf		IMULQ DI, BX		
			if !evacuated(oldb) {
  0x40ccad		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40ccae		498d0418		LEAQ 0(R8)(BX*1), AX	
	h := b.tophash[0]
  0x40ccb2		420fb61403		MOVZX 0(BX)(R8*1), DX	
	return h > emptyOne && h < minTopHash
  0x40ccb7		80fa01			CMPL $0x1, DL		
  0x40ccba		7617			JBE 0x40ccd3		
  0x40ccbc		80fa05			CMPL $0x5, DL		
  0x40ccbf		0f92c2			SETB DL			
			if !evacuated(oldb) {
  0x40ccc2		84d2			TESTL DL, DL		
  0x40ccc4		7408			JE 0x40ccce		
	for ; b != nil; b = b.overflow(t) {
  0x40ccc6		4889c8			MOVQ CX, AX		
  0x40ccc9		e93affffff		JMP 0x40cc08		
  0x40ccce		4889c1			MOVQ AX, CX		
				b = oldb
  0x40ccd1		ebf3			JMP 0x40ccc6		
  0x40ccd3		31d2			XORL DX, DX		
	return h > emptyOne && h < minTopHash
  0x40ccd5		ebeb			JMP 0x40ccc2		
				m >>= 1
  0x40ccd7		48d1eb			SHRQ $0x1, BX		
  0x40ccda		ebc9			JMP 0x40cca5		
		return unsafe.Pointer(&zeroVal[0]), false
  0x40ccdc		488d057d0b0d00		LEAQ runtime.zeroVal(SB), AX	
  0x40cce3		4889442440		MOVQ AX, 0x40(SP)		
  0x40cce8		c644244800		MOVB $0x0, 0x48(SP)		
  0x40cced		488b6c2418		MOVQ 0x18(SP), BP		
  0x40ccf2		4883c420		ADDQ $0x20, SP			
  0x40ccf6		c3			RET				
		throw("concurrent map read and map write")
  0x40ccf7		488d05f8530600		LEAQ 0x653f8(IP), AX	
  0x40ccfe		48890424		MOVQ AX, 0(SP)		
  0x40cd02		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40cd0b		e870670100		CALL runtime.throw(SB)	
  0x40cd10		0f0b			UD2			
func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {
  0x40cd12		e869ab0300		CALL runtime.morestack_noctxt(SB)	
  0x40cd17		e934feffff		JMP runtime.mapaccess2_fast32(SB)	

TEXT runtime.mapassign_fast32(SB) /usr/local/go/src/runtime/map_fast32.go
func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40cd20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40cd29		483b6110		CMPQ 0x10(CX), SP	
  0x40cd2d		0f866a030000		JBE 0x40d09d		
  0x40cd33		4883ec38		SUBQ $0x38, SP		
  0x40cd37		48896c2430		MOVQ BP, 0x30(SP)	
  0x40cd3c		488d6c2430		LEAQ 0x30(SP), BP	
	if h == nil {
  0x40cd41		488b442448		MOVQ 0x48(SP), AX	
  0x40cd46		4885c0			TESTQ AX, AX		
  0x40cd49		0f8430030000		JE 0x40d07f		
	if h.flags&hashWriting != 0 {
  0x40cd4f		0fb64808		MOVZX 0x8(AX), CX	
  0x40cd53		f6c104			TESTL $0x4, CL		
  0x40cd56		0f8508030000		JNE 0x40d064		
	hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
  0x40cd5c		488b4c2440		MOVQ 0x40(SP), CX	
  0x40cd61		488b5930		MOVQ 0x30(CX), BX	
  0x40cd65		488b5b18		MOVQ 0x18(BX), BX	
  0x40cd69		488b13			MOVQ 0(BX), DX		
  0x40cd6c		90			NOPL			
  0x40cd6d		8b580c			MOVL 0xc(AX), BX	
  0x40cd70		488d742450		LEAQ 0x50(SP), SI	
  0x40cd75		48893424		MOVQ SI, 0(SP)		
  0x40cd79		48895c2408		MOVQ BX, 0x8(SP)	
  0x40cd7e		488b1a			MOVQ 0(DX), BX		
  0x40cd81		ffd3			CALL BX			
  0x40cd83		488b442410		MOVQ 0x10(SP), AX	
  0x40cd88		4889442420		MOVQ AX, 0x20(SP)	
	h.flags ^= hashWriting
  0x40cd8d		488b4c2448		MOVQ 0x48(SP), CX	
  0x40cd92		0fb65908		MOVZX 0x8(CX), BX	
  0x40cd96		83f304			XORL $0x4, BX		
  0x40cd99		885908			MOVB BL, 0x8(CX)	
	if h.buckets == nil {
  0x40cd9c		4883791000		CMPQ $0x0, 0x10(CX)	
  0x40cda1		0f844e020000		JE 0x40cff5		
	bucket := hash & bucketMask(h.B)
  0x40cda7		488b542440		MOVQ 0x40(SP), DX	
  0x40cdac		e9b7000000		JMP 0x40ce68		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40cdb1		4d8d542401		LEAQ 0x1(R12), R10	
	if insertb == nil {
  0x40cdb6		4889d9			MOVQ BX, CX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cdb9		4d89c8			MOVQ R9, R8		
			if isEmpty(b.tophash[i]) {
  0x40cdbc		4c89db			MOVQ R11, BX		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40cdbf		4d89d1			MOVQ R10, R9		
  0x40cdc2		4983f908		CMPQ $0x8, R9		
  0x40cdc6		0f83cd010000		JAE 0x40cf99		
			if isEmpty(b.tophash[i]) {
  0x40cdcc		8403			TESTB AL, 0(BX)		
  0x40cdce		90			NOPL			
  0x40cdcf		460fb6140b		MOVZX 0(BX)(R9*1), R10	
	return x <= emptyOne
  0x40cdd4		4180fa01		CMPL $0x1, R10		
			if isEmpty(b.tophash[i]) {
  0x40cdd8		0f8789010000		JA 0x40cf67		
				if insertb == nil {
  0x40cdde		4885c9			TESTQ CX, CX		
	if insertb == nil {
  0x40cde1		4989db			MOVQ BX, R11		
  0x40cde4		480f45d9		CMOVNE CX, BX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cde8		4d89cc			MOVQ R9, R12		
  0x40cdeb		4d0f45c8		CMOVNE R8, R9		
				if b.tophash[i] == emptyRest {
  0x40cdef		4584d2			TESTL R10, R10		
  0x40cdf2		75bd			JNE 0x40cdb1		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40cdf4		90			NOPL			
	return h.oldbuckets != nil
  0x40cdf5		48837e1800		CMPQ $0x0, 0x18(SI)	
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40cdfa		0f85a4000000		JNE 0x40cea4		
  0x40ce00		90			NOPL			
  0x40ce01		488b3e			MOVQ 0(SI), DI		
  0x40ce04		48ffc7			INCQ DI			
  0x40ce07		0fb64e09		MOVZX 0x9(SI), CX	
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40ce0b		4883ff08		CMPQ $0x8, DI		
  0x40ce0f		0f8e4b010000		JLE 0x40cf60		
	return uintptr(1) << b
  0x40ce15		41b801000000		MOVL $0x1, R8		
  0x40ce1b		49d3e0			SHLQ CL, R8		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40ce1e		49d1e8			SHRQ $0x1, R8		
  0x40ce21		4f8d1440		LEAQ 0(R8)(R8*2), R10	
  0x40ce25		4f8d0490		LEAQ 0(R8)(R10*4), R8	
  0x40ce29		4c39c7			CMPQ R8, DI		
  0x40ce2c		400f97c7		SETA DI			
  0x40ce30		90			NOPL			
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40ce31		4084ff			TESTL DI, DI		
  0x40ce34		0f84ff000000		JE 0x40cf39		
  0x40ce3a		b901000000		MOVL $0x1, CX		
  0x40ce3f		84c9			TESTL CL, CL		
  0x40ce41		7461			JE 0x40cea4		
		hashGrow(t, h)
  0x40ce43		48891424		MOVQ DX, 0(SP)			
  0x40ce47		4889742408		MOVQ SI, 0x8(SP)		
  0x40ce4c		e82ff1ffff		CALL runtime.hashGrow(SB)	
		goto again // Growing the table invalidates everything, so try again
  0x40ce51		488b442440		MOVQ 0x40(SP), AX	
  0x40ce56		488b4c2448		MOVQ 0x48(SP), CX	
  0x40ce5b		488b542420		MOVQ 0x20(SP), DX	
	bucket := hash & bucketMask(h.B)
  0x40ce60		4889d0			MOVQ DX, AX		
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40ce63		488b542440		MOVQ 0x40(SP), DX	
	bucket := hash & bucketMask(h.B)
  0x40ce68		0fb65909		MOVZX 0x9(CX), BX	
func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40ce6c		4889ce			MOVQ CX, SI		
	return uintptr(1) << b
  0x40ce6f		89d9			MOVL BX, CX		
  0x40ce71		bf01000000		MOVL $0x1, DI		
  0x40ce76		48d3e7			SHLQ CL, DI		
	return bucketShift(b) - 1
  0x40ce79		488d5fff		LEAQ -0x1(DI), BX	
	bucket := hash & bucketMask(h.B)
  0x40ce7d		4821c3			ANDQ AX, BX		
  0x40ce80		90			NOPL			
	if h.growing() {
  0x40ce81		90			NOPL			
	return bucketShift(b) - 1
  0x40ce82		90			NOPL			
	return h.oldbuckets != nil
  0x40ce83		48837e1800		CMPQ $0x0, 0x18(SI)	
	if h.growing() {
  0x40ce88		0f8536010000		JNE 0x40cfc4		
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40ce8e		0fb77a4a		MOVZX 0x4a(DX), DI	
  0x40ce92		480fafdf		IMULQ DI, BX		
  0x40ce96		48035e10		ADDQ 0x10(SI), BX	
  0x40ce9a		31c9			XORL CX, CX		
  0x40ce9c		4531c0			XORL R8, R8		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40ce9f		e90a010000		JMP 0x40cfae		
	if insertb == nil {
  0x40cea4		4885db			TESTQ BX, BX		
  0x40cea7		7461			JE 0x40cf0a		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cea9		90			NOPL			
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40ceaa		48c1e838		SHRQ $0x38, AX		
	if top < minTopHash {
  0x40ceae		3c05			CMPL $0x5, AL		
  0x40ceb0		7303			JAE 0x40ceb5		
		top += minTopHash
  0x40ceb2		83c005			ADDL $0x5, AX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40ceb5		8403			TESTB AL, 0(BX)		
  0x40ceb7		4c89c9			MOVQ R9, CX		
  0x40ceba		4983e107		ANDQ $0x7, R9		
  0x40cebe		4288040b		MOVB AL, 0(BX)(R9*1)	
	return unsafe.Pointer(uintptr(p) + x)
  0x40cec2		4889d8			MOVQ BX, AX		
  0x40cec5		488d1c8b		LEAQ 0(BX)(CX*4), BX	
  0x40cec9		488d5b08		LEAQ 0x8(BX), BX	
	insertk = add(unsafe.Pointer(insertb), dataOffset+inserti*4)
  0x40cecd		90			NOPL			
	*(*uint32)(insertk) = key
  0x40cece		8b7c2450		MOVL 0x50(SP), DI	
  0x40ced2		893b			MOVL DI, 0(BX)		
	h.count++
  0x40ced4		48ff06			INCQ 0(SI)		
	val := add(unsafe.Pointer(insertb), dataOffset+bucketCnt*4+inserti*uintptr(t.valuesize))
  0x40ced7		90			NOPL			
  0x40ced8		0fb65249		MOVZX 0x49(DX), DX	
  0x40cedc		480fafca		IMULQ DX, CX		
	if h.flags&hashWriting == 0 {
  0x40cee0		0fb65608		MOVZX 0x8(SI), DX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40cee4		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x40cee8		488d4028		LEAQ 0x28(AX), AX	
	if h.flags&hashWriting == 0 {
  0x40ceec		f6c204			TESTL $0x4, DL		
  0x40ceef		0f8454010000		JE 0x40d049		
	h.flags &^= hashWriting
  0x40cef5		83e2fb			ANDL $-0x5, DX		
  0x40cef8		885608			MOVB DL, 0x8(SI)	
	return val
  0x40cefb		4889442458		MOVQ AX, 0x58(SP)	
  0x40cf00		488b6c2430		MOVQ 0x30(SP), BP	
  0x40cf05		4883c438		ADDQ $0x38, SP		
  0x40cf09		c3			RET			
		insertb = h.newoverflow(t, b)
  0x40cf0a		48893424		MOVQ SI, 0(SP)				
  0x40cf0e		4889542408		MOVQ DX, 0x8(SP)			
  0x40cf13		4c895c2410		MOVQ R11, 0x10(SP)			
  0x40cf18		e8c3e0ffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x40cf1d		488b5c2418		MOVQ 0x18(SP), BX			
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40cf22		488b442420		MOVQ 0x20(SP), AX	
	val := add(unsafe.Pointer(insertb), dataOffset+bucketCnt*4+inserti*uintptr(t.valuesize))
  0x40cf27		488b542440		MOVQ 0x40(SP), DX	
	h.count++
  0x40cf2c		488b742448		MOVQ 0x48(SP), SI	
  0x40cf31		4531c9			XORL R9, R9		
		inserti = 0 // not necessary, but avoids needlessly spilling inserti
  0x40cf34		e970ffffff		JMP 0x40cea9		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40cf39		90			NOPL			
  0x40cf3a		0fb77e0a		MOVZX 0xa(SI), DI	
	if B > 15 {
  0x40cf3e		80f90f			CMPL $0xf, CL		
  0x40cf41		7605			JBE 0x40cf48		
  0x40cf43		b90f000000		MOVL $0xf, CX		
	return noverflow >= uint16(1)<<(B&15)
  0x40cf48		83e10f			ANDL $0xf, CX		
  0x40cf4b		41b801000000		MOVL $0x1, R8		
  0x40cf51		41d3e0			SHLL CL, R8		
  0x40cf54		664439c7		CMPW R8, DI		
  0x40cf58		0f93c1			SETAE CL		
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
  0x40cf5b		e9dffeffff		JMP 0x40ce3f		
  0x40cf60		31ff			XORL DI, DI		
	return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen)
  0x40cf62		e9cafeffff		JMP 0x40ce31		
	return unsafe.Pointer(uintptr(p) + x)
  0x40cf67		4989da			MOVQ BX, R10		
  0x40cf6a		4a8d1c8b		LEAQ 0(BX)(R9*4), BX	
  0x40cf6e		488d5b08		LEAQ 0x8(BX), BX	
			k := *((*uint32)(add(unsafe.Pointer(b), dataOffset+i*4)))
  0x40cf72		90			NOPL			
			if k != key {
  0x40cf73		448b5c2450		MOVL 0x50(SP), R11	
  0x40cf78		44391b			CMPL R11, 0(BX)		
  0x40cf7b		7411			JE 0x40cf8e		
			if isEmpty(b.tophash[i]) {
  0x40cf7d		4d89d3			MOVQ R10, R11		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40cf80		4d89cc			MOVQ R9, R12		
	if insertb == nil {
  0x40cf83		4889cb			MOVQ CX, BX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cf86		4d89c1			MOVQ R8, R9		
				continue
  0x40cf89		e923feffff		JMP 0x40cdb1		
	val := add(unsafe.Pointer(insertb), dataOffset+bucketCnt*4+inserti*uintptr(t.valuesize))
  0x40cf8e		4c89d0			MOVQ R10, AX		
  0x40cf91		4c89c9			MOVQ R9, CX		
			goto done
  0x40cf94		e93effffff		JMP 0x40ced7		
	return unsafe.Pointer(uintptr(p) + x)
  0x40cf99		4989d9			MOVQ BX, R9		
  0x40cf9c		488d1c3b		LEAQ 0(BX)(DI*1), BX	
  0x40cfa0		488d5bf8		LEAQ -0x8(BX), BX	
		ovf := b.overflow(t)
  0x40cfa4		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40cfa5		488b1b			MOVQ 0(BX), BX		
  0x40cfa8		90			NOPL			
		if ovf == nil {
  0x40cfa9		4885db			TESTQ BX, BX		
  0x40cfac		7408			JE 0x40cfb6		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cfae		4531c9			XORL R9, R9		
		for i := uintptr(0); i < bucketCnt; i++ {
  0x40cfb1		e90cfeffff		JMP 0x40cdc2		
		insertb = h.newoverflow(t, b)
  0x40cfb6		4d89cb			MOVQ R9, R11		
	if insertb == nil {
  0x40cfb9		4889cb			MOVQ CX, BX		
	insertb.tophash[inserti&(bucketCnt-1)] = tophash(hash) // mask inserti to avoid bounds checks
  0x40cfbc		4d89c1			MOVQ R8, R9		
			break
  0x40cfbf		e930feffff		JMP 0x40cdf4		
	bucket := hash & bucketMask(h.B)
  0x40cfc4		48895c2428		MOVQ BX, 0x28(SP)	
		growWork_fast32(t, h, bucket)
  0x40cfc9		48891424		MOVQ DX, 0(SP)				
  0x40cfcd		4889742408		MOVQ SI, 0x8(SP)			
  0x40cfd2		48895c2410		MOVQ BX, 0x10(SP)			
  0x40cfd7		e8d4000000		CALL runtime.growWork_fast32(SB)	
	top := uint8(hash >> (sys.PtrSize*8 - 8))
  0x40cfdc		488b442420		MOVQ 0x20(SP), AX	
	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
  0x40cfe1		488b542440		MOVQ 0x40(SP), DX	
  0x40cfe6		488b5c2428		MOVQ 0x28(SP), BX	
  0x40cfeb		488b742448		MOVQ 0x48(SP), SI	
		growWork_fast32(t, h, bucket)
  0x40cff0		e999feffff		JMP 0x40ce8e		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40cff5		488b442440		MOVQ 0x40(SP), AX	
  0x40cffa		488b4840		MOVQ 0x40(AX), CX	
  0x40cffe		90			NOPL			
	return mallocgc(typ.size, typ, true)
  0x40cfff		488b11			MOVQ 0(CX), DX			
  0x40d002		48891424		MOVQ DX, 0(SP)			
  0x40d006		48894c2408		MOVQ CX, 0x8(SP)		
  0x40d00b		c644241001		MOVB $0x1, 0x10(SP)		
  0x40d010		e8fbcbffff		CALL runtime.mallocgc(SB)	
  0x40d015		488b442418		MOVQ 0x18(SP), AX		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40d01a		833dfffd0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x40d021		7516			JNE 0x40d039				
  0x40d023		488b542448		MOVQ 0x48(SP), DX			
  0x40d028		48894210		MOVQ AX, 0x10(DX)			
	bucket := hash & bucketMask(h.B)
  0x40d02c		488b442420		MOVQ 0x20(SP), AX	
  0x40d031		4889d1			MOVQ DX, CX		
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40d034		e96efdffff		JMP 0x40cda7		
	if h.buckets == nil {
  0x40d039		488b542448		MOVQ 0x48(SP), DX	
  0x40d03e		488d7a10		LEAQ 0x10(DX), DI	
		h.buckets = newobject(t.bucket) // newarray(t.bucket, 1)
  0x40d042		e839c60300		CALL runtime.gcWriteBarrier(SB)	
  0x40d047		ebe3			JMP 0x40d02c			
		throw("concurrent map writes")
  0x40d049		488d05c9370600		LEAQ 0x637c9(IP), AX	
  0x40d050		48890424		MOVQ AX, 0(SP)		
  0x40d054		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x40d05d		e81e640100		CALL runtime.throw(SB)	
  0x40d062		0f0b			UD2			
		throw("concurrent map writes")
  0x40d064		488d05ae370600		LEAQ 0x637ae(IP), AX	
  0x40d06b		48890424		MOVQ AX, 0(SP)		
  0x40d06f		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x40d078		e803640100		CALL runtime.throw(SB)	
  0x40d07d		0f0b			UD2			
		panic(plainError("assignment to entry in nil map"))
  0x40d07f		488d057a200500		LEAQ 0x5207a(IP), AX			
  0x40d086		48890424		MOVQ AX, 0(SP)				
  0x40d08a		488d05effe0600		LEAQ runtime.statictmp_12(SB), AX	
  0x40d091		4889442408		MOVQ AX, 0x8(SP)			
  0x40d096		e8155e0100		CALL runtime.gopanic(SB)		
  0x40d09b		0f0b			UD2					
func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {
  0x40d09d		e8dea70300		CALL runtime.morestack_noctxt(SB)	
  0x40d0a2		e979fcffff		JMP runtime.mapassign_fast32(SB)	

TEXT runtime.growWork_fast32(SB) /usr/local/go/src/runtime/map_fast32.go
func growWork_fast32(t *maptype, h *hmap, bucket uintptr) {
  0x40d0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40d0b9		483b6110		CMPQ 0x10(CX), SP	
  0x40d0bd		0f868b000000		JBE 0x40d14e		
  0x40d0c3		4883ec20		SUBQ $0x20, SP		
  0x40d0c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x40d0cc		488d6c2418		LEAQ 0x18(SP), BP	
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x40d0d1		90			NOPL			
	return h.noldbuckets() - 1
  0x40d0d2		90			NOPL			
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x40d0d3		488b442430		MOVQ 0x30(SP), AX	
	oldB := h.B
  0x40d0d8		0fb65009		MOVZX 0x9(AX), DX	
	if !h.sameSizeGrow() {
  0x40d0dc		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40d0dd		0fb65808		MOVZX 0x8(AX), BX	
  0x40d0e1		f6c308			TESTL $0x8, BL		
	if !h.sameSizeGrow() {
  0x40d0e4		7464			JE 0x40d14a		
	return bucketShift(oldB)
  0x40d0e6		90			NOPL			
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x40d0e7		488b5c2428		MOVQ 0x28(SP), BX	
  0x40d0ec		48891c24		MOVQ BX, 0(SP)		
  0x40d0f0		4889442408		MOVQ AX, 0x8(SP)	
	return uintptr(1) << b
  0x40d0f5		89d1			MOVL DX, CX		
  0x40d0f7		be01000000		MOVL $0x1, SI		
  0x40d0fc		48d3e6			SHLQ CL, SI		
	return h.noldbuckets() - 1
  0x40d0ff		488d56ff		LEAQ -0x1(SI), DX	
	evacuate_fast32(t, h, bucket&h.oldbucketmask())
  0x40d103		488b742438		MOVQ 0x38(SP), SI			
  0x40d108		4821d6			ANDQ DX, SI				
  0x40d10b		4889742410		MOVQ SI, 0x10(SP)			
  0x40d110		e84b000000		CALL runtime.evacuate_fast32(SB)	
	if h.growing() {
  0x40d115		90			NOPL			
	return h.oldbuckets != nil
  0x40d116		488b442430		MOVQ 0x30(SP), AX	
  0x40d11b		4883781800		CMPQ $0x0, 0x18(AX)	
	if h.growing() {
  0x40d120		750a			JNE 0x40d12c		
  0x40d122		488b6c2418		MOVQ 0x18(SP), BP	
  0x40d127		4883c420		ADDQ $0x20, SP		
  0x40d12b		c3			RET			
		evacuate_fast32(t, h, h.nevacuate)
  0x40d12c		488b4820		MOVQ 0x20(AX), CX			
  0x40d130		488b542428		MOVQ 0x28(SP), DX			
  0x40d135		48891424		MOVQ DX, 0(SP)				
  0x40d139		4889442408		MOVQ AX, 0x8(SP)			
  0x40d13e		48894c2410		MOVQ CX, 0x10(SP)			
  0x40d143		e818000000		CALL runtime.evacuate_fast32(SB)	
  0x40d148		ebd8			JMP 0x40d122				
		oldB--
  0x40d14a		ffca			DECL DX			
  0x40d14c		eb98			JMP 0x40d0e6		
func growWork_fast32(t *maptype, h *hmap, bucket uintptr) {
  0x40d14e		e82da70300		CALL runtime.morestack_noctxt(SB)	
  0x40d153		e958ffffff		JMP runtime.growWork_fast32(SB)		

TEXT runtime.evacuate_fast32(SB) /usr/local/go/src/runtime/map_fast32.go
func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr) {
  0x40d160		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40d169		488d4424e0		LEAQ -0x20(SP), AX	
  0x40d16e		483b4110		CMPQ 0x10(CX), AX	
  0x40d172		0f8603040000		JBE 0x40d57b		
  0x40d178		4881eca0000000		SUBQ $0xa0, SP		
  0x40d17f		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x40d187		488dac2498000000	LEAQ 0x98(SP), BP	
	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
  0x40d18f		90			NOPL			
  0x40d190		488b8424a8000000	MOVQ 0xa8(SP), AX	
  0x40d198		0fb7584a		MOVZX 0x4a(AX), BX	
  0x40d19c		488bb424b8000000	MOVQ 0xb8(SP), SI	
  0x40d1a4		480fafde		IMULQ SI, BX		
	newbit := h.noldbuckets()
  0x40d1a8		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d1a9		488bbc24b0000000	MOVQ 0xb0(SP), DI	
  0x40d1b1		48035f18		ADDQ 0x18(DI), BX	
	oldB := h.B
  0x40d1b5		440fb64709		MOVZX 0x9(DI), R8	
	if !h.sameSizeGrow() {
  0x40d1ba		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40d1bb		440fb64f08		MOVZX 0x8(DI), R9	
  0x40d1c0		41f6c108		TESTL $0x8, R9		
	if !h.sameSizeGrow() {
  0x40d1c4		0f8487030000		JE 0x40d551		
	if !evacuated(b) {
  0x40d1ca		90			NOPL			
	return bucketShift(oldB)
  0x40d1cb		90			NOPL			
	h := b.tophash[0]
  0x40d1cc		440fb60b		MOVZX 0(BX), R9		
	return h > emptyOne && h < minTopHash
  0x40d1d0		4180f901		CMPL $0x1, R9		
  0x40d1d4		0f866f030000		JBE 0x40d549		
  0x40d1da		4180f905		CMPL $0x5, R9		
  0x40d1de		410f92c1		SETB R9			
	return uintptr(1) << b
  0x40d1e2		4489c1			MOVL R8, CX		
  0x40d1e5		41ba01000000		MOVL $0x1, R10		
  0x40d1eb		49d3e2			SHLQ CL, R10		
	if !evacuated(b) {
  0x40d1ee		4584c9			TESTL R9, R9		
  0x40d1f1		0f85ab020000		JNE 0x40d4a2		
		var xy [2]evacDst
  0x40d1f7		0f57c0			XORPS X0, X0		
  0x40d1fa		0f11442458		MOVUPS X0, 0x58(SP)	
  0x40d1ff		0f11442468		MOVUPS X0, 0x68(SP)	
  0x40d204		0f11442478		MOVUPS X0, 0x78(SP)	
  0x40d209		0f11842488000000	MOVUPS X0, 0x88(SP)	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x40d211		90			NOPL			
  0x40d212		440fb7484a		MOVZX 0x4a(AX), R9	
  0x40d217		4c0fafce		IMULQ SI, R9		
	return unsafe.Pointer(uintptr(p) + x)
  0x40d21b		4c034f10		ADDQ 0x10(DI), R9	
		x.b = (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))
  0x40d21f		4c894c2458		MOVQ R9, 0x58(SP)	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x40d224		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d225		4d8d5908		LEAQ 0x8(R9), R11	
		x.k = add(unsafe.Pointer(x.b), dataOffset)
  0x40d229		4c895c2468		MOVQ R11, 0x68(SP)	
		x.v = add(x.k, bucketCnt*4)
  0x40d22e		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d22f		4983c128		ADDQ $0x28, R9		
		x.v = add(x.k, bucketCnt*4)
  0x40d233		4c894c2470		MOVQ R9, 0x70(SP)	
		if !h.sameSizeGrow() {
  0x40d238		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40d239		440fb64f08		MOVZX 0x8(DI), R9	
  0x40d23e		41f6c108		TESTL $0x8, R9		
		if !h.sameSizeGrow() {
  0x40d242		0f84cb020000		JE 0x40d513		
	return bucketShift(oldB)
  0x40d248		884c2427		MOVB CL, 0x27(SP)	
	return uintptr(1) << b
  0x40d24c		4c89542438		MOVQ R10, 0x38(SP)	
		for ; b != nil; b = b.overflow(t) {
  0x40d251		e91b020000		JMP 0x40d471		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d256		48ffc2			INCQ DX			
  0x40d259		90			NOPL			
  0x40d25a		90			NOPL			
  0x40d25b		440fb66049		MOVZX 0x49(AX), R12	
	return unsafe.Pointer(uintptr(p) + x)
  0x40d260		4983c104		ADDQ $0x4, R9		
  0x40d264		4d01e3			ADDQ R12, R11		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d267		4883fa08		CMPQ $0x8, DX		
  0x40d26b		0f8dee010000		JGE 0x40d45f		
				top := b.tophash[i]
  0x40d271		440fb62413		MOVZX 0(BX)(DX*1), R12	
				if isEmpty(top) {
  0x40d276		90			NOPL			
	return x <= emptyOne
  0x40d277		4180fc01		CMPL $0x1, R12		
				if isEmpty(top) {
  0x40d27b		7706			JA 0x40d283		
					b.tophash[i] = evacuatedEmpty
  0x40d27d		c6041304		MOVB $0x4, 0(BX)(DX*1)	
					continue
  0x40d281		ebd3			JMP 0x40d256		
				if top < minTopHash {
  0x40d283		4180fc05		CMPL $0x5, R12		
  0x40d287		0f82d3020000		JB 0x40d560		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d28d		4889542428		MOVQ DX, 0x28(SP)	
				top := b.tophash[i]
  0x40d292		4488642426		MOVB R12, 0x26(SP)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d297		4c895c2440		MOVQ R11, 0x40(SP)	
					*(*uint32)(dst.k) = *(*uint32)(k)
  0x40d29c		4c894c2448		MOVQ R9, 0x48(SP)	
				if !h.sameSizeGrow() {
  0x40d2a1		90			NOPL			
	return h.flags&sameSizeGrow != 0
  0x40d2a2		440fb66f08		MOVZX 0x8(DI), R13	
  0x40d2a7		41f6c508		TESTL $0x8, R13		
				if !h.sameSizeGrow() {
  0x40d2ab		0f8440010000		JE 0x40d3f1		
  0x40d2b1		4531ed			XORL R13, R13		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY, enforced in makemap
  0x40d2b4		458d7502		LEAL 0x2(R13), R14	
  0x40d2b8		44883413		MOVB R14, 0(BX)(DX*1)	
				dst := &xy[useY]                 // evacuation destination
  0x40d2bc		450fb6ed		MOVZX R13, R13		
  0x40d2c0		4983fd02		CMPQ $0x2, R13		
  0x40d2c4		0f838f020000		JAE 0x40d559		
  0x40d2ca		49c1e505		SHLQ $0x5, R13		
  0x40d2ce		4c896c2430		MOVQ R13, 0x30(SP)	
				if dst.i == bucketCnt {
  0x40d2d3		4e8b742c60		MOVQ 0x60(SP)(R13*1), R14	
  0x40d2d8		4983fe08		CMPQ $0x8, R14			
  0x40d2dc		0f84ae000000		JE 0x40d390			
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40d2e2		4a8b4c2c58		MOVQ 0x58(SP)(R13*1), CX	
  0x40d2e7		8401			TESTB AL, 0(CX)			
  0x40d2e9		4a8b542c60		MOVQ 0x60(SP)(R13*1), DX	
  0x40d2ee		4883e207		ANDQ $0x7, DX			
  0x40d2f2		44882411		MOVB R12, 0(CX)(DX*1)		
					*(*uint32)(dst.k) = *(*uint32)(k)
  0x40d2f6		4a8b4c2c68		MOVQ 0x68(SP)(R13*1), CX	
  0x40d2fb		418b11			MOVL 0(R9), DX			
  0x40d2fe		8911			MOVL DX, 0(CX)			
				typedmemmove(t.elem, dst.v, v)
  0x40d300		488b4838		MOVQ 0x38(AX), CX		
  0x40d304		4a8b542c70		MOVQ 0x70(SP)(R13*1), DX	
  0x40d309		48890c24		MOVQ CX, 0(SP)			
  0x40d30d		4889542408		MOVQ DX, 0x8(SP)		
  0x40d312		4c895c2410		MOVQ R11, 0x10(SP)		
  0x40d317		e874020000		CALL runtime.typedmemmove(SB)	
				dst.i++
  0x40d31c		488b442430		MOVQ 0x30(SP), AX	
  0x40d321		488b4c0460		MOVQ 0x60(SP)(AX*1), CX	
  0x40d326		48ffc1			INCQ CX			
  0x40d329		48894c0460		MOVQ CX, 0x60(SP)(AX*1)	
				dst.k = add(dst.k, 4)
  0x40d32e		90			NOPL			
  0x40d32f		488b4c0468		MOVQ 0x68(SP)(AX*1), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40d334		4883c104		ADDQ $0x4, CX		
				dst.k = add(dst.k, 4)
  0x40d338		48894c0468		MOVQ CX, 0x68(SP)(AX*1)	
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40d33d		90			NOPL			
  0x40d33e		488b4c0470		MOVQ 0x70(SP)(AX*1), CX	
  0x40d343		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x40d34b		0fb65a49		MOVZX 0x49(DX), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x40d34f		4801d9			ADDQ BX, CX		
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40d352		48894c0470		MOVQ CX, 0x70(SP)(AX*1)	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d357		4889d0			MOVQ DX, AX		
					if hash&newbit != 0 {
  0x40d35a		0fb64c2427		MOVZX 0x27(SP), CX	
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d35f		488b542428		MOVQ 0x28(SP), DX	
				top := b.tophash[i]
  0x40d364		488b5c2450		MOVQ 0x50(SP), BX	
	if oldbucket == h.nevacuate {
  0x40d369		488bb424b8000000	MOVQ 0xb8(SP), SI	
	return h.flags&sameSizeGrow != 0
  0x40d371		488bbc24b0000000	MOVQ 0xb0(SP), DI	
					if hash&newbit != 0 {
  0x40d379		4189c8			MOVL CX, R8		
	return unsafe.Pointer(uintptr(p) + x)
  0x40d37c		4c8b4c2448		MOVQ 0x48(SP), R9	
		advanceEvacuationMark(h, t, newbit)
  0x40d381		4c8b542438		MOVQ 0x38(SP), R10	
	return unsafe.Pointer(uintptr(p) + x)
  0x40d386		4c8b5c2440		MOVQ 0x40(SP), R11	
				dst.v = add(dst.v, uintptr(t.valuesize))
  0x40d38b		e9c6feffff		JMP 0x40d256		
					dst.b = h.newoverflow(t, dst.b)
  0x40d390		4a8b4c2c58		MOVQ 0x58(SP)(R13*1), CX		
  0x40d395		48893c24		MOVQ DI, 0(SP)				
  0x40d399		4889442408		MOVQ AX, 0x8(SP)			
  0x40d39e		48894c2410		MOVQ CX, 0x10(SP)			
  0x40d3a3		e838dcffff		CALL runtime.(*hmap).newoverflow(SB)	
  0x40d3a8		488b442418		MOVQ 0x18(SP), AX			
  0x40d3ad		4c8b6c2430		MOVQ 0x30(SP), R13			
  0x40d3b2		4a89442c58		MOVQ AX, 0x58(SP)(R13*1)		
					dst.i = 0
  0x40d3b7		4ac7442c6000000000	MOVQ $0x0, 0x60(SP)(R13*1)	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x40d3c0		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d3c1		488d4808		LEAQ 0x8(AX), CX	
					dst.k = add(unsafe.Pointer(dst.b), dataOffset)
  0x40d3c5		4a894c2c68		MOVQ CX, 0x68(SP)(R13*1)	
					dst.v = add(dst.k, bucketCnt*4)
  0x40d3ca		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d3cb		4883c028		ADDQ $0x28, AX		
					dst.v = add(dst.k, bucketCnt*4)
  0x40d3cf		4a89442c70		MOVQ AX, 0x70(SP)(R13*1)	
				typedmemmove(t.elem, dst.v, v)
  0x40d3d4		488b8424a8000000	MOVQ 0xa8(SP), AX	
					*(*uint32)(dst.k) = *(*uint32)(k)
  0x40d3dc		4c8b4c2448		MOVQ 0x48(SP), R9	
				typedmemmove(t.elem, dst.v, v)
  0x40d3e1		4c8b5c2440		MOVQ 0x40(SP), R11	
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40d3e6		440fb6642426		MOVZX 0x26(SP), R12	
					dst.v = add(dst.k, bucketCnt*4)
  0x40d3ec		e9f1feffff		JMP 0x40d2e2		
					hash := t.key.alg.hash(k, uintptr(h.hash0))
  0x40d3f1		488b4830		MOVQ 0x30(AX), CX	
  0x40d3f5		488b4918		MOVQ 0x18(CX), CX	
  0x40d3f9		488b11			MOVQ 0(CX), DX		
  0x40d3fc		8b4f0c			MOVL 0xc(DI), CX	
  0x40d3ff		4c890c24		MOVQ R9, 0(SP)		
  0x40d403		48894c2408		MOVQ CX, 0x8(SP)	
  0x40d408		488b0a			MOVQ 0(DX), CX		
  0x40d40b		ffd1			CALL CX			
  0x40d40d		488b442410		MOVQ 0x10(SP), AX	
					if hash&newbit != 0 {
  0x40d412		440fb6442427		MOVZX 0x27(SP), R8	
  0x40d418		4c0fa3c0		BTQ R8, AX		
  0x40d41c		410f92c5		SETB R13		
				typedmemmove(t.elem, dst.v, v)
  0x40d420		488b8424a8000000	MOVQ 0xa8(SP), AX	
					if hash&newbit != 0 {
  0x40d428		4489c1			MOVL R8, CX		
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY, enforced in makemap
  0x40d42b		488b542428		MOVQ 0x28(SP), DX	
  0x40d430		488b5c2450		MOVQ 0x50(SP), BX	
	if oldbucket == h.nevacuate {
  0x40d435		488bb424b8000000	MOVQ 0xb8(SP), SI	
					dst.b = h.newoverflow(t, dst.b)
  0x40d43d		488bbc24b0000000	MOVQ 0xb0(SP), DI	
					*(*uint32)(dst.k) = *(*uint32)(k)
  0x40d445		4c8b4c2448		MOVQ 0x48(SP), R9	
		advanceEvacuationMark(h, t, newbit)
  0x40d44a		4c8b542438		MOVQ 0x38(SP), R10	
				typedmemmove(t.elem, dst.v, v)
  0x40d44f		4c8b5c2440		MOVQ 0x40(SP), R11	
				dst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check
  0x40d454		440fb6642426		MOVZX 0x26(SP), R12	
				b.tophash[i] = evacuatedX + useY // evacuatedX + 1 == evacuatedY, enforced in makemap
  0x40d45a		e955feffff		JMP 0x40d2b4		
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40d45f		440fb7484a		MOVZX 0x4a(AX), R9	
	return unsafe.Pointer(uintptr(p) + x)
  0x40d464		4e8d0c0b		LEAQ 0(BX)(R9*1), R9	
  0x40d468		4d8d49f8		LEAQ -0x8(R9), R9	
		for ; b != nil; b = b.overflow(t) {
  0x40d46c		90			NOPL			
	return *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))
  0x40d46d		498b19			MOVQ 0(R9), BX		
  0x40d470		90			NOPL			
		for ; b != nil; b = b.overflow(t) {
  0x40d471		4885db			TESTQ BX, BX		
  0x40d474		7416			JE 0x40d48c		
  0x40d476		48895c2450		MOVQ BX, 0x50(SP)	
			k := add(unsafe.Pointer(b), dataOffset)
  0x40d47b		90			NOPL			
			v := add(k, bucketCnt*4)
  0x40d47c		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d47d		4c8d4b08		LEAQ 0x8(BX), R9	
  0x40d481		4c8d5b28		LEAQ 0x28(BX), R11	
  0x40d485		31d2			XORL DX, DX		
			for i := 0; i < bucketCnt; i, k, v = i+1, add(k, 4), add(v, uintptr(t.valuesize)) {
  0x40d487		e9dbfdffff		JMP 0x40d267		
		if h.flags&oldIterator == 0 && t.bucket.kind&kindNoPointers == 0 {
  0x40d48c		0fb64f08		MOVZX 0x8(DI), CX	
  0x40d490		f6c102			TESTL $0x2, CL		
  0x40d493		750d			JNE 0x40d4a2		
  0x40d495		488b4840		MOVQ 0x40(AX), CX	
  0x40d499		0fb64917		MOVZX 0x17(CX), CX	
  0x40d49d		f6c180			TESTL $0x80, CL		
  0x40d4a0		742b			JE 0x40d4cd		
	if oldbucket == h.nevacuate {
  0x40d4a2		48397720		CMPQ SI, 0x20(DI)	
  0x40d4a6		7410			JE 0x40d4b8		
  0x40d4a8		488bac2498000000	MOVQ 0x98(SP), BP	
  0x40d4b0		4881c4a0000000		ADDQ $0xa0, SP		
  0x40d4b7		c3			RET			
		advanceEvacuationMark(h, t, newbit)
  0x40d4b8		48893c24		MOVQ DI, 0(SP)				
  0x40d4bc		4889442408		MOVQ AX, 0x8(SP)			
  0x40d4c1		4c89542410		MOVQ R10, 0x10(SP)			
  0x40d4c6		e8d5f3ffff		CALL runtime.advanceEvacuationMark(SB)	
  0x40d4cb		ebdb			JMP 0x40d4a8				
			b := add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))
  0x40d4cd		90			NOPL			
  0x40d4ce		0fb7484a		MOVZX 0x4a(AX), CX	
  0x40d4d2		4889ca			MOVQ CX, DX		
  0x40d4d5		480fafce		IMULQ SI, CX		
			ptr := add(b, dataOffset)
  0x40d4d9		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d4da		48034f18		ADDQ 0x18(DI), CX	
  0x40d4de		4883c108		ADDQ $0x8, CX		
			memclrHasPointers(ptr, n)
  0x40d4e2		48890c24		MOVQ CX, 0(SP)		
			n := uintptr(t.bucketsize) - dataOffset
  0x40d4e6		488d4af8		LEAQ -0x8(DX), CX	
			memclrHasPointers(ptr, n)
  0x40d4ea		48894c2408		MOVQ CX, 0x8(SP)			
  0x40d4ef		e8bc030000		CALL runtime.memclrHasPointers(SB)	
		advanceEvacuationMark(h, t, newbit)
  0x40d4f4		488b8424a8000000	MOVQ 0xa8(SP), AX	
	if oldbucket == h.nevacuate {
  0x40d4fc		488bb424b8000000	MOVQ 0xb8(SP), SI	
  0x40d504		488bbc24b0000000	MOVQ 0xb0(SP), DI	
		advanceEvacuationMark(h, t, newbit)
  0x40d50c		4c8b542438		MOVQ 0x38(SP), R10	
			memclrHasPointers(ptr, n)
  0x40d511		eb8f			JMP 0x40d4a2		
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x40d513		90			NOPL			
  0x40d514		4d8d0c32		LEAQ 0(R10)(SI*1), R9	
  0x40d518		440fb7584a		MOVZX 0x4a(AX), R11	
  0x40d51d		4d0fafd9		IMULQ R9, R11		
	return unsafe.Pointer(uintptr(p) + x)
  0x40d521		4c035f10		ADDQ 0x10(DI), R11	
			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))
  0x40d525		4c895c2478		MOVQ R11, 0x78(SP)	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x40d52a		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d52b		4d8d4b08		LEAQ 0x8(R11), R9	
			y.k = add(unsafe.Pointer(y.b), dataOffset)
  0x40d52f		4c898c2488000000	MOVQ R9, 0x88(SP)	
			y.v = add(y.k, bucketCnt*4)
  0x40d537		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x40d538		4d8d4b28		LEAQ 0x28(R11), R9	
			y.v = add(y.k, bucketCnt*4)
  0x40d53c		4c898c2490000000	MOVQ R9, 0x90(SP)	
  0x40d544		e9fffcffff		JMP 0x40d248		
  0x40d549		4531c9			XORL R9, R9		
	return h > emptyOne && h < minTopHash
  0x40d54c		e991fcffff		JMP 0x40d1e2		
		oldB--
  0x40d551		41ffc8			DECL R8			
  0x40d554		e971fcffff		JMP 0x40d1ca		
				dst := &xy[useY]                 // evacuation destination
  0x40d559		e8c2490100		CALL runtime.panicindex(SB)	
  0x40d55e		0f0b			UD2				
					throw("bad map state")
  0x40d560		488d0500270600		LEAQ 0x62700(IP), AX	
  0x40d567		48890424		MOVQ AX, 0(SP)		
  0x40d56b		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x40d574		e8075f0100		CALL runtime.throw(SB)	
  0x40d579		0f0b			UD2			
func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr) {
  0x40d57b		e800a30300		CALL runtime.morestack_noctxt(SB)	
  0x40d580		e9dbfbffff		JMP runtime.evacuate_fast32(SB)		

TEXT runtime.typedmemmove(SB) /usr/local/go/src/runtime/mbarrier.go
func typedmemmove(typ *_type, dst, src unsafe.Pointer) {
  0x40d590		4883ec30		SUBQ $0x30, SP		
  0x40d594		48896c2428		MOVQ BP, 0x28(SP)	
  0x40d599		488d6c2428		LEAQ 0x28(SP), BP	
	if dst == src {
  0x40d59e		488b442440		MOVQ 0x40(SP), AX	
  0x40d5a3		488b4c2448		MOVQ 0x48(SP), CX	
  0x40d5a8		4839c8			CMPQ CX, AX		
  0x40d5ab		0f8496000000		JE 0x40d647		
	if typ.kind&kindNoPointers == 0 {
  0x40d5b1		488b542438		MOVQ 0x38(SP), DX	
  0x40d5b6		0fb65a17		MOVZX 0x17(DX), BX	
  0x40d5ba		f6c380			TESTL $0x80, BL		
  0x40d5bd		745e			JE 0x40d61d		
	memmove(dst, src, typ.size)
  0x40d5bf		488b1a			MOVQ 0(DX), BX			
  0x40d5c2		48890424		MOVQ AX, 0(SP)			
  0x40d5c6		48894c2408		MOVQ CX, 0x8(SP)		
  0x40d5cb		48895c2410		MOVQ BX, 0x10(SP)		
  0x40d5d0		e87bd10300		CALL runtime.memmove(SB)	
	if writeBarrier.cgo {
  0x40d5d5		803d49f80c0000		CMPB $0x0, runtime.writeBarrier+5(SB)	
  0x40d5dc		750a			JNE 0x40d5e8				
  0x40d5de		488b6c2428		MOVQ 0x28(SP), BP			
  0x40d5e3		4883c430		ADDQ $0x30, SP				
  0x40d5e7		c3			RET					
		cgoCheckMemmove(typ, dst, src, 0, typ.size)
  0x40d5e8		488b442438		MOVQ 0x38(SP), AX			
  0x40d5ed		488b08			MOVQ 0(AX), CX				
  0x40d5f0		48890424		MOVQ AX, 0(SP)				
  0x40d5f4		488b442440		MOVQ 0x40(SP), AX			
  0x40d5f9		4889442408		MOVQ AX, 0x8(SP)			
  0x40d5fe		488b442448		MOVQ 0x48(SP), AX			
  0x40d603		4889442410		MOVQ AX, 0x10(SP)			
  0x40d608		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x40d611		48894c2420		MOVQ CX, 0x20(SP)			
  0x40d616		e8b564ffff		CALL runtime.cgoCheckMemmove(SB)	
  0x40d61b		ebc1			JMP 0x40d5de				
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), typ.size)
  0x40d61d		488b32			MOVQ 0(DX), SI				
  0x40d620		48890424		MOVQ AX, 0(SP)				
  0x40d624		48894c2408		MOVQ CX, 0x8(SP)			
  0x40d629		4889742410		MOVQ SI, 0x10(SP)			
  0x40d62e		e82d0b0000		CALL runtime.bulkBarrierPreWrite(SB)	
	memmove(dst, src, typ.size)
  0x40d633		488b442440		MOVQ 0x40(SP), AX	
  0x40d638		488b4c2448		MOVQ 0x48(SP), CX	
  0x40d63d		488b542438		MOVQ 0x38(SP), DX	
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), typ.size)
  0x40d642		e978ffffff		JMP 0x40d5bf		
		return
  0x40d647		488b6c2428		MOVQ 0x28(SP), BP	
  0x40d64c		4883c430		ADDQ $0x30, SP		
  0x40d650		c3			RET			

TEXT runtime.reflectcallmove(SB) /usr/local/go/src/runtime/mbarrier.go
func reflectcallmove(typ *_type, dst, src unsafe.Pointer, size uintptr) {
  0x40d660		4883ec20		SUBQ $0x20, SP		
  0x40d664		48896c2418		MOVQ BP, 0x18(SP)	
  0x40d669		488d6c2418		LEAQ 0x18(SP), BP	
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40d66e		803daff70c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x40d675		7477			JE 0x40d6ee				
  0x40d677		488b442428		MOVQ 0x28(SP), AX			
  0x40d67c		4885c0			TESTQ AX, AX				
  0x40d67f		7466			JE 0x40d6e7				
  0x40d681		0fb64017		MOVZX 0x17(AX), AX			
  0x40d685		f6c080			TESTL $0x80, AL				
  0x40d688		7556			JNE 0x40d6e0				
  0x40d68a		488b442440		MOVQ 0x40(SP), AX			
  0x40d68f		4883f808		CMPQ $0x8, AX				
  0x40d693		7327			JAE 0x40d6bc				
	memmove(dst, src, size)
  0x40d695		488b4c2430		MOVQ 0x30(SP), CX		
  0x40d69a		48890c24		MOVQ CX, 0(SP)			
  0x40d69e		488b4c2438		MOVQ 0x38(SP), CX		
  0x40d6a3		48894c2408		MOVQ CX, 0x8(SP)		
  0x40d6a8		4889442410		MOVQ AX, 0x10(SP)		
  0x40d6ad		e89ed00300		CALL runtime.memmove(SB)	
}
  0x40d6b2		488b6c2418		MOVQ 0x18(SP), BP	
  0x40d6b7		4883c420		ADDQ $0x20, SP		
  0x40d6bb		c3			RET			
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), size)
  0x40d6bc		488b4c2430		MOVQ 0x30(SP), CX			
  0x40d6c1		48890c24		MOVQ CX, 0(SP)				
  0x40d6c5		488b4c2438		MOVQ 0x38(SP), CX			
  0x40d6ca		48894c2408		MOVQ CX, 0x8(SP)			
  0x40d6cf		4889442410		MOVQ AX, 0x10(SP)			
  0x40d6d4		e8870a0000		CALL runtime.bulkBarrierPreWrite(SB)	
	memmove(dst, src, size)
  0x40d6d9		488b442440		MOVQ 0x40(SP), AX	
		bulkBarrierPreWrite(uintptr(dst), uintptr(src), size)
  0x40d6de		ebb5			JMP 0x40d695		
	memmove(dst, src, size)
  0x40d6e0		488b442440		MOVQ 0x40(SP), AX	
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40d6e5		ebae			JMP 0x40d695		
	memmove(dst, src, size)
  0x40d6e7		488b442440		MOVQ 0x40(SP), AX	
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40d6ec		eba7			JMP 0x40d695		
	memmove(dst, src, size)
  0x40d6ee		488b442440		MOVQ 0x40(SP), AX	
	if writeBarrier.needed && typ != nil && typ.kind&kindNoPointers == 0 && size >= sys.PtrSize {
  0x40d6f3		eba0			JMP 0x40d695		

TEXT runtime.typedslicecopy(SB) /usr/local/go/src/runtime/mbarrier.go
func typedslicecopy(typ *_type, dst, src slice) int {
  0x40d700		4883ec58		SUBQ $0x58, SP		
  0x40d704		48896c2450		MOVQ BP, 0x50(SP)	
  0x40d709		488d6c2450		LEAQ 0x50(SP), BP	
	if n > src.len {
  0x40d70e		488b442470		MOVQ 0x70(SP), AX	
  0x40d713		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x40d71b		4839c8			CMPQ CX, AX		
	if n == 0 {
  0x40d71e		4889c2			MOVQ AX, DX		
  0x40d721		480f4fc1		CMOVG CX, AX		
  0x40d725		4885c0			TESTQ AX, AX		
	if n > src.len {
  0x40d728		0f84f6000000		JE 0x40d824		
	if n == 0 {
  0x40d72e		4889442448		MOVQ AX, 0x48(SP)	
	if writeBarrier.cgo {
  0x40d733		803debf60c0000		CMPB $0x0, runtime.writeBarrier+5(SB)	
  0x40d73a		0f858f000000		JNE 0x40d7cf				
	if dstp == srcp {
  0x40d740		488b4c2468		MOVQ 0x68(SP), CX	
  0x40d745		488b942480000000	MOVQ 0x80(SP), DX	
  0x40d74d		4839d1			CMPQ DX, CX		
  0x40d750		746b			JE 0x40d7bd		
	size := uintptr(n) * typ.size
  0x40d752		488b5c2460		MOVQ 0x60(SP), BX	
  0x40d757		488b1b			MOVQ 0(BX), BX		
  0x40d75a		480fafd8		IMULQ AX, BX		
	if writeBarrier.needed {
  0x40d75e		803dbff60c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x40d765		752a			JNE 0x40d791				
	memmove(dstp, srcp, size)
  0x40d767		48890c24		MOVQ CX, 0(SP)			
  0x40d76b		4889542408		MOVQ DX, 0x8(SP)		
  0x40d770		48895c2410		MOVQ BX, 0x10(SP)		
  0x40d775		e8d6cf0300		CALL runtime.memmove(SB)	
	return n
  0x40d77a		488b442448		MOVQ 0x48(SP), AX	
  0x40d77f		4889842498000000	MOVQ AX, 0x98(SP)	
  0x40d787		488b6c2450		MOVQ 0x50(SP), BP	
  0x40d78c		4883c458		ADDQ $0x58, SP		
  0x40d790		c3			RET			
	size := uintptr(n) * typ.size
  0x40d791		48895c2440		MOVQ BX, 0x40(SP)	
		bulkBarrierPreWrite(uintptr(dstp), uintptr(srcp), size)
  0x40d796		48890c24		MOVQ CX, 0(SP)				
  0x40d79a		4889542408		MOVQ DX, 0x8(SP)			
  0x40d79f		48895c2410		MOVQ BX, 0x10(SP)			
  0x40d7a4		e8b7090000		CALL runtime.bulkBarrierPreWrite(SB)	
	memmove(dstp, srcp, size)
  0x40d7a9		488b4c2468		MOVQ 0x68(SP), CX	
  0x40d7ae		488b942480000000	MOVQ 0x80(SP), DX	
  0x40d7b6		488b5c2440		MOVQ 0x40(SP), BX	
		bulkBarrierPreWrite(uintptr(dstp), uintptr(srcp), size)
  0x40d7bb		ebaa			JMP 0x40d767		
		return n
  0x40d7bd		4889842498000000	MOVQ AX, 0x98(SP)	
  0x40d7c5		488b6c2450		MOVQ 0x50(SP), BP	
  0x40d7ca		4883c458		ADDQ $0x58, SP		
  0x40d7ce		c3			RET			
		cgoCheckSliceCopy(typ, dst, src, n)
  0x40d7cf		488b5c2460		MOVQ 0x60(SP), BX			
  0x40d7d4		48891c24		MOVQ BX, 0(SP)				
  0x40d7d8		488b742468		MOVQ 0x68(SP), SI			
  0x40d7dd		4889742408		MOVQ SI, 0x8(SP)			
  0x40d7e2		4889542410		MOVQ DX, 0x10(SP)			
  0x40d7e7		488b542478		MOVQ 0x78(SP), DX			
  0x40d7ec		4889542418		MOVQ DX, 0x18(SP)			
  0x40d7f1		488b942480000000	MOVQ 0x80(SP), DX			
  0x40d7f9		4889542420		MOVQ DX, 0x20(SP)			
  0x40d7fe		48894c2428		MOVQ CX, 0x28(SP)			
  0x40d803		488b8c2490000000	MOVQ 0x90(SP), CX			
  0x40d80b		48894c2430		MOVQ CX, 0x30(SP)			
  0x40d810		4889442438		MOVQ AX, 0x38(SP)			
  0x40d815		e85663ffff		CALL runtime.cgoCheckSliceCopy(SB)	
	size := uintptr(n) * typ.size
  0x40d81a		488b442448		MOVQ 0x48(SP), AX	
		cgoCheckSliceCopy(typ, dst, src, n)
  0x40d81f		e91cffffff		JMP 0x40d740		
		return 0
  0x40d824		48c784249800000000000000	MOVQ $0x0, 0x98(SP)	
  0x40d830		488b6c2450			MOVQ 0x50(SP), BP	
  0x40d835		4883c458			ADDQ $0x58, SP		
  0x40d839		c3				RET			

TEXT runtime.typedmemclr(SB) /usr/local/go/src/runtime/mbarrier.go
func typedmemclr(typ *_type, ptr unsafe.Pointer) {
  0x40d840		4883ec20		SUBQ $0x20, SP		
  0x40d844		48896c2418		MOVQ BP, 0x18(SP)	
  0x40d849		488d6c2418		LEAQ 0x18(SP), BP	
	if typ.kind&kindNoPointers == 0 {
  0x40d84e		488b442428		MOVQ 0x28(SP), AX	
  0x40d853		0fb64817		MOVZX 0x17(AX), CX	
  0x40d857		f6c180			TESTL $0x80, CL		
  0x40d85a		7420			JE 0x40d87c		
	memclrNoHeapPointers(ptr, typ.size)
  0x40d85c		488b00			MOVQ 0(AX), AX				
  0x40d85f		488b4c2430		MOVQ 0x30(SP), CX			
  0x40d864		48890c24		MOVQ CX, 0(SP)				
  0x40d868		4889442408		MOVQ AX, 0x8(SP)			
  0x40d86d		e84ecc0300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40d872		488b6c2418		MOVQ 0x18(SP), BP	
  0x40d877		4883c420		ADDQ $0x20, SP		
  0x40d87b		c3			RET			
		bulkBarrierPreWrite(uintptr(ptr), 0, typ.size)
  0x40d87c		488b4c2430		MOVQ 0x30(SP), CX			
  0x40d881		488b18			MOVQ 0(AX), BX				
  0x40d884		48890c24		MOVQ CX, 0(SP)				
  0x40d888		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40d891		48895c2410		MOVQ BX, 0x10(SP)			
  0x40d896		e8c5080000		CALL runtime.bulkBarrierPreWrite(SB)	
	memclrNoHeapPointers(ptr, typ.size)
  0x40d89b		488b442428		MOVQ 0x28(SP), AX	
		bulkBarrierPreWrite(uintptr(ptr), 0, typ.size)
  0x40d8a0		ebba			JMP 0x40d85c		

TEXT runtime.memclrHasPointers(SB) /usr/local/go/src/runtime/mbarrier.go
func memclrHasPointers(ptr unsafe.Pointer, n uintptr) {
  0x40d8b0		4883ec20		SUBQ $0x20, SP		
  0x40d8b4		48896c2418		MOVQ BP, 0x18(SP)	
  0x40d8b9		488d6c2418		LEAQ 0x18(SP), BP	
	bulkBarrierPreWrite(uintptr(ptr), 0, n)
  0x40d8be		488b442428		MOVQ 0x28(SP), AX			
  0x40d8c3		48890424		MOVQ AX, 0(SP)				
  0x40d8c7		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x40d8d0		488b442430		MOVQ 0x30(SP), AX			
  0x40d8d5		4889442410		MOVQ AX, 0x10(SP)			
  0x40d8da		e881080000		CALL runtime.bulkBarrierPreWrite(SB)	
	memclrNoHeapPointers(ptr, n)
  0x40d8df		488b442428		MOVQ 0x28(SP), AX			
  0x40d8e4		48890424		MOVQ AX, 0(SP)				
  0x40d8e8		488b442430		MOVQ 0x30(SP), AX			
  0x40d8ed		4889442408		MOVQ AX, 0x8(SP)			
  0x40d8f2		e8c9cb0300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40d8f7		488b6c2418		MOVQ 0x18(SP), BP	
  0x40d8fc		4883c420		ADDQ $0x20, SP		
  0x40d900		c3			RET			

TEXT runtime.(*mspan).refillAllocCache(SB) /usr/local/go/src/runtime/mbitmap.go
	bytes := (*[8]uint8)(unsafe.Pointer(s.allocBits.bytep(whichByte)))
  0x40d910		90			NOPL			
  0x40d911		488b442410		MOVQ 0x10(SP), AX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40d916		488b4c2408		MOVQ 0x8(SP), CX	
  0x40d91b		48034148		ADDQ 0x48(CX), AX	
	aCache |= uint64(bytes[0])
  0x40d91f		488b00			MOVQ 0(AX), AX		
	s.allocCache = ^aCache
  0x40d922		48f7d0			NOTQ AX			
	return addb((*uint8)(b), n)
  0x40d925		90			NOPL			
	s.allocCache = ^aCache
  0x40d926		48894140		MOVQ AX, 0x40(CX)	
}
  0x40d92a		c3			RET			

TEXT runtime.(*mspan).nextFreeIndex(SB) /usr/local/go/src/runtime/mbitmap.go
func (s *mspan) nextFreeIndex() uintptr {
  0x40d930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40d939		483b6110		CMPQ 0x10(CX), SP	
  0x40d93d		0f8662010000		JBE 0x40daa5		
  0x40d943		4883ec30		SUBQ $0x30, SP		
  0x40d947		48896c2428		MOVQ BP, 0x28(SP)	
  0x40d94c		488d6c2428		LEAQ 0x28(SP), BP	
	sfreeindex := s.freeindex
  0x40d951		488b442438		MOVQ 0x38(SP), AX	
  0x40d956		488b5030		MOVQ 0x30(AX), DX	
	snelems := s.nelems
  0x40d95a		488b5838		MOVQ 0x38(AX), BX	
	if sfreeindex == snelems {
  0x40d95e		4839d3			CMPQ DX, BX		
  0x40d961		0f8414010000		JE 0x40da7b		
	if sfreeindex > snelems {
  0x40d967		4839da			CMPQ BX, DX		
  0x40d96a		0f871a010000		JA 0x40da8a		
	snelems := s.nelems
  0x40d970		48895c2410		MOVQ BX, 0x10(SP)	
	aCache := s.allocCache
  0x40d975		488b7040		MOVQ 0x40(AX), SI	
	bitIndex := sys.Ctz64(aCache)
  0x40d979		480fbcf6		BSFQ SI, SI		
  0x40d97d		bf40000000		MOVL $0x40, DI		
  0x40d982		480f44f7		CMOVE DI, SI		
	for bitIndex == 64 {
  0x40d986		eb42			JMP 0x40d9ca		
		sfreeindex = (sfreeindex + 64) &^ (64 - 1)
  0x40d988		48894c2418		MOVQ CX, 0x18(SP)	
		s.refillAllocCache(whichByte)
  0x40d98d		48890424		MOVQ AX, 0(SP)		
		whichByte := sfreeindex / 8
  0x40d991		48c1e903		SHRQ $0x3, CX		
		s.refillAllocCache(whichByte)
  0x40d995		48894c2408		MOVQ CX, 0x8(SP)				
  0x40d99a		e871ffffff		CALL runtime.(*mspan).refillAllocCache(SB)	
		aCache = s.allocCache
  0x40d99f		488b442438		MOVQ 0x38(SP), AX	
  0x40d9a4		488b4840		MOVQ 0x40(AX), CX	
		bitIndex = sys.Ctz64(aCache)
  0x40d9a8		480fbcc9		BSFQ CX, CX		
  0x40d9ac		bf40000000		MOVL $0x40, DI		
  0x40d9b1		480f44cf		CMOVE DI, CX		
	for bitIndex == 64 {
  0x40d9b5		488b542410		MOVQ 0x10(SP), DX	
  0x40d9ba		488b5c2418		MOVQ 0x18(SP), BX	
		if sfreeindex >= snelems {
  0x40d9bf		4889d3			MOVQ DX, BX		
	for bitIndex == 64 {
  0x40d9c2		4889ce			MOVQ CX, SI		
	result := sfreeindex + uintptr(bitIndex)
  0x40d9c5		488b542418		MOVQ 0x18(SP), DX	
	for bitIndex == 64 {
  0x40d9ca		4883fe40		CMPQ $0x40, SI		
  0x40d9ce		7520			JNE 0x40d9f0		
		sfreeindex = (sfreeindex + 64) &^ (64 - 1)
  0x40d9d0		488d4a40		LEAQ 0x40(DX), CX	
  0x40d9d4		4883e1c0		ANDQ $-0x40, CX		
		if sfreeindex >= snelems {
  0x40d9d8		4839d9			CMPQ BX, CX		
  0x40d9db		72ab			JB 0x40d988		
			s.freeindex = snelems
  0x40d9dd		48895830		MOVQ BX, 0x30(AX)	
			return snelems
  0x40d9e1		48895c2440		MOVQ BX, 0x40(SP)	
  0x40d9e6		488b6c2428		MOVQ 0x28(SP), BP	
  0x40d9eb		4883c430		ADDQ $0x30, SP		
  0x40d9ef		c3			RET			
	result := sfreeindex + uintptr(bitIndex)
  0x40d9f0		488d3c32		LEAQ 0(DX)(SI*1), DI	
	if result >= snelems {
  0x40d9f4		4839df			CMPQ BX, DI		
  0x40d9f7		736f			JAE 0x40da68		
	s.allocCache >>= uint(bitIndex + 1)
  0x40d9f9		488d4e01		LEAQ 0x1(SI), CX	
  0x40d9fd		4883f940		CMPQ $0x40, CX		
  0x40da01		4d19c0			SBBQ R8, R8		
  0x40da04		4c8b4840		MOVQ 0x40(AX), R9	
  0x40da08		49d3e9			SHRQ CL, R9		
  0x40da0b		4d21c1			ANDQ R8, R9		
  0x40da0e		4c894840		MOVQ R9, 0x40(AX)	
	sfreeindex = result + 1
  0x40da12		488d1432		LEAQ 0(DX)(SI*1), DX	
  0x40da16		488d5201		LEAQ 0x1(DX), DX	
	if sfreeindex%64 == 0 && sfreeindex != snelems {
  0x40da1a		48f7c23f000000		TESTQ $0x3f, DX		
  0x40da21		7505			JNE 0x40da28		
  0x40da23		4839da			CMPQ BX, DX		
  0x40da26		7513			JNE 0x40da3b		
	s.freeindex = sfreeindex
  0x40da28		48895030		MOVQ DX, 0x30(AX)	
	return result
  0x40da2c		48897c2440		MOVQ DI, 0x40(SP)	
  0x40da31		488b6c2428		MOVQ 0x28(SP), BP	
  0x40da36		4883c430		ADDQ $0x30, SP		
  0x40da3a		c3			RET			
	result := sfreeindex + uintptr(bitIndex)
  0x40da3b		48897c2420		MOVQ DI, 0x20(SP)	
	sfreeindex = result + 1
  0x40da40		4889542418		MOVQ DX, 0x18(SP)	
		s.refillAllocCache(whichByte)
  0x40da45		48890424		MOVQ AX, 0(SP)		
		whichByte := sfreeindex / 8
  0x40da49		48c1ea03		SHRQ $0x3, DX		
		s.refillAllocCache(whichByte)
  0x40da4d		4889542408		MOVQ DX, 0x8(SP)				
  0x40da52		e8b9feffff		CALL runtime.(*mspan).refillAllocCache(SB)	
	s.freeindex = sfreeindex
  0x40da57		488b442438		MOVQ 0x38(SP), AX	
  0x40da5c		488b542418		MOVQ 0x18(SP), DX	
	return result
  0x40da61		488b7c2420		MOVQ 0x20(SP), DI	
		s.refillAllocCache(whichByte)
  0x40da66		ebc0			JMP 0x40da28		
		s.freeindex = snelems
  0x40da68		48895830		MOVQ BX, 0x30(AX)	
		return snelems
  0x40da6c		48895c2440		MOVQ BX, 0x40(SP)	
  0x40da71		488b6c2428		MOVQ 0x28(SP), BP	
  0x40da76		4883c430		ADDQ $0x30, SP		
  0x40da7a		c3			RET			
		return sfreeindex
  0x40da7b		4889542440		MOVQ DX, 0x40(SP)	
  0x40da80		488b6c2428		MOVQ 0x28(SP), BP	
  0x40da85		4883c430		ADDQ $0x30, SP		
  0x40da89		c3			RET			
		throw("s.freeindex > s.nelems")
  0x40da8a		488d0510300600		LEAQ 0x63010(IP), AX	
  0x40da91		48890424		MOVQ AX, 0(SP)		
  0x40da95		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x40da9e		e8dd590100		CALL runtime.throw(SB)	
  0x40daa3		0f0b			UD2			
func (s *mspan) nextFreeIndex() uintptr {
  0x40daa5		e8d69d0300		CALL runtime.morestack_noctxt(SB)	
  0x40daaa		e981feffff		JMP runtime.(*mspan).nextFreeIndex(SB)	

TEXT runtime.markBitsForAddr(SB) /usr/local/go/src/runtime/mbitmap.go
	s := spanOf(p)
  0x40dab0		90			NOPL			
	ri := arenaIndex(p)
  0x40dab1		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40dab2		90			NOPL			
	s := spanOf(p)
  0x40dab3		48b80000000000800000	MOVQ $0x800000000000, AX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40dabd		488b542408		MOVQ 0x8(SP), DX	
  0x40dac2		4801d0			ADDQ DX, AX		
  0x40dac5		48c1e81a		SHRQ $0x1a, AX		
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40dac9		483d00004000		CMPQ $0x400000, AX	
  0x40dacf		0f828d000000		JB 0x40db62		
  0x40dad5		31c0			XORL AX, AX		
	objIndex := s.objIndex(p)
  0x40dad7		90			NOPL			
	return s.startAddr
  0x40dad8		488b5818		MOVQ 0x18(AX), BX	
	byteOffset := p - s.base()
  0x40dadc		4829da			SUBQ BX, DX		
  0x40dadf		90			NOPL			
	if byteOffset == 0 {
  0x40dae0		4885d2			TESTQ DX, DX		
  0x40dae3		752e			JNE 0x40db13		
  0x40dae5		31c9			XORL CX, CX		
	return s.markBitsForIndex(objIndex)
  0x40dae7		90			NOPL			
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x40dae8		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x40dae9		90			NOPL			
  0x40daea		4889ca			MOVQ CX, DX		
  0x40daed		48c1e903		SHRQ $0x3, CX		
	return addb((*uint8)(b), n)
  0x40daf1		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40daf2		48034850		ADDQ 0x50(AX), CX	
	return s.markBitsForIndex(objIndex)
  0x40daf6		48894c2410		MOVQ CX, 0x10(SP)	
	return b.bytep(n / 8), 1 << (n % 8)
  0x40dafb		4889d1			MOVQ DX, CX		
  0x40dafe		4883e107		ANDQ $0x7, CX		
  0x40db02		b801000000		MOVL $0x1, AX		
  0x40db07		d3e0			SHLL CL, AX		
	return s.markBitsForIndex(objIndex)
  0x40db09		88442418		MOVB AL, 0x18(SP)	
  0x40db0d		4889542420		MOVQ DX, 0x20(SP)	
  0x40db12		c3			RET			
	if s.baseMask != 0 {
  0x40db13		6683785e00		CMPW $0x0, 0x5e(AX)	
  0x40db18		7415			JE 0x40db2f		
		return byteOffset >> s.divShift
  0x40db1a		0fb64865		MOVZX 0x65(AX), CX	
  0x40db1e		80f940			CMPL $0x40, CL		
  0x40db21		4819db			SBBQ BX, BX		
  0x40db24		48d3ea			SHRQ CL, DX		
  0x40db27		4821da			ANDQ BX, DX		
	objIndex := s.objIndex(p)
  0x40db2a		4889d1			MOVQ DX, CX		
  0x40db2d		ebb8			JMP 0x40dae7		
	return uintptr(((uint64(byteOffset) >> s.divShift) * uint64(s.divMul)) >> s.divShift2)
  0x40db2f		0fb64865		MOVZX 0x65(AX), CX	
  0x40db33		80f940			CMPL $0x40, CL		
  0x40db36		4819db			SBBQ BX, BX		
  0x40db39		0fb67066		MOVZX 0x66(AX), SI	
  0x40db3d		4080fe40		CMPL $0x40, SI		
  0x40db41		4819ff			SBBQ DI, DI		
  0x40db44		48d3ea			SHRQ CL, DX		
  0x40db47		4821da			ANDQ BX, DX		
  0x40db4a		0fb7485c		MOVZX 0x5c(AX), CX	
  0x40db4e		480fafca		IMULQ DX, CX		
  0x40db52		4889ca			MOVQ CX, DX		
  0x40db55		89f1			MOVL SI, CX		
  0x40db57		48d3ea			SHRQ CL, DX		
  0x40db5a		4821fa			ANDQ DI, DX		
	objIndex := s.objIndex(p)
  0x40db5d		4889d1			MOVQ DX, CX		
  0x40db60		eb85			JMP 0x40dae7		
	l2 := mheap_.arenas[ri.l1()]
  0x40db62		488b1de78d0b00		MOVQ runtime.mheap_+784(SB), BX	
	ha := l2[ri.l2()]
  0x40db69		8403			TESTB AL, 0(BX)		
	l2 := mheap_.arenas[ri.l1()]
  0x40db6b		90			NOPL			
	ha := l2[ri.l2()]
  0x40db6c		488b04c3		MOVQ 0(BX)(AX*8), AX	
  0x40db70		90			NOPL			
	if ha == nil {
  0x40db71		4885c0			TESTQ AX, AX		
  0x40db74		741e			JE 0x40db94		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x40db76		4889d3			MOVQ DX, BX			
  0x40db79		48c1ea0d		SHRQ $0xd, DX			
  0x40db7d		4881e2ff1f0000		ANDQ $0x1fff, DX		
  0x40db84		488b84d000002000	MOVQ 0x200000(AX)(DX*8), AX	
	byteOffset := p - s.base()
  0x40db8c		4889da			MOVQ BX, DX		
	s := spanOf(p)
  0x40db8f		e943ffffff		JMP 0x40dad7		
  0x40db94		31c0			XORL AX, AX		
  0x40db96		e93cffffff		JMP 0x40dad7		

TEXT runtime.findObject(SB) /usr/local/go/src/runtime/mbitmap.go
func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr) {
  0x40dba0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40dba9		483b6110		CMPQ 0x10(CX), SP	
  0x40dbad		0f86ac030000		JBE 0x40df5f		
  0x40dbb3		4883ec48		SUBQ $0x48, SP		
  0x40dbb7		48896c2440		MOVQ BP, 0x40(SP)	
  0x40dbbc		488d6c2440		LEAQ 0x40(SP), BP	
	s = spanOf(p)
  0x40dbc1		90			NOPL			
	ri := arenaIndex(p)
  0x40dbc2		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40dbc3		90			NOPL			
	s = spanOf(p)
  0x40dbc4		488b442450		MOVQ 0x50(SP), AX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40dbc9		48ba0000000000800000	MOVQ $0x800000000000, DX	
  0x40dbd3		4801c2			ADDQ AX, DX			
  0x40dbd6		48c1ea1a		SHRQ $0x1a, DX			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40dbda		4881fa00004000		CMPQ $0x400000, DX	
  0x40dbe1		0f8211030000		JB 0x40def8		
  0x40dbe7		31c9			XORL CX, CX		
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40dbe9		4885c9			TESTQ CX, CX		
  0x40dbec		7411			JE 0x40dbff		
  0x40dbee		90			NOPL			
	return s.startAddr
  0x40dbef		488b5118		MOVQ 0x18(CX), DX	
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40dbf3		4839d0			CMPQ DX, AX		
  0x40dbf6		0f8341020000		JAE 0x40de3d		
  0x40dbfc		4885c9			TESTQ CX, CX		
		if s == nil || s.state == mSpanManual {
  0x40dbff		7406			JE 0x40dc07		
  0x40dc01		80796302		CMPB $0x2, 0x63(CX)	
  0x40dc05		7521			JNE 0x40dc28		
			return
  0x40dc07		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x40dc10		48894c2470		MOVQ CX, 0x70(SP)	
  0x40dc15		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x40dc1e		488b6c2440		MOVQ 0x40(SP), BP	
  0x40dc23		4883c448		ADDQ $0x48, SP		
  0x40dc27		c3			RET			
		if debug.invalidptr != 0 {
  0x40dc28		833dd5f20c0000		CMPL $0x0, runtime.debug+36(SB)	
  0x40dc2f		7521			JNE 0x40dc52			
		return
  0x40dc31		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x40dc3a		48894c2470		MOVQ CX, 0x70(SP)	
  0x40dc3f		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x40dc48		488b6c2440		MOVQ 0x40(SP), BP	
  0x40dc4d		4883c448		ADDQ $0x48, SP		
  0x40dc51		c3			RET			
	s = spanOf(p)
  0x40dc52		48894c2438		MOVQ CX, 0x38(SP)	
			printlock()
  0x40dc57		e864620100		CALL runtime.printlock(SB)	
			print("runtime: pointer ", hex(p))
  0x40dc5c		e85f620100		CALL runtime.printlock(SB)	
  0x40dc61		488d058f250600		LEAQ 0x6258f(IP), AX		
  0x40dc68		48890424		MOVQ AX, 0(SP)			
  0x40dc6c		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x40dc75		e8766b0100		CALL runtime.printstring(SB)	
  0x40dc7a		488b442450		MOVQ 0x50(SP), AX		
  0x40dc7f		48890424		MOVQ AX, 0(SP)			
  0x40dc83		e8286a0100		CALL runtime.printhex(SB)	
  0x40dc88		e8b3620100		CALL runtime.printunlock(SB)	
			if s.state != mSpanInUse {
  0x40dc8d		488b442438		MOVQ 0x38(SP), AX	
  0x40dc92		80786301		CMPB $0x1, 0x63(AX)	
  0x40dc96		0f8479010000		JE 0x40de15		
				print(" to unallocated span")
  0x40dc9c		e81f620100		CALL runtime.printlock(SB)	
  0x40dca1		488d05b1280600		LEAQ 0x628b1(IP), AX		
  0x40dca8		48890424		MOVQ AX, 0(SP)			
  0x40dcac		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x40dcb5		e8366b0100		CALL runtime.printstring(SB)	
  0x40dcba		e881620100		CALL runtime.printunlock(SB)	
			print(" span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", s.state, "\n")
  0x40dcbf		90			NOPL			
  0x40dcc0		488b442438		MOVQ 0x38(SP), AX	
  0x40dcc5		488b4878		MOVQ 0x78(AX), CX	
  0x40dcc9		48894c2430		MOVQ CX, 0x30(SP)	
  0x40dcce		0fb65063		MOVZX 0x63(AX), DX	
  0x40dcd2		4889542428		MOVQ DX, 0x28(SP)	
	return s.startAddr
  0x40dcd7		488b4018		MOVQ 0x18(AX), AX	
  0x40dcdb		4889442420		MOVQ AX, 0x20(SP)	
			print(" span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", s.state, "\n")
  0x40dce0		e8db610100		CALL runtime.printlock(SB)	
  0x40dce5		488d05f91e0600		LEAQ 0x61ef9(IP), AX		
  0x40dcec		48890424		MOVQ AX, 0(SP)			
  0x40dcf0		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x40dcf9		e8f26a0100		CALL runtime.printstring(SB)	
  0x40dcfe		488b442420		MOVQ 0x20(SP), AX		
  0x40dd03		48890424		MOVQ AX, 0(SP)			
  0x40dd07		e8a4690100		CALL runtime.printhex(SB)	
  0x40dd0c		488d05fe1c0600		LEAQ 0x61cfe(IP), AX		
  0x40dd13		48890424		MOVQ AX, 0(SP)			
  0x40dd17		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x40dd20		e8cb6a0100		CALL runtime.printstring(SB)	
  0x40dd25		488b442430		MOVQ 0x30(SP), AX		
  0x40dd2a		48890424		MOVQ AX, 0(SP)			
  0x40dd2e		e87d690100		CALL runtime.printhex(SB)	
  0x40dd33		488d05e31c0600		LEAQ 0x61ce3(IP), AX		
  0x40dd3a		48890424		MOVQ AX, 0(SP)			
  0x40dd3e		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x40dd47		e8a46a0100		CALL runtime.printstring(SB)	
  0x40dd4c		488b442428		MOVQ 0x28(SP), AX		
  0x40dd51		48890424		MOVQ AX, 0(SP)			
  0x40dd55		e8e6670100		CALL runtime.printuint(SB)	
  0x40dd5a		e8f1630100		CALL runtime.printnl(SB)	
  0x40dd5f		e8dc610100		CALL runtime.printunlock(SB)	
			if refBase != 0 {
  0x40dd64		488b442458		MOVQ 0x58(SP), AX	
  0x40dd69		4885c0			TESTQ AX, AX		
  0x40dd6c		0f84be010000		JE 0x40df30		
				print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n")
  0x40dd72		e849610100		CALL runtime.printlock(SB)	
  0x40dd77		488d05e63e0600		LEAQ 0x63ee6(IP), AX		
  0x40dd7e		48890424		MOVQ AX, 0(SP)			
  0x40dd82		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x40dd8b		e8606a0100		CALL runtime.printstring(SB)	
  0x40dd90		488b442458		MOVQ 0x58(SP), AX		
  0x40dd95		48890424		MOVQ AX, 0(SP)			
  0x40dd99		e812690100		CALL runtime.printhex(SB)	
  0x40dd9e		488d05de120600		LEAQ 0x612de(IP), AX		
  0x40dda5		48890424		MOVQ AX, 0(SP)			
  0x40dda9		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x40ddb2		e8396a0100		CALL runtime.printstring(SB)	
  0x40ddb7		488b442460		MOVQ 0x60(SP), AX		
  0x40ddbc		48890424		MOVQ AX, 0(SP)			
  0x40ddc0		e8eb680100		CALL runtime.printhex(SB)	
  0x40ddc5		488d05ce120600		LEAQ 0x612ce(IP), AX		
  0x40ddcc		48890424		MOVQ AX, 0(SP)			
  0x40ddd0		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x40ddd9		e8126a0100		CALL runtime.printstring(SB)	
  0x40ddde		e85d610100		CALL runtime.printunlock(SB)	
				gcDumpObject("object", refBase, refOff)
  0x40dde3		488d05a2140600		LEAQ 0x614a2(IP), AX		
  0x40ddea		48890424		MOVQ AX, 0(SP)			
  0x40ddee		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x40ddf7		488b442458		MOVQ 0x58(SP), AX		
  0x40ddfc		4889442410		MOVQ AX, 0x10(SP)		
  0x40de01		488b442460		MOVQ 0x60(SP), AX		
  0x40de06		4889442418		MOVQ AX, 0x18(SP)		
  0x40de0b		e870b40000		CALL runtime.gcDumpObject(SB)	
  0x40de10		e91b010000		JMP 0x40df30			
				print(" to unused region of span")
  0x40de15		e8a6600100		CALL runtime.printlock(SB)	
  0x40de1a		488d0549310600		LEAQ 0x63149(IP), AX		
  0x40de21		48890424		MOVQ AX, 0(SP)			
  0x40de25		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x40de2e		e8bd690100		CALL runtime.printstring(SB)	
  0x40de33		e808610100		CALL runtime.printunlock(SB)	
  0x40de38		e982feffff		JMP 0x40dcbf			
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40de3d		48394178		CMPQ AX, 0x78(CX)	
  0x40de41		7708			JA 0x40de4b		
  0x40de43		4885c9			TESTQ CX, CX		
  0x40de46		e9b4fdffff		JMP 0x40dbff		
  0x40de4b		80796301		CMPB $0x1, 0x63(CX)	
  0x40de4f		7408			JE 0x40de59		
  0x40de51		4885c9			TESTQ CX, CX		
  0x40de54		e9a6fdffff		JMP 0x40dbff		
	if s.baseMask != 0 {
  0x40de59		0fb7595e		MOVZX 0x5e(CX), BX	
  0x40de5d		6685db			TESTW BX, BX		
  0x40de60		743b			JE 0x40de9d		
		objIndex = (base - s.base()) >> s.divShift
  0x40de62		0fb67165		MOVZX 0x65(CX), SI	
  0x40de66		4080fe40		CMPL $0x40, SI		
  0x40de6a		4819ff			SBBQ DI, DI		
		base = s.base()
  0x40de6d		90			NOPL			
		base = base + (p-base)&uintptr(s.baseMask)
  0x40de6e		4829d0			SUBQ DX, AX		
  0x40de71		4821c3			ANDQ AX, BX		
  0x40de74		488d0413		LEAQ 0(BX)(DX*1), AX	
		objIndex = (base - s.base()) >> s.divShift
  0x40de78		90			NOPL			
	s = spanOf(p)
  0x40de79		4889ca			MOVQ CX, DX		
		objIndex = (base - s.base()) >> s.divShift
  0x40de7c		89f1			MOVL SI, CX		
  0x40de7e		48d3eb			SHRQ CL, BX		
  0x40de81		4821fb			ANDQ DI, BX		
	return
  0x40de84		4889442468		MOVQ AX, 0x68(SP)	
  0x40de89		4889542470		MOVQ DX, 0x70(SP)	
  0x40de8e		48895c2478		MOVQ BX, 0x78(SP)	
  0x40de93		488b6c2440		MOVQ 0x40(SP), BP	
  0x40de98		4883c448		ADDQ $0x48, SP		
  0x40de9c		c3			RET			
		base = s.base()
  0x40de9d		90			NOPL			
		if p-base >= s.elemsize {
  0x40de9e		4829d0			SUBQ DX, AX		
  0x40dea1		488b5968		MOVQ 0x68(CX), BX	
  0x40dea5		4839d8			CMPQ BX, AX		
  0x40dea8		7244			JB 0x40deee		
			objIndex = uintptr(p-base) >> s.divShift * uintptr(s.divMul) >> s.divShift2
  0x40deaa		0fb67165		MOVZX 0x65(CX), SI	
  0x40deae		4080fe40		CMPL $0x40, SI		
  0x40deb2		4819ff			SBBQ DI, DI		
  0x40deb5		440fb64166		MOVZX 0x66(CX), R8	
  0x40deba		4180f840		CMPL $0x40, R8		
  0x40debe		4d19c9			SBBQ R9, R9		
	s = spanOf(p)
  0x40dec1		4989ca			MOVQ CX, R10		
			objIndex = uintptr(p-base) >> s.divShift * uintptr(s.divMul) >> s.divShift2
  0x40dec4		89f1			MOVL SI, CX		
  0x40dec6		48d3e8			SHRQ CL, AX		
  0x40dec9		4821f8			ANDQ DI, AX		
  0x40decc		410fb7725c		MOVZX 0x5c(R10), SI	
  0x40ded1		480faff0		IMULQ AX, SI		
  0x40ded5		4489c1			MOVL R8, CX		
  0x40ded8		48d3ee			SHRQ CL, SI		
  0x40dedb		4c21ce			ANDQ R9, SI		
			base += objIndex * s.elemsize
  0x40dede		480fafde		IMULQ SI, BX		
  0x40dee2		488d0413		LEAQ 0(BX)(DX*1), AX	
	return
  0x40dee6		4c89d2			MOVQ R10, DX		
  0x40dee9		4889f3			MOVQ SI, BX		
  0x40deec		eb96			JMP 0x40de84		
  0x40deee		4989ca			MOVQ CX, R10		
  0x40def1		31f6			XORL SI, SI		
  0x40def3		4889d0			MOVQ DX, AX		
		if p-base >= s.elemsize {
  0x40def6		ebee			JMP 0x40dee6		
	l2 := mheap_.arenas[ri.l1()]
  0x40def8		488b1d518a0b00		MOVQ runtime.mheap_+784(SB), BX	
	ha := l2[ri.l2()]
  0x40deff		8403			TESTB AL, 0(BX)		
	l2 := mheap_.arenas[ri.l1()]
  0x40df01		90			NOPL			
	ha := l2[ri.l2()]
  0x40df02		488b14d3		MOVQ 0(BX)(DX*8), DX	
  0x40df06		90			NOPL			
	if ha == nil {
  0x40df07		4885d2			TESTQ DX, DX		
  0x40df0a		741d			JE 0x40df29		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x40df0c		4889c3			MOVQ AX, BX			
  0x40df0f		48c1e80d		SHRQ $0xd, AX			
  0x40df13		4825ff1f0000		ANDQ $0x1fff, AX		
  0x40df19		488b8cc200002000	MOVQ 0x200000(DX)(AX*8), CX	
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x40df21		4889d8			MOVQ BX, AX		
	s = spanOf(p)
  0x40df24		e9c0fcffff		JMP 0x40dbe9		
  0x40df29		31c9			XORL CX, CX		
  0x40df2b		e9b9fcffff		JMP 0x40dbe9		
			getg().m.traceback = 2
  0x40df30		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40df39		488b4030		MOVQ 0x30(AX), AX	
  0x40df3d		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)")
  0x40df44		488d0560560600		LEAQ 0x65660(IP), AX	
  0x40df4b		48890424		MOVQ AX, 0(SP)		
  0x40df4f		48c74424083e000000	MOVQ $0x3e, 0x8(SP)	
  0x40df58		e823550100		CALL runtime.throw(SB)	
  0x40df5d		0f0b			UD2			
func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr) {
  0x40df5f		e81c990300		CALL runtime.morestack_noctxt(SB)	
  0x40df64		e937fcffff		JMP runtime.findObject(SB)		

TEXT runtime.heapBits.nextArena(SB) /usr/local/go/src/runtime/mbitmap.go
	l2 := mheap_.arenas[ai.l1()]
  0x40df70		488b05d9890b00		MOVQ runtime.mheap_+784(SB), AX	
  0x40df77		90			NOPL				
	if l2 == nil {
  0x40df78		4885c0			TESTQ AX, AX		
  0x40df7b		7448			JE 0x40dfc5		
	h.arena++
  0x40df7d		8b4c2414		MOVL 0x14(SP), CX	
  0x40df81		ffc1			INCL CX			
	ha := l2[ai.l2()]
  0x40df83		90			NOPL			
  0x40df84		4881f900004000		CMPQ $0x400000, CX	
  0x40df8b		734a			JAE 0x40dfd7		
  0x40df8d		488b04c8		MOVQ 0(AX)(CX*8), AX	
	if ha == nil {
  0x40df91		4885c0			TESTQ AX, AX		
  0x40df94		741d			JE 0x40dfb3		
	return h
  0x40df96		4889442420		MOVQ AX, 0x20(SP)	
  0x40df9b		c744242800000000	MOVL $0x0, 0x28(SP)	
  0x40dfa3		894c242c		MOVL CX, 0x2c(SP)	
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40dfa7		4805ffff1f00		ADDQ $0x1fffff, AX	
	return h
  0x40dfad		4889442430		MOVQ AX, 0x30(SP)	
  0x40dfb2		c3			RET			
		return heapBits{}
  0x40dfb3		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x40dfbc		0f57c0			XORPS X0, X0		
  0x40dfbf		0f11442428		MOVUPS X0, 0x28(SP)	
  0x40dfc4		c3			RET			
		return heapBits{}
  0x40dfc5		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x40dfce		0f57c0			XORPS X0, X0		
  0x40dfd1		0f11442428		MOVUPS X0, 0x28(SP)	
  0x40dfd6		c3			RET			
	ha := l2[ai.l2()]
  0x40dfd7		e8443f0100		CALL runtime.panicindex(SB)	
  0x40dfdc		0f0b			UD2				

TEXT runtime.heapBits.forward(SB) /usr/local/go/src/runtime/mbitmap.go
	n += uintptr(h.shift) / heapBitsShift
  0x40dfe0		488b442420		MOVQ 0x20(SP), AX	
  0x40dfe5		8b4c2410		MOVL 0x10(SP), CX	
  0x40dfe9		4801c8			ADDQ CX, AX		
	nbitp := uintptr(unsafe.Pointer(h.bitp)) + n/4
  0x40dfec		488b4c2408		MOVQ 0x8(SP), CX	
  0x40dff1		4889ca			MOVQ CX, DX		
  0x40dff4		4889c3			MOVQ AX, BX		
  0x40dff7		48c1e802		SHRQ $0x2, AX		
  0x40dffb		4801c1			ADDQ AX, CX		
	h.shift = uint32(n%4) * heapBitsShift
  0x40dffe		4883e303		ANDQ $0x3, BX		
	if nbitp <= uintptr(unsafe.Pointer(h.last)) {
  0x40e002		488b742418		MOVQ 0x18(SP), SI	
  0x40e007		4889f7			MOVQ SI, DI		
  0x40e00a		4839f1			CMPQ SI, CX		
  0x40e00d		7662			JBE 0x40e071		
	past := nbitp - (uintptr(unsafe.Pointer(h.last)) + 1)
  0x40e00f		488d4601		LEAQ 0x1(SI), AX	
  0x40e013		4829c1			SUBQ AX, CX		
	h.arena += 1 + uint32(past/heapArenaBitmapBytes)
  0x40e016		4889c8			MOVQ CX, AX		
  0x40e019		48c1e915		SHRQ $0x15, CX		
  0x40e01d		8b542414		MOVL 0x14(SP), DX	
  0x40e021		8d0c0a			LEAL 0(DX)(CX*1), CX	
  0x40e024		8d4901			LEAL 0x1(CX), CX	
	if l2 := mheap_.arenas[ai.l1()]; l2 != nil && l2[ai.l2()] != nil {
  0x40e027		488b1522890b00		MOVQ runtime.mheap_+784(SB), DX	
  0x40e02e		90			NOPL				
  0x40e02f		4885d2			TESTQ DX, DX			
  0x40e032		7437			JE 0x40e06b			
  0x40e034		90			NOPL				
  0x40e035		4881f900004000		CMPQ $0x400000, CX		
  0x40e03c		734d			JAE 0x40e08b			
  0x40e03e		488b14ca		MOVQ 0(DX)(CX*8), DX		
  0x40e042		4885d2			TESTQ DX, DX			
  0x40e045		7424			JE 0x40e06b			
		a := l2[ai.l2()]
  0x40e047		90			NOPL			
		h.bitp = &a.bitmap[past%heapArenaBitmapBytes]
  0x40e048		4825ffff1f00		ANDQ $0x1fffff, AX	
  0x40e04e		4801d0			ADDQ DX, AX		
		h.last = &a.bitmap[len(a.bitmap)-1]
  0x40e051		4881c2ffff1f00		ADDQ $0x1fffff, DX	
	return h
  0x40e058		4889442428		MOVQ AX, 0x28(SP)	
  0x40e05d		895c2430		MOVL BX, 0x30(SP)	
  0x40e061		894c2434		MOVL CX, 0x34(SP)	
  0x40e065		4889542438		MOVQ DX, 0x38(SP)	
  0x40e06a		c3			RET			
  0x40e06b		31d2			XORL DX, DX		
  0x40e06d		31c0			XORL AX, AX		
		h.bitp, h.last = nil, nil
  0x40e06f		ebe7			JMP 0x40e058		
		h.bitp = (*uint8)(unsafe.Pointer(nbitp))
  0x40e071		4801d0			ADDQ DX, AX		
		return h
  0x40e074		4889442428		MOVQ AX, 0x28(SP)	
  0x40e079		895c2430		MOVL BX, 0x30(SP)	
  0x40e07d		8b442414		MOVL 0x14(SP), AX	
  0x40e081		89442434		MOVL AX, 0x34(SP)	
  0x40e085		48897c2438		MOVQ DI, 0x38(SP)	
  0x40e08a		c3			RET			
	if l2 := mheap_.arenas[ai.l1()]; l2 != nil && l2[ai.l2()] != nil {
  0x40e08b		e8903e0100		CALL runtime.panicindex(SB)	
  0x40e090		0f0b			UD2				

TEXT runtime.heapBits.forwardOrBoundary(SB) /usr/local/go/src/runtime/mbitmap.go
func (h heapBits) forwardOrBoundary(n uintptr) (heapBits, uintptr) {
  0x40e0a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40e0a9		483b6110		CMPQ 0x10(CX), SP	
  0x40e0ad		0f8697000000		JBE 0x40e14a		
  0x40e0b3		4883ec40		SUBQ $0x40, SP		
  0x40e0b7		48896c2438		MOVQ BP, 0x38(SP)	
  0x40e0bc		488d6c2438		LEAQ 0x38(SP), BP	
	maxn := 4 * ((uintptr(unsafe.Pointer(h.last)) + 1) - uintptr(unsafe.Pointer(h.bitp)))
  0x40e0c1		488b442458		MOVQ 0x58(SP), AX	
  0x40e0c6		4889c1			MOVQ AX, CX		
  0x40e0c9		488b542448		MOVQ 0x48(SP), DX	
  0x40e0ce		4889d3			MOVQ DX, BX		
	return h.forward(n), n
  0x40e0d1		48891c24		MOVQ BX, 0(SP)		
  0x40e0d5		8b5c2450		MOVL 0x50(SP), BX	
  0x40e0d9		895c2408		MOVL BX, 0x8(SP)	
  0x40e0dd		8b5c2454		MOVL 0x54(SP), BX	
  0x40e0e1		895c240c		MOVL BX, 0xc(SP)	
  0x40e0e5		48894c2410		MOVQ CX, 0x10(SP)	
	maxn := 4 * ((uintptr(unsafe.Pointer(h.last)) + 1) - uintptr(unsafe.Pointer(h.bitp)))
  0x40e0ea		48ffc0			INCQ AX			
  0x40e0ed		4829d0			SUBQ DX, AX		
  0x40e0f0		48c1e002		SHLQ $0x2, AX		
	if n > maxn {
  0x40e0f4		488b4c2460		MOVQ 0x60(SP), CX	
  0x40e0f9		4839c1			CMPQ AX, CX		
	return h.forward(n), n
  0x40e0fc		480f47c8		CMOVA AX, CX				
  0x40e100		48894c2460		MOVQ CX, 0x60(SP)			
  0x40e105		48894c2418		MOVQ CX, 0x18(SP)			
  0x40e10a		e8d1feffff		CALL runtime.heapBits.forward(SB)	
  0x40e10f		488b442420		MOVQ 0x20(SP), AX			
  0x40e114		8b4c2428		MOVL 0x28(SP), CX			
  0x40e118		8b54242c		MOVL 0x2c(SP), DX			
  0x40e11c		488b5c2430		MOVQ 0x30(SP), BX			
  0x40e121		4889442468		MOVQ AX, 0x68(SP)			
  0x40e126		894c2470		MOVL CX, 0x70(SP)			
  0x40e12a		89542474		MOVL DX, 0x74(SP)			
  0x40e12e		48895c2478		MOVQ BX, 0x78(SP)			
  0x40e133		488b442460		MOVQ 0x60(SP), AX			
  0x40e138		4889842480000000	MOVQ AX, 0x80(SP)			
	if n > maxn {
  0x40e140		488b6c2438		MOVQ 0x38(SP), BP	
  0x40e145		4883c440		ADDQ $0x40, SP		
  0x40e149		c3			RET			
func (h heapBits) forwardOrBoundary(n uintptr) (heapBits, uintptr) {
  0x40e14a		e831970300		CALL runtime.morestack_noctxt(SB)		
  0x40e14f		e94cffffff		JMP runtime.heapBits.forwardOrBoundary(SB)	

TEXT runtime.bulkBarrierPreWrite(SB) /usr/local/go/src/runtime/mbitmap.go
func bulkBarrierPreWrite(dst, src, size uintptr) {
  0x40e160		4881ec80000000		SUBQ $0x80, SP		
  0x40e167		48896c2478		MOVQ BP, 0x78(SP)	
  0x40e16c		488d6c2478		LEAQ 0x78(SP), BP	
	if (dst|src|size)&(sys.PtrSize-1) != 0 {
  0x40e171		488b842490000000	MOVQ 0x90(SP), AX	
  0x40e179		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x40e181		4889c2			MOVQ AX, DX		
  0x40e184		4809c8			ORQ CX, AX		
  0x40e187		488b9c2498000000	MOVQ 0x98(SP), BX	
  0x40e18f		4809d8			ORQ BX, AX		
  0x40e192		48a907000000		TESTQ $0x7, AX		
  0x40e198		0f8561040000		JNE 0x40e5ff		
	if !writeBarrier.needed {
  0x40e19e		803d7fec0c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x40e1a5		0f8440040000		JE 0x40e5eb				
	if s := spanOf(dst); s == nil {
  0x40e1ab		90			NOPL			
	ri := arenaIndex(p)
  0x40e1ac		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40e1ad		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40e1ae		48b80000000000800000	MOVQ $0x800000000000, AX	
  0x40e1b8		4801c8			ADDQ CX, AX			
  0x40e1bb		48c1e81a		SHRQ $0x1a, AX			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40e1bf		483d00004000		CMPQ $0x400000, AX	
  0x40e1c5		0f82e7030000		JB 0x40e5b2		
  0x40e1cb		31f6			XORL SI, SI		
	if s := spanOf(dst); s == nil {
  0x40e1cd		4885f6			TESTQ SI, SI		
  0x40e1d0		0f84e2020000		JE 0x40e4b8		
	} else if s.state != mSpanInUse || dst < s.base() || s.limit <= dst {
  0x40e1d6		807e6301		CMPB $0x1, 0x63(SI)	
  0x40e1da		0f85cb020000		JNE 0x40e4ab		
  0x40e1e0		90			NOPL			
	return s.startAddr
  0x40e1e1		48394e18		CMPQ CX, 0x18(SI)	
	} else if s.state != mSpanInUse || dst < s.base() || s.limit <= dst {
  0x40e1e5		0f87c0020000		JA 0x40e4ab		
  0x40e1eb		48394e78		CMPQ CX, 0x78(SI)	
  0x40e1ef		0f86b6020000		JBE 0x40e4ab		
	buf := &getg().m.p.ptr().wbBuf
  0x40e1f5		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x40e1fe		488b7630		MOVQ 0x30(SI), SI	
  0x40e202		488bbed0000000		MOVQ 0xd0(SI), DI	
  0x40e209		8407			TESTB AL, 0(DI)		
  0x40e20b		8406			TESTB AL, 0(SI)		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e20d		488b353c870b00		MOVQ runtime.mheap_+784(SB), SI	
  0x40e214		8406			TESTB AL, 0(SI)			
	buf := &getg().m.p.ptr().wbBuf
  0x40e216		90			NOPL			
	h := heapBitsForAddr(dst)
  0x40e217		90			NOPL			
	arena := arenaIndex(addr)
  0x40e218		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e219		90			NOPL			
  0x40e21a		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x40e21b		483d00004000		CMPQ $0x400000, AX	
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e221		0f83d1030000		JAE 0x40e5f8		
  0x40e227		488b34c6		MOVQ 0(SI)(AX*8), SI	
	if ha == nil {
  0x40e22b		4885f6			TESTQ SI, SI		
  0x40e22e		0f8466020000		JE 0x40e49a		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40e234		4989c8			MOVQ CX, R8		
  0x40e237		48c1e905		SHRQ $0x5, CX		
  0x40e23b		4881e1ffff1f00		ANDQ $0x1fffff, CX	
  0x40e242		4801f1			ADDQ SI, CX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x40e245		4d89c1			MOVQ R8, R9		
  0x40e248		49c1e803		SHRQ $0x3, R8		
  0x40e24c		4983e003		ANDQ $0x3, R8		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40e250		4881c6ffff1f00		ADDQ $0x1fffff, SI	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40e257		48897c2470		MOVQ DI, 0x70(SP)	
	if src == 0 {
  0x40e25c		4885d2			TESTQ DX, DX		
  0x40e25f		0f8518010000		JNE 0x40e37d		
  0x40e265		31d2			XORL DX, DX		
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e267		eb04			JMP 0x40e26d		
  0x40e269		4883c208		ADDQ $0x8, DX		
  0x40e26d		4839da			CMPQ BX, DX		
  0x40e270		0f83fa000000		JAE 0x40e370		
  0x40e276		4889542440		MOVQ DX, 0x40(SP)	
			if h.isPointer() {
  0x40e27b		90			NOPL			
	return h.bits()&bitPointer != 0
  0x40e27c		90			NOPL			
	return uint32(*h.bitp) >> (h.shift & 31)
  0x40e27d		440fb611		MOVZX 0(CX), R10	
	return h.bits()&bitPointer != 0
  0x40e281		450fa3c2		BTL R8, R10		
			if h.isPointer() {
  0x40e285		7335			JAE 0x40e2bc		
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e287		4e8d140a		LEAQ 0(DX)(R9*1), R10	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e28b		4c8b9f20130000		MOVQ 0x1320(DI), R11	
				if !buf.putFast(*dstx, 0) {
  0x40e292		90			NOPL			
  0x40e293		4d8b12			MOVQ 0(R10), R10	
	p[0] = old
  0x40e296		4d8913			MOVQ R10, 0(R11)	
	p[1] = new
  0x40e299		49c7430800000000	MOVQ $0x0, 0x8(R11)	
	b.next += 2 * sys.PtrSize
  0x40e2a1		4c8b9720130000		MOVQ 0x1320(DI), R10	
  0x40e2a8		4983c210		ADDQ $0x10, R10		
  0x40e2ac		4c899720130000		MOVQ R10, 0x1320(DI)	
	return b.next != b.end
  0x40e2b3		4c399728130000		CMPQ R10, 0x1328(DI)	
				if !buf.putFast(*dstx, 0) {
  0x40e2ba		7463			JE 0x40e31f		
			h = h.next()
  0x40e2bc		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x40e2bd		4183f803		CMPL $0x3, R8		
  0x40e2c1		7305			JAE 0x40e2c8		
		h.shift += heapBitsShift
  0x40e2c3		41ffc0			INCL R8			
  0x40e2c6		eba1			JMP 0x40e269		
	} else if h.bitp != h.last {
  0x40e2c8		4839f1			CMPQ SI, CX		
  0x40e2cb		7409			JE 0x40e2d6		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40e2cd		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e2ce		48ffc1			INCQ CX			
  0x40e2d1		4531c0			XORL R8, R8		
			h = h.next()
  0x40e2d4		eb93			JMP 0x40e269		
		return h.nextArena()
  0x40e2d6		48890c24		MOVQ CX, 0(SP)				
  0x40e2da		4489442408		MOVL R8, 0x8(SP)			
  0x40e2df		8944240c		MOVL AX, 0xc(SP)			
  0x40e2e3		4889742410		MOVQ SI, 0x10(SP)			
  0x40e2e8		e883fcffff		CALL runtime.heapBits.nextArena(SB)	
  0x40e2ed		8b442424		MOVL 0x24(SP), AX			
  0x40e2f1		448b442420		MOVL 0x20(SP), R8			
  0x40e2f6		488b4c2418		MOVQ 0x18(SP), CX			
  0x40e2fb		488b742428		MOVQ 0x28(SP), SI			
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e300		488b542440		MOVQ 0x40(SP), DX	
  0x40e305		488b9c2498000000	MOVQ 0x98(SP), BX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e30d		488b7c2470		MOVQ 0x70(SP), DI	
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e312		4c8b8c2488000000	MOVQ 0x88(SP), R9	
			h = h.next()
  0x40e31a		e94affffff		JMP 0x40e269		
			if h.isPointer() {
  0x40e31f		4889742458		MOVQ SI, 0x58(SP)	
  0x40e324		89442438		MOVL AX, 0x38(SP)	
  0x40e328		4489442430		MOVL R8, 0x30(SP)	
  0x40e32d		48894c2468		MOVQ CX, 0x68(SP)	
					wbBufFlush(nil, 0)
  0x40e332		0f57c0			XORPS X0, X0			
  0x40e335		0f110424		MOVUPS X0, 0(SP)		
  0x40e339		e8c2280100		CALL runtime.wbBufFlush(SB)	
			h = h.next()
  0x40e33e		8b442438		MOVL 0x38(SP), AX	
	} else if h.bitp != h.last {
  0x40e342		488b4c2468		MOVQ 0x68(SP), CX	
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e347		488b542440		MOVQ 0x40(SP), DX	
  0x40e34c		488b9c2498000000	MOVQ 0x98(SP), BX	
	} else if h.bitp != h.last {
  0x40e354		488b742458		MOVQ 0x58(SP), SI	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e359		488b7c2470		MOVQ 0x70(SP), DI	
	if h.shift < 3*heapBitsShift {
  0x40e35e		448b442430		MOVL 0x30(SP), R8	
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e363		4c8b8c2488000000	MOVQ 0x88(SP), R9	
					wbBufFlush(nil, 0)
  0x40e36b		e94cffffff		JMP 0x40e2bc		
  0x40e370		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e375		4881c480000000		ADDQ $0x80, SP		
  0x40e37c		c3			RET			
  0x40e37d		4531d2			XORL R10, R10		
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e380		eb04			JMP 0x40e386		
  0x40e382		4983c208		ADDQ $0x8, R10		
  0x40e386		4939da			CMPQ BX, R10		
  0x40e389		73e5			JAE 0x40e370		
  0x40e38b		4c89542448		MOVQ R10, 0x48(SP)	
			if h.isPointer() {
  0x40e390		90			NOPL			
	return h.bits()&bitPointer != 0
  0x40e391		90			NOPL			
	return uint32(*h.bitp) >> (h.shift & 31)
  0x40e392		440fb619		MOVZX 0(CX), R11	
	return h.bits()&bitPointer != 0
  0x40e396		450fa3c3		BTL R8, R11		
			if h.isPointer() {
  0x40e39a		733a			JAE 0x40e3d6		
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e39c		4f8d1c0a		LEAQ 0(R10)(R9*1), R11	
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e3a0		4d8d2412		LEAQ 0(R10)(DX*1), R12	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e3a4		4c8baf20130000		MOVQ 0x1320(DI), R13	
				if !buf.putFast(*dstx, *srcx) {
  0x40e3ab		90			NOPL			
  0x40e3ac		4d8b1b			MOVQ 0(R11), R11	
  0x40e3af		4d8b2424		MOVQ 0(R12), R12	
	p[0] = old
  0x40e3b3		4d895d00		MOVQ R11, 0(R13)	
	p[1] = new
  0x40e3b7		4d896508		MOVQ R12, 0x8(R13)	
	b.next += 2 * sys.PtrSize
  0x40e3bb		4c8b9f20130000		MOVQ 0x1320(DI), R11	
  0x40e3c2		4983c310		ADDQ $0x10, R11		
  0x40e3c6		4c899f20130000		MOVQ R11, 0x1320(DI)	
	return b.next != b.end
  0x40e3cd		4c399f28130000		CMPQ R11, 0x1328(DI)	
				if !buf.putFast(*dstx, *srcx) {
  0x40e3d4		746b			JE 0x40e441		
			h = h.next()
  0x40e3d6		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x40e3d7		4183f803		CMPL $0x3, R8		
  0x40e3db		7305			JAE 0x40e3e2		
		h.shift += heapBitsShift
  0x40e3dd		41ffc0			INCL R8			
  0x40e3e0		eba0			JMP 0x40e382		
	} else if h.bitp != h.last {
  0x40e3e2		4839f1			CMPQ SI, CX		
  0x40e3e5		7409			JE 0x40e3f0		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40e3e7		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e3e8		48ffc1			INCQ CX			
  0x40e3eb		4531c0			XORL R8, R8		
			h = h.next()
  0x40e3ee		eb92			JMP 0x40e382		
		return h.nextArena()
  0x40e3f0		48890c24		MOVQ CX, 0(SP)				
  0x40e3f4		4489442408		MOVL R8, 0x8(SP)			
  0x40e3f9		8944240c		MOVL AX, 0xc(SP)			
  0x40e3fd		4889742410		MOVQ SI, 0x10(SP)			
  0x40e402		e869fbffff		CALL runtime.heapBits.nextArena(SB)	
  0x40e407		488b742428		MOVQ 0x28(SP), SI			
  0x40e40c		8b442424		MOVL 0x24(SP), AX			
  0x40e410		448b442420		MOVL 0x20(SP), R8			
  0x40e415		488b4c2418		MOVQ 0x18(SP), CX			
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e41a		488b942490000000	MOVQ 0x90(SP), DX	
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e422		488b9c2498000000	MOVQ 0x98(SP), BX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e42a		488b7c2470		MOVQ 0x70(SP), DI	
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e42f		4c8b8c2488000000	MOVQ 0x88(SP), R9	
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e437		4c8b542448		MOVQ 0x48(SP), R10	
			h = h.next()
  0x40e43c		e941ffffff		JMP 0x40e382		
			if h.isPointer() {
  0x40e441		4889742450		MOVQ SI, 0x50(SP)	
  0x40e446		4489442434		MOVL R8, 0x34(SP)	
  0x40e44b		48894c2460		MOVQ CX, 0x60(SP)	
  0x40e450		8944243c		MOVL AX, 0x3c(SP)	
					wbBufFlush(nil, 0)
  0x40e454		0f57c0			XORPS X0, X0			
  0x40e457		0f110424		MOVUPS X0, 0(SP)		
  0x40e45b		e8a0270100		CALL runtime.wbBufFlush(SB)	
			h = h.next()
  0x40e460		8b44243c		MOVL 0x3c(SP), AX	
	} else if h.bitp != h.last {
  0x40e464		488b4c2460		MOVQ 0x60(SP), CX	
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e469		488b942490000000	MOVQ 0x90(SP), DX	
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e471		488b9c2498000000	MOVQ 0x98(SP), BX	
	} else if h.bitp != h.last {
  0x40e479		488b742450		MOVQ 0x50(SP), SI	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e47e		488b7c2470		MOVQ 0x70(SP), DI	
	if h.shift < 3*heapBitsShift {
  0x40e483		448b442434		MOVL 0x34(SP), R8	
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e488		4c8b8c2488000000	MOVQ 0x88(SP), R9	
		for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e490		4c8b542448		MOVQ 0x48(SP), R10	
					wbBufFlush(nil, 0)
  0x40e495		e93cffffff		JMP 0x40e3d6		
				dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e49a		4989c9			MOVQ CX, R9		
  0x40e49d		31f6			XORL SI, SI		
  0x40e49f		31c0			XORL AX, AX		
  0x40e4a1		4531c0			XORL R8, R8		
  0x40e4a4		31c9			XORL CX, CX		
	h := heapBitsForAddr(dst)
  0x40e4a6		e9acfdffff		JMP 0x40e257		
		return
  0x40e4ab		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e4b0		4881c480000000		ADDQ $0x80, SP		
  0x40e4b7		c3			RET			
		for _, datap := range activeModules() {
  0x40e4b8		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x40e4b9		488b05b8340b00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x40e4c0		4885c0			TESTQ AX, AX		
  0x40e4c3		0f84e0000000		JE 0x40e5a9		
	return *p
  0x40e4c9		488b7008		MOVQ 0x8(AX), SI	
  0x40e4cd		488b00			MOVQ 0(AX), AX		
		for _, datap := range activeModules() {
  0x40e4d0		31ff			XORL DI, DI		
  0x40e4d2		eb03			JMP 0x40e4d7		
  0x40e4d4		48ffc7			INCQ DI			
  0x40e4d7		4839f7			CMPQ SI, DI		
  0x40e4da		7d4d			JGE 0x40e529		
  0x40e4dc		4c8b04f8		MOVQ 0(AX)(DI*8), R8	
			if datap.data <= dst && dst < datap.edata {
  0x40e4e0		4d8b8880000000		MOVQ 0x80(R8), R9	
  0x40e4e7		4939c9			CMPQ CX, R9		
  0x40e4ea		77e8			JA 0x40e4d4		
  0x40e4ec		49398888000000		CMPQ CX, 0x88(R8)	
  0x40e4f3		76df			JBE 0x40e4d4		
				bulkBarrierBitmap(dst, src, size, dst-datap.data, datap.gcdatamask.bytedata)
  0x40e4f5		498b8098010000		MOVQ 0x198(R8), AX			
  0x40e4fc		48890c24		MOVQ CX, 0(SP)				
  0x40e500		4889542408		MOVQ DX, 0x8(SP)			
  0x40e505		48895c2410		MOVQ BX, 0x10(SP)			
  0x40e50a		4c29c9			SUBQ R9, CX				
  0x40e50d		48894c2418		MOVQ CX, 0x18(SP)			
  0x40e512		4889442420		MOVQ AX, 0x20(SP)			
  0x40e517		e804030000		CALL runtime.bulkBarrierBitmap(SB)	
				return
  0x40e51c		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e521		4881c480000000		ADDQ $0x80, SP		
  0x40e528		c3			RET			
		for _, datap := range activeModules() {
  0x40e529		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x40e52a		488b0547340b00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x40e531		4885c0			TESTQ AX, AX		
  0x40e534		746d			JE 0x40e5a3		
	return *p
  0x40e536		488b30			MOVQ 0(AX), SI		
  0x40e539		488b4008		MOVQ 0x8(AX), AX	
		for _, datap := range activeModules() {
  0x40e53d		31ff			XORL DI, DI		
  0x40e53f		eb03			JMP 0x40e544		
  0x40e541		48ffc7			INCQ DI			
  0x40e544		4839c7			CMPQ AX, DI		
  0x40e547		7d4d			JGE 0x40e596		
  0x40e549		4c8b04fe		MOVQ 0(SI)(DI*8), R8	
			if datap.bss <= dst && dst < datap.ebss {
  0x40e54d		4d8b8890000000		MOVQ 0x90(R8), R9	
  0x40e554		4939c9			CMPQ CX, R9		
  0x40e557		77e8			JA 0x40e541		
  0x40e559		49398898000000		CMPQ CX, 0x98(R8)	
  0x40e560		76df			JBE 0x40e541		
				bulkBarrierBitmap(dst, src, size, dst-datap.bss, datap.gcbssmask.bytedata)
  0x40e562		498b80a8010000		MOVQ 0x1a8(R8), AX			
  0x40e569		48890c24		MOVQ CX, 0(SP)				
  0x40e56d		4889542408		MOVQ DX, 0x8(SP)			
  0x40e572		48895c2410		MOVQ BX, 0x10(SP)			
  0x40e577		4c29c9			SUBQ R9, CX				
  0x40e57a		48894c2418		MOVQ CX, 0x18(SP)			
  0x40e57f		4889442420		MOVQ AX, 0x20(SP)			
  0x40e584		e897020000		CALL runtime.bulkBarrierBitmap(SB)	
				return
  0x40e589		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e58e		4881c480000000		ADDQ $0x80, SP		
  0x40e595		c3			RET			
		return
  0x40e596		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e59b		4881c480000000		ADDQ $0x80, SP		
  0x40e5a2		c3			RET			
  0x40e5a3		31c0			XORL AX, AX		
  0x40e5a5		31f6			XORL SI, SI		
		for _, datap := range activeModules() {
  0x40e5a7		eb94			JMP 0x40e53d		
  0x40e5a9		31f6			XORL SI, SI		
  0x40e5ab		31c0			XORL AX, AX		
		for _, datap := range activeModules() {
  0x40e5ad		e91effffff		JMP 0x40e4d0		
	l2 := mheap_.arenas[ri.l1()]
  0x40e5b2		488b3597830b00		MOVQ runtime.mheap_+784(SB), SI	
	ha := l2[ri.l2()]
  0x40e5b9		8406			TESTB AL, 0(SI)		
	l2 := mheap_.arenas[ri.l1()]
  0x40e5bb		90			NOPL			
	ha := l2[ri.l2()]
  0x40e5bc		488b34c6		MOVQ 0(SI)(AX*8), SI	
  0x40e5c0		90			NOPL			
	if ha == nil {
  0x40e5c1		4885f6			TESTQ SI, SI		
  0x40e5c4		741e			JE 0x40e5e4		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x40e5c6		4889cf			MOVQ CX, DI			
  0x40e5c9		48c1e90d		SHRQ $0xd, CX			
  0x40e5cd		4881e1ff1f0000		ANDQ $0x1fff, CX		
  0x40e5d4		488bb4ce00002000	MOVQ 0x200000(SI)(CX*8), SI	
	return s.startAddr
  0x40e5dc		4889f9			MOVQ DI, CX		
	if s := spanOf(dst); s == nil {
  0x40e5df		e9e9fbffff		JMP 0x40e1cd		
  0x40e5e4		31f6			XORL SI, SI		
  0x40e5e6		e9e2fbffff		JMP 0x40e1cd		
		return
  0x40e5eb		488b6c2478		MOVQ 0x78(SP), BP	
  0x40e5f0		4881c480000000		ADDQ $0x80, SP		
  0x40e5f7		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e5f8		e823390100		CALL runtime.panicindex(SB)	
  0x40e5fd		0f0b			UD2				
		throw("bulkBarrierPreWrite: unaligned arguments")
  0x40e5ff		488d051c430600		LEAQ 0x6431c(IP), AX	
  0x40e606		48890424		MOVQ AX, 0(SP)		
  0x40e60a		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x40e613		e8684e0100		CALL runtime.throw(SB)	
  0x40e618		0f0b			UD2			

TEXT runtime.bulkBarrierPreWriteSrcOnly(SB) /usr/local/go/src/runtime/mbitmap.go
func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr) {
  0x40e620		4883ec60		SUBQ $0x60, SP		
  0x40e624		48896c2458		MOVQ BP, 0x58(SP)	
  0x40e629		488d6c2458		LEAQ 0x58(SP), BP	
	if (dst|src|size)&(sys.PtrSize-1) != 0 {
  0x40e62e		488b442470		MOVQ 0x70(SP), AX	
  0x40e633		488b4c2468		MOVQ 0x68(SP), CX	
  0x40e638		4889c2			MOVQ AX, DX		
  0x40e63b		4809c8			ORQ CX, AX		
  0x40e63e		488b5c2478		MOVQ 0x78(SP), BX	
  0x40e643		4809d8			ORQ BX, AX		
  0x40e646		48a907000000		TESTQ $0x7, AX		
  0x40e64c		0f85ab010000		JNE 0x40e7fd		
	if !writeBarrier.needed {
  0x40e652		803dcbe70c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x40e659		0f848d010000		JE 0x40e7ec				
	buf := &getg().m.p.ptr().wbBuf
  0x40e65f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40e668		488b4030		MOVQ 0x30(AX), AX	
  0x40e66c		488bb0d0000000		MOVQ 0xd0(AX), SI	
  0x40e673		8406			TESTB AL, 0(SI)		
  0x40e675		8400			TESTB AL, 0(AX)		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e677		488b05d2820b00		MOVQ runtime.mheap_+784(SB), AX	
  0x40e67e		8400			TESTB AL, 0(AX)			
	buf := &getg().m.p.ptr().wbBuf
  0x40e680		90			NOPL			
	h := heapBitsForAddr(dst)
  0x40e681		90			NOPL			
	arena := arenaIndex(addr)
  0x40e682		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e683		90			NOPL			
  0x40e684		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40e685		48bf0000000000800000	MOVQ $0x800000000000, DI	
  0x40e68f		4801cf			ADDQ CX, DI			
  0x40e692		48c1ef1a		SHRQ $0x1a, DI			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e696		4881ff00004000		CMPQ $0x400000, DI	
  0x40e69d		0f8353010000		JAE 0x40e7f6		
  0x40e6a3		488b04f8		MOVQ 0(AX)(DI*8), AX	
	if ha == nil {
  0x40e6a7		4885c0			TESTQ AX, AX		
  0x40e6aa		0f842e010000		JE 0x40e7de		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40e6b0		4989c8			MOVQ CX, R8		
  0x40e6b3		48c1e905		SHRQ $0x5, CX		
  0x40e6b7		4881e1ffff1f00		ANDQ $0x1fffff, CX	
  0x40e6be		4801c1			ADDQ AX, CX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x40e6c1		49c1e803		SHRQ $0x3, R8		
  0x40e6c5		4983e003		ANDQ $0x3, R8		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40e6c9		4805ffff1f00		ADDQ $0x1fffff, AX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40e6cf		4889742450		MOVQ SI, 0x50(SP)	
  0x40e6d4		4531c9			XORL R9, R9		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e6d7		eb04			JMP 0x40e6dd		
  0x40e6d9		4983c108		ADDQ $0x8, R9		
  0x40e6dd		4939d9			CMPQ BX, R9		
  0x40e6e0		0f83ee000000		JAE 0x40e7d4		
  0x40e6e6		4c894c2438		MOVQ R9, 0x38(SP)	
		if h.isPointer() {
  0x40e6eb		90			NOPL			
	return h.bits()&bitPointer != 0
  0x40e6ec		90			NOPL			
	return uint32(*h.bitp) >> (h.shift & 31)
  0x40e6ed		440fb611		MOVZX 0(CX), R10	
	return h.bits()&bitPointer != 0
  0x40e6f1		450fa3c2		BTL R8, R10		
		if h.isPointer() {
  0x40e6f5		7335			JAE 0x40e72c		
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e6f7		4d8d1411		LEAQ 0(R9)(DX*1), R10	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e6fb		4c8b9e20130000		MOVQ 0x1320(SI), R11	
			if !buf.putFast(0, *srcx) {
  0x40e702		90			NOPL			
  0x40e703		4d8b12			MOVQ 0(R10), R10	
	p[0] = old
  0x40e706		49c70300000000		MOVQ $0x0, 0(R11)	
	p[1] = new
  0x40e70d		4d895308		MOVQ R10, 0x8(R11)	
	b.next += 2 * sys.PtrSize
  0x40e711		4c8b9620130000		MOVQ 0x1320(SI), R10	
  0x40e718		4983c210		ADDQ $0x10, R10		
  0x40e71c		4c899620130000		MOVQ R10, 0x1320(SI)	
	return b.next != b.end
  0x40e723		4c399628130000		CMPQ R10, 0x1328(SI)	
			if !buf.putFast(0, *srcx) {
  0x40e72a		745d			JE 0x40e789		
		h = h.next()
  0x40e72c		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x40e72d		4183f803		CMPL $0x3, R8		
  0x40e731		7305			JAE 0x40e738		
		h.shift += heapBitsShift
  0x40e733		41ffc0			INCL R8			
  0x40e736		eba1			JMP 0x40e6d9		
	} else if h.bitp != h.last {
  0x40e738		4839c1			CMPQ AX, CX		
  0x40e73b		7409			JE 0x40e746		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40e73d		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40e73e		48ffc1			INCQ CX			
  0x40e741		4531c0			XORL R8, R8		
		h = h.next()
  0x40e744		eb93			JMP 0x40e6d9		
		return h.nextArena()
  0x40e746		48890c24		MOVQ CX, 0(SP)				
  0x40e74a		4489442408		MOVL R8, 0x8(SP)			
  0x40e74f		897c240c		MOVL DI, 0xc(SP)			
  0x40e753		4889442410		MOVQ AX, 0x10(SP)			
  0x40e758		e813f8ffff		CALL runtime.heapBits.nextArena(SB)	
  0x40e75d		448b442420		MOVL 0x20(SP), R8			
  0x40e762		488b4c2418		MOVQ 0x18(SP), CX			
  0x40e767		488b442428		MOVQ 0x28(SP), AX			
  0x40e76c		8b7c2424		MOVL 0x24(SP), DI			
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e770		488b542470		MOVQ 0x70(SP), DX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e775		488b5c2478		MOVQ 0x78(SP), BX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e77a		488b742450		MOVQ 0x50(SP), SI	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e77f		4c8b4c2438		MOVQ 0x38(SP), R9	
		h = h.next()
  0x40e784		e950ffffff		JMP 0x40e6d9		
		if h.isPointer() {
  0x40e789		4889442440		MOVQ AX, 0x40(SP)	
  0x40e78e		897c2434		MOVL DI, 0x34(SP)	
  0x40e792		4489442430		MOVL R8, 0x30(SP)	
  0x40e797		48894c2448		MOVQ CX, 0x48(SP)	
				wbBufFlush(nil, 0)
  0x40e79c		0f57c0			XORPS X0, X0			
  0x40e79f		0f110424		MOVUPS X0, 0(SP)		
  0x40e7a3		e858240100		CALL runtime.wbBufFlush(SB)	
	} else if h.bitp != h.last {
  0x40e7a8		488b442440		MOVQ 0x40(SP), AX	
  0x40e7ad		488b4c2448		MOVQ 0x48(SP), CX	
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e7b2		488b542470		MOVQ 0x70(SP), DX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e7b7		488b5c2478		MOVQ 0x78(SP), BX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e7bc		488b742450		MOVQ 0x50(SP), SI	
		h = h.next()
  0x40e7c1		8b7c2434		MOVL 0x34(SP), DI	
	if h.shift < 3*heapBitsShift {
  0x40e7c5		448b442430		MOVL 0x30(SP), R8	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e7ca		4c8b4c2438		MOVQ 0x38(SP), R9	
				wbBufFlush(nil, 0)
  0x40e7cf		e958ffffff		JMP 0x40e72c		
  0x40e7d4		488b6c2458		MOVQ 0x58(SP), BP	
  0x40e7d9		4883c460		ADDQ $0x60, SP		
  0x40e7dd		c3			RET			
  0x40e7de		31c0			XORL AX, AX		
  0x40e7e0		31ff			XORL DI, DI		
  0x40e7e2		4531c0			XORL R8, R8		
  0x40e7e5		31c9			XORL CX, CX		
	h := heapBitsForAddr(dst)
  0x40e7e7		e9e3feffff		JMP 0x40e6cf		
		return
  0x40e7ec		488b6c2458		MOVQ 0x58(SP), BP	
  0x40e7f1		4883c460		ADDQ $0x60, SP		
  0x40e7f5		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40e7f6		e825370100		CALL runtime.panicindex(SB)	
  0x40e7fb		0f0b			UD2				
		throw("bulkBarrierPreWrite: unaligned arguments")
  0x40e7fd		488d051e410600		LEAQ 0x6411e(IP), AX	
  0x40e804		48890424		MOVQ AX, 0(SP)		
  0x40e808		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x40e811		e86a4c0100		CALL runtime.throw(SB)	
  0x40e816		0f0b			UD2			

TEXT runtime.bulkBarrierBitmap(SB) /usr/local/go/src/runtime/mbitmap.go
func bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8) {
  0x40e820		4883ec38		SUBQ $0x38, SP		
  0x40e824		48896c2430		MOVQ BP, 0x30(SP)	
  0x40e829		488d6c2430		LEAQ 0x30(SP), BP	
	buf := &getg().m.p.ptr().wbBuf
  0x40e82e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x40e837		488b4030		MOVQ 0x30(AX), AX	
  0x40e83b		488b90d0000000		MOVQ 0xd0(AX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40e842		4889542428		MOVQ DX, 0x28(SP)	
	buf := &getg().m.p.ptr().wbBuf
  0x40e847		8402			TESTB AL, 0(DX)		
  0x40e849		8400			TESTB AL, 0(AX)		
	word := maskOffset / sys.PtrSize
  0x40e84b		488b4c2458		MOVQ 0x58(SP), CX	
  0x40e850		4889c8			MOVQ CX, AX		
  0x40e853		48c1e903		SHRQ $0x3, CX		
	bits = addb(bits, word/8)
  0x40e857		90			NOPL			
  0x40e858		48c1e806		SHRQ $0x6, AX		
	mask := uint8(1) << (word % 8)
  0x40e85c		4883e107		ANDQ $0x7, CX		
  0x40e860		bb01000000		MOVL $0x1, BX		
  0x40e865		d3e3			SHLL CL, BX		
	buf := &getg().m.p.ptr().wbBuf
  0x40e867		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40e868		488b742460		MOVQ 0x60(SP), SI	
  0x40e86d		4801f0			ADDQ SI, AX		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e870		488b742450		MOVQ 0x50(SP), SI	
  0x40e875		488b7c2448		MOVQ 0x48(SP), DI	
  0x40e87a		4c8b442440		MOVQ 0x40(SP), R8	
  0x40e87f		31c9			XORL CX, CX		
  0x40e881		eb07			JMP 0x40e88a		
  0x40e883		488d4808		LEAQ 0x8(AX), CX	
			bits = addb(bits, 1)
  0x40e887		4c89c8			MOVQ R9, AX		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e88a		4839f1			CMPQ SI, CX		
  0x40e88d		0f831d010000		JAE 0x40e9b0		
		if mask == 0 {
  0x40e893		84db			TESTL BL, BL		
  0x40e895		0f850b010000		JNE 0x40e9a6		
			bits = addb(bits, 1)
  0x40e89b		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40e89c		4c8d4801		LEAQ 0x1(AX), R9	
			if *bits == 0 {
  0x40e8a0		80780100		CMPB $0x0, 0x1(AX)	
  0x40e8a4		7506			JNE 0x40e8ac		
				i += 7 * sys.PtrSize
  0x40e8a6		488d4138		LEAQ 0x38(CX), AX	
				continue
  0x40e8aa		ebd7			JMP 0x40e883		
  0x40e8ac		b801000000		MOVL $0x1, AX		
		if *bits&mask != 0 {
  0x40e8b1		410fb619		MOVZX 0(R9), BX		
  0x40e8b5		84c3			TESTL AL, BL		
  0x40e8b7		7448			JE 0x40e901		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e8b9		48894c2418		MOVQ CX, 0x18(SP)	
		if *bits&mask != 0 {
  0x40e8be		4c894c2420		MOVQ R9, 0x20(SP)	
  0x40e8c3		88442417		MOVB AL, 0x17(SP)	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e8c7		4a8d1c01		LEAQ 0(CX)(R8*1), BX	
			if src == 0 {
  0x40e8cb		4885ff			TESTQ DI, DI		
  0x40e8ce		756e			JNE 0x40e93e		
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e8d0		4c8b9220130000		MOVQ 0x1320(DX), R10	
				if !buf.putFast(*dstx, 0) {
  0x40e8d7		90			NOPL			
  0x40e8d8		488b1b			MOVQ 0(BX), BX		
	p[0] = old
  0x40e8db		49891a			MOVQ BX, 0(R10)		
	p[1] = new
  0x40e8de		49c7420800000000	MOVQ $0x0, 0x8(R10)	
	b.next += 2 * sys.PtrSize
  0x40e8e6		488b9a20130000		MOVQ 0x1320(DX), BX	
  0x40e8ed		4883c310		ADDQ $0x10, BX		
  0x40e8f1		48899a20130000		MOVQ BX, 0x1320(DX)	
	return b.next != b.end
  0x40e8f8		48399a28130000		CMPQ BX, 0x1328(DX)	
				if !buf.putFast(*dstx, 0) {
  0x40e8ff		740c			JE 0x40e90d		
		mask <<= 1
  0x40e901		d1e0			SHLL $0x1, AX		
		if mask == 0 {
  0x40e903		89c3			MOVL AX, BX		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e905		4889c8			MOVQ CX, AX		
		mask <<= 1
  0x40e908		e976ffffff		JMP 0x40e883		
					wbBufFlush(nil, 0)
  0x40e90d		0f57c0			XORPS X0, X0			
  0x40e910		0f110424		MOVUPS X0, 0(SP)		
  0x40e914		e8e7220100		CALL runtime.wbBufFlush(SB)	
		mask <<= 1
  0x40e919		0fb6442417		MOVZX 0x17(SP), AX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e91e		488b4c2418		MOVQ 0x18(SP), CX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e923		488b542428		MOVQ 0x28(SP), DX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e928		488b742450		MOVQ 0x50(SP), SI	
			if src == 0 {
  0x40e92d		488b7c2448		MOVQ 0x48(SP), DI	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e932		4c8b442440		MOVQ 0x40(SP), R8	
			bits = addb(bits, 1)
  0x40e937		4c8b4c2420		MOVQ 0x20(SP), R9	
					wbBufFlush(nil, 0)
  0x40e93c		ebc3			JMP 0x40e901		
				srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40e93e		4c8d1439		LEAQ 0(CX)(DI*1), R10	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e942		4c8b9a20130000		MOVQ 0x1320(DX), R11	
				if !buf.putFast(*dstx, *srcx) {
  0x40e949		90			NOPL			
  0x40e94a		488b1b			MOVQ 0(BX), BX		
  0x40e94d		4d8b12			MOVQ 0(R10), R10	
	p[0] = old
  0x40e950		49891b			MOVQ BX, 0(R11)		
	p[1] = new
  0x40e953		4d895308		MOVQ R10, 0x8(R11)	
	b.next += 2 * sys.PtrSize
  0x40e957		488b9a20130000		MOVQ 0x1320(DX), BX	
  0x40e95e		4883c310		ADDQ $0x10, BX		
  0x40e962		48899a20130000		MOVQ BX, 0x1320(DX)	
	return b.next != b.end
  0x40e969		48399a28130000		CMPQ BX, 0x1328(DX)	
				if !buf.putFast(*dstx, *srcx) {
  0x40e970		758f			JNE 0x40e901		
					wbBufFlush(nil, 0)
  0x40e972		0f57c0			XORPS X0, X0			
  0x40e975		0f110424		MOVUPS X0, 0(SP)		
  0x40e979		e882220100		CALL runtime.wbBufFlush(SB)	
		mask <<= 1
  0x40e97e		0fb6442417		MOVZX 0x17(SP), AX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e983		488b4c2418		MOVQ 0x18(SP), CX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40e988		488b542428		MOVQ 0x28(SP), DX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x40e98d		488b742450		MOVQ 0x50(SP), SI	
			if src == 0 {
  0x40e992		488b7c2448		MOVQ 0x48(SP), DI	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40e997		4c8b442440		MOVQ 0x40(SP), R8	
			bits = addb(bits, 1)
  0x40e99c		4c8b4c2420		MOVQ 0x20(SP), R9	
					wbBufFlush(nil, 0)
  0x40e9a1		e95bffffff		JMP 0x40e901		
		if *bits&mask != 0 {
  0x40e9a6		4989c1			MOVQ AX, R9		
  0x40e9a9		89d8			MOVL BX, AX		
		if mask == 0 {
  0x40e9ab		e901ffffff		JMP 0x40e8b1		
  0x40e9b0		488b6c2430		MOVQ 0x30(SP), BP	
  0x40e9b5		4883c438		ADDQ $0x38, SP		
  0x40e9b9		c3			RET			

TEXT runtime.typeBitsBulkBarrier(SB) /usr/local/go/src/runtime/mbitmap.go
func typeBitsBulkBarrier(typ *_type, dst, src, size uintptr) {
  0x40e9c0		4883ec58		SUBQ $0x58, SP		
  0x40e9c4		48896c2450		MOVQ BP, 0x50(SP)	
  0x40e9c9		488d6c2450		LEAQ 0x50(SP), BP	
	if typ == nil {
  0x40e9ce		488b442460		MOVQ 0x60(SP), AX	
  0x40e9d3		4885c0			TESTQ AX, AX		
  0x40e9d6		0f847b020000		JE 0x40ec57		
	if typ.size != size {
  0x40e9dc		488b4c2478		MOVQ 0x78(SP), CX	
  0x40e9e1		483908			CMPQ CX, 0(AX)		
  0x40e9e4		0f859a010000		JNE 0x40eb84		
	if typ.kind&kindGCProg != 0 {
  0x40e9ea		0fb64817		MOVZX 0x17(AX), CX	
  0x40e9ee		f6c140			TESTL $0x40, CL		
  0x40e9f1		0f8501010000		JNE 0x40eaf8		
	if !writeBarrier.needed {
  0x40e9f7		803d26e40c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x40e9fe		0f84ea000000		JE 0x40eaee				
	buf := &getg().m.p.ptr().wbBuf
  0x40ea04		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ea0d		488b4930		MOVQ 0x30(CX), CX	
  0x40ea11		488b91d0000000		MOVQ 0xd0(CX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x40ea18		4889542448		MOVQ DX, 0x48(SP)	
	buf := &getg().m.p.ptr().wbBuf
  0x40ea1d		8402			TESTB AL, 0(DX)		
  0x40ea1f		8401			TESTB AL, 0(CX)		
	ptrmask := typ.gcdata
  0x40ea21		488b4820		MOVQ 0x20(AX), CX	
	buf := &getg().m.p.ptr().wbBuf
  0x40ea25		90			NOPL			
	for i := uintptr(0); i < typ.ptrdata; i += sys.PtrSize {
  0x40ea26		488b5c2470		MOVQ 0x70(SP), BX	
  0x40ea2b		488b742468		MOVQ 0x68(SP), SI	
  0x40ea30		31ff			XORL DI, DI		
  0x40ea32		4531c0			XORL R8, R8		
  0x40ea35		eb04			JMP 0x40ea3b		
  0x40ea37		4883c708		ADDQ $0x8, DI		
  0x40ea3b		48397808		CMPQ DI, 0x8(AX)	
  0x40ea3f		0f869f000000		JBE 0x40eae4		
		if i&(sys.PtrSize*8-1) == 0 {
  0x40ea45		48f7c73f000000		TESTQ $0x3f, DI		
  0x40ea4c		0f858a000000		JNE 0x40eadc		
			bits = uint32(*ptrmask)
  0x40ea52		440fb601		MOVZX 0(CX), R8		
			ptrmask = addb(ptrmask, 1)
  0x40ea56		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40ea57		48ffc1			INCQ CX			
		if bits&1 != 0 {
  0x40ea5a		410fbae000		BTL $0x0, R8		
  0x40ea5f		73d6			JAE 0x40ea37		
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40ea61		4c8d0c37		LEAQ 0(DI)(SI*1), R9	
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40ea65		4c8d141f		LEAQ 0(DI)(BX*1), R10	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40ea69		4c8b9a20130000		MOVQ 0x1320(DX), R11	
			if !buf.putFast(*dstx, *srcx) {
  0x40ea70		90			NOPL			
  0x40ea71		4d8b09			MOVQ 0(R9), R9		
  0x40ea74		4d8b12			MOVQ 0(R10), R10	
	p[0] = old
  0x40ea77		4d890b			MOVQ R9, 0(R11)		
	p[1] = new
  0x40ea7a		4d895308		MOVQ R10, 0x8(R11)	
	b.next += 2 * sys.PtrSize
  0x40ea7e		4c8b8a20130000		MOVQ 0x1320(DX), R9	
  0x40ea85		4983c110		ADDQ $0x10, R9		
  0x40ea89		4c898a20130000		MOVQ R9, 0x1320(DX)	
	return b.next != b.end
  0x40ea90		4c398a28130000		CMPQ R9, 0x1328(DX)	
			if !buf.putFast(*dstx, *srcx) {
  0x40ea97		759e			JNE 0x40ea37		
	for i := uintptr(0); i < typ.ptrdata; i += sys.PtrSize {
  0x40ea99		48897c2420		MOVQ DI, 0x20(SP)	
		if bits&1 != 0 {
  0x40ea9e		448944241c		MOVL R8, 0x1c(SP)	
			bits = uint32(*ptrmask)
  0x40eaa3		48894c2438		MOVQ CX, 0x38(SP)	
				wbBufFlush(nil, 0)
  0x40eaa8		0f57c0			XORPS X0, X0			
  0x40eaab		0f110424		MOVUPS X0, 0(SP)		
  0x40eaaf		e84c210100		CALL runtime.wbBufFlush(SB)	
	for i := uintptr(0); i < typ.ptrdata; i += sys.PtrSize {
  0x40eab4		488b442460		MOVQ 0x60(SP), AX	
			bits = uint32(*ptrmask)
  0x40eab9		488b4c2438		MOVQ 0x38(SP), CX	
	p := (*[2]uintptr)(unsafe.Pointer(b.next))
  0x40eabe		488b542448		MOVQ 0x48(SP), DX	
			srcx := (*uintptr)(unsafe.Pointer(src + i))
  0x40eac3		488b5c2470		MOVQ 0x70(SP), BX	
			dstx := (*uintptr)(unsafe.Pointer(dst + i))
  0x40eac8		488b742468		MOVQ 0x68(SP), SI	
	for i := uintptr(0); i < typ.ptrdata; i += sys.PtrSize {
  0x40eacd		488b7c2420		MOVQ 0x20(SP), DI	
			bits = bits >> 1
  0x40ead2		448b44241c		MOVL 0x1c(SP), R8	
				wbBufFlush(nil, 0)
  0x40ead7		e95bffffff		JMP 0x40ea37		
			bits = bits >> 1
  0x40eadc		41d1e8			SHRL $0x1, R8		
  0x40eadf		e976ffffff		JMP 0x40ea5a		
  0x40eae4		488b6c2450		MOVQ 0x50(SP), BP	
  0x40eae9		4883c458		ADDQ $0x58, SP		
  0x40eaed		c3			RET			
		return
  0x40eaee		488b6c2450		MOVQ 0x50(SP), BP	
  0x40eaf3		4883c458		ADDQ $0x58, SP		
  0x40eaf7		c3			RET			
		println("runtime: typeBitsBulkBarrier with type ", typ.string(), " with GC prog")
  0x40eaf8		48890424		MOVQ AX, 0(SP)				
  0x40eafc		e8ef2b0300		CALL runtime.(*_type).string(SB)	
  0x40eb01		488b442410		MOVQ 0x10(SP), AX			
  0x40eb06		4889442430		MOVQ AX, 0x30(SP)			
  0x40eb0b		488b4c2408		MOVQ 0x8(SP), CX			
  0x40eb10		48894c2440		MOVQ CX, 0x40(SP)			
  0x40eb15		e8a6530100		CALL runtime.printlock(SB)		
  0x40eb1a		488d05c93e0600		LEAQ 0x63ec9(IP), AX			
  0x40eb21		48890424		MOVQ AX, 0(SP)				
  0x40eb25		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x40eb2e		e8bd5c0100		CALL runtime.printstring(SB)		
  0x40eb33		488b442440		MOVQ 0x40(SP), AX			
  0x40eb38		48890424		MOVQ AX, 0(SP)				
  0x40eb3c		488b442430		MOVQ 0x30(SP), AX			
  0x40eb41		4889442408		MOVQ AX, 0x8(SP)			
  0x40eb46		e8a55c0100		CALL runtime.printstring(SB)		
  0x40eb4b		488d0502130600		LEAQ 0x61302(IP), AX			
  0x40eb52		48890424		MOVQ AX, 0(SP)				
  0x40eb56		48c74424080f000000	MOVQ $0xf, 0x8(SP)			
  0x40eb5f		e88c5c0100		CALL runtime.printstring(SB)		
  0x40eb64		e8d7530100		CALL runtime.printunlock(SB)		
		throw("runtime: invalid typeBitsBulkBarrier")
  0x40eb69		488d05073a0600		LEAQ 0x63a07(IP), AX	
  0x40eb70		48890424		MOVQ AX, 0(SP)		
  0x40eb74		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x40eb7d		e8fe480100		CALL runtime.throw(SB)	
  0x40eb82		0f0b			UD2			
		println("runtime: typeBitsBulkBarrier with type ", typ.string(), " of size ", typ.size, " but memory size", size)
  0x40eb84		48890424		MOVQ AX, 0(SP)				
  0x40eb88		e8632b0300		CALL runtime.(*_type).string(SB)	
  0x40eb8d		488b442410		MOVQ 0x10(SP), AX			
  0x40eb92		4889442430		MOVQ AX, 0x30(SP)			
  0x40eb97		488b4c2408		MOVQ 0x8(SP), CX			
  0x40eb9c		48894c2440		MOVQ CX, 0x40(SP)			
  0x40eba1		488b542460		MOVQ 0x60(SP), DX			
  0x40eba6		488b12			MOVQ 0(DX), DX				
  0x40eba9		4889542428		MOVQ DX, 0x28(SP)			
  0x40ebae		e80d530100		CALL runtime.printlock(SB)		
  0x40ebb3		488d05303e0600		LEAQ 0x63e30(IP), AX			
  0x40ebba		48890424		MOVQ AX, 0(SP)				
  0x40ebbe		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x40ebc7		e8245c0100		CALL runtime.printstring(SB)		
  0x40ebcc		488b442440		MOVQ 0x40(SP), AX			
  0x40ebd1		48890424		MOVQ AX, 0(SP)				
  0x40ebd5		488b442430		MOVQ 0x30(SP), AX			
  0x40ebda		4889442408		MOVQ AX, 0x8(SP)			
  0x40ebdf		e80c5c0100		CALL runtime.printstring(SB)		
  0x40ebe4		488d052b0c0600		LEAQ 0x60c2b(IP), AX			
  0x40ebeb		48890424		MOVQ AX, 0(SP)				
  0x40ebef		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x40ebf8		e8f35b0100		CALL runtime.printstring(SB)		
  0x40ebfd		488b442428		MOVQ 0x28(SP), AX			
  0x40ec02		48890424		MOVQ AX, 0(SP)				
  0x40ec06		e835590100		CALL runtime.printuint(SB)		
  0x40ec0b		488d057e160600		LEAQ 0x6167e(IP), AX			
  0x40ec12		48890424		MOVQ AX, 0(SP)				
  0x40ec16		48c744240812000000	MOVQ $0x12, 0x8(SP)			
  0x40ec1f		e8cc5b0100		CALL runtime.printstring(SB)		
  0x40ec24		488b442478		MOVQ 0x78(SP), AX			
  0x40ec29		48890424		MOVQ AX, 0(SP)				
  0x40ec2d		e80e590100		CALL runtime.printuint(SB)		
  0x40ec32		e819550100		CALL runtime.printnl(SB)		
  0x40ec37		e804530100		CALL runtime.printunlock(SB)		
		throw("runtime: invalid typeBitsBulkBarrier")
  0x40ec3c		488d0534390600		LEAQ 0x63934(IP), AX	
  0x40ec43		48890424		MOVQ AX, 0(SP)		
  0x40ec47		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x40ec50		e82b480100		CALL runtime.throw(SB)	
  0x40ec55		0f0b			UD2			
		throw("runtime: typeBitsBulkBarrier without type")
  0x40ec57		488d05813e0600		LEAQ 0x63e81(IP), AX	
  0x40ec5e		48890424		MOVQ AX, 0(SP)		
  0x40ec62		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x40ec6b		e810480100		CALL runtime.throw(SB)	
  0x40ec70		0f0b			UD2			

TEXT runtime.heapBits.initSpan(SB) /usr/local/go/src/runtime/mbitmap.go
func (h heapBits) initSpan(s *mspan) {
  0x40ec80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ec89		483b6110		CMPQ 0x10(CX), SP	
  0x40ec8d		0f86ef010000		JBE 0x40ee82		
  0x40ec93		4883ec78		SUBQ $0x78, SP		
  0x40ec97		48896c2470		MOVQ BP, 0x70(SP)	
  0x40ec9c		488d6c2470		LEAQ 0x70(SP), BP	
	size, n, total := s.layout()
  0x40eca1		90			NOPL			
  0x40eca2		488b8c2498000000	MOVQ 0x98(SP), CX	
	total = s.npages << _PageShift
  0x40ecaa		488b4120		MOVQ 0x20(CX), AX	
  0x40ecae		48c1e00d		SHLQ $0xd, AX		
  0x40ecb2		4889442458		MOVQ AX, 0x58(SP)	
	size = s.elemsize
  0x40ecb7		488b5168		MOVQ 0x68(CX), DX	
  0x40ecbb		4889542448		MOVQ DX, 0x48(SP)	
	if size > 0 {
  0x40ecc0		4885d2			TESTQ DX, DX		
  0x40ecc3		0f867c010000		JBE 0x40ee45		
		n = total / size
  0x40ecc9		4889d3			MOVQ DX, BX		
  0x40eccc		31d2			XORL DX, DX		
  0x40ecce		48f7f3			DIVQ BX			
	s.freeindex = 0
  0x40ecd1		48c7413000000000	MOVQ $0x0, 0x30(CX)	
	s.allocCache = ^uint64(0) // all 1s indicating all free.
  0x40ecd9		48c74140ffffffff	MOVQ $-0x1, 0x40(CX)	
	s.nelems = n
  0x40ece1		48894138		MOVQ AX, 0x38(CX)	
	s.gcmarkBits = nil
  0x40ece5		0f57c0			XORPS X0, X0		
  0x40ece8		0f114148		MOVUPS X0, 0x48(CX)	
	s.gcmarkBits = newMarkBits(s.nelems)
  0x40ecec		48890424		MOVQ AX, 0(SP)			
  0x40ecf0		e8bb030100		CALL runtime.newMarkBits(SB)	
  0x40ecf5		488b442408		MOVQ 0x8(SP), AX		
  0x40ecfa		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x40ed02		48894150		MOVQ AX, 0x50(CX)		
	s.allocBits = newAllocBits(s.nelems)
  0x40ed06		90			NOPL			
  0x40ed07		488b4138		MOVQ 0x38(CX), AX	
	return newMarkBits(nelems)
  0x40ed0b		48890424		MOVQ AX, 0(SP)			
  0x40ed0f		e89c030100		CALL runtime.newMarkBits(SB)	
  0x40ed14		488b442408		MOVQ 0x8(SP), AX		
	s.allocBits = newAllocBits(s.nelems)
  0x40ed19		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x40ed21		48894148		MOVQ AX, 0x48(CX)	
	nw := total / sys.PtrSize
  0x40ed25		488b442458		MOVQ 0x58(SP), AX	
  0x40ed2a		48c1e803		SHRQ $0x3, AX		
	if nw%wordsPerBitmapByte != 0 {
  0x40ed2e		48a903000000		TESTQ $0x3, AX		
  0x40ed34		0f852d010000		JNE 0x40ee67		
	if h.shift != 0 {
  0x40ed3a		8b8c2488000000		MOVL 0x88(SP), CX	
  0x40ed41		85c9			TESTL CX, CX		
  0x40ed43		0f8503010000		JNE 0x40ee4c		
		hNext, anw := h.forwardOrBoundary(nw)
  0x40ed49		8b94248c000000		MOVL 0x8c(SP), DX	
  0x40ed50		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x40ed58		488bb42490000000	MOVQ 0x90(SP), SI	
	for nw > 0 {
  0x40ed60		eb24			JMP 0x40ed86		
				*bitp = bitPointerAll | bitScanAll
  0x40ed62		41c601ff		MOVB $0xff, 0(R9)	
			for i := uintptr(0); i < nbyte; i++ {
  0x40ed66		49ffc2			INCQ R10		
				bitp = add1(bitp)
  0x40ed69		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40ed6a		49ffc1			INCQ R9			
			for i := uintptr(0); i < nbyte; i++ {
  0x40ed6d		4939f2			CMPQ SI, R10		
  0x40ed70		72f0			JB 0x40ed62		
		nw -= anw
  0x40ed72		4c8b4c2450		MOVQ 0x50(SP), R9	
  0x40ed77		4929f9			SUBQ DI, R9		
		hNext, anw := h.forwardOrBoundary(nw)
  0x40ed7a		4889c6			MOVQ AX, SI		
	for nw > 0 {
  0x40ed7d		4c89c8			MOVQ R9, AX		
		hNext, anw := h.forwardOrBoundary(nw)
  0x40ed80		89d7			MOVL DX, DI		
  0x40ed82		89ca			MOVL CX, DX		
  0x40ed84		89f9			MOVL DI, CX		
	for nw > 0 {
  0x40ed86		4885c0			TESTQ AX, AX		
  0x40ed89		0f86ac000000		JBE 0x40ee3b		
  0x40ed8f		4889442450		MOVQ AX, 0x50(SP)	
		hNext, anw := h.forwardOrBoundary(nw)
  0x40ed94		48899c2480000000	MOVQ BX, 0x80(SP)				
  0x40ed9c		48891c24		MOVQ BX, 0(SP)					
  0x40eda0		894c2408		MOVL CX, 0x8(SP)				
  0x40eda4		8954240c		MOVL DX, 0xc(SP)				
  0x40eda8		4889742410		MOVQ SI, 0x10(SP)				
  0x40edad		4889442418		MOVQ AX, 0x18(SP)				
  0x40edb2		e8e9f2ffff		CALL runtime.heapBits.forwardOrBoundary(SB)	
  0x40edb7		488b442430		MOVQ 0x30(SP), AX				
  0x40edbc		8b4c242c		MOVL 0x2c(SP), CX				
  0x40edc0		8b542428		MOVL 0x28(SP), DX				
  0x40edc4		488b5c2420		MOVQ 0x20(SP), BX				
  0x40edc9		488b742438		MOVQ 0x38(SP), SI				
		nbyte := anw / wordsPerBitmapByte
  0x40edce		4889f7			MOVQ SI, DI		
  0x40edd1		48c1ee02		SHRQ $0x2, SI		
		if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40edd5		4c8b442448		MOVQ 0x48(SP), R8	
  0x40edda		4983f808		CMPQ $0x8, R8		
  0x40edde		750d			JNE 0x40eded		
			for i := uintptr(0); i < nbyte; i++ {
  0x40ede0		4c8b8c2480000000	MOVQ 0x80(SP), R9	
  0x40ede8		4531d2			XORL R10, R10		
  0x40edeb		eb80			JMP 0x40ed6d		
		hNext, anw := h.forwardOrBoundary(nw)
  0x40eded		4889442468		MOVQ AX, 0x68(SP)	
  0x40edf2		894c2444		MOVL CX, 0x44(SP)	
  0x40edf6		89542440		MOVL DX, 0x40(SP)	
  0x40edfa		48895c2460		MOVQ BX, 0x60(SP)	
  0x40edff		48897c2458		MOVQ DI, 0x58(SP)	
			memclrNoHeapPointers(unsafe.Pointer(h.bitp), nbyte)
  0x40ee04		488b842480000000	MOVQ 0x80(SP), AX			
  0x40ee0c		48890424		MOVQ AX, 0(SP)				
  0x40ee10		4889742408		MOVQ SI, 0x8(SP)			
  0x40ee15		e8a6b60300		CALL runtime.memclrNoHeapPointers(SB)	
		hNext, anw := h.forwardOrBoundary(nw)
  0x40ee1a		488b442468		MOVQ 0x68(SP), AX	
  0x40ee1f		8b4c2444		MOVL 0x44(SP), CX	
  0x40ee23		8b542440		MOVL 0x40(SP), DX	
  0x40ee27		488b5c2460		MOVQ 0x60(SP), BX	
		nw -= anw
  0x40ee2c		488b7c2458		MOVQ 0x58(SP), DI	
		if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40ee31		4c8b442448		MOVQ 0x48(SP), R8	
			memclrNoHeapPointers(unsafe.Pointer(h.bitp), nbyte)
  0x40ee36		e937ffffff		JMP 0x40ed72		
  0x40ee3b		488b6c2470		MOVQ 0x70(SP), BP	
  0x40ee40		4883c478		ADDQ $0x78, SP		
  0x40ee44		c3			RET			
  0x40ee45		31c0			XORL AX, AX		
	if size > 0 {
  0x40ee47		e985feffff		JMP 0x40ecd1		
		throw("initSpan: unaligned base")
  0x40ee4c		488d056f200600		LEAQ 0x6206f(IP), AX	
  0x40ee53		48890424		MOVQ AX, 0(SP)		
  0x40ee57		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x40ee60		e81b460100		CALL runtime.throw(SB)	
  0x40ee65		0f0b			UD2			
		throw("initSpan: unaligned length")
  0x40ee67		488d05f2230600		LEAQ 0x623f2(IP), AX	
  0x40ee6e		48890424		MOVQ AX, 0(SP)		
  0x40ee72		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x40ee7b		e800460100		CALL runtime.throw(SB)	
  0x40ee80		0f0b			UD2			
func (h heapBits) initSpan(s *mspan) {
  0x40ee82		e8f9890300		CALL runtime.morestack_noctxt(SB)	
  0x40ee87		e9f4fdffff		JMP runtime.heapBits.initSpan(SB)	

TEXT runtime.heapBits.initCheckmarkSpan(SB) /usr/local/go/src/runtime/mbitmap.go
func (h heapBits) initCheckmarkSpan(size, n, total uintptr) {
  0x40ee90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40ee99		483b6110		CMPQ 0x10(CX), SP	
  0x40ee9d		0f861a010000		JBE 0x40efbd		
  0x40eea3		4883ec50		SUBQ $0x50, SP		
  0x40eea7		48896c2448		MOVQ BP, 0x48(SP)	
  0x40eeac		488d6c2448		LEAQ 0x48(SP), BP	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40eeb1		488b442470		MOVQ 0x70(SP), AX	
  0x40eeb6		4883f808		CMPQ $0x8, AX		
  0x40eeba		7571			JNE 0x40ef2d		
  0x40eebc		31c0			XORL AX, AX		
			*h.bitp &^= bitPointerAll
  0x40eebe		488b4c2468		MOVQ 0x68(SP), CX	
  0x40eec3		8b542464		MOVL 0x64(SP), DX	
  0x40eec7		488b5c2458		MOVQ 0x58(SP), BX	
  0x40eecc		8b742460		MOVL 0x60(SP), SI	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40eed0		eb47			JMP 0x40ef19		
  0x40eed2		4889442440		MOVQ AX, 0x40(SP)	
			*h.bitp &^= bitPointerAll
  0x40eed7		0fb603			MOVZX 0(BX), AX		
  0x40eeda		83e0f0			ANDL $-0x10, AX		
  0x40eedd		8803			MOVB AL, 0(BX)		
			h = h.forward(wordsPerBitmapByte)
  0x40eedf		48891c24		MOVQ BX, 0(SP)				
  0x40eee3		89742408		MOVL SI, 0x8(SP)			
  0x40eee7		8954240c		MOVL DX, 0xc(SP)			
  0x40eeeb		48894c2410		MOVQ CX, 0x10(SP)			
  0x40eef0		48c744241804000000	MOVQ $0x4, 0x18(SP)			
  0x40eef9		e8e2f0ffff		CALL runtime.heapBits.forward(SB)	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40eefe		488b442440		MOVQ 0x40(SP), AX	
  0x40ef03		4883c004		ADDQ $0x4, AX		
			h = h.forward(wordsPerBitmapByte)
  0x40ef07		488b5c2420		MOVQ 0x20(SP), BX	
  0x40ef0c		8b742428		MOVL 0x28(SP), SI	
  0x40ef10		8b54242c		MOVL 0x2c(SP), DX	
  0x40ef14		488b4c2430		MOVQ 0x30(SP), CX	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40ef19		488b7c2478		MOVQ 0x78(SP), DI	
  0x40ef1e		4839f8			CMPQ DI, AX		
  0x40ef21		72af			JB 0x40eed2		
		return
  0x40ef23		488b6c2448		MOVQ 0x48(SP), BP	
  0x40ef28		4883c450		ADDQ $0x50, SP		
  0x40ef2c		c3			RET			
  0x40ef2d		31c9			XORL CX, CX		
		*h.bitp &^= bitScan << (heapBitsShift + h.shift)
  0x40ef2f		8b542460		MOVL 0x60(SP), DX	
  0x40ef33		488b5c2458		MOVQ 0x58(SP), BX	
  0x40ef38		8b742464		MOVL 0x64(SP), SI	
  0x40ef3c		488b7c2468		MOVQ 0x68(SP), DI	
	for i := uintptr(0); i < n; i++ {
  0x40ef41		eb66			JMP 0x40efa9		
  0x40ef43		48894c2438		MOVQ CX, 0x38(SP)	
		*h.bitp &^= bitScan << (heapBitsShift + h.shift)
  0x40ef48		8d4a01			LEAL 0x1(DX), CX	
  0x40ef4b		83f920			CMPL $0x20, CX		
  0x40ef4e		4519c0			SBBL R8, R8		
  0x40ef51		440fb60b		MOVZX 0(BX), R9		
  0x40ef55		41ba10000000		MOVL $0x10, R10		
  0x40ef5b		41d3e2			SHLL CL, R10		
  0x40ef5e		4521c2			ANDL R8, R10		
  0x40ef61		41f7d2			NOTL R10		
  0x40ef64		4521ca			ANDL R9, R10		
  0x40ef67		448813			MOVB R10, 0(BX)		
		h = h.forward(size / sys.PtrSize)
  0x40ef6a		48891c24		MOVQ BX, 0(SP)				
  0x40ef6e		89542408		MOVL DX, 0x8(SP)			
  0x40ef72		8974240c		MOVL SI, 0xc(SP)			
  0x40ef76		48897c2410		MOVQ DI, 0x10(SP)			
  0x40ef7b		48c1e803		SHRQ $0x3, AX				
  0x40ef7f		4889442418		MOVQ AX, 0x18(SP)			
  0x40ef84		e857f0ffff		CALL runtime.heapBits.forward(SB)	
	for i := uintptr(0); i < n; i++ {
  0x40ef89		488b442438		MOVQ 0x38(SP), AX	
  0x40ef8e		488d4801		LEAQ 0x1(AX), CX	
		h = h.forward(size / sys.PtrSize)
  0x40ef92		488b5c2420		MOVQ 0x20(SP), BX	
  0x40ef97		8b542428		MOVL 0x28(SP), DX	
  0x40ef9b		8b74242c		MOVL 0x2c(SP), SI	
  0x40ef9f		488b7c2430		MOVQ 0x30(SP), DI	
  0x40efa4		488b442470		MOVQ 0x70(SP), AX	
	for i := uintptr(0); i < n; i++ {
  0x40efa9		4c8b442478		MOVQ 0x78(SP), R8	
  0x40efae		4c39c1			CMPQ R8, CX		
  0x40efb1		7290			JB 0x40ef43		
  0x40efb3		488b6c2448		MOVQ 0x48(SP), BP	
  0x40efb8		4883c450		ADDQ $0x50, SP		
  0x40efbc		c3			RET			
func (h heapBits) initCheckmarkSpan(size, n, total uintptr) {
  0x40efbd		e8be880300		CALL runtime.morestack_noctxt(SB)		
  0x40efc2		e9c9feffff		JMP runtime.heapBits.initCheckmarkSpan(SB)	

TEXT runtime.heapBits.clearCheckmarkSpan(SB) /usr/local/go/src/runtime/mbitmap.go
func (h heapBits) clearCheckmarkSpan(size, n, total uintptr) {
  0x40efd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40efd9		483b6110		CMPQ 0x10(CX), SP	
  0x40efdd		0f868a000000		JBE 0x40f06d		
  0x40efe3		4883ec48		SUBQ $0x48, SP		
  0x40efe7		48896c2440		MOVQ BP, 0x40(SP)	
  0x40efec		488d6c2440		LEAQ 0x40(SP), BP	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40eff1		488b442468		MOVQ 0x68(SP), AX	
  0x40eff6		4883f808		CMPQ $0x8, AX		
  0x40effa		7567			JNE 0x40f063		
  0x40effc		31c0			XORL AX, AX		
			*h.bitp |= bitPointerAll
  0x40effe		488b4c2460		MOVQ 0x60(SP), CX	
  0x40f003		8b54245c		MOVL 0x5c(SP), DX	
  0x40f007		8b5c2458		MOVL 0x58(SP), BX	
  0x40f00b		488b742450		MOVQ 0x50(SP), SI	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40f010		eb47			JMP 0x40f059		
  0x40f012		4889442438		MOVQ AX, 0x38(SP)	
			*h.bitp |= bitPointerAll
  0x40f017		0fb606			MOVZX 0(SI), AX		
  0x40f01a		83c80f			ORL $0xf, AX		
  0x40f01d		8806			MOVB AL, 0(SI)		
			h = h.forward(wordsPerBitmapByte)
  0x40f01f		48893424		MOVQ SI, 0(SP)				
  0x40f023		895c2408		MOVL BX, 0x8(SP)			
  0x40f027		8954240c		MOVL DX, 0xc(SP)			
  0x40f02b		48894c2410		MOVQ CX, 0x10(SP)			
  0x40f030		48c744241804000000	MOVQ $0x4, 0x18(SP)			
  0x40f039		e8a2efffff		CALL runtime.heapBits.forward(SB)	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40f03e		488b442438		MOVQ 0x38(SP), AX	
  0x40f043		4883c004		ADDQ $0x4, AX		
			h = h.forward(wordsPerBitmapByte)
  0x40f047		488b742420		MOVQ 0x20(SP), SI	
  0x40f04c		8b5c2428		MOVL 0x28(SP), BX	
  0x40f050		8b54242c		MOVL 0x2c(SP), DX	
  0x40f054		488b4c2430		MOVQ 0x30(SP), CX	
		for i := uintptr(0); i < n; i += wordsPerBitmapByte {
  0x40f059		488b7c2470		MOVQ 0x70(SP), DI	
  0x40f05e		4839f8			CMPQ DI, AX		
  0x40f061		72af			JB 0x40f012		
  0x40f063		488b6c2440		MOVQ 0x40(SP), BP	
  0x40f068		4883c448		ADDQ $0x48, SP		
  0x40f06c		c3			RET			
func (h heapBits) clearCheckmarkSpan(size, n, total uintptr) {
  0x40f06d		e80e880300		CALL runtime.morestack_noctxt(SB)		
  0x40f072		e959ffffff		JMP runtime.heapBits.clearCheckmarkSpan(SB)	

TEXT runtime.(*mspan).countAlloc(SB) /usr/local/go/src/runtime/mbitmap.go
	maxIndex := s.nelems / 8
  0x40f080		488b442408		MOVQ 0x8(SP), AX	
  0x40f085		488b4838		MOVQ 0x38(AX), CX	
  0x40f089		4889ca			MOVQ CX, DX		
  0x40f08c		48c1e903		SHRQ $0x3, CX		
  0x40f090		31db			XORL BX, BX		
  0x40f092		31f6			XORL SI, SI		
	for i := uintptr(0); i < maxIndex; i++ {
  0x40f094		eb21			JMP 0x40f0b7		
  0x40f096		488d7b01		LEAQ 0x1(BX), DI	
		mrkBits := *s.gcmarkBits.bytep(i)
  0x40f09a		4c8b4050		MOVQ 0x50(AX), R8	
  0x40f09e		460fb60403		MOVZX 0(BX)(R8*1), R8	
  0x40f0a3		90			NOPL			
		count += int(oneBitCount[mrkBits])
  0x40f0a4		4c8d0dd5020b00		LEAQ runtime.oneBitCount(SB), R9	
  0x40f0ab		470fb60401		MOVZX 0(R9)(R8*1), R8			
  0x40f0b0		4c01c6			ADDQ R8, SI				
	return addb((*uint8)(b), n)
  0x40f0b3		90			NOPL			
	for i := uintptr(0); i < maxIndex; i++ {
  0x40f0b4		4889fb			MOVQ DI, BX		
  0x40f0b7		4839cb			CMPQ CX, BX		
  0x40f0ba		72da			JB 0x40f096		
	if bitsInLastByte := s.nelems % 8; bitsInLastByte != 0 {
  0x40f0bc		48f7c207000000		TESTQ $0x7, DX		
  0x40f0c3		7434			JE 0x40f0f9		
  0x40f0c5		4883e207		ANDQ $0x7, DX		
		mrkBits := *s.gcmarkBits.bytep(maxIndex)
  0x40f0c9		488b4050		MOVQ 0x50(AX), AX	
  0x40f0cd		0fb60401		MOVZX 0(CX)(AX*1), AX	
  0x40f0d1		90			NOPL			
		mask := uint8((1 << bitsInLastByte) - 1)
  0x40f0d2		4889d1			MOVQ DX, CX		
  0x40f0d5		bb01000000		MOVL $0x1, BX		
  0x40f0da		d3e3			SHLL CL, BX		
  0x40f0dc		8d53ff			LEAL -0x1(BX), DX	
		bits := mrkBits & mask
  0x40f0df		21d0			ANDL DX, AX		
		count += int(oneBitCount[bits])
  0x40f0e1		0fb6c0			MOVZX AL, AX				
  0x40f0e4		488d1595020b00		LEAQ runtime.oneBitCount(SB), DX	
  0x40f0eb		0fb60410		MOVZX 0(AX)(DX*1), AX			
  0x40f0ef		4801f0			ADDQ SI, AX				
	return addb((*uint8)(b), n)
  0x40f0f2		90			NOPL			
	return count
  0x40f0f3		4889442410		MOVQ AX, 0x10(SP)	
  0x40f0f8		c3			RET			
  0x40f0f9		4889f0			MOVQ SI, AX		
	if bitsInLastByte := s.nelems % 8; bitsInLastByte != 0 {
  0x40f0fc		ebf5			JMP 0x40f0f3		

TEXT runtime.heapBitsSetType(SB) /usr/local/go/src/runtime/mbitmap.go
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40f100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40f109		488d4424b0		LEAQ -0x50(SP), AX	
  0x40f10e		483b4110		CMPQ 0x10(CX), AX	
  0x40f112		0f86390a0000		JBE 0x40fb51		
  0x40f118		4881ecd0000000		SUBQ $0xd0, SP		
  0x40f11f		4889ac24c8000000	MOVQ BP, 0xc8(SP)	
  0x40f127		488dac24c8000000	LEAQ 0xc8(SP), BP	
	if sys.PtrSize == 8 && size == sys.PtrSize {
  0x40f12f		488b9424e0000000	MOVQ 0xe0(SP), DX	
  0x40f137		4883fa08		CMPQ $0x8, DX		
  0x40f13b		0f8452090000		JE 0x40fa93		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f141		488b1d08780b00		MOVQ runtime.mheap_+784(SB), BX	
  0x40f148		8403			TESTB AL, 0(BX)			
	h := heapBitsForAddr(x)
  0x40f14a		90			NOPL			
	arena := arenaIndex(addr)
  0x40f14b		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f14c		90			NOPL			
  0x40f14d		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40f14e		488bb424d8000000	MOVQ 0xd8(SP), SI		
  0x40f156		48bf0000000000800000	MOVQ $0x800000000000, DI	
  0x40f160		4801f7			ADDQ SI, DI			
  0x40f163		48c1ef1a		SHRQ $0x1a, DI			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f167		4881ff00004000		CMPQ $0x400000, DI	
  0x40f16e		0f83d6090000		JAE 0x40fb4a		
  0x40f174		488b1cfb		MOVQ 0(BX)(DI*8), BX	
	if ha == nil {
  0x40f178		4885db			TESTQ BX, BX		
  0x40f17b		0f84fe080000		JE 0x40fa7f		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f181		4989f0			MOVQ SI, R8		
  0x40f184		48c1ee05		SHRQ $0x5, SI		
  0x40f188		4881e6ffff1f00		ANDQ $0x1fffff, SI	
  0x40f18f		4801de			ADDQ BX, SI		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x40f192		4d89c1			MOVQ R8, R9		
  0x40f195		49c1e803		SHRQ $0x3, R8		
  0x40f199		4983e003		ANDQ $0x3, R8		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40f19d		4881c3ffff1f00		ADDQ $0x1fffff, BX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40f1a4		4889f8			MOVQ DI, AX		
	ptrmask := typ.gcdata // start of 1-bit pointer mask (or GC program, handled below)
  0x40f1a7		4c8b9424f0000000	MOVQ 0xf0(SP), R10	
  0x40f1af		4d8b5a20		MOVQ 0x20(R10), R11	
	if size == 2*sys.PtrSize {
  0x40f1b3		4883fa10		CMPQ $0x10, DX		
  0x40f1b7		0f8450080000		JE 0x40fa0d		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f1bd		90			NOPL			
  0x40f1be		4e8d240a		LEAQ 0(DX)(R9*1), R12	
  0x40f1c2		4189fd			MOVL DI, R13		
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40f1c5		49beffffffffff7f0000	MOVQ $0x7fffffffffff, R14	
  0x40f1cf		4d01f4			ADDQ R14, R12			
  0x40f1d2		49c1ec1a		SHRQ $0x1a, R12			
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f1d6		4d39e5			CMPQ R12, R13		
  0x40f1d9		0f841b080000		JE 0x40f9fa		
		h.bitp = (*uint8)(unsafe.Pointer(x))
  0x40f1df		4c89cb			MOVQ R9, BX		
  0x40f1e2		31c9			XORL CX, CX		
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x40f1e4		4c89a42498000000	MOVQ R12, 0x98(SP)	
  0x40f1ec		4889842490000000	MOVQ AX, 0x90(SP)	
	if typ.kind&kindGCProg != 0 {
  0x40f1f4		410fb67217		MOVZX 0x17(R10), SI	
  0x40f1f9		40f6c640		TESTL $0x40, SI		
  0x40f1fd		0f8589070000		JNE 0x40f98c		
	if typ.size < dataSize {
  0x40f203		498b0a			MOVQ 0(R10), CX		
  0x40f206		488bb424e8000000	MOVQ 0xe8(SP), SI	
  0x40f20e		4839f1			CMPQ SI, CX		
  0x40f211		0f8357070000		JAE 0x40f96e		
		if typ.ptrdata/sys.PtrSize <= maxBits {
  0x40f217		498b7a08		MOVQ 0x8(R10), DI	
  0x40f21b		48c1ef03		SHRQ $0x3, DI		
  0x40f21f		4883ff39		CMPQ $0x39, DI		
  0x40f223		0f8706070000		JA 0x40f92f		
	if typ.size < dataSize {
  0x40f229		48898c2488000000	MOVQ CX, 0x88(SP)	
	ptrmask := typ.gcdata // start of 1-bit pointer mask (or GC program, handled below)
  0x40f231		4d89de			MOVQ R11, R14		
  0x40f234		4531ff			XORL R15, R15		
			pbits = b
  0x40f237		4531db			XORL R11, R11		
  0x40f23a		4c895c2450		MOVQ R11, 0x50(SP)	
				b |= uintptr(*p) << i
  0x40f23f		4d89f3			MOVQ R14, R11		
			for i := uintptr(0); i < nb; i += 8 {
  0x40f242		eb4c			JMP 0x40f290		
				b |= uintptr(*p) << i
  0x40f244		4983ff40		CMPQ $0x40, R15		
  0x40f248		4819db			SBBQ BX, BX		
			for i := uintptr(0); i < nb; i += 8 {
  0x40f24b		498d4708		LEAQ 0x8(R15), AX	
				b |= uintptr(*p) << i
  0x40f24f		450fb623		MOVZX 0(R11), R12	
  0x40f253		4c89f9			MOVQ R15, CX		
  0x40f256		49d3e4			SHLQ CL, R12		
  0x40f259		4921dc			ANDQ BX, R12		
  0x40f25c		488b4c2450		MOVQ 0x50(SP), CX	
  0x40f261		4c09e1			ORQ R12, CX		
				p = add1(p)
  0x40f264		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f265		49ffc3			INCQ R11		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f268		488b9c24d8000000	MOVQ 0xd8(SP), BX	
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f270		4c8ba42498000000	MOVQ 0x98(SP), R12	
			for i := uintptr(0); i < nb; i += 8 {
  0x40f278		4989c7			MOVQ AX, R15		
			pbits = b
  0x40f27b		48894c2450		MOVQ CX, 0x50(SP)	
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f280		488b842490000000	MOVQ 0x90(SP), AX	
			nb = typ.size / sys.PtrSize
  0x40f288		488b8c2488000000	MOVQ 0x88(SP), CX	
			for i := uintptr(0); i < nb; i += 8 {
  0x40f290		4939ff			CMPQ DI, R15		
  0x40f293		72af			JB 0x40f244		
			nb = typ.size / sys.PtrSize
  0x40f295		4889cf			MOVQ CX, DI		
  0x40f298		48c1e903		SHRQ $0x3, CX		
			if nb+nb <= maxBits {
  0x40f29c		4c8d1c09		LEAQ 0(CX)(CX*1), R11	
  0x40f2a0		4983fb39		CMPQ $0x39, R11		
  0x40f2a4		0f8775060000		JA 0x40f91f		
				for endnb <= sys.PtrSize*8 {
  0x40f2aa		4c8b5c2450		MOVQ 0x50(SP), R11	
			nb = typ.size / sys.PtrSize
  0x40f2af		4989cf			MOVQ CX, R15		
				for endnb <= sys.PtrSize*8 {
  0x40f2b2		eb21			JMP 0x40f2d5		
				pbits &= 1<<endnb - 1
  0x40f2b4		4c895c2450		MOVQ R11, 0x50(SP)	
					pbits |= pbits << endnb
  0x40f2b9		4819db			SBBQ BX, BX		
  0x40f2bc		49d3e3			SHLQ CL, R11		
  0x40f2bf		4921db			ANDQ BX, R11		
  0x40f2c2		488b5c2450		MOVQ 0x50(SP), BX	
  0x40f2c7		4909db			ORQ BX, R11		
					endnb += endnb
  0x40f2ca		4801c9			ADDQ CX, CX		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f2cd		488b9c24d8000000	MOVQ 0xd8(SP), BX	
				for endnb <= sys.PtrSize*8 {
  0x40f2d5		4883f940		CMPQ $0x40, CX		
  0x40f2d9		76d9			JBE 0x40f2b4		
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40f2db		4584ff			TESTL R15, R15		
  0x40f2de		0f845f080000		JE 0x40fb43		
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40f2e4		4889d9			MOVQ BX, CX		
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40f2e7		410fb6df		MOVZX R15, BX		
  0x40f2eb		41bc39000000		MOVL $0x39, R12		
  0x40f2f1		450fb6e4		MOVZX R12, R12		
  0x40f2f5		4489e0			MOVL R12, AX		
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40f2f8		4989d4			MOVQ DX, R12		
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40f2fb		31d2			XORL DX, DX		
  0x40f2fd		66f7f3			DIVW BX			
  0x40f300		0fb6d0			MOVZX AL, DX		
  0x40f303		490fafd7		IMULQ R15, DX		
				pbits &= 1<<endnb - 1
  0x40f307		4883fa40		CMPQ $0x40, DX		
  0x40f30b		4819db			SBBQ BX, BX		
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40f30e		4889c8			MOVQ CX, AX		
				pbits &= 1<<endnb - 1
  0x40f311		4889d1			MOVQ DX, CX		
  0x40f314		41bf01000000		MOVL $0x1, R15		
  0x40f31a		49d3e7			SHLQ CL, R15		
  0x40f31d		4921df			ANDQ BX, R15		
  0x40f320		498d5fff		LEAQ -0x1(R15), BX	
  0x40f324		4921db			ANDQ BX, R11		
				nb += endnb
  0x40f327		31d2			XORL DX, DX		
  0x40f329		31db			XORL BX, BX		
  0x40f32b		4989cf			MOVQ CX, R15		
	if p != nil {
  0x40f32e		4885d2			TESTQ DX, DX		
  0x40f331		0f84d8050000		JE 0x40f90f		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f337		4c89e9			MOVQ R13, CX		
		b = uintptr(*p)
  0x40f33a		440fb62a		MOVZX 0(DX), R13	
		p = add1(p)
  0x40f33e		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f33f		48ffc2			INCQ DX			
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40f342		4889442468		MOVQ AX, 0x68(SP)	
		nb -= 4
  0x40f347		b808000000		MOVL $0x8, AX		
  0x40f34c		4889442458		MOVQ AX, 0x58(SP)	
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f351		488b442468		MOVQ 0x68(SP), AX	
	if typ.size == dataSize {
  0x40f356		4839fe			CMPQ DI, SI		
  0x40f359		0f8576050000		JNE 0x40f8d5		
		nw = typ.ptrdata / sys.PtrSize
  0x40f35f		498b7208		MOVQ 0x8(R10), SI	
  0x40f363		48c1ee03		SHRQ $0x3, SI		
	if nw == 0 {
  0x40f367		4885f6			TESTQ SI, SI		
  0x40f36a		0f844e070000		JE 0x40fabe		
	if nw < 2 {
  0x40f370		4883fe02		CMPQ $0x2, SI		
		if w += 2; w >= nw {
  0x40f374		bf02000000		MOVL $0x2, DI		
  0x40f379		480f42f7		CMOVB DI, SI		
	case h.shift == 0:
  0x40f37d		4585c0			TESTL R8, R8		
	if nw < 2 {
  0x40f380		0f85ef040000		JNE 0x40f875		
		hb = b & bitPointerAll
  0x40f386		4c89ef			MOVQ R13, DI		
  0x40f389		4983e50f		ANDQ $0xf, R13		
		hb |= bitScan | bitScan<<(2*heapBitsShift) | bitScan<<(3*heapBitsShift)
  0x40f38d		4981cdd0000000		ORQ $0xd0, R13		
		if w += 4; w >= nw {
  0x40f394		4883fe04		CMPQ $0x4, SI		
  0x40f398		0f877e030000		JA 0x40f71c		
  0x40f39e		ba04000000		MOVL $0x4, DX		
	if w > nw {
  0x40f3a3		4839f2			CMPQ SI, DX		
  0x40f3a6		0f8665030000		JBE 0x40f711		
		mask := uintptr(1)<<(4-(w-nw)) - 1
  0x40f3ac		4889d3			MOVQ DX, BX		
  0x40f3af		4829f2			SUBQ SI, DX		
  0x40f3b2		4883c2fc		ADDQ $-0x4, DX		
  0x40f3b6		48f7da			NEGQ DX			
  0x40f3b9		4883fa40		CMPQ $0x40, DX		
  0x40f3bd		4819f6			SBBQ SI, SI		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f3c0		4889cf			MOVQ CX, DI		
		mask := uintptr(1)<<(4-(w-nw)) - 1
  0x40f3c3		4889d1			MOVQ DX, CX		
  0x40f3c6		41b801000000		MOVL $0x1, R8		
  0x40f3cc		49d3e0			SHLQ CL, R8		
  0x40f3cf		4921f0			ANDQ SI, R8		
  0x40f3d2		498d50ff		LEAQ -0x1(R8), DX	
		hb &= mask | mask<<4 // apply mask to both pointer bits and scan bits
  0x40f3d6		4889d6			MOVQ DX, SI		
  0x40f3d9		48c1e204		SHLQ $0x4, DX		
  0x40f3dd		4809f2			ORQ SI, DX		
  0x40f3e0		4921d5			ANDQ DX, R13		
	nw = size / sys.PtrSize
  0x40f3e3		4c89e1			MOVQ R12, CX		
  0x40f3e6		49c1ec03		SHRQ $0x3, R12		
	if w <= nw {
  0x40f3ea		4c39e3			CMPQ R12, BX		
  0x40f3ed		0f8710030000		JA 0x40f703		
		*hbitp = uint8(hb)
  0x40f3f3		458829			MOVB R13, 0(R9)		
		hbitp = add1(hbitp)
  0x40f3f6		90			NOPL			
		for w += 4; w <= nw; w += 4 {
  0x40f3f7		488d5304		LEAQ 0x4(BX), DX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f3fb		498d5901		LEAQ 0x1(R9), BX	
		for w += 4; w <= nw; w += 4 {
  0x40f3ff		eb0b			JMP 0x40f40c		
			*hbitp = 0
  0x40f401		c60300			MOVB $0x0, 0(BX)	
		for w += 4; w <= nw; w += 4 {
  0x40f404		4883c204		ADDQ $0x4, DX		
			hbitp = add1(hbitp)
  0x40f408		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f409		48ffc3			INCQ BX			
		for w += 4; w <= nw; w += 4 {
  0x40f40c		4c39e2			CMPQ R12, DX		
  0x40f40f		76f0			JBE 0x40f401		
  0x40f411		31f6			XORL SI, SI		
	if w == nw+2 {
  0x40f413		4d8d442402		LEAQ 0x2(R12), R8	
  0x40f418		4939d0			CMPQ DX, R8		
  0x40f41b		0f85d2020000		JNE 0x40f6f3		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f421		0fb613			MOVZX 0(BX), DX		
  0x40f424		83e2cc			ANDL $-0x34, DX		
  0x40f427		09d6			ORL DX, SI		
  0x40f429		408833			MOVB SI, 0(BX)		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f42c		488b942498000000	MOVQ 0x98(SP), DX	
  0x40f434		4839d7			CMPQ DX, DI		
	if outOfPlace {
  0x40f437		0f84ae010000		JE 0x40f5eb		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f43d		488b150c750b00		MOVQ runtime.mheap_+784(SB), DX	
  0x40f444		8402			TESTB AL, 0(DX)			
		h := heapBitsForAddr(x)
  0x40f446		90			NOPL			
	arena := arenaIndex(addr)
  0x40f447		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40f448		90			NOPL			
  0x40f449		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x40f451		488b14da		MOVQ 0(DX)(BX*8), DX	
  0x40f455		90			NOPL			
	if ha == nil {
  0x40f456		4885d2			TESTQ DX, DX		
  0x40f459		0f8484020000		JE 0x40f6e3		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f45f		4889c6			MOVQ AX, SI		
  0x40f462		48c1e805		SHRQ $0x5, AX		
  0x40f466		4825ffff1f00		ANDQ $0x1fffff, AX	
  0x40f46c		4801d0			ADDQ DX, AX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x40f46f		4889f7			MOVQ SI, DI		
  0x40f472		48c1ee03		SHRQ $0x3, SI		
  0x40f476		4883e603		ANDQ $0x3, SI		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x40f47a		4881c2ffff1f00		ADDQ $0x1fffff, DX	
		cnw := size / sys.PtrSize
  0x40f481		48c1e903		SHRQ $0x3, CX		
		src := (*uint8)(unsafe.Pointer(x))
  0x40f485		4989f8			MOVQ DI, R8		
		if sys.PtrSize == 8 && h.shift == 2 {
  0x40f488		83fe02			CMPL $0x2, SI		
  0x40f48b		0f8507010000		JNE 0x40f598		
			*h.bitp = *h.bitp&^((bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift)<<(2*heapBitsShift)) | *src
  0x40f491		440fb608		MOVZX 0(AX), R9		
  0x40f495		4183e133		ANDL $0x33, R9		
  0x40f499		440fb617		MOVZX 0(DI), R10	
  0x40f49d		4509d1			ORL R10, R9		
  0x40f4a0		448808			MOVB R9, 0(AX)		
			h = h.next().next()
  0x40f4a3		90			NOPL			
  0x40f4a4		90			NOPL			
		h.shift += heapBitsShift
  0x40f4a5		448d4e01		LEAL 0x1(SI), R9	
	if h.shift < 3*heapBitsShift {
  0x40f4a9		4183f903		CMPL $0x3, R9		
  0x40f4ad		0f83ca010000		JAE 0x40f67d		
		h.shift += heapBitsShift
  0x40f4b3		83c602			ADDL $0x2, SI		
			cnw -= 2
  0x40f4b6		4883c1fe		ADDQ $-0x2, CX		
			src = addb(src, 1)
  0x40f4ba		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f4bb		48ffc7			INCQ DI			
			src = addb(src, 1)
  0x40f4be		e9d5000000		JMP 0x40f598		
			*h.bitp = *h.bitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | *src
  0x40f4c3		48898424a8000000	MOVQ AX, 0xa8(SP)	
		for cnw >= 4 {
  0x40f4cb		48894c2460		MOVQ CX, 0x60(SP)	
			hNext, words := h.forwardOrBoundary(cnw / 4 * 4)
  0x40f4d0		48890424		MOVQ AX, 0(SP)					
  0x40f4d4		89742408		MOVL SI, 0x8(SP)				
  0x40f4d8		895c240c		MOVL BX, 0xc(SP)				
  0x40f4dc		4889542410		MOVQ DX, 0x10(SP)				
  0x40f4e1		48c1e902		SHRQ $0x2, CX					
  0x40f4e5		48c1e102		SHLQ $0x2, CX					
  0x40f4e9		48894c2418		MOVQ CX, 0x18(SP)				
  0x40f4ee		e8adebffff		CALL runtime.heapBits.forwardOrBoundary(SB)	
  0x40f4f3		488b442430		MOVQ 0x30(SP), AX				
  0x40f4f8		48898424c0000000	MOVQ AX, 0xc0(SP)				
  0x40f500		8b4c242c		MOVL 0x2c(SP), CX				
  0x40f504		894c2444		MOVL CX, 0x44(SP)				
  0x40f508		488b542438		MOVQ 0x38(SP), DX				
  0x40f50d		4889542448		MOVQ DX, 0x48(SP)				
  0x40f512		8b5c2428		MOVL 0x28(SP), BX				
  0x40f516		895c2440		MOVL BX, 0x40(SP)				
  0x40f51a		488b742420		MOVQ 0x20(SP), SI				
  0x40f51f		4889b424b8000000	MOVQ SI, 0xb8(SP)				
			memmove(unsafe.Pointer(h.bitp), unsafe.Pointer(src), n)
  0x40f527		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x40f52f		48893c24		MOVQ DI, 0(SP)		
  0x40f533		488bbc24a0000000	MOVQ 0xa0(SP), DI	
  0x40f53b		48897c2408		MOVQ DI, 0x8(SP)	
			n := words / 4
  0x40f540		48c1ea02		SHRQ $0x2, DX		
  0x40f544		4889942498000000	MOVQ DX, 0x98(SP)	
			memmove(unsafe.Pointer(h.bitp), unsafe.Pointer(src), n)
  0x40f54c		4889542410		MOVQ DX, 0x10(SP)		
  0x40f551		e8fab10300		CALL runtime.memmove(SB)	
			cnw -= words
  0x40f556		488b4c2460		MOVQ 0x60(SP), CX	
  0x40f55b		488b442448		MOVQ 0x48(SP), AX	
  0x40f560		4829c1			SUBQ AX, CX		
			src = addb(src, n)
  0x40f563		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f564		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x40f56c		488b942498000000	MOVQ 0x98(SP), DX	
  0x40f574		488d3c02		LEAQ 0(DX)(AX*1), DI	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f578		4c8b8424d8000000	MOVQ 0xd8(SP), R8	
			*h.bitp = *h.bitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | *src
  0x40f580		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x40f588		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x40f590		8b5c2444		MOVL 0x44(SP), BX	
  0x40f594		8b742440		MOVL 0x40(SP), SI	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f598		4889bc24a0000000	MOVQ DI, 0xa0(SP)	
		for cnw >= 4 {
  0x40f5a0		4883f904		CMPQ $0x4, CX		
  0x40f5a4		0f8319ffffff		JAE 0x40f4c3		
		if cnw == 2 {
  0x40f5aa		4883f902		CMPQ $0x2, CX		
  0x40f5ae		0f85c1000000		JNE 0x40f675		
			*h.bitp = *h.bitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | *src
  0x40f5b4		0fb608			MOVZX 0(AX), CX		
  0x40f5b7		83e1cc			ANDL $-0x34, CX		
  0x40f5ba		440fb60f		MOVZX 0(DI), R9		
  0x40f5be		4409c9			ORL R9, CX		
  0x40f5c1		8808			MOVB CL, 0(AX)		
			src = addb(src, 1)
  0x40f5c3		90			NOPL			
			h = h.next().next()
  0x40f5c4		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x40f5c5		83fe03			CMPL $0x3, SI		
  0x40f5c8		7361			JAE 0x40f62b		
		h.shift += heapBitsShift
  0x40f5ca		8d4e01			LEAL 0x1(SI), CX	
			h = h.next().next()
  0x40f5cd		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x40f5ce		83f903			CMPL $0x3, CX		
  0x40f5d1		7328			JAE 0x40f5fb		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f5d3		488d4701		LEAQ 0x1(DI), AX	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f5d7		4c89c1			MOVQ R8, CX				
  0x40f5da		4c890424		MOVQ R8, 0(SP)				
  0x40f5de		4829c8			SUBQ CX, AX				
  0x40f5e1		4889442408		MOVQ AX, 0x8(SP)			
  0x40f5e6		e8d5ae0300		CALL runtime.memclrNoHeapPointers(SB)	
  0x40f5eb		488bac24c8000000	MOVQ 0xc8(SP), BP			
  0x40f5f3		4881c4d0000000		ADDQ $0xd0, SP				
  0x40f5fa		c3			RET					
	} else if h.bitp != h.last {
  0x40f5fb		4839d0			CMPQ DX, AX		
  0x40f5fe		7403			JE 0x40f603		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40f600		90			NOPL			
			h = h.next().next()
  0x40f601		ebd0			JMP 0x40f5d3		
		return h.nextArena()
  0x40f603		48890424		MOVQ AX, 0(SP)				
  0x40f607		894c2408		MOVL CX, 0x8(SP)			
  0x40f60b		895c240c		MOVL BX, 0xc(SP)			
  0x40f60f		4889542410		MOVQ DX, 0x10(SP)			
  0x40f614		e857e9ffff		CALL runtime.heapBits.nextArena(SB)	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f619		488bbc24a0000000	MOVQ 0xa0(SP), DI	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f621		4c8b8424d8000000	MOVQ 0xd8(SP), R8	
			h = h.next().next()
  0x40f629		eba8			JMP 0x40f5d3		
	} else if h.bitp != h.last {
  0x40f62b		4839d0			CMPQ DX, AX		
  0x40f62e		7408			JE 0x40f638		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40f630		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f631		48ffc0			INCQ AX			
  0x40f634		31c9			XORL CX, CX		
			h = h.next().next()
  0x40f636		eb95			JMP 0x40f5cd		
		return h.nextArena()
  0x40f638		48890424		MOVQ AX, 0(SP)				
  0x40f63c		89742408		MOVL SI, 0x8(SP)			
  0x40f640		895c240c		MOVL BX, 0xc(SP)			
  0x40f644		4889542410		MOVQ DX, 0x10(SP)			
  0x40f649		e822e9ffff		CALL runtime.heapBits.nextArena(SB)	
  0x40f64e		488b542428		MOVQ 0x28(SP), DX			
  0x40f653		8b5c2424		MOVL 0x24(SP), BX			
  0x40f657		8b4c2420		MOVL 0x20(SP), CX			
  0x40f65b		488b442418		MOVQ 0x18(SP), AX			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f660		488bbc24a0000000	MOVQ 0xa0(SP), DI	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f668		4c8b8424d8000000	MOVQ 0xd8(SP), R8	
			h = h.next().next()
  0x40f670		e958ffffff		JMP 0x40f5cd		
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f675		4889f8			MOVQ DI, AX		
		if cnw == 2 {
  0x40f678		e95affffff		JMP 0x40f5d7		
	} else if h.bitp != h.last {
  0x40f67d		4839d0			CMPQ DX, AX		
  0x40f680		740b			JE 0x40f68d		
		h.bitp, h.shift = add1(h.bitp), 0
  0x40f682		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f683		48ffc0			INCQ AX			
  0x40f686		31f6			XORL SI, SI		
			h = h.next().next()
  0x40f688		e929feffff		JMP 0x40f4b6		
		cnw := size / sys.PtrSize
  0x40f68d		48898c2480000000	MOVQ CX, 0x80(SP)	
		src := (*uint8)(unsafe.Pointer(x))
  0x40f695		4889bc24b0000000	MOVQ DI, 0xb0(SP)	
		return h.nextArena()
  0x40f69d		48890424		MOVQ AX, 0(SP)				
  0x40f6a1		44894c2408		MOVL R9, 0x8(SP)			
  0x40f6a6		895c240c		MOVL BX, 0xc(SP)			
  0x40f6aa		4889542410		MOVQ DX, 0x10(SP)			
  0x40f6af		e8bce8ffff		CALL runtime.heapBits.nextArena(SB)	
  0x40f6b4		488b542428		MOVQ 0x28(SP), DX			
  0x40f6b9		8b742420		MOVL 0x20(SP), SI			
  0x40f6bd		8b5c2424		MOVL 0x24(SP), BX			
  0x40f6c1		488b442418		MOVQ 0x18(SP), AX			
			cnw -= 2
  0x40f6c6		488b8c2480000000	MOVQ 0x80(SP), CX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f6ce		488bbc24b0000000	MOVQ 0xb0(SP), DI	
		memclrNoHeapPointers(unsafe.Pointer(x), uintptr(unsafe.Pointer(src))-x)
  0x40f6d6		4c8b8424d8000000	MOVQ 0xd8(SP), R8	
			h = h.next().next()
  0x40f6de		e9d3fdffff		JMP 0x40f4b6		
		src := (*uint8)(unsafe.Pointer(x))
  0x40f6e3		4889c7			MOVQ AX, DI		
  0x40f6e6		31d2			XORL DX, DX		
  0x40f6e8		31db			XORL BX, BX		
  0x40f6ea		31f6			XORL SI, SI		
  0x40f6ec		31c0			XORL AX, AX		
		h := heapBitsForAddr(x)
  0x40f6ee		e98efdffff		JMP 0x40f481		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f6f3		488b942498000000	MOVQ 0x98(SP), DX	
  0x40f6fb		4839d7			CMPQ DX, DI		
	if w == nw+2 {
  0x40f6fe		e934fdffff		JMP 0x40f437		
  0x40f703		4889da			MOVQ BX, DX		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f706		4c89cb			MOVQ R9, BX		
  0x40f709		4c89ee			MOVQ R13, SI		
	if w <= nw {
  0x40f70c		e902fdffff		JMP 0x40f413		
  0x40f711		4889d3			MOVQ DX, BX		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f714		4889cf			MOVQ CX, DI		
	if w > nw {
  0x40f717		e9c7fcffff		JMP 0x40f3e3		
		*hbitp = uint8(hb)
  0x40f71c		458829			MOVB R13, 0(R9)		
		hbitp = add1(hbitp)
  0x40f71f		90			NOPL			
		b >>= 4
  0x40f720		48c1ef04		SHRQ $0x4, DI		
		nb -= 4
  0x40f724		4c8b442458		MOVQ 0x58(SP), R8	
  0x40f729		4983c0fc		ADDQ $-0x4, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f72d		49ffc1			INCQ R9			
  0x40f730		41ba04000000		MOVL $0x4, R10		
	nb -= 4
  0x40f736		4983c0fc		ADDQ $-0x4, R8		
	for {
  0x40f73a		eb24			JMP 0x40f760		
		*hbitp = uint8(hb)
  0x40f73c		45886901		MOVB R13, 0x1(R9)	
		hbitp = add1(hbitp)
  0x40f740		90			NOPL			
		b >>= 4
  0x40f741		48c1ea04		SHRQ $0x4, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f745		4983c102		ADDQ $0x2, R9		
		if w += 4; w >= nw {
  0x40f749		4d89c2			MOVQ R8, R10		
			b |= uintptr(*p) << nb
  0x40f74c		4989c8			MOVQ CX, R8		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f74f		4889f9			MOVQ DI, CX		
		hb = b & bitPointerAll
  0x40f752		4889d7			MOVQ DX, DI		
		if p != endp {
  0x40f755		4889c2			MOVQ AX, DX		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f758		488b8424d8000000	MOVQ 0xd8(SP), AX	
		hb = b & bitPointerAll
  0x40f760		4989fd			MOVQ DI, R13		
  0x40f763		4883e70f		ANDQ $0xf, DI		
		hb |= bitScanAll
  0x40f767		4881cff0000000		ORQ $0xf0, DI		
		if w += 4; w >= nw {
  0x40f76e		498d4204		LEAQ 0x4(R10), AX	
  0x40f772		4839f0			CMPQ SI, AX		
  0x40f775		0f83e9000000		JAE 0x40f864		
		*hbitp = uint8(hb)
  0x40f77b		418839			MOVB DI, 0(R9)		
		hbitp = add1(hbitp)
  0x40f77e		90			NOPL			
		b >>= 4
  0x40f77f		49c1ed04		SHRQ $0x4, R13		
		if p != endp {
  0x40f783		4839d3			CMPQ DX, BX		
  0x40f786		745a			JE 0x40f7e2		
			if nb < 8 {
  0x40f788		4983f808		CMPQ $0x8, R8		
  0x40f78c		7345			JAE 0x40f7d3		
				b |= uintptr(*p) << nb
  0x40f78e		0fb602			MOVZX 0(DX), AX		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f791		4889cf			MOVQ CX, DI		
				b |= uintptr(*p) << nb
  0x40f794		4c89c1			MOVQ R8, CX		
  0x40f797		48d3e0			SHLQ CL, AX		
  0x40f79a		4909c5			ORQ AX, R13		
				p = add1(p)
  0x40f79d		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f79e		488d4201		LEAQ 0x1(DX), AX	
		hb = b & bitPointerAll
  0x40f7a2		4c89ea			MOVQ R13, DX		
  0x40f7a5		4983e50f		ANDQ $0xf, R13		
		hb |= bitScanAll
  0x40f7a9		4981cdf0000000		ORQ $0xf0, R13		
		if w += 4; w >= nw {
  0x40f7b0		4d8d4208		LEAQ 0x8(R10), R8	
  0x40f7b4		4939f0			CMPQ SI, R8		
  0x40f7b7		7283			JB 0x40f73c		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f7b9		498d4101		LEAQ 0x1(R9), AX	
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f7bd		4889f9			MOVQ DI, CX		
	if w > nw {
  0x40f7c0		4c89c2			MOVQ R8, DX		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f7c3		4989c1			MOVQ AX, R9		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f7c6		488b8424d8000000	MOVQ 0xd8(SP), AX	
	if w > nw {
  0x40f7ce		e9d0fbffff		JMP 0x40f3a3		
				nb -= 8
  0x40f7d3		4983c0f8		ADDQ $-0x8, R8		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f7d7		4889cf			MOVQ CX, DI		
		if p != endp {
  0x40f7da		4889d0			MOVQ DX, AX		
			b |= uintptr(*p) << nb
  0x40f7dd		4c89c1			MOVQ R8, CX		
				nb -= 8
  0x40f7e0		ebc0			JMP 0x40f7a2		
		} else if p == nil {
  0x40f7e2		4885d2			TESTQ DX, DX		
  0x40f7e5		744d			JE 0x40f834		
			b |= uintptr(*p) << nb
  0x40f7e7		4983f840		CMPQ $0x40, R8		
  0x40f7eb		4819c0			SBBQ AX, AX		
  0x40f7ee		0fb612			MOVZX 0(DX), DX		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f7f1		4889cf			MOVQ CX, DI		
			b |= uintptr(*p) << nb
  0x40f7f4		4c89c1			MOVQ R8, CX		
  0x40f7f7		48d3e2			SHLQ CL, DX		
  0x40f7fa		4821d0			ANDQ DX, AX		
  0x40f7fd		4909c5			ORQ AX, R13		
			nb += endnb
  0x40f800		4a8d0439		LEAQ 0(CX)(R15*1), AX	
			if nb < 8 {
  0x40f804		4883f808		CMPQ $0x8, AX		
  0x40f808		731d			JAE 0x40f827		
				b |= uintptr(*ptrmask) << nb
  0x40f80a		410fb616		MOVZX 0(R14), DX	
  0x40f80e		4889c1			MOVQ AX, CX		
  0x40f811		48d3e2			SHLQ CL, DX		
  0x40f814		4909d5			ORQ DX, R13		
				p = add1(ptrmask)
  0x40f817		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f818		498d5601		LEAQ 0x1(R14), DX	
			b |= uintptr(*p) << nb
  0x40f81c		4889c1			MOVQ AX, CX		
		if p != endp {
  0x40f81f		4889d0			MOVQ DX, AX		
		hb = b & bitPointerAll
  0x40f822		e97bffffff		JMP 0x40f7a2		
				nb -= 8
  0x40f827		4a8d0439		LEAQ 0(CX)(R15*1), AX	
  0x40f82b		488d40f8		LEAQ -0x8(AX), AX	
		if p != endp {
  0x40f82f		4c89f2			MOVQ R14, DX		
				p = ptrmask
  0x40f832		ebe8			JMP 0x40f81c		
			if nb < 8 {
  0x40f834		4983f808		CMPQ $0x8, R8		
  0x40f838		7322			JAE 0x40f85c		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f83a		4889c8			MOVQ CX, AX		
				b |= pbits << nb
  0x40f83d		4c89c1			MOVQ R8, CX		
  0x40f840		4c89df			MOVQ R11, DI		
  0x40f843		49d3e3			SHLQ CL, R11		
  0x40f846		4d09dd			ORQ R11, R13		
				nb += endnb
  0x40f849		4e8d0439		LEAQ 0(CX)(R15*1), R8	
			nb -= 8 // for next iteration
  0x40f84d		4983c0f8		ADDQ $-0x8, R8		
				b |= pbits << nb
  0x40f851		4989fb			MOVQ DI, R11		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f854		4889c7			MOVQ AX, DI		
			b |= uintptr(*p) << nb
  0x40f857		4c89c0			MOVQ R8, AX		
			nb -= 8 // for next iteration
  0x40f85a		ebc0			JMP 0x40f81c		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f85c		4889c8			MOVQ CX, AX		
				b |= pbits << nb
  0x40f85f		4c89df			MOVQ R11, DI		
			if nb < 8 {
  0x40f862		ebe9			JMP 0x40f84d		
	if w > nw {
  0x40f864		4989c0			MOVQ AX, R8		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f867		4c89c8			MOVQ R9, AX		
  0x40f86a		4989fd			MOVQ DI, R13		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f86d		4889cf			MOVQ CX, DI		
			break
  0x40f870		e948ffffff		JMP 0x40f7bd		
	case sys.PtrSize == 8 && h.shift == 2:
  0x40f875		4183f802		CMPL $0x2, R8		
	switch {
  0x40f879		0f8524020000		JNE 0x40faa3		
		hb = (b & (bitPointer | bitPointer<<heapBitsShift)) << (2 * heapBitsShift)
  0x40f87f		4c89ef			MOVQ R13, DI		
  0x40f882		4983e503		ANDQ $0x3, R13		
  0x40f886		49c1e502		SHLQ $0x2, R13		
		hb |= bitScan << (2 * heapBitsShift)
  0x40f88a		4983cd40		ORQ $0x40, R13		
		*hbitp &^= uint8((bitPointer | bitScan | (bitPointer << heapBitsShift)) << (2 * heapBitsShift))
  0x40f88e		450fb601		MOVZX 0(R9), R8		
  0x40f892		4183e0b3		ANDL $-0x4d, R8		
		*hbitp |= uint8(hb)
  0x40f896		4509e8			ORL R13, R8		
  0x40f899		458801			MOVB R8, 0(R9)		
		hbitp = add1(hbitp)
  0x40f89c		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x40f89d		4d8d4101		LEAQ 0x1(R9), R8	
		if w += 2; w >= nw {
  0x40f8a1		4883fe02		CMPQ $0x2, SI		
  0x40f8a5		7710			JA 0x40f8b7		
			w += 4
  0x40f8a7		ba06000000		MOVL $0x6, DX		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f8ac		4d89c1			MOVQ R8, R9		
  0x40f8af		4531ed			XORL R13, R13		
			goto Phase3
  0x40f8b2		e9ecfaffff		JMP 0x40f3a3		
		b >>= 2
  0x40f8b7		48c1ef02		SHRQ $0x2, DI		
		nb -= 2
  0x40f8bb		4c8b6c2458		MOVQ 0x58(SP), R13	
  0x40f8c0		4983c5fe		ADDQ $-0x2, R13		
  0x40f8c4		41ba02000000		MOVL $0x2, R10		
		*hbitp = *hbitp&^(bitPointer|bitScan|(bitPointer|bitScan)<<heapBitsShift) | uint8(hb)
  0x40f8ca		4d89c1			MOVQ R8, R9		
	nb -= 4
  0x40f8cd		4d89e8			MOVQ R13, R8		
	switch {
  0x40f8d0		e961feffff		JMP 0x40f736		
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40f8d5		4885ff			TESTQ DI, DI		
  0x40f8d8		0f845e020000		JE 0x40fb3c		
  0x40f8de		4889f0			MOVQ SI, AX		
		if p != endp {
  0x40f8e1		4889d6			MOVQ DX, SI		
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40f8e4		31d2			XORL DX, DX		
  0x40f8e6		48f7f7			DIVQ DI			
	if typ.size < dataSize {
  0x40f8e9		4889fa			MOVQ DI, DX		
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40f8ec		488d78ff		LEAQ -0x1(AX), DI	
  0x40f8f0		480faffa		IMULQ DX, DI		
  0x40f8f4		49037a08		ADDQ 0x8(R10), DI	
  0x40f8f8		48c1ef03		SHRQ $0x3, DI		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f8fc		488b8424d8000000	MOVQ 0xd8(SP), AX	
		if p != endp {
  0x40f904		4889f2			MOVQ SI, DX		
	if nw == 0 {
  0x40f907		4889fe			MOVQ DI, SI		
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40f90a		e958faffff		JMP 0x40f367		
		nb -= 4
  0x40f90f		48894c2458		MOVQ CX, 0x58(SP)	
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f914		4c89e9			MOVQ R13, CX		
		hb = (b & (bitPointer | bitPointer<<heapBitsShift)) << (2 * heapBitsShift)
  0x40f917		4d89dd			MOVQ R11, R13		
	if p != nil {
  0x40f91a		e937faffff		JMP 0x40f356		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f91f		4889d8			MOVQ BX, AX		
	nw = size / sys.PtrSize
  0x40f922		4989d4			MOVQ DX, R12		
				b |= pbits << nb
  0x40f925		4c8b5c2450		MOVQ 0x50(SP), R11	
			if nb+nb <= maxBits {
  0x40f92a		e9f8f9ffff		JMP 0x40f327		
			n := (typ.ptrdata/sys.PtrSize+7)/8 - 1
  0x40f92f		4883c707		ADDQ $0x7, DI		
  0x40f933		48c1ef03		SHRQ $0x3, DI		
  0x40f937		4c8d77ff		LEAQ -0x1(DI), R14	
			endp = addb(ptrmask, n)
  0x40f93b		90			NOPL			
			endnb = typ.size/sys.PtrSize - n*8
  0x40f93c		4989cf			MOVQ CX, R15		
  0x40f93f		49c1ef03		SHRQ $0x3, R15		
  0x40f943		49c1e603		SHLQ $0x3, R14		
  0x40f947		4d29f7			SUBQ R14, R15		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f94a		4d89de			MOVQ R11, R14		
  0x40f94d		4a8d3c1f		LEAQ 0(DI)(R11*1), DI	
  0x40f951		488d7fff		LEAQ -0x1(DI), DI	
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f955		4889d8			MOVQ BX, AX		
	nw = size / sys.PtrSize
  0x40f958		4989d4			MOVQ DX, R12		
	if p != nil {
  0x40f95b		4c89f2			MOVQ R14, DX		
		if p != endp {
  0x40f95e		4889fb			MOVQ DI, BX		
  0x40f961		4531db			XORL R11, R11		
	if typ.size == dataSize {
  0x40f964		4889cf			MOVQ CX, DI		
  0x40f967		31c9			XORL CX, CX		
			endnb = typ.size/sys.PtrSize - n*8
  0x40f969		e9c0f9ffff		JMP 0x40f32e		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f96e		4889d8			MOVQ BX, AX		
	if typ.size == dataSize {
  0x40f971		4889cf			MOVQ CX, DI		
	nw = size / sys.PtrSize
  0x40f974		4989d4			MOVQ DX, R12		
				b |= uintptr(*ptrmask) << nb
  0x40f977		4d89de			MOVQ R11, R14		
	if p != nil {
  0x40f97a		4c89f2			MOVQ R14, DX		
  0x40f97d		31c9			XORL CX, CX		
  0x40f97f		31db			XORL BX, BX		
  0x40f981		4531db			XORL R11, R11		
  0x40f984		4531ff			XORL R15, R15		
	if typ.size < dataSize {
  0x40f987		e9a2f9ffff		JMP 0x40f32e		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f98c		4c896c2478		MOVQ R13, 0x78(SP)	
		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4))
  0x40f991		498b4208		MOVQ 0x8(R10), AX	
  0x40f995		498b1a			MOVQ 0(R10), BX		
  0x40f998		90			NOPL			
  0x40f999		4c890c24		MOVQ R9, 0(SP)		
  0x40f99d		4489442408		MOVL R8, 0x8(SP)	
  0x40f9a2		897c240c		MOVL DI, 0xc(SP)	
  0x40f9a6		48894c2410		MOVQ CX, 0x10(SP)	
  0x40f9ab		4889442418		MOVQ AX, 0x18(SP)	
  0x40f9b0		48895c2420		MOVQ BX, 0x20(SP)	
  0x40f9b5		488b8424e8000000	MOVQ 0xe8(SP), AX	
  0x40f9bd		4889442428		MOVQ AX, 0x28(SP)	
  0x40f9c2		4889542430		MOVQ DX, 0x30(SP)	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40f9c7		498d4304		LEAQ 0x4(R11), AX	
		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4))
  0x40f9cb		4889442438		MOVQ AX, 0x38(SP)			
  0x40f9d0		e88b010000		CALL runtime.heapBitsSetTypeGCProg(SB)	
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40f9d5		488b442478		MOVQ 0x78(SP), AX	
  0x40f9da		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x40f9e2		4839c8			CMPQ CX, AX		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40f9e5		488b8424d8000000	MOVQ 0xd8(SP), AX	
		cnw := size / sys.PtrSize
  0x40f9ed		488b8c24e0000000	MOVQ 0xe0(SP), CX	
		goto Phase4
  0x40f9f5		e93dfaffff		JMP 0x40f437		
	hbitp = h.bitp
  0x40f9fa		4889d9			MOVQ BX, CX		
  0x40f9fd		4989f1			MOVQ SI, R9		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x40fa00		488b9c24d8000000	MOVQ 0xd8(SP), BX	
	hbitp = h.bitp
  0x40fa08		e9d7f7ffff		JMP 0x40f1e4		
		if typ.size == sys.PtrSize {
  0x40fa0d		49833a08		CMPQ $0x8, 0(R10)	
  0x40fa11		7529			JNE 0x40fa3c		
				*h.bitp |= (bitPointer | bitScan | bitPointer<<heapBitsShift) << h.shift
  0x40fa13		4183f820		CMPL $0x20, R8		
  0x40fa17		19c0			SBBL AX, AX		
  0x40fa19		0fb616			MOVZX 0(SI), DX		
  0x40fa1c		4489c1			MOVL R8, CX		
  0x40fa1f		bb13000000		MOVL $0x13, BX		
  0x40fa24		d3e3			SHLL CL, BX		
  0x40fa26		21c3			ANDL AX, BX		
  0x40fa28		09da			ORL BX, DX		
  0x40fa2a		8816			MOVB DL, 0(SI)		
			return
  0x40fa2c		488bac24c8000000	MOVQ 0xc8(SP), BP	
  0x40fa34		4881c4d0000000		ADDQ $0xd0, SP		
  0x40fa3b		c3			RET			
		*h.bitp |= uint8(hb << h.shift)
  0x40fa3c		4183f820		CMPL $0x20, R8		
		*h.bitp &^= (bitPointer | bitScan | ((bitPointer | bitScan) << heapBitsShift)) << h.shift
  0x40fa40		19c0			SBBL AX, AX		
		*h.bitp |= uint8(hb << h.shift)
  0x40fa42		19d2			SBBL DX, DX		
		b := uint32(*ptrmask)
  0x40fa44		410fb61b		MOVZX 0(R11), BX	
		hb := (b & 3) | bitScan
  0x40fa48		83e303			ANDL $0x3, BX		
  0x40fa4b		83cb10			ORL $0x10, BX		
		*h.bitp &^= (bitPointer | bitScan | ((bitPointer | bitScan) << heapBitsShift)) << h.shift
  0x40fa4e		0fb63e			MOVZX 0(SI), DI		
  0x40fa51		4489c1			MOVL R8, CX		
  0x40fa54		41b933000000		MOVL $0x33, R9		
  0x40fa5a		41d3e1			SHLL CL, R9		
  0x40fa5d		4121c1			ANDL AX, R9		
  0x40fa60		41f7d1			NOTL R9			
  0x40fa63		4121f9			ANDL DI, R9		
		*h.bitp |= uint8(hb << h.shift)
  0x40fa66		d3e3			SHLL CL, BX		
  0x40fa68		21d3			ANDL DX, BX		
  0x40fa6a		4409cb			ORL R9, BX		
  0x40fa6d		881e			MOVB BL, 0(SI)		
		return
  0x40fa6f		488bac24c8000000	MOVQ 0xc8(SP), BP	
  0x40fa77		4881c4d0000000		ADDQ $0xd0, SP		
  0x40fa7e		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40fa7f		4889f8			MOVQ DI, AX		
	if arenaIndex(x+size-1) != arenaIdx(h.arena) || (doubleCheck && fastrand()%2 == 0) {
  0x40fa82		4989f1			MOVQ SI, R9		
  0x40fa85		31db			XORL BX, BX		
  0x40fa87		31ff			XORL DI, DI		
  0x40fa89		4531c0			XORL R8, R8		
  0x40fa8c		31f6			XORL SI, SI		
	h := heapBitsForAddr(x)
  0x40fa8e		e914f7ffff		JMP 0x40f1a7		
		return
  0x40fa93		488bac24c8000000	MOVQ 0xc8(SP), BP	
  0x40fa9b		4881c4d0000000		ADDQ $0xd0, SP		
  0x40faa2		c3			RET			
		throw("heapBitsSetType: unexpected shift")
  0x40faa3		488d05af260600		LEAQ 0x626af(IP), AX	
  0x40faaa		48890424		MOVQ AX, 0(SP)		
  0x40faae		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x40fab7		e8c4390100		CALL runtime.throw(SB)	
  0x40fabc		0f0b			UD2			
		println("runtime: invalid type ", typ.string())
  0x40fabe		4c891424		MOVQ R10, 0(SP)				
  0x40fac2		e8291c0300		CALL runtime.(*_type).string(SB)	
  0x40fac7		488b442408		MOVQ 0x8(SP), AX			
  0x40facc		48898424c0000000	MOVQ AX, 0xc0(SP)			
  0x40fad4		488b4c2410		MOVQ 0x10(SP), CX			
  0x40fad9		48894c2470		MOVQ CX, 0x70(SP)			
  0x40fade		e8dd430100		CALL runtime.printlock(SB)		
  0x40fae3		488d0532120600		LEAQ 0x61232(IP), AX			
  0x40faea		48890424		MOVQ AX, 0(SP)				
  0x40faee		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x40faf7		e8f44c0100		CALL runtime.printstring(SB)		
  0x40fafc		488b8424c0000000	MOVQ 0xc0(SP), AX			
  0x40fb04		48890424		MOVQ AX, 0(SP)				
  0x40fb08		488b442470		MOVQ 0x70(SP), AX			
  0x40fb0d		4889442408		MOVQ AX, 0x8(SP)			
  0x40fb12		e8d94c0100		CALL runtime.printstring(SB)		
  0x40fb17		e834460100		CALL runtime.printnl(SB)		
  0x40fb1c		e81f440100		CALL runtime.printunlock(SB)		
		throw("heapBitsSetType: called with non-pointer type")
  0x40fb21		488d0560330600		LEAQ 0x63360(IP), AX	
  0x40fb28		48890424		MOVQ AX, 0(SP)		
  0x40fb2c		48c74424082d000000	MOVQ $0x2d, 0x8(SP)	
  0x40fb35		e846390100		CALL runtime.throw(SB)	
  0x40fb3a		0f0b			UD2			
		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
  0x40fb3c		e83f260100		CALL runtime.panicdivide(SB)	
  0x40fb41		0f0b			UD2				
				endnb = uintptr(maxBits/byte(nb)) * nb
  0x40fb43		e838260100		CALL runtime.panicdivide(SB)	
  0x40fb48		0f0b			UD2				
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x40fb4a		e8d1230100		CALL runtime.panicindex(SB)	
  0x40fb4f		0f0b			UD2				
func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
  0x40fb51		e82a7d0300		CALL runtime.morestack_noctxt(SB)	
  0x40fb56		e9a5f5ffff		JMP runtime.heapBitsSetType(SB)		

TEXT runtime.heapBitsSetTypeGCProg(SB) /usr/local/go/src/runtime/mbitmap.go
func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte) {
  0x40fb60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fb69		483b6110		CMPQ 0x10(CX), SP	
  0x40fb6d		0f864d030000		JBE 0x40fec0		
  0x40fb73		4883ec60		SUBQ $0x60, SP		
  0x40fb77		48896c2458		MOVQ BP, 0x58(SP)	
  0x40fb7c		488d6c2458		LEAQ 0x58(SP), BP	
	if sys.PtrSize == 8 && allocSize%(4*sys.PtrSize) != 0 {
  0x40fb81		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x40fb89		48f7c11f000000		TESTQ $0x1f, CX		
  0x40fb90		0f850f030000		JNE 0x40fea5		
	if elemSize == dataSize {
  0x40fb96		488b942488000000	MOVQ 0x88(SP), DX	
  0x40fb9e		488b842490000000	MOVQ 0x90(SP), AX	
  0x40fba6		4839c2			CMPQ AX, DX		
  0x40fba9		0f84e9010000		JE 0x40fd98		
		count := dataSize / elemSize
  0x40fbaf		4885d2			TESTQ DX, DX		
  0x40fbb2		0f8466020000		JE 0x40fe1e		
  0x40fbb8		4889d3			MOVQ DX, BX		
  0x40fbbb		31d2			XORL DX, DX		
  0x40fbbd		48f7f3			DIVQ BX			
		var trailer [40]byte // 3 varints (max 10 each) + some bytes
  0x40fbc0		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x40fbc9		0f57c0			XORPS X0, X0		
  0x40fbcc		0f11442438		MOVUPS X0, 0x38(SP)	
  0x40fbd1		0f11442448		MOVUPS X0, 0x48(SP)	
		if n := elemSize/sys.PtrSize - progSize/sys.PtrSize; n > 0 {
  0x40fbd6		4889da			MOVQ BX, DX		
  0x40fbd9		48c1eb03		SHRQ $0x3, BX		
  0x40fbdd		488bb42480000000	MOVQ 0x80(SP), SI	
  0x40fbe5		4889f7			MOVQ SI, DI		
  0x40fbe8		48c1ee03		SHRQ $0x3, SI		
  0x40fbec		4989d8			MOVQ BX, R8		
  0x40fbef		4829f3			SUBQ SI, BX		
  0x40fbf2		4885db			TESTQ BX, BX		
  0x40fbf5		0f8696010000		JBE 0x40fd91		
			trailer[i] = 0x01
  0x40fbfb		c644243001		MOVB $0x1, 0x30(SP)	
			if n > 1 {
  0x40fc00		4883fb01		CMPQ $0x1, BX		
  0x40fc04		0f867d010000		JBE 0x40fd87		
				trailer[i] = 0x81
  0x40fc0a		c644243281		MOVB $0x81, 0x32(SP)	
				n--
  0x40fc0f		48ffcb			DECQ BX			
				i++
  0x40fc12		be03000000		MOVL $0x3, SI		
				for ; n >= 0x80; n >>= 7 {
  0x40fc17		eb16			JMP 0x40fc2f		
					trailer[i] = byte(n | 0x80)
  0x40fc19		4989d9			MOVQ BX, R9		
  0x40fc1c		480fbaeb07		BTSQ $0x7, BX		
  0x40fc21		885c3430		MOVB BL, 0x30(SP)(SI*1)	
				for ; n >= 0x80; n >>= 7 {
  0x40fc25		49c1e907		SHRQ $0x7, R9		
					i++
  0x40fc29		48ffc6			INCQ SI			
				for ; n >= 0x80; n >>= 7 {
  0x40fc2c		4c89cb			MOVQ R9, BX		
  0x40fc2f		4881fb80000000		CMPQ $0x80, BX		
  0x40fc36		720b			JB 0x40fc43		
					trailer[i] = byte(n | 0x80)
  0x40fc38		4883fe28		CMPQ $0x28, SI		
  0x40fc3c		72db			JB 0x40fc19		
  0x40fc3e		e9d4010000		JMP 0x40fe17		
				trailer[i] = byte(n)
  0x40fc43		4883fe28		CMPQ $0x28, SI		
  0x40fc47		0f83c3010000		JAE 0x40fe10		
  0x40fc4d		885c3430		MOVB BL, 0x30(SP)(SI*1)	
				i++
  0x40fc51		488d5e01		LEAQ 0x1(SI), BX	
		trailer[i] = 0x80
  0x40fc55		4883fb28		CMPQ $0x28, BX			
  0x40fc59		0f83aa010000		JAE 0x40fe09			
  0x40fc5f		c6441c3080		MOVB $0x80, 0x30(SP)(BX*1)	
		i++
  0x40fc64		48ffc3			INCQ BX			
		for ; n >= 0x80; n >>= 7 {
  0x40fc67		eb17			JMP 0x40fc80		
			trailer[i] = byte(n | 0x80)
  0x40fc69		4c89c6			MOVQ R8, SI		
  0x40fc6c		490fbae807		BTSQ $0x7, R8		
  0x40fc71		4488441c30		MOVB R8, 0x30(SP)(BX*1)	
		for ; n >= 0x80; n >>= 7 {
  0x40fc76		48c1ee07		SHRQ $0x7, SI		
			i++
  0x40fc7a		48ffc3			INCQ BX			
		for ; n >= 0x80; n >>= 7 {
  0x40fc7d		4989f0			MOVQ SI, R8		
  0x40fc80		4981f880000000		CMPQ $0x80, R8		
  0x40fc87		720b			JB 0x40fc94		
			trailer[i] = byte(n | 0x80)
  0x40fc89		4883fb28		CMPQ $0x28, BX		
  0x40fc8d		72da			JB 0x40fc69		
  0x40fc8f		e96e010000		JMP 0x40fe02		
		trailer[i] = byte(n)
  0x40fc94		4883fb28		CMPQ $0x28, BX		
  0x40fc98		0f835d010000		JAE 0x40fdfb		
  0x40fc9e		4488441c30		MOVB R8, 0x30(SP)(BX*1)	
		i++
  0x40fca3		48ffc3			INCQ BX			
		n = count - 1
  0x40fca6		48ffc8			DECQ AX			
  0x40fca9		4889c6			MOVQ AX, SI		
		for ; n >= 0x80; n >>= 7 {
  0x40fcac		eb16			JMP 0x40fcc4		
			trailer[i] = byte(n | 0x80)
  0x40fcae		4989c0			MOVQ AX, R8		
  0x40fcb1		480fbae807		BTSQ $0x7, AX		
  0x40fcb6		88441c30		MOVB AL, 0x30(SP)(BX*1)	
		for ; n >= 0x80; n >>= 7 {
  0x40fcba		49c1e807		SHRQ $0x7, R8		
			i++
  0x40fcbe		48ffc3			INCQ BX			
		for ; n >= 0x80; n >>= 7 {
  0x40fcc1		4c89c0			MOVQ R8, AX		
  0x40fcc4		483d80000000		CMPQ $0x80, AX		
  0x40fcca		720b			JB 0x40fcd7		
			trailer[i] = byte(n | 0x80)
  0x40fccc		4883fb28		CMPQ $0x28, BX		
  0x40fcd0		72dc			JB 0x40fcae		
  0x40fcd2		e91d010000		JMP 0x40fdf4		
		trailer[i] = byte(n)
  0x40fcd7		4883fb28		CMPQ $0x28, BX		
  0x40fcdb		0f830c010000		JAE 0x40fded		
  0x40fce1		88441c30		MOVB AL, 0x30(SP)(BX*1)	
		i++
  0x40fce5		488d4301		LEAQ 0x1(BX), AX	
		trailer[i] = 0
  0x40fce9		4883f828		CMPQ $0x28, AX		
  0x40fced		0f83f3000000		JAE 0x40fde6		
		n = count - 1
  0x40fcf3		4889742428		MOVQ SI, 0x28(SP)	
		trailer[i] = 0
  0x40fcf8		c6441c3100		MOVB $0x0, 0x31(SP)(BX*1)	
		runGCProg(prog, &trailer[0], h.bitp, 2)
  0x40fcfd		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x40fd05		48890424		MOVQ AX, 0(SP)			
  0x40fd09		488d442430		LEAQ 0x30(SP), AX		
  0x40fd0e		4889442408		MOVQ AX, 0x8(SP)		
  0x40fd13		488b442468		MOVQ 0x68(SP), AX		
  0x40fd18		4889442410		MOVQ AX, 0x10(SP)		
  0x40fd1d		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x40fd26		e8d5020000		CALL runtime.runGCProg(SB)	
		totalBits = (elemSize*(count-1) + progSize) / sys.PtrSize
  0x40fd2b		488b842488000000	MOVQ 0x88(SP), AX	
  0x40fd33		488b4c2428		MOVQ 0x28(SP), CX	
  0x40fd38		480fafc1		IMULQ CX, AX		
  0x40fd3c		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x40fd44		4801c8			ADDQ CX, AX		
  0x40fd47		48c1e803		SHRQ $0x3, AX		
	endProg := unsafe.Pointer(addb(h.bitp, (totalBits+3)/4))
  0x40fd4b		90			NOPL			
  0x40fd4c		4883c003		ADDQ $0x3, AX		
  0x40fd50		48c1e802		SHRQ $0x2, AX		
	endAlloc := unsafe.Pointer(addb(h.bitp, allocSize/sys.PtrSize/wordsPerBitmapByte))
  0x40fd54		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40fd55		488b4c2468		MOVQ 0x68(SP), CX	
  0x40fd5a		4801c8			ADDQ CX, AX		
	memclrNoHeapPointers(endProg, uintptr(endAlloc)-uintptr(endProg))
  0x40fd5d		48890424		MOVQ AX, 0(SP)		
	endAlloc := unsafe.Pointer(addb(h.bitp, allocSize/sys.PtrSize/wordsPerBitmapByte))
  0x40fd61		488b942498000000	MOVQ 0x98(SP), DX	
  0x40fd69		48c1ea05		SHRQ $0x5, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x40fd6d		4801d1			ADDQ DX, CX		
	memclrNoHeapPointers(endProg, uintptr(endAlloc)-uintptr(endProg))
  0x40fd70		4829c1			SUBQ AX, CX				
  0x40fd73		48894c2408		MOVQ CX, 0x8(SP)			
  0x40fd78		e843a70300		CALL runtime.memclrNoHeapPointers(SB)	
}
  0x40fd7d		488b6c2458		MOVQ 0x58(SP), BP	
  0x40fd82		4883c460		ADDQ $0x60, SP		
  0x40fd86		c3			RET			
  0x40fd87		bb02000000		MOVL $0x2, BX		
			if n > 1 {
  0x40fd8c		e9c4feffff		JMP 0x40fc55		
  0x40fd91		31db			XORL BX, BX		
		if n := elemSize/sys.PtrSize - progSize/sys.PtrSize; n > 0 {
  0x40fd93		e9bdfeffff		JMP 0x40fc55		
		totalBits = runGCProg(prog, nil, h.bitp, 2)
  0x40fd98		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x40fda0		48890424		MOVQ AX, 0(SP)			
  0x40fda4		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x40fdad		488b442468		MOVQ 0x68(SP), AX		
  0x40fdb2		4889442410		MOVQ AX, 0x10(SP)		
  0x40fdb7		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x40fdc0		e83b020000		CALL runtime.runGCProg(SB)	
  0x40fdc5		488b442420		MOVQ 0x20(SP), AX		
		if totalBits*sys.PtrSize != progSize {
  0x40fdca		4889c1			MOVQ AX, CX		
  0x40fdcd		48c1e003		SHLQ $0x3, AX		
  0x40fdd1		488b942480000000	MOVQ 0x80(SP), DX	
  0x40fdd9		4839d0			CMPQ DX, AX		
  0x40fddc		7547			JNE 0x40fe25		
	endProg := unsafe.Pointer(addb(h.bitp, (totalBits+3)/4))
  0x40fdde		4889c8			MOVQ CX, AX		
  0x40fde1		e965ffffff		JMP 0x40fd4b		
		trailer[i] = 0
  0x40fde6		e835210100		CALL runtime.panicindex(SB)	
  0x40fdeb		0f0b			UD2				
		trailer[i] = byte(n)
  0x40fded		e82e210100		CALL runtime.panicindex(SB)	
  0x40fdf2		0f0b			UD2				
			trailer[i] = byte(n | 0x80)
  0x40fdf4		e827210100		CALL runtime.panicindex(SB)	
  0x40fdf9		0f0b			UD2				
		trailer[i] = byte(n)
  0x40fdfb		e820210100		CALL runtime.panicindex(SB)	
  0x40fe00		0f0b			UD2				
			trailer[i] = byte(n | 0x80)
  0x40fe02		e819210100		CALL runtime.panicindex(SB)	
  0x40fe07		0f0b			UD2				
		trailer[i] = 0x80
  0x40fe09		e812210100		CALL runtime.panicindex(SB)	
  0x40fe0e		0f0b			UD2				
				trailer[i] = byte(n)
  0x40fe10		e80b210100		CALL runtime.panicindex(SB)	
  0x40fe15		0f0b			UD2				
					trailer[i] = byte(n | 0x80)
  0x40fe17		e804210100		CALL runtime.panicindex(SB)	
  0x40fe1c		0f0b			UD2				
		count := dataSize / elemSize
  0x40fe1e		e85d230100		CALL runtime.panicdivide(SB)	
  0x40fe23		0f0b			UD2				
		totalBits = runGCProg(prog, nil, h.bitp, 2)
  0x40fe25		48894c2428		MOVQ CX, 0x28(SP)	
			println("runtime: heapBitsSetTypeGCProg: total bits", totalBits, "but progSize", progSize)
  0x40fe2a		e891400100		CALL runtime.printlock(SB)	
  0x40fe2f		488d05202f0600		LEAQ 0x62f20(IP), AX		
  0x40fe36		48890424		MOVQ AX, 0(SP)			
  0x40fe3a		48c74424082b000000	MOVQ $0x2b, 0x8(SP)		
  0x40fe43		e8a8490100		CALL runtime.printstring(SB)	
  0x40fe48		488b442428		MOVQ 0x28(SP), AX		
  0x40fe4d		48890424		MOVQ AX, 0(SP)			
  0x40fe51		e8ea460100		CALL runtime.printuint(SB)	
  0x40fe56		488d0599fe0500		LEAQ 0x5fe99(IP), AX		
  0x40fe5d		48890424		MOVQ AX, 0(SP)			
  0x40fe61		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x40fe6a		e881490100		CALL runtime.printstring(SB)	
  0x40fe6f		488b842480000000	MOVQ 0x80(SP), AX		
  0x40fe77		48890424		MOVQ AX, 0(SP)			
  0x40fe7b		e8c0460100		CALL runtime.printuint(SB)	
  0x40fe80		e8cb420100		CALL runtime.printnl(SB)	
  0x40fe85		e8b6400100		CALL runtime.printunlock(SB)	
			throw("heapBitsSetTypeGCProg: unexpected bit count")
  0x40fe8a		488d056f2e0600		LEAQ 0x62e6f(IP), AX	
  0x40fe91		48890424		MOVQ AX, 0(SP)		
  0x40fe95		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x40fe9e		e8dd350100		CALL runtime.throw(SB)	
  0x40fea3		0f0b			UD2			
		throw("heapBitsSetTypeGCProg: small allocation")
  0x40fea5		488d053e290600		LEAQ 0x6293e(IP), AX	
  0x40feac		48890424		MOVQ AX, 0(SP)		
  0x40feb0		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x40feb9		e8c2350100		CALL runtime.throw(SB)	
  0x40febe		0f0b			UD2			
func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte) {
  0x40fec0		e8bb790300		CALL runtime.morestack_noctxt(SB)	
  0x40fec5		e996fcffff		JMP runtime.heapBitsSetTypeGCProg(SB)	

TEXT runtime.progToPointerMask(SB) /usr/local/go/src/runtime/mbitmap.go
func progToPointerMask(prog *byte, size uintptr) bitvector {
  0x40fed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x40fed9		483b6110		CMPQ 0x10(CX), SP	
  0x40fedd		0f8609010000		JBE 0x40ffec		
  0x40fee3		4883ec48		SUBQ $0x48, SP		
  0x40fee7		48896c2440		MOVQ BP, 0x40(SP)	
  0x40feec		488d6c2440		LEAQ 0x40(SP), BP	
	n := (size/sys.PtrSize + 7) / 8
  0x40fef1		488b442458		MOVQ 0x58(SP), AX	
  0x40fef6		48c1e803		SHRQ $0x3, AX		
  0x40fefa		4883c007		ADDQ $0x7, AX		
  0x40fefe		48c1e803		SHRQ $0x3, AX		
  0x40ff02		4889442430		MOVQ AX, 0x30(SP)	
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40ff07		488d4801		LEAQ 0x1(AX), CX			
  0x40ff0b		48894c2428		MOVQ CX, 0x28(SP)			
  0x40ff10		48890c24		MOVQ CX, 0(SP)				
  0x40ff14		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x40ff1d		488d15ccdd0c00		LEAQ runtime.memstats+144(SB), DX	
  0x40ff24		4889542410		MOVQ DX, 0x10(SP)			
  0x40ff29		e842abffff		CALL runtime.persistentalloc(SB)	
  0x40ff2e		488b442418		MOVQ 0x18(SP), AX			
  0x40ff33		8400			TESTB AL, 0(AX)				
  0x40ff35		488b4c2428		MOVQ 0x28(SP), CX			
  0x40ff3a		4885c9			TESTQ CX, CX				
  0x40ff3d		0f8ca2000000		JL 0x40ffe5				
  0x40ff43		4881f900000040		CMPQ $0x40000000, CX			
  0x40ff4a		0f8795000000		JA 0x40ffe5				
	x[len(x)-1] = 0xa1 // overflow check sentinel
  0x40ff50		488b542430		MOVQ 0x30(SP), DX	
  0x40ff55		4839ca			CMPQ CX, DX		
  0x40ff58		0f8380000000		JAE 0x40ffde		
  0x40ff5e		c60402a1		MOVB $0xa1, 0(DX)(AX*1)	
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40ff62		4885c9			TESTQ CX, CX		
	n = runGCProg(prog, nil, &x[0], 1)
  0x40ff65		7670			JBE 0x40ffd7		
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40ff67		4889442438		MOVQ AX, 0x38(SP)	
	n = runGCProg(prog, nil, &x[0], 1)
  0x40ff6c		488b4c2450		MOVQ 0x50(SP), CX		
  0x40ff71		48890c24		MOVQ CX, 0(SP)			
  0x40ff75		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x40ff7e		4889442410		MOVQ AX, 0x10(SP)		
  0x40ff83		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x40ff8c		e86f000000		CALL runtime.runGCProg(SB)	
  0x40ff91		488b442420		MOVQ 0x20(SP), AX		
	if x[len(x)-1] != 0xa1 {
  0x40ff96		488b4c2438		MOVQ 0x38(SP), CX	
  0x40ff9b		488b542430		MOVQ 0x30(SP), DX	
  0x40ffa0		0fb6140a		MOVZX 0(DX)(CX*1), DX	
  0x40ffa4		80faa1			CMPL $0xa1, DL		
  0x40ffa7		7513			JNE 0x40ffbc		
	return bitvector{int32(n), &x[0]}
  0x40ffa9		89442460		MOVL AX, 0x60(SP)	
  0x40ffad		48894c2468		MOVQ CX, 0x68(SP)	
  0x40ffb2		488b6c2440		MOVQ 0x40(SP), BP	
  0x40ffb7		4883c448		ADDQ $0x48, SP		
  0x40ffbb		c3			RET			
		throw("progToPointerMask: overflow")
  0x40ffbc		488d0598140600		LEAQ 0x61498(IP), AX	
  0x40ffc3		48890424		MOVQ AX, 0(SP)		
  0x40ffc7		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x40ffd0		e8ab340100		CALL runtime.throw(SB)	
  0x40ffd5		0f0b			UD2			
	n = runGCProg(prog, nil, &x[0], 1)
  0x40ffd7		e8441f0100		CALL runtime.panicindex(SB)	
  0x40ffdc		0f0b			UD2				
	x[len(x)-1] = 0xa1 // overflow check sentinel
  0x40ffde		e83d1f0100		CALL runtime.panicindex(SB)	
  0x40ffe3		0f0b			UD2				
	x := (*[1 << 30]byte)(persistentalloc(n+1, 1, &memstats.buckhash_sys))[:n+1]
  0x40ffe5		e866200100		CALL runtime.panicslice(SB)	
  0x40ffea		0f0b			UD2				
func progToPointerMask(prog *byte, size uintptr) bitvector {
  0x40ffec		e88f780300		CALL runtime.morestack_noctxt(SB)	
  0x40fff1		e9dafeffff		JMP runtime.progToPointerMask(SB)	

TEXT runtime.runGCProg(SB) /usr/local/go/src/runtime/mbitmap.go
func runGCProg(prog, trailer, dst *byte, size int) uintptr {
  0x410000		4883ec08		SUBQ $0x8, SP		
  0x410004		48892c24		MOVQ BP, 0(SP)		
  0x410008		488d2c24		LEAQ 0(SP), BP		
  0x41000c		31c0			XORL AX, AX		
		inst := uintptr(*p)
  0x41000e		488b4c2410		MOVQ 0x10(SP), CX	
				if trailer != nil {
  0x410013		488b542418		MOVQ 0x18(SP), DX	
		totalBits = (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*4 + nbits
  0x410018		488b5c2420		MOVQ 0x20(SP), BX	
  0x41001d		31f6			XORL SI, SI		
		for ; nbits >= 8; nbits -= 8 {
  0x41001f		e988000000		JMP 0x4100ac		
  0x410024		4883c0f8		ADDQ $-0x8, AX		
  0x410028		4883f808		CMPQ $0x8, AX		
  0x41002c		7246			JB 0x410074		
			if size == 1 {
  0x41002e		4883ff01		CMPQ $0x1, DI		
  0x410032		750d			JNE 0x410041		
				*dst = uint8(bits)
  0x410034		408833			MOVB SI, 0(BX)		
				dst = add1(dst)
  0x410037		90			NOPL			
				bits >>= 8
  0x410038		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x41003c		48ffc3			INCQ BX			
				bits >>= 8
  0x41003f		ebe3			JMP 0x410024		
				v := bits&bitPointerAll | bitScanAll
  0x410041		4989f0			MOVQ SI, R8		
  0x410044		4883e60f		ANDQ $0xf, SI		
  0x410048		4881cef0000000		ORQ $0xf0, SI		
				*dst = uint8(v)
  0x41004f		408833			MOVB SI, 0(BX)		
				dst = add1(dst)
  0x410052		90			NOPL			
				bits >>= 4
  0x410053		4c89c6			MOVQ R8, SI		
  0x410056		49c1e804		SHRQ $0x4, R8		
				v = bits&bitPointerAll | bitScanAll
  0x41005a		4983e00f		ANDQ $0xf, R8		
  0x41005e		4981c8f0000000		ORQ $0xf0, R8		
				*dst = uint8(v)
  0x410065		44884301		MOVB R8, 0x1(BX)	
				dst = add1(dst)
  0x410069		90			NOPL			
				bits >>= 4
  0x41006a		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x41006e		4883c302		ADDQ $0x2, BX		
				bits >>= 4
  0x410072		ebb0			JMP 0x410024		
		inst := uintptr(*p)
  0x410074		440fb601		MOVZX 0(CX), R8		
		p = add1(p)
  0x410078		90			NOPL			
		n := inst & 0x7F
  0x410079		4d89c1			MOVQ R8, R9		
  0x41007c		4983e07f		ANDQ $0x7f, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x410080		4c8d5101		LEAQ 0x1(CX), R10	
		if inst&0x80 == 0 {
  0x410084		410fbae107		BTL $0x7, R9		
  0x410089		0f825a010000		JB 0x4101e9		
			if n == 0 {
  0x41008f		49f7c17f000000		TESTQ $0x7f, R9		
  0x410096		0f85a5000000		JNE 0x410141		
				if trailer != nil {
  0x41009c		4885d2			TESTQ DX, DX		
  0x41009f		7415			JE 0x4100b6		
  0x4100a1		31c9			XORL CX, CX		
		inst := uintptr(*p)
  0x4100a3		4989c8			MOVQ CX, R8		
  0x4100a6		4889d1			MOVQ DX, CX		
				if trailer != nil {
  0x4100a9		4c89c2			MOVQ R8, DX		
		for ; nbits >= 8; nbits -= 8 {
  0x4100ac		488b7c2428		MOVQ 0x28(SP), DI	
  0x4100b1		e972ffffff		JMP 0x410028		
	if size == 1 {
  0x4100b6		4883ff01		CMPQ $0x1, DI		
  0x4100ba		7540			JNE 0x4100fc		
		totalBits = (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*8 + nbits
  0x4100bc		4889d9			MOVQ BX, CX		
  0x4100bf		488b542420		MOVQ 0x20(SP), DX	
  0x4100c4		4829d3			SUBQ DX, BX		
  0x4100c7		488d14d8		LEAQ 0(AX)(BX*8), DX	
		nbits += -nbits & 7
  0x4100cb		4889c3			MOVQ AX, BX		
  0x4100ce		48f7d8			NEGQ AX			
  0x4100d1		4883e007		ANDQ $0x7, AX		
  0x4100d5		4801d8			ADDQ BX, AX		
		for ; nbits > 0; nbits -= 8 {
  0x4100d8		eb0f			JMP 0x4100e9		
			*dst = uint8(bits)
  0x4100da		408831			MOVB SI, 0(CX)		
		for ; nbits > 0; nbits -= 8 {
  0x4100dd		4883c0f8		ADDQ $-0x8, AX		
			dst = add1(dst)
  0x4100e1		90			NOPL			
			bits >>= 8
  0x4100e2		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4100e6		48ffc1			INCQ CX			
		for ; nbits > 0; nbits -= 8 {
  0x4100e9		4885c0			TESTQ AX, AX		
  0x4100ec		77ec			JA 0x4100da		
	return totalBits
  0x4100ee		4889542430		MOVQ DX, 0x30(SP)	
  0x4100f3		488b2c24		MOVQ 0(SP), BP		
  0x4100f7		4883c408		ADDQ $0x8, SP		
  0x4100fb		c3			RET			
		totalBits = (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*4 + nbits
  0x4100fc		4889d9			MOVQ BX, CX		
  0x4100ff		488b542420		MOVQ 0x20(SP), DX	
  0x410104		4829d3			SUBQ DX, BX		
  0x410107		488d1498		LEAQ 0(AX)(BX*4), DX	
		nbits += -nbits & 3
  0x41010b		4889c3			MOVQ AX, BX		
  0x41010e		48f7d8			NEGQ AX			
  0x410111		4883e003		ANDQ $0x3, AX		
  0x410115		4801d8			ADDQ BX, AX		
		for ; nbits > 0; nbits -= 4 {
  0x410118		eb20			JMP 0x41013a		
			v := bits&0xf | bitScanAll
  0x41011a		4889f3			MOVQ SI, BX		
  0x41011d		4883e60f		ANDQ $0xf, SI		
  0x410121		4881cef0000000		ORQ $0xf0, SI		
			*dst = uint8(v)
  0x410128		408831			MOVB SI, 0(CX)		
		for ; nbits > 0; nbits -= 4 {
  0x41012b		4883c0fc		ADDQ $-0x4, AX		
			dst = add1(dst)
  0x41012f		90			NOPL			
			bits >>= 4
  0x410130		48c1eb04		SHRQ $0x4, BX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x410134		48ffc1			INCQ CX			
			v := bits&0xf | bitScanAll
  0x410137		4889de			MOVQ BX, SI		
		for ; nbits > 0; nbits -= 4 {
  0x41013a		4885c0			TESTQ AX, AX		
  0x41013d		77db			JA 0x41011a		
  0x41013f		ebad			JMP 0x4100ee		
			nbyte := n / 8
  0x410141		49c1e803		SHRQ $0x3, R8		
  0x410145		31c9			XORL CX, CX		
			for i := uintptr(0); i < nbyte; i++ {
  0x410147		eb0b			JMP 0x410154		
  0x410149		4d8d5c2401		LEAQ 0x1(R12), R11	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x41014e		49ffc2			INCQ R10		
			for i := uintptr(0); i < nbyte; i++ {
  0x410151		4c89d9			MOVQ R11, CX		
  0x410154		4c39c1			CMPQ R8, CX		
  0x410157		7357			JAE 0x4101b0		
				bits |= uintptr(*p) << nbits
  0x410159		450fb61a		MOVZX 0(R10), R11	
			for i := uintptr(0); i < nbyte; i++ {
  0x41015d		4989cc			MOVQ CX, R12		
				bits |= uintptr(*p) << nbits
  0x410160		4889c1			MOVQ AX, CX		
  0x410163		49d3e3			SHLQ CL, R11		
  0x410166		4c09de			ORQ R11, SI		
				p = add1(p)
  0x410169		90			NOPL			
				if size == 1 {
  0x41016a		4883ff01		CMPQ $0x1, DI		
  0x41016e		750d			JNE 0x41017d		
					*dst = uint8(bits)
  0x410170		408833			MOVB SI, 0(BX)		
					dst = add1(dst)
  0x410173		90			NOPL			
					bits >>= 8
  0x410174		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x410178		48ffc3			INCQ BX			
					bits >>= 8
  0x41017b		ebcc			JMP 0x410149		
					v := bits&0xf | bitScanAll
  0x41017d		4989f3			MOVQ SI, R11		
  0x410180		4883e60f		ANDQ $0xf, SI		
  0x410184		4881cef0000000		ORQ $0xf0, SI		
					*dst = uint8(v)
  0x41018b		408833			MOVB SI, 0(BX)		
					dst = add1(dst)
  0x41018e		90			NOPL			
					bits >>= 4
  0x41018f		4c89de			MOVQ R11, SI		
  0x410192		49c1eb04		SHRQ $0x4, R11		
					v = bits&0xf | bitScanAll
  0x410196		4983e30f		ANDQ $0xf, R11		
  0x41019a		4981cbf0000000		ORQ $0xf0, R11		
					*dst = uint8(v)
  0x4101a1		44885b01		MOVB R11, 0x1(BX)	
					dst = add1(dst)
  0x4101a5		90			NOPL			
					bits >>= 4
  0x4101a6		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4101aa		4883c302		ADDQ $0x2, BX		
					bits >>= 4
  0x4101ae		eb99			JMP 0x410149		
			if n %= 8; n > 0 {
  0x4101b0		49f7c107000000		TESTQ $0x7, R9		
  0x4101b7		7628			JBE 0x4101e1		
  0x4101b9		4983e107		ANDQ $0x7, R9		
				bits |= uintptr(*p) << nbits
  0x4101bd		450fb602		MOVZX 0(R10), R8	
  0x4101c1		4889c1			MOVQ AX, CX		
  0x4101c4		49d3e0			SHLQ CL, R8		
  0x4101c7		4c09c6			ORQ R8, SI		
				p = add1(p)
  0x4101ca		90			NOPL			
				nbits += n
  0x4101cb		4d8d0401		LEAQ 0(R9)(AX*1), R8	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4101cf		4d8d4a01		LEAQ 0x1(R10), R9	
		for ; nbits >= 8; nbits -= 8 {
  0x4101d3		4c89c0			MOVQ R8, AX		
				if trailer != nil {
  0x4101d6		4889d1			MOVQ DX, CX		
		inst := uintptr(*p)
  0x4101d9		4c89ca			MOVQ R9, DX		
			continue Run
  0x4101dc		e9c2feffff		JMP 0x4100a3		
		for ; nbits >= 8; nbits -= 8 {
  0x4101e1		4989c0			MOVQ AX, R8		
		inst := uintptr(*p)
  0x4101e4		4d89d1			MOVQ R10, R9		
			if n %= 8; n > 0 {
  0x4101e7		ebea			JMP 0x4101d3		
		if n == 0 {
  0x4101e9		49f7c17f000000		TESTQ $0x7f, R9		
  0x4101f0		0f854d040000		JNE 0x410643		
  0x4101f6		31c9			XORL CX, CX		
				x := uintptr(*p)
  0x4101f8		eb07			JMP 0x410201		
			for off := uint(0); ; off += 7 {
  0x4101fa		4883c107		ADDQ $0x7, CX		
				x := uintptr(*p)
  0x4101fe		4d89ca			MOVQ R9, R10		
				n |= (x & 0x7F) << off
  0x410201		4883f940		CMPQ $0x40, CX		
  0x410205		4d19c9			SBBQ R9, R9		
				x := uintptr(*p)
  0x410208		450fb61a		MOVZX 0(R10), R11	
				p = add1(p)
  0x41020c		90			NOPL			
				n |= (x & 0x7F) << off
  0x41020d		4d89dc			MOVQ R11, R12		
  0x410210		4983e37f		ANDQ $0x7f, R11		
  0x410214		49d3e3			SHLQ CL, R11		
  0x410217		4d21cb			ANDQ R9, R11		
  0x41021a		4d09d8			ORQ R11, R8		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x41021d		4d8d4a01		LEAQ 0x1(R10), R9	
				if x&0x80 == 0 {
  0x410221		410fbae407		BTL $0x7, R12		
  0x410226		72d2			JB 0x4101fa		
		c *= n // now total number of bits to copy
  0x410228		31c9			XORL CX, CX		
  0x41022a		4531d2			XORL R10, R10		
			x := uintptr(*p)
  0x41022d		eb07			JMP 0x410236		
		for off := uint(0); ; off += 7 {
  0x41022f		4c8d5107		LEAQ 0x7(CX), R10	
			c |= (x & 0x7F) << off
  0x410233		4c89f1			MOVQ R14, CX		
  0x410236		4983fa40		CMPQ $0x40, R10		
  0x41023a		4d19db			SBBQ R11, R11		
			x := uintptr(*p)
  0x41023d		450fb621		MOVZX 0(R9), R12	
			p = add1(p)
  0x410241		90			NOPL			
			c |= (x & 0x7F) << off
  0x410242		4d89e5			MOVQ R12, R13		
  0x410245		4983e47f		ANDQ $0x7f, R12		
  0x410249		4989ce			MOVQ CX, R14		
  0x41024c		4c89d1			MOVQ R10, CX		
  0x41024f		49d3e4			SHLQ CL, R12		
  0x410252		4d21dc			ANDQ R11, R12		
  0x410255		4d09e6			ORQ R12, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x410258		49ffc1			INCQ R9			
			if x&0x80 == 0 {
  0x41025b		410fbae507		BTL $0x7, R13		
  0x410260		72cd			JB 0x41022f		
		c *= n // now total number of bits to copy
  0x410262		4d0faff0		IMULQ R8, R14		
		if n <= maxBits {
  0x410266		4983f839		CMPQ $0x39, R8		
  0x41026a		0f87f1010000		JA 0x410461		
			if size == 1 {
  0x410270		4883ff01		CMPQ $0x1, DI		
  0x410274		0f85b9010000		JNE 0x410433		
				src = subtract1(src)
  0x41027a		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x41027b		4c8d53ff		LEAQ -0x1(BX), R10	
		for ; nbits >= 8; nbits -= 8 {
  0x41027f		4889c1			MOVQ AX, CX		
			v := bits&0xf | bitScanAll
  0x410282		4989f3			MOVQ SI, R11		
				for npattern < n {
  0x410285		eb13			JMP 0x41029a		
					pattern <<= 8
  0x410287		48c1e608		SHLQ $0x8, SI		
					pattern |= uintptr(*src)
  0x41028b		450fb622		MOVZX 0(R10), R12	
  0x41028f		4c09e6			ORQ R12, SI		
					src = subtract1(src)
  0x410292		90			NOPL			
					npattern += 8
  0x410293		4883c008		ADDQ $0x8, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x410297		49ffca			DECQ R10		
				for npattern < n {
  0x41029a		4c39c0			CMPQ R8, AX		
  0x41029d		72e8			JB 0x410287		
			if npattern > n {
  0x41029f		4c39c0			CMPQ R8, AX		
  0x4102a2		0f8680010000		JBE 0x410428		
				pattern >>= npattern - n
  0x4102a8		4c29c0			SUBQ R8, AX		
  0x4102ab		4883f840		CMPQ $0x40, AX		
  0x4102af		4d19d2			SBBQ R10, R10		
		for ; nbits >= 8; nbits -= 8 {
  0x4102b2		4989cc			MOVQ CX, R12		
				pattern >>= npattern - n
  0x4102b5		4889c1			MOVQ AX, CX		
  0x4102b8		48d3ee			SHRQ CL, SI		
  0x4102bb		4c21d6			ANDQ R10, SI		
			if npattern == 1 {
  0x4102be		4983f801		CMPQ $0x1, R8		
  0x4102c2		0f85e8000000		JNE 0x4103b0		
				if pattern == 1 {
  0x4102c8		4883fe01		CMPQ $0x1, SI			
  0x4102cc		0f85d3000000		JNE 0x4103a5			
  0x4102d2		b839000000		MOVL $0x39, AX			
  0x4102d7		48b9ffffffffffffff01	MOVQ $0x1ffffffffffffff, CX	
			for ; c >= npattern; c -= npattern {
  0x4102e1		eb1e			JMP 0x410301		
						*dst = uint8(bits)
  0x4102e3		44881b			MOVB R11, 0(BX)		
						dst = add1(dst)
  0x4102e6		90			NOPL			
						bits >>= 8
  0x4102e7		49c1eb08		SHRQ $0x8, R11		
						nbits -= 8
  0x4102eb		4883c6f8		ADDQ $-0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4102ef		48ffc3			INCQ BX			
					for nbits >= 8 {
  0x4102f2		4883fe08		CMPQ $0x8, SI		
  0x4102f6		73eb			JAE 0x4102e3		
			for ; c >= npattern; c -= npattern {
  0x4102f8		4929c6			SUBQ AX, R14		
				bits |= pattern << nbits
  0x4102fb		4c89d1			MOVQ R10, CX		
				bits |= pattern << nbits
  0x4102fe		4989f4			MOVQ SI, R12		
			for ; c >= npattern; c -= npattern {
  0x410301		4939c6			CMPQ AX, R14		
  0x410304		724d			JB 0x410353		
				bits |= pattern << nbits
  0x410306		4983fc40		CMPQ $0x40, R12		
  0x41030a		4819f6			SBBQ SI, SI		
				pattern &= 1<<c - 1
  0x41030d		4989c8			MOVQ CX, R8		
				bits |= pattern << nbits
  0x410310		4c89e1			MOVQ R12, CX		
  0x410313		4d89c2			MOVQ R8, R10		
  0x410316		49d3e0			SHLQ CL, R8		
  0x410319		4921f0			ANDQ SI, R8		
  0x41031c		4d09c3			ORQ R8, R11		
				nbits += npattern
  0x41031f		488d3408		LEAQ 0(AX)(CX*1), SI	
			if size == 1 {
  0x410323		4883ff01		CMPQ $0x1, DI		
				if size == 1 {
  0x410327		74c9			JE 0x4102f2		
  0x410329		eb20			JMP 0x41034b		
						*dst = uint8(bits&0xf | bitScanAll)
  0x41032b		4d89d8			MOVQ R11, R8		
  0x41032e		4983e30f		ANDQ $0xf, R11		
  0x410332		4981cbf0000000		ORQ $0xf0, R11		
  0x410339		44881b			MOVB R11, 0(BX)		
						dst = add1(dst)
  0x41033c		90			NOPL			
						bits >>= 4
  0x41033d		49c1e804		SHRQ $0x4, R8		
						nbits -= 4
  0x410341		4883c6fc		ADDQ $-0x4, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x410345		48ffc3			INCQ BX			
			v := bits&0xf | bitScanAll
  0x410348		4d89c3			MOVQ R8, R11		
					for nbits >= 4 {
  0x41034b		4883fe04		CMPQ $0x4, SI		
  0x41034f		73da			JAE 0x41032b		
  0x410351		eba5			JMP 0x4102f8		
			if c > 0 {
  0x410353		4d85f6			TESTQ R14, R14		
  0x410356		7648			JBE 0x4103a0		
				pattern &= 1<<c - 1
  0x410358		4983fe40		CMPQ $0x40, R14		
  0x41035c		4819f6			SBBQ SI, SI		
				bits |= pattern << nbits
  0x41035f		4983fc40		CMPQ $0x40, R12		
  0x410363		4d19c0			SBBQ R8, R8		
				pattern &= 1<<c - 1
  0x410366		4889c8			MOVQ CX, AX		
  0x410369		4c89f1			MOVQ R14, CX		
  0x41036c		41ba01000000		MOVL $0x1, R10		
  0x410372		49d3e2			SHLQ CL, R10		
  0x410375		4921f2			ANDQ SI, R10		
  0x410378		498d72ff		LEAQ -0x1(R10), SI	
  0x41037c		4821f0			ANDQ SI, AX		
				bits |= pattern << nbits
  0x41037f		4c89e1			MOVQ R12, CX		
  0x410382		48d3e0			SHLQ CL, AX		
  0x410385		4c21c0			ANDQ R8, AX		
  0x410388		4909c3			ORQ AX, R11		
				nbits += c
  0x41038b		4a8d3431		LEAQ 0(CX)(R14*1), SI	
		for ; nbits >= 8; nbits -= 8 {
  0x41038f		4889f0			MOVQ SI, AX		
				if trailer != nil {
  0x410392		4889d1			MOVQ DX, CX		
			v := bits&0xf | bitScanAll
  0x410395		4c89de			MOVQ R11, SI		
		inst := uintptr(*p)
  0x410398		4c89ca			MOVQ R9, DX		
			continue Run
  0x41039b		e903fdffff		JMP 0x4100a3		
		for ; nbits >= 8; nbits -= 8 {
  0x4103a0		4c89e6			MOVQ R12, SI		
			if c > 0 {
  0x4103a3		ebea			JMP 0x41038f		
			for ; c >= npattern; c -= npattern {
  0x4103a5		4c89f0			MOVQ R14, AX		
				pattern &= 1<<c - 1
  0x4103a8		4889f1			MOVQ SI, CX		
					npattern = c
  0x4103ab		e951ffffff		JMP 0x410301		
				if nb+nb <= maxBits {
  0x4103b0		4f8d1400		LEAQ 0(R8)(R8*1), R10	
  0x4103b4		4983fa39		CMPQ $0x39, R10		
  0x4103b8		7766			JA 0x410420		
			if npattern == 1 {
  0x4103ba		4c89c0			MOVQ R8, AX		
					for nb <= sys.PtrSize*8 {
  0x4103bd		eb16			JMP 0x4103d5		
						b |= b << nb
  0x4103bf		4d19d2			SBBQ R10, R10		
  0x4103c2		4c89c1			MOVQ R8, CX		
  0x4103c5		4989f5			MOVQ SI, R13		
  0x4103c8		48d3e6			SHLQ CL, SI		
  0x4103cb		4c21d6			ANDQ R10, SI		
  0x4103ce		4c09ee			ORQ R13, SI		
						nb += nb
  0x4103d1		4c8d0409		LEAQ 0(CX)(CX*1), R8	
					for nb <= sys.PtrSize*8 {
  0x4103d5		4983f840		CMPQ $0x40, R8		
  0x4103d9		76e4			JBE 0x4103bf		
					nb = maxBits / npattern * npattern
  0x4103db		4885c0			TESTQ AX, AX		
  0x4103de		0f8467020000		JE 0x41064b		
			if npattern == 1 {
  0x4103e4		4889c1			MOVQ AX, CX		
					nb = maxBits / npattern * npattern
  0x4103e7		b839000000		MOVL $0x39, AX		
				if trailer != nil {
  0x4103ec		4989d0			MOVQ DX, R8		
					nb = maxBits / npattern * npattern
  0x4103ef		31d2			XORL DX, DX		
  0x4103f1		48f7f1			DIVQ CX			
  0x4103f4		480fafc8		IMULQ AX, CX		
					b &= 1<<nb - 1
  0x4103f8		4883f940		CMPQ $0x40, CX		
  0x4103fc		4819d2			SBBQ DX, DX		
  0x4103ff		41ba01000000		MOVL $0x1, R10		
  0x410405		49d3e2			SHLQ CL, R10		
  0x410408		4921d2			ANDQ DX, R10		
  0x41040b		498d52ff		LEAQ -0x1(R10), DX	
  0x41040f		4821d6			ANDQ DX, SI		
				if trailer != nil {
  0x410412		4c89c2			MOVQ R8, DX		
			for ; c >= npattern; c -= npattern {
  0x410415		4889c8			MOVQ CX, AX		
				pattern &= 1<<c - 1
  0x410418		4889f1			MOVQ SI, CX		
			for ; c >= npattern; c -= npattern {
  0x41041b		e9e1feffff		JMP 0x410301		
  0x410420		4c89c1			MOVQ R8, CX		
				if trailer != nil {
  0x410423		4989d0			MOVQ DX, R8		
				if nb+nb <= maxBits {
  0x410426		ebea			JMP 0x410412		
				bits |= pattern << nbits
  0x410428		4989cc			MOVQ CX, R12		
			if npattern == 1 {
  0x41042b		4989c0			MOVQ AX, R8		
			if npattern > n {
  0x41042e		e98bfeffff		JMP 0x4102be		
				src = subtract1(src)
  0x410433		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x410434		4c8d53ff		LEAQ -0x1(BX), R10	
		for ; nbits >= 8; nbits -= 8 {
  0x410438		4889c1			MOVQ AX, CX		
			v := bits&0xf | bitScanAll
  0x41043b		4989f3			MOVQ SI, R11		
				for npattern < n {
  0x41043e		eb17			JMP 0x410457		
					pattern <<= 4
  0x410440		48c1e604		SHLQ $0x4, SI		
					pattern |= uintptr(*src) & 0xf
  0x410444		450fb622		MOVZX 0(R10), R12	
  0x410448		4983e40f		ANDQ $0xf, R12		
  0x41044c		4c09e6			ORQ R12, SI		
					src = subtract1(src)
  0x41044f		90			NOPL			
					npattern += 4
  0x410450		4883c004		ADDQ $0x4, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))
  0x410454		49ffca			DECQ R10		
				for npattern < n {
  0x410457		4c39c0			CMPQ R8, AX		
  0x41045a		72e4			JB 0x410440		
  0x41045c		e93efeffff		JMP 0x41029f		
		off := n - nbits // n > nbits because n > maxBits and nbits <= 7
  0x410461		4929c0			SUBQ AX, R8		
		if size == 1 {
  0x410464		4883ff01		CMPQ $0x1, DI		
  0x410468		0f85e2000000		JNE 0x410550		
			src = subtractb(src, (off+7)/8)
  0x41046e		90			NOPL			
  0x41046f		4d8d5007		LEAQ 0x7(R8), R10	
  0x410473		49c1ea03		SHRQ $0x3, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x410477		4989db			MOVQ BX, R11		
  0x41047a		4c29d3			SUBQ R10, BX		
  0x41047d		4989da			MOVQ BX, R10		
			if frag := off & 7; frag != 0 {
  0x410480		49f7c007000000		TESTQ $0x7, R8		
  0x410487		0f84b8000000		JE 0x410545		
  0x41048d		4983e007		ANDQ $0x7, R8		
				bits |= uintptr(*src) >> (8 - frag) << nbits
  0x410491		498d48f8		LEAQ -0x8(R8), CX	
  0x410495		48f7d9			NEGQ CX			
  0x410498		4883f940		CMPQ $0x40, CX		
  0x41049c		4d19e4			SBBQ R12, R12		
  0x41049f		0fb61b			MOVZX 0(BX), BX		
  0x4104a2		48d3eb			SHRQ CL, BX		
  0x4104a5		4c21e3			ANDQ R12, BX		
  0x4104a8		4889c1			MOVQ AX, CX		
  0x4104ab		48d3e3			SHLQ CL, BX		
  0x4104ae		4809de			ORQ BX, SI		
				src = add1(src)
  0x4104b1		90			NOPL			
				nbits += frag
  0x4104b2		498d1c00		LEAQ 0(R8)(AX*1), BX	
				c -= frag
  0x4104b6		4d29c6			SUBQ R8, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4104b9		4d8d4201		LEAQ 0x1(R10), R8	
			for i := c / 8; i > 0; i-- {
  0x4104bd		4c89f1			MOVQ R14, CX		
  0x4104c0		49c1ee03		SHRQ $0x3, R14		
  0x4104c4		eb2f			JMP 0x4104f5		
				bits |= uintptr(*src) << nbits
  0x4104c6		4883fb40		CMPQ $0x40, BX		
  0x4104ca		4d19d2			SBBQ R10, R10		
  0x4104cd		450fb620		MOVZX 0(R8), R12	
			for i := c / 8; i > 0; i-- {
  0x4104d1		4889c8			MOVQ CX, AX		
				bits |= uintptr(*src) << nbits
  0x4104d4		4889d9			MOVQ BX, CX		
  0x4104d7		49d3e4			SHLQ CL, R12		
  0x4104da		4d21d4			ANDQ R10, R12		
  0x4104dd		4c09e6			ORQ R12, SI		
				src = add1(src)
  0x4104e0		90			NOPL			
				*dst = uint8(bits)
  0x4104e1		418833			MOVB SI, 0(R11)		
			for i := c / 8; i > 0; i-- {
  0x4104e4		49ffce			DECQ R14		
				dst = add1(dst)
  0x4104e7		90			NOPL			
				bits >>= 8
  0x4104e8		48c1ee08		SHRQ $0x8, SI		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4104ec		49ffc0			INCQ R8			
  0x4104ef		49ffc3			INCQ R11		
			if c %= 8; c > 0 {
  0x4104f2		4889c1			MOVQ AX, CX		
			for i := c / 8; i > 0; i-- {
  0x4104f5		4d85f6			TESTQ R14, R14		
  0x4104f8		77cc			JA 0x4104c6		
			if c %= 8; c > 0 {
  0x4104fa		48f7c107000000		TESTQ $0x7, CX		
  0x410501		7631			JBE 0x410534		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410503		4883fb40		CMPQ $0x40, BX		
  0x410507		4d19d2			SBBQ R10, R10		
			if c %= 8; c > 0 {
  0x41050a		4883e107		ANDQ $0x7, CX		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x41050e		450fb600		MOVZX 0(R8), R8		
  0x410512		41bc01000000		MOVL $0x1, R12		
  0x410518		49d3e4			SHLQ CL, R12		
  0x41051b		49ffcc			DECQ R12		
  0x41051e		4d21c4			ANDQ R8, R12		
			if c %= 8; c > 0 {
  0x410521		4889c8			MOVQ CX, AX		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410524		4889d9			MOVQ BX, CX		
  0x410527		49d3e4			SHLQ CL, R12		
  0x41052a		4d21d4			ANDQ R10, R12		
  0x41052d		4c09e6			ORQ R12, SI		
				nbits += c
  0x410530		488d1c08		LEAQ 0(AX)(CX*1), BX	
		for ; nbits >= 8; nbits -= 8 {
  0x410534		4889d8			MOVQ BX, AX		
				if trailer != nil {
  0x410537		4889d1			MOVQ DX, CX		
		totalBits = (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*4 + nbits
  0x41053a		4c89db			MOVQ R11, BX		
		inst := uintptr(*p)
  0x41053d		4c89ca			MOVQ R9, DX		
		for ; nbits >= 8; nbits -= 8 {
  0x410540		e95efbffff		JMP 0x4100a3		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410545		4989d8			MOVQ BX, R8		
  0x410548		4889c3			MOVQ AX, BX		
			if frag := off & 7; frag != 0 {
  0x41054b		e96dffffff		JMP 0x4104bd		
			src = subtractb(src, (off+3)/4)
  0x410550		90			NOPL			
  0x410551		4d8d5003		LEAQ 0x3(R8), R10	
  0x410555		49c1ea02		SHRQ $0x2, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))
  0x410559		4989db			MOVQ BX, R11		
  0x41055c		4c29d3			SUBQ R10, BX		
  0x41055f		4989da			MOVQ BX, R10		
			if frag := off & 3; frag != 0 {
  0x410562		49f7c003000000		TESTQ $0x3, R8		
  0x410569		0f84c9000000		JE 0x410638		
  0x41056f		4983e003		ANDQ $0x3, R8		
				bits |= (uintptr(*src) & 0xf) >> (4 - frag) << nbits
  0x410573		498d48fc		LEAQ -0x4(R8), CX	
  0x410577		48f7d9			NEGQ CX			
  0x41057a		4883f940		CMPQ $0x40, CX		
  0x41057e		4d19e4			SBBQ R12, R12		
  0x410581		0fb61b			MOVZX 0(BX), BX		
  0x410584		4883e30f		ANDQ $0xf, BX		
  0x410588		48d3eb			SHRQ CL, BX		
  0x41058b		4c21e3			ANDQ R12, BX		
  0x41058e		4889c1			MOVQ AX, CX		
  0x410591		48d3e3			SHLQ CL, BX		
  0x410594		4809de			ORQ BX, SI		
				src = add1(src)
  0x410597		90			NOPL			
				nbits += frag
  0x410598		498d1c00		LEAQ 0(R8)(AX*1), BX	
				c -= frag
  0x41059c		4d29c6			SUBQ R8, R14		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x41059f		4d8d4201		LEAQ 0x1(R10), R8	
			for i := c / 4; i > 0; i-- {
  0x4105a3		4c89f1			MOVQ R14, CX		
  0x4105a6		49c1ee02		SHRQ $0x2, R14		
  0x4105aa		eb44			JMP 0x4105f0		
				bits |= (uintptr(*src) & 0xf) << nbits
  0x4105ac		4883fb40		CMPQ $0x40, BX		
  0x4105b0		4d19d2			SBBQ R10, R10		
  0x4105b3		450fb620		MOVZX 0(R8), R12	
  0x4105b7		4983e40f		ANDQ $0xf, R12		
			for i := c / 4; i > 0; i-- {
  0x4105bb		4889c8			MOVQ CX, AX		
				bits |= (uintptr(*src) & 0xf) << nbits
  0x4105be		4889d9			MOVQ BX, CX		
  0x4105c1		49d3e4			SHLQ CL, R12		
  0x4105c4		4d21d4			ANDQ R10, R12		
  0x4105c7		4c09e6			ORQ R12, SI		
				src = add1(src)
  0x4105ca		90			NOPL			
				*dst = uint8(bits&0xf | bitScanAll)
  0x4105cb		4989f2			MOVQ SI, R10		
  0x4105ce		4883e60f		ANDQ $0xf, SI		
  0x4105d2		4881cef0000000		ORQ $0xf0, SI		
  0x4105d9		418833			MOVB SI, 0(R11)		
			for i := c / 4; i > 0; i-- {
  0x4105dc		49ffce			DECQ R14		
				dst = add1(dst)
  0x4105df		90			NOPL			
				bits >>= 4
  0x4105e0		49c1ea04		SHRQ $0x4, R10		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x4105e4		49ffc0			INCQ R8			
  0x4105e7		49ffc3			INCQ R11		
			if c %= 4; c > 0 {
  0x4105ea		4889c1			MOVQ AX, CX		
			v := bits&0xf | bitScanAll
  0x4105ed		4c89d6			MOVQ R10, SI		
			for i := c / 4; i > 0; i-- {
  0x4105f0		4d85f6			TESTQ R14, R14		
  0x4105f3		77b7			JA 0x4105ac		
			if c %= 4; c > 0 {
  0x4105f5		48f7c103000000		TESTQ $0x3, CX		
  0x4105fc		0f8632ffffff		JBE 0x410534		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410602		4883fb40		CMPQ $0x40, BX		
  0x410606		4d19d2			SBBQ R10, R10		
			if c %= 4; c > 0 {
  0x410609		4883e103		ANDQ $0x3, CX		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x41060d		450fb600		MOVZX 0(R8), R8		
  0x410611		41bc01000000		MOVL $0x1, R12		
  0x410617		49d3e4			SHLQ CL, R12		
  0x41061a		49ffcc			DECQ R12		
  0x41061d		4d21c4			ANDQ R8, R12		
			if c %= 4; c > 0 {
  0x410620		4889c8			MOVQ CX, AX		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410623		4889d9			MOVQ BX, CX		
  0x410626		49d3e4			SHLQ CL, R12		
  0x410629		4d21d4			ANDQ R10, R12		
  0x41062c		4c09e6			ORQ R12, SI		
				nbits += c
  0x41062f		488d1c08		LEAQ 0(AX)(CX*1), BX	
  0x410633		e9fcfeffff		JMP 0x410534		
				bits |= (uintptr(*src) & (1<<c - 1)) << nbits
  0x410638		4989d8			MOVQ BX, R8		
  0x41063b		4889c3			MOVQ AX, BX		
			if frag := off & 3; frag != 0 {
  0x41063e		e960ffffff		JMP 0x4105a3		
			x := uintptr(*p)
  0x410643		4d89d1			MOVQ R10, R9		
		if n == 0 {
  0x410646		e9ddfbffff		JMP 0x410228		
					nb = maxBits / npattern * npattern
  0x41064b		e8301b0100		CALL runtime.panicdivide(SB)	
  0x410650		0f0b			UD2				

TEXT runtime.materializeGCProg(SB) /usr/local/go/src/runtime/mbitmap.go
func materializeGCProg(ptrdata uintptr, prog *byte) *mspan {
  0x410660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410669		483b6110		CMPQ 0x10(CX), SP	
  0x41066d		0f868e000000		JBE 0x410701		
  0x410673		4883ec38		SUBQ $0x38, SP		
  0x410677		48896c2430		MOVQ BP, 0x30(SP)	
  0x41067c		488d6c2430		LEAQ 0x30(SP), BP	
	s := mheap_.allocManual((ptrdata/(8*sys.PtrSize)+pageSize-1)/pageSize, &memstats.gc_sys)
  0x410681		488d05b85f0b00		LEAQ runtime.mheap_(SB), AX		
  0x410688		48890424		MOVQ AX, 0(SP)				
  0x41068c		488b442440		MOVQ 0x40(SP), AX			
  0x410691		48c1e806		SHRQ $0x6, AX				
  0x410695		4805ff1f0000		ADDQ $0x1fff, AX			
  0x41069b		48c1e80d		SHRQ $0xd, AX				
  0x41069f		4889442408		MOVQ AX, 0x8(SP)			
  0x4106a4		488d054dd60c00		LEAQ runtime.memstats+152(SB), AX	
  0x4106ab		4889442410		MOVQ AX, 0x10(SP)			
  0x4106b0		e8ebce0000		CALL runtime.(*mheap).allocManual(SB)	
  0x4106b5		488b442418		MOVQ 0x18(SP), AX			
  0x4106ba		4889442428		MOVQ AX, 0x28(SP)			
	runGCProg(addb(prog, 4), nil, (*byte)(unsafe.Pointer(s.startAddr)), 1)
  0x4106bf		90			NOPL			
  0x4106c0		488b4818		MOVQ 0x18(AX), CX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x4106c4		488b542448		MOVQ 0x48(SP), DX	
  0x4106c9		4883c204		ADDQ $0x4, DX		
	runGCProg(addb(prog, 4), nil, (*byte)(unsafe.Pointer(s.startAddr)), 1)
  0x4106cd		48891424		MOVQ DX, 0(SP)			
  0x4106d1		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4106da		48894c2410		MOVQ CX, 0x10(SP)		
  0x4106df		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x4106e8		e813f9ffff		CALL runtime.runGCProg(SB)	
	return s
  0x4106ed		488b442428		MOVQ 0x28(SP), AX	
  0x4106f2		4889442450		MOVQ AX, 0x50(SP)	
  0x4106f7		488b6c2430		MOVQ 0x30(SP), BP	
  0x4106fc		4883c438		ADDQ $0x38, SP		
  0x410700		c3			RET			
func materializeGCProg(ptrdata uintptr, prog *byte) *mspan {
  0x410701		e87a710300		CALL runtime.morestack_noctxt(SB)	
  0x410706		e955ffffff		JMP runtime.materializeGCProg(SB)	

TEXT runtime.allocmcache(SB) /usr/local/go/src/runtime/mcache.go
func allocmcache() *mcache {
  0x410710		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410719		483b6110		CMPQ 0x10(CX), SP	
  0x41071d		0f86a0000000		JBE 0x4107c3		
  0x410723		4883ec20		SUBQ $0x20, SP		
  0x410727		48896c2418		MOVQ BP, 0x18(SP)	
  0x41072c		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&mheap_.lock)
  0x410731		488d05085f0b00		LEAQ runtime.mheap_(SB), AX	
  0x410738		48890424		MOVQ AX, 0(SP)			
  0x41073c		e89f7fffff		CALL runtime.lock(SB)		
	c := (*mcache)(mheap_.cachealloc.alloc())
  0x410741		488d0540840b00		LEAQ runtime.mheap_+9544(SB), AX	
  0x410748		48890424		MOVQ AX, 0(SP)				
  0x41074c		e83f140000		CALL runtime.(*fixalloc).alloc(SB)	
  0x410751		488b442408		MOVQ 0x8(SP), AX			
  0x410756		4889442410		MOVQ AX, 0x10(SP)			
	c.flushGen = mheap_.sweepgen
  0x41075b		8b0df75e0b00		MOVL runtime.mheap_+24(SB), CX	
  0x410761		8988c0060000		MOVL CX, 0x6c0(AX)		
	unlock(&mheap_.lock)
  0x410767		488d0dd25e0b00		LEAQ runtime.mheap_(SB), CX	
  0x41076e		48890c24		MOVQ CX, 0(SP)			
  0x410772		e81981ffff		CALL runtime.unlock(SB)		
	for i := range c.alloc {
  0x410777		488b442410		MOVQ 0x10(SP), AX	
  0x41077c		31c9			XORL CX, CX		
  0x41077e		eb0f			JMP 0x41078f		
		c.alloc[i] = &emptymspan
  0x410780		488d1579140b00		LEAQ runtime.emptymspan(SB), DX	
  0x410787		488954c828		MOVQ DX, 0x28(AX)(CX*8)		
	for i := range c.alloc {
  0x41078c		48ffc1			INCQ CX			
  0x41078f		4881f986000000		CMPQ $0x86, CX		
  0x410796		7ce8			JL 0x410780		
	c.next_sample = nextSample()
  0x410798		90			NOPL			
	return fastexprand(MemProfileRate)
  0x410799		488b0588e80a00		MOVQ runtime.MemProfileRate(SB), AX	
  0x4107a0		48890424		MOVQ AX, 0(SP)				
  0x4107a4		e847a1ffff		CALL runtime.fastexprand(SB)		
  0x4107a9		8b442408		MOVL 0x8(SP), AX			
	c.next_sample = nextSample()
  0x4107ad		488b4c2410		MOVQ 0x10(SP), CX	
  0x4107b2		8901			MOVL AX, 0(CX)		
	return c
  0x4107b4		48894c2428		MOVQ CX, 0x28(SP)	
  0x4107b9		488b6c2418		MOVQ 0x18(SP), BP	
  0x4107be		4883c420		ADDQ $0x20, SP		
  0x4107c2		c3			RET			
func allocmcache() *mcache {
  0x4107c3		e8b8700300		CALL runtime.morestack_noctxt(SB)	
  0x4107c8		e943ffffff		JMP runtime.allocmcache(SB)		

TEXT runtime.freemcache(SB) /usr/local/go/src/runtime/mcache.go
func freemcache(c *mcache) {
  0x4107d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4107d9		483b6110		CMPQ 0x10(CX), SP	
  0x4107dd		7644			JBE 0x410823		
  0x4107df		4883ec20		SUBQ $0x20, SP		
  0x4107e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4107e8		488d6c2418		LEAQ 0x18(SP), BP	
	systemstack(func() {
  0x4107ed		0f57c0			XORPS X0, X0				
  0x4107f0		0f11442408		MOVUPS X0, 0x8(SP)			
  0x4107f5		488d05d4430300		LEAQ runtime.freemcache.func1(SB), AX	
  0x4107fc		4889442408		MOVQ AX, 0x8(SP)			
  0x410801		488b442428		MOVQ 0x28(SP), AX			
  0x410806		4889442410		MOVQ AX, 0x10(SP)			
  0x41080b		488d442408		LEAQ 0x8(SP), AX			
  0x410810		48890424		MOVQ AX, 0(SP)				
  0x410814		e8176f0300		CALL runtime.systemstack(SB)		
}
  0x410819		488b6c2418		MOVQ 0x18(SP), BP	
  0x41081e		4883c420		ADDQ $0x20, SP		
  0x410822		c3			RET			
func freemcache(c *mcache) {
  0x410823		e858700300		CALL runtime.morestack_noctxt(SB)	
  0x410828		eba6			JMP runtime.freemcache(SB)		

TEXT runtime.(*mcache).refill(SB) /usr/local/go/src/runtime/mcache.go
func (c *mcache) refill(spc spanClass) {
  0x410830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410839		483b6110		CMPQ 0x10(CX), SP	
  0x41083d		0f861f010000		JBE 0x410962		
  0x410843		4883ec18		SUBQ $0x18, SP		
  0x410847		48896c2410		MOVQ BP, 0x10(SP)	
  0x41084c		488d6c2410		LEAQ 0x10(SP), BP	
	s := c.alloc[spc]
  0x410851		488b442420		MOVQ 0x20(SP), AX	
  0x410856		8400			TESTB AL, 0(AX)		
  0x410858		0fb64c2428		MOVZX 0x28(SP), CX	
  0x41085d		4881f986000000		CMPQ $0x86, CX		
  0x410864		0f83f1000000		JAE 0x41095b		
  0x41086a		488b54c828		MOVQ 0x28(AX)(CX*8), DX	
	if uintptr(s.allocCount) != s.nelems {
  0x41086f		0fb75a60		MOVZX 0x60(DX), BX	
  0x410873		48395a38		CMPQ BX, 0x38(DX)	
  0x410877		0f85c3000000		JNE 0x410940		
	if s != &emptymspan {
  0x41087d		488d1d7c130b00		LEAQ runtime.emptymspan(SB), BX	
  0x410884		4839da			CMPQ BX, DX			
  0x410887		7415			JE 0x41089e			
		if s.sweepgen != mheap_.sweepgen+3 {
  0x410889		8b1dc95d0b00		MOVL runtime.mheap_+24(SB), BX	
  0x41088f		8d7303			LEAL 0x3(BX), SI		
  0x410892		397258			CMPL SI, 0x58(DX)		
  0x410895		0f858a000000		JNE 0x410925			
		atomic.Store(&s.sweepgen, mheap_.sweepgen)
  0x41089b		875a58			XCHGL BX, 0x58(DX)	
	s = mheap_.central[spc].mcentral.cacheSpan()
  0x41089e		48c1e106		SHLQ $0x6, CX				
  0x4108a2		488d1517610b00		LEAQ runtime.mheap_+896(SB), DX		
  0x4108a9		488d0c0a		LEAQ 0(DX)(CX*1), CX			
  0x4108ad		48890c24		MOVQ CX, 0(SP)				
  0x4108b1		e86a020000		CALL runtime.(*mcentral).cacheSpan(SB)	
  0x4108b6		488b442408		MOVQ 0x8(SP), AX			
	if s == nil {
  0x4108bb		4885c0			TESTQ AX, AX		
  0x4108be		744a			JE 0x41090a		
	if uintptr(s.allocCount) == s.nelems {
  0x4108c0		0fb74860		MOVZX 0x60(AX), CX	
  0x4108c4		48394838		CMPQ CX, 0x38(AX)	
  0x4108c8		7425			JE 0x4108ef		
	s.sweepgen = mheap_.sweepgen + 3
  0x4108ca		8b0d885d0b00		MOVL runtime.mheap_+24(SB), CX	
  0x4108d0		83c103			ADDL $0x3, CX			
  0x4108d3		894858			MOVL CX, 0x58(AX)		
	c.alloc[spc] = s
  0x4108d6		0fb64c2428		MOVZX 0x28(SP), CX	
  0x4108db		488b542420		MOVQ 0x20(SP), DX	
  0x4108e0		488944ca28		MOVQ AX, 0x28(DX)(CX*8)	
}
  0x4108e5		488b6c2410		MOVQ 0x10(SP), BP	
  0x4108ea		4883c418		ADDQ $0x18, SP		
  0x4108ee		c3			RET			
		throw("span has no free space")
  0x4108ef		488d05ed010600		LEAQ 0x601ed(IP), AX	
  0x4108f6		48890424		MOVQ AX, 0(SP)		
  0x4108fa		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x410903		e8782b0100		CALL runtime.throw(SB)	
  0x410908		0f0b			UD2			
		throw("out of memory")
  0x41090a		488d058af30500		LEAQ 0x5f38a(IP), AX	
  0x410911		48890424		MOVQ AX, 0(SP)		
  0x410915		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x41091e		e85d2b0100		CALL runtime.throw(SB)	
  0x410923		0f0b			UD2			
			throw("bad sweepgen in refill")
  0x410925		488d0557000600		LEAQ 0x60057(IP), AX	
  0x41092c		48890424		MOVQ AX, 0(SP)		
  0x410930		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x410939		e8422b0100		CALL runtime.throw(SB)	
  0x41093e		0f0b			UD2			
		throw("refill of span with free space remaining")
  0x410940		488d0553200600		LEAQ 0x62053(IP), AX	
  0x410947		48890424		MOVQ AX, 0(SP)		
  0x41094b		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x410954		e8272b0100		CALL runtime.throw(SB)	
  0x410959		0f0b			UD2			
	s := c.alloc[spc]
  0x41095b		e8c0150100		CALL runtime.panicindex(SB)	
  0x410960		0f0b			UD2				
func (c *mcache) refill(spc spanClass) {
  0x410962		e8196f0300		CALL runtime.morestack_noctxt(SB)	
  0x410967		e9c4feffff		JMP runtime.(*mcache).refill(SB)	

TEXT runtime.(*mcache).releaseAll(SB) /usr/local/go/src/runtime/mcache.go
func (c *mcache) releaseAll() {
  0x410970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410979		483b6110		CMPQ 0x10(CX), SP	
  0x41097d		0f8681000000		JBE 0x410a04		
  0x410983		4883ec20		SUBQ $0x20, SP		
  0x410987		48896c2418		MOVQ BP, 0x18(SP)	
  0x41098c		488d6c2418		LEAQ 0x18(SP), BP	
	for i := range c.alloc {
  0x410991		488b442428		MOVQ 0x28(SP), AX	
  0x410996		31c9			XORL CX, CX		
  0x410998		eb03			JMP 0x41099d		
  0x41099a		48ffc1			INCQ CX			
  0x41099d		4881f986000000		CMPQ $0x86, CX		
  0x4109a4		7d4d			JGE 0x4109f3		
		s := c.alloc[i]
  0x4109a6		8400			TESTB AL, 0(AX)		
  0x4109a8		488b54c828		MOVQ 0x28(AX)(CX*8), DX	
		if s != &emptymspan {
  0x4109ad		488d1d4c120b00		LEAQ runtime.emptymspan(SB), BX	
  0x4109b4		4839da			CMPQ BX, DX			
  0x4109b7		74e1			JE 0x41099a			
	for i := range c.alloc {
  0x4109b9		48894c2410		MOVQ CX, 0x10(SP)	
			mheap_.central[i].mcentral.uncacheSpan(s)
  0x4109be		48c1e106		SHLQ $0x6, CX					
  0x4109c2		488d1df75f0b00		LEAQ runtime.mheap_+896(SB), BX			
  0x4109c9		488d0c0b		LEAQ 0(BX)(CX*1), CX				
  0x4109cd		48890c24		MOVQ CX, 0(SP)					
  0x4109d1		4889542408		MOVQ DX, 0x8(SP)				
  0x4109d6		e8a5050000		CALL runtime.(*mcentral).uncacheSpan(SB)	
			c.alloc[i] = &emptymspan
  0x4109db		488b4c2410		MOVQ 0x10(SP), CX		
  0x4109e0		488d1d19120b00		LEAQ runtime.emptymspan(SB), BX	
  0x4109e7		488b442428		MOVQ 0x28(SP), AX		
  0x4109ec		48895cc828		MOVQ BX, 0x28(AX)(CX*8)		
  0x4109f1		eba7			JMP 0x41099a			
	c.tinyoffset = 0
  0x4109f3		0f57c0			XORPS X0, X0		
  0x4109f6		0f114010		MOVUPS X0, 0x10(AX)	
}
  0x4109fa		488b6c2418		MOVQ 0x18(SP), BP	
  0x4109ff		4883c420		ADDQ $0x20, SP		
  0x410a03		c3			RET			
func (c *mcache) releaseAll() {
  0x410a04		e8776e0300		CALL runtime.morestack_noctxt(SB)	
  0x410a09		e962ffffff		JMP runtime.(*mcache).releaseAll(SB)	

TEXT runtime.(*mcache).prepareForSweep(SB) /usr/local/go/src/runtime/mcache.go
func (c *mcache) prepareForSweep() {
  0x410a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410a19		483b6110		CMPQ 0x10(CX), SP	
  0x410a1d		0f86e4000000		JBE 0x410b07		
  0x410a23		4883ec20		SUBQ $0x20, SP		
  0x410a27		48896c2418		MOVQ BP, 0x18(SP)	
  0x410a2c		488d6c2418		LEAQ 0x18(SP), BP	
	sg := mheap_.sweepgen
  0x410a31		8b05215c0b00		MOVL runtime.mheap_+24(SB), AX	
	if c.flushGen == sg {
  0x410a37		488b4c2428		MOVQ 0x28(SP), CX	
  0x410a3c		8b91c0060000		MOVL 0x6c0(CX), DX	
  0x410a42		39c2			CMPL AX, DX		
  0x410a44		7439			JE 0x410a7f		
	} else if c.flushGen != sg-2 {
  0x410a46		8d58fe			LEAL -0x2(AX), BX	
  0x410a49		39da			CMPL BX, DX		
  0x410a4b		753c			JNE 0x410a89		
	c.releaseAll()
  0x410a4d		48890c24		MOVQ CX, 0(SP)				
  0x410a51		e81affffff		CALL runtime.(*mcache).releaseAll(SB)	
	stackcache_clear(c)
  0x410a56		488b442428		MOVQ 0x28(SP), AX			
  0x410a5b		48890424		MOVQ AX, 0(SP)				
  0x410a5f		e85c5f0200		CALL runtime.stackcache_clear(SB)	
	atomic.Store(&c.flushGen, mheap_.sweepgen) // Synchronizes with gcStart
  0x410a64		8b05ee5b0b00		MOVL runtime.mheap_+24(SB), AX	
  0x410a6a		488b4c2428		MOVQ 0x28(SP), CX		
  0x410a6f		8781c0060000		XCHGL AX, 0x6c0(CX)		
}
  0x410a75		488b6c2418		MOVQ 0x18(SP), BP	
  0x410a7a		4883c420		ADDQ $0x20, SP		
  0x410a7e		c3			RET			
		return
  0x410a7f		488b6c2418		MOVQ 0x18(SP), BP	
  0x410a84		4883c420		ADDQ $0x20, SP		
  0x410a88		c3			RET			
	sg := mheap_.sweepgen
  0x410a89		89442410		MOVL AX, 0x10(SP)	
	if c.flushGen == sg {
  0x410a8d		89542414		MOVL DX, 0x14(SP)	
		println("bad flushGen", c.flushGen, "in prepareForSweep; sweepgen", sg)
  0x410a91		e82a340100		CALL runtime.printlock(SB)	
  0x410a96		488d05bdf10500		LEAQ 0x5f1bd(IP), AX		
  0x410a9d		48890424		MOVQ AX, 0(SP)			
  0x410aa1		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x410aaa		e8413d0100		CALL runtime.printstring(SB)	
  0x410aaf		8b442414		MOVL 0x14(SP), AX		
  0x410ab3		48890424		MOVQ AX, 0(SP)			
  0x410ab7		e8843a0100		CALL runtime.printuint(SB)	
  0x410abc		488d05a30f0600		LEAQ 0x60fa3(IP), AX		
  0x410ac3		48890424		MOVQ AX, 0(SP)			
  0x410ac7		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x410ad0		e81b3d0100		CALL runtime.printstring(SB)	
  0x410ad5		8b442410		MOVL 0x10(SP), AX		
  0x410ad9		48890424		MOVQ AX, 0(SP)			
  0x410add		e85e3a0100		CALL runtime.printuint(SB)	
  0x410ae2		e869360100		CALL runtime.printnl(SB)	
  0x410ae7		e854340100		CALL runtime.printunlock(SB)	
		throw("bad flushGen")
  0x410aec		488d05a2ef0500		LEAQ 0x5efa2(IP), AX	
  0x410af3		48890424		MOVQ AX, 0(SP)		
  0x410af7		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x410b00		e87b290100		CALL runtime.throw(SB)	
  0x410b05		0f0b			UD2			
func (c *mcache) prepareForSweep() {
  0x410b07		e8746d0300		CALL runtime.morestack_noctxt(SB)		
  0x410b0c		e9fffeffff		JMP runtime.(*mcache).prepareForSweep(SB)	

TEXT runtime.(*mcentral).cacheSpan(SB) /usr/local/go/src/runtime/mcentral.go
func (c *mcentral) cacheSpan() *mspan {
  0x410b20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410b29		483b6110		CMPQ 0x10(CX), SP	
  0x410b2d		0f8635040000		JBE 0x410f68		
  0x410b33		4883ec58		SUBQ $0x58, SP		
  0x410b37		48896c2450		MOVQ BP, 0x50(SP)	
  0x410b3c		488d6c2450		LEAQ 0x50(SP), BP	
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x410b41		488b442460		MOVQ 0x60(SP), AX	
  0x410b46		0fb64808		MOVZX 0x8(AX), CX	
	return int8(sc >> 1)
  0x410b4a		d0e9			SHRL $0x1, CL		
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x410b4c		480fbec9		MOVSX CL, CX					
  0x410b50		90			NOPL						
  0x410b51		4883f943		CMPQ $0x43, CX					
  0x410b55		0f8306040000		JAE 0x410f61					
  0x410b5b		488d057ee50a00		LEAQ runtime.class_to_allocnpages(SB), AX	
  0x410b62		0fb60408		MOVZX 0(AX)(CX*1), AX				
  0x410b66		48c1e00d		SHLQ $0xd, AX					
  0x410b6a		4889442430		MOVQ AX, 0x30(SP)				
	deductSweepCredit(spanBytes, 0)
  0x410b6f		48890424		MOVQ AX, 0(SP)				
  0x410b73		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x410b7c		e82fa50000		CALL runtime.deductSweepCredit(SB)	
	lock(&c.lock)
  0x410b81		488b442460		MOVQ 0x60(SP), AX	
  0x410b86		48890424		MOVQ AX, 0(SP)		
  0x410b8a		e8517bffff		CALL runtime.lock(SB)	
	if trace.enabled {
  0x410b8f		803d3ac00b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x410b96		0f85a0030000		JNE 0x410f3c			
	sg := mheap_.sweepgen
  0x410b9c		8b0db65a0b00		MOVL runtime.mheap_+24(SB), CX	
  0x410ba2		894c242c		MOVL CX, 0x2c(SP)		
retry:
  0x410ba6		e971030000		JMP 0x410f1c		
	for s = c.nonempty.first; s != nil; s = s.next {
  0x410bab		488b1b			MOVQ 0(BX), BX		
  0x410bae		4885db			TESTQ BX, BX		
  0x410bb1		0f8407020000		JE 0x410dbe		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410bb7		8d41fe			LEAL -0x2(CX), AX		
  0x410bba		394358			CMPL AX, 0x58(BX)		
  0x410bbd		0f85f4010000		JNE 0x410db7			
  0x410bc3		8d71ff			LEAL -0x1(CX), SI		
  0x410bc6		f00fb17358		LOCK CMPXCHGL SI, 0x58(BX)	
  0x410bcb		400f94c6		SETE SI				
	for s = c.nonempty.first; s != nil; s = s.next {
  0x410bcf		48895c2440		MOVQ BX, 0x40(SP)	
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410bd4		4084f6			TESTL SI, SI		
  0x410bd7		0f857f010000		JNE 0x410d5c		
		if s.sweepgen == sg-1 {
  0x410bdd		8d71ff			LEAL -0x1(CX), SI	
  0x410be0		397358			CMPL SI, 0x58(BX)	
  0x410be3		74c6			JE 0x410bab		
		c.nonempty.remove(s)
  0x410be5		488d4210		LEAQ 0x10(DX), AX			
  0x410be9		48890424		MOVQ AX, 0(SP)				
  0x410bed		48895c2408		MOVQ BX, 0x8(SP)			
  0x410bf2		e8b9dc0000		CALL runtime.(*mSpanList).remove(SB)	
		c.empty.insertBack(s)
  0x410bf7		488b442460		MOVQ 0x60(SP), AX				
  0x410bfc		488d4820		LEAQ 0x20(AX), CX				
  0x410c00		48890c24		MOVQ CX, 0(SP)					
  0x410c04		488b4c2440		MOVQ 0x40(SP), CX				
  0x410c09		48894c2408		MOVQ CX, 0x8(SP)				
  0x410c0e		e84ddf0000		CALL runtime.(*mSpanList).insertBack(SB)	
		unlock(&c.lock)
  0x410c13		488b442460		MOVQ 0x60(SP), AX	
  0x410c18		48890424		MOVQ AX, 0(SP)		
  0x410c1c		e86f7cffff		CALL runtime.unlock(SB)	
  0x410c21		31c0			XORL AX, AX		
	n := int(s.nelems) - int(s.allocCount)
  0x410c23		488b4c2440		MOVQ 0x40(SP), CX	
  0x410c28		48894c2440		MOVQ CX, 0x40(SP)	
	if trace.enabled && !traceDone {
  0x410c2d		803d9cbf0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x410c34		7408			JE 0x410c3e			
  0x410c36		84c0			TESTL AL, AL			
  0x410c38		0f840f010000		JE 0x410d4d			
	n := int(s.nelems) - int(s.allocCount)
  0x410c3e		488b4138		MOVQ 0x38(CX), AX	
  0x410c42		0fb75160		MOVZX 0x60(CX), DX	
  0x410c46		4889c3			MOVQ AX, BX		
  0x410c49		4829d0			SUBQ DX, AX		
	if n == 0 || s.freeindex == s.nelems || uintptr(s.allocCount) == s.nelems {
  0x410c4c		4885c0			TESTQ AX, AX		
  0x410c4f		0f84f1020000		JE 0x410f46		
  0x410c55		48395930		CMPQ BX, 0x30(CX)	
  0x410c59		0f84e7020000		JE 0x410f46		
  0x410c5f		4839d3			CMPQ DX, BX		
  0x410c62		0f84de020000		JE 0x410f46		
	atomic.Xadd64(&c.nmalloc, int64(n))
  0x410c68		488b542460		MOVQ 0x60(SP), DX	
  0x410c6d		f0480fc14230		LOCK XADDQ AX, 0x30(DX)	
	usedBytes := uintptr(s.allocCount) * s.elemsize
  0x410c73		0fb74160		MOVZX 0x60(CX), AX	
  0x410c77		488b5168		MOVQ 0x68(CX), DX	
  0x410c7b		480fafc2		IMULQ DX, AX		
	atomic.Xadd64(&memstats.heap_live, int64(spanBytes)-int64(usedBytes))
  0x410c7f		488b542430		MOVQ 0x30(SP), DX			
  0x410c84		4829c2			SUBQ AX, DX				
  0x410c87		488d0512e70c00		LEAQ runtime.memstats+5952(SB), AX	
  0x410c8e		f0480fc110		LOCK XADDQ DX, 0(AX)			
	if trace.enabled {
  0x410c93		803d36bf0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x410c9a		7563			JNE 0x410cff			
	if gcBlackenEnabled != 0 {
  0x410c9c		833d2dc00c0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x410ca3		7543			JNE 0x410ce8				
	freeByteBase := s.freeindex &^ (64 - 1)
  0x410ca5		488b4130		MOVQ 0x30(CX), AX	
	s.refillAllocCache(whichByte)
  0x410ca9		48890c24		MOVQ CX, 0(SP)		
	freeByteBase := s.freeindex &^ (64 - 1)
  0x410cad		4883e0c0		ANDQ $-0x40, AX		
	whichByte := freeByteBase / 8
  0x410cb1		48c1e803		SHRQ $0x3, AX		
	s.refillAllocCache(whichByte)
  0x410cb5		4889442408		MOVQ AX, 0x8(SP)				
  0x410cba		e851ccffff		CALL runtime.(*mspan).refillAllocCache(SB)	
	s.allocCache >>= s.freeindex % 64
  0x410cbf		488b442440		MOVQ 0x40(SP), AX	
  0x410cc4		488b4840		MOVQ 0x40(AX), CX	
  0x410cc8		488b5030		MOVQ 0x30(AX), DX	
  0x410ccc		4889cb			MOVQ CX, BX		
  0x410ccf		4889d1			MOVQ DX, CX		
  0x410cd2		48d3eb			SHRQ CL, BX		
  0x410cd5		48895840		MOVQ BX, 0x40(AX)	
	return s
  0x410cd9		4889442468		MOVQ AX, 0x68(SP)	
  0x410cde		488b6c2450		MOVQ 0x50(SP), BP	
  0x410ce3		4883c458		ADDQ $0x58, SP		
  0x410ce7		c3			RET			
		gcController.revise()
  0x410ce8		488d0591c40c00		LEAQ runtime.gcController(SB), AX		
  0x410cef		48890424		MOVQ AX, 0(SP)					
  0x410cf3		e898160000		CALL runtime.(*gcControllerState).revise(SB)	
	freeByteBase := s.freeindex &^ (64 - 1)
  0x410cf8		488b4c2440		MOVQ 0x40(SP), CX	
		gcController.revise()
  0x410cfd		eba6			JMP 0x410ca5		
		traceHeapAlloc()
  0x410cff		90			NOPL			
	traceEvent(traceEvHeapAlloc, -1, memstats.heap_live)
  0x410d00		48c744243800000000	MOVQ $0x0, 0x38(SP)			
  0x410d09		488b0590e60c00		MOVQ runtime.memstats+5952(SB), AX	
  0x410d10		4889442438		MOVQ AX, 0x38(SP)			
  0x410d15		c6042421		MOVB $0x21, 0(SP)			
  0x410d19		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x410d22		488d442438		LEAQ 0x38(SP), AX			
  0x410d27		4889442410		MOVQ AX, 0x10(SP)			
  0x410d2c		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x410d35		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x410d3e		e85db10200		CALL runtime.traceEvent(SB)		
	freeByteBase := s.freeindex &^ (64 - 1)
  0x410d43		488b4c2440		MOVQ 0x40(SP), CX	
	if gcBlackenEnabled != 0 {
  0x410d48		e94fffffff		JMP 0x410c9c		
		traceGCSweepDone()
  0x410d4d		e85ec00200		CALL runtime.traceGCSweepDone(SB)	
	n := int(s.nelems) - int(s.allocCount)
  0x410d52		488b4c2440		MOVQ 0x40(SP), CX	
		traceGCSweepDone()
  0x410d57		e9e2feffff		JMP 0x410c3e		
			c.nonempty.remove(s)
  0x410d5c		488d4210		LEAQ 0x10(DX), AX			
  0x410d60		48890424		MOVQ AX, 0(SP)				
  0x410d64		48895c2408		MOVQ BX, 0x8(SP)			
  0x410d69		e842db0000		CALL runtime.(*mSpanList).remove(SB)	
			c.empty.insertBack(s)
  0x410d6e		488b442460		MOVQ 0x60(SP), AX				
  0x410d73		488d4820		LEAQ 0x20(AX), CX				
  0x410d77		48890c24		MOVQ CX, 0(SP)					
  0x410d7b		488b4c2440		MOVQ 0x40(SP), CX				
  0x410d80		48894c2408		MOVQ CX, 0x8(SP)				
  0x410d85		e8d6dd0000		CALL runtime.(*mSpanList).insertBack(SB)	
			unlock(&c.lock)
  0x410d8a		488b442460		MOVQ 0x60(SP), AX	
  0x410d8f		48890424		MOVQ AX, 0(SP)		
  0x410d93		e8f87affff		CALL runtime.unlock(SB)	
			s.sweep(true)
  0x410d98		488b442440		MOVQ 0x40(SP), AX		
  0x410d9d		48890424		MOVQ AX, 0(SP)			
  0x410da1		c644240801		MOVB $0x1, 0x8(SP)		
  0x410da6		e855990000		CALL runtime.(*mspan).sweep(SB)	
  0x410dab		31c0			XORL AX, AX			
	n := int(s.nelems) - int(s.allocCount)
  0x410dad		488b4c2440		MOVQ 0x40(SP), CX	
			goto havespan
  0x410db2		e971feffff		JMP 0x410c28		
  0x410db7		31f6			XORL SI, SI		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410db9		e911feffff		JMP 0x410bcf		
	for s = c.empty.first; s != nil; s = s.next {
  0x410dbe		488b5a20		MOVQ 0x20(DX), BX	
  0x410dc2		eb03			JMP 0x410dc7		
  0x410dc4		488b1b			MOVQ 0(BX), BX		
  0x410dc7		4885db			TESTQ BX, BX		
  0x410dca		7429			JE 0x410df5		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410dcc		8d41fe			LEAL -0x2(CX), AX		
  0x410dcf		394358			CMPL AX, 0x58(BX)		
  0x410dd2		0f855d010000		JNE 0x410f35			
  0x410dd8		8d71ff			LEAL -0x1(CX), SI		
  0x410ddb		f00fb17358		LOCK CMPXCHGL SI, 0x58(BX)	
  0x410de0		400f94c6		SETE SI				
  0x410de4		4084f6			TESTL SI, SI			
  0x410de7		0f85aa000000		JNE 0x410e97			
		if s.sweepgen == sg-1 {
  0x410ded		8d71ff			LEAL -0x1(CX), SI	
  0x410df0		397358			CMPL SI, 0x58(BX)	
  0x410df3		74cf			JE 0x410dc4		
	if trace.enabled {
  0x410df5		0fb605d4bd0b00		MOVZX runtime.trace+16(SB), AX	
  0x410dfc		8844242b		MOVB AL, 0x2b(SP)		
  0x410e00		84c0			TESTL AL, AL			
  0x410e02		0f8580000000		JNE 0x410e88			
	unlock(&c.lock)
  0x410e08		48891424		MOVQ DX, 0(SP)		
  0x410e0c		e87f7affff		CALL runtime.unlock(SB)	
	s = c.grow()
  0x410e11		488b442460		MOVQ 0x60(SP), AX			
  0x410e16		48890424		MOVQ AX, 0(SP)				
  0x410e1a		e861040000		CALL runtime.(*mcentral).grow(SB)	
  0x410e1f		488b442408		MOVQ 0x8(SP), AX			
	if s == nil {
  0x410e24		4885c0			TESTQ AX, AX		
  0x410e27		744c			JE 0x410e75		
	s = c.grow()
  0x410e29		4889442440		MOVQ AX, 0x40(SP)	
	lock(&c.lock)
  0x410e2e		488b442460		MOVQ 0x60(SP), AX	
  0x410e33		48890424		MOVQ AX, 0(SP)		
  0x410e37		e8a478ffff		CALL runtime.lock(SB)	
	c.empty.insertBack(s)
  0x410e3c		488b442460		MOVQ 0x60(SP), AX				
  0x410e41		488d4820		LEAQ 0x20(AX), CX				
  0x410e45		48890c24		MOVQ CX, 0(SP)					
  0x410e49		488b4c2440		MOVQ 0x40(SP), CX				
  0x410e4e		48894c2408		MOVQ CX, 0x8(SP)				
  0x410e53		e808dd0000		CALL runtime.(*mSpanList).insertBack(SB)	
	unlock(&c.lock)
  0x410e58		488b442460		MOVQ 0x60(SP), AX	
  0x410e5d		48890424		MOVQ AX, 0(SP)		
  0x410e61		e82a7affff		CALL runtime.unlock(SB)	
	if trace.enabled && !traceDone {
  0x410e66		0fb644242b		MOVZX 0x2b(SP), AX	
	n := int(s.nelems) - int(s.allocCount)
  0x410e6b		488b4c2440		MOVQ 0x40(SP), CX	
havespan:
  0x410e70		e9b3fdffff		JMP 0x410c28		
		return nil
  0x410e75		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x410e7e		488b6c2450		MOVQ 0x50(SP), BP	
  0x410e83		4883c458		ADDQ $0x58, SP		
  0x410e87		c3			RET			
		traceGCSweepDone()
  0x410e88		e823bf0200		CALL runtime.traceGCSweepDone(SB)	
	unlock(&c.lock)
  0x410e8d		488b542460		MOVQ 0x60(SP), DX	
		traceDone = true
  0x410e92		e971ffffff		JMP 0x410e08		
	for s = c.empty.first; s != nil; s = s.next {
  0x410e97		48895c2440		MOVQ BX, 0x40(SP)	
			c.empty.remove(s)
  0x410e9c		488d4220		LEAQ 0x20(DX), AX			
  0x410ea0		4889442448		MOVQ AX, 0x48(SP)			
  0x410ea5		48890424		MOVQ AX, 0(SP)				
  0x410ea9		48895c2408		MOVQ BX, 0x8(SP)			
  0x410eae		e8fdd90000		CALL runtime.(*mSpanList).remove(SB)	
			c.empty.insertBack(s)
  0x410eb3		488b442448		MOVQ 0x48(SP), AX				
  0x410eb8		48890424		MOVQ AX, 0(SP)					
  0x410ebc		488b442440		MOVQ 0x40(SP), AX				
  0x410ec1		4889442408		MOVQ AX, 0x8(SP)				
  0x410ec6		e895dc0000		CALL runtime.(*mSpanList).insertBack(SB)	
			unlock(&c.lock)
  0x410ecb		488b442460		MOVQ 0x60(SP), AX	
  0x410ed0		48890424		MOVQ AX, 0(SP)		
  0x410ed4		e8b779ffff		CALL runtime.unlock(SB)	
			s.sweep(true)
  0x410ed9		488b442440		MOVQ 0x40(SP), AX		
  0x410ede		48890424		MOVQ AX, 0(SP)			
  0x410ee2		c644240801		MOVB $0x1, 0x8(SP)		
  0x410ee7		e814980000		CALL runtime.(*mspan).sweep(SB)	
			freeIndex := s.nextFreeIndex()
  0x410eec		488b442440		MOVQ 0x40(SP), AX			
  0x410ef1		48890424		MOVQ AX, 0(SP)				
  0x410ef5		e836caffff		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x410efa		488b442408		MOVQ 0x8(SP), AX			
			if freeIndex != s.nelems {
  0x410eff		488b4c2440		MOVQ 0x40(SP), CX	
  0x410f04		48394138		CMPQ AX, 0x38(CX)	
  0x410f08		7520			JNE 0x410f2a		
			lock(&c.lock)
  0x410f0a		488b442460		MOVQ 0x60(SP), AX	
  0x410f0f		48890424		MOVQ AX, 0(SP)		
  0x410f13		e8c877ffff		CALL runtime.lock(SB)	
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410f18		8b4c242c		MOVL 0x2c(SP), CX	
	for s = c.nonempty.first; s != nil; s = s.next {
  0x410f1c		488b542460		MOVQ 0x60(SP), DX	
  0x410f21		488b5a10		MOVQ 0x10(DX), BX	
  0x410f25		e984fcffff		JMP 0x410bae		
				s.freeindex = freeIndex
  0x410f2a		48894130		MOVQ AX, 0x30(CX)	
  0x410f2e		31c0			XORL AX, AX		
				goto havespan
  0x410f30		e9f3fcffff		JMP 0x410c28		
  0x410f35		31f6			XORL SI, SI		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x410f37		e9a8feffff		JMP 0x410de4		
		traceGCSweepStart()
  0x410f3c		e84fbd0200		CALL runtime.traceGCSweepStart(SB)	
  0x410f41		e956fcffff		JMP 0x410b9c				
		throw("span has no free objects")
  0x410f46		488d05edff0500		LEAQ 0x5ffed(IP), AX	
  0x410f4d		48890424		MOVQ AX, 0(SP)		
  0x410f51		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x410f5a		e821250100		CALL runtime.throw(SB)	
  0x410f5f		0f0b			UD2			
	spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize
  0x410f61		e8ba0f0100		CALL runtime.panicindex(SB)	
  0x410f66		0f0b			UD2				
func (c *mcentral) cacheSpan() *mspan {
  0x410f68		e813690300		CALL runtime.morestack_noctxt(SB)	
  0x410f6d		e9aefbffff		JMP runtime.(*mcentral).cacheSpan(SB)	

TEXT runtime.(*mcentral).uncacheSpan(SB) /usr/local/go/src/runtime/mcentral.go
func (c *mcentral) uncacheSpan(s *mspan) {
  0x410f80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x410f89		483b6110		CMPQ 0x10(CX), SP	
  0x410f8d		0f8635010000		JBE 0x4110c8		
  0x410f93		4883ec30		SUBQ $0x30, SP		
  0x410f97		48896c2428		MOVQ BP, 0x28(SP)	
  0x410f9c		488d6c2428		LEAQ 0x28(SP), BP	
	if s.allocCount == 0 {
  0x410fa1		488b442440		MOVQ 0x40(SP), AX	
  0x410fa6		6683786000		CMPW $0x0, 0x60(AX)	
  0x410fab		0f84fc000000		JE 0x4110ad		
	sg := mheap_.sweepgen
  0x410fb1		8b0da1560b00		MOVL runtime.mheap_+24(SB), CX	
	stale := s.sweepgen == sg+1
  0x410fb7		8d5101			LEAL 0x1(CX), DX	
  0x410fba		8b5858			MOVL 0x58(AX), BX	
  0x410fbd		39d3			CMPL DX, BX		
	if stale {
  0x410fbf		0f85e0000000		JNE 0x4110a5		
		atomic.Store(&s.sweepgen, sg-1)
  0x410fc5		ffc9			DECL CX			
  0x410fc7		874858			XCHGL CX, 0x58(AX)	
	n := int(s.nelems) - int(s.allocCount)
  0x410fca		488b4838		MOVQ 0x38(AX), CX	
  0x410fce		0fb77060		MOVZX 0x60(AX), SI	
  0x410fd2		4889cf			MOVQ CX, DI		
  0x410fd5		4829f1			SUBQ SI, CX		
	if n > 0 {
  0x410fd8		4885c9			TESTQ CX, CX		
  0x410fdb		7f1e			JG 0x410ffb		
	stale := s.sweepgen == sg+1
  0x410fdd		39d3			CMPL DX, BX		
	if stale {
  0x410fdf		740a			JE 0x410feb		
  0x410fe1		488b6c2428		MOVQ 0x28(SP), BP	
  0x410fe6		4883c430		ADDQ $0x30, SP		
  0x410fea		c3			RET			
		s.sweep(false)
  0x410feb		48890424		MOVQ AX, 0(SP)			
  0x410fef		c644240800		MOVB $0x0, 0x8(SP)		
  0x410ff4		e807970000		CALL runtime.(*mspan).sweep(SB)	
  0x410ff9		ebe6			JMP 0x410fe1			
	stale := s.sweepgen == sg+1
  0x410ffb		8954241c		MOVL DX, 0x1c(SP)	
  0x410fff		895c2418		MOVL BX, 0x18(SP)	
		atomic.Xadd64(&c.nmalloc, -int64(n))
  0x411003		4829fe			SUBQ DI, SI		
  0x411006		4889742420		MOVQ SI, 0x20(SP)	
  0x41100b		488b442438		MOVQ 0x38(SP), AX	
  0x411010		f0480fc17030		LOCK XADDQ SI, 0x30(AX)	
		lock(&c.lock)
  0x411016		48890424		MOVQ AX, 0(SP)		
  0x41101a		e8c176ffff		CALL runtime.lock(SB)	
		c.empty.remove(s)
  0x41101f		488b442438		MOVQ 0x38(SP), AX			
  0x411024		488d4820		LEAQ 0x20(AX), CX			
  0x411028		48890c24		MOVQ CX, 0(SP)				
  0x41102c		488b4c2440		MOVQ 0x40(SP), CX			
  0x411031		48894c2408		MOVQ CX, 0x8(SP)			
  0x411036		e875d80000		CALL runtime.(*mSpanList).remove(SB)	
		c.nonempty.insert(s)
  0x41103b		488b442438		MOVQ 0x38(SP), AX			
  0x411040		488d4810		LEAQ 0x10(AX), CX			
  0x411044		48890c24		MOVQ CX, 0(SP)				
  0x411048		488b4c2440		MOVQ 0x40(SP), CX			
  0x41104d		48894c2408		MOVQ CX, 0x8(SP)			
  0x411052		e8e9d90000		CALL runtime.(*mSpanList).insert(SB)	
	stale := s.sweepgen == sg+1
  0x411057		8b442418		MOVL 0x18(SP), AX	
  0x41105b		8b4c241c		MOVL 0x1c(SP), CX	
  0x41105f		39c8			CMPL CX, AX		
		if !stale {
  0x411061		7522			JNE 0x411085		
		unlock(&c.lock)
  0x411063		488b442438		MOVQ 0x38(SP), AX	
  0x411068		48890424		MOVQ AX, 0(SP)		
  0x41106c		e81f78ffff		CALL runtime.unlock(SB)	
	stale := s.sweepgen == sg+1
  0x411071		8b442418		MOVL 0x18(SP), AX	
  0x411075		8b4c241c		MOVL 0x1c(SP), CX	
  0x411079		39c8			CMPL CX, AX		
		s.sweep(false)
  0x41107b		488b442440		MOVQ 0x40(SP), AX	
		unlock(&c.lock)
  0x411080		e95affffff		JMP 0x410fdf		
			atomic.Xadd64(&memstats.heap_live, -int64(n)*int64(s.elemsize))
  0x411085		488b542440		MOVQ 0x40(SP), DX			
  0x41108a		488b5a68		MOVQ 0x68(DX), BX			
  0x41108e		488b742420		MOVQ 0x20(SP), SI			
  0x411093		480faff3		IMULQ BX, SI				
  0x411097		488d1d02e30c00		LEAQ runtime.memstats+5952(SB), BX	
  0x41109e		f0480fc133		LOCK XADDQ SI, 0(BX)			
  0x4110a3		ebbe			JMP 0x411063				
		atomic.Store(&s.sweepgen, sg)
  0x4110a5		874858			XCHGL CX, 0x58(AX)	
  0x4110a8		e91dffffff		JMP 0x410fca		
		throw("uncaching span but s.allocCount == 0")
  0x4110ad		488d0577150600		LEAQ 0x61577(IP), AX	
  0x4110b4		48890424		MOVQ AX, 0(SP)		
  0x4110b8		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x4110c1		e8ba230100		CALL runtime.throw(SB)	
  0x4110c6		0f0b			UD2			
func (c *mcentral) uncacheSpan(s *mspan) {
  0x4110c8		e8b3670300		CALL runtime.morestack_noctxt(SB)	
  0x4110cd		e9aefeffff		JMP runtime.(*mcentral).uncacheSpan(SB)	

TEXT runtime.(*mcentral).freeSpan(SB) /usr/local/go/src/runtime/mcentral.go
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x4110e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4110e9		483b6110		CMPQ 0x10(CX), SP	
  0x4110ed		0f8678010000		JBE 0x41126b		
  0x4110f3		4883ec20		SUBQ $0x20, SP		
  0x4110f7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4110fc		488d6c2418		LEAQ 0x18(SP), BP	
	if sg := mheap_.sweepgen; s.sweepgen == sg+1 || s.sweepgen == sg+3 {
  0x411101		8b0551550b00		MOVL runtime.mheap_+24(SB), AX	
  0x411107		488b4c2430		MOVQ 0x30(SP), CX		
  0x41110c		8b5158			MOVL 0x58(CX), DX		
  0x41110f		8d5801			LEAL 0x1(AX), BX		
  0x411112		39d3			CMPL DX, BX			
  0x411114		0f8436010000		JE 0x411250			
  0x41111a		83c003			ADDL $0x3, AX			
  0x41111d		39d0			CMPL DX, AX			
  0x41111f		0f842b010000		JE 0x411250			
	s.needzero = 1
  0x411125		c6416401		MOVB $0x1, 0x64(CX)	
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x411129		0fb6442438		MOVZX 0x38(SP), AX	
  0x41112e		84c0			TESTL AL, AL		
	if preserve {
  0x411130		7424			JE 0x411156		
		if !s.inList() {
  0x411132		90			NOPL			
	return span.list != nil
  0x411133		4883791000		CMPQ $0x0, 0x10(CX)	
		if !s.inList() {
  0x411138		0f84f7000000		JE 0x411235		
		atomic.Store(&s.sweepgen, mheap_.sweepgen)
  0x41113e		8b0514550b00		MOVL runtime.mheap_+24(SB), AX	
  0x411144		874158			XCHGL AX, 0x58(CX)		
		return false
  0x411147		c644244000		MOVB $0x0, 0x40(SP)	
  0x41114c		488b6c2418		MOVQ 0x18(SP), BP	
  0x411151		4883c420		ADDQ $0x20, SP		
  0x411155		c3			RET			
	lock(&c.lock)
  0x411156		488b442428		MOVQ 0x28(SP), AX	
  0x41115b		8400			TESTB AL, 0(AX)		
  0x41115d		48890424		MOVQ AX, 0(SP)		
  0x411161		e87a75ffff		CALL runtime.lock(SB)	
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x411166		0fb6442439		MOVZX 0x39(SP), AX	
  0x41116b		84c0			TESTL AL, AL		
	if wasempty {
  0x41116d		0f8585000000		JNE 0x4111f8		
	atomic.Store(&s.sweepgen, mheap_.sweepgen)
  0x411173		8b05df540b00		MOVL runtime.mheap_+24(SB), AX	
  0x411179		488b4c2430		MOVQ 0x30(SP), CX		
  0x41117e		874158			XCHGL AX, 0x58(CX)		
	if s.allocCount != 0 {
  0x411181		6683796000		CMPW $0x0, 0x60(CX)	
  0x411186		741d			JE 0x4111a5		
		unlock(&c.lock)
  0x411188		488b442428		MOVQ 0x28(SP), AX	
  0x41118d		48890424		MOVQ AX, 0(SP)		
  0x411191		e8fa76ffff		CALL runtime.unlock(SB)	
		return false
  0x411196		c644244000		MOVB $0x0, 0x40(SP)	
  0x41119b		488b6c2418		MOVQ 0x18(SP), BP	
  0x4111a0		4883c420		ADDQ $0x20, SP		
  0x4111a4		c3			RET			
	c.nonempty.remove(s)
  0x4111a5		488b442428		MOVQ 0x28(SP), AX			
  0x4111aa		488d5010		LEAQ 0x10(AX), DX			
  0x4111ae		48891424		MOVQ DX, 0(SP)				
  0x4111b2		48894c2408		MOVQ CX, 0x8(SP)			
  0x4111b7		e8f4d60000		CALL runtime.(*mSpanList).remove(SB)	
	unlock(&c.lock)
  0x4111bc		488b442428		MOVQ 0x28(SP), AX	
  0x4111c1		48890424		MOVQ AX, 0(SP)		
  0x4111c5		e8c676ffff		CALL runtime.unlock(SB)	
	mheap_.freeSpan(s, false)
  0x4111ca		488d056f540b00		LEAQ runtime.mheap_(SB), AX		
  0x4111d1		48890424		MOVQ AX, 0(SP)				
  0x4111d5		488b442430		MOVQ 0x30(SP), AX			
  0x4111da		4889442408		MOVQ AX, 0x8(SP)			
  0x4111df		c644241000		MOVB $0x0, 0x10(SP)			
  0x4111e4		e827cd0000		CALL runtime.(*mheap).freeSpan(SB)	
	return true
  0x4111e9		c644244001		MOVB $0x1, 0x40(SP)	
  0x4111ee		488b6c2418		MOVQ 0x18(SP), BP	
  0x4111f3		4883c420		ADDQ $0x20, SP		
  0x4111f7		c3			RET			
		c.empty.remove(s)
  0x4111f8		488b442428		MOVQ 0x28(SP), AX			
  0x4111fd		488d4820		LEAQ 0x20(AX), CX			
  0x411201		48890c24		MOVQ CX, 0(SP)				
  0x411205		488b4c2430		MOVQ 0x30(SP), CX			
  0x41120a		48894c2408		MOVQ CX, 0x8(SP)			
  0x41120f		e89cd60000		CALL runtime.(*mSpanList).remove(SB)	
		c.nonempty.insert(s)
  0x411214		488b442428		MOVQ 0x28(SP), AX			
  0x411219		488d4810		LEAQ 0x10(AX), CX			
  0x41121d		48890c24		MOVQ CX, 0(SP)				
  0x411221		488b4c2430		MOVQ 0x30(SP), CX			
  0x411226		48894c2408		MOVQ CX, 0x8(SP)			
  0x41122b		e810d80000		CALL runtime.(*mSpanList).insert(SB)	
  0x411230		e93effffff		JMP 0x411173				
			throw("can't preserve unlinked span")
  0x411235		488d050a040600		LEAQ 0x6040a(IP), AX	
  0x41123c		48890424		MOVQ AX, 0(SP)		
  0x411240		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x411249		e832220100		CALL runtime.throw(SB)	
  0x41124e		0f0b			UD2			
		throw("freeSpan given cached span")
  0x411250		488d05d5ff0500		LEAQ 0x5ffd5(IP), AX	
  0x411257		48890424		MOVQ AX, 0(SP)		
  0x41125b		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x411264		e817220100		CALL runtime.throw(SB)	
  0x411269		0f0b			UD2			
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
  0x41126b		e810660300		CALL runtime.morestack_noctxt(SB)	
  0x411270		e96bfeffff		JMP runtime.(*mcentral).freeSpan(SB)	

TEXT runtime.(*mcentral).grow(SB) /usr/local/go/src/runtime/mcentral.go
func (c *mcentral) grow() *mspan {
  0x411280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411289		483b6110		CMPQ 0x10(CX), SP	
  0x41128d		0f8661010000		JBE 0x4113f4		
  0x411293		4883ec40		SUBQ $0x40, SP		
  0x411297		48896c2438		MOVQ BP, 0x38(SP)	
  0x41129c		488d6c2438		LEAQ 0x38(SP), BP	
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x4112a1		488b4c2448		MOVQ 0x48(SP), CX	
  0x4112a6		0fb64908		MOVZX 0x8(CX), CX	
	return int8(sc >> 1)
  0x4112aa		89ca			MOVL CX, DX		
  0x4112ac		d0e9			SHRL $0x1, CL		
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x4112ae		480fbec9		MOVSX CL, CX					
  0x4112b2		90			NOPL						
  0x4112b3		4883f943		CMPQ $0x43, CX					
  0x4112b7		0f8330010000		JAE 0x4113ed					
  0x4112bd		488d1d1cde0a00		LEAQ runtime.class_to_allocnpages(SB), BX	
  0x4112c4		0fb6040b		MOVZX 0(BX)(CX*1), AX				
	size := uintptr(class_to_size[c.spanclass.sizeclass()])
  0x4112c8		488d1d11df0a00		LEAQ runtime.class_to_size(SB), BX	
  0x4112cf		0fb70c4b		MOVZX 0(BX)(CX*2), CX			
  0x4112d3		90			NOPL					
	n := (npages << _PageShift) / size
  0x4112d4		4885c9			TESTQ CX, CX		
  0x4112d7		0f8409010000		JE 0x4113e6		
	size := uintptr(class_to_size[c.spanclass.sizeclass()])
  0x4112dd		66894c2426		MOVW CX, 0x26(SP)	
	n := (npages << _PageShift) / size
  0x4112e2		89c3			MOVL AX, BX		
  0x4112e4		48c1e00d		SHLQ $0xd, AX		
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x4112e8		89d6			MOVL DX, SI		
	n := (npages << _PageShift) / size
  0x4112ea		31d2			XORL DX, DX		
  0x4112ec		48f7f1			DIVQ CX			
  0x4112ef		4889442428		MOVQ AX, 0x28(SP)	
	s := mheap_.alloc(npages, c.spanclass, false, true)
  0x4112f4		488d1545530b00		LEAQ runtime.mheap_(SB), DX	
  0x4112fb		48891424		MOVQ DX, 0(SP)			
  0x4112ff		48895c2408		MOVQ BX, 0x8(SP)		
  0x411304		4088742410		MOVB SI, 0x10(SP)		
  0x411309		66c74424110001		MOVW $0x100, 0x11(SP)		
  0x411310		e89bc10000		CALL runtime.(*mheap).alloc(SB)	
  0x411315		488b4c2418		MOVQ 0x18(SP), CX		
	if s == nil {
  0x41131a		4885c9			TESTQ CX, CX		
  0x41131d		0f84a9000000		JE 0x4113cc		
	p := s.base()
  0x411323		90			NOPL			
	s.limit = p + size*n
  0x411324		0fb7442426		MOVZX 0x26(SP), AX	
  0x411329		488b542428		MOVQ 0x28(SP), DX	
  0x41132e		480fafc2		IMULQ DX, AX		
  0x411332		48034118		ADDQ 0x18(CX), AX	
  0x411336		48894178		MOVQ AX, 0x78(CX)	
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41133a		488b050f560b00		MOVQ runtime.mheap_+784(SB), AX	
  0x411341		8400			TESTB AL, 0(AX)			
	heapBitsForAddr(s.base()).initSpan(s)
  0x411343		90			NOPL			
  0x411344		90			NOPL			
	return s.startAddr
  0x411345		488b5118		MOVQ 0x18(CX), DX	
	arena := arenaIndex(addr)
  0x411349		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41134a		90			NOPL			
  0x41134b		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41134c		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x411356		4801d3			ADDQ DX, BX			
  0x411359		48c1eb1a		SHRQ $0x1a, BX			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41135d		4881fb00004000		CMPQ $0x400000, BX	
  0x411364		7379			JAE 0x4113df		
  0x411366		488b04d8		MOVQ 0(AX)(BX*8), AX	
	if ha == nil {
  0x41136a		4885c0			TESTQ AX, AX		
  0x41136d		7453			JE 0x4113c2		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x41136f		4889d6			MOVQ DX, SI		
  0x411372		48c1ea05		SHRQ $0x5, DX		
  0x411376		4881e2ffff1f00		ANDQ $0x1fffff, DX	
  0x41137d		4801c2			ADDQ AX, DX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x411380		48c1ee03		SHRQ $0x3, SI		
  0x411384		4883e603		ANDQ $0x3, SI		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x411388		4805ffff1f00		ADDQ $0x1fffff, AX	
	s := mheap_.alloc(npages, c.spanclass, false, true)
  0x41138e		48894c2430		MOVQ CX, 0x30(SP)	
	heapBitsForAddr(s.base()).initSpan(s)
  0x411393		48891424		MOVQ DX, 0(SP)				
  0x411397		89742408		MOVL SI, 0x8(SP)			
  0x41139b		895c240c		MOVL BX, 0xc(SP)			
  0x41139f		4889442410		MOVQ AX, 0x10(SP)			
  0x4113a4		48894c2418		MOVQ CX, 0x18(SP)			
  0x4113a9		e8d2d8ffff		CALL runtime.heapBits.initSpan(SB)	
	return s
  0x4113ae		488b442430		MOVQ 0x30(SP), AX	
  0x4113b3		4889442450		MOVQ AX, 0x50(SP)	
  0x4113b8		488b6c2438		MOVQ 0x38(SP), BP	
  0x4113bd		4883c440		ADDQ $0x40, SP		
  0x4113c1		c3			RET			
  0x4113c2		31c0			XORL AX, AX		
  0x4113c4		31db			XORL BX, BX		
  0x4113c6		31f6			XORL SI, SI		
  0x4113c8		31d2			XORL DX, DX		
	heapBitsForAddr(s.base()).initSpan(s)
  0x4113ca		ebc2			JMP 0x41138e		
		return nil
  0x4113cc		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x4113d5		488b6c2438		MOVQ 0x38(SP), BP	
  0x4113da		4883c440		ADDQ $0x40, SP		
  0x4113de		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x4113df		e83c0b0100		CALL runtime.panicindex(SB)	
  0x4113e4		0f0b			UD2				
	n := (npages << _PageShift) / size
  0x4113e6		e8950d0100		CALL runtime.panicdivide(SB)	
  0x4113eb		0f0b			UD2				
	npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])
  0x4113ed		e82e0b0100		CALL runtime.panicindex(SB)	
  0x4113f2		0f0b			UD2				
func (c *mcentral) grow() *mspan {
  0x4113f4		e887640300		CALL runtime.morestack_noctxt(SB)	
  0x4113f9		e982feffff		JMP runtime.(*mcentral).grow(SB)	

TEXT runtime.sysAlloc(SB) /usr/local/go/src/runtime/mem_linux.go
func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {
  0x411400		4883ec48		SUBQ $0x48, SP		
  0x411404		48896c2440		MOVQ BP, 0x40(SP)	
  0x411409		488d6c2440		LEAQ 0x40(SP), BP	
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x41140e		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x411416		488b442450		MOVQ 0x50(SP), AX	
  0x41141b		4889442408		MOVQ AX, 0x8(SP)	
  0x411420		48b90300000022000000	MOVQ $0x2200000003, CX	
  0x41142a		48894c2410		MOVQ CX, 0x10(SP)	
  0x41142f		b9ffffffff		MOVL $-0x1, CX		
  0x411434		48894c2418		MOVQ CX, 0x18(SP)	
  0x411439		e84220ffff		CALL runtime.mmap(SB)	
  0x41143e		488b442420		MOVQ 0x20(SP), AX	
  0x411443		488b4c2428		MOVQ 0x28(SP), CX	
	if err != 0 {
  0x411448		4885c9			TESTQ CX, CX		
  0x41144b		0f848e000000		JE 0x4114df		
		if err == _EACCES {
  0x411451		4883f90d		CMPQ $0xd, CX		
  0x411455		744a			JE 0x4114a1		
		if err == _EAGAIN {
  0x411457		4883f90b		CMPQ $0xb, CX		
  0x41145b		7413			JE 0x411470		
		return nil
  0x41145d		48c744246000000000	MOVQ $0x0, 0x60(SP)	
  0x411466		488b6c2440		MOVQ 0x40(SP), BP	
  0x41146b		4883c448		ADDQ $0x48, SP		
  0x41146f		c3			RET			
			print("runtime: mmap: too much locked memory (check 'ulimit -l').\n")
  0x411470		e84b2a0100		CALL runtime.printlock(SB)	
  0x411475		488d05b7200600		LEAQ 0x620b7(IP), AX		
  0x41147c		48890424		MOVQ AX, 0(SP)			
  0x411480		48c74424083b000000	MOVQ $0x3b, 0x8(SP)		
  0x411489		e862330100		CALL runtime.printstring(SB)	
  0x41148e		e8ad2a0100		CALL runtime.printunlock(SB)	
			exit(2)
  0x411493		c7042402000000		MOVL $0x2, 0(SP)	
  0x41149a		e881990300		CALL runtime.exit(SB)	
  0x41149f		ebbc			JMP 0x41145d		
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x4114a1		48894c2430		MOVQ CX, 0x30(SP)	
			print("runtime: mmap: access denied\n")
  0x4114a6		e8152a0100		CALL runtime.printlock(SB)	
  0x4114ab		488d0591040600		LEAQ 0x60491(IP), AX		
  0x4114b2		48890424		MOVQ AX, 0(SP)			
  0x4114b6		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x4114bf		e82c330100		CALL runtime.printstring(SB)	
  0x4114c4		e8772a0100		CALL runtime.printunlock(SB)	
			exit(2)
  0x4114c9		c7042402000000		MOVL $0x2, 0(SP)	
  0x4114d0		e84b990300		CALL runtime.exit(SB)	
		if err == _EAGAIN {
  0x4114d5		488b4c2430		MOVQ 0x30(SP), CX	
			exit(2)
  0x4114da		e978ffffff		JMP 0x411457		
	p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x4114df		4889442438		MOVQ AX, 0x38(SP)	
	mSysStatInc(sysStat, n)
  0x4114e4		488b442458		MOVQ 0x58(SP), AX		
  0x4114e9		48890424		MOVQ AX, 0(SP)			
  0x4114ed		488b442450		MOVQ 0x50(SP), AX		
  0x4114f2		4889442408		MOVQ AX, 0x8(SP)		
  0x4114f7		e8f4f40000		CALL runtime.mSysStatInc(SB)	
	return p
  0x4114fc		488b442438		MOVQ 0x38(SP), AX	
  0x411501		4889442460		MOVQ AX, 0x60(SP)	
  0x411506		488b6c2440		MOVQ 0x40(SP), BP	
  0x41150b		4883c448		ADDQ $0x48, SP		
  0x41150f		c3			RET			

TEXT runtime.sysUnused(SB) /usr/local/go/src/runtime/mem_linux.go
func sysUnused(v unsafe.Pointer, n uintptr) {
  0x411510		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411519		483b6110		CMPQ 0x10(CX), SP	
  0x41151d		0f86c9010000		JBE 0x4116ec		
  0x411523		4883ec40		SUBQ $0x40, SP		
  0x411527		48896c2438		MOVQ BP, 0x38(SP)	
  0x41152c		488d6c2438		LEAQ 0x38(SP), BP	
		if uintptr(v)%s != 0 {
  0x411531		488b442448		MOVQ 0x48(SP), AX	
  0x411536		4889c1			MOVQ AX, CX		
			head = uintptr(v) &^ (s - 1)
  0x411539		4889c2			MOVQ AX, DX		
  0x41153c		48250000e0ff		ANDQ $-0x200000, AX	
		if uintptr(v)%s != 0 {
  0x411542		48f7c2ffff1f00		TESTQ $0x1fffff, DX	
		if head != 0 && head+sys.HugePageSize == tail {
  0x411549		bb00000000		MOVL $0x0, BX		
  0x41154e		480f45d8		CMOVNE AX, BX		
		if (uintptr(v)+n)%s != 0 {
  0x411552		488b442450		MOVQ 0x50(SP), AX	
  0x411557		488d3410		LEAQ 0(AX)(DX*1), SI	
			tail = (uintptr(v) + n - 1) &^ (s - 1)
  0x41155b		488d1410		LEAQ 0(AX)(DX*1), DX	
  0x41155f		488d52ff		LEAQ -0x1(DX), DX	
  0x411563		4881e20000e0ff		ANDQ $-0x200000, DX	
		if (uintptr(v)+n)%s != 0 {
  0x41156a		48f7c6ffff1f00		TESTQ $0x1fffff, SI	
			if tail != 0 && tail != head {
  0x411571		be00000000		MOVL $0x0, SI		
  0x411576		480f45f2		CMOVNE DX, SI		
		if head != 0 && head+sys.HugePageSize == tail {
  0x41157a		4885db			TESTQ BX, BX		
		if uintptr(v)%s != 0 {
  0x41157d		7413			JE 0x411592		
		if head != 0 && head+sys.HugePageSize == tail {
  0x41157f		488d9300002000		LEAQ 0x200000(BX), DX	
  0x411586		4839f2			CMPQ SI, DX		
  0x411589		0f8419010000		JE 0x4116a8		
  0x41158f		4885db			TESTQ BX, BX		
			if head != 0 {
  0x411592		0f85d3000000		JNE 0x41166b		
			if tail != 0 && tail != head {
  0x411598		4885f6			TESTQ SI, SI		
  0x41159b		7409			JE 0x4115a6		
  0x41159d		4839f3			CMPQ SI, BX		
  0x4115a0		0f859c000000		JNE 0x411642		
	if uintptr(v)&(physPageSize-1) != 0 || n&(physPageSize-1) != 0 {
  0x4115a6		4889ca			MOVQ CX, DX				
  0x4115a9		488b1df8b70c00		MOVQ runtime.physPageSize(SB), BX	
  0x4115b0		48ffcb			DECQ BX					
  0x4115b3		4885d9			TESTQ BX, CX				
  0x4115b6		0f8515010000		JNE 0x4116d1				
  0x4115bc		4885d8			TESTQ BX, AX				
  0x4115bf		0f850c010000		JNE 0x4116d1				
	if debug.madvdontneed != 0 {
  0x4115c5		833d3cb90c0000		CMPL $0x0, runtime.debug+40(SB)	
  0x4115cc		746a			JE 0x411638			
  0x4115ce		b904000000		MOVL $0x4, CX			
	if errno := madvise(v, n, int32(advise)); advise == _MADV_FREE && errno != 0 {
  0x4115d3		894c2424		MOVL CX, 0x24(SP)		
  0x4115d7		48891424		MOVQ DX, 0(SP)			
  0x4115db		4889442408		MOVQ AX, 0x8(SP)		
  0x4115e0		894c2410		MOVL CX, 0x10(SP)		
  0x4115e4		e8a79e0300		CALL runtime.madvise(SB)	
  0x4115e9		8b442418		MOVL 0x18(SP), AX		
  0x4115ed		83f800			CMPL $0x0, AX			
  0x4115f0		8b4c2424		MOVL 0x24(SP), CX		
  0x4115f4		83f908			CMPL $0x8, CX			
  0x4115f7		7505			JNE 0x4115fe			
  0x4115f9		83f800			CMPL $0x0, AX			
  0x4115fc		750a			JNE 0x411608			
  0x4115fe		488b6c2438		MOVQ 0x38(SP), BP		
  0x411603		4883c440		ADDQ $0x40, SP			
  0x411607		c3			RET				
		atomic.Store(&adviseUnused, _MADV_DONTNEED)
  0x411608		b804000000		MOVL $0x4, AX				
  0x41160d		488d0df0d90a00		LEAQ runtime.adviseUnused(SB), CX	
  0x411614		8701			XCHGL AX, 0(CX)				
		madvise(v, n, _MADV_DONTNEED)
  0x411616		488b442448		MOVQ 0x48(SP), AX		
  0x41161b		48890424		MOVQ AX, 0(SP)			
  0x41161f		488b442450		MOVQ 0x50(SP), AX		
  0x411624		4889442408		MOVQ AX, 0x8(SP)		
  0x411629		c744241004000000	MOVL $0x4, 0x10(SP)		
  0x411631		e85a9e0300		CALL runtime.madvise(SB)	
  0x411636		ebc6			JMP 0x4115fe			
		advise = atomic.Load(&adviseUnused)
  0x411638		8b1dc6d90a00		MOVL runtime.adviseUnused(SB), BX	
	if errno := madvise(v, n, int32(advise)); advise == _MADV_FREE && errno != 0 {
  0x41163e		89d9			MOVL BX, CX		
		advise = atomic.Load(&adviseUnused)
  0x411640		eb91			JMP 0x4115d3		
				madvise(unsafe.Pointer(tail), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x411642		48893424		MOVQ SI, 0(SP)			
  0x411646		48c744240800002000	MOVQ $0x200000, 0x8(SP)		
  0x41164f		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x411657		e8349e0300		CALL runtime.madvise(SB)	
	if uintptr(v)&(physPageSize-1) != 0 || n&(physPageSize-1) != 0 {
  0x41165c		488b442450		MOVQ 0x50(SP), AX	
  0x411661		488b4c2448		MOVQ 0x48(SP), CX	
				madvise(unsafe.Pointer(tail), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x411666		e93bffffff		JMP 0x4115a6		
			if tail != 0 && tail != head {
  0x41166b		4889742428		MOVQ SI, 0x28(SP)	
		if head != 0 && head+sys.HugePageSize == tail {
  0x411670		48895c2430		MOVQ BX, 0x30(SP)	
				madvise(unsafe.Pointer(head), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x411675		48891c24		MOVQ BX, 0(SP)			
  0x411679		48c744240800002000	MOVQ $0x200000, 0x8(SP)		
  0x411682		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x41168a		e8019e0300		CALL runtime.madvise(SB)	
	if uintptr(v)&(physPageSize-1) != 0 || n&(physPageSize-1) != 0 {
  0x41168f		488b442450		MOVQ 0x50(SP), AX	
  0x411694		488b4c2448		MOVQ 0x48(SP), CX	
			if tail != 0 && tail != head {
  0x411699		488b5c2430		MOVQ 0x30(SP), BX	
  0x41169e		488b742428		MOVQ 0x28(SP), SI	
				madvise(unsafe.Pointer(head), sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x4116a3		e9f0feffff		JMP 0x411598		
			madvise(unsafe.Pointer(head), 2*sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x4116a8		48891c24		MOVQ BX, 0(SP)			
  0x4116ac		48c744240800004000	MOVQ $0x400000, 0x8(SP)		
  0x4116b5		c74424100f000000	MOVL $0xf, 0x10(SP)		
  0x4116bd		e8ce9d0300		CALL runtime.madvise(SB)	
	if uintptr(v)&(physPageSize-1) != 0 || n&(physPageSize-1) != 0 {
  0x4116c2		488b442450		MOVQ 0x50(SP), AX	
  0x4116c7		488b4c2448		MOVQ 0x48(SP), CX	
			madvise(unsafe.Pointer(head), 2*sys.HugePageSize, _MADV_NOHUGEPAGE)
  0x4116cc		e9d5feffff		JMP 0x4115a6		
		throw("unaligned sysUnused")
  0x4116d1		488d0547ee0500		LEAQ 0x5ee47(IP), AX	
  0x4116d8		48890424		MOVQ AX, 0(SP)		
  0x4116dc		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x4116e5		e8961d0100		CALL runtime.throw(SB)	
  0x4116ea		0f0b			UD2			
func sysUnused(v unsafe.Pointer, n uintptr) {
  0x4116ec		e88f610300		CALL runtime.morestack_noctxt(SB)	
  0x4116f1		e91afeffff		JMP runtime.sysUnused(SB)		

TEXT runtime.sysUsed(SB) /usr/local/go/src/runtime/mem_linux.go
func sysUsed(v unsafe.Pointer, n uintptr) {
  0x411700		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411709		483b6110		CMPQ 0x10(CX), SP	
  0x41170d		765c			JBE 0x41176b		
  0x41170f		4883ec28		SUBQ $0x28, SP		
  0x411713		48896c2420		MOVQ BP, 0x20(SP)	
  0x411718		488d6c2420		LEAQ 0x20(SP), BP	
		beg := (uintptr(v) + (s - 1)) &^ (s - 1)
  0x41171d		488b442430		MOVQ 0x30(SP), AX	
  0x411722		488d88ffff1f00		LEAQ 0x1fffff(AX), CX	
  0x411729		4881e10000e0ff		ANDQ $-0x200000, CX	
		end := (uintptr(v) + n) &^ (s - 1)
  0x411730		488b542438		MOVQ 0x38(SP), DX	
  0x411735		4801d0			ADDQ DX, AX		
  0x411738		48250000e0ff		ANDQ $-0x200000, AX	
		if beg < end {
  0x41173e		4839c1			CMPQ AX, CX		
  0x411741		720a			JB 0x41174d		
  0x411743		488b6c2420		MOVQ 0x20(SP), BP	
  0x411748		4883c428		ADDQ $0x28, SP		
  0x41174c		c3			RET			
			madvise(unsafe.Pointer(beg), end-beg, _MADV_HUGEPAGE)
  0x41174d		4889ca			MOVQ CX, DX			
  0x411750		48890c24		MOVQ CX, 0(SP)			
  0x411754		4829d0			SUBQ DX, AX			
  0x411757		4889442408		MOVQ AX, 0x8(SP)		
  0x41175c		c74424100e000000	MOVL $0xe, 0x10(SP)		
  0x411764		e8279d0300		CALL runtime.madvise(SB)	
  0x411769		ebd8			JMP 0x411743			
func sysUsed(v unsafe.Pointer, n uintptr) {
  0x41176b		e810610300		CALL runtime.morestack_noctxt(SB)	
  0x411770		eb8e			JMP runtime.sysUsed(SB)			

TEXT runtime.sysFree(SB) /usr/local/go/src/runtime/mem_linux.go
func sysFree(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x411780		4883ec18		SUBQ $0x18, SP		
  0x411784		48896c2410		MOVQ BP, 0x10(SP)	
  0x411789		488d6c2410		LEAQ 0x10(SP), BP	
	mSysStatDec(sysStat, n)
  0x41178e		488b442430		MOVQ 0x30(SP), AX		
  0x411793		48890424		MOVQ AX, 0(SP)			
  0x411797		488b442428		MOVQ 0x28(SP), AX		
  0x41179c		4889442408		MOVQ AX, 0x8(SP)		
  0x4117a1		e80af30000		CALL runtime.mSysStatDec(SB)	
	munmap(v, n)
  0x4117a6		488b442420		MOVQ 0x20(SP), AX	
  0x4117ab		48890424		MOVQ AX, 0(SP)		
  0x4117af		488b442428		MOVQ 0x28(SP), AX	
  0x4117b4		4889442408		MOVQ AX, 0x8(SP)	
  0x4117b9		e8321effff		CALL runtime.munmap(SB)	
}
  0x4117be		488b6c2410		MOVQ 0x10(SP), BP	
  0x4117c3		4883c418		ADDQ $0x18, SP		
  0x4117c7		c3			RET			

TEXT runtime.sysMap(SB) /usr/local/go/src/runtime/mem_linux.go
func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x4117d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4117d9		483b6110		CMPQ 0x10(CX), SP	
  0x4117dd		0f86b6000000		JBE 0x411899		
  0x4117e3		4883ec38		SUBQ $0x38, SP		
  0x4117e7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4117ec		488d6c2430		LEAQ 0x30(SP), BP	
	mSysStatInc(sysStat, n)
  0x4117f1		488b442450		MOVQ 0x50(SP), AX		
  0x4117f6		48890424		MOVQ AX, 0(SP)			
  0x4117fa		488b442448		MOVQ 0x48(SP), AX		
  0x4117ff		4889442408		MOVQ AX, 0x8(SP)		
  0x411804		e8e7f10000		CALL runtime.mSysStatInc(SB)	
	p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)
  0x411809		488b442440		MOVQ 0x40(SP), AX	
  0x41180e		48890424		MOVQ AX, 0(SP)		
  0x411812		488b4c2448		MOVQ 0x48(SP), CX	
  0x411817		48894c2408		MOVQ CX, 0x8(SP)	
  0x41181c		48b90300000032000000	MOVQ $0x3200000003, CX	
  0x411826		48894c2410		MOVQ CX, 0x10(SP)	
  0x41182b		b9ffffffff		MOVL $-0x1, CX		
  0x411830		48894c2418		MOVQ CX, 0x18(SP)	
  0x411835		e8461cffff		CALL runtime.mmap(SB)	
  0x41183a		488b442420		MOVQ 0x20(SP), AX	
  0x41183f		488b4c2428		MOVQ 0x28(SP), CX	
	if err == _ENOMEM {
  0x411844		4883f90c		CMPQ $0xc, CX		
  0x411848		7434			JE 0x41187e		
	if p != v || err != 0 {
  0x41184a		488b542440		MOVQ 0x40(SP), DX	
  0x41184f		4839d0			CMPQ DX, AX		
  0x411852		750f			JNE 0x411863		
  0x411854		4885c9			TESTQ CX, CX		
  0x411857		750a			JNE 0x411863		
  0x411859		488b6c2430		MOVQ 0x30(SP), BP	
  0x41185e		4883c438		ADDQ $0x38, SP		
  0x411862		c3			RET			
		throw("runtime: cannot map pages in arena address space")
  0x411863		488d0545180600		LEAQ 0x61845(IP), AX	
  0x41186a		48890424		MOVQ AX, 0(SP)		
  0x41186e		48c744240830000000	MOVQ $0x30, 0x8(SP)	
  0x411877		e8041c0100		CALL runtime.throw(SB)	
  0x41187c		0f0b			UD2			
		throw("runtime: out of memory")
  0x41187e		488d05daf10500		LEAQ 0x5f1da(IP), AX	
  0x411885		48890424		MOVQ AX, 0(SP)		
  0x411889		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x411892		e8e91b0100		CALL runtime.throw(SB)	
  0x411897		0f0b			UD2			
func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {
  0x411899		e8e25f0300		CALL runtime.morestack_noctxt(SB)	
  0x41189e		e92dffffff		JMP runtime.sysMap(SB)			

TEXT runtime.queuefinalizer(SB) /usr/local/go/src/runtime/mfinal.go
func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {
  0x4118b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4118b9		483b6110		CMPQ 0x10(CX), SP	
  0x4118bd		0f8627020000		JBE 0x411aea		
  0x4118c3		4883ec28		SUBQ $0x28, SP		
  0x4118c7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4118cc		488d6c2420		LEAQ 0x20(SP), BP	
	if gcphase != _GCoff {
  0x4118d1		833d04b40c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x4118d8		0f85f1010000		JNE 0x411acf			
	lock(&finlock)
  0x4118de		488d058bb40c00		LEAQ runtime.finlock(SB), AX	
  0x4118e5		48890424		MOVQ AX, 0(SP)			
  0x4118e9		e8f26dffff		CALL runtime.lock(SB)		
	if finq == nil || finq.cnt == uint32(len(finq.fin)) {
  0x4118ee		488b056b000b00		MOVQ runtime.finq(SB), AX	
  0x4118f5		4885c0			TESTQ AX, AX			
  0x4118f8		740a			JE 0x411904			
  0x4118fa		83781065		CMPL $0x65, 0x10(AX)		
  0x4118fe		0f85da000000		JNE 0x4119de			
		if finc == nil {
  0x411904		48833d44000b0000	CMPQ $0x0, runtime.finc(SB)	
  0x41190c		0f85a8000000		JNE 0x4119ba			
			finc = (*finblock)(persistentalloc(_FinBlockSize, 0, &memstats.gc_sys))
  0x411912		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x41191a		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x411923		488d05cec30c00		LEAQ runtime.memstats+152(SB), AX	
  0x41192a		4889442410		MOVQ AX, 0x10(SP)			
  0x41192f		e83c91ffff		CALL runtime.persistentalloc(SB)	
  0x411934		488b442418		MOVQ 0x18(SP), AX			
  0x411939		48890510000b00		MOVQ AX, runtime.finc(SB)		
			finc.alllink = allfin
  0x411940		488b0dc9ff0a00		MOVQ runtime.allfin(SB), CX	
  0x411947		488908			MOVQ CX, 0(AX)			
			allfin = finc
  0x41194a		488b05ffff0a00		MOVQ runtime.finc(SB), AX	
  0x411951		488905b8ff0a00		MOVQ AX, runtime.allfin(SB)	
			if finptrmask[0] == 0 {
  0x411958		803dc1b50c0000		CMPB $0x0, runtime.finptrmask(SB)	
  0x41195f		7559			JNE 0x4119ba				
  0x411961		31c0			XORL AX, AX				
				for i := range finptrmask {
  0x411963		eb19			JMP 0x41197e		
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x411965		488d0da8d60a00		LEAQ runtime.finalizer1(SB), CX	
  0x41196c		0fb61c19		MOVZX 0(CX)(BX*1), BX		
  0x411970		488d35a9b50c00		LEAQ runtime.finptrmask(SB), SI	
  0x411977		881c16			MOVB BL, 0(SI)(DX*1)		
				for i := range finptrmask {
  0x41197a		488d4201		LEAQ 0x1(DX), AX	
  0x41197e		4883f840		CMPQ $0x40, AX		
  0x411982		7d36			JGE 0x4119ba		
  0x411984		4889c1			MOVQ AX, CX		
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x411987		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
  0x411991		48f7e9			IMULQ CX			
  0x411994		4801ca			ADDQ CX, DX			
  0x411997		48c1fa02		SARQ $0x2, DX			
  0x41199b		4889cb			MOVQ CX, BX			
  0x41199e		48c1f93f		SARQ $0x3f, CX			
  0x4119a2		4829ca			SUBQ CX, DX			
  0x4119a5		488d0c92		LEAQ 0(DX)(DX*4), CX		
  0x4119a9		4889da			MOVQ BX, DX			
  0x4119ac		4829cb			SUBQ CX, BX			
  0x4119af		4883fb05		CMPQ $0x5, BX			
  0x4119b3		72b0			JB 0x411965			
  0x4119b5		e90e010000		JMP 0x411ac8			
		block := finc
  0x4119ba		488b0d8fff0a00		MOVQ runtime.finc(SB), CX	
		finc = block.next
  0x4119c1		488b5108		MOVQ 0x8(CX), DX		
  0x4119c5		48891584ff0a00		MOVQ DX, runtime.finc(SB)	
		block.next = finq
  0x4119cc		488b158dff0a00		MOVQ runtime.finq(SB), DX	
  0x4119d3		48895108		MOVQ DX, 0x8(CX)		
		finq = block
  0x4119d7		48890d82ff0a00		MOVQ CX, runtime.finq(SB)	
	f := &finq.fin[finq.cnt]
  0x4119de		488b0d7bff0a00		MOVQ runtime.finq(SB), CX	
  0x4119e5		8b5110			MOVL 0x10(CX), DX		
  0x4119e8		4883fa65		CMPQ $0x65, DX			
  0x4119ec		0f83cf000000		JAE 0x411ac1			
	atomic.Xadd(&finq.cnt, +1) // Sync with markroots
  0x4119f2		bb01000000		MOVL $0x1, BX		
  0x4119f7		f00fc15910		LOCK XADDL BX, 0x10(CX)	
	f := &finq.fin[finq.cnt]
  0x4119fc		488d1492		LEAQ 0(DX)(DX*4), DX	
	f.fn = fn
  0x411a00		488d3cd1		LEAQ 0(CX)(DX*8), DI	
  0x411a04		488d7f18		LEAQ 0x18(DI), DI	
	f.fint = fint
  0x411a08		488d1cd1		LEAQ 0(CX)(DX*8), BX	
  0x411a0c		488d5b30		LEAQ 0x30(BX), BX	
	f.ot = ot
  0x411a10		488d34d1		LEAQ 0(CX)(DX*8), SI	
  0x411a14		488d7638		LEAQ 0x38(SI), SI	
	f.arg = p
  0x411a18		4c8d04d1		LEAQ 0(CX)(DX*8), R8	
  0x411a1c		4d8d4020		LEAQ 0x20(R8), R8	
	f.fn = fn
  0x411a20		833df9b30c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x411a27		0f8585000000		JNE 0x411ab2				
  0x411a2d		4c8b4c2438		MOVQ 0x38(SP), R9			
  0x411a32		4c894cd118		MOVQ R9, 0x18(CX)(DX*8)			
	f.nret = nret
  0x411a37		4c8b4c2440		MOVQ 0x40(SP), R9	
  0x411a3c		4c894cd128		MOVQ R9, 0x28(CX)(DX*8)	
	f.fint = fint
  0x411a41		833dd8b30c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x411a48		753f			JNE 0x411a89				
  0x411a4a		488b442448		MOVQ 0x48(SP), AX			
  0x411a4f		488944d130		MOVQ AX, 0x30(CX)(DX*8)			
	f.ot = ot
  0x411a54		488b442450		MOVQ 0x50(SP), AX	
  0x411a59		488944d138		MOVQ AX, 0x38(CX)(DX*8)	
	f.arg = p
  0x411a5e		488b442430		MOVQ 0x30(SP), AX	
  0x411a63		488944d120		MOVQ AX, 0x20(CX)(DX*8)	
	fingwake = true
  0x411a68		c6053ab20c0001		MOVB $0x1, runtime.fingwake(SB)	
	unlock(&finlock)
  0x411a6f		488d05fab20c00		LEAQ runtime.finlock(SB), AX	
  0x411a76		48890424		MOVQ AX, 0(SP)			
  0x411a7a		e8116effff		CALL runtime.unlock(SB)		
}
  0x411a7f		488b6c2420		MOVQ 0x20(SP), BP	
  0x411a84		4883c428		ADDQ $0x28, SP		
  0x411a88		c3			RET			
	f.fint = fint
  0x411a89		4889df			MOVQ BX, DI			
  0x411a8c		488b442448		MOVQ 0x48(SP), AX		
  0x411a91		e8ea7b0300		CALL runtime.gcWriteBarrier(SB)	
	f.ot = ot
  0x411a96		4889f7			MOVQ SI, DI			
  0x411a99		488b442450		MOVQ 0x50(SP), AX		
  0x411a9e		e8dd7b0300		CALL runtime.gcWriteBarrier(SB)	
	f.arg = p
  0x411aa3		4c89c7			MOVQ R8, DI			
  0x411aa6		488b442430		MOVQ 0x30(SP), AX		
  0x411aab		e8d07b0300		CALL runtime.gcWriteBarrier(SB)	
	f.fint = fint
  0x411ab0		ebb6			JMP 0x411a68		
	f.fn = fn
  0x411ab2		488b442438		MOVQ 0x38(SP), AX		
  0x411ab7		e8c47b0300		CALL runtime.gcWriteBarrier(SB)	
  0x411abc		e976ffffff		JMP 0x411a37			
	f := &finq.fin[finq.cnt]
  0x411ac1		e85a040100		CALL runtime.panicindex(SB)	
  0x411ac6		0f0b			UD2				
					finptrmask[i] = finalizer1[i%len(finalizer1)]
  0x411ac8		e853040100		CALL runtime.panicindex(SB)	
  0x411acd		0f0b			UD2				
		throw("queuefinalizer during GC")
  0x411acf		488d0504f40500		LEAQ 0x5f404(IP), AX	
  0x411ad6		48890424		MOVQ AX, 0(SP)		
  0x411ada		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x411ae3		e898190100		CALL runtime.throw(SB)	
  0x411ae8		0f0b			UD2			
func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {
  0x411aea		e8915d0300		CALL runtime.morestack_noctxt(SB)	
  0x411aef		e9bcfdffff		JMP runtime.queuefinalizer(SB)		

TEXT runtime.wakefing(SB) /usr/local/go/src/runtime/mfinal.go
func wakefing() *g {
  0x411b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411b09		483b6110		CMPQ 0x10(CX), SP	
  0x411b0d		7672			JBE 0x411b81		
  0x411b0f		4883ec18		SUBQ $0x18, SP		
  0x411b13		48896c2410		MOVQ BP, 0x10(SP)	
  0x411b18		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&finlock)
  0x411b1d		488d054cb20c00		LEAQ runtime.finlock(SB), AX	
  0x411b24		48890424		MOVQ AX, 0(SP)			
  0x411b28		e8b36bffff		CALL runtime.lock(SB)		
	if fingwait && fingwake {
  0x411b2d		803d74b10c0000		CMPB $0x0, runtime.fingwait(SB)	
  0x411b34		7447			JE 0x411b7d			
  0x411b36		803d6cb10c0000		CMPB $0x0, runtime.fingwake(SB)	
  0x411b3d		743e			JE 0x411b7d			
		fingwait = false
  0x411b3f		c60562b10c0000		MOVB $0x0, runtime.fingwait(SB)	
		fingwake = false
  0x411b46		c6055cb10c0000		MOVB $0x0, runtime.fingwake(SB)	
		res = fing
  0x411b4d		488b0504fe0a00		MOVQ runtime.fing(SB), AX	
	return res
  0x411b54		4889442408		MOVQ AX, 0x8(SP)	
	unlock(&finlock)
  0x411b59		488d0d10b20c00		LEAQ runtime.finlock(SB), CX	
  0x411b60		48890c24		MOVQ CX, 0(SP)			
  0x411b64		e8276dffff		CALL runtime.unlock(SB)		
	return res
  0x411b69		488b442408		MOVQ 0x8(SP), AX	
  0x411b6e		4889442420		MOVQ AX, 0x20(SP)	
  0x411b73		488b6c2410		MOVQ 0x10(SP), BP	
  0x411b78		4883c418		ADDQ $0x18, SP		
  0x411b7c		c3			RET			
  0x411b7d		31c0			XORL AX, AX		
	unlock(&finlock)
  0x411b7f		ebd3			JMP 0x411b54		
func wakefing() *g {
  0x411b81		e8fa5c0300		CALL runtime.morestack_noctxt(SB)	
  0x411b86		e975ffffff		JMP runtime.wakefing(SB)		

TEXT runtime.(*fixalloc).alloc(SB) /usr/local/go/src/runtime/mfixalloc.go
func (f *fixalloc) alloc() unsafe.Pointer {
  0x411b90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411b99		483b6110		CMPQ 0x10(CX), SP	
  0x411b9d		0f863d010000		JBE 0x411ce0		
  0x411ba3		4883ec38		SUBQ $0x38, SP		
  0x411ba7		48896c2430		MOVQ BP, 0x30(SP)	
  0x411bac		488d6c2430		LEAQ 0x30(SP), BP	
	if f.size == 0 {
  0x411bb1		488b442440		MOVQ 0x40(SP), AX	
  0x411bb6		488b08			MOVQ 0(AX), CX		
  0x411bb9		4885c9			TESTQ CX, CX		
  0x411bbc		0f84e0000000		JE 0x411ca2		
	if f.list != nil {
  0x411bc2		488b5818		MOVQ 0x18(AX), BX	
  0x411bc6		4885db			TESTQ BX, BX		
  0x411bc9		7440			JE 0x411c0b		
		f.list = f.list.next
  0x411bcb		488b0b			MOVQ 0(BX), CX		
  0x411bce		48894818		MOVQ CX, 0x18(AX)	
		f.inuse += f.size
  0x411bd2		488b08			MOVQ 0(AX), CX		
  0x411bd5		48014830		ADDQ CX, 0x30(AX)	
		if f.zero {
  0x411bd9		80784000		CMPB $0x0, 0x40(AX)	
  0x411bdd		750f			JNE 0x411bee		
		return v
  0x411bdf		48895c2448		MOVQ BX, 0x48(SP)	
  0x411be4		488b6c2430		MOVQ 0x30(SP), BP	
  0x411be9		4883c438		ADDQ $0x38, SP		
  0x411bed		c3			RET			
	if f.list != nil {
  0x411bee		48895c2428		MOVQ BX, 0x28(SP)	
			memclrNoHeapPointers(v, f.size)
  0x411bf3		488b00			MOVQ 0(AX), AX				
  0x411bf6		48891c24		MOVQ BX, 0(SP)				
  0x411bfa		4889442408		MOVQ AX, 0x8(SP)			
  0x411bff		e8bc880300		CALL runtime.memclrNoHeapPointers(SB)	
		return v
  0x411c04		488b5c2428		MOVQ 0x28(SP), BX	
			memclrNoHeapPointers(v, f.size)
  0x411c09		ebd4			JMP 0x411bdf		
	if uintptr(f.nchunk) < f.size {
  0x411c0b		8b5828			MOVL 0x28(AX), BX	
  0x411c0e		4839cb			CMPQ CX, BX		
  0x411c11		7253			JB 0x411c66		
	v := unsafe.Pointer(f.chunk)
  0x411c13		488b4820		MOVQ 0x20(AX), CX	
	if f.first != nil {
  0x411c17		488b5008		MOVQ 0x8(AX), DX	
  0x411c1b		4885d2			TESTQ DX, DX		
  0x411c1e		7523			JNE 0x411c43		
	f.chunk = f.chunk + f.size
  0x411c20		488b10			MOVQ 0(AX), DX		
  0x411c23		48015020		ADDQ DX, 0x20(AX)	
	f.nchunk -= uint32(f.size)
  0x411c27		488b10			MOVQ 0(AX), DX		
  0x411c2a		295028			SUBL DX, 0x28(AX)	
	f.inuse += f.size
  0x411c2d		488b10			MOVQ 0(AX), DX		
  0x411c30		48015030		ADDQ DX, 0x30(AX)	
	return v
  0x411c34		48894c2448		MOVQ CX, 0x48(SP)	
  0x411c39		488b6c2430		MOVQ 0x30(SP), BP	
  0x411c3e		4883c438		ADDQ $0x38, SP		
  0x411c42		c3			RET			
	v := unsafe.Pointer(f.chunk)
  0x411c43		48894c2420		MOVQ CX, 0x20(SP)	
		f.first(f.arg, v)
  0x411c48		488b5810		MOVQ 0x10(AX), BX	
  0x411c4c		48891c24		MOVQ BX, 0(SP)		
  0x411c50		48894c2408		MOVQ CX, 0x8(SP)	
  0x411c55		488b1a			MOVQ 0(DX), BX		
  0x411c58		ffd3			CALL BX			
	f.chunk = f.chunk + f.size
  0x411c5a		488b442440		MOVQ 0x40(SP), AX	
	return v
  0x411c5f		488b4c2420		MOVQ 0x20(SP), CX	
		f.first(f.arg, v)
  0x411c64		ebba			JMP 0x411c20		
		f.chunk = uintptr(persistentalloc(_FixAllocChunk, 0, f.stat))
  0x411c66		488b4838		MOVQ 0x38(AX), CX			
  0x411c6a		48c7042400400000	MOVQ $0x4000, 0(SP)			
  0x411c72		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x411c7b		48894c2410		MOVQ CX, 0x10(SP)			
  0x411c80		e8eb8dffff		CALL runtime.persistentalloc(SB)	
  0x411c85		488b442418		MOVQ 0x18(SP), AX			
  0x411c8a		488b4c2440		MOVQ 0x40(SP), CX			
  0x411c8f		48894120		MOVQ AX, 0x20(CX)			
		f.nchunk = _FixAllocChunk
  0x411c93		c7412800400000		MOVL $0x4000, 0x28(CX)	
	v := unsafe.Pointer(f.chunk)
  0x411c9a		4889c8			MOVQ CX, AX		
		f.nchunk = _FixAllocChunk
  0x411c9d		e971ffffff		JMP 0x411c13		
		print("runtime: use of FixAlloc_Alloc before FixAlloc_Init\n")
  0x411ca2		e819220100		CALL runtime.printlock(SB)	
  0x411ca7		488d05f2150600		LEAQ 0x615f2(IP), AX		
  0x411cae		48890424		MOVQ AX, 0(SP)			
  0x411cb2		48c744240834000000	MOVQ $0x34, 0x8(SP)		
  0x411cbb		e8302b0100		CALL runtime.printstring(SB)	
  0x411cc0		e87b220100		CALL runtime.printunlock(SB)	
		throw("runtime: internal error")
  0x411cc5		488d0539f00500		LEAQ 0x5f039(IP), AX	
  0x411ccc		48890424		MOVQ AX, 0(SP)		
  0x411cd0		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x411cd9		e8a2170100		CALL runtime.throw(SB)	
  0x411cde		0f0b			UD2			
func (f *fixalloc) alloc() unsafe.Pointer {
  0x411ce0		e89b5b0300		CALL runtime.morestack_noctxt(SB)	
  0x411ce5		e9a6feffff		JMP runtime.(*fixalloc).alloc(SB)	

TEXT runtime.gcinit(SB) /usr/local/go/src/runtime/mgc.go
func gcinit() {
  0x411cf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411cf9		483b6110		CMPQ 0x10(CX), SP	
  0x411cfd		0f86b2000000		JBE 0x411db5		
  0x411d03		4883ec18		SUBQ $0x18, SP		
  0x411d07		48896c2410		MOVQ BP, 0x10(SP)	
  0x411d0c		488d6c2410		LEAQ 0x10(SP), BP	
	mheap_.sweepdone = 1
  0x411d11		c70541490b0001000000	MOVL $0x1, runtime.mheap_+28(SB)	
	memstats.triggerRatio = 7 / 8.0
  0x411d1b		f20f100585af0600	MOVSD_XMM $f64.3fec000000000000(SB), X0	
  0x411d23		f20f110565d60c00	MOVSD_XMM X0, runtime.memstats+5936(SB)	
	memstats.heap_marked = uint64(float64(heapminimum) / (1 + memstats.triggerRatio))
  0x411d2b		488b0506d30a00		MOVQ runtime.heapminimum(SB), AX	
  0x411d32		4885c0			TESTQ AX, AX				
  0x411d35		7c63			JL 0x411d9a				
  0x411d37		0f57c0			XORPS X0, X0				
  0x411d3a		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x411d3f		f20f100d89af0600	MOVSD_XMM $f64.3ffe000000000000(SB), X1	
  0x411d47		f20f5ec1		DIVSD X1, X0				
  0x411d4b		f20f100dadaf0600	MOVSD_XMM $f64.43e0000000000000(SB), X1	
  0x411d53		660f2ec8		UCOMISD X0, X1				
  0x411d57		7631			JBE 0x411d8a				
  0x411d59		f2480f2cc0		CVTTSD2SIQ X0, AX			
  0x411d5e		4889054bd60c00		MOVQ AX, runtime.memstats+5968(SB)	
	_ = setGCPercent(readgogc())
  0x411d65		e856000000		CALL runtime.readgogc(SB)		
  0x411d6a		e8b1010000		CALL runtime/debug.setGCPercent(SB)	
	work.markDoneSema = 1
  0x411d6f		48b80100000001000000	MOVQ $0x100000001, AX		
  0x411d79		488905d0020b00		MOVQ AX, runtime.work+208(SB)	
}
  0x411d80		488b6c2410		MOVQ 0x10(SP), BP	
  0x411d85		4883c418		ADDQ $0x18, SP		
  0x411d89		c3			RET			
	memstats.heap_marked = uint64(float64(heapminimum) / (1 + memstats.triggerRatio))
  0x411d8a		f20f5cc1		SUBSD X1, X0		
  0x411d8e		f2480f2cc0		CVTTSD2SIQ X0, AX	
  0x411d93		480fbae83f		BTSQ $0x3f, AX		
  0x411d98		ebc4			JMP 0x411d5e		
  0x411d9a		4889c1			MOVQ AX, CX		
  0x411d9d		4883e001		ANDQ $0x1, AX		
  0x411da1		48d1e9			SHRQ $0x1, CX		
  0x411da4		4809c1			ORQ AX, CX		
  0x411da7		0f57c0			XORPS X0, X0		
  0x411daa		f2480f2ac1		CVTSI2SDQ CX, X0	
  0x411daf		f20f58c0		ADDSD X0, X0		
  0x411db3		eb8a			JMP 0x411d3f		
func gcinit() {
  0x411db5		e8c65a0300		CALL runtime.morestack_noctxt(SB)	
  0x411dba		e931ffffff		JMP runtime.gcinit(SB)			

TEXT runtime.readgogc(SB) /usr/local/go/src/runtime/mgc.go
func readgogc() int32 {
  0x411dc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411dc9		483b6110		CMPQ 0x10(CX), SP	
  0x411dcd		0f86a6000000		JBE 0x411e79		
  0x411dd3		4883ec28		SUBQ $0x28, SP		
  0x411dd7		48896c2420		MOVQ BP, 0x20(SP)	
  0x411ddc		488d6c2420		LEAQ 0x20(SP), BP	
	p := gogetenv("GOGC")
  0x411de1		488d0549d30500		LEAQ 0x5d349(IP), AX		
  0x411de8		48890424		MOVQ AX, 0(SP)			
  0x411dec		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x411df5		e87642ffff		CALL runtime.gogetenv(SB)	
  0x411dfa		488b442418		MOVQ 0x18(SP), AX		
  0x411dff		488b4c2410		MOVQ 0x10(SP), CX		
	if p == "off" {
  0x411e04		4883f803		CMPQ $0x3, AX		
  0x411e08		750d			JNE 0x411e17		
  0x411e0a		6681396f66		CMPW $0x666f, 0(CX)	
  0x411e0f		7506			JNE 0x411e17		
  0x411e11		80790266		CMPB $0x66, 0x2(CX)	
  0x411e15		7450			JE 0x411e67		
	if n, ok := atoi32(p); ok {
  0x411e17		90			NOPL			
	if n, ok := atoi(s); n == int(int32(n)) {
  0x411e18		48890c24		MOVQ CX, 0(SP)		
  0x411e1c		4889442408		MOVQ AX, 0x8(SP)	
  0x411e21		e8aa800200		CALL runtime.atoi(SB)	
  0x411e26		488b442410		MOVQ 0x10(SP), AX	
  0x411e2b		4863c8			MOVSXD AX, CX		
  0x411e2e		4839c1			CMPQ AX, CX		
	if n, ok := atoi32(p); ok {
  0x411e31		b900000000		MOVL $0x0, CX		
  0x411e36		0f44c8			CMOVE AX, CX		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x411e39		0f94c0			SETE AL			
  0x411e3c		0fb6542418		MOVZX 0x18(SP), DX	
	if n, ok := atoi32(p); ok {
  0x411e41		21d0			ANDL DX, AX		
  0x411e43		84c0			TESTL AL, AL		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x411e45		740e			JE 0x411e55		
		return n
  0x411e47		894c2430		MOVL CX, 0x30(SP)	
  0x411e4b		488b6c2420		MOVQ 0x20(SP), BP	
  0x411e50		4883c428		ADDQ $0x28, SP		
  0x411e54		c3			RET			
	return 100
  0x411e55		c744243064000000	MOVL $0x64, 0x30(SP)	
  0x411e5d		488b6c2420		MOVQ 0x20(SP), BP	
  0x411e62		4883c428		ADDQ $0x28, SP		
  0x411e66		c3			RET			
		return -1
  0x411e67		c7442430ffffffff	MOVL $-0x1, 0x30(SP)	
  0x411e6f		488b6c2420		MOVQ 0x20(SP), BP	
  0x411e74		4883c428		ADDQ $0x28, SP		
  0x411e78		c3			RET			
func readgogc() int32 {
  0x411e79		e8025a0300		CALL runtime.morestack_noctxt(SB)	
  0x411e7e		e93dffffff		JMP runtime.readgogc(SB)		

TEXT runtime.gcenable(SB) /usr/local/go/src/runtime/mgc.go
func gcenable() {
  0x411e90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411e99		483b6110		CMPQ 0x10(CX), SP	
  0x411e9d		7671			JBE 0x411f10		
  0x411e9f		4883ec28		SUBQ $0x28, SP		
  0x411ea3		48896c2420		MOVQ BP, 0x20(SP)	
  0x411ea8		488d6c2420		LEAQ 0x20(SP), BP	
	c := make(chan int, 1)
  0x411ead		488d050c8a0400		LEAQ 0x48a0c(IP), AX		
  0x411eb4		48890424		MOVQ AX, 0(SP)			
  0x411eb8		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x411ec1		e86a24ffff		CALL runtime.makechan(SB)	
  0x411ec6		488b442410		MOVQ 0x10(SP), AX		
  0x411ecb		4889442418		MOVQ AX, 0x18(SP)		
	go bgsweep(c)
  0x411ed0		c7042408000000		MOVL $0x8, 0(SP)		
  0x411ed7		488d0d72180600		LEAQ 0x61872(IP), CX		
  0x411ede		48894c2408		MOVQ CX, 0x8(SP)		
  0x411ee3		e868a60100		CALL runtime.newproc(SB)	
	<-c
  0x411ee8		488b442418		MOVQ 0x18(SP), AX		
  0x411eed		48890424		MOVQ AX, 0(SP)			
  0x411ef1		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x411efa		e8a131ffff		CALL runtime.chanrecv1(SB)	
	memstats.enablegc = true // now that runtime is initialized, GC is okay
  0x411eff		c6052ace0c0001		MOVB $0x1, runtime.memstats+4304(SB)	
}
  0x411f06		488b6c2420		MOVQ 0x20(SP), BP	
  0x411f0b		4883c428		ADDQ $0x28, SP		
  0x411f0f		c3			RET			
func gcenable() {
  0x411f10		e86b590300		CALL runtime.morestack_noctxt(SB)	
  0x411f15		e976ffffff		JMP runtime.gcenable(SB)		

TEXT runtime/debug.setGCPercent(SB) /usr/local/go/src/runtime/mgc.go
func setGCPercent(in int32) (out int32) {
  0x411f20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411f29		483b6110		CMPQ 0x10(CX), SP	
  0x411f2d		0f86ae000000		JBE 0x411fe1		
  0x411f33		4883ec18		SUBQ $0x18, SP		
  0x411f37		48896c2410		MOVQ BP, 0x10(SP)	
  0x411f3c		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&mheap_.lock)
  0x411f41		488d05f8460b00		LEAQ runtime.mheap_(SB), AX	
  0x411f48		48890424		MOVQ AX, 0(SP)			
  0x411f4c		e88f67ffff		CALL runtime.lock(SB)		
	if in < 0 {
  0x411f51		8b442420		MOVL 0x20(SP), AX	
  0x411f55		85c0			TESTL AX, AX		
	gcpercent = in
  0x411f57		b9ffffffff		MOVL $-0x1, CX		
  0x411f5c		0f4cc1			CMOVL CX, AX		
  0x411f5f		89442420		MOVL AX, 0x20(SP)	
	out = gcpercent
  0x411f63		8b0d6fad0c00		MOVL runtime.gcpercent(SB), CX	
  0x411f69		894c240c		MOVL CX, 0xc(SP)		
	gcpercent = in
  0x411f6d		890565ad0c00		MOVL AX, runtime.gcpercent(SB)	
	heapminimum = defaultHeapMinimum * uint64(gcpercent) / 100
  0x411f73		4863d0			MOVSXD AX, DX				
  0x411f76		48c1e216		SHLQ $0x16, DX				
  0x411f7a		48d1ea			SHRQ $0x1, DX				
  0x411f7d		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x411f87		48f7e2			MULQ DX					
  0x411f8a		48c1ea05		SHRQ $0x5, DX				
  0x411f8e		488915a3d00a00		MOVQ DX, runtime.heapminimum(SB)	
	gcSetTriggerRatio(memstats.triggerRatio)
  0x411f95		f20f1005f3d30c00	MOVSD_XMM runtime.memstats+5936(SB), X0	
  0x411f9d		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x411fa2		e8690e0000		CALL runtime.gcSetTriggerRatio(SB)	
	unlock(&mheap_.lock)
  0x411fa7		488d0592460b00		LEAQ runtime.mheap_(SB), AX	
  0x411fae		48890424		MOVQ AX, 0(SP)			
  0x411fb2		e8d968ffff		CALL runtime.unlock(SB)		
	if in < 0 {
  0x411fb7		8b442420		MOVL 0x20(SP), AX	
  0x411fbb		85c0			TESTL AX, AX		
	if in < 0 {
  0x411fbd		7c12			JL 0x411fd1		
	return out
  0x411fbf		8b44240c		MOVL 0xc(SP), AX	
  0x411fc3		89442428		MOVL AX, 0x28(SP)	
  0x411fc7		488b6c2410		MOVQ 0x10(SP), BP	
  0x411fcc		4883c418		ADDQ $0x18, SP		
  0x411fd0		c3			RET			
		gcWaitOnMark(atomic.Load(&work.cycles))
  0x411fd1		8b05d9000b00		MOVL runtime.work+304(SB), AX	
  0x411fd7		890424			MOVL AX, 0(SP)			
  0x411fda		e831120000		CALL runtime.gcWaitOnMark(SB)	
  0x411fdf		ebde			JMP 0x411fbf			
func setGCPercent(in int32) (out int32) {
  0x411fe1		e89a580300		CALL runtime.morestack_noctxt(SB)	
  0x411fe6		e935ffffff		JMP runtime/debug.setGCPercent(SB)	

TEXT runtime.(*gcControllerState).startCycle(SB) /usr/local/go/src/runtime/mgc.go
func (c *gcControllerState) startCycle() {
  0x411ff0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x411ff9		483b6110		CMPQ 0x10(CX), SP	
  0x411ffd		0f8678030000		JBE 0x41237b		
  0x412003		4883ec48		SUBQ $0x48, SP		
  0x412007		48896c2440		MOVQ BP, 0x40(SP)	
  0x41200c		488d6c2440		LEAQ 0x40(SP), BP	
	c.bgScanCredit = 0
  0x412011		0f57c0			XORPS X0, X0		
  0x412014		488b4c2450		MOVQ 0x50(SP), CX	
  0x412019		0f1101			MOVUPS X0, 0(CX)	
	c.dedicatedMarkTime = 0
  0x41201c		0f114110		MOVUPS X0, 0x10(CX)	
	c.idleMarkTime = 0
  0x412020		0f114120		MOVUPS X0, 0x20(CX)	
	if memstats.gc_trigger <= heapminimum {
  0x412024		488b156dd30c00		MOVQ runtime.memstats+5944(SB), DX	
  0x41202b		48391506d00a00		CMPQ DX, runtime.heapminimum(SB)	
  0x412032		0f8236030000		JB 0x41236e				
		memstats.heap_marked = uint64(float64(memstats.gc_trigger) / (1 + memstats.triggerRatio))
  0x412038		4885d2			TESTQ DX, DX				
  0x41203b		0f8c0f030000		JL 0x412350				
  0x412041		0f57c9			XORPS X1, X1				
  0x412044		f2480f2aca		CVTSI2SDQ DX, X1			
  0x412049		f20f10153fd30c00	MOVSD_XMM runtime.memstats+5936(SB), X2	
  0x412051		f20f101d5fac0600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
  0x412059		f20f58d3		ADDSD X3, X2				
  0x41205d		f20f5eca		DIVSD X2, X1				
  0x412061		f20f101597ac0600	MOVSD_XMM $f64.43e0000000000000(SB), X2	
  0x412069		660f2ed1		UCOMISD X1, X2				
  0x41206d		0f86ca020000		JBE 0x41233d				
  0x412073		f2480f2cd1		CVTTSD2SIQ X1, DX			
  0x412078		48891531d30c00		MOVQ DX, runtime.memstats+5968(SB)	
	memstats.next_gc = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100
  0x41207f		488b152ad30c00		MOVQ runtime.memstats+5968(SB), DX	
  0x412086		48631d4bac0c00		MOVSXD runtime.gcpercent(SB), BX	
  0x41208d		480fafda		IMULQ DX, BX				
  0x412091		48d1eb			SHRQ $0x1, BX				
  0x412094		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
  0x41209e		4889d6			MOVQ DX, SI				
  0x4120a1		48f7e3			MULQ BX					
  0x4120a4		48c1ea05		SHRQ $0x5, DX				
  0x4120a8		4801f2			ADDQ SI, DX				
  0x4120ab		48891556bc0c00		MOVQ DX, runtime.memstats+168(SB)	
	if gcpercent < 0 {
  0x4120b2		833d1fac0c0000		CMPL $0x0, runtime.gcpercent(SB)	
  0x4120b9		7d0b			JGE 0x4120c6				
		memstats.next_gc = ^uint64(0)
  0x4120bb		48c70542bc0c00ffffffff	MOVQ $-0x1, runtime.memstats+168(SB)	
	if memstats.next_gc < memstats.heap_live+1024*1024 {
  0x4120c6		488b05d3d20c00		MOVQ runtime.memstats+5952(SB), AX	
  0x4120cd		480500001000		ADDQ $0x100000, AX			
  0x4120d3		4839052ebc0c00		CMPQ AX, runtime.memstats+168(SB)	
  0x4120da		7307			JAE 0x4120e3				
		memstats.next_gc = memstats.heap_live + 1024*1024
  0x4120dc		48890525bc0c00		MOVQ AX, runtime.memstats+168(SB)	
	totalUtilizationGoal := float64(gomaxprocs) * gcBackgroundUtilization
  0x4120e3		8b05f7ab0c00		MOVL runtime.gomaxprocs(SB), AX		
  0x4120e9		0f57c9			XORPS X1, X1				
  0x4120ec		f20f2ac8		CVTSI2SDL AX, X1			
  0x4120f0		f20f101598ab0600	MOVSD_XMM $f64.3fd0000000000000(SB), X2	
  0x4120f8		f20f59ca		MULSD X2, X1				
	c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5)
  0x4120fc		f20f10159cab0600	MOVSD_XMM $f64.3fe0000000000000(SB), X2	
  0x412104		f20f58d1		ADDSD X1, X2				
  0x412108		f2480f2cc2		CVTTSD2SIQ X2, AX			
  0x41210d		48894138		MOVQ AX, 0x38(CX)			
	utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1
  0x412111		0f57d2			XORPS X2, X2		
  0x412114		f2480f2ad0		CVTSI2SDQ AX, X2	
  0x412119		0f10e2			MOVUPS X2, X4		
  0x41211c		f20f5ed1		DIVSD X1, X2		
  0x412120		f20f5cd3		SUBSD X3, X2		
	if utilError < -maxUtilError || utilError > maxUtilError {
  0x412124		f20f101de4ab0600	MOVSD_XMM $f64.bfd3333333333333(SB), X3	
  0x41212c		660f2eda		UCOMISD X2, X3				
  0x412130		0f86e8010000		JBE 0x41231e				
		if float64(c.dedicatedMarkWorkersNeeded) > totalUtilizationGoal {
  0x412136		660f2ee1		UCOMISD X1, X4		
  0x41213a		7607			JBE 0x412143		
			c.dedicatedMarkWorkersNeeded--
  0x41213c		48ffc8			DECQ AX			
  0x41213f		48894138		MOVQ AX, 0x38(CX)	
		c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(gomaxprocs)
  0x412143		488b4138		MOVQ 0x38(CX), AX		
  0x412147		0f57d2			XORPS X2, X2			
  0x41214a		f2480f2ad0		CVTSI2SDQ AX, X2		
  0x41214f		f20f5cca		SUBSD X2, X1			
  0x412153		8b0587ab0c00		MOVL runtime.gomaxprocs(SB), AX	
  0x412159		0f57d2			XORPS X2, X2			
  0x41215c		f20f2ad0		CVTSI2SDL AX, X2		
  0x412160		f20f5eca		DIVSD X2, X1			
  0x412164		f20f114950		MOVSD_XMM X1, 0x50(CX)		
	if debug.gcstoptheworld > 0 {
  0x412169		833d8cad0c0000		CMPL $0x0, runtime.debug+28(SB)	
  0x412170		7e13			JLE 0x412185			
		c.dedicatedMarkWorkersNeeded = int64(gomaxprocs)
  0x412172		48630567ab0c00		MOVSXD runtime.gomaxprocs(SB), AX	
  0x412179		48894138		MOVQ AX, 0x38(CX)			
		c.fractionalUtilizationGoal = 0
  0x41217d		0f57c9			XORPS X1, X1		
  0x412180		f20f114950		MOVSD_XMM X1, 0x50(CX)	
	for _, p := range allp {
  0x412185		488b059cf80a00		MOVQ runtime.allp+8(SB), AX	
  0x41218c		488b158df80a00		MOVQ runtime.allp(SB), DX	
  0x412193		31db			XORL BX, BX			
  0x412195		eb10			JMP 0x4121a7			
  0x412197		488b34da		MOVQ 0(DX)(BX*8), SI		
		p.gcAssistTime = 0
  0x41219b		8406			TESTB AL, 0(SI)		
		p.gcFractionalMarkTime = 0
  0x41219d		0f118648120000		MOVUPS X0, 0x1248(SI)	
	for _, p := range allp {
  0x4121a4		48ffc3			INCQ BX			
  0x4121a7		4839c3			CMPQ AX, BX		
  0x4121aa		7ceb			JL 0x412197		
	c.revise()
  0x4121ac		48890c24		MOVQ CX, 0(SP)					
  0x4121b0		e8db010000		CALL runtime.(*gcControllerState).revise(SB)	
	if debug.gcpacertrace > 0 {
  0x4121b5		833d38ad0c0000		CMPL $0x0, runtime.debug+20(SB)	
  0x4121bc		7f0a			JG 0x4121c8			
  0x4121be		488b6c2440		MOVQ 0x40(SP), BP		
  0x4121c3		4883c448		ADDQ $0x48, SP			
  0x4121c7		c3			RET				
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x4121c8		488b442450		MOVQ 0x50(SP), AX	
  0x4121cd		f20f104040		MOVSD_XMM 0x40(AX), X0	
  0x4121d2		f20f11442438		MOVSD_XMM X0, 0x38(SP)	
			" (scan ", memstats.heap_scan>>20, " MB in ",
  0x4121d8		488b0dc9d10c00		MOVQ runtime.memstats+5960(SB), CX	
  0x4121df		48894c2430		MOVQ CX, 0x30(SP)			
			work.initialHeapLive>>20, "->",
  0x4121e4		488b1595fe0a00		MOVQ runtime.work+256(SB), DX	
  0x4121eb		4889542428		MOVQ DX, 0x28(SP)		
			memstats.next_gc>>20, " MB)",
  0x4121f0		488b1d11bb0c00		MOVQ runtime.memstats+168(SB), BX	
  0x4121f7		48895c2420		MOVQ BX, 0x20(SP)			
			" workers=", c.dedicatedMarkWorkersNeeded,
  0x4121fc		488b7038		MOVQ 0x38(AX), SI	
  0x412200		4889742418		MOVQ SI, 0x18(SP)	
			"+", c.fractionalUtilizationGoal, "\n")
  0x412205		f20f104850		MOVSD_XMM 0x50(AX), X1	
  0x41220a		f20f114c2410		MOVSD_XMM X1, 0x10(SP)	
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x412210		e8ab1c0100		CALL runtime.printlock(SB)	
  0x412215		488d05e1e40500		LEAQ 0x5e4e1(IP), AX		
  0x41221c		48890424		MOVQ AX, 0(SP)			
  0x412220		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x412229		e8c2250100		CALL runtime.printstring(SB)	
  0x41222e		f20f10442438		MOVSD_XMM 0x38(SP), X0		
  0x412234		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x412239		e8d21f0100		CALL runtime.printfloat(SB)	
  0x41223e		488d055fd00500		LEAQ 0x5d05f(IP), AX		
  0x412245		48890424		MOVQ AX, 0(SP)			
  0x412249		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x412252		e899250100		CALL runtime.printstring(SB)	
			" (scan ", memstats.heap_scan>>20, " MB in ",
  0x412257		488b442430		MOVQ 0x30(SP), AX	
  0x41225c		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x412260		48890424		MOVQ AX, 0(SP)			
  0x412264		e8d7220100		CALL runtime.printuint(SB)	
  0x412269		488d0542d00500		LEAQ 0x5d042(IP), AX		
  0x412270		48890424		MOVQ AX, 0(SP)			
  0x412274		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x41227d		e86e250100		CALL runtime.printstring(SB)	
			work.initialHeapLive>>20, "->",
  0x412282		488b442428		MOVQ 0x28(SP), AX	
  0x412287		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x41228b		48890424		MOVQ AX, 0(SP)			
  0x41228f		e8ac220100		CALL runtime.printuint(SB)	
  0x412294		488d0503ce0500		LEAQ 0x5ce03(IP), AX		
  0x41229b		48890424		MOVQ AX, 0(SP)			
  0x41229f		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4122a8		e843250100		CALL runtime.printstring(SB)	
			memstats.next_gc>>20, " MB)",
  0x4122ad		488b442420		MOVQ 0x20(SP), AX	
  0x4122b2		48c1e814		SHRQ $0x14, AX		
		print("pacer: assist ratio=", c.assistWorkPerByte,
  0x4122b6		48890424		MOVQ AX, 0(SP)			
  0x4122ba		e881220100		CALL runtime.printuint(SB)	
  0x4122bf		488d059dd80500		LEAQ 0x5d89d(IP), AX		
  0x4122c6		48890424		MOVQ AX, 0(SP)			
  0x4122ca		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4122d3		e818250100		CALL runtime.printstring(SB)	
  0x4122d8		488b442418		MOVQ 0x18(SP), AX		
  0x4122dd		48890424		MOVQ AX, 0(SP)			
  0x4122e1		e85a230100		CALL runtime.printint(SB)	
  0x4122e6		488d0596cd0500		LEAQ 0x5cd96(IP), AX		
  0x4122ed		48890424		MOVQ AX, 0(SP)			
  0x4122f1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4122fa		e8f1240100		CALL runtime.printstring(SB)	
  0x4122ff		f20f10442410		MOVSD_XMM 0x10(SP), X0		
  0x412305		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x41230a		e8011f0100		CALL runtime.printfloat(SB)	
  0x41230f		e83c1e0100		CALL runtime.printnl(SB)	
  0x412314		e8271c0100		CALL runtime.printunlock(SB)	
  0x412319		e9a0feffff		JMP 0x4121be			
	if utilError < -maxUtilError || utilError > maxUtilError {
  0x41231e		f20f101d72a90600	MOVSD_XMM $f64.3fd3333333333333(SB), X3	
  0x412326		660f2ed3		UCOMISD X3, X2				
  0x41232a		0f8706feffff		JA 0x412136				
		c.fractionalUtilizationGoal = 0
  0x412330		0f57c9			XORPS X1, X1		
  0x412333		f20f114950		MOVSD_XMM X1, 0x50(CX)	
  0x412338		e92cfeffff		JMP 0x412169		
		memstats.heap_marked = uint64(float64(memstats.gc_trigger) / (1 + memstats.triggerRatio))
  0x41233d		f20f5cca		SUBSD X2, X1				
  0x412341		f2480f2cd1		CVTTSD2SIQ X1, DX			
  0x412346		480fbaea3f		BTSQ $0x3f, DX				
  0x41234b		e928fdffff		JMP 0x412078				
  0x412350		4889d3			MOVQ DX, BX				
  0x412353		48d1ea			SHRQ $0x1, DX				
  0x412356		4883e301		ANDQ $0x1, BX				
  0x41235a		4809d3			ORQ DX, BX				
  0x41235d		0f57c9			XORPS X1, X1				
  0x412360		f2480f2acb		CVTSI2SDQ BX, X1			
  0x412365		f20f58c9		ADDSD X1, X1				
  0x412369		e9dbfcffff		JMP 0x412049				
  0x41236e		f20f101d42a90600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
	if memstats.gc_trigger <= heapminimum {
  0x412376		e904fdffff		JMP 0x41207f		
func (c *gcControllerState) startCycle() {
  0x41237b		e800550300		CALL runtime.morestack_noctxt(SB)		
  0x412380		e96bfcffff		JMP runtime.(*gcControllerState).startCycle(SB)	

TEXT runtime.(*gcControllerState).revise(SB) /usr/local/go/src/runtime/mgc.go
	gcpercent := gcpercent
  0x412390		8b0542a90c00		MOVL runtime.gcpercent(SB), AX	
	live := atomic.Load64(&memstats.heap_live)
  0x412396		488b0d03d00c00		MOVQ runtime.memstats+5952(SB), CX	
	if gcpercent < 0 {
  0x41239d		85c0			TESTL AX, AX		
		scanWorkExpected = int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))
  0x41239f		baa0860100		MOVL $0x186a0, DX	
  0x4123a4		0f4cc2			CMOVL DX, AX		
	if live <= memstats.next_gc {
  0x4123a7		488b155ab90c00		MOVQ runtime.memstats+168(SB), DX	
  0x4123ae		4839d1			CMPQ DX, CX				
	if gcpercent < 0 {
  0x4123b1		0f879d000000		JA 0x412454		
		scanWorkExpected = int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))
  0x4123b7		488b1deacf0c00		MOVQ runtime.memstats+5960(SB), BX	
  0x4123be		4885db			TESTQ BX, BX				
  0x4123c1		7c73			JL 0x412436				
  0x4123c3		0f57c0			XORPS X0, X0				
  0x4123c6		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x4123cb		f20f100d1da90600	MOVSD_XMM $f64.4059000000000000(SB), X1	
  0x4123d3		f20f59c8		MULSD X0, X1				
  0x4123d7		83c064			ADDL $0x64, AX				
  0x4123da		0f57c0			XORPS X0, X0				
  0x4123dd		f20f2ac0		CVTSI2SDL AX, X0			
  0x4123e1		f20f5ec8		DIVSD X0, X1				
  0x4123e5		f2480f2cc1		CVTTSD2SIQ X1, AX			
	scanWorkRemaining := scanWorkExpected - c.scanWork
  0x4123ea		488b5c2408		MOVQ 0x8(SP), BX	
  0x4123ef		482b03			SUBQ 0(BX), AX		
	if scanWorkRemaining < 1000 {
  0x4123f2		483de8030000		CMPQ $0x3e8, AX		
	c.assistWorkPerByte = float64(scanWorkRemaining) / float64(heapRemaining)
  0x4123f8		bee8030000		MOVL $0x3e8, SI		
  0x4123fd		480f4cc6		CMOVL SI, AX		
	heapRemaining := heapGoal - int64(live)
  0x412401		4829ca			SUBQ CX, DX		
	if heapRemaining <= 0 {
  0x412404		4885d2			TESTQ DX, DX		
	c.assistWorkPerByte = float64(scanWorkRemaining) / float64(heapRemaining)
  0x412407		b901000000		MOVL $0x1, CX		
  0x41240c		480f4ed1		CMOVLE CX, DX		
	c.assistBytesPerWork = float64(heapRemaining) / float64(scanWorkRemaining)
  0x412410		0f57c0			XORPS X0, X0		
  0x412413		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x412418		0f57c9			XORPS X1, X1		
  0x41241b		f2480f2ac8		CVTSI2SDQ AX, X1	
	c.assistWorkPerByte = float64(scanWorkRemaining) / float64(heapRemaining)
  0x412420		0f10d1			MOVUPS X1, X2		
  0x412423		f20f5ec8		DIVSD X0, X1		
  0x412427		f20f114b40		MOVSD_XMM X1, 0x40(BX)	
	c.assistBytesPerWork = float64(heapRemaining) / float64(scanWorkRemaining)
  0x41242c		f20f5ec2		DIVSD X2, X0		
  0x412430		f20f114348		MOVSD_XMM X0, 0x48(BX)	
	if scanWorkRemaining < 1000 {
  0x412435		c3			RET			
		scanWorkExpected = int64(float64(memstats.heap_scan) * 100 / float64(100+gcpercent))
  0x412436		4889de			MOVQ BX, SI		
  0x412439		48d1eb			SHRQ $0x1, BX		
  0x41243c		4883e601		ANDQ $0x1, SI		
  0x412440		4809de			ORQ BX, SI		
  0x412443		0f57c0			XORPS X0, X0		
  0x412446		f2480f2ac6		CVTSI2SDQ SI, X0	
  0x41244b		f20f58c0		ADDSD X0, X0		
  0x41244f		e977ffffff		JMP 0x4123cb		
		heapGoal = int64(float64(memstats.next_gc) * maxOvershoot)
  0x412454		4885d2			TESTQ DX, DX				
  0x412457		7c25			JL 0x41247e				
  0x412459		0f57c0			XORPS X0, X0				
  0x41245c		f2480f2ac2		CVTSI2SDQ DX, X0			
  0x412461		f20f100d57a80600	MOVSD_XMM $f64.3ff199999999999a(SB), X1	
  0x412469		f20f59c8		MULSD X0, X1				
  0x41246d		f2480f2cd1		CVTTSD2SIQ X1, DX			
		scanWorkExpected = int64(memstats.heap_scan)
  0x412472		488b052fcf0c00		MOVQ runtime.memstats+5960(SB), AX	
  0x412479		e96cffffff		JMP 0x4123ea				
		heapGoal = int64(float64(memstats.next_gc) * maxOvershoot)
  0x41247e		4889d0			MOVQ DX, AX		
  0x412481		48d1ea			SHRQ $0x1, DX		
  0x412484		4883e001		ANDQ $0x1, AX		
  0x412488		4809d0			ORQ DX, AX		
  0x41248b		0f57c0			XORPS X0, X0		
  0x41248e		f2480f2ac0		CVTSI2SDQ AX, X0	
  0x412493		f20f58c0		ADDSD X0, X0		
  0x412497		ebc8			JMP 0x412461		

TEXT runtime.(*gcControllerState).endCycle(SB) /usr/local/go/src/runtime/mgc.go
func (c *gcControllerState) endCycle() float64 {
  0x4124a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4124a9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4124ae		483b4110		CMPQ 0x10(CX), AX	
  0x4124b2		0f8692040000		JBE 0x41294a		
  0x4124b8		4881ec88000000		SUBQ $0x88, SP		
  0x4124bf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x4124c7		488dac2480000000	LEAQ 0x80(SP), BP	
	if work.userForced {
  0x4124cf		803d9afb0a0000		CMPB $0x0, runtime.work+240(SB)	
  0x4124d6		0f854d040000		JNE 0x412929			
	goalGrowthRatio := float64(gcpercent) / 100
  0x4124dc		8b05f6a70c00		MOVL runtime.gcpercent(SB), AX	
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x4124e2		488b0db7ce0c00		MOVQ runtime.memstats+5952(SB), CX	
  0x4124e9		4885c9			TESTQ CX, CX				
  0x4124ec		0f8c19040000		JL 0x41290b				
  0x4124f2		0f57c0			XORPS X0, X0				
  0x4124f5		f2480f2ac1		CVTSI2SDQ CX, X0			
	goalGrowthRatio := float64(gcpercent) / 100
  0x4124fa		89442414		MOVL AX, 0x14(SP)	
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x4124fe		f20f11442478		MOVSD_XMM X0, 0x78(SP)			
  0x412504		488b0da5ce0c00		MOVQ runtime.memstats+5968(SB), CX	
  0x41250b		4885c9			TESTQ CX, CX				
  0x41250e		0f8cd9030000		JL 0x4128ed				
  0x412514		0f57c9			XORPS X1, X1				
  0x412517		f2480f2ac9		CVTSI2SDQ CX, X1			
  0x41251c		f20f114c2470		MOVSD_XMM X1, 0x70(SP)			
	assistDuration := nanotime() - c.markStartTime
  0x412522		e8898b0300		CALL runtime.nanotime(SB)	
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x412527		f20f10442478		MOVSD_XMM 0x78(SP), X0	
  0x41252d		f20f104c2470		MOVSD_XMM 0x70(SP), X1	
  0x412533		f20f5ec1		DIVSD X1, X0		
	assistDuration := nanotime() - c.markStartTime
  0x412537		488b0424		MOVQ 0(SP), AX		
  0x41253b		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x412543		482b4130		SUBQ 0x30(CX), AX	
	if assistDuration > 0 {
  0x412547		4885c0			TESTQ AX, AX		
  0x41254a		0f8e90030000		JLE 0x4128e0		
		utilization += float64(c.assistTime) / float64(assistDuration*int64(gomaxprocs))
  0x412550		488b5110		MOVQ 0x10(CX), DX			
  0x412554		0f57c9			XORPS X1, X1				
  0x412557		f2480f2aca		CVTSI2SDQ DX, X1			
  0x41255c		4863157da70c00		MOVSXD runtime.gomaxprocs(SB), DX	
  0x412563		480fafc2		IMULQ DX, AX				
  0x412567		0f57d2			XORPS X2, X2				
  0x41256a		f2480f2ad0		CVTSI2SDQ AX, X2			
  0x41256f		f20f5eca		DIVSD X2, X1				
  0x412573		f20f101515a70600	MOVSD_XMM $f64.3fd0000000000000(SB), X2	
  0x41257b		f20f58d1		ADDSD X1, X2				
	goalGrowthRatio := float64(gcpercent) / 100
  0x41257f		8b442414		MOVL 0x14(SP), AX			
  0x412583		0f57c9			XORPS X1, X1				
  0x412586		f20f2ac8		CVTSI2SDL AX, X1			
  0x41258a		f20f101d5ea70600	MOVSD_XMM $f64.4059000000000000(SB), X3	
  0x412592		f20f5ecb		DIVSD X3, X1				
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x412596		f20f101d1aa70600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
  0x41259e		f20f5cc3		SUBSD X3, X0				
	triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)
  0x4125a2		f20f1025e6cd0c00	MOVSD_XMM runtime.memstats+5936(SB), X4	
  0x4125aa		0f10e9			MOVUPS X1, X5				
  0x4125ad		f20f5ccc		SUBSD X4, X1				
  0x4125b1		f20f1035dfa60600	MOVSD_XMM $f64.3fd3333333333333(SB), X6	
  0x4125b9		0f10fa			MOVUPS X2, X7				
  0x4125bc		f20f5ed6		DIVSD X6, X2				
  0x4125c0		440f10c0		MOVUPS X0, X8				
  0x4125c4		f20f5cc4		SUBSD X4, X0				
  0x4125c8		440f10c8		MOVUPS X0, X9				
  0x4125cc		f20f59c2		MULSD X2, X0				
  0x4125d0		440f10d1		MOVUPS X1, X10				
  0x4125d4		f20f5cc8		SUBSD X0, X1				
	triggerRatio := memstats.triggerRatio + triggerGain*triggerError
  0x4125d8		f20f1005c0a60600	MOVSD_XMM $f64.3fe0000000000000(SB), X0	
  0x4125e0		f20f59c1		MULSD X1, X0				
  0x4125e4		f20f58c4		ADDSD X4, X0				
  0x4125e8		f20f11442418		MOVSD_XMM X0, 0x18(SP)			
	if debug.gcpacertrace > 0 {
  0x4125ee		833dffa80c0000		CMPL $0x0, runtime.debug+20(SB)	
  0x4125f5		0f8ea8020000		JLE 0x4128a3			
	goalGrowthRatio := float64(gcpercent) / 100
  0x4125fb		f20f116c2478		MOVSD_XMM X5, 0x78(SP)	
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x412601		f2440f11442470		MOVSD_XMM X8, 0x70(SP)	
	triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-memstats.triggerRatio)
  0x412608		f20f11642468		MOVSD_XMM X4, 0x68(SP)	
  0x41260e		f2440f11542460		MOVSD_XMM X10, 0x60(SP)	
  0x412615		f20f117c2458		MOVSD_XMM X7, 0x58(SP)	
  0x41261b		f20f11542450		MOVSD_XMM X2, 0x50(SP)	
  0x412621		f2440f114c2448		MOVSD_XMM X9, 0x48(SP)	
		H_m_prev := memstats.heap_marked
  0x412628		488b0581cd0c00		MOVQ runtime.memstats+5968(SB), AX	
  0x41262f		4889442428		MOVQ AX, 0x28(SP)			
		H_T := memstats.gc_trigger
  0x412634		488b155dcd0c00		MOVQ runtime.memstats+5944(SB), DX	
  0x41263b		4889542438		MOVQ DX, 0x38(SP)			
		H_a := memstats.heap_live
  0x412640		488b1d59cd0c00		MOVQ runtime.memstats+5952(SB), BX	
  0x412647		48895c2430		MOVQ BX, 0x30(SP)			
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x41264c		4885c0			TESTQ AX, AX		
  0x41264f		0f8c6d020000		JL 0x4128c2		
  0x412655		0f57c9			XORPS X1, X1		
  0x412658		f2480f2ac8		CVTSI2SDQ AX, X1	
  0x41265d		f20f114c2440		MOVSD_XMM X1, 0x40(SP)	
		W_a := c.scanWork
  0x412663		488b01			MOVQ 0(CX), AX		
  0x412666		4889442420		MOVQ AX, 0x20(SP)	
		print("pacer: H_m_prev=", H_m_prev,
  0x41266b		e850180100		CALL runtime.printlock(SB)	
  0x412670		488d05f0d90500		LEAQ 0x5d9f0(IP), AX		
  0x412677		48890424		MOVQ AX, 0(SP)			
  0x41267b		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x412684		e867210100		CALL runtime.printstring(SB)	
  0x412689		488b442428		MOVQ 0x28(SP), AX		
  0x41268e		48890424		MOVQ AX, 0(SP)			
  0x412692		e8a91e0100		CALL runtime.printuint(SB)	
  0x412697		488d051dcb0500		LEAQ 0x5cb1d(IP), AX		
  0x41269e		48890424		MOVQ AX, 0(SP)			
  0x4126a2		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4126ab		e840210100		CALL runtime.printstring(SB)	
  0x4126b0		f20f10442468		MOVSD_XMM 0x68(SP), X0		
  0x4126b6		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x4126bb		e8501b0100		CALL runtime.printfloat(SB)	
  0x4126c0		488d05c7ca0500		LEAQ 0x5cac7(IP), AX		
  0x4126c7		48890424		MOVQ AX, 0(SP)			
  0x4126cb		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4126d4		e817210100		CALL runtime.printstring(SB)	
  0x4126d9		488b442438		MOVQ 0x38(SP), AX		
  0x4126de		48890424		MOVQ AX, 0(SP)			
  0x4126e2		e8591e0100		CALL runtime.printuint(SB)	
  0x4126e7		488d05c3ca0500		LEAQ 0x5cac3(IP), AX		
  0x4126ee		48890424		MOVQ AX, 0(SP)			
  0x4126f2		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4126fb		e8f0200100		CALL runtime.printstring(SB)	
  0x412700		f20f10442470		MOVSD_XMM 0x70(SP), X0		
  0x412706		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x41270b		e8001b0100		CALL runtime.printfloat(SB)	
  0x412710		488d057cca0500		LEAQ 0x5ca7c(IP), AX		
  0x412717		48890424		MOVQ AX, 0(SP)			
  0x41271b		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x412724		e8c7200100		CALL runtime.printstring(SB)	
  0x412729		488b442430		MOVQ 0x30(SP), AX		
  0x41272e		48890424		MOVQ AX, 0(SP)			
  0x412732		e8091e0100		CALL runtime.printuint(SB)	
  0x412737		488d0578ca0500		LEAQ 0x5ca78(IP), AX		
  0x41273e		48890424		MOVQ AX, 0(SP)			
  0x412742		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41274b		e8a0200100		CALL runtime.printstring(SB)	
  0x412750		f20f10442478		MOVSD_XMM 0x78(SP), X0		
  0x412756		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x41275b		e8b01a0100		CALL runtime.printfloat(SB)	
  0x412760		488d0531ca0500		LEAQ 0x5ca31(IP), AX		
  0x412767		48890424		MOVQ AX, 0(SP)			
  0x41276b		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x412774		e877200100		CALL runtime.printstring(SB)	
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x412779		f20f100537a50600	MOVSD_XMM $f64.3ff0000000000000(SB), X0	
  0x412781		f20f104c2478		MOVSD_XMM 0x78(SP), X1			
  0x412787		f20f58c1		ADDSD X1, X0				
  0x41278b		f20f104c2440		MOVSD_XMM 0x40(SP), X1			
  0x412791		f20f59c1		MULSD X1, X0				
  0x412795		f2480f2cc0		CVTTSD2SIQ X0, AX			
		print("pacer: H_m_prev=", H_m_prev,
  0x41279a		48890424		MOVQ AX, 0(SP)				
  0x41279e		e89d1e0100		CALL runtime.printint(SB)		
  0x4127a3		488d052fca0500		LEAQ 0x5ca2f(IP), AX			
  0x4127aa		48890424		MOVQ AX, 0(SP)				
  0x4127ae		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x4127b7		e834200100		CALL runtime.printstring(SB)		
  0x4127bc		f20f10442458		MOVSD_XMM 0x58(SP), X0			
  0x4127c2		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4127c7		e8441a0100		CALL runtime.printfloat(SB)		
  0x4127cc		488d050bca0500		LEAQ 0x5ca0b(IP), AX			
  0x4127d3		48890424		MOVQ AX, 0(SP)				
  0x4127d7		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x4127e0		e80b200100		CALL runtime.printstring(SB)		
  0x4127e5		f20f1005aba40600	MOVSD_XMM $f64.3fd3333333333333(SB), X0	
  0x4127ed		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4127f2		e8191a0100		CALL runtime.printfloat(SB)		
  0x4127f7		488d05a4c90500		LEAQ 0x5c9a4(IP), AX			
  0x4127fe		48890424		MOVQ AX, 0(SP)				
  0x412802		48c744240805000000	MOVQ $0x5, 0x8(SP)			
  0x41280b		e8e01f0100		CALL runtime.printstring(SB)		
  0x412810		488b442420		MOVQ 0x20(SP), AX			
  0x412815		48890424		MOVQ AX, 0(SP)				
  0x412819		e8221e0100		CALL runtime.printint(SB)		
  0x41281e		488d05bbcb0500		LEAQ 0x5cbbb(IP), AX			
  0x412825		48890424		MOVQ AX, 0(SP)				
  0x412829		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x412832		e8b91f0100		CALL runtime.printstring(SB)		
  0x412837		f20f10442460		MOVSD_XMM 0x60(SP), X0			
  0x41283d		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x412842		e8c9190100		CALL runtime.printfloat(SB)		
  0x412847		488d05b0ce0500		LEAQ 0x5ceb0(IP), AX			
  0x41284e		48890424		MOVQ AX, 0(SP)				
  0x412852		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x41285b		e8901f0100		CALL runtime.printstring(SB)		
  0x412860		f20f10442448		MOVSD_XMM 0x48(SP), X0			
  0x412866		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x41286b		e8a0190100		CALL runtime.printfloat(SB)		
  0x412870		488d0597cc0500		LEAQ 0x5cc97(IP), AX			
  0x412877		48890424		MOVQ AX, 0(SP)				
  0x41287b		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x412884		e8671f0100		CALL runtime.printstring(SB)		
  0x412889		f20f10442450		MOVSD_XMM 0x50(SP), X0			
  0x41288f		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x412894		e877190100		CALL runtime.printfloat(SB)		
  0x412899		e8b2180100		CALL runtime.printnl(SB)		
  0x41289e		e89d160100		CALL runtime.printunlock(SB)		
	return triggerRatio
  0x4128a3		f20f10442418		MOVSD_XMM 0x18(SP), X0	
  0x4128a9		f20f11842498000000	MOVSD_XMM X0, 0x98(SP)	
  0x4128b2		488bac2480000000	MOVQ 0x80(SP), BP	
  0x4128ba		4881c488000000		ADDQ $0x88, SP		
  0x4128c1		c3			RET			
		H_g := int64(float64(H_m_prev) * (1 + h_g))
  0x4128c2		4889c6			MOVQ AX, SI				
  0x4128c5		4883e001		ANDQ $0x1, AX				
  0x4128c9		48d1ee			SHRQ $0x1, SI				
  0x4128cc		4809f0			ORQ SI, AX				
  0x4128cf		0f57c9			XORPS X1, X1				
  0x4128d2		f2480f2ac8		CVTSI2SDQ AX, X1			
  0x4128d7		f20f58c9		ADDSD X1, X1				
  0x4128db		e97dfdffff		JMP 0x41265d				
  0x4128e0		f20f1015a8a30600	MOVSD_XMM $f64.3fd0000000000000(SB), X2	
	if assistDuration > 0 {
  0x4128e8		e992fcffff		JMP 0x41257f		
	actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1
  0x4128ed		4889ca			MOVQ CX, DX		
  0x4128f0		48d1e9			SHRQ $0x1, CX		
  0x4128f3		4883e201		ANDQ $0x1, DX		
  0x4128f7		4809ca			ORQ CX, DX		
  0x4128fa		0f57c9			XORPS X1, X1		
  0x4128fd		f2480f2aca		CVTSI2SDQ DX, X1	
  0x412902		f20f58c9		ADDSD X1, X1		
  0x412906		e911fcffff		JMP 0x41251c		
  0x41290b		4889ca			MOVQ CX, DX		
  0x41290e		48d1e9			SHRQ $0x1, CX		
  0x412911		4883e201		ANDQ $0x1, DX		
  0x412915		4809ca			ORQ CX, DX		
  0x412918		0f57c0			XORPS X0, X0		
  0x41291b		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x412920		f20f58c0		ADDSD X0, X0		
  0x412924		e9d1fbffff		JMP 0x4124fa		
		return memstats.triggerRatio
  0x412929		f20f10055fca0c00	MOVSD_XMM runtime.memstats+5936(SB), X0	
  0x412931		f20f11842498000000	MOVSD_XMM X0, 0x98(SP)			
  0x41293a		488bac2480000000	MOVQ 0x80(SP), BP			
  0x412942		4881c488000000		ADDQ $0x88, SP				
  0x412949		c3			RET					
func (c *gcControllerState) endCycle() float64 {
  0x41294a		e8314f0300		CALL runtime.morestack_noctxt(SB)		
  0x41294f		e94cfbffff		JMP runtime.(*gcControllerState).endCycle(SB)	

TEXT runtime.(*gcControllerState).enlistWorker(SB) /usr/local/go/src/runtime/mgc.go
func (c *gcControllerState) enlistWorker() {
  0x412960		4883ec08		SUBQ $0x8, SP		
  0x412964		48892c24		MOVQ BP, 0(SP)		
  0x412968		488d2c24		LEAQ 0(SP), BP		
	if c.dedicatedMarkWorkersNeeded <= 0 {
  0x41296c		488b442410		MOVQ 0x10(SP), AX	
  0x412971		4883783800		CMPQ $0x0, 0x38(AX)	
  0x412976		0f8e56010000		JLE 0x412ad2		
	if gomaxprocs <= 1 {
  0x41297c		833d5da30c0001		CMPL $0x1, runtime.gomaxprocs(SB)	
  0x412983		0f8e40010000		JLE 0x412ac9				
	gp := getg()
  0x412989		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == nil || gp.m == nil || gp.m.p == 0 {
  0x412992		4885c0			TESTQ AX, AX		
  0x412995		0f8425010000		JE 0x412ac0		
  0x41299b		488b4030		MOVQ 0x30(AX), AX	
  0x41299f		4885c0			TESTQ AX, AX		
  0x4129a2		0f8418010000		JE 0x412ac0		
  0x4129a8		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x4129af		4885c0			TESTQ AX, AX		
  0x4129b2		0f8408010000		JE 0x412ac0		
	myID := gp.m.p.ptr().id
  0x4129b8		90			NOPL			
  0x4129b9		8b4008			MOVL 0x8(AX), AX	
  0x4129bc		31c9			XORL CX, CX		
	for tries := 0; tries < 5; tries++ {
  0x4129be		eb03			JMP 0x4129c3		
  0x4129c0		48ffc1			INCQ CX			
  0x4129c3		4883f905		CMPQ $0x5, CX		
  0x4129c7		0f8dea000000		JGE 0x412ab7		
	mp := getg().m
  0x4129cd		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x4129d6		488b5230		MOVQ 0x30(DX), DX	
		id := int32(fastrandn(uint32(gomaxprocs - 1)))
  0x4129da		90			NOPL				
  0x4129db		8b1dffa20c00		MOVL runtime.gomaxprocs(SB), BX	
	return uint32(uint64(fastrand()) * uint64(n) >> 32)
  0x4129e1		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x4129e2		8bb220010000		MOVL 0x120(DX), SI	
  0x4129e8		8bba24010000		MOVL 0x124(DX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x4129ee		89ba20010000		MOVL DI, 0x120(DX)	
	s1 ^= s1 << 17
  0x4129f4		4189f0			MOVL SI, R8		
  0x4129f7		c1e611			SHLL $0x11, SI		
  0x4129fa		4431c6			XORL R8, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x4129fd		4189f8			MOVL DI, R8		
  0x412a00		31f7			XORL SI, DI		
  0x412a02		c1ee07			SHRL $0x7, SI		
  0x412a05		31fe			XORL DI, SI		
  0x412a07		4489c7			MOVL R8, DI		
  0x412a0a		41c1e810		SHRL $0x10, R8		
  0x412a0e		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x412a11		44898224010000		MOVL R8, 0x124(DX)	
		id := int32(fastrandn(uint32(gomaxprocs - 1)))
  0x412a18		8d53ff			LEAL -0x1(BX), DX	
	return s0 + s1
  0x412a1b		428d1c07		LEAL 0(DI)(R8*1), BX	
	return uint32(uint64(fastrand()) * uint64(n) >> 32)
  0x412a1f		480fafda		IMULQ DX, BX		
  0x412a23		48c1eb20		SHRQ $0x20, BX		
		if id >= myID {
  0x412a27		39c3			CMPL AX, BX		
  0x412a29		0f8c80000000		JL 0x412aaf		
			id++
  0x412a2f		8d5301			LEAL 0x1(BX), DX	
		p := allp[id]
  0x412a32		488b1de7ef0a00		MOVQ runtime.allp(SB), BX	
  0x412a39		4863d2			MOVSXD DX, DX			
  0x412a3c		483915e5ef0a00		CMPQ DX, runtime.allp+8(SB)	
  0x412a43		0f8692000000		JBE 0x412adb			
  0x412a49		488b14d3		MOVQ 0(BX)(DX*8), DX		
		if p.status != _Prunning {
  0x412a4d		837a0c01		CMPL $0x1, 0xc(DX)	
  0x412a51		0f8569ffffff		JNE 0x4129c0		
		if preemptone(p) {
  0x412a57		90			NOPL			
	mp := _p_.m.ptr()
  0x412a58		488b5240		MOVQ 0x40(DX), DX	
  0x412a5c		90			NOPL			
	if mp == nil || mp == getg().m {
  0x412a5d		4885d2			TESTQ DX, DX		
  0x412a60		740f			JE 0x412a71		
  0x412a62		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x412a6b		48395330		CMPQ DX, 0x30(BX)	
  0x412a6f		7513			JNE 0x412a84		
  0x412a71		31d2			XORL DX, DX		
		if preemptone(p) {
  0x412a73		84d2			TESTL DL, DL		
  0x412a75		0f8445ffffff		JE 0x4129c0		
			return
  0x412a7b		488b2c24		MOVQ 0(SP), BP		
  0x412a7f		4883c408		ADDQ $0x8, SP		
  0x412a83		c3			RET			
	gp := mp.curg
  0x412a84		488b9ac0000000		MOVQ 0xc0(DX), BX	
	if gp == nil || gp == mp.g0 {
  0x412a8b		4885db			TESTQ BX, BX		
  0x412a8e		7405			JE 0x412a95		
  0x412a90		48391a			CMPQ BX, 0(DX)		
  0x412a93		7504			JNE 0x412a99		
  0x412a95		31d2			XORL DX, DX		
		if preemptone(p) {
  0x412a97		ebda			JMP 0x412a73		
	gp.preempt = true
  0x412a99		c683b100000001		MOVB $0x1, 0xb1(BX)	
	gp.stackguard0 = stackPreempt
  0x412aa0		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
  0x412aa8		ba01000000		MOVL $0x1, DX		
		if preemptone(p) {
  0x412aad		ebc4			JMP 0x412a73		
		p := allp[id]
  0x412aaf		4889da			MOVQ BX, DX		
		if id >= myID {
  0x412ab2		e97bffffff		JMP 0x412a32		
  0x412ab7		488b2c24		MOVQ 0(SP), BP		
  0x412abb		4883c408		ADDQ $0x8, SP		
  0x412abf		c3			RET			
		return
  0x412ac0		488b2c24		MOVQ 0(SP), BP		
  0x412ac4		4883c408		ADDQ $0x8, SP		
  0x412ac8		c3			RET			
		return
  0x412ac9		488b2c24		MOVQ 0(SP), BP		
  0x412acd		4883c408		ADDQ $0x8, SP		
  0x412ad1		c3			RET			
		return
  0x412ad2		488b2c24		MOVQ 0(SP), BP		
  0x412ad6		4883c408		ADDQ $0x8, SP		
  0x412ada		c3			RET			
		p := allp[id]
  0x412adb		e840f40000		CALL runtime.panicindex(SB)	
  0x412ae0		0f0b			UD2				

TEXT runtime.(*gcControllerState).findRunnableGCWorker(SB) /usr/local/go/src/runtime/mgc.go
func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {
  0x412af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412af9		483b6110		CMPQ 0x10(CX), SP	
  0x412afd		0f8641020000		JBE 0x412d44		
  0x412b03		4883ec20		SUBQ $0x20, SP		
  0x412b07		48896c2418		MOVQ BP, 0x18(SP)	
  0x412b0c		488d6c2418		LEAQ 0x18(SP), BP	
	if gcBlackenEnabled == 0 {
  0x412b11		833db8a10c0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x412b18		0f840b020000		JE 0x412d29				
	if _p_.gcBgMarkWorker == 0 {
  0x412b1e		488b442430		MOVQ 0x30(SP), AX	
  0x412b23		8400			TESTB AL, 0(AX)		
  0x412b25		4883b85812000000	CMPQ $0x0, 0x1258(AX)	
  0x412b2d		0f84e3010000		JE 0x412d16		
	if !gcMarkWorkAvailable(_p_) {
  0x412b33		90			NOPL			
	if p != nil && !p.gcw.empty() {
  0x412b34		90			NOPL			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x412b35		488b8870120000		MOVQ 0x1270(AX), CX	
  0x412b3c		4885c9			TESTQ CX, CX		
  0x412b3f		0f84c7010000		JE 0x412d0c		
  0x412b45		4883791000		CMPQ $0x0, 0x10(CX)	
  0x412b4a		0f85b5010000		JNE 0x412d05		
  0x412b50		488b8878120000		MOVQ 0x1278(AX), CX	
  0x412b57		4883791000		CMPQ $0x0, 0x10(CX)	
  0x412b5c		0f94c1			SETE CL			
	if p != nil && !p.gcw.empty() {
  0x412b5f		84c9			TESTL CL, CL		
  0x412b61		0f8494010000		JE 0x412cfb		
	if !work.full.empty() {
  0x412b67		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x412b68		488b0d11f40a00		MOVQ runtime.work(SB), CX	
  0x412b6f		4885c9			TESTQ CX, CX			
	if !work.full.empty() {
  0x412b72		0f8579010000		JNE 0x412cf1		
	if work.markrootNext < work.markrootJobs {
  0x412b78		8b0d8ef40a00		MOVL runtime.work+140(SB), CX	
  0x412b7e		390d84f40a00		CMPL CX, runtime.work+136(SB)	
  0x412b84		0f8360010000		JAE 0x412cea			
  0x412b8a		b901000000		MOVL $0x1, CX			
	if !gcMarkWorkAvailable(_p_) {
  0x412b8f		84c9			TESTL CL, CL		
  0x412b91		0f8440010000		JE 0x412cd7		
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x412b97		90			NOPL			
		if *ptr > 0 {
  0x412b98		488b4c2428		MOVQ 0x28(SP), CX	
  0x412b9d		4883793800		CMPQ $0x0, 0x38(CX)	
  0x412ba2		0f8e28010000		JLE 0x412cd0		
			if atomic.Xaddint64(ptr, -1) >= 0 {
  0x412ba8		48c7c2ffffffff		MOVQ $-0x1, DX		
  0x412baf		f0480fc15138		LOCK XADDQ DX, 0x38(CX)	
  0x412bb5		48ffca			DECQ DX			
  0x412bb8		4885d2			TESTQ DX, DX		
  0x412bbb		0f8c04010000		JL 0x412cc5		
  0x412bc1		ba01000000		MOVL $0x1, DX		
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x412bc6		84d2			TESTL DL, DL		
  0x412bc8		7466			JE 0x412c30		
		_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode
  0x412bca		48c7806012000000000000	MOVQ $0x0, 0x1260(AX)	
	gp := _p_.gcBgMarkWorker.ptr()
  0x412bd5		488b8058120000		MOVQ 0x1258(AX), AX	
  0x412bdc		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x412bdd		4889442410		MOVQ AX, 0x10(SP)	
	casgstatus(gp, _Gwaiting, _Grunnable)
  0x412be2		48890424		MOVQ AX, 0(SP)			
  0x412be6		48b90400000001000000	MOVQ $0x100000004, CX		
  0x412bf0		48894c2408		MOVQ CX, 0x8(SP)		
  0x412bf5		e8a6400100		CALL runtime.casgstatus(SB)	
	if trace.enabled {
  0x412bfa		803dcf9f0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x412c01		7514			JNE 0x412c17			
	return gp
  0x412c03		488b442410		MOVQ 0x10(SP), AX	
  0x412c08		4889442438		MOVQ AX, 0x38(SP)	
  0x412c0d		488b6c2418		MOVQ 0x18(SP), BP	
  0x412c12		4883c420		ADDQ $0x20, SP		
  0x412c16		c3			RET			
		traceGoUnpark(gp, 0)
  0x412c17		488b442410		MOVQ 0x10(SP), AX		
  0x412c1c		48890424		MOVQ AX, 0(SP)			
  0x412c20		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x412c29		e892a50200		CALL runtime.traceGoUnpark(SB)	
  0x412c2e		ebd3			JMP 0x412c03			
	} else if c.fractionalUtilizationGoal == 0 {
  0x412c30		f20f104150		MOVSD_XMM 0x50(CX), X0	
  0x412c35		0f57c9			XORPS X1, X1		
  0x412c38		660f2ec1		UCOMISD X1, X0		
  0x412c3c		7502			JNE 0x412c40		
  0x412c3e		7b72			JNP 0x412cb2		
		delta := nanotime() - gcController.markStartTime
  0x412c40		e86b840300		CALL runtime.nanotime(SB)		
  0x412c45		488b0424		MOVQ 0(SP), AX				
  0x412c49		482b0560a50c00		SUBQ runtime.gcController+48(SB), AX	
		if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
  0x412c50		4885c0			TESTQ AX, AX		
  0x412c53		7e56			JLE 0x412cab		
  0x412c55		488b4c2430		MOVQ 0x30(SP), CX	
  0x412c5a		488b9150120000		MOVQ 0x1250(CX), DX	
  0x412c61		0f57c0			XORPS X0, X0		
  0x412c64		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x412c69		0f57c9			XORPS X1, X1		
  0x412c6c		f2480f2ac8		CVTSI2SDQ AX, X1	
  0x412c71		f20f5ec1		DIVSD X1, X0		
  0x412c75		488b442428		MOVQ 0x28(SP), AX	
  0x412c7a		f20f104850		MOVSD_XMM 0x50(AX), X1	
  0x412c7f		660f2ec1		UCOMISD X1, X0		
  0x412c83		7713			JA 0x412c98		
		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode
  0x412c85		48c7816012000001000000	MOVQ $0x1, 0x1260(CX)	
	gp := _p_.gcBgMarkWorker.ptr()
  0x412c90		4889c8			MOVQ CX, AX		
  0x412c93		e93dffffff		JMP 0x412bd5		
			return nil
  0x412c98		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x412ca1		488b6c2418		MOVQ 0x18(SP), BP	
  0x412ca6		4883c420		ADDQ $0x20, SP		
  0x412caa		c3			RET			
		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode
  0x412cab		488b4c2430		MOVQ 0x30(SP), CX	
		if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
  0x412cb0		ebd3			JMP 0x412c85		
		return nil
  0x412cb2		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x412cbb		488b6c2418		MOVQ 0x18(SP), BP	
  0x412cc0		4883c420		ADDQ $0x20, SP		
  0x412cc4		c3			RET			
			atomic.Xaddint64(ptr, +1)
  0x412cc5		ba01000000		MOVL $0x1, DX		
  0x412cca		f0480fc15138		LOCK XADDQ DX, 0x38(CX)	
	} else if c.fractionalUtilizationGoal == 0 {
  0x412cd0		31d2			XORL DX, DX		
	if decIfPositive(&c.dedicatedMarkWorkersNeeded) {
  0x412cd2		e9effeffff		JMP 0x412bc6		
		return nil
  0x412cd7		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x412ce0		488b6c2418		MOVQ 0x18(SP), BP	
  0x412ce5		4883c420		ADDQ $0x20, SP		
  0x412ce9		c3			RET			
  0x412cea		31c9			XORL CX, CX		
	if !gcMarkWorkAvailable(_p_) {
  0x412cec		e99efeffff		JMP 0x412b8f		
  0x412cf1		b901000000		MOVL $0x1, CX		
  0x412cf6		e994feffff		JMP 0x412b8f		
  0x412cfb		b901000000		MOVL $0x1, CX		
  0x412d00		e98afeffff		JMP 0x412b8f		
  0x412d05		31c9			XORL CX, CX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x412d07		e953feffff		JMP 0x412b5f		
  0x412d0c		b901000000		MOVL $0x1, CX		
  0x412d11		e949feffff		JMP 0x412b5f		
		return nil
  0x412d16		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x412d1f		488b6c2418		MOVQ 0x18(SP), BP	
  0x412d24		4883c420		ADDQ $0x20, SP		
  0x412d28		c3			RET			
		throw("gcControllerState.findRunnable: blackening not enabled")
  0x412d29		488d050f060600		LEAQ 0x6060f(IP), AX	
  0x412d30		48890424		MOVQ AX, 0(SP)		
  0x412d34		48c744240836000000	MOVQ $0x36, 0x8(SP)	
  0x412d3d		e83e070100		CALL runtime.throw(SB)	
  0x412d42		0f0b			UD2			
func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {
  0x412d44		e8374b0300		CALL runtime.morestack_noctxt(SB)				
  0x412d49		e9a2fdffff		JMP runtime.(*gcControllerState).findRunnableGCWorker(SB)	

TEXT runtime.pollFractionalWorkerExit(SB) /usr/local/go/src/runtime/mgc.go
func pollFractionalWorkerExit() bool {
  0x412d50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412d59		483b6110		CMPQ 0x10(CX), SP	
  0x412d5d		0f8699000000		JBE 0x412dfc		
  0x412d63		4883ec10		SUBQ $0x10, SP		
  0x412d67		48896c2408		MOVQ BP, 0x8(SP)	
  0x412d6c		488d6c2408		LEAQ 0x8(SP), BP	
	now := nanotime()
  0x412d71		e83a830300		CALL runtime.nanotime(SB)	
  0x412d76		488b0424		MOVQ 0(SP), AX			
	delta := now - gcController.markStartTime
  0x412d7a		488b0d2fa40c00		MOVQ runtime.gcController+48(SB), CX	
  0x412d81		4889c2			MOVQ AX, DX				
  0x412d84		4829c8			SUBQ CX, AX				
	if delta <= 0 {
  0x412d87		4885c0			TESTQ AX, AX		
  0x412d8a		7f0f			JG 0x412d9b		
		return true
  0x412d8c		c644241801		MOVB $0x1, 0x18(SP)	
  0x412d91		488b6c2408		MOVQ 0x8(SP), BP	
  0x412d96		4883c410		ADDQ $0x10, SP		
  0x412d9a		c3			RET			
	p := getg().m.p.ptr()
  0x412d9b		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412da4		488b4930		MOVQ 0x30(CX), CX	
  0x412da8		488b89d0000000		MOVQ 0xd0(CX), CX	
	selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)
  0x412daf		8401			TESTB AL, 0(CX)		
	p := getg().m.p.ptr()
  0x412db1		90			NOPL			
	selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)
  0x412db2		488b9968120000		MOVQ 0x1268(CX), BX	
  0x412db9		4829da			SUBQ BX, DX		
  0x412dbc		48039150120000		ADDQ 0x1250(CX), DX	
	return float64(selfTime)/float64(delta) > 1.2*gcController.fractionalUtilizationGoal
  0x412dc3		f20f1005fd9e0600	MOVSD_XMM $f64.3ff3333333333333(SB), X0	
  0x412dcb		f20f5905fda30c00	MULSD runtime.gcController+80(SB), X0	
  0x412dd3		0f57c9			XORPS X1, X1				
  0x412dd6		f2480f2aca		CVTSI2SDQ DX, X1			
  0x412ddb		0f57d2			XORPS X2, X2				
  0x412dde		f2480f2ad0		CVTSI2SDQ AX, X2			
  0x412de3		f20f5eca		DIVSD X2, X1				
  0x412de7		660f2ec8		UCOMISD X0, X1				
  0x412deb		0f97c0			SETA AL					
  0x412dee		88442418		MOVB AL, 0x18(SP)			
  0x412df2		488b6c2408		MOVQ 0x8(SP), BP			
  0x412df7		4883c410		ADDQ $0x10, SP				
  0x412dfb		c3			RET					
func pollFractionalWorkerExit() bool {
  0x412dfc		e87f4a0300		CALL runtime.morestack_noctxt(SB)		
  0x412e01		e94affffff		JMP runtime.pollFractionalWorkerExit(SB)	

TEXT runtime.gcSetTriggerRatio(SB) /usr/local/go/src/runtime/mgc.go
func gcSetTriggerRatio(triggerRatio float64) {
  0x412e10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x412e19		483b6110		CMPQ 0x10(CX), SP	
  0x412e1d		0f86db030000		JBE 0x4131fe		
  0x412e23		4883ec48		SUBQ $0x48, SP		
  0x412e27		48896c2440		MOVQ BP, 0x40(SP)	
  0x412e2c		488d6c2440		LEAQ 0x40(SP), BP	
	if triggerRatio < 0 {
  0x412e31		0f57c0			XORPS X0, X0		
  0x412e34		f20f104c2450		MOVSD_XMM 0x50(SP), X1	
  0x412e3a		660f2ec1		UCOMISD X1, X0		
  0x412e3e		0f8628020000		JBE 0x41306c		
  0x412e44		0f57c9			XORPS X1, X1		
	memstats.triggerRatio = triggerRatio
  0x412e47		f20f110d41c50c00	MOVSD_XMM X1, runtime.memstats+5936(SB)	
	if gcpercent >= 0 {
  0x412e4f		833d829e0c0000		CMPL $0x0, runtime.gcpercent(SB)	
  0x412e56		0f8c04020000		JL 0x413060				
		trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))
  0x412e5c		488b0d4dc50c00		MOVQ runtime.memstats+5968(SB), CX	
  0x412e63		4885c9			TESTQ CX, CX				
  0x412e66		0f8cd6010000		JL 0x413042				
  0x412e6c		0f57d2			XORPS X2, X2				
  0x412e6f		f2480f2ad1		CVTSI2SDQ CX, X2			
  0x412e74		f20f101d3c9e0600	MOVSD_XMM $f64.3ff0000000000000(SB), X3	
  0x412e7c		f20f58d9		ADDSD X1, X3				
  0x412e80		f20f59da		MULSD X2, X3				
  0x412e84		f20f1015749e0600	MOVSD_XMM $f64.43e0000000000000(SB), X2	
  0x412e8c		660f2ed3		UCOMISD X3, X2				
  0x412e90		0f8699010000		JBE 0x41302f				
  0x412e96		f2480f2ccb		CVTTSD2SIQ X3, CX			
		minTrigger := heapminimum
  0x412e9b		488b1596c10a00		MOVQ runtime.heapminimum(SB), DX	
		if !isSweepDone() {
  0x412ea2		90			NOPL			
	return mheap_.sweepdone != 0
  0x412ea3		833db2370b0000		CMPL $0x0, runtime.mheap_+28(SB)	
		if !isSweepDone() {
  0x412eaa		0f8444010000		JE 0x412ff4		
		if trigger < minTrigger {
  0x412eb0		4839d1			CMPQ DX, CX		
		if int64(trigger) < 0 {
  0x412eb3		480f42ca		CMOVB DX, CX		
  0x412eb7		4885c9			TESTQ CX, CX		
		if trigger < minTrigger {
  0x412eba		0f8ced010000		JL 0x4130ad		
	memstats.gc_trigger = trigger
  0x412ec0		48890dd1c40c00		MOVQ CX, runtime.memstats+5944(SB)	
	if gcpercent >= 0 {
  0x412ec7		8b150b9e0c00		MOVL runtime.gcpercent(SB), DX	
  0x412ecd		85d2			TESTL DX, DX			
  0x412ecf		0f8c13010000		JL 0x412fe8			
		goal = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100
  0x412ed5		488b05d4c40c00		MOVQ runtime.memstats+5968(SB), AX	
  0x412edc		4863d2			MOVSXD DX, DX				
  0x412edf		480fafd0		IMULQ AX, DX				
  0x412ee3		48d1ea			SHRQ $0x1, DX				
  0x412ee6		4889c3			MOVQ AX, BX				
  0x412ee9		4889d0			MOVQ DX, AX				
  0x412eec		48be0bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, SI		
  0x412ef6		48f7e6			MULQ SI					
  0x412ef9		48c1ea05		SHRQ $0x5, DX				
  0x412efd		4801da			ADDQ BX, DX				
		if goal < trigger {
  0x412f00		4839ca			CMPQ CX, DX		
	memstats.next_gc = goal
  0x412f03		480f42d1		CMOVB CX, DX		
	memstats.gc_trigger = trigger
  0x412f07		48894c2418		MOVQ CX, 0x18(SP)	
	memstats.next_gc = goal
  0x412f0c		488915f5ad0c00		MOVQ DX, runtime.memstats+168(SB)	
	if trace.enabled {
  0x412f13		803db69c0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x412f1a		0f85b6000000		JNE 0x412fd6			
	if gcphase != _GCoff {
  0x412f20		833db59d0c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x412f27		0f858c000000		JNE 0x412fb9			
	if isSweepDone() {
  0x412f2d		90			NOPL			
	return mheap_.sweepdone != 0
  0x412f2e		833d27370b0000		CMPL $0x0, runtime.mheap_+28(SB)	
	if isSweepDone() {
  0x412f35		7412			JE 0x412f49		
		mheap_.sweepPagesPerByte = 0
  0x412f37		f20f1105b9370b00	MOVSD_XMM X0, runtime.mheap_+184(SB)	
  0x412f3f		488b6c2440		MOVQ 0x40(SP), BP			
  0x412f44		4883c448		ADDQ $0x48, SP				
  0x412f48		c3			RET					
		heapLiveBasis := atomic.Load64(&memstats.heap_live)
  0x412f49		488b0550c40c00		MOVQ runtime.memstats+5952(SB), AX	
		pagesSwept := atomic.Load64(&mheap_.pagesSwept)
  0x412f50		488b1589370b00		MOVQ runtime.mheap_+160(SB), DX	
		heapDistance := int64(trigger) - int64(heapLiveBasis)
  0x412f57		4829c1			SUBQ AX, CX		
		heapDistance -= 1024 * 1024
  0x412f5a		4881c10000f0ff		ADDQ $-0x100000, CX	
		if heapDistance < _PageSize {
  0x412f61		4881f900200000		CMPQ $0x2000, CX	
			mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)
  0x412f68		bb00200000		MOVL $0x2000, BX	
  0x412f6d		480f4ccb		CMOVL BX, CX		
		sweepDistancePages := int64(mheap_.pagesInUse) - int64(pagesSwept)
  0x412f71		488b1d60370b00		MOVQ runtime.mheap_+152(SB), BX	
  0x412f78		4829d3			SUBQ DX, BX			
		if sweepDistancePages <= 0 {
  0x412f7b		4885db			TESTQ BX, BX		
		if heapDistance < _PageSize {
  0x412f7e		7f0a			JG 0x412f8a		
			mheap_.sweepPagesPerByte = 0
  0x412f80		f20f110570370b00	MOVSD_XMM X0, runtime.mheap_+184(SB)	
  0x412f88		ebb5			JMP 0x412f3f				
			mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)
  0x412f8a		0f57c0			XORPS X0, X0				
  0x412f8d		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x412f92		0f57c9			XORPS X1, X1				
  0x412f95		f2480f2ac9		CVTSI2SDQ CX, X1			
  0x412f9a		f20f5ec1		DIVSD X1, X0				
  0x412f9e		f20f110552370b00	MOVSD_XMM X0, runtime.mheap_+184(SB)	
			mheap_.sweepHeapLiveBasis = heapLiveBasis
  0x412fa6		48890543370b00		MOVQ AX, runtime.mheap_+176(SB)	
			atomic.Store64(&mheap_.pagesSweptBasis, pagesSwept)
  0x412fad		488d0534370b00		LEAQ runtime.mheap_+168(SB), AX	
  0x412fb4		488710			XCHGQ DX, 0(AX)			
  0x412fb7		eb86			JMP 0x412f3f			
		gcController.revise()
  0x412fb9		488d05c0a10c00		LEAQ runtime.gcController(SB), AX		
  0x412fc0		48890424		MOVQ AX, 0(SP)					
  0x412fc4		e8c7f3ffff		CALL runtime.(*gcControllerState).revise(SB)	
		heapDistance := int64(trigger) - int64(heapLiveBasis)
  0x412fc9		488b4c2418		MOVQ 0x18(SP), CX	
  0x412fce		0f57c0			XORPS X0, X0		
		gcController.revise()
  0x412fd1		e957ffffff		JMP 0x412f2d		
		traceNextGC()
  0x412fd6		e8f5a40200		CALL runtime.traceNextGC(SB)	
		heapDistance := int64(trigger) - int64(heapLiveBasis)
  0x412fdb		488b4c2418		MOVQ 0x18(SP), CX	
  0x412fe0		0f57c0			XORPS X0, X0		
		traceNextGC()
  0x412fe3		e938ffffff		JMP 0x412f20		
  0x412fe8		48c7c2ffffffff		MOVQ $-0x1, DX		
	if gcpercent >= 0 {
  0x412fef		e913ffffff		JMP 0x412f07		
			sweepMin := atomic.Load64(&memstats.heap_live) + sweepMinHeapDistance*uint64(gcpercent)/100
  0x412ff4		488b1da5c30c00		MOVQ runtime.memstats+5952(SB), BX	
  0x412ffb		486335d69c0c00		MOVSXD runtime.gcpercent(SB), SI	
  0x413002		48c1e614		SHLQ $0x14, SI				
  0x413006		48d1ee			SHRQ $0x1, SI				
  0x413009		48b80bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, AX		
		minTrigger := heapminimum
  0x413013		4889d7			MOVQ DX, DI		
			sweepMin := atomic.Load64(&memstats.heap_live) + sweepMinHeapDistance*uint64(gcpercent)/100
  0x413016		48f7e6			MULQ SI			
  0x413019		48c1ea05		SHRQ $0x5, DX		
  0x41301d		4801d3			ADDQ DX, BX		
			if sweepMin > minTrigger {
  0x413020		4839fb			CMPQ DI, BX		
		if trigger < minTrigger {
  0x413023		480f47fb		CMOVA BX, DI		
  0x413027		4889fa			MOVQ DI, DX		
			if sweepMin > minTrigger {
  0x41302a		e981feffff		JMP 0x412eb0		
		trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))
  0x41302f		f20f5cda		SUBSD X2, X3		
  0x413033		f2480f2ccb		CVTTSD2SIQ X3, CX	
  0x413038		480fbae93f		BTSQ $0x3f, CX		
  0x41303d		e959feffff		JMP 0x412e9b		
  0x413042		4889ca			MOVQ CX, DX		
  0x413045		48d1e9			SHRQ $0x1, CX		
  0x413048		4883e201		ANDQ $0x1, DX		
  0x41304c		4809ca			ORQ CX, DX		
  0x41304f		0f57d2			XORPS X2, X2		
  0x413052		f2480f2ad2		CVTSI2SDQ DX, X2	
  0x413057		f20f58d2		ADDSD X2, X2		
  0x41305b		e914feffff		JMP 0x412e74		
  0x413060		48c7c1ffffffff		MOVQ $-0x1, CX		
	if gcpercent >= 0 {
  0x413067		e954feffff		JMP 0x412ec0		
	} else if gcpercent >= 0 {
  0x41306c		8b0d669c0c00		MOVL runtime.gcpercent(SB), CX	
  0x413072		85c9			TESTL CX, CX			
  0x413074		7c32			JL 0x4130a8			
		maxTriggerRatio := 0.95 * float64(gcpercent) / 100
  0x413076		0f57d2			XORPS X2, X2				
  0x413079		f20f2ad1		CVTSI2SDL CX, X2			
  0x41307d		f20f101d2b9c0600	MOVSD_XMM $f64.3fee666666666666(SB), X3	
  0x413085		f20f59d3		MULSD X3, X2				
  0x413089		f20f101d5f9c0600	MOVSD_XMM $f64.4059000000000000(SB), X3	
  0x413091		f20f5ed3		DIVSD X3, X2				
		if triggerRatio > maxTriggerRatio {
  0x413095		660f2eca		UCOMISD X2, X1		
  0x413099		7608			JBE 0x4130a3		
	memstats.triggerRatio = triggerRatio
  0x41309b		0f10ca			MOVUPS X2, X1		
  0x41309e		e9a4fdffff		JMP 0x412e47		
  0x4130a3		0f10d1			MOVUPS X1, X2		
		if triggerRatio > maxTriggerRatio {
  0x4130a6		ebf3			JMP 0x41309b		
	memstats.triggerRatio = triggerRatio
  0x4130a8		0f10d1			MOVUPS X1, X2		
	} else if gcpercent >= 0 {
  0x4130ab		ebee			JMP 0x41309b		
	memstats.triggerRatio = triggerRatio
  0x4130ad		f20f114c2450		MOVSD_XMM X1, 0x50(SP)	
		if trigger < minTrigger {
  0x4130b3		4889542410		MOVQ DX, 0x10(SP)	
			print("runtime: next_gc=", memstats.next_gc, " heap_marked=", memstats.heap_marked, " heap_live=", memstats.heap_live, " initialHeapLive=", work.initialHeapLive, "triggerRatio=", triggerRatio, " minTrigger=", minTrigger, "\n")
  0x4130b8		488b0549ac0c00		MOVQ runtime.memstats+168(SB), AX	
  0x4130bf		4889442438		MOVQ AX, 0x38(SP)			
  0x4130c4		488b0de5c20c00		MOVQ runtime.memstats+5968(SB), CX	
  0x4130cb		48894c2430		MOVQ CX, 0x30(SP)			
  0x4130d0		488b15c9c20c00		MOVQ runtime.memstats+5952(SB), DX	
  0x4130d7		4889542428		MOVQ DX, 0x28(SP)			
  0x4130dc		488b1d9def0a00		MOVQ runtime.work+256(SB), BX		
  0x4130e3		48895c2420		MOVQ BX, 0x20(SP)			
  0x4130e8		e8d30d0100		CALL runtime.printlock(SB)		
  0x4130ed		488d05f2d00500		LEAQ 0x5d0f2(IP), AX			
  0x4130f4		48890424		MOVQ AX, 0(SP)				
  0x4130f8		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x413101		e8ea160100		CALL runtime.printstring(SB)		
  0x413106		488b442438		MOVQ 0x38(SP), AX			
  0x41310b		48890424		MOVQ AX, 0(SP)				
  0x41310f		e82c140100		CALL runtime.printuint(SB)		
  0x413114		488d0589ca0500		LEAQ 0x5ca89(IP), AX			
  0x41311b		48890424		MOVQ AX, 0(SP)				
  0x41311f		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x413128		e8c3160100		CALL runtime.printstring(SB)		
  0x41312d		488b442430		MOVQ 0x30(SP), AX			
  0x413132		48890424		MOVQ AX, 0(SP)				
  0x413136		e805140100		CALL runtime.printuint(SB)		
  0x41313b		488d0500c70500		LEAQ 0x5c700(IP), AX			
  0x413142		48890424		MOVQ AX, 0(SP)				
  0x413146		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x41314f		e89c160100		CALL runtime.printstring(SB)		
  0x413154		488b442428		MOVQ 0x28(SP), AX			
  0x413159		48890424		MOVQ AX, 0(SP)				
  0x41315d		e8de130100		CALL runtime.printuint(SB)		
  0x413162		488d057ecf0500		LEAQ 0x5cf7e(IP), AX			
  0x413169		48890424		MOVQ AX, 0(SP)				
  0x41316d		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x413176		e875160100		CALL runtime.printstring(SB)		
  0x41317b		488b442420		MOVQ 0x20(SP), AX			
  0x413180		48890424		MOVQ AX, 0(SP)				
  0x413184		e8b7130100		CALL runtime.printuint(SB)		
  0x413189		488d0525cb0500		LEAQ 0x5cb25(IP), AX			
  0x413190		48890424		MOVQ AX, 0(SP)				
  0x413194		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x41319d		e84e160100		CALL runtime.printstring(SB)		
  0x4131a2		f20f10442450		MOVSD_XMM 0x50(SP), X0			
  0x4131a8		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x4131ad		e85e100100		CALL runtime.printfloat(SB)		
  0x4131b2		488d0504c80500		LEAQ 0x5c804(IP), AX			
  0x4131b9		48890424		MOVQ AX, 0(SP)				
  0x4131bd		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x4131c6		e825160100		CALL runtime.printstring(SB)		
  0x4131cb		488b442410		MOVQ 0x10(SP), AX			
  0x4131d0		48890424		MOVQ AX, 0(SP)				
  0x4131d4		e867130100		CALL runtime.printuint(SB)		
  0x4131d9		e8720f0100		CALL runtime.printnl(SB)		
  0x4131de		e85d0d0100		CALL runtime.printunlock(SB)		
			throw("gc_trigger underflow")
  0x4131e3		488d0573d40500		LEAQ 0x5d473(IP), AX	
  0x4131ea		48890424		MOVQ AX, 0(SP)		
  0x4131ee		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x4131f7		e884020100		CALL runtime.throw(SB)	
  0x4131fc		0f0b			UD2			
func gcSetTriggerRatio(triggerRatio float64) {
  0x4131fe		e87d460300		CALL runtime.morestack_noctxt(SB)	
  0x413203		e908fcffff		JMP runtime.gcSetTriggerRatio(SB)	

TEXT runtime.gcWaitOnMark(SB) /usr/local/go/src/runtime/mgc.go
func gcWaitOnMark(n uint32) {
  0x413210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413219		483b6110		CMPQ 0x10(CX), SP	
  0x41321d		0f86a2000000		JBE 0x4132c5		
  0x413223		4883ec28		SUBQ $0x28, SP		
  0x413227		48896c2420		MOVQ BP, 0x20(SP)	
  0x41322c		488d6c2420		LEAQ 0x20(SP), BP	
	for {
  0x413231		eb4d			JMP 0x413280		
		work.sweepWaiters.list.push(getg())
  0x413233		90			NOPL			
  0x413234		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	gp.schedlink = l.head
  0x41323d		488b0d64ee0a00		MOVQ runtime.work+296(SB), CX	
  0x413244		488988a0000000		MOVQ CX, 0xa0(AX)		
	l.head.set(gp)
  0x41324b		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41324c		48890555ee0a00		MOVQ AX, runtime.work+296(SB)	
		goparkunlock(&work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceEvGoBlock, 1)
  0x413253		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x413254		488d05d5060600		LEAQ 0x606d5(IP), AX		
  0x41325b		48890424		MOVQ AX, 0(SP)			
  0x41325f		488d0d3aee0a00		LEAQ runtime.work+288(SB), CX	
  0x413266		48894c2408		MOVQ CX, 0x8(SP)		
  0x41326b		66c74424101614		MOVW $0x1416, 0x10(SP)		
  0x413272		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x41327b		e8d01e0100		CALL runtime.gopark(SB)		
		lock(&work.sweepWaiters.lock)
  0x413280		488d0519ee0a00		LEAQ runtime.work+288(SB), AX	
  0x413287		48890424		MOVQ AX, 0(SP)			
  0x41328b		e85054ffff		CALL runtime.lock(SB)		
		nMarks := atomic.Load(&work.cycles)
  0x413290		8b051aee0a00		MOVL runtime.work+304(SB), AX	
			nMarks++
  0x413296		8d4801			LEAL 0x1(AX), CX	
		if gcphase != _GCmark {
  0x413299		833d3c9a0c0001		CMPL $0x1, runtime.gcphase(SB)	
		if nMarks > n {
  0x4132a0		0f45c1			CMOVNE CX, AX		
  0x4132a3		8b4c2430		MOVL 0x30(SP), CX	
  0x4132a7		39c8			CMPL CX, AX		
		if gcphase != _GCmark {
  0x4132a9		7688			JBE 0x413233		
			unlock(&work.sweepWaiters.lock)
  0x4132ab		488d05eeed0a00		LEAQ runtime.work+288(SB), AX	
  0x4132b2		48890424		MOVQ AX, 0(SP)			
  0x4132b6		e8d555ffff		CALL runtime.unlock(SB)		
			return
  0x4132bb		488b6c2420		MOVQ 0x20(SP), BP	
  0x4132c0		4883c428		ADDQ $0x28, SP		
  0x4132c4		c3			RET			
func gcWaitOnMark(n uint32) {
  0x4132c5		e8b6450300		CALL runtime.morestack_noctxt(SB)	
  0x4132ca		e941ffffff		JMP runtime.gcWaitOnMark(SB)		

TEXT runtime.gcStart(SB) /usr/local/go/src/runtime/mgc.go
func gcStart(trigger gcTrigger) {
  0x4132d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4132d9		483b6110		CMPQ 0x10(CX), SP	
  0x4132dd		0f868e060000		JBE 0x413971		
  0x4132e3		4883ec68		SUBQ $0x68, SP		
  0x4132e7		48896c2460		MOVQ BP, 0x60(SP)	
  0x4132ec		488d6c2460		LEAQ 0x60(SP), BP	
	_g_ := getg()
  0x4132f1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x4132fa		488b4830		MOVQ 0x30(AX), CX	
	mp := acquirem()
  0x4132fe		90			NOPL			
	_g_.m.locks++
  0x4132ff		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x413305		488b4830		MOVQ 0x30(AX), CX	
  0x413309		8400			TESTB AL, 0(AX)		
	if gp := getg(); gp == mp.g0 || mp.locks > 1 || mp.preemptoff != "" {
  0x41330b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x413314		483901			CMPQ AX, 0(CX)		
  0x413317		0f8474050000		JE 0x413891		
  0x41331d		8b9108010000		MOVL 0x108(CX), DX	
  0x413323		83fa01			CMPL $0x1, DX		
  0x413326		0f8f65050000		JG 0x413891		
  0x41332c		4883b90001000000	CMPQ $0x0, 0x100(CX)	
  0x413334		0f8557050000		JNE 0x413891		
	releasem(mp)
  0x41333a		90			NOPL			
	mp.locks--
  0x41333b		8d5aff			LEAL -0x1(DX), BX	
  0x41333e		899908010000		MOVL BX, 0x108(CX)	
	if gp := getg(); gp == mp.g0 || mp.locks > 1 || mp.preemptoff != "" {
  0x413344		83fa01			CMPL $0x1, DX		
	if mp.locks == 0 && _g_.preempt {
  0x413347		7511			JNE 0x41335a		
  0x413349		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x413350		7408			JE 0x41335a		
		_g_.stackguard0 = stackPreempt
  0x413352		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x41335a		8b842480000000		MOVL 0x80(SP), AX	
  0x413361		488b4c2470		MOVQ 0x70(SP), CX	
  0x413366		eb06			JMP 0x41336e		
		sweep.nbgsweep++
  0x413368		ff0506e80a00		INCL runtime.sweep+20(SB)	
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x41336e		90			NOPL			
	if !memstats.enablegc || panicking != 0 {
  0x41336f		803dbab90c0000		CMPB $0x0, runtime.memstats+4304(SB)	
  0x413376		740d			JE 0x413385				
  0x413378		833d75990c0000		CMPL $0x0, runtime.panicking(SB)	
  0x41337f		0f8463040000		JE 0x4137e8				
  0x413385		31d2			XORL DX, DX				
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x413387		84d2			TESTL DL, DL		
  0x413389		0f853b040000		JNE 0x4137ca		
  0x41338f		31d2			XORL DX, DX		
  0x413391		84d2			TESTL DL, DL		
  0x413393		75d3			JNE 0x413368		
	semacquire(&work.startSema)
  0x413395		90			NOPL			
	semacquire1(addr, false, 0)
  0x413396		488d05b3ec0a00		LEAQ runtime.work+208(SB), AX	
  0x41339d		48890424		MOVQ AX, 0(SP)			
  0x4133a1		c644240800		MOVB $0x0, 0x8(SP)		
  0x4133a6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4133af		e85cf10100		CALL runtime.semacquire1(SB)	
	if !trigger.test() {
  0x4133b4		90			NOPL			
	if !memstats.enablegc || panicking != 0 {
  0x4133b5		803d74b90c0000		CMPB $0x0, runtime.memstats+4304(SB)	
  0x4133bc		740d			JE 0x4133cb				
  0x4133be		833d2f990c0000		CMPL $0x0, runtime.panicking(SB)	
  0x4133c5		0f8453030000		JE 0x41371e				
  0x4133cb		31c0			XORL AX, AX				
	if !trigger.test() {
  0x4133cd		84c0			TESTL AL, AL		
  0x4133cf		0f8429030000		JE 0x4136fe		
	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle
  0x4133d5		488b442470		MOVQ 0x70(SP), AX		
  0x4133da		4885c0			TESTQ AX, AX			
  0x4133dd		0f850f030000		JNE 0x4136f2			
  0x4133e3		b801000000		MOVL $0x1, AX			
  0x4133e8		880582ec0a00		MOVB AL, runtime.work+240(SB)	
	if debug.gcstoptheworld == 1 {
  0x4133ee		8b05089b0c00		MOVL runtime.debug+28(SB), AX	
  0x4133f4		83f801			CMPL $0x1, AX			
  0x4133f7		0f85df020000		JNE 0x4136dc			
  0x4133fd		b801000000		MOVL $0x1, AX			
	work.mode = mode
  0x413402		4889442438		MOVQ AX, 0x38(SP)	
	semacquire(&worldsema)
  0x413407		90			NOPL			
	semacquire1(addr, false, 0)
  0x413408		488d0d01bc0a00		LEAQ runtime.worldsema(SB), CX	
  0x41340f		48890c24		MOVQ CX, 0(SP)			
  0x413413		c644240800		MOVB $0x0, 0x8(SP)		
  0x413418		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x413421		e8eaf00100		CALL runtime.semacquire1(SB)	
	if trace.enabled {
  0x413426		803da3970b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41342d		0f8559020000		JNE 0x41368c			
	for _, p := range allp {
  0x413433		488b05e6e50a00		MOVQ runtime.allp(SB), AX	
  0x41343a		488b0de7e50a00		MOVQ runtime.allp+8(SB), CX	
  0x413441		31d2			XORL DX, DX			
  0x413443		eb03			JMP 0x413448			
  0x413445		48ffc2			INCQ DX				
  0x413448		4839ca			CMPQ CX, DX			
  0x41344b		7d1f			JGE 0x41346c			
  0x41344d		488b1cd0		MOVQ 0(AX)(DX*8), BX		
		if fg := atomic.Load(&p.mcache.flushGen); fg != mheap_.sweepgen {
  0x413451		488b7348		MOVQ 0x48(BX), SI		
  0x413455		8403			TESTB AL, 0(BX)			
  0x413457		8bb6c0060000		MOVL 0x6c0(SI), SI		
  0x41345d		8b3df5310b00		MOVL runtime.mheap_+24(SB), DI	
  0x413463		39fe			CMPL DI, SI			
  0x413465		74de			JE 0x413445			
  0x413467		e955040000		JMP 0x4138c1			
	gcBgMarkStartWorkers()
  0x41346c		e8df120000		CALL runtime.gcBgMarkStartWorkers(SB)	
	gcResetMarkState()
  0x413471		e8da1f0000		CALL runtime.gcResetMarkState(SB)	
	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs
  0x413476		8b0564980c00		MOVL runtime.gomaxprocs(SB), AX	
  0x41347c		890532ec0a00		MOVL AX, runtime.work+308(SB)	
  0x413482		890530ec0a00		MOVL AX, runtime.work+312(SB)	
	if work.stwprocs > ncpu {
  0x413488		8b0d56980c00		MOVL runtime.ncpu(SB), CX	
  0x41348e		39c8			CMPL CX, AX			
  0x413490		7e06			JLE 0x413498			
		work.stwprocs = ncpu
  0x413492		890d1cec0a00		MOVL CX, runtime.work+308(SB)	
	work.heap0 = atomic.Load64(&memstats.heap_live)
  0x413498		488b0501bf0c00		MOVQ runtime.memstats+5952(SB), AX	
  0x41349f		4889054aec0a00		MOVQ AX, runtime.work+368(SB)		
	work.pauseNS = 0
  0x4134a6		48c7052fec0a0000000000	MOVQ $0x0, runtime.work+352(SB)	
	work.mode = mode
  0x4134b1		488b442438		MOVQ 0x38(SP), AX		
  0x4134b6		488905abeb0a00		MOVQ AX, runtime.work+232(SB)	
	now := nanotime()
  0x4134bd		e8ee7b0300		CALL runtime.nanotime(SB)	
  0x4134c2		488b0424		MOVQ 0(SP), AX			
  0x4134c6		4889442430		MOVQ AX, 0x30(SP)		
	work.tSweepTerm = now
  0x4134cb		488905eeeb0a00		MOVQ AX, runtime.work+320(SB)	
	work.pauseStart = now
  0x4134d2		4889050fec0a00		MOVQ AX, runtime.work+360(SB)	
	if trace.enabled {
  0x4134d9		803df0960b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x4134e0		0f8560010000		JNE 0x413646			
	systemstack(stopTheWorldWithSema)
  0x4134e6		488d05a3040600		LEAQ 0x604a3(IP), AX		
  0x4134ed		48890424		MOVQ AX, 0(SP)			
  0x4134f1		e83a420300		CALL runtime.systemstack(SB)	
	systemstack(func() {
  0x4134f6		488d0543030600		LEAQ 0x60343(IP), AX		
  0x4134fd		48890424		MOVQ AX, 0(SP)			
  0x413501		e82a420300		CALL runtime.systemstack(SB)	
	clearpools()
  0x413506		e895200000		CALL runtime.clearpools(SB)	
	work.cycles++
  0x41350b		ff059feb0a00		INCL runtime.work+304(SB)	
	gcController.startCycle()
  0x413511		488d05689c0c00		LEAQ runtime.gcController(SB), AX			
  0x413518		48890424		MOVQ AX, 0(SP)						
  0x41351c		e8cfeaffff		CALL runtime.(*gcControllerState).startCycle(SB)	
	work.heapGoal = memstats.next_gc
  0x413521		488b05e0a70c00		MOVQ runtime.memstats+168(SB), AX	
  0x413528		488905d9eb0a00		MOVQ AX, runtime.work+392(SB)		
	if mode != gcBackgroundMode {
  0x41352f		488b442438		MOVQ 0x38(SP), AX	
  0x413534		4885c0			TESTQ AX, AX		
  0x413537		0f85f6000000		JNE 0x413633		
	setGCPhase(_GCmark)
  0x41353d		90			NOPL			
	atomic.Store(&gcphase, x)
  0x41353e		b901000000		MOVL $0x1, CX			
  0x413543		488d1592970c00		LEAQ runtime.gcphase(SB), DX	
  0x41354a		870a			XCHGL CX, 0(DX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x41354c		8b0d8a970c00		MOVL runtime.gcphase(SB), CX		
  0x413552		83f901			CMPL $0x1, CX				
  0x413555		0f85cd000000		JNE 0x413628				
  0x41355b		b901000000		MOVL $0x1, CX				
  0x413560		880dbe980c00		MOVB CL, runtime.writeBarrier+4(SB)	
  0x413566		84c9			TESTL CL, CL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x413568		0f84ae000000		JE 0x41361c				
  0x41356e		b901000000		MOVL $0x1, CX				
  0x413573		880da7980c00		MOVB CL, runtime.writeBarrier(SB)	
	gcBgMarkPrepare() // Must happen before assist enable.
  0x413579		90			NOPL			
	work.nproc = ^uint32(0)
  0x41357a		c7058cea0a00ffffffff	MOVL $-0x1, runtime.work+144(SB)	
	work.nwait = ^uint32(0)
  0x413584		c70592ea0a00ffffffff	MOVL $-0x1, runtime.work+160(SB)	
	gcMarkRootPrepare()
  0x41358e		e89d2d0000		CALL runtime.gcMarkRootPrepare(SB)	
	gcMarkTinyAllocs()
  0x413593		e818620000		CALL runtime.gcMarkTinyAllocs(SB)	
	atomic.Store(&gcBlackenEnabled, 1)
  0x413598		b801000000		MOVL $0x1, AX				
  0x41359d		488d0d2c970c00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x4135a4		8701			XCHGL AX, 0(CX)				
	gcController.markStartTime = now
  0x4135a6		488b442430		MOVQ 0x30(SP), AX			
  0x4135ab		488905fe9b0c00		MOVQ AX, runtime.gcController+48(SB)	
	systemstack(func() {
  0x4135b2		0f57c0			XORPS X0, X0				
  0x4135b5		0f11442450		MOVUPS X0, 0x50(SP)			
  0x4135ba		488d05ef160300		LEAQ runtime.gcStart.func2(SB), AX	
  0x4135c1		4889442450		MOVQ AX, 0x50(SP)			
  0x4135c6		488d442430		LEAQ 0x30(SP), AX			
  0x4135cb		4889442458		MOVQ AX, 0x58(SP)			
  0x4135d0		488d442450		LEAQ 0x50(SP), AX			
  0x4135d5		48890424		MOVQ AX, 0(SP)				
  0x4135d9		e852410300		CALL runtime.systemstack(SB)		
	if mode != gcBackgroundMode {
  0x4135de		488b442438		MOVQ 0x38(SP), AX	
  0x4135e3		4885c0			TESTQ AX, AX		
	if mode != gcBackgroundMode {
  0x4135e6		7520			JNE 0x413608		
	semrelease(&work.startSema)
  0x4135e8		90			NOPL			
	semrelease1(addr, false)
  0x4135e9		488d0560ea0a00		LEAQ runtime.work+208(SB), AX	
  0x4135f0		48890424		MOVQ AX, 0(SP)			
  0x4135f4		c644240800		MOVB $0x0, 0x8(SP)		
  0x4135f9		e8e2f10100		CALL runtime.semrelease1(SB)	
  0x4135fe		488b6c2460		MOVQ 0x60(SP), BP		
  0x413603		4883c468		ADDQ $0x68, SP			
  0x413607		c3			RET				
		Gosched()
  0x413608		90			NOPL			
	checkTimeouts()
  0x413609		90			NOPL			
	mcall(gosched_m)
  0x41360a		488d0547020600		LEAQ 0x60247(IP), AX	
  0x413611		48890424		MOVQ AX, 0(SP)		
  0x413615		e896400300		CALL runtime.mcall(SB)	
	semrelease(&work.startSema)
  0x41361a		ebcc			JMP 0x4135e8		
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x41361c		0fb60d02980c00		MOVZX runtime.writeBarrier+5(SB), CX	
  0x413623		e94bffffff		JMP 0x413573				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x413628		83f902			CMPL $0x2, CX		
  0x41362b		0f94c1			SETE CL			
  0x41362e		e92dffffff		JMP 0x413560		
		schedEnableUser(false)
  0x413633		c6042400		MOVB $0x0, 0(SP)			
  0x413637		e834ca0100		CALL runtime.schedEnableUser(SB)	
	if mode != gcBackgroundMode {
  0x41363c		488b442438		MOVQ 0x38(SP), AX	
		schedEnableUser(false)
  0x413641		e9f7feffff		JMP 0x41353d		
		traceGCSTWStart(1)
  0x413646		90			NOPL			
	traceEvent(traceEvGCSTWStart, -1, uint64(kind))
  0x413647		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x413650		48c744244801000000	MOVQ $0x1, 0x48(SP)		
  0x413659		c6042409		MOVB $0x9, 0(SP)		
  0x41365d		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x413666		488d442448		LEAQ 0x48(SP), AX		
  0x41366b		4889442410		MOVQ AX, 0x10(SP)		
  0x413670		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x413679		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x413682		e819880200		CALL runtime.traceEvent(SB)	
	systemstack(stopTheWorldWithSema)
  0x413687		e95afeffff		JMP 0x4134e6		
		traceGCStart()
  0x41368c		90			NOPL			
	traceEvent(traceEvGCStart, 3, trace.seqGC)
  0x41368d		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x413696		488b0563950b00		MOVQ runtime.trace+64(SB), AX	
  0x41369d		4889442448		MOVQ AX, 0x48(SP)		
  0x4136a2		c6042407		MOVB $0x7, 0(SP)		
  0x4136a6		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4136af		488d442448		LEAQ 0x48(SP), AX		
  0x4136b4		4889442410		MOVQ AX, 0x10(SP)		
  0x4136b9		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x4136c2		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x4136cb		e8d0870200		CALL runtime.traceEvent(SB)	
	trace.seqGC++
  0x4136d0		48ff0529950b00		INCQ runtime.trace+64(SB)	
	for _, p := range allp {
  0x4136d7		e957fdffff		JMP 0x413433		
	} else if debug.gcstoptheworld == 2 {
  0x4136dc		83f802			CMPL $0x2, AX		
	work.mode = mode
  0x4136df		b800000000		MOVL $0x0, AX		
  0x4136e4		b902000000		MOVL $0x2, CX		
  0x4136e9		480f44c1		CMOVE CX, AX		
	} else if debug.gcstoptheworld == 2 {
  0x4136ed		e910fdffff		JMP 0x413402		
	work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle
  0x4136f2		4883f803		CMPQ $0x3, AX		
  0x4136f6		0f94c0			SETE AL			
  0x4136f9		e9eafcffff		JMP 0x4133e8		
		semrelease(&work.startSema)
  0x4136fe		90			NOPL			
	semrelease1(addr, false)
  0x4136ff		488d054ae90a00		LEAQ runtime.work+208(SB), AX	
  0x413706		48890424		MOVQ AX, 0(SP)			
  0x41370a		c644240800		MOVB $0x0, 0x8(SP)		
  0x41370f		e8ccf00100		CALL runtime.semrelease1(SB)	
		return
  0x413714		488b6c2460		MOVQ 0x60(SP), BP	
  0x413719		4883c468		ADDQ $0x68, SP		
  0x41371d		c3			RET			
	if t.kind == gcTriggerAlways {
  0x41371e		488b442470		MOVQ 0x70(SP), AX	
  0x413723		4885c0			TESTQ AX, AX		
  0x413726		750a			JNE 0x413732		
  0x413728		b801000000		MOVL $0x1, AX		
	if !trigger.test() {
  0x41372d		e99bfcffff		JMP 0x4133cd		
	if gcphase != _GCoff {
  0x413732		833da3950c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x413739		7407			JE 0x413742			
  0x41373b		31c0			XORL AX, AX			
	if !trigger.test() {
  0x41373d		e98bfcffff		JMP 0x4133cd		
	case gcTriggerHeap:
  0x413742		4883f801		CMPQ $0x1, AX		
  0x413746		7518			JNE 0x413760		
		return memstats.heap_live >= memstats.gc_trigger
  0x413748		488b0d49bc0c00		MOVQ runtime.memstats+5944(SB), CX	
  0x41374f		48390d4abc0c00		CMPQ CX, runtime.memstats+5952(SB)	
  0x413756		0f93c1			SETAE CL				
	if !trigger.test() {
  0x413759		89c8			MOVL CX, AX		
  0x41375b		e96dfcffff		JMP 0x4133cd		
	case gcTriggerTime:
  0x413760		4883f802		CMPQ $0x2, AX		
  0x413764		7539			JNE 0x41379f		
		if gcpercent < 0 {
  0x413766		833d6b950c0000		CMPL $0x0, runtime.gcpercent(SB)	
  0x41376d		7d07			JGE 0x413776				
  0x41376f		31c0			XORL AX, AX				
	if !trigger.test() {
  0x413771		e957fcffff		JMP 0x4133cd		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x413776		488b0d03bc0c00		MOVQ runtime.memstats+5920(SB), CX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x41377d		4885c9			TESTQ CX, CX				
  0x413780		7419			JE 0x41379b				
  0x413782		488b542478		MOVQ 0x78(SP), DX			
  0x413787		4829ca			SUBQ CX, DX				
  0x41378a		4839159fb80a00		CMPQ DX, runtime.forcegcperiod(SB)	
  0x413791		0f9cc1			SETL CL					
	if !trigger.test() {
  0x413794		89c8			MOVL CX, AX		
  0x413796		e932fcffff		JMP 0x4133cd		
  0x41379b		31c9			XORL CX, CX		
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x41379d		ebf5			JMP 0x413794		
	case gcTriggerCycle:
  0x41379f		4883f803		CMPQ $0x3, AX		
  0x4137a3		751b			JNE 0x4137c0		
		return int32(t.n-work.cycles) > 0
  0x4137a5		8b0d05e90a00		MOVL runtime.work+304(SB), CX	
  0x4137ab		8b942480000000		MOVL 0x80(SP), DX		
  0x4137b2		29ca			SUBL CX, DX			
  0x4137b4		85d2			TESTL DX, DX			
  0x4137b6		0f9fc1			SETG CL				
	if !trigger.test() {
  0x4137b9		89c8			MOVL CX, AX		
  0x4137bb		e90dfcffff		JMP 0x4133cd		
  0x4137c0		b801000000		MOVL $0x1, AX		
  0x4137c5		e903fcffff		JMP 0x4133cd		
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x4137ca		e8516a0000		CALL runtime.sweepone(SB)	
  0x4137cf		48833c24ff		CMPQ $-0x1, 0(SP)		
  0x4137d4		0f95c2			SETNE DL			
		return int32(t.n-work.cycles) > 0
  0x4137d7		8b842480000000		MOVL 0x80(SP), AX	
	if t.kind == gcTriggerAlways {
  0x4137de		488b4c2470		MOVQ 0x70(SP), CX	
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x4137e3		e9a9fbffff		JMP 0x413391		
	if t.kind == gcTriggerAlways {
  0x4137e8		4885c9			TESTQ CX, CX		
  0x4137eb		750a			JNE 0x4137f7		
  0x4137ed		ba01000000		MOVL $0x1, DX		
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x4137f2		e990fbffff		JMP 0x413387		
	if gcphase != _GCoff {
  0x4137f7		833dde940c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x4137fe		7407			JE 0x413807			
  0x413800		31d2			XORL DX, DX			
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x413802		e980fbffff		JMP 0x413387		
	case gcTriggerHeap:
  0x413807		4883f901		CMPQ $0x1, CX		
  0x41380b		7516			JNE 0x413823		
		return memstats.heap_live >= memstats.gc_trigger
  0x41380d		488b1d84bb0c00		MOVQ runtime.memstats+5944(SB), BX	
  0x413814		48391d85bb0c00		CMPQ BX, runtime.memstats+5952(SB)	
  0x41381b		0f93c2			SETAE DL				
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x41381e		e964fbffff		JMP 0x413387		
	case gcTriggerTime:
  0x413823		4883f902		CMPQ $0x2, CX		
  0x413827		7542			JNE 0x41386b		
		if gcpercent < 0 {
  0x413829		833da8940c0000		CMPL $0x0, runtime.gcpercent(SB)	
  0x413830		7d07			JGE 0x413839				
  0x413832		31d2			XORL DX, DX				
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x413834		e94efbffff		JMP 0x413387		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x413839		488b1540bb0c00		MOVQ runtime.memstats+5920(SB), DX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x413840		4885d2			TESTQ DX, DX				
  0x413843		741a			JE 0x41385f				
  0x413845		488b5c2478		MOVQ 0x78(SP), BX			
  0x41384a		4889de			MOVQ BX, SI				
  0x41384d		4829d3			SUBQ DX, BX				
  0x413850		48391dd9b70a00		CMPQ BX, runtime.forcegcperiod(SB)	
  0x413857		0f9cc2			SETL DL					
  0x41385a		e928fbffff		JMP 0x413387				
  0x41385f		488b742478		MOVQ 0x78(SP), SI			
  0x413864		31d2			XORL DX, DX				
  0x413866		e91cfbffff		JMP 0x413387				
	case gcTriggerCycle:
  0x41386b		4883f903		CMPQ $0x3, CX		
  0x41386f		7516			JNE 0x413887		
		return int32(t.n-work.cycles) > 0
  0x413871		8b1d39e80a00		MOVL runtime.work+304(SB), BX	
  0x413877		89c6			MOVL AX, SI			
  0x413879		29d8			SUBL BX, AX			
  0x41387b		85c0			TESTL AX, AX			
  0x41387d		0f9fc2			SETG DL				
  0x413880		89f0			MOVL SI, AX			
	for trigger.test() && sweepone() != ^uintptr(0) {
  0x413882		e900fbffff		JMP 0x413387		
  0x413887		ba01000000		MOVL $0x1, DX		
  0x41388c		e9f6faffff		JMP 0x413387		
		releasem(mp)
  0x413891		90			NOPL			
	mp.locks--
  0x413892		8b9108010000		MOVL 0x108(CX), DX	
  0x413898		8d5aff			LEAL -0x1(DX), BX	
  0x41389b		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x4138a1		83fa01			CMPL $0x1, DX		
  0x4138a4		7511			JNE 0x4138b7		
  0x4138a6		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x4138ad		7408			JE 0x4138b7		
		_g_.stackguard0 = stackPreempt
  0x4138af		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
		return
  0x4138b7		488b6c2460		MOVQ 0x60(SP), BP	
  0x4138bc		4883c468		ADDQ $0x68, SP		
  0x4138c0		c3			RET			
		if fg := atomic.Load(&p.mcache.flushGen); fg != mheap_.sweepgen {
  0x4138c1		89742428		MOVL SI, 0x28(SP)	
  0x4138c5		897c242c		MOVL DI, 0x2c(SP)	
			println("runtime: p", p.id, "flushGen", fg, "!= sweepgen", mheap_.sweepgen)
  0x4138c9		48634308		MOVSXD 0x8(BX), AX		
  0x4138cd		4889442440		MOVQ AX, 0x40(SP)		
  0x4138d2		e8e9050100		CALL runtime.printlock(SB)	
  0x4138d7		488d0577c00500		LEAQ 0x5c077(IP), AX		
  0x4138de		48890424		MOVQ AX, 0(SP)			
  0x4138e2		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x4138eb		e8000f0100		CALL runtime.printstring(SB)	
  0x4138f0		488b442440		MOVQ 0x40(SP), AX		
  0x4138f5		48890424		MOVQ AX, 0(SP)			
  0x4138f9		e8420d0100		CALL runtime.printint(SB)	
  0x4138fe		488d0503be0500		LEAQ 0x5be03(IP), AX		
  0x413905		48890424		MOVQ AX, 0(SP)			
  0x413909		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x413912		e8d90e0100		CALL runtime.printstring(SB)	
  0x413917		8b442428		MOVL 0x28(SP), AX		
  0x41391b		89c0			MOVL AX, AX			
  0x41391d		48890424		MOVQ AX, 0(SP)			
  0x413921		e81a0c0100		CALL runtime.printuint(SB)	
  0x413926		488d051cc20500		LEAQ 0x5c21c(IP), AX		
  0x41392d		48890424		MOVQ AX, 0(SP)			
  0x413931		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x41393a		e8b10e0100		CALL runtime.printstring(SB)	
  0x41393f		8b44242c		MOVL 0x2c(SP), AX		
  0x413943		48890424		MOVQ AX, 0(SP)			
  0x413947		e8f40b0100		CALL runtime.printuint(SB)	
  0x41394c		e8ff070100		CALL runtime.printnl(SB)	
  0x413951		e8ea050100		CALL runtime.printunlock(SB)	
			throw("p mcache not flushed")
  0x413956		488d058ccd0500		LEAQ 0x5cd8c(IP), AX	
  0x41395d		48890424		MOVQ AX, 0(SP)		
  0x413961		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41396a		e811fb0000		CALL runtime.throw(SB)	
  0x41396f		0f0b			UD2			
func gcStart(trigger gcTrigger) {
  0x413971		e80a3f0300		CALL runtime.morestack_noctxt(SB)	
  0x413976		e955f9ffff		JMP runtime.gcStart(SB)			

TEXT runtime.gcMarkDone(SB) /usr/local/go/src/runtime/mgc.go
func gcMarkDone() {
  0x413980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413989		483b6110		CMPQ 0x10(CX), SP	
  0x41398d		0f868e020000		JBE 0x413c21		
  0x413993		4883ec50		SUBQ $0x50, SP		
  0x413997		48896c2448		MOVQ BP, 0x48(SP)	
  0x41399c		488d6c2448		LEAQ 0x48(SP), BP	
	semacquire(&work.markDoneSema)
  0x4139a1		90			NOPL				
  0x4139a2		488d05abe60a00		LEAQ runtime.work+212(SB), AX	
	semacquire1(addr, false, 0)
  0x4139a9		48890424		MOVQ AX, 0(SP)			
  0x4139ad		c644240800		MOVB $0x0, 0x8(SP)		
  0x4139b2		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4139bb		e850eb0100		CALL runtime.semacquire1(SB)	
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x4139c0		eb10			JMP 0x4139d2		
			systemstack(func() {
  0x4139c2		488d054ffe0500		LEAQ 0x5fe4f(IP), AX		
  0x4139c9		48890424		MOVQ AX, 0(SP)			
  0x4139cd		e85e3d0300		CALL runtime.systemstack(SB)	
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x4139d2		833d03930c0001		CMPL $0x1, runtime.gcphase(SB)	
  0x4139d9		0f853b020000		JNE 0x413c1a			
  0x4139df		8b052be60a00		MOVL runtime.work+144(SB), AX	
  0x4139e5		390535e60a00		CMPL AX, runtime.work+160(SB)	
  0x4139eb		0f8522020000		JNE 0x413c13			
  0x4139f1		90			NOPL				
	if !work.full.empty() {
  0x4139f2		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x4139f3		488b0586e50a00		MOVQ runtime.work(SB), AX	
  0x4139fa		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x4139fd		0f8506020000		JNE 0x413c09		
	if work.markrootNext < work.markrootJobs {
  0x413a03		8b0503e60a00		MOVL runtime.work+140(SB), AX	
  0x413a09		3905f9e50a00		CMPL AX, runtime.work+136(SB)	
  0x413a0f		0f83ed010000		JAE 0x413c02			
  0x413a15		b801000000		MOVL $0x1, AX			
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x413a1a		83f001			XORL $0x1, AX		
  0x413a1d		84c0			TESTL AL, AL		
  0x413a1f		0f84bd010000		JE 0x413be2		
	gcMarkDoneFlushed = 0
  0x413a25		c705a5920c0000000000	MOVL $0x0, runtime.gcMarkDoneFlushed(SB)	
	systemstack(func() {
  0x413a2f		488d05dafd0500		LEAQ 0x5fdda(IP), AX		
  0x413a36		48890424		MOVQ AX, 0(SP)			
  0x413a3a		e8f13c0300		CALL runtime.systemstack(SB)	
	if gcMarkDoneFlushed != 0 {
  0x413a3f		833d8e920c0000		CMPL $0x0, runtime.gcMarkDoneFlushed(SB)	
  0x413a46		758a			JNE 0x4139d2					
	now := nanotime()
  0x413a48		e863760300		CALL runtime.nanotime(SB)	
  0x413a4d		488b0424		MOVQ 0(SP), AX			
	work.tMarkTerm = now
  0x413a51		48890578e60a00		MOVQ AX, runtime.work+336(SB)	
	work.pauseStart = now
  0x413a58		48890589e60a00		MOVQ AX, runtime.work+360(SB)	
	getg().m.preemptoff = "gcing"
  0x413a5f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x413a68		488b4030		MOVQ 0x30(AX), AX			
  0x413a6c		48c7800001000005000000	MOVQ $0x5, 0x100(AX)			
  0x413a77		833da2930c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x413a7e		0f8546010000		JNE 0x413bca				
  0x413a84		488d0d71b70500		LEAQ 0x5b771(IP), CX			
  0x413a8b		488988f8000000		MOVQ CX, 0xf8(AX)			
	if trace.enabled {
  0x413a92		803d37910b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x413a99		0f85e5000000		JNE 0x413b84			
	systemstack(stopTheWorldWithSema)
  0x413a9f		488d05eafe0500		LEAQ 0x5feea(IP), AX		
  0x413aa6		48890424		MOVQ AX, 0(SP)			
  0x413aaa		e8813c0300		CALL runtime.systemstack(SB)	
		restart := false
  0x413aaf		c644242f00		MOVB $0x0, 0x2f(SP)	
		systemstack(func() {
  0x413ab4		0f57c0			XORPS X0, X0				
  0x413ab7		0f11442438		MOVUPS X0, 0x38(SP)			
  0x413abc		488d056d130300		LEAQ runtime.gcMarkDone.func2(SB), AX	
  0x413ac3		4889442438		MOVQ AX, 0x38(SP)			
  0x413ac8		488d4c242f		LEAQ 0x2f(SP), CX			
  0x413acd		48894c2440		MOVQ CX, 0x40(SP)			
  0x413ad2		488d4c2438		LEAQ 0x38(SP), CX			
  0x413ad7		48890c24		MOVQ CX, 0(SP)				
  0x413adb		e8503c0300		CALL runtime.systemstack(SB)		
		if restart {
  0x413ae0		807c242f00		CMPB $0x0, 0x2f(SP)	
  0x413ae5		7444			JE 0x413b2b		
			getg().m.preemptoff = ""
  0x413ae7		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x413af0		488b4930		MOVQ 0x30(CX), CX			
  0x413af4		48c7810001000000000000	MOVQ $0x0, 0x100(CX)			
  0x413aff		833d1a930c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x413b06		7510			JNE 0x413b18				
  0x413b08		48c781f800000000000000	MOVQ $0x0, 0xf8(CX)			
  0x413b13		e9aafeffff		JMP 0x4139c2				
  0x413b18		488db9f8000000		LEAQ 0xf8(CX), DI			
  0x413b1f		31c0			XORL AX, AX				
  0x413b21		e85a5b0300		CALL runtime.gcWriteBarrier(SB)		
  0x413b26		e997feffff		JMP 0x4139c2				
	atomic.Store(&gcBlackenEnabled, 0)
  0x413b2b		31c0			XORL AX, AX				
  0x413b2d		488d0d9c910c00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x413b34		8701			XCHGL AX, 0(CX)				
	gcWakeAllAssists()
  0x413b36		e845390000		CALL runtime.gcWakeAllAssists(SB)	
	semrelease(&work.markDoneSema)
  0x413b3b		90			NOPL			
	semrelease1(addr, false)
  0x413b3c		488d0511e50a00		LEAQ runtime.work+212(SB), AX	
  0x413b43		48890424		MOVQ AX, 0(SP)			
  0x413b47		c644240800		MOVB $0x0, 0x8(SP)		
  0x413b4c		e88fec0100		CALL runtime.semrelease1(SB)	
	schedEnableUser(true)
  0x413b51		c6042401		MOVB $0x1, 0(SP)			
  0x413b55		e816c50100		CALL runtime.schedEnableUser(SB)	
	nextTriggerRatio := gcController.endCycle()
  0x413b5a		488d051f960c00		LEAQ runtime.gcController(SB), AX		
  0x413b61		48890424		MOVQ AX, 0(SP)					
  0x413b65		e836e9ffff		CALL runtime.(*gcControllerState).endCycle(SB)	
  0x413b6a		f20f10442408		MOVSD_XMM 0x8(SP), X0				
	gcMarkTermination(nextTriggerRatio)
  0x413b70		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x413b75		e8b6000000		CALL runtime.gcMarkTermination(SB)	
}
  0x413b7a		488b6c2448		MOVQ 0x48(SP), BP	
  0x413b7f		4883c450		ADDQ $0x50, SP		
  0x413b83		c3			RET			
		traceGCSTWStart(0)
  0x413b84		90			NOPL			
	traceEvent(traceEvGCSTWStart, -1, uint64(kind))
  0x413b85		48c744243000000000	MOVQ $0x0, 0x30(SP)		
  0x413b8e		48c744243000000000	MOVQ $0x0, 0x30(SP)		
  0x413b97		c6042409		MOVB $0x9, 0(SP)		
  0x413b9b		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x413ba4		488d442430		LEAQ 0x30(SP), AX		
  0x413ba9		4889442410		MOVQ AX, 0x10(SP)		
  0x413bae		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x413bb7		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x413bc0		e8db820200		CALL runtime.traceEvent(SB)	
	systemstack(stopTheWorldWithSema)
  0x413bc5		e9d5feffff		JMP 0x413a9f		
	getg().m.preemptoff = "gcing"
  0x413bca		488db8f8000000		LEAQ 0xf8(AX), DI		
  0x413bd1		488d0524b60500		LEAQ 0x5b624(IP), AX		
  0x413bd8		e8a35a0300		CALL runtime.gcWriteBarrier(SB)	
  0x413bdd		e9b0feffff		JMP 0x413a92			
		semrelease(&work.markDoneSema)
  0x413be2		90			NOPL			
	semrelease1(addr, false)
  0x413be3		488d056ae40a00		LEAQ runtime.work+212(SB), AX	
  0x413bea		48890424		MOVQ AX, 0(SP)			
  0x413bee		c644240800		MOVB $0x0, 0x8(SP)		
  0x413bf3		e8e8eb0100		CALL runtime.semrelease1(SB)	
		return
  0x413bf8		488b6c2448		MOVQ 0x48(SP), BP	
  0x413bfd		4883c450		ADDQ $0x50, SP		
  0x413c01		c3			RET			
  0x413c02		31c0			XORL AX, AX		
	if !(gcphase == _GCmark && work.nwait == work.nproc && !gcMarkWorkAvailable(nil)) {
  0x413c04		e911feffff		JMP 0x413a1a		
  0x413c09		b801000000		MOVL $0x1, AX		
  0x413c0e		e907feffff		JMP 0x413a1a		
  0x413c13		31c0			XORL AX, AX		
  0x413c15		e903feffff		JMP 0x413a1d		
  0x413c1a		31c0			XORL AX, AX		
  0x413c1c		e9fcfdffff		JMP 0x413a1d		
func gcMarkDone() {
  0x413c21		e85a3c0300		CALL runtime.morestack_noctxt(SB)	
  0x413c26		e955fdffff		JMP runtime.gcMarkDone(SB)		

TEXT runtime.gcMarkTermination(SB) /usr/local/go/src/runtime/mgc.go
func gcMarkTermination(nextTriggerRatio float64) {
  0x413c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x413c39		488d8424c8feffff	LEAQ 0xfffffec8(SP), AX	
  0x413c41		483b4110		CMPQ 0x10(CX), AX	
  0x413c45		0f86f90a0000		JBE 0x414744		
  0x413c4b		4881ecb8010000		SUBQ $0x1b8, SP		
  0x413c52		4889ac24b0010000	MOVQ BP, 0x1b0(SP)	
  0x413c5a		488dac24b0010000	LEAQ 0x1b0(SP), BP	
	atomic.Store(&gcBlackenEnabled, 0)
  0x413c62		31c0			XORL AX, AX				
  0x413c64		488d0d65900c00		LEAQ runtime.gcBlackenEnabled(SB), CX	
  0x413c6b		8701			XCHGL AX, 0(CX)				
	setGCPhase(_GCmarktermination)
  0x413c6d		90			NOPL			
	atomic.Store(&gcphase, x)
  0x413c6e		b802000000		MOVL $0x2, AX			
  0x413c73		488d0d62900c00		LEAQ runtime.gcphase(SB), CX	
  0x413c7a		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x413c7c		8b055a900c00		MOVL runtime.gcphase(SB), AX		
  0x413c82		83f801			CMPL $0x1, AX				
  0x413c85		0f85930a0000		JNE 0x41471e				
  0x413c8b		b801000000		MOVL $0x1, AX				
  0x413c90		88058e910c00		MOVB AL, runtime.writeBarrier+4(SB)	
  0x413c96		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x413c98		0f84740a0000		JE 0x414712				
  0x413c9e		b801000000		MOVL $0x1, AX				
  0x413ca3		880577910c00		MOVB AL, runtime.writeBarrier(SB)	
	work.heap1 = memstats.heap_live
  0x413ca9		488b05f0b60c00		MOVQ runtime.memstats+5952(SB), AX	
  0x413cb0		48890541e40a00		MOVQ AX, runtime.work+376(SB)		
	startTime := nanotime()
  0x413cb7		e8f4730300		CALL runtime.nanotime(SB)	
	_g_ := getg()
  0x413cbc		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x413cc5		488b4830		MOVQ 0x30(AX), CX	
	startTime := nanotime()
  0x413cc9		488b1424		MOVQ 0(SP), DX		
  0x413ccd		4889542448		MOVQ DX, 0x48(SP)	
	mp := acquirem()
  0x413cd2		90			NOPL			
	_g_.m.locks++
  0x413cd3		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x413cd9		488b4830		MOVQ 0x30(AX), CX	
  0x413cdd		48898c2488010000	MOVQ CX, 0x188(SP)	
  0x413ce5		8400			TESTB AL, 0(AX)		
	mp.preemptoff = "gcing"
  0x413ce7		48c7810001000005000000	MOVQ $0x5, 0x100(CX)			
  0x413cf2		488db9f8000000		LEAQ 0xf8(CX), DI			
  0x413cf9		4889bc24a8010000	MOVQ DI, 0x1a8(SP)			
  0x413d01		833d18910c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x413d08		0f85f3090000		JNE 0x414701				
  0x413d0e		488d05e7b40500		LEAQ 0x5b4e7(IP), AX			
  0x413d15		488981f8000000		MOVQ AX, 0xf8(CX)			
	_g_ := getg()
  0x413d1c		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x413d25		4889842498010000	MOVQ AX, 0x198(SP)	
	_g_.m.traceback = 2
  0x413d2d		488b4830		MOVQ 0x30(AX), CX	
  0x413d31		c6812901000002		MOVB $0x2, 0x129(CX)	
	gp := _g_.m.curg
  0x413d38		488b4830		MOVQ 0x30(AX), CX	
  0x413d3c		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x413d43		48898c2490010000	MOVQ CX, 0x190(SP)	
	casgstatus(gp, _Grunning, _Gwaiting)
  0x413d4b		48890c24		MOVQ CX, 0(SP)			
  0x413d4f		48ba0200000004000000	MOVQ $0x400000002, DX		
  0x413d59		4889542408		MOVQ DX, 0x8(SP)		
  0x413d5e		e83d2f0100		CALL runtime.casgstatus(SB)	
	gp.waitreason = waitReasonGarbageCollection
  0x413d63		488b842490010000	MOVQ 0x190(SP), AX	
  0x413d6b		c680b000000006		MOVB $0x6, 0xb0(AX)	
	systemstack(func() {
  0x413d72		0f57c0			XORPS X0, X0					
  0x413d75		0f118424c0000000	MOVUPS X0, 0xc0(SP)				
  0x413d7d		488d0dcc110300		LEAQ runtime.gcMarkTermination.func1(SB), CX	
  0x413d84		48898c24c0000000	MOVQ CX, 0xc0(SP)				
  0x413d8c		488b4c2448		MOVQ 0x48(SP), CX				
  0x413d91		48898c24c8000000	MOVQ CX, 0xc8(SP)				
  0x413d99		488d8c24c0000000	LEAQ 0xc0(SP), CX				
  0x413da1		48890c24		MOVQ CX, 0(SP)					
  0x413da5		e886390300		CALL runtime.systemstack(SB)			
	systemstack(func() {
  0x413daa		488d056ffa0500		LEAQ 0x5fa6f(IP), AX		
  0x413db1		48890424		MOVQ AX, 0(SP)			
  0x413db5		e876390300		CALL runtime.systemstack(SB)	
	_g_.m.traceback = 0
  0x413dba		488b842498010000	MOVQ 0x198(SP), AX	
  0x413dc2		488b4030		MOVQ 0x30(AX), AX	
  0x413dc6		c6802901000000		MOVB $0x0, 0x129(AX)	
	casgstatus(gp, _Gwaiting, _Grunning)
  0x413dcd		488b842490010000	MOVQ 0x190(SP), AX		
  0x413dd5		48890424		MOVQ AX, 0(SP)			
  0x413dd9		48b80400000002000000	MOVQ $0x200000004, AX		
  0x413de3		4889442408		MOVQ AX, 0x8(SP)		
  0x413de8		e8b32e0100		CALL runtime.casgstatus(SB)	
	if trace.enabled {
  0x413ded		803ddc8d0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x413df4		0f85de080000		JNE 0x4146d8			
	mp.preemptoff = ""
  0x413dfa		488b8c2488010000	MOVQ 0x188(SP), CX			
  0x413e02		48c7810001000000000000	MOVQ $0x0, 0x100(CX)			
  0x413e0d		833d0c900c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x413e14		0f85aa080000		JNE 0x4146c4				
  0x413e1a		48c781f800000000000000	MOVQ $0x0, 0xf8(CX)			
	if gcphase != _GCoff {
  0x413e25		833db08e0c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x413e2c		0f85f7080000		JNE 0x414729			
	gcSetTriggerRatio(nextTriggerRatio)
  0x413e32		f20f108424c0010000	MOVSD_XMM 0x1c0(SP), X0			
  0x413e3b		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x413e40		e8cbefffff		CALL runtime.gcSetTriggerRatio(SB)	
	now := nanotime()
  0x413e45		e866720300		CALL runtime.nanotime(SB)	
  0x413e4a		488b0424		MOVQ 0(SP), AX			
  0x413e4e		4889442468		MOVQ AX, 0x68(SP)		
	sec, nsec, _ := time_now()
  0x413e53		e8187e0200		CALL time.now(SB)	
  0x413e58		488b0424		MOVQ 0(SP), AX		
  0x413e5c		48634c2408		MOVSXD 0x8(SP), CX	
	work.pauseNS += now - work.pauseStart
  0x413e61		488b1580e20a00		MOVQ runtime.work+360(SB), DX	
  0x413e68		488b5c2468		MOVQ 0x68(SP), BX		
  0x413e6d		4889de			MOVQ BX, SI			
  0x413e70		4829d3			SUBQ DX, BX			
  0x413e73		48011d66e20a00		ADDQ BX, runtime.work+352(SB)	
	work.tEnd = now
  0x413e7a		48893557e20a00		MOVQ SI, runtime.work+344(SB)	
	unixNow := sec*1e9 + int64(nsec)
  0x413e81		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	
  0x413e88		4801c8			ADDQ CX, AX			
	atomic.Store64(&memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user
  0x413e8b		488d0d7e9e0c00		LEAQ runtime.memstats+176(SB), CX	
  0x413e92		4889c2			MOVQ AX, DX				
  0x413e95		488701			XCHGQ AX, 0(CX)				
	atomic.Store64(&memstats.last_gc_nanotime, uint64(now)) // monotonic time for us
  0x413e98		488d05e1b40c00		LEAQ runtime.memstats+5920(SB), AX	
  0x413e9f		4889f1			MOVQ SI, CX				
  0x413ea2		488730			XCHGQ SI, 0(AX)				
	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)
  0x413ea5		0fb60574ae0c00		MOVZX runtime.memstats+4288(SB), AX	
  0x413eac		488b1d2de20a00		MOVQ runtime.work+352(SB), BX		
  0x413eb3		488d35669e0c00		LEAQ runtime.memstats+192(SB), SI	
  0x413eba		48891cc6		MOVQ BX, 0(SI)(AX*8)			
	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)
  0x413ebe		0fb6055bae0c00		MOVZX runtime.memstats+4288(SB), AX	
  0x413ec5		488d1d54a60c00		LEAQ runtime.memstats+2240(SB), BX	
  0x413ecc		488914c3		MOVQ DX, 0(BX)(AX*8)			
	memstats.pause_total_ns += uint64(work.pauseNS)
  0x413ed0		488b05419e0c00		MOVQ runtime.memstats+184(SB), AX	
  0x413ed7		48030502e20a00		ADDQ runtime.work+352(SB), AX		
  0x413ede		488905339e0c00		MOVQ AX, runtime.memstats+184(SB)	
	sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)
  0x413ee5		486305c8e10a00		MOVSXD runtime.work+308(SB), AX	
  0x413eec		488b15d5e10a00		MOVQ runtime.work+328(SB), DX	
  0x413ef3		482b15c6e10a00		SUBQ runtime.work+320(SB), DX	
  0x413efa		480fafd0		IMULQ AX, DX			
  0x413efe		4889542440		MOVQ DX, 0x40(SP)		
	markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime
  0x413f03		488b1d8e920c00		MOVQ runtime.gcController+24(SB), BX	
  0x413f0a		48031d7f920c00		ADDQ runtime.gcController+16(SB), BX	
  0x413f11		48031d88920c00		ADDQ runtime.gcController+32(SB), BX	
	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)
  0x413f18		488b35b9e10a00		MOVQ runtime.work+344(SB), SI	
  0x413f1f		482b35aae10a00		SUBQ runtime.work+336(SB), SI	
  0x413f26		480fafc6		IMULQ SI, AX			
  0x413f2a		4889442470		MOVQ AX, 0x70(SP)		
	cycleCpu := sweepTermCpu + markCpu + markTermCpu
  0x413f2f		4801d3			ADDQ DX, BX		
  0x413f32		4801c3			ADDQ AX, BX		
	work.totaltime += cycleCpu
  0x413f35		48031d3ce10a00		ADDQ runtime.work+248(SB), BX	
  0x413f3c		48891d35e10a00		MOVQ BX, runtime.work+248(SB)	
	totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)
  0x413f43		488b358ede0a00		MOVQ runtime.sched+312(SB), SI		
  0x413f4a		4829f1			SUBQ SI, CX				
  0x413f4d		4863358c8d0c00		MOVSXD runtime.gomaxprocs(SB), SI	
  0x413f54		480faff1		IMULQ CX, SI				
  0x413f58		48033581de0a00		ADDQ runtime.sched+320(SB), SI		
	memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)
  0x413f5f		0f57c0			XORPS X0, X0				
  0x413f62		f2480f2ac3		CVTSI2SDQ BX, X0			
  0x413f67		0f57c9			XORPS X1, X1				
  0x413f6a		f2480f2ace		CVTSI2SDQ SI, X1			
  0x413f6f		f20f5ec1		DIVSD X1, X0				
  0x413f73		f20f1105adad0c00	MOVSD_XMM X0, runtime.memstats+4296(SB)	
	sweep.npausesweep = 0
  0x413f7b		48c705eedb0a0000000000	MOVQ $0x0, runtime.sweep+20(SB)	
	if work.userForced {
  0x413f86		803de3e00a0000		CMPB $0x0, runtime.work+240(SB)	
  0x413f8d		7406			JE 0x413f95			
		memstats.numforcedgc++
  0x413f8f		ff058fad0c00		INCL runtime.memstats+4292(SB)	
	lock(&work.sweepWaiters.lock)
  0x413f95		488d0504e10a00		LEAQ runtime.work+288(SB), AX	
  0x413f9c		48890424		MOVQ AX, 0(SP)			
  0x413fa0		e83b47ffff		CALL runtime.lock(SB)		
	memstats.numgc++
  0x413fa5		ff0575ad0c00		INCL runtime.memstats+4288(SB)	
	injectglist(&work.sweepWaiters.list)
  0x413fab		488d05f6e00a00		LEAQ runtime.work+296(SB), AX	
  0x413fb2		48890424		MOVQ AX, 0(SP)			
  0x413fb6		e8b5680100		CALL runtime.injectglist(SB)	
	unlock(&work.sweepWaiters.lock)
  0x413fbb		488d05dee00a00		LEAQ runtime.work+288(SB), AX	
  0x413fc2		48890424		MOVQ AX, 0(SP)			
  0x413fc6		e8c548ffff		CALL runtime.unlock(SB)		
	mProf_NextCycle()
  0x413fcb		e820bb0000		CALL runtime.mProf_NextCycle(SB)	
	systemstack(func() { startTheWorldWithSema(true) })
  0x413fd0		488d0551f80500		LEAQ 0x5f851(IP), AX		
  0x413fd7		48890424		MOVQ AX, 0(SP)			
  0x413fdb		e850370300		CALL runtime.systemstack(SB)	
	mProf_Flush()
  0x413fe0		e88bbb0000		CALL runtime.mProf_Flush(SB)	
	prepareFreeWorkbufs()
  0x413fe5		e816800000		CALL runtime.prepareFreeWorkbufs(SB)	
	systemstack(freeStackSpans)
  0x413fea		488d05fff70500		LEAQ 0x5f7ff(IP), AX		
  0x413ff1		48890424		MOVQ AX, 0(SP)			
  0x413ff5		e836370300		CALL runtime.systemstack(SB)	
	systemstack(func() {
  0x413ffa		488d0537f80500		LEAQ 0x5f837(IP), AX		
  0x414001		48890424		MOVQ AX, 0(SP)			
  0x414005		e826370300		CALL runtime.systemstack(SB)	
	if debug.gctrace > 0 {
  0x41400a		833def8e0c0000		CMPL $0x0, runtime.debug+32(SB)	
  0x414011		0f8e28060000		JLE 0x41463f			
		util := int(memstats.gc_cpu_fraction * 100)
  0x414017		f20f1005d18c0600	MOVSD_XMM $f64.4059000000000000(SB), X0	
  0x41401f		f20f590501ad0c00	MULSD runtime.memstats+4296(SB), X0	
  0x414027		f20f118424b8000000	MOVSD_XMM X0, 0xb8(SP)			
		var sbuf [24]byte
  0x414030		48c78424d000000000000000	MOVQ $0x0, 0xd0(SP)	
  0x41403c		0f57c9				XORPS X1, X1		
  0x41403f		0f118c24d8000000		MOVUPS X1, 0xd8(SP)	
		printlock()
  0x414047		e874fe0000		CALL runtime.printlock(SB)	
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
  0x41404c		488b056de00a00		MOVQ runtime.work+320(SB), AX		
  0x414053		482b056e8d0c00		SUBQ runtime.runtimeInitTime(SB), AX	
  0x41405a		488d8c24d0000000	LEAQ 0xd0(SP), CX			
  0x414062		48890c24		MOVQ CX, 0(SP)				
  0x414066		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x41406f		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x414078		4889c2			MOVQ AX, DX				
  0x41407b		48b8b6696caf05bd3786	MOVQ $0x8637bd05af6c69b6, AX		
  0x414085		48f7e2			MULQ DX					
  0x414088		48c1ea13		SHRQ $0x13, DX				
  0x41408c		4889542418		MOVQ DX, 0x18(SP)			
  0x414091		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x41409a		e861160000		CALL runtime.itoaDiv(SB)		
		print("gc ", memstats.numgc,
  0x41409f		8b057bac0c00		MOVL runtime.memstats+4288(SB), AX	
  0x4140a5		48898424b0000000	MOVQ AX, 0xb0(SP)			
			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",
  0x4140ad		488b4c2430		MOVQ 0x30(SP), CX			
  0x4140b2		488b542428		MOVQ 0x28(SP), DX			
  0x4140b7		488b5c2438		MOVQ 0x38(SP), BX			
  0x4140bc		488db42440010000	LEAQ 0x140(SP), SI			
  0x4140c4		48893424		MOVQ SI, 0(SP)				
  0x4140c8		4889542408		MOVQ DX, 0x8(SP)			
  0x4140cd		48894c2410		MOVQ CX, 0x10(SP)			
  0x4140d2		48895c2418		MOVQ BX, 0x18(SP)			
  0x4140d7		e8f4590200		CALL runtime.slicebytetostring(SB)	
  0x4140dc		488b442428		MOVQ 0x28(SP), AX			
  0x4140e1		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x4140e9		488b4c2420		MOVQ 0x20(SP), CX			
  0x4140ee		48898c24a0010000	MOVQ CX, 0x1a0(SP)			
		print("gc ", memstats.numgc,
  0x4140f6		e8c5fd0000		CALL runtime.printlock(SB)	
  0x4140fb		488d05e4af0500		LEAQ 0x5afe4(IP), AX		
  0x414102		48890424		MOVQ AX, 0(SP)			
  0x414106		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x41410f		e8dc060100		CALL runtime.printstring(SB)	
  0x414114		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x41411c		48890424		MOVQ AX, 0(SP)			
  0x414120		e81b040100		CALL runtime.printuint(SB)	
  0x414125		488d0566af0500		LEAQ 0x5af66(IP), AX		
  0x41412c		48890424		MOVQ AX, 0(SP)			
  0x414130		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x414139		e8b2060100		CALL runtime.printstring(SB)	
  0x41413e		488b8424a0010000	MOVQ 0x1a0(SP), AX		
  0x414146		48890424		MOVQ AX, 0(SP)			
  0x41414a		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x414152		4889442408		MOVQ AX, 0x8(SP)		
  0x414157		e894060100		CALL runtime.printstring(SB)	
  0x41415c		488d0549af0500		LEAQ 0x5af49(IP), AX		
  0x414163		48890424		MOVQ AX, 0(SP)			
  0x414167		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x414170		e87b060100		CALL runtime.printstring(SB)	
		util := int(memstats.gc_cpu_fraction * 100)
  0x414175		f20f108424b8000000	MOVSD_XMM 0xb8(SP), X0	
  0x41417e		f2480f2cc0		CVTTSD2SIQ X0, AX	
		print("gc ", memstats.numgc,
  0x414183		48890424		MOVQ AX, 0(SP)			
  0x414187		e8b4040100		CALL runtime.printint(SB)	
  0x41418c		488d0535af0500		LEAQ 0x5af35(IP), AX		
  0x414193		48890424		MOVQ AX, 0(SP)			
  0x414197		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4141a0		e84b060100		CALL runtime.printstring(SB)	
  0x4141a5		e896fd0000		CALL runtime.printunlock(SB)	
		prev := work.tSweepTerm
  0x4141aa		488b050fdf0a00		MOVQ runtime.work+320(SB), AX	
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
  0x4141b1		48c78424e800000000000000	MOVQ $0x0, 0xe8(SP)		
  0x4141bd		0f57c0				XORPS X0, X0			
  0x4141c0		0f118424f0000000		MOVUPS X0, 0xf0(SP)		
  0x4141c8		488b0df9de0a00			MOVQ runtime.work+328(SB), CX	
  0x4141cf		48898c24e8000000		MOVQ CX, 0xe8(SP)		
  0x4141d7		488b0df2de0a00			MOVQ runtime.work+336(SB), CX	
  0x4141de		48898c24f0000000		MOVQ CX, 0xf0(SP)		
  0x4141e6		488b0debde0a00			MOVQ runtime.work+344(SB), CX	
  0x4141ed		48898c24f8000000		MOVQ CX, 0xf8(SP)		
  0x4141f5		31c9				XORL CX, CX			
  0x4141f7		e9ad000000			JMP 0x4142a9			
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
  0x4141fc		488d8c24d0000000	LEAQ 0xd0(SP), CX			
  0x414204		48890c24		MOVQ CX, 0(SP)				
  0x414208		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x414211		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x41421a		4829c2			SUBQ AX, DX				
  0x41421d		4889542418		MOVQ DX, 0x18(SP)			
  0x414222		e8b9150000		CALL runtime.fmtNSAsMS(SB)		
  0x414227		488b442430		MOVQ 0x30(SP), AX			
  0x41422c		488b4c2420		MOVQ 0x20(SP), CX			
  0x414231		488b542428		MOVQ 0x28(SP), DX			
  0x414236		488d9c2420010000	LEAQ 0x120(SP), BX			
  0x41423e		48891c24		MOVQ BX, 0(SP)				
  0x414242		48894c2408		MOVQ CX, 0x8(SP)			
  0x414247		4889542410		MOVQ DX, 0x10(SP)			
  0x41424c		4889442418		MOVQ AX, 0x18(SP)			
  0x414251		e87a580200		CALL runtime.slicebytetostring(SB)	
  0x414256		488b442420		MOVQ 0x20(SP), AX			
  0x41425b		48898424a0010000	MOVQ AX, 0x1a0(SP)			
  0x414263		488b4c2428		MOVQ 0x28(SP), CX			
  0x414268		48898c24a8000000	MOVQ CX, 0xa8(SP)			
  0x414270		e84bfc0000		CALL runtime.printlock(SB)		
  0x414275		488b8424a0010000	MOVQ 0x1a0(SP), AX			
  0x41427d		48890424		MOVQ AX, 0(SP)				
  0x414281		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x414289		4889442408		MOVQ AX, 0x8(SP)			
  0x41428e		e85d050100		CALL runtime.printstring(SB)		
  0x414293		e8a8fc0000		CALL runtime.printunlock(SB)		
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
  0x414298		488b442478		MOVQ 0x78(SP), AX	
  0x41429d		488d4801		LEAQ 0x1(AX), CX	
	systemstack(func() {
  0x4142a1		0f57c0			XORPS X0, X0		
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
  0x4142a4		488b442458		MOVQ 0x58(SP), AX	
		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {
  0x4142a9		4883f903		CMPQ $0x3, CX		
  0x4142ad		7d52			JGE 0x414301		
  0x4142af		48894c2478		MOVQ CX, 0x78(SP)	
  0x4142b4		488b94cce8000000	MOVQ 0xe8(SP)(CX*8), DX	
  0x4142bc		4889542458		MOVQ DX, 0x58(SP)	
			if i != 0 {
  0x4142c1		4885c9			TESTQ CX, CX		
  0x4142c4		0f8432ffffff		JE 0x4141fc		
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
  0x4142ca		4889442450		MOVQ AX, 0x50(SP)	
				print("+")
  0x4142cf		e8ecfb0000		CALL runtime.printlock(SB)	
  0x4142d4		488d05a8ad0500		LEAQ 0x5ada8(IP), AX		
  0x4142db		48890424		MOVQ AX, 0(SP)			
  0x4142df		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4142e8		e803050100		CALL runtime.printstring(SB)	
  0x4142ed		e84efc0000		CALL runtime.printunlock(SB)	
			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))
  0x4142f2		488b442450		MOVQ 0x50(SP), AX	
  0x4142f7		488b542458		MOVQ 0x58(SP), DX	
				print("+")
  0x4142fc		e9fbfeffff		JMP 0x4141fc		
		print(" ms clock, ")
  0x414301		e8bafb0000		CALL runtime.printlock(SB)	
  0x414306		488d056cb50500		LEAQ 0x5b56c(IP), AX		
  0x41430d		48890424		MOVQ AX, 0(SP)			
  0x414311		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x41431a		e8d1040100		CALL runtime.printstring(SB)	
  0x41431f		e81cfc0000		CALL runtime.printunlock(SB)	
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
  0x414324		48c784246001000000000000	MOVQ $0x0, 0x160(SP)			
  0x414330		0f57c0				XORPS X0, X0				
  0x414333		0f11842468010000		MOVUPS X0, 0x168(SP)			
  0x41433b		0f11842478010000		MOVUPS X0, 0x178(SP)			
  0x414343		488b442440			MOVQ 0x40(SP), AX			
  0x414348		4889842460010000		MOVQ AX, 0x160(SP)			
  0x414350		488b05398e0c00			MOVQ runtime.gcController+16(SB), AX	
  0x414357		4889842468010000		MOVQ AX, 0x168(SP)			
  0x41435f		488b053a8e0c00			MOVQ runtime.gcController+32(SB), AX	
  0x414366		4803052b8e0c00			ADDQ runtime.gcController+24(SB), AX	
  0x41436d		4889842470010000		MOVQ AX, 0x170(SP)			
  0x414375		488b052c8e0c00			MOVQ runtime.gcController+40(SB), AX	
  0x41437c		4889842478010000		MOVQ AX, 0x178(SP)			
  0x414384		488b442470			MOVQ 0x70(SP), AX			
  0x414389		4889842480010000		MOVQ AX, 0x180(SP)			
  0x414391		31c0				XORL AX, AX				
  0x414393		e9a9000000			JMP 0x414441				
			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))
  0x414398		488d8424d0000000	LEAQ 0xd0(SP), AX			
  0x4143a0		48890424		MOVQ AX, 0(SP)				
  0x4143a4		48c744240818000000	MOVQ $0x18, 0x8(SP)			
  0x4143ad		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x4143b6		488b4c2460		MOVQ 0x60(SP), CX			
  0x4143bb		48894c2418		MOVQ CX, 0x18(SP)			
  0x4143c0		e81b140000		CALL runtime.fmtNSAsMS(SB)		
  0x4143c5		488b442430		MOVQ 0x30(SP), AX			
  0x4143ca		488b4c2428		MOVQ 0x28(SP), CX			
  0x4143cf		488b542420		MOVQ 0x20(SP), DX			
  0x4143d4		488d9c2400010000	LEAQ 0x100(SP), BX			
  0x4143dc		48891c24		MOVQ BX, 0(SP)				
  0x4143e0		4889542408		MOVQ DX, 0x8(SP)			
  0x4143e5		48894c2410		MOVQ CX, 0x10(SP)			
  0x4143ea		4889442418		MOVQ AX, 0x18(SP)			
  0x4143ef		e8dc560200		CALL runtime.slicebytetostring(SB)	
  0x4143f4		488b442428		MOVQ 0x28(SP), AX			
  0x4143f9		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x414401		488b4c2420		MOVQ 0x20(SP), CX			
  0x414406		48898c24a0010000	MOVQ CX, 0x1a0(SP)			
  0x41440e		e8adfa0000		CALL runtime.printlock(SB)		
  0x414413		488b8424a0010000	MOVQ 0x1a0(SP), AX			
  0x41441b		48890424		MOVQ AX, 0(SP)				
  0x41441f		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x414427		4889442408		MOVQ AX, 0x8(SP)			
  0x41442c		e8bf030100		CALL runtime.printstring(SB)		
  0x414431		e80afb0000		CALL runtime.printunlock(SB)		
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
  0x414436		488b842480000000	MOVQ 0x80(SP), AX		
  0x41443e		48ffc0			INCQ AX				
  0x414441		4883f805		CMPQ $0x5, AX			
  0x414445		0f8d87000000		JGE 0x4144d2			
  0x41444b		4889842480000000	MOVQ AX, 0x80(SP)		
  0x414453		488b8cc460010000	MOVQ 0x160(SP)(AX*8), CX	
  0x41445b		48894c2460		MOVQ CX, 0x60(SP)		
			if i == 2 || i == 3 {
  0x414460		4883f802		CMPQ $0x2, AX		
  0x414464		7528			JNE 0x41448e		
				print("/")
  0x414466		e855fa0000		CALL runtime.printlock(SB)	
  0x41446b		488d0515ac0500		LEAQ 0x5ac15(IP), AX		
  0x414472		48890424		MOVQ AX, 0(SP)			
  0x414476		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41447f		e86c030100		CALL runtime.printstring(SB)	
  0x414484		e8b7fa0000		CALL runtime.printunlock(SB)	
  0x414489		e90affffff		JMP 0x414398			
			if i == 2 || i == 3 {
  0x41448e		4883f803		CMPQ $0x3, AX		
  0x414492		74d2			JE 0x414466		
			} else if i != 0 {
  0x414494		4885c0			TESTQ AX, AX		
  0x414497		0f84fbfeffff		JE 0x414398		
				print("+")
  0x41449d		e81efa0000		CALL runtime.printlock(SB)	
  0x4144a2		488d05daab0500		LEAQ 0x5abda(IP), AX		
  0x4144a9		48890424		MOVQ AX, 0(SP)			
  0x4144ad		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4144b6		e835030100		CALL runtime.printstring(SB)	
  0x4144bb		e880fa0000		CALL runtime.printunlock(SB)	
		for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {
  0x4144c0		488b842480000000	MOVQ 0x80(SP), AX	
			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))
  0x4144c8		488b4c2460		MOVQ 0x60(SP), CX	
				print("+")
  0x4144cd		e9c6feffff		JMP 0x414398		
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x4144d2		488b0517dc0a00		MOVQ runtime.work+368(SB), AX	
  0x4144d9		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x4144e1		488b0d10dc0a00		MOVQ runtime.work+376(SB), CX	
  0x4144e8		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x4144f0		488b1509dc0a00		MOVQ runtime.work+384(SB), DX	
  0x4144f7		4889942498000000	MOVQ DX, 0x98(SP)		
			work.heapGoal>>20, " MB goal, ",
  0x4144ff		488b1d02dc0a00		MOVQ runtime.work+392(SB), BX	
  0x414506		48899c2490000000	MOVQ BX, 0x90(SP)		
			work.maxprocs, " P")
  0x41450e		486335a3db0a00		MOVSXD runtime.work+312(SB), SI	
  0x414515		4889b42488000000	MOVQ SI, 0x88(SP)		
		print(" ms cpu, ",
  0x41451d		e89ef90000		CALL runtime.printlock(SB)	
  0x414522		488d05afaf0500		LEAQ 0x5afaf(IP), AX		
  0x414529		48890424		MOVQ AX, 0(SP)			
  0x41452d		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x414536		e8b5020100		CALL runtime.printstring(SB)	
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x41453b		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x414543		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x414547		48890424		MOVQ AX, 0(SP)			
  0x41454b		e8f0ff0000		CALL runtime.printuint(SB)	
  0x414550		488d0547ab0500		LEAQ 0x5ab47(IP), AX		
  0x414557		48890424		MOVQ AX, 0(SP)			
  0x41455b		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x414564		e887020100		CALL runtime.printstring(SB)	
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x414569		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x414571		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x414575		48890424		MOVQ AX, 0(SP)			
  0x414579		e8c2ff0000		CALL runtime.printuint(SB)	
  0x41457e		488d0519ab0500		LEAQ 0x5ab19(IP), AX		
  0x414585		48890424		MOVQ AX, 0(SP)			
  0x414589		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x414592		e859020100		CALL runtime.printstring(SB)	
			work.heap0>>20, "->", work.heap1>>20, "->", work.heap2>>20, " MB, ",
  0x414597		488b842498000000	MOVQ 0x98(SP), AX	
  0x41459f		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x4145a3		48890424		MOVQ AX, 0(SP)			
  0x4145a7		e894ff0000		CALL runtime.printuint(SB)	
  0x4145ac		488d05eaab0500		LEAQ 0x5abea(IP), AX		
  0x4145b3		48890424		MOVQ AX, 0(SP)			
  0x4145b7		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4145c0		e82b020100		CALL runtime.printstring(SB)	
			work.heapGoal>>20, " MB goal, ",
  0x4145c5		488b842490000000	MOVQ 0x90(SP), AX	
  0x4145cd		48c1e814		SHRQ $0x14, AX		
		print(" ms cpu, ",
  0x4145d1		48890424		MOVQ AX, 0(SP)			
  0x4145d5		e866ff0000		CALL runtime.printuint(SB)	
  0x4145da		488d0513b10500		LEAQ 0x5b113(IP), AX		
  0x4145e1		48890424		MOVQ AX, 0(SP)			
  0x4145e5		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x4145ee		e8fd010100		CALL runtime.printstring(SB)	
  0x4145f3		488b842488000000	MOVQ 0x88(SP), AX		
  0x4145fb		48890424		MOVQ AX, 0(SP)			
  0x4145ff		e83c000100		CALL runtime.printint(SB)	
  0x414604		488d0589aa0500		LEAQ 0x5aa89(IP), AX		
  0x41460b		48890424		MOVQ AX, 0(SP)			
  0x41460f		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x414618		e8d3010100		CALL runtime.printstring(SB)	
  0x41461d		e81ef90000		CALL runtime.printunlock(SB)	
		if work.userForced {
  0x414622		803d47da0a0000		CMPB $0x0, runtime.work+240(SB)	
  0x414629		7571			JNE 0x41469c			
		print("\n")
  0x41462b		e890f80000		CALL runtime.printlock(SB)	
  0x414630		e81bfb0000		CALL runtime.printnl(SB)	
  0x414635		e806f90000		CALL runtime.printunlock(SB)	
		printunlock()
  0x41463a		e801f90000		CALL runtime.printunlock(SB)	
	semrelease(&worldsema)
  0x41463f		90			NOPL			
	semrelease1(addr, false)
  0x414640		488d05c9a90a00		LEAQ runtime.worldsema(SB), AX	
  0x414647		48890424		MOVQ AX, 0(SP)			
  0x41464b		c644240800		MOVB $0x0, 0x8(SP)		
  0x414650		e88be10100		CALL runtime.semrelease1(SB)	
	releasem(mp)
  0x414655		90			NOPL			
	_g_ := getg()
  0x414656		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x41465f		488b8c2488010000	MOVQ 0x188(SP), CX	
  0x414667		8b9108010000		MOVL 0x108(CX), DX	
  0x41466d		8d5aff			LEAL -0x1(DX), BX	
  0x414670		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x414676		83fa01			CMPL $0x1, DX		
  0x414679		7511			JNE 0x41468c		
  0x41467b		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x414682		7408			JE 0x41468c		
		_g_.stackguard0 = stackPreempt
  0x414684		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x41468c		488bac24b0010000	MOVQ 0x1b0(SP), BP	
  0x414694		4881c4b8010000		ADDQ $0x1b8, SP		
  0x41469b		c3			RET			
			print(" (forced)")
  0x41469c		e81ff80000		CALL runtime.printlock(SB)	
  0x4146a1		488d05e8ad0500		LEAQ 0x5ade8(IP), AX		
  0x4146a8		48890424		MOVQ AX, 0(SP)			
  0x4146ac		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4146b5		e836010100		CALL runtime.printstring(SB)	
  0x4146ba		e881f80000		CALL runtime.printunlock(SB)	
  0x4146bf		e967ffffff		JMP 0x41462b			
	mp.preemptoff = ""
  0x4146c4		488bbc24a8010000	MOVQ 0x1a8(SP), DI		
  0x4146cc		31c0			XORL AX, AX			
  0x4146ce		e8ad4f0300		CALL runtime.gcWriteBarrier(SB)	
  0x4146d3		e94df7ffff		JMP 0x413e25			
		traceGCDone()
  0x4146d8		90			NOPL			
	traceEvent(traceEvGCDone, -1)
  0x4146d9		c6042408		MOVB $0x8, 0(SP)		
  0x4146dd		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4146e6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4146ef		0f57c0			XORPS X0, X0			
  0x4146f2		0f11442418		MOVUPS X0, 0x18(SP)		
  0x4146f7		e8a4770200		CALL runtime.traceEvent(SB)	
	mp.preemptoff = ""
  0x4146fc		e9f9f6ffff		JMP 0x413dfa		
	mp.preemptoff = "gcing"
  0x414701		488d05f4aa0500		LEAQ 0x5aaf4(IP), AX		
  0x414708		e8734f0300		CALL runtime.gcWriteBarrier(SB)	
  0x41470d		e90af6ffff		JMP 0x413d1c			
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x414712		0fb6050c870c00		MOVZX runtime.writeBarrier+5(SB), AX	
  0x414719		e985f5ffff		JMP 0x413ca3				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x41471e		83f802			CMPL $0x2, AX		
  0x414721		0f94c0			SETE AL			
  0x414724		e967f5ffff		JMP 0x413c90		
		throw("gc done but gcphase != _GCoff")
  0x414729		488d0582d10500		LEAQ 0x5d182(IP), AX	
  0x414730		48890424		MOVQ AX, 0(SP)		
  0x414734		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x41473d		e83eed0000		CALL runtime.throw(SB)	
  0x414742		0f0b			UD2			
func gcMarkTermination(nextTriggerRatio float64) {
  0x414744		e837310300		CALL runtime.morestack_noctxt(SB)	
  0x414749		e9e2f4ffff		JMP runtime.gcMarkTermination(SB)	

TEXT runtime.gcBgMarkStartWorkers(SB) /usr/local/go/src/runtime/mgc.go
func gcBgMarkStartWorkers() {
  0x414750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414759		483b6110		CMPQ 0x10(CX), SP	
  0x41475d		0f86a4000000		JBE 0x414807		
  0x414763		4883ec38		SUBQ $0x38, SP		
  0x414767		48896c2430		MOVQ BP, 0x30(SP)	
  0x41476c		488d6c2430		LEAQ 0x30(SP), BP	
	for _, p := range allp {
  0x414771		488b05b0d20a00		MOVQ runtime.allp+8(SB), AX	
  0x414778		4889442420		MOVQ AX, 0x20(SP)		
  0x41477d		488b0d9cd20a00		MOVQ runtime.allp(SB), CX	
  0x414784		48894c2428		MOVQ CX, 0x28(SP)		
  0x414789		31d2			XORL DX, DX			
  0x41478b		eb03			JMP 0x414790			
  0x41478d		48ffc2			INCQ DX				
  0x414790		4839c2			CMPQ AX, DX			
  0x414793		7d68			JGE 0x4147fd			
  0x414795		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		if p.gcBgMarkWorker == 0 {
  0x414799		8403			TESTB AL, 0(BX)		
  0x41479b		4883bb5812000000	CMPQ $0x0, 0x1258(BX)	
  0x4147a3		75e8			JNE 0x41478d		
	for _, p := range allp {
  0x4147a5		4889542418		MOVQ DX, 0x18(SP)	
			go gcBgMarkWorker(p)
  0x4147aa		c7042408000000		MOVL $0x8, 0(SP)		
  0x4147b1		488d0548f00500		LEAQ 0x5f048(IP), AX		
  0x4147b8		4889442408		MOVQ AX, 0x8(SP)		
  0x4147bd		48895c2410		MOVQ BX, 0x10(SP)		
  0x4147c2		e8897d0100		CALL runtime.newproc(SB)	
			notetsleepg(&work.bgMarkReady, -1)
  0x4147c7		488d058ad80a00		LEAQ runtime.work+216(SB), AX	
  0x4147ce		48890424		MOVQ AX, 0(SP)			
  0x4147d2		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4147db		e89045ffff		CALL runtime.notetsleepg(SB)	
			noteclear(&work.bgMarkReady)
  0x4147e0		90			NOPL			
	n.key = 0
  0x4147e1		48c7056cd80a0000000000	MOVQ $0x0, runtime.work+216(SB)	
	for _, p := range allp {
  0x4147ec		488b442420		MOVQ 0x20(SP), AX	
  0x4147f1		488b4c2428		MOVQ 0x28(SP), CX	
  0x4147f6		488b542418		MOVQ 0x18(SP), DX	
  0x4147fb		eb90			JMP 0x41478d		
  0x4147fd		488b6c2430		MOVQ 0x30(SP), BP	
  0x414802		4883c438		ADDQ $0x38, SP		
  0x414806		c3			RET			
func gcBgMarkStartWorkers() {
  0x414807		e874300300		CALL runtime.morestack_noctxt(SB)	
  0x41480c		e93fffffff		JMP runtime.gcBgMarkStartWorkers(SB)	

TEXT runtime.gcBgMarkWorker(SB) /usr/local/go/src/runtime/mgc.go
func gcBgMarkWorker(_p_ *p) {
  0x414820		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414829		483b6110		CMPQ 0x10(CX), SP	
  0x41482d		0f869a040000		JBE 0x414ccd		
  0x414833		4883ec70		SUBQ $0x70, SP		
  0x414837		48896c2468		MOVQ BP, 0x68(SP)	
  0x41483c		488d6c2468		LEAQ 0x68(SP), BP	
	gp := getg()
  0x414841		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41484a		48894c2440		MOVQ CX, 0x40(SP)	
	gp.m.preemptoff = "GC worker init"
  0x41484f		488b5130		MOVQ 0x30(CX), DX			
  0x414853		48c782000100000e000000	MOVQ $0xe, 0x100(DX)			
  0x41485e		833dbb850c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x414865		0f8500030000		JNE 0x414b6b				
  0x41486b		488d05e6b40500		LEAQ 0x5b4e6(IP), AX			
  0x414872		488982f8000000		MOVQ AX, 0xf8(DX)			
	park := new(parkInfo)
  0x414879		488d0520de0400		LEAQ 0x4de20(IP), AX		
  0x414880		48890424		MOVQ AX, 0(SP)			
  0x414884		e8c75effff		CALL runtime.newobject(SB)	
	gp.m.preemptoff = ""
  0x414889		488b442440		MOVQ 0x40(SP), AX	
  0x41488e		488b4830		MOVQ 0x30(AX), CX	
	park := new(parkInfo)
  0x414892		488b542408		MOVQ 0x8(SP), DX	
	gp.m.preemptoff = ""
  0x414897		48c7810001000000000000	MOVQ $0x0, 0x100(CX)			
  0x4148a2		833d77850c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4148a9		0f85a9020000		JNE 0x414b58				
  0x4148af		48c781f800000000000000	MOVQ $0x0, 0xf8(CX)			
	park := new(parkInfo)
  0x4148ba		4889542448		MOVQ DX, 0x48(SP)	
	_g_ := getg()
  0x4148bf		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x4148c8		488b4830		MOVQ 0x30(AX), CX	
	park.m.set(acquirem())
  0x4148cc		90			NOPL			
	_g_.m.locks++
  0x4148cd		ff8108010000		INCL 0x108(CX)		
	park.m.set(acquirem())
  0x4148d3		90			NOPL			
	return _g_.m
  0x4148d4		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4148d8		488902			MOVQ AX, 0(DX)		
	park.attach.set(_p_)
  0x4148db		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4148dc		488b442478		MOVQ 0x78(SP), AX	
  0x4148e1		48894208		MOVQ AX, 0x8(DX)	
	notewakeup(&work.bgMarkReady)
  0x4148e5		488d056cd70a00		LEAQ runtime.work+216(SB), AX	
  0x4148ec		48890424		MOVQ AX, 0(SP)			
  0x4148f0		e86b40ffff		CALL runtime.notewakeup(SB)	
		gopark(func(g *g, parkp unsafe.Pointer) bool {
  0x4148f5		488d05fcee0500		LEAQ 0x5eefc(IP), AX	
  0x4148fc		48890424		MOVQ AX, 0(SP)		
  0x414900		488b4c2448		MOVQ 0x48(SP), CX	
  0x414905		48894c2408		MOVQ CX, 0x8(SP)	
  0x41490a		66c74424101714		MOVW $0x1417, 0x10(SP)	
  0x414911		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x41491a		e831080100		CALL runtime.gopark(SB)	
		if _p_.gcBgMarkWorker.ptr() != gp {
  0x41491f		488b442478		MOVQ 0x78(SP), AX	
  0x414924		8400			TESTB AL, 0(AX)		
  0x414926		488b8858120000		MOVQ 0x1258(AX), CX	
  0x41492d		90			NOPL			
  0x41492e		488b542440		MOVQ 0x40(SP), DX	
  0x414933		4839d1			CMPQ DX, CX		
  0x414936		0f8512020000		JNE 0x414b4e		
	_g_ := getg()
  0x41493c		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x414945		488b5930		MOVQ 0x30(CX), BX	
		park.m.set(acquirem())
  0x414949		90			NOPL			
	_g_.m.locks++
  0x41494a		ff8308010000		INCL 0x108(BX)		
		park.m.set(acquirem())
  0x414950		90			NOPL			
	return _g_.m
  0x414951		488b4930		MOVQ 0x30(CX), CX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x414955		488b5c2448		MOVQ 0x48(SP), BX	
  0x41495a		48890b			MOVQ CX, 0(BX)		
		if gcBlackenEnabled == 0 {
  0x41495d		833d6c830c0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x414964		0f8448030000		JE 0x414cb2				
		startTime := nanotime()
  0x41496a		e841670300		CALL runtime.nanotime(SB)	
  0x41496f		488b0424		MOVQ 0(SP), AX			
		_p_.gcMarkWorkerStartTime = startTime
  0x414973		488b4c2478		MOVQ 0x78(SP), CX	
  0x414978		48898168120000		MOVQ AX, 0x1268(CX)	
		decnwait := atomic.Xadd(&work.nwait, -1)
  0x41497f		baffffffff		MOVL $-0x1, DX			
  0x414984		488d1d95d60a00		LEAQ runtime.work+160(SB), BX	
  0x41498b		f00fc113		LOCK XADDL DX, 0(BX)		
  0x41498f		ffca			DECL DX				
		if decnwait == work.nproc {
  0x414991		8b3579d60a00		MOVL runtime.work+144(SB), SI	
  0x414997		39f2			CMPL SI, DX			
  0x414999		0f8495020000		JE 0x414c34			
		startTime := nanotime()
  0x41499f		4889442430		MOVQ AX, 0x30(SP)	
		systemstack(func() {
  0x4149a4		0f57c0			XORPS X0, X0					
  0x4149a7		0f11442450		MOVUPS X0, 0x50(SP)				
  0x4149ac		48c744246000000000	MOVQ $0x0, 0x60(SP)				
  0x4149b5		488d0524080300		LEAQ runtime.gcBgMarkWorker.func2(SB), AX	
  0x4149bc		4889442450		MOVQ AX, 0x50(SP)				
  0x4149c1		488b542440		MOVQ 0x40(SP), DX				
  0x4149c6		4889542458		MOVQ DX, 0x58(SP)				
  0x4149cb		48894c2460		MOVQ CX, 0x60(SP)				
  0x4149d0		488d5c2450		LEAQ 0x50(SP), BX				
  0x4149d5		48891c24		MOVQ BX, 0(SP)					
  0x4149d9		e8522d0300		CALL runtime.systemstack(SB)			
		duration := nanotime() - startTime
  0x4149de		e8cd660300		CALL runtime.nanotime(SB)	
  0x4149e3		488b0424		MOVQ 0(SP), AX			
  0x4149e7		488b4c2430		MOVQ 0x30(SP), CX		
  0x4149ec		4829c8			SUBQ CX, AX			
		switch _p_.gcMarkWorkerMode {
  0x4149ef		488b4c2478		MOVQ 0x78(SP), CX	
  0x4149f4		488b9160120000		MOVQ 0x1260(CX), DX	
		case gcMarkWorkerDedicatedMode:
  0x4149fb		4885d2			TESTQ DX, DX		
  0x4149fe		0f850c010000		JNE 0x414b10		
			atomic.Xaddint64(&gcController.dedicatedMarkTime, duration)
  0x414a04		488d158d870c00		LEAQ runtime.gcController+24(SB), DX	
  0x414a0b		f0480fc102		LOCK XADDQ AX, 0(DX)			
			atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 1)
  0x414a10		b801000000		MOVL $0x1, AX				
  0x414a15		488d159c870c00		LEAQ runtime.gcController+56(SB), DX	
  0x414a1c		f0480fc102		LOCK XADDQ AX, 0(DX)			
		incnwait := atomic.Xadd(&work.nwait, +1)
  0x414a21		b801000000		MOVL $0x1, AX			
  0x414a26		488d15f3d50a00		LEAQ runtime.work+160(SB), DX	
  0x414a2d		f00fc102		LOCK XADDL AX, 0(DX)		
  0x414a31		ffc0			INCL AX				
		if incnwait > work.nproc {
  0x414a33		8b15d7d50a00		MOVL runtime.work+144(SB), DX	
  0x414a39		39d0			CMPL DX, AX			
  0x414a3b		0f8742010000		JA 0x414b83			
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414a41		0f85c2000000		JNE 0x414b09		
  0x414a47		90			NOPL			
	if !work.full.empty() {
  0x414a48		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x414a49		488b0530d50a00		MOVQ runtime.work(SB), AX	
  0x414a50		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x414a53		0f85a6000000		JNE 0x414aff		
	if work.markrootNext < work.markrootJobs {
  0x414a59		8b05add50a00		MOVL runtime.work+140(SB), AX	
  0x414a5f		3905a3d50a00		CMPL AX, runtime.work+136(SB)	
  0x414a65		0f838d000000		JAE 0x414af8			
  0x414a6b		b801000000		MOVL $0x1, AX			
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414a70		83f001			XORL $0x1, AX		
  0x414a73		84c0			TESTL AL, AL		
  0x414a75		0f847afeffff		JE 0x4148f5		
			_p_.gcBgMarkWorker.set(nil)
  0x414a7b		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x414a7c		31c0			XORL AX, AX		
  0x414a7e		48898158120000		MOVQ AX, 0x1258(CX)	
			releasem(park.m.ptr())
  0x414a85		488b442448		MOVQ 0x48(SP), AX	
  0x414a8a		488b10			MOVQ 0(AX), DX		
  0x414a8d		90			NOPL			
  0x414a8e		90			NOPL			
	_g_ := getg()
  0x414a8f		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	mp.locks--
  0x414a98		8bb208010000		MOVL 0x108(DX), SI	
  0x414a9e		8d7eff			LEAL -0x1(SI), DI	
  0x414aa1		89ba08010000		MOVL DI, 0x108(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x414aa7		83fe01			CMPL $0x1, SI		
  0x414aaa		7511			JNE 0x414abd		
  0x414aac		80bbb100000000		CMPB $0x0, 0xb1(BX)	
  0x414ab3		7408			JE 0x414abd		
		_g_.stackguard0 = stackPreempt
  0x414ab5		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
			gcMarkDone()
  0x414abd		e8beeeffff		CALL runtime.gcMarkDone(SB)	
	_g_ := getg()
  0x414ac2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x414acb		488b4830		MOVQ 0x30(AX), CX	
			park.m.set(acquirem())
  0x414acf		90			NOPL			
	_g_.m.locks++
  0x414ad0		ff8108010000		INCL 0x108(CX)		
			park.m.set(acquirem())
  0x414ad6		90			NOPL			
	return _g_.m
  0x414ad7		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x414adb		488b4c2448		MOVQ 0x48(SP), CX	
  0x414ae0		488901			MOVQ AX, 0(CX)		
			park.attach.set(_p_)
  0x414ae3		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x414ae4		488b442478		MOVQ 0x78(SP), AX	
  0x414ae9		4889c2			MOVQ AX, DX		
  0x414aec		48894108		MOVQ AX, 0x8(CX)	
		if _p_.gcBgMarkWorker.ptr() != gp {
  0x414af0		4889d1			MOVQ DX, CX		
		gopark(func(g *g, parkp unsafe.Pointer) bool {
  0x414af3		e9fdfdffff		JMP 0x4148f5		
  0x414af8		31c0			XORL AX, AX		
		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x414afa		e971ffffff		JMP 0x414a70		
  0x414aff		b801000000		MOVL $0x1, AX		
  0x414b04		e967ffffff		JMP 0x414a70		
  0x414b09		31c0			XORL AX, AX		
  0x414b0b		e963ffffff		JMP 0x414a73		
		case gcMarkWorkerFractionalMode:
  0x414b10		4883fa01		CMPQ $0x1, DX		
  0x414b14		751d			JNE 0x414b33		
			atomic.Xaddint64(&gcController.fractionalMarkTime, duration)
  0x414b16		488d1583860c00		LEAQ runtime.gcController+32(SB), DX	
  0x414b1d		4889c3			MOVQ AX, BX				
  0x414b20		f0480fc102		LOCK XADDQ AX, 0(DX)			
			atomic.Xaddint64(&_p_.gcFractionalMarkTime, duration)
  0x414b25		f0480fc19950120000	LOCK XADDQ BX, 0x1250(CX)	
		switch _p_.gcMarkWorkerMode {
  0x414b2e		e9eefeffff		JMP 0x414a21		
		case gcMarkWorkerIdleMode:
  0x414b33		4883fa02		CMPQ $0x2, DX		
  0x414b37		0f85e4feffff		JNE 0x414a21		
			atomic.Xaddint64(&gcController.idleMarkTime, duration)
  0x414b3d		488d1564860c00		LEAQ runtime.gcController+40(SB), DX	
  0x414b44		f0480fc102		LOCK XADDQ AX, 0(DX)			
		switch _p_.gcMarkWorkerMode {
  0x414b49		e9d3feffff		JMP 0x414a21		
  0x414b4e		488b6c2468		MOVQ 0x68(SP), BP	
  0x414b53		4883c470		ADDQ $0x70, SP		
  0x414b57		c3			RET			
	gp.m.preemptoff = ""
  0x414b58		488db9f8000000		LEAQ 0xf8(CX), DI		
  0x414b5f		31c0			XORL AX, AX			
  0x414b61		e81a4b0300		CALL runtime.gcWriteBarrier(SB)	
  0x414b66		e94ffdffff		JMP 0x4148ba			
	gp.m.preemptoff = "GC worker init"
  0x414b6b		488dbaf8000000		LEAQ 0xf8(DX), DI		
  0x414b72		488d05dfb10500		LEAQ 0x5b1df(IP), AX		
  0x414b79		e8024b0300		CALL runtime.gcWriteBarrier(SB)	
  0x414b7e		e9f6fcffff		JMP 0x414879			
		incnwait := atomic.Xadd(&work.nwait, +1)
  0x414b83		89442424		MOVL AX, 0x24(SP)	
		if incnwait > work.nproc {
  0x414b87		8954242c		MOVL DX, 0x2c(SP)	
			println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,
  0x414b8b		488b8160120000		MOVQ 0x1260(CX), AX		
  0x414b92		4889442438		MOVQ AX, 0x38(SP)		
  0x414b97		e824f30000		CALL runtime.printlock(SB)	
  0x414b9c		488d05bdcd0500		LEAQ 0x5cdbd(IP), AX		
  0x414ba3		48890424		MOVQ AX, 0(SP)			
  0x414ba7		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x414bb0		e83bfc0000		CALL runtime.printstring(SB)	
  0x414bb5		488b442438		MOVQ 0x38(SP), AX		
  0x414bba		48890424		MOVQ AX, 0(SP)			
  0x414bbe		e87dfa0000		CALL runtime.printint(SB)	
  0x414bc3		488d0542b00500		LEAQ 0x5b042(IP), AX		
  0x414bca		48890424		MOVQ AX, 0(SP)			
  0x414bce		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414bd7		e814fc0000		CALL runtime.printstring(SB)	
  0x414bdc		8b442424		MOVL 0x24(SP), AX		
  0x414be0		48890424		MOVQ AX, 0(SP)			
  0x414be4		e857f90000		CALL runtime.printuint(SB)	
  0x414be9		488d050fb00500		LEAQ 0x5b00f(IP), AX		
  0x414bf0		48890424		MOVQ AX, 0(SP)			
  0x414bf4		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414bfd		e8eefb0000		CALL runtime.printstring(SB)	
  0x414c02		8b44242c		MOVL 0x2c(SP), AX		
  0x414c06		48890424		MOVQ AX, 0(SP)			
  0x414c0a		e831f90000		CALL runtime.printuint(SB)	
  0x414c0f		e83cf50000		CALL runtime.printnl(SB)	
  0x414c14		e827f30000		CALL runtime.printunlock(SB)	
			throw("work.nwait > work.nproc")
  0x414c19		488d05cbc10500		LEAQ 0x5c1cb(IP), AX	
  0x414c20		48890424		MOVQ AX, 0(SP)		
  0x414c24		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x414c2d		e84ee80000		CALL runtime.throw(SB)	
  0x414c32		0f0b			UD2			
		decnwait := atomic.Xadd(&work.nwait, -1)
  0x414c34		89542428		MOVL DX, 0x28(SP)	
		if decnwait == work.nproc {
  0x414c38		8974242c		MOVL SI, 0x2c(SP)	
			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
  0x414c3c		e87ff20000		CALL runtime.printlock(SB)	
  0x414c41		488d0579bc0500		LEAQ 0x5bc79(IP), AX		
  0x414c48		48890424		MOVQ AX, 0(SP)			
  0x414c4c		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x414c55		e896fb0000		CALL runtime.printstring(SB)	
  0x414c5a		8b442428		MOVL 0x28(SP), AX		
  0x414c5e		48890424		MOVQ AX, 0(SP)			
  0x414c62		e8d9f80000		CALL runtime.printuint(SB)	
  0x414c67		488d0591af0500		LEAQ 0x5af91(IP), AX		
  0x414c6e		48890424		MOVQ AX, 0(SP)			
  0x414c72		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414c7b		e870fb0000		CALL runtime.printstring(SB)	
  0x414c80		8b44242c		MOVL 0x2c(SP), AX		
  0x414c84		48890424		MOVQ AX, 0(SP)			
  0x414c88		e8b3f80000		CALL runtime.printuint(SB)	
  0x414c8d		e8bef40000		CALL runtime.printnl(SB)	
  0x414c92		e8a9f20000		CALL runtime.printunlock(SB)	
			throw("work.nwait was > work.nproc")
  0x414c97		488d0501c90500		LEAQ 0x5c901(IP), AX	
  0x414c9e		48890424		MOVQ AX, 0(SP)		
  0x414ca2		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x414cab		e8d0e70000		CALL runtime.throw(SB)	
  0x414cb0		0f0b			UD2			
			throw("gcBgMarkWorker: blackening not enabled")
  0x414cb2		488d05bfda0500		LEAQ 0x5dabf(IP), AX	
  0x414cb9		48890424		MOVQ AX, 0(SP)		
  0x414cbd		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x414cc6		e8b5e70000		CALL runtime.throw(SB)	
  0x414ccb		0f0b			UD2			
func gcBgMarkWorker(_p_ *p) {
  0x414ccd		e8ae2b0300		CALL runtime.morestack_noctxt(SB)	
  0x414cd2		e949fbffff		JMP runtime.gcBgMarkWorker(SB)		

TEXT runtime.gcMark(SB) /usr/local/go/src/runtime/mgc.go
func gcMark(start_time int64) {
  0x414ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x414ce9		488d4424f0		LEAQ -0x10(SP), AX	
  0x414cee		483b4110		CMPQ 0x10(CX), AX	
  0x414cf2		0f8653050000		JBE 0x41524b		
  0x414cf8		4881ec90000000		SUBQ $0x90, SP		
  0x414cff		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x414d07		488dac2488000000	LEAQ 0x88(SP), BP	
	if debug.allocfreetrace > 0 {
  0x414d0f		833dca810c0000		CMPL $0x0, runtime.debug(SB)	
  0x414d16		0f8f41030000		JG 0x41505d			
	if gcphase != _GCmarktermination {
  0x414d1c		833db97f0c0002		CMPL $0x2, runtime.gcphase(SB)	
  0x414d23		0f8507050000		JNE 0x415230			
	work.tstart = start_time
  0x414d29		488b842498000000	MOVQ 0x98(SP), AX		
  0x414d31		488905e0d20a00		MOVQ AX, runtime.work+152(SB)	
	if work.full != 0 || work.markrootNext < work.markrootJobs {
  0x414d38		488b0541d20a00		MOVQ runtime.work(SB), AX	
  0x414d3f		4889442470		MOVQ AX, 0x70(SP)		
  0x414d44		4885c0			TESTQ AX, AX			
  0x414d47		0f855f030000		JNE 0x4150ac			
  0x414d4d		8b0db9d20a00		MOVL runtime.work+140(SB), CX	
  0x414d53		390dafd20a00		CMPL CX, runtime.work+136(SB)	
  0x414d59		0f824d030000		JB 0x4150ac			
	if debug.gccheckmark > 0 {
  0x414d5f		833d8a810c0000		CMPL $0x0, runtime.debug+16(SB)	
  0x414d66		0f8fe7020000		JG 0x415053			
	if work.full != 0 {
  0x414d6c		48833d0cd20a0000	CMPQ $0x0, runtime.work(SB)	
  0x414d74		0f8517030000		JNE 0x415091			
	for _, p := range allp {
  0x414d7a		488b05a7cc0a00		MOVQ runtime.allp+8(SB), AX	
  0x414d81		4889442468		MOVQ AX, 0x68(SP)		
  0x414d86		488b0d93cc0a00		MOVQ runtime.allp(SB), CX	
  0x414d8d		48898c2480000000	MOVQ CX, 0x80(SP)		
  0x414d95		31d2			XORL DX, DX			
  0x414d97		eb25			JMP 0x414dbe			
		gcw := &p.gcw
  0x414d99		480570120000		ADDQ $0x1270, AX	
		gcw.dispose()
  0x414d9f		48890424		MOVQ AX, 0(SP)				
  0x414da3		e8886b0000		CALL runtime.(*gcWork).dispose(SB)	
	for _, p := range allp {
  0x414da8		488b442460		MOVQ 0x60(SP), AX	
  0x414dad		488d5001		LEAQ 0x1(AX), DX	
  0x414db1		488b442468		MOVQ 0x68(SP), AX	
  0x414db6		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x414dbe		4839c2			CMPQ AX, DX		
  0x414dc1		0f8df7010000		JGE 0x414fbe		
  0x414dc7		4889542460		MOVQ DX, 0x60(SP)	
  0x414dcc		488b1cd1		MOVQ 0(CX)(DX*8), BX	
  0x414dd0		48895c2478		MOVQ BX, 0x78(SP)	
		if debug.gccheckmark > 0 || throwOnGCWork {
  0x414dd5		833d14810c0000		CMPL $0x0, runtime.debug+16(SB)	
  0x414ddc		0f8eb8010000		JLE 0x414f9a			
			wbBufFlush1(p)
  0x414de2		48891c24		MOVQ BX, 0(SP)			
  0x414de6		e805bf0000		CALL runtime.wbBufFlush1(SB)	
		gcw := &p.gcw
  0x414deb		488b442478		MOVQ 0x78(SP), AX	
  0x414df0		8400			TESTB AL, 0(AX)		
		if !gcw.empty() {
  0x414df2		90			NOPL			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x414df3		488b8870120000		MOVQ 0x1270(AX), CX	
  0x414dfa		4885c9			TESTQ CX, CX		
  0x414dfd		0f848d010000		JE 0x414f90		
  0x414e03		4883791000		CMPQ $0x0, 0x10(CX)	
  0x414e08		0f857b010000		JNE 0x414f89		
  0x414e0e		488b8878120000		MOVQ 0x1278(AX), CX	
  0x414e15		4883791000		CMPQ $0x0, 0x10(CX)	
  0x414e1a		0f94c1			SETE CL			
		if !gcw.empty() {
  0x414e1d		84c9			TESTL CL, CL		
  0x414e1f		0f8574ffffff		JNE 0x414d99		
			printlock()
  0x414e25		e896f00000		CALL runtime.printlock(SB)	
			print("runtime: P ", p.id, " flushedWork ", gcw.flushedWork)
  0x414e2a		488b442478		MOVQ 0x78(SP), AX		
  0x414e2f		48634808		MOVSXD 0x8(AX), CX		
  0x414e33		48894c2458		MOVQ CX, 0x58(SP)		
  0x414e38		0fb69090120000		MOVZX 0x1290(AX), DX		
  0x414e3f		8854242f		MOVB DL, 0x2f(SP)		
  0x414e43		e878f00000		CALL runtime.printlock(SB)	
  0x414e48		488d05fbaa0500		LEAQ 0x5aafb(IP), AX		
  0x414e4f		48890424		MOVQ AX, 0(SP)			
  0x414e53		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x414e5c		e88ff90000		CALL runtime.printstring(SB)	
  0x414e61		488b442458		MOVQ 0x58(SP), AX		
  0x414e66		48890424		MOVQ AX, 0(SP)			
  0x414e6a		e8d1f70000		CALL runtime.printint(SB)	
  0x414e6f		488d0514ad0500		LEAQ 0x5ad14(IP), AX		
  0x414e76		48890424		MOVQ AX, 0(SP)			
  0x414e7a		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x414e83		e868f90000		CALL runtime.printstring(SB)	
  0x414e88		0fb644242f		MOVZX 0x2f(SP), AX		
  0x414e8d		880424			MOVB AL, 0(SP)			
  0x414e90		e80bf30000		CALL runtime.printbool(SB)	
  0x414e95		e8a6f00000		CALL runtime.printunlock(SB)	
			if gcw.wbuf1 == nil {
  0x414e9a		488b442478		MOVQ 0x78(SP), AX	
  0x414e9f		488b8870120000		MOVQ 0x1270(AX), CX	
  0x414ea6		4885c9			TESTQ CX, CX		
  0x414ea9		0f84b2000000		JE 0x414f61		
				print(" wbuf1.n=", gcw.wbuf1.nobj)
  0x414eaf		488b4110		MOVQ 0x10(CX), AX		
  0x414eb3		4889442468		MOVQ AX, 0x68(SP)		
  0x414eb8		e803f00000		CALL runtime.printlock(SB)	
  0x414ebd		488d0553a60500		LEAQ 0x5a653(IP), AX		
  0x414ec4		48890424		MOVQ AX, 0(SP)			
  0x414ec8		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x414ed1		e81af90000		CALL runtime.printstring(SB)	
  0x414ed6		488b442468		MOVQ 0x68(SP), AX		
  0x414edb		48890424		MOVQ AX, 0(SP)			
  0x414edf		e85cf70000		CALL runtime.printint(SB)	
  0x414ee4		e857f00000		CALL runtime.printunlock(SB)	
			if gcw.wbuf2 == nil {
  0x414ee9		488b442478		MOVQ 0x78(SP), AX	
  0x414eee		488b8078120000		MOVQ 0x1278(AX), AX	
  0x414ef5		4885c0			TESTQ AX, AX		
  0x414ef8		743f			JE 0x414f39		
				print(" wbuf2.n=", gcw.wbuf2.nobj)
  0x414efa		488b4010		MOVQ 0x10(AX), AX		
  0x414efe		4889442468		MOVQ AX, 0x68(SP)		
  0x414f03		e8b8ef0000		CALL runtime.printlock(SB)	
  0x414f08		488d0511a60500		LEAQ 0x5a611(IP), AX		
  0x414f0f		48890424		MOVQ AX, 0(SP)			
  0x414f13		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x414f1c		e8cff80000		CALL runtime.printstring(SB)	
  0x414f21		488b442468		MOVQ 0x68(SP), AX		
  0x414f26		48890424		MOVQ AX, 0(SP)			
  0x414f2a		e811f70000		CALL runtime.printint(SB)	
  0x414f2f		e80cf00000		CALL runtime.printunlock(SB)	
  0x414f34		e92e010000		JMP 0x415067			
				print(" wbuf2=<nil>")
  0x414f39		e882ef0000		CALL runtime.printlock(SB)	
  0x414f3e		488d0508ab0500		LEAQ 0x5ab08(IP), AX		
  0x414f45		48890424		MOVQ AX, 0(SP)			
  0x414f49		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x414f52		e899f80000		CALL runtime.printstring(SB)	
  0x414f57		e8e4ef0000		CALL runtime.printunlock(SB)	
  0x414f5c		e906010000		JMP 0x415067			
				print(" wbuf1=<nil>")
  0x414f61		e85aef0000		CALL runtime.printlock(SB)	
  0x414f66		488d05d4aa0500		LEAQ 0x5aad4(IP), AX		
  0x414f6d		48890424		MOVQ AX, 0(SP)			
  0x414f71		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x414f7a		e871f80000		CALL runtime.printstring(SB)	
  0x414f7f		e8bcef0000		CALL runtime.printunlock(SB)	
  0x414f84		e960ffffff		JMP 0x414ee9			
  0x414f89		31c9			XORL CX, CX			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x414f8b		e98dfeffff		JMP 0x414e1d		
  0x414f90		b901000000		MOVL $0x1, CX		
  0x414f95		e983feffff		JMP 0x414e1d		
		if debug.gccheckmark > 0 || throwOnGCWork {
  0x414f9a		803d127d0c0000		CMPB $0x0, runtime.throwOnGCWork(SB)	
  0x414fa1		0f853bfeffff		JNE 0x414de2				
			p.wbBuf.reset()
  0x414fa7		8403			TESTB AL, 0(BX)			
  0x414fa9		488d8320130000		LEAQ 0x1320(BX), AX		
  0x414fb0		48890424		MOVQ AX, 0(SP)			
  0x414fb4		e8b7bb0000		CALL runtime.(*wbBuf).reset(SB)	
  0x414fb9		e92dfeffff		JMP 0x414deb			
	throwOnGCWork = false
  0x414fbe		c605ee7c0c0000		MOVB $0x0, runtime.throwOnGCWork(SB)	
	cachestats()
  0x414fc5		e886b80000		CALL runtime.cachestats(SB)	
	memstats.heap_marked = work.bytesMarked
  0x414fca		488b052fd00a00		MOVQ runtime.work+128(SB), AX		
  0x414fd1		488905d8a30c00		MOVQ AX, runtime.memstats+5968(SB)	
	memstats.heap_live = work.bytesMarked
  0x414fd8		488b0521d00a00		MOVQ runtime.work+128(SB), AX		
  0x414fdf		488905baa30c00		MOVQ AX, runtime.memstats+5952(SB)	
	memstats.heap_scan = uint64(gcController.scanWork)
  0x414fe6		488b0593810c00		MOVQ runtime.gcController(SB), AX	
  0x414fed		488905b4a30c00		MOVQ AX, runtime.memstats+5960(SB)	
	if trace.enabled {
  0x414ff4		803dd57b0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x414ffb		7510			JNE 0x41500d			
  0x414ffd		488bac2488000000	MOVQ 0x88(SP), BP		
  0x415005		4881c490000000		ADDQ $0x90, SP			
  0x41500c		c3			RET				
		traceHeapAlloc()
  0x41500d		90			NOPL			
	traceEvent(traceEvHeapAlloc, -1, memstats.heap_live)
  0x41500e		48c744243000000000	MOVQ $0x0, 0x30(SP)			
  0x415017		488b0582a30c00		MOVQ runtime.memstats+5952(SB), AX	
  0x41501e		4889442430		MOVQ AX, 0x30(SP)			
  0x415023		c6042421		MOVB $0x21, 0(SP)			
  0x415027		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x415030		488d442430		LEAQ 0x30(SP), AX			
  0x415035		4889442410		MOVQ AX, 0x10(SP)			
  0x41503a		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x415043		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x41504c		e84f6e0200		CALL runtime.traceEvent(SB)		
  0x415051		ebaa			JMP 0x414ffd				
		gcMarkRootCheck()
  0x415053		e828140000		CALL runtime.gcMarkRootCheck(SB)	
  0x415058		e90ffdffff		JMP 0x414d6c				
		tracegc()
  0x41505d		e86eb60000		CALL runtime.tracegc(SB)	
  0x415062		e9b5fcffff		JMP 0x414d1c			
			print("\n")
  0x415067		e854ee0000		CALL runtime.printlock(SB)	
  0x41506c		e8dff00000		CALL runtime.printnl(SB)	
  0x415071		e8caee0000		CALL runtime.printunlock(SB)	
			throw("P has cached GC work at end of mark termination")
  0x415076		488d0503e00500		LEAQ 0x5e003(IP), AX	
  0x41507d		48890424		MOVQ AX, 0(SP)		
  0x415081		48c74424082f000000	MOVQ $0x2f, 0x8(SP)	
  0x41508a		e8f1e30000		CALL runtime.throw(SB)	
  0x41508f		0f0b			UD2			
		throw("work.full != 0")
  0x415091		488d05aead0500		LEAQ 0x5adae(IP), AX	
  0x415098		48890424		MOVQ AX, 0(SP)		
  0x41509c		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4150a5		e8d6e30000		CALL runtime.throw(SB)	
  0x4150aa		0f0b			UD2			
		print("runtime: full=", hex(work.full), " next=", work.markrootNext, " jobs=", work.markrootJobs, " nDataRoots=", work.nDataRoots, " nBSSRoots=", work.nBSSRoots, " nSpanRoots=", work.nSpanRoots, " nStackRoots=", work.nStackRoots, "\n")
  0x4150ac		8b0556cf0a00		MOVL runtime.work+136(SB), AX	
  0x4150b2		4889442450		MOVQ AX, 0x50(SP)		
  0x4150b7		8b0d4fcf0a00		MOVL runtime.work+140(SB), CX	
  0x4150bd		48894c2448		MOVQ CX, 0x48(SP)		
  0x4150c2		488b1567cf0a00		MOVQ runtime.work+176(SB), DX	
  0x4150c9		4889542468		MOVQ DX, 0x68(SP)		
  0x4150ce		488b1d63cf0a00		MOVQ runtime.work+184(SB), BX	
  0x4150d5		48895c2460		MOVQ BX, 0x60(SP)		
  0x4150da		488b355fcf0a00		MOVQ runtime.work+192(SB), SI	
  0x4150e1		4889742440		MOVQ SI, 0x40(SP)		
  0x4150e6		488b3d5bcf0a00		MOVQ runtime.work+200(SB), DI	
  0x4150ed		48897c2438		MOVQ DI, 0x38(SP)		
  0x4150f2		e8c9ed0000		CALL runtime.printlock(SB)	
  0x4150f7		488d05e6ac0500		LEAQ 0x5ace6(IP), AX		
  0x4150fe		48890424		MOVQ AX, 0(SP)			
  0x415102		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x41510b		e8e0f60000		CALL runtime.printstring(SB)	
  0x415110		488b442470		MOVQ 0x70(SP), AX		
  0x415115		48890424		MOVQ AX, 0(SP)			
  0x415119		e892f50000		CALL runtime.printhex(SB)	
  0x41511e		488d0531a10500		LEAQ 0x5a131(IP), AX		
  0x415125		48890424		MOVQ AX, 0(SP)			
  0x415129		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x415132		e8b9f60000		CALL runtime.printstring(SB)	
  0x415137		488b442450		MOVQ 0x50(SP), AX		
  0x41513c		48890424		MOVQ AX, 0(SP)			
  0x415140		e8fbf30000		CALL runtime.printuint(SB)	
  0x415145		488d05f8a00500		LEAQ 0x5a0f8(IP), AX		
  0x41514c		48890424		MOVQ AX, 0(SP)			
  0x415150		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x415159		e892f60000		CALL runtime.printstring(SB)	
  0x41515e		488b442448		MOVQ 0x48(SP), AX		
  0x415163		48890424		MOVQ AX, 0(SP)			
  0x415167		e8d4f30000		CALL runtime.printuint(SB)	
  0x41516c		488d0556a80500		LEAQ 0x5a856(IP), AX		
  0x415173		48890424		MOVQ AX, 0(SP)			
  0x415177		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x415180		e86bf60000		CALL runtime.printstring(SB)	
  0x415185		488b442468		MOVQ 0x68(SP), AX		
  0x41518a		48890424		MOVQ AX, 0(SP)			
  0x41518e		e8adf40000		CALL runtime.printint(SB)	
  0x415193		488d05eaa60500		LEAQ 0x5a6ea(IP), AX		
  0x41519a		48890424		MOVQ AX, 0(SP)			
  0x41519e		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x4151a7		e844f60000		CALL runtime.printstring(SB)	
  0x4151ac		488b442460		MOVQ 0x60(SP), AX		
  0x4151b1		48890424		MOVQ AX, 0(SP)			
  0x4151b5		e886f40000		CALL runtime.printint(SB)	
  0x4151ba		488d0514a80500		LEAQ 0x5a814(IP), AX		
  0x4151c1		48890424		MOVQ AX, 0(SP)			
  0x4151c5		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4151ce		e81df60000		CALL runtime.printstring(SB)	
  0x4151d3		488b442440		MOVQ 0x40(SP), AX		
  0x4151d8		48890424		MOVQ AX, 0(SP)			
  0x4151dc		e85ff40000		CALL runtime.printint(SB)	
  0x4151e1		488d05e3a90500		LEAQ 0x5a9e3(IP), AX		
  0x4151e8		48890424		MOVQ AX, 0(SP)			
  0x4151ec		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4151f5		e8f6f50000		CALL runtime.printstring(SB)	
  0x4151fa		488b442438		MOVQ 0x38(SP), AX		
  0x4151ff		48890424		MOVQ AX, 0(SP)			
  0x415203		e838f40000		CALL runtime.printint(SB)	
  0x415208		e843ef0000		CALL runtime.printnl(SB)	
  0x41520d		e82eed0000		CALL runtime.printunlock(SB)	
		panic("non-empty mark queue after concurrent mark")
  0x415212		488d05a75f0400		LEAQ 0x45fa7(IP), AX			
  0x415219		48890424		MOVQ AX, 0(SP)				
  0x41521d		488d056c7d0600		LEAQ runtime.statictmp_17(SB), AX	
  0x415224		4889442408		MOVQ AX, 0x8(SP)			
  0x415229		e882dc0000		CALL runtime.gopanic(SB)		
  0x41522e		0f0b			UD2					
		throw("in gcMark expecting to see gcphase as _GCmarktermination")
  0x415230		488d0519e20500		LEAQ 0x5e219(IP), AX	
  0x415237		48890424		MOVQ AX, 0(SP)		
  0x41523b		48c744240838000000	MOVQ $0x38, 0x8(SP)	
  0x415244		e837e20000		CALL runtime.throw(SB)	
  0x415249		0f0b			UD2			
func gcMark(start_time int64) {
  0x41524b		e830260300		CALL runtime.morestack_noctxt(SB)	
  0x415250		e98bfaffff		JMP runtime.gcMark(SB)			

TEXT runtime.gcSweep(SB) /usr/local/go/src/runtime/mgc.go
func gcSweep(mode gcMode) {
  0x415260		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415269		483b6110		CMPQ 0x10(CX), SP	
  0x41526d		0f86d0010000		JBE 0x415443		
  0x415273		4883ec20		SUBQ $0x20, SP		
  0x415277		48896c2418		MOVQ BP, 0x18(SP)	
  0x41527c		488d6c2418		LEAQ 0x18(SP), BP	
	if gcphase != _GCoff {
  0x415281		833d547a0c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x415288		0f859a010000		JNE 0x415428			
	lock(&mheap_.lock)
  0x41528e		488d05ab130b00		LEAQ runtime.mheap_(SB), AX	
  0x415295		48890424		MOVQ AX, 0(SP)			
  0x415299		e84234ffff		CALL runtime.lock(SB)		
	mheap_.sweepgen += 2
  0x41529e		8b05b4130b00		MOVL runtime.mheap_+24(SB), AX	
  0x4152a4		83c002			ADDL $0x2, AX			
  0x4152a7		8905ab130b00		MOVL AX, runtime.mheap_+24(SB)	
	mheap_.sweepdone = 0
  0x4152ad		c705a5130b0000000000	MOVL $0x0, runtime.mheap_+28(SB)	
	if mheap_.sweepSpans[mheap_.sweepgen/2%2].index != 0 {
  0x4152b7		d1e8			SHRL $0x1, AX			
  0x4152b9		83e001			ANDL $0x1, AX			
  0x4152bc		488d0480		LEAQ 0(AX)(AX*4), AX		
  0x4152c0		488d0db9130b00		LEAQ runtime.mheap_+64(SB), CX	
  0x4152c7		8b44c120		MOVL 0x20(CX)(AX*8), AX		
  0x4152cb		85c0			TESTL AX, AX			
  0x4152cd		0f853a010000		JNE 0x41540d			
	mheap_.pagesSwept = 0
  0x4152d3		48c70502140b0000000000	MOVQ $0x0, runtime.mheap_+160(SB)	
	mheap_.sweepArenas = mheap_.allArenas
  0x4152de		488b0dbb160b00		MOVQ runtime.mheap_+864(SB), CX		
  0x4152e5		488b05a4160b00		MOVQ runtime.mheap_+848(SB), AX		
  0x4152ec		488b15a5160b00		MOVQ runtime.mheap_+856(SB), DX		
  0x4152f3		488915b6160b00		MOVQ DX, runtime.mheap_+880(SB)		
  0x4152fa		48890db7160b00		MOVQ CX, runtime.mheap_+888(SB)		
  0x415301		833d187b0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x415308		0f85ee000000		JNE 0x4153fc				
  0x41530e		48890593160b00		MOVQ AX, runtime.mheap_+872(SB)		
	mheap_.reclaimCredit = 0
  0x415315		0f57c0			XORPS X0, X0				
  0x415318		0f1105e1130b00		MOVUPS X0, runtime.mheap_+192(SB)	
	unlock(&mheap_.lock)
  0x41531f		488d051a130b00		LEAQ runtime.mheap_(SB), AX	
  0x415326		48890424		MOVQ AX, 0(SP)			
  0x41532a		e86135ffff		CALL runtime.unlock(SB)		
	if !_ConcurrentSweep || mode == gcForceBlockMode {
  0x41532f		488b442428		MOVQ 0x28(SP), AX	
  0x415334		4883f802		CMPQ $0x2, AX		
  0x415338		7568			JNE 0x4153a2		
		lock(&mheap_.lock)
  0x41533a		488d05ff120b00		LEAQ runtime.mheap_(SB), AX	
  0x415341		48890424		MOVQ AX, 0(SP)			
  0x415345		e89633ffff		CALL runtime.lock(SB)		
		mheap_.sweepPagesPerByte = 0
  0x41534a		0f57c0			XORPS X0, X0				
  0x41534d		f20f1105a3130b00	MOVSD_XMM X0, runtime.mheap_+184(SB)	
		unlock(&mheap_.lock)
  0x415355		488d05e4120b00		LEAQ runtime.mheap_(SB), AX	
  0x41535c		48890424		MOVQ AX, 0(SP)			
  0x415360		e82b35ffff		CALL runtime.unlock(SB)		
		for sweepone() != ^uintptr(0) {
  0x415365		eb06			JMP 0x41536d		
			sweep.npausesweep++
  0x415367		ff050bc80a00		INCL runtime.sweep+24(SB)	
		for sweepone() != ^uintptr(0) {
  0x41536d		e8ae4e0000		CALL runtime.sweepone(SB)	
  0x415372		48833c24ff		CMPQ $-0x1, 0(SP)		
  0x415377		75ee			JNE 0x415367			
		prepareFreeWorkbufs()
  0x415379		e8826c0000		CALL runtime.prepareFreeWorkbufs(SB)	
		for freeSomeWbufs(false) {
  0x41537e		c6042400		MOVB $0x0, 0(SP)		
  0x415382		e8296d0000		CALL runtime.freeSomeWbufs(SB)	
  0x415387		807c240800		CMPB $0x0, 0x8(SP)		
  0x41538c		75f0			JNE 0x41537e			
		mProf_NextCycle()
  0x41538e		e85da70000		CALL runtime.mProf_NextCycle(SB)	
		mProf_Flush()
  0x415393		e8d8a70000		CALL runtime.mProf_Flush(SB)	
		return
  0x415398		488b6c2418		MOVQ 0x18(SP), BP	
  0x41539d		4883c420		ADDQ $0x20, SP		
  0x4153a1		c3			RET			
	lock(&sweep.lock)
  0x4153a2		488d05b7c70a00		LEAQ runtime.sweep(SB), AX	
  0x4153a9		48890424		MOVQ AX, 0(SP)			
  0x4153ad		e82e33ffff		CALL runtime.lock(SB)		
	if sweep.parked {
  0x4153b2		803db7c70a0000		CMPB $0x0, runtime.sweep+16(SB)	
  0x4153b9		751a			JNE 0x4153d5			
	unlock(&sweep.lock)
  0x4153bb		488d059ec70a00		LEAQ runtime.sweep(SB), AX	
  0x4153c2		48890424		MOVQ AX, 0(SP)			
  0x4153c6		e8c534ffff		CALL runtime.unlock(SB)		
}
  0x4153cb		488b6c2418		MOVQ 0x18(SP), BP	
  0x4153d0		4883c420		ADDQ $0x20, SP		
  0x4153d4		c3			RET			
		sweep.parked = false
  0x4153d5		c60594c70a0000		MOVB $0x0, runtime.sweep+16(SB)	
		ready(sweep.g, 0, true)
  0x4153dc		488b0585c70a00		MOVQ runtime.sweep+8(SB), AX	
  0x4153e3		48890424		MOVQ AX, 0(SP)			
  0x4153e7		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x4153f0		c644241001		MOVB $0x1, 0x10(SP)		
  0x4153f5		e8f60f0100		CALL runtime.ready(SB)		
  0x4153fa		ebbf			JMP 0x4153bb			
	mheap_.sweepArenas = mheap_.allArenas
  0x4153fc		488d3da5150b00		LEAQ runtime.mheap_+872(SB), DI	
  0x415403		e878420300		CALL runtime.gcWriteBarrier(SB)	
  0x415408		e908ffffff		JMP 0x415315			
		throw("non-empty swept list")
  0x41540d		488d05adb20500		LEAQ 0x5b2ad(IP), AX	
  0x415414		48890424		MOVQ AX, 0(SP)		
  0x415418		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x415421		e85ae00000		CALL runtime.throw(SB)	
  0x415426		0f0b			UD2			
		throw("gcSweep being done but phase is not GCoff")
  0x415428		488d050cd60500		LEAQ 0x5d60c(IP), AX	
  0x41542f		48890424		MOVQ AX, 0(SP)		
  0x415433		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x41543c		e83fe00000		CALL runtime.throw(SB)	
  0x415441		0f0b			UD2			
func gcSweep(mode gcMode) {
  0x415443		e838240300		CALL runtime.morestack_noctxt(SB)	
  0x415448		e913feffff		JMP runtime.gcSweep(SB)			

TEXT runtime.gcResetMarkState(SB) /usr/local/go/src/runtime/mgc.go
func gcResetMarkState() {
  0x415450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415459		483b6110		CMPQ 0x10(CX), SP	
  0x41545d		0f8625010000		JBE 0x415588		
  0x415463		4883ec30		SUBQ $0x30, SP		
  0x415467		48896c2428		MOVQ BP, 0x28(SP)	
  0x41546c		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&allglock)
  0x415471		488d05a8780c00		LEAQ runtime.allglock(SB), AX	
  0x415478		48890424		MOVQ AX, 0(SP)			
  0x41547c		e85f32ffff		CALL runtime.lock(SB)		
	for _, gp := range allgs {
  0x415481		488b0580c50a00		MOVQ runtime.allgs+8(SB), AX	
  0x415488		488b0d71c50a00		MOVQ runtime.allgs(SB), CX	
  0x41548f		31d2			XORL DX, DX			
  0x415491		eb1b			JMP 0x4154ae			
  0x415493		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		gp.gcscanvalid = false // stack has not been scanned
  0x415497		66c783b40000000000	MOVW $0x0, 0xb4(BX)	
		gp.gcAssistBytes = 0
  0x4154a0		48c7837001000000000000	MOVQ $0x0, 0x170(BX)	
	for _, gp := range allgs {
  0x4154ab		48ffc2			INCQ DX			
  0x4154ae		4839c2			CMPQ AX, DX		
  0x4154b1		7ce0			JL 0x415493		
	unlock(&allglock)
  0x4154b3		488d0566780c00		LEAQ runtime.allglock(SB), AX	
  0x4154ba		48890424		MOVQ AX, 0(SP)			
  0x4154be		e8cd33ffff		CALL runtime.unlock(SB)		
	lock(&mheap_.lock)
  0x4154c3		488d0576110b00		LEAQ runtime.mheap_(SB), AX	
  0x4154ca		48890424		MOVQ AX, 0(SP)			
  0x4154ce		e80d32ffff		CALL runtime.lock(SB)		
	arenas := mheap_.allArenas
  0x4154d3		488b05b6140b00		MOVQ runtime.mheap_+848(SB), AX	
  0x4154da		4889442420		MOVQ AX, 0x20(SP)		
  0x4154df		488b0db2140b00		MOVQ runtime.mheap_+856(SB), CX	
  0x4154e6		48894c2410		MOVQ CX, 0x10(SP)		
	unlock(&mheap_.lock)
  0x4154eb		488d154e110b00		LEAQ runtime.mheap_(SB), DX	
  0x4154f2		48891424		MOVQ DX, 0(SP)			
  0x4154f6		e89533ffff		CALL runtime.unlock(SB)		
	for _, ai := range arenas {
  0x4154fb		488b442410		MOVQ 0x10(SP), AX	
  0x415500		488b4c2420		MOVQ 0x20(SP), CX	
  0x415505		31d2			XORL DX, DX		
  0x415507		eb36			JMP 0x41553f		
  0x415509		4889542418		MOVQ DX, 0x18(SP)	
		ha := mheap_.arenas[ai.l1()][ai.l2()]
  0x41550e		488b04f3		MOVQ 0(BX)(SI*8), AX	
		for i := range ha.pageMarks {
  0x415512		8400			TESTB AL, 0(AX)				
  0x415514		480500042100		ADDQ $0x210400, AX			
  0x41551a		48890424		MOVQ AX, 0(SP)				
  0x41551e		48c744240800040000	MOVQ $0x400, 0x8(SP)			
  0x415527		e8944f0300		CALL runtime.memclrNoHeapPointers(SB)	
	for _, ai := range arenas {
  0x41552c		488b442418		MOVQ 0x18(SP), AX	
  0x415531		488d5001		LEAQ 0x1(AX), DX	
  0x415535		488b442410		MOVQ 0x10(SP), AX	
  0x41553a		488b4c2420		MOVQ 0x20(SP), CX	
  0x41553f		4839c2			CMPQ AX, DX		
  0x415542		7d1a			JGE 0x41555e		
		ha := mheap_.arenas[ai.l1()][ai.l2()]
  0x415544		488b1d05140b00		MOVQ runtime.mheap_+784(SB), BX	
  0x41554b		8403			TESTB AL, 0(BX)			
	for _, ai := range arenas {
  0x41554d		488b34d1		MOVQ 0(CX)(DX*8), SI	
		ha := mheap_.arenas[ai.l1()][ai.l2()]
  0x415551		90			NOPL			
  0x415552		90			NOPL			
  0x415553		4881fe00004000		CMPQ $0x400000, SI	
  0x41555a		72ad			JB 0x415509		
  0x41555c		eb23			JMP 0x415581		
	work.bytesMarked = 0
  0x41555e		48c70597ca0a0000000000	MOVQ $0x0, runtime.work+128(SB)	
	work.initialHeapLive = atomic.Load64(&memstats.heap_live)
  0x415569		488b05309e0c00		MOVQ runtime.memstats+5952(SB), AX	
  0x415570		48890509cb0a00		MOVQ AX, runtime.work+256(SB)		
}
  0x415577		488b6c2428		MOVQ 0x28(SP), BP	
  0x41557c		4883c430		ADDQ $0x30, SP		
  0x415580		c3			RET			
		ha := mheap_.arenas[ai.l1()][ai.l2()]
  0x415581		e89ac90000		CALL runtime.panicindex(SB)	
  0x415586		0f0b			UD2				
func gcResetMarkState() {
  0x415588		e8f3220300		CALL runtime.morestack_noctxt(SB)	
  0x41558d		e9befeffff		JMP runtime.gcResetMarkState(SB)	

TEXT runtime.clearpools(SB) /usr/local/go/src/runtime/mgc.go
func clearpools() {
  0x4155a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4155a9		483b6110		CMPQ 0x10(CX), SP	
  0x4155ad		0f8642010000		JBE 0x4156f5		
  0x4155b3		4883ec10		SUBQ $0x10, SP		
  0x4155b7		48896c2408		MOVQ BP, 0x8(SP)	
  0x4155bc		488d6c2408		LEAQ 0x8(SP), BP	
	if poolcleanup != nil {
  0x4155c1		488b15c0c30a00		MOVQ runtime.poolcleanup(SB), DX	
  0x4155c8		4885d2			TESTQ DX, DX				
  0x4155cb		0f851a010000		JNE 0x4156eb				
	lock(&sched.sudoglock)
  0x4155d1		488d0578c70a00		LEAQ runtime.sched+176(SB), AX	
  0x4155d8		48890424		MOVQ AX, 0(SP)			
  0x4155dc		e8ff30ffff		CALL runtime.lock(SB)		
	for sg = sched.sudogcache; sg != nil; sg = sgnext {
  0x4155e1		488b0570c70a00		MOVQ runtime.sched+184(SB), AX	
  0x4155e8		eb03			JMP 0x4155ed			
  0x4155ea		4889c8			MOVQ CX, AX			
  0x4155ed		4885c0			TESTQ AX, AX			
  0x4155f0		7424			JE 0x415616			
		sgnext = sg.next
  0x4155f2		488b4810		MOVQ 0x10(AX), CX	
		sg.next = nil
  0x4155f6		833d23780c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4155fd		750a			JNE 0x415609				
  0x4155ff		48c7401000000000	MOVQ $0x0, 0x10(AX)			
  0x415607		ebe1			JMP 0x4155ea				
		sgnext = sg.next
  0x415609		488d7810		LEAQ 0x10(AX), DI	
		sg.next = nil
  0x41560d		31c0			XORL AX, AX			
  0x41560f		e86c400300		CALL runtime.gcWriteBarrier(SB)	
  0x415614		ebd4			JMP 0x4155ea			
	sched.sudogcache = nil
  0x415616		833d03780c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41561d		0f85b5000000		JNE 0x4156d8				
  0x415623		48c7052ac70a0000000000	MOVQ $0x0, runtime.sched+184(SB)	
	unlock(&sched.sudoglock)
  0x41562e		488d051bc70a00		LEAQ runtime.sched+176(SB), AX	
  0x415635		48890424		MOVQ AX, 0(SP)			
  0x415639		e85232ffff		CALL runtime.unlock(SB)		
	lock(&sched.deferlock)
  0x41563e		488d051bc70a00		LEAQ runtime.sched+192(SB), AX	
  0x415645		48890424		MOVQ AX, 0(SP)			
  0x415649		e89230ffff		CALL runtime.lock(SB)		
  0x41564e		31c0			XORL AX, AX			
	for i := range sched.deferpool {
  0x415650		eb46			JMP 0x415698		
		for d = sched.deferpool[i]; d != nil; d = dlink {
  0x415652		4889da			MOVQ BX, DX		
  0x415655		4885d2			TESTQ DX, DX		
  0x415658		742a			JE 0x415684		
			dlink = d.link
  0x41565a		488b5a28		MOVQ 0x28(DX), BX	
			d.link = nil
  0x41565e		833dbb770c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x415665		750a			JNE 0x415671				
  0x415667		48c7422800000000	MOVQ $0x0, 0x28(DX)			
  0x41566f		ebe1			JMP 0x415652				
			dlink = d.link
  0x415671		488d7a28		LEAQ 0x28(DX), DI	
	for i := range sched.deferpool {
  0x415675		4889c2			MOVQ AX, DX		
			d.link = nil
  0x415678		31c0			XORL AX, AX			
  0x41567a		e801400300		CALL runtime.gcWriteBarrier(SB)	
		sched.deferpool[i] = nil
  0x41567f		4889d0			MOVQ DX, AX		
			d.link = nil
  0x415682		ebce			JMP 0x415652		
		sched.deferpool[i] = nil
  0x415684		833d95770c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41568b		751e			JNE 0x4156ab				
  0x41568d		48c704c100000000	MOVQ $0x0, 0(CX)(AX*8)			
	for i := range sched.deferpool {
  0x415695		48ffc0			INCQ AX			
  0x415698		4883f805		CMPQ $0x5, AX		
  0x41569c		7d20			JGE 0x4156be		
		for d = sched.deferpool[i]; d != nil; d = dlink {
  0x41569e		488d0dc3c60a00		LEAQ runtime.sched+200(SB), CX	
  0x4156a5		488b14c1		MOVQ 0(CX)(AX*8), DX		
  0x4156a9		ebaa			JMP 0x415655			
  0x4156ab		488d3cc1		LEAQ 0(CX)(AX*8), DI		
	for i := range sched.deferpool {
  0x4156af		4889c1			MOVQ AX, CX		
		sched.deferpool[i] = nil
  0x4156b2		31c0			XORL AX, AX			
  0x4156b4		e8c73f0300		CALL runtime.gcWriteBarrier(SB)	
	for i := range sched.deferpool {
  0x4156b9		4889c8			MOVQ CX, AX		
		sched.deferpool[i] = nil
  0x4156bc		ebd7			JMP 0x415695		
	unlock(&sched.deferlock)
  0x4156be		488d059bc60a00		LEAQ runtime.sched+192(SB), AX	
  0x4156c5		48890424		MOVQ AX, 0(SP)			
  0x4156c9		e8c231ffff		CALL runtime.unlock(SB)		
}
  0x4156ce		488b6c2408		MOVQ 0x8(SP), BP	
  0x4156d3		4883c410		ADDQ $0x10, SP		
  0x4156d7		c3			RET			
	sched.sudogcache = nil
  0x4156d8		488d3d79c60a00		LEAQ runtime.sched+184(SB), DI	
  0x4156df		31c0			XORL AX, AX			
  0x4156e1		e89a3f0300		CALL runtime.gcWriteBarrier(SB)	
  0x4156e6		e943ffffff		JMP 0x41562e			
		poolcleanup()
  0x4156eb		488b02			MOVQ 0(DX), AX		
  0x4156ee		ffd0			CALL AX			
  0x4156f0		e9dcfeffff		JMP 0x4155d1		
func clearpools() {
  0x4156f5		e886210300		CALL runtime.morestack_noctxt(SB)	
  0x4156fa		e9a1feffff		JMP runtime.clearpools(SB)		

TEXT runtime.itoaDiv(SB) /usr/local/go/src/runtime/mgc.go
func itoaDiv(buf []byte, val uint64, dec int) []byte {
  0x415700		4883ec08		SUBQ $0x8, SP		
  0x415704		48892c24		MOVQ BP, 0(SP)		
  0x415708		488d2c24		LEAQ 0(SP), BP		
	i := len(buf) - 1
  0x41570c		488b4c2418		MOVQ 0x18(SP), CX	
  0x415711		488d51ff		LEAQ -0x1(CX), DX	
	idec := i - dec
  0x415715		488b5c2430		MOVQ 0x30(SP), BX	
  0x41571a		4889d6			MOVQ DX, SI		
  0x41571d		4829da			SUBQ BX, DX		
	for val >= 10 || i >= idec {
  0x415720		488b5c2410		MOVQ 0x10(SP), BX	
  0x415725		488b7c2428		MOVQ 0x28(SP), DI	
  0x41572a		eb06			JMP 0x415732		
  0x41572c		4889d7			MOVQ DX, DI		
  0x41572f		4c89c2			MOVQ R8, DX		
  0x415732		4883ff0a		CMPQ $0xa, DI		
  0x415736		7249			JB 0x415781		
		buf[i] = byte(val%10 + '0')
  0x415738		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
	idec := i - dec
  0x415742		4989d0			MOVQ DX, R8		
		buf[i] = byte(val%10 + '0')
  0x415745		48f7e7			MULQ DI			
  0x415748		48c1ea03		SHRQ $0x3, DX		
  0x41574c		4c8d0c92		LEAQ 0(DX)(DX*4), R9	
  0x415750		49d1e1			SHLQ $0x1, R9		
  0x415753		4c29cf			SUBQ R9, DI		
  0x415756		4839ce			CMPQ CX, SI		
  0x415759		7378			JAE 0x4157d3		
  0x41575b		4883c730		ADDQ $0x30, DI		
  0x41575f		40883c33		MOVB DI, 0(BX)(SI*1)	
		i--
  0x415763		488d7eff		LEAQ -0x1(SI), DI	
		if i == idec {
  0x415767		4c39c7			CMPQ R8, DI		
  0x41576a		7510			JNE 0x41577c		
			buf[i] = '.'
  0x41576c		4839cf			CMPQ CX, DI			
  0x41576f		735b			JAE 0x4157cc			
  0x415771		c6441eff2e		MOVB $0x2e, -0x1(SI)(BX*1)	
			i--
  0x415776		4883c6fe		ADDQ $-0x2, SI		
  0x41577a		ebb0			JMP 0x41572c		
	for val >= 10 || i >= idec {
  0x41577c		4889fe			MOVQ DI, SI		
		if i == idec {
  0x41577f		ebab			JMP 0x41572c		
	for val >= 10 || i >= idec {
  0x415781		4839d6			CMPQ DX, SI		
  0x415784		7db2			JGE 0x415738		
	buf[i] = byte(val + '0')
  0x415786		4839ce			CMPQ CX, SI		
  0x415789		733a			JAE 0x4157c5		
  0x41578b		488d4730		LEAQ 0x30(DI), AX	
  0x41578f		880433			MOVB AL, 0(BX)(SI*1)	
	return buf[i:]
  0x415792		488b442420		MOVQ 0x20(SP), AX	
  0x415797		4829f0			SUBQ SI, AX		
  0x41579a		4889c2			MOVQ AX, DX		
  0x41579d		48f7d8			NEGQ AX			
  0x4157a0		48c1f83f		SARQ $0x3f, AX		
  0x4157a4		4821f0			ANDQ SI, AX		
  0x4157a7		4801d8			ADDQ BX, AX		
  0x4157aa		4889442438		MOVQ AX, 0x38(SP)	
  0x4157af		4829f1			SUBQ SI, CX		
  0x4157b2		48894c2440		MOVQ CX, 0x40(SP)	
  0x4157b7		4889542448		MOVQ DX, 0x48(SP)	
  0x4157bc		488b2c24		MOVQ 0(SP), BP		
  0x4157c0		4883c408		ADDQ $0x8, SP		
  0x4157c4		c3			RET			
	buf[i] = byte(val + '0')
  0x4157c5		e856c70000		CALL runtime.panicindex(SB)	
  0x4157ca		0f0b			UD2				
			buf[i] = '.'
  0x4157cc		e84fc70000		CALL runtime.panicindex(SB)	
  0x4157d1		0f0b			UD2				
		buf[i] = byte(val%10 + '0')
  0x4157d3		e848c70000		CALL runtime.panicindex(SB)	
  0x4157d8		0f0b			UD2				

TEXT runtime.fmtNSAsMS(SB) /usr/local/go/src/runtime/mgc.go
func fmtNSAsMS(buf []byte, ns uint64) []byte {
  0x4157e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4157e9		483b6110		CMPQ 0x10(CX), SP	
  0x4157ed		0f8666010000		JBE 0x415959		
  0x4157f3		4883ec48		SUBQ $0x48, SP		
  0x4157f7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4157fc		488d6c2440		LEAQ 0x40(SP), BP	
	if ns >= 10e6 {
  0x415801		488b4c2468		MOVQ 0x68(SP), CX	
  0x415806		4881f980969800		CMPQ $0x989680, CX	
  0x41580d		0f83d3000000		JAE 0x4158e6		
	x := ns / 1e3
  0x415813		48d1e9			SHRQ $0x1, CX			
  0x415816		48b83cdf4f8d976e1283	MOVQ $0x83126e978d4fdf3c, AX	
  0x415820		48f7e1			MULQ CX				
  0x415823		48c1ea08		SHRQ $0x8, DX			
	if x == 0 {
  0x415827		4885d2			TESTQ DX, DX		
  0x41582a		747f			JE 0x4158ab		
  0x41582c		b803000000		MOVL $0x3, AX		
	for x >= 100 {
  0x415831		eb1b			JMP 0x41584e		
	return itoaDiv(buf, x, dec)
  0x415833		4889c1			MOVQ AX, CX		
		x /= 10
  0x415836		4889d0			MOVQ DX, AX			
  0x415839		48bbcdcccccccccccccc	MOVQ $0xcccccccccccccccd, BX	
  0x415843		48f7e3			MULQ BX				
  0x415846		48c1ea03		SHRQ $0x3, DX			
		dec--
  0x41584a		488d41ff		LEAQ -0x1(CX), AX	
	for x >= 100 {
  0x41584e		4883fa64		CMPQ $0x64, DX		
  0x415852		73df			JAE 0x415833		
	return itoaDiv(buf, x, dec)
  0x415854		488b4c2450		MOVQ 0x50(SP), CX		
  0x415859		48890c24		MOVQ CX, 0(SP)			
  0x41585d		488b4c2458		MOVQ 0x58(SP), CX		
  0x415862		48894c2408		MOVQ CX, 0x8(SP)		
  0x415867		488b4c2460		MOVQ 0x60(SP), CX		
  0x41586c		48894c2410		MOVQ CX, 0x10(SP)		
  0x415871		4889542418		MOVQ DX, 0x18(SP)		
  0x415876		4889442420		MOVQ AX, 0x20(SP)		
  0x41587b		e880feffff		CALL runtime.itoaDiv(SB)	
  0x415880		488b442428		MOVQ 0x28(SP), AX		
  0x415885		488b4c2430		MOVQ 0x30(SP), CX		
  0x41588a		488b542438		MOVQ 0x38(SP), DX		
  0x41588f		4889442470		MOVQ AX, 0x70(SP)		
  0x415894		48894c2478		MOVQ CX, 0x78(SP)		
  0x415899		4889942480000000	MOVQ DX, 0x80(SP)		
  0x4158a1		488b6c2440		MOVQ 0x40(SP), BP		
  0x4158a6		4883c448		ADDQ $0x48, SP			
  0x4158aa		c3			RET				
		buf[0] = '0'
  0x4158ab		488b442458		MOVQ 0x58(SP), AX	
  0x4158b0		4885c0			TESTQ AX, AX		
  0x4158b3		0f8699000000		JBE 0x415952		
  0x4158b9		488b442450		MOVQ 0x50(SP), AX	
  0x4158be		c60030			MOVB $0x30, 0(AX)	
		return buf[:1]
  0x4158c1		4889442470		MOVQ AX, 0x70(SP)	
  0x4158c6		48c744247801000000	MOVQ $0x1, 0x78(SP)	
  0x4158cf		488b442460		MOVQ 0x60(SP), AX	
  0x4158d4		4889842480000000	MOVQ AX, 0x80(SP)	
  0x4158dc		488b6c2440		MOVQ 0x40(SP), BP	
  0x4158e1		4883c448		ADDQ $0x48, SP		
  0x4158e5		c3			RET			
		return itoaDiv(buf, ns/1e6, 0)
  0x4158e6		488b542450		MOVQ 0x50(SP), DX		
  0x4158eb		48891424		MOVQ DX, 0(SP)			
  0x4158ef		488b542458		MOVQ 0x58(SP), DX		
  0x4158f4		4889542408		MOVQ DX, 0x8(SP)		
  0x4158f9		488b542460		MOVQ 0x60(SP), DX		
  0x4158fe		4889542410		MOVQ DX, 0x10(SP)		
  0x415903		48b8b6696caf05bd3786	MOVQ $0x8637bd05af6c69b6, AX	
  0x41590d		48f7e1			MULQ CX				
  0x415910		48c1ea13		SHRQ $0x13, DX			
  0x415914		4889542418		MOVQ DX, 0x18(SP)		
  0x415919		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x415922		e8d9fdffff		CALL runtime.itoaDiv(SB)	
  0x415927		488b4c2438		MOVQ 0x38(SP), CX		
  0x41592c		488b542430		MOVQ 0x30(SP), DX		
  0x415931		488b5c2428		MOVQ 0x28(SP), BX		
  0x415936		48895c2470		MOVQ BX, 0x70(SP)		
  0x41593b		4889542478		MOVQ DX, 0x78(SP)		
  0x415940		48898c2480000000	MOVQ CX, 0x80(SP)		
  0x415948		488b6c2440		MOVQ 0x40(SP), BP		
  0x41594d		4883c448		ADDQ $0x48, SP			
  0x415951		c3			RET				
		buf[0] = '0'
  0x415952		e8c9c50000		CALL runtime.panicindex(SB)	
  0x415957		0f0b			UD2				
func fmtNSAsMS(buf []byte, ns uint64) []byte {
  0x415959		e8221f0300		CALL runtime.morestack_noctxt(SB)	
  0x41595e		e97dfeffff		JMP runtime.fmtNSAsMS(SB)		

TEXT runtime.(*treapNode).pred(SB) /usr/local/go/src/runtime/mgclarge.go
func (t *treapNode) pred() *treapNode {
  0x415970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415979		483b6110		CMPQ 0x10(CX), SP	
  0x41597d		0f86e6000000		JBE 0x415a69		
  0x415983		4883ec20		SUBQ $0x20, SP		
  0x415987		48896c2418		MOVQ BP, 0x18(SP)	
  0x41598c		488d6c2418		LEAQ 0x18(SP), BP	
	if t.left != nil {
  0x415991		488b442428		MOVQ 0x28(SP), AX	
  0x415996		488b4808		MOVQ 0x8(AX), CX	
  0x41599a		4885c9			TESTQ CX, CX		
  0x41599d		7505			JNE 0x4159a4		
  0x41599f		eb1d			JMP 0x4159be		
		for t.right != nil {
  0x4159a1		4889c1			MOVQ AX, CX		
  0x4159a4		488b01			MOVQ 0(CX), AX		
  0x4159a7		4885c0			TESTQ AX, AX		
  0x4159aa		75f5			JNE 0x4159a1		
		return t
  0x4159ac		48894c2430		MOVQ CX, 0x30(SP)	
  0x4159b1		488b6c2418		MOVQ 0x18(SP), BP	
  0x4159b6		4883c420		ADDQ $0x20, SP		
  0x4159ba		c3			RET			
	for t.parent != nil && t.parent.right != t {
  0x4159bb		4889c8			MOVQ CX, AX		
  0x4159be		488b4810		MOVQ 0x10(AX), CX	
  0x4159c2		4885c9			TESTQ CX, CX		
  0x4159c5		740d			JE 0x4159d4		
  0x4159c7		483901			CMPQ AX, 0(CX)		
  0x4159ca		7408			JE 0x4159d4		
		if t.parent.left != t {
  0x4159cc		48394108		CMPQ AX, 0x8(CX)	
  0x4159d0		74e9			JE 0x4159bb		
  0x4159d2		eb0f			JMP 0x4159e3		
	return t.parent
  0x4159d4		48894c2430		MOVQ CX, 0x30(SP)	
  0x4159d9		488b6c2418		MOVQ 0x18(SP), BP	
  0x4159de		4883c420		ADDQ $0x20, SP		
  0x4159e2		c3			RET			
	for t.parent != nil && t.parent.right != t {
  0x4159e3		4889442428		MOVQ AX, 0x28(SP)	
			println("runtime: predecessor t=", t, "t.spanKey=", t.spanKey)
  0x4159e8		488b4820		MOVQ 0x20(AX), CX		
  0x4159ec		48894c2410		MOVQ CX, 0x10(SP)		
  0x4159f1		e8cae40000		CALL runtime.printlock(SB)	
  0x4159f6		488d0525b50500		LEAQ 0x5b525(IP), AX		
  0x4159fd		48890424		MOVQ AX, 0(SP)			
  0x415a01		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x415a0a		e8e1ed0000		CALL runtime.printstring(SB)	
  0x415a0f		488b442428		MOVQ 0x28(SP), AX		
  0x415a14		48890424		MOVQ AX, 0(SP)			
  0x415a18		e893ed0000		CALL runtime.printpointer(SB)	
  0x415a1d		488d0511a00500		LEAQ 0x5a011(IP), AX		
  0x415a24		48890424		MOVQ AX, 0(SP)			
  0x415a28		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x415a31		e8baed0000		CALL runtime.printstring(SB)	
  0x415a36		488b442410		MOVQ 0x10(SP), AX		
  0x415a3b		48890424		MOVQ AX, 0(SP)			
  0x415a3f		e86ced0000		CALL runtime.printpointer(SB)	
  0x415a44		e807e70000		CALL runtime.printnl(SB)	
  0x415a49		e8f2e40000		CALL runtime.printunlock(SB)	
			throw("node is not its parent's child")
  0x415a4e		488d05b5c10500		LEAQ 0x5c1b5(IP), AX	
  0x415a55		48890424		MOVQ AX, 0(SP)		
  0x415a59		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x415a62		e819da0000		CALL runtime.throw(SB)	
  0x415a67		0f0b			UD2			
func (t *treapNode) pred() *treapNode {
  0x415a69		e8121e0300		CALL runtime.morestack_noctxt(SB)	
  0x415a6e		e9fdfeffff		JMP runtime.(*treapNode).pred(SB)	

TEXT runtime.(*treapNode).succ(SB) /usr/local/go/src/runtime/mgclarge.go
func (t *treapNode) succ() *treapNode {
  0x415a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415a89		483b6110		CMPQ 0x10(CX), SP	
  0x415a8d		0f86e6000000		JBE 0x415b79		
  0x415a93		4883ec20		SUBQ $0x20, SP		
  0x415a97		48896c2418		MOVQ BP, 0x18(SP)	
  0x415a9c		488d6c2418		LEAQ 0x18(SP), BP	
	if t.right != nil {
  0x415aa1		488b442428		MOVQ 0x28(SP), AX	
  0x415aa6		488b08			MOVQ 0(AX), CX		
  0x415aa9		4885c9			TESTQ CX, CX		
  0x415aac		7505			JNE 0x415ab3		
  0x415aae		eb1e			JMP 0x415ace		
		for t.left != nil {
  0x415ab0		4889c1			MOVQ AX, CX		
  0x415ab3		488b4108		MOVQ 0x8(CX), AX	
  0x415ab7		4885c0			TESTQ AX, AX		
  0x415aba		75f4			JNE 0x415ab0		
		return t
  0x415abc		48894c2430		MOVQ CX, 0x30(SP)	
  0x415ac1		488b6c2418		MOVQ 0x18(SP), BP	
  0x415ac6		4883c420		ADDQ $0x20, SP		
  0x415aca		c3			RET			
	for t.parent != nil && t.parent.left != t {
  0x415acb		4889c8			MOVQ CX, AX		
  0x415ace		488b4810		MOVQ 0x10(AX), CX	
  0x415ad2		4885c9			TESTQ CX, CX		
  0x415ad5		740d			JE 0x415ae4		
  0x415ad7		48394108		CMPQ AX, 0x8(CX)	
  0x415adb		7407			JE 0x415ae4		
		if t.parent.right != t {
  0x415add		483901			CMPQ AX, 0(CX)		
  0x415ae0		74e9			JE 0x415acb		
  0x415ae2		eb0f			JMP 0x415af3		
	return t.parent
  0x415ae4		48894c2430		MOVQ CX, 0x30(SP)	
  0x415ae9		488b6c2418		MOVQ 0x18(SP), BP	
  0x415aee		4883c420		ADDQ $0x20, SP		
  0x415af2		c3			RET			
	for t.parent != nil && t.parent.left != t {
  0x415af3		4889442428		MOVQ AX, 0x28(SP)	
			println("runtime: predecessor t=", t, "t.spanKey=", t.spanKey)
  0x415af8		488b4820		MOVQ 0x20(AX), CX		
  0x415afc		48894c2410		MOVQ CX, 0x10(SP)		
  0x415b01		e8bae30000		CALL runtime.printlock(SB)	
  0x415b06		488d0515b40500		LEAQ 0x5b415(IP), AX		
  0x415b0d		48890424		MOVQ AX, 0(SP)			
  0x415b11		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x415b1a		e8d1ec0000		CALL runtime.printstring(SB)	
  0x415b1f		488b442428		MOVQ 0x28(SP), AX		
  0x415b24		48890424		MOVQ AX, 0(SP)			
  0x415b28		e883ec0000		CALL runtime.printpointer(SB)	
  0x415b2d		488d05019f0500		LEAQ 0x59f01(IP), AX		
  0x415b34		48890424		MOVQ AX, 0(SP)			
  0x415b38		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x415b41		e8aaec0000		CALL runtime.printstring(SB)	
  0x415b46		488b442410		MOVQ 0x10(SP), AX		
  0x415b4b		48890424		MOVQ AX, 0(SP)			
  0x415b4f		e85cec0000		CALL runtime.printpointer(SB)	
  0x415b54		e8f7e50000		CALL runtime.printnl(SB)	
  0x415b59		e8e2e30000		CALL runtime.printunlock(SB)	
			throw("node is not its parent's child")
  0x415b5e		488d05a5c00500		LEAQ 0x5c0a5(IP), AX	
  0x415b65		48890424		MOVQ AX, 0(SP)		
  0x415b69		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x415b72		e809d90000		CALL runtime.throw(SB)	
  0x415b77		0f0b			UD2			
func (t *treapNode) succ() *treapNode {
  0x415b79		e8021d0300		CALL runtime.morestack_noctxt(SB)	
  0x415b7e		e9fdfeffff		JMP runtime.(*treapNode).succ(SB)	

TEXT runtime.treapIter.prev(SB) /usr/local/go/src/runtime/mgclarge.go
func (i treapIter) prev() treapIter {
  0x415b90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415b99		483b6110		CMPQ 0x10(CX), SP	
  0x415b9d		7630			JBE 0x415bcf		
  0x415b9f		4883ec18		SUBQ $0x18, SP		
  0x415ba3		48896c2410		MOVQ BP, 0x10(SP)	
  0x415ba8		488d6c2410		LEAQ 0x10(SP), BP	
	i.t = i.t.pred()
  0x415bad		488b442420		MOVQ 0x20(SP), AX			
  0x415bb2		48890424		MOVQ AX, 0(SP)				
  0x415bb6		e8b5fdffff		CALL runtime.(*treapNode).pred(SB)	
  0x415bbb		488b442408		MOVQ 0x8(SP), AX			
	return i
  0x415bc0		4889442428		MOVQ AX, 0x28(SP)	
  0x415bc5		488b6c2410		MOVQ 0x10(SP), BP	
  0x415bca		4883c418		ADDQ $0x18, SP		
  0x415bce		c3			RET			
func (i treapIter) prev() treapIter {
  0x415bcf		e8ac1c0300		CALL runtime.morestack_noctxt(SB)	
  0x415bd4		ebba			JMP runtime.treapIter.prev(SB)		

TEXT runtime.(*mTreap).start(SB) /usr/local/go/src/runtime/mgclarge.go
	t := root.treap
  0x415be0		488b442408		MOVQ 0x8(SP), AX	
  0x415be5		488b00			MOVQ 0(AX), AX		
	if t == nil {
  0x415be8		4885c0			TESTQ AX, AX		
  0x415beb		7505			JNE 0x415bf2		
  0x415bed		eb12			JMP 0x415c01		
	for t.left != nil {
  0x415bef		4889c8			MOVQ CX, AX		
  0x415bf2		488b4808		MOVQ 0x8(AX), CX	
  0x415bf6		4885c9			TESTQ CX, CX		
  0x415bf9		75f4			JNE 0x415bef		
	return treapIter{t: t}
  0x415bfb		4889442410		MOVQ AX, 0x10(SP)	
  0x415c00		c3			RET			
		return treapIter{}
  0x415c01		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x415c0a		c3			RET			

TEXT runtime.(*mTreap).end(SB) /usr/local/go/src/runtime/mgclarge.go
	t := root.treap
  0x415c10		488b442408		MOVQ 0x8(SP), AX	
  0x415c15		488b00			MOVQ 0(AX), AX		
	if t == nil {
  0x415c18		4885c0			TESTQ AX, AX		
  0x415c1b		7505			JNE 0x415c22		
  0x415c1d		eb11			JMP 0x415c30		
	for t.right != nil {
  0x415c1f		4889c8			MOVQ CX, AX		
  0x415c22		488b08			MOVQ 0(AX), CX		
  0x415c25		4885c9			TESTQ CX, CX		
  0x415c28		75f5			JNE 0x415c1f		
	return treapIter{t: t}
  0x415c2a		4889442410		MOVQ AX, 0x10(SP)	
  0x415c2f		c3			RET			
		return treapIter{}
  0x415c30		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x415c39		c3			RET			

TEXT runtime.(*mTreap).insert(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) insert(span *mspan) {
  0x415c40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415c49		483b6110		CMPQ 0x10(CX), SP	
  0x415c4d		0f86a6020000		JBE 0x415ef9		
  0x415c53		4883ec40		SUBQ $0x40, SP		
  0x415c57		48896c2438		MOVQ BP, 0x38(SP)	
  0x415c5c		488d6c2438		LEAQ 0x38(SP), BP	
	npages := span.npages
  0x415c61		488b442450		MOVQ 0x50(SP), AX	
  0x415c66		488b4820		MOVQ 0x20(AX), CX	
	for t := *pt; t != nil; t = *pt {
  0x415c6a		488b542448		MOVQ 0x48(SP), DX	
  0x415c6f		488b1a			MOVQ 0(DX), BX		
func (root *mTreap) insert(span *mspan) {
  0x415c72		4889d6			MOVQ DX, SI		
  0x415c75		31ff			XORL DI, DI		
	for t := *pt; t != nil; t = *pt {
  0x415c77		eb0c			JMP 0x415c85		
  0x415c79		4c8b03			MOVQ 0(BX), R8		
	t.parent = last
  0x415c7c		4889d7			MOVQ DX, DI		
	*pt = t // t now at a leaf.
  0x415c7f		4889da			MOVQ BX, DX		
	for t := *pt; t != nil; t = *pt {
  0x415c82		4c89c3			MOVQ R8, BX		
  0x415c85		4885db			TESTQ BX, BX		
  0x415c88		7454			JE 0x415cde		
		if t.npagesKey < npages {
  0x415c8a		488b5318		MOVQ 0x18(BX), DX	
  0x415c8e		4839ca			CMPQ CX, DX		
  0x415c91		7305			JAE 0x415c98		
	for t := *pt; t != nil; t = *pt {
  0x415c93		4889da			MOVQ BX, DX		
			pt = &t.right
  0x415c96		ebe1			JMP 0x415c79		
		} else if t.npagesKey > npages {
  0x415c98		760f			JBE 0x415ca9		
			pt = &t.left
  0x415c9a		488d5308		LEAQ 0x8(BX), DX	
	t.parent = last
  0x415c9e		4889d7			MOVQ DX, DI		
  0x415ca1		4889da			MOVQ BX, DX		
	for t := *pt; t != nil; t = *pt {
  0x415ca4		4889fb			MOVQ DI, BX		
  0x415ca7		ebd0			JMP 0x415c79		
		} else if t.spanKey.base() < span.base() {
  0x415ca9		488b5320		MOVQ 0x20(BX), DX	
  0x415cad		90			NOPL			
  0x415cae		90			NOPL			
	return s.startAddr
  0x415caf		488b5218		MOVQ 0x18(DX), DX	
  0x415cb3		488b7818		MOVQ 0x18(AX), DI	
		} else if t.spanKey.base() < span.base() {
  0x415cb7		4839fa			CMPQ DI, DX		
  0x415cba		730e			JAE 0x415cca		
	for t := *pt; t != nil; t = *pt {
  0x415cbc		4889da			MOVQ BX, DX		
	t.parent = last
  0x415cbf		4889df			MOVQ BX, DI		
  0x415cc2		4889d3			MOVQ DX, BX		
	for t := *pt; t != nil; t = *pt {
  0x415cc5		4889fa			MOVQ DI, DX		
  0x415cc8		ebd4			JMP 0x415c9e		
		} else if t.spanKey.base() > span.base() {
  0x415cca		90			NOPL			
  0x415ccb		90			NOPL			
  0x415ccc		0f860c020000		JBE 0x415ede		
			pt = &t.left
  0x415cd2		488d7b08		LEAQ 0x8(BX), DI	
	t.parent = last
  0x415cd6		4889da			MOVQ BX, DX		
	for t := *pt; t != nil; t = *pt {
  0x415cd9		4889fb			MOVQ DI, BX		
  0x415cdc		ebe1			JMP 0x415cbf		
	*pt = t // t now at a leaf.
  0x415cde		4889542418		MOVQ DX, 0x18(SP)	
	t.parent = last
  0x415ce3		48897c2420		MOVQ DI, 0x20(SP)	
	t := (*treapNode)(mheap_.treapalloc.alloc())
  0x415ce8		488d05e12e0b00		LEAQ runtime.mheap_+9616(SB), AX	
  0x415cef		48890424		MOVQ AX, 0(SP)				
  0x415cf3		e898beffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x415cf8		488b442408		MOVQ 0x8(SP), AX			
  0x415cfd		4889442430		MOVQ AX, 0x30(SP)			
	t.npagesKey = span.npages
  0x415d02		488b4c2450		MOVQ 0x50(SP), CX	
  0x415d07		488b5120		MOVQ 0x20(CX), DX	
  0x415d0b		48895018		MOVQ DX, 0x18(AX)	
	mp := getg().m
  0x415d0f		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x415d18		488b5230		MOVQ 0x30(DX), DX	
	t.priority = fastrand()
  0x415d1c		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x415d1d		8b9a20010000		MOVL 0x120(DX), BX	
  0x415d23		8bb224010000		MOVL 0x124(DX), SI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x415d29		89b220010000		MOVL SI, 0x120(DX)	
	s1 ^= s1 << 17
  0x415d2f		89df			MOVL BX, DI		
  0x415d31		c1e311			SHLL $0x11, BX		
  0x415d34		31fb			XORL DI, BX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x415d36		89f7			MOVL SI, DI		
  0x415d38		31de			XORL BX, SI		
  0x415d3a		c1eb07			SHRL $0x7, BX		
  0x415d3d		31f3			XORL SI, BX		
  0x415d3f		89fe			MOVL DI, SI		
  0x415d41		c1ef10			SHRL $0x10, DI		
  0x415d44		31df			XORL BX, DI		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x415d46		89ba24010000		MOVL DI, 0x124(DX)	
	return s0 + s1
  0x415d4c		8d143e			LEAL 0(SI)(DI*1), DX	
	t.priority = fastrand()
  0x415d4f		895028			MOVL DX, 0x28(AX)	
	t.spanKey = span
  0x415d52		48894820		MOVQ CX, 0x20(AX)	
	t.parent = last
  0x415d56		488b4c2420		MOVQ 0x20(SP), CX	
  0x415d5b		48894810		MOVQ CX, 0x10(AX)	
	*pt = t // t now at a leaf.
  0x415d5f		488b4c2418		MOVQ 0x18(SP), CX	
  0x415d64		488901			MOVQ AX, 0(CX)		
	for t.parent != nil && t.parent.priority > t.priority {
  0x415d67		488b4c2448		MOVQ 0x48(SP), CX	
  0x415d6c		eb10			JMP 0x415d7e		
  0x415d6e		488b542430		MOVQ 0x30(SP), DX	
  0x415d73		488b5c2448		MOVQ 0x48(SP), BX	
  0x415d78		4889d0			MOVQ DX, AX		
			root.rotateLeft(t.parent)
  0x415d7b		4889d9			MOVQ BX, CX		
	for t.parent != nil && t.parent.priority > t.priority {
  0x415d7e		488b5010		MOVQ 0x10(AX), DX	
  0x415d82		4885d2			TESTQ DX, DX		
  0x415d85		7441			JE 0x415dc8		
  0x415d87		8b5828			MOVL 0x28(AX), BX	
  0x415d8a		395a28			CMPL BX, 0x28(DX)	
  0x415d8d		7639			JBE 0x415dc8		
		if t != nil && t.spanKey.npages != t.npagesKey {
  0x415d8f		488b5820		MOVQ 0x20(AX), BX	
  0x415d93		488b7018		MOVQ 0x18(AX), SI	
  0x415d97		48397320		CMPQ SI, 0x20(BX)	
  0x415d9b		7550			JNE 0x415ded		
		if t.parent.left == t {
  0x415d9d		48394208		CMPQ AX, 0x8(DX)	
  0x415da1		7415			JE 0x415db8		
			if t.parent.right != t {
  0x415da3		483902			CMPQ AX, 0(DX)		
  0x415da6		752a			JNE 0x415dd2		
			root.rotateLeft(t.parent)
  0x415da8		48890c24		MOVQ CX, 0(SP)				
  0x415dac		4889542408		MOVQ DX, 0x8(SP)			
  0x415db1		e8fa030000		CALL runtime.(*mTreap).rotateLeft(SB)	
  0x415db6		ebb6			JMP 0x415d6e				
			root.rotateRight(t.parent)
  0x415db8		48890c24		MOVQ CX, 0(SP)				
  0x415dbc		4889542408		MOVQ DX, 0x8(SP)			
  0x415dc1		e8aa040000		CALL runtime.(*mTreap).rotateRight(SB)	
  0x415dc6		eba6			JMP 0x415d6e				
  0x415dc8		488b6c2438		MOVQ 0x38(SP), BP			
  0x415dcd		4883c440		ADDQ $0x40, SP				
  0x415dd1		c3			RET					
				throw("treap insert finds a broken treap")
  0x415dd2		488d05ebc40500		LEAQ 0x5c4eb(IP), AX	
  0x415dd9		48890424		MOVQ AX, 0(SP)		
  0x415ddd		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x415de6		e895d60000		CALL runtime.throw(SB)	
  0x415deb		0f0b			UD2			
		if t != nil && t.spanKey.npages != t.npagesKey {
  0x415ded		4889742410		MOVQ SI, 0x10(SP)	
			println("runtime: insert t=", t, "t.npagesKey=", t.npagesKey)
  0x415df2		e8c9e00000		CALL runtime.printlock(SB)	
  0x415df7		488d05c2a60500		LEAQ 0x5a6c2(IP), AX		
  0x415dfe		48890424		MOVQ AX, 0(SP)			
  0x415e02		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x415e0b		e8e0e90000		CALL runtime.printstring(SB)	
  0x415e10		488b442430		MOVQ 0x30(SP), AX		
  0x415e15		48890424		MOVQ AX, 0(SP)			
  0x415e19		e892e90000		CALL runtime.printpointer(SB)	
  0x415e1e		488d05fb9e0500		LEAQ 0x59efb(IP), AX		
  0x415e25		48890424		MOVQ AX, 0(SP)			
  0x415e29		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x415e32		e8b9e90000		CALL runtime.printstring(SB)	
  0x415e37		488b442410		MOVQ 0x10(SP), AX		
  0x415e3c		48890424		MOVQ AX, 0(SP)			
  0x415e40		e8fbe60000		CALL runtime.printuint(SB)	
  0x415e45		e806e30000		CALL runtime.printnl(SB)	
  0x415e4a		e8f1e00000		CALL runtime.printunlock(SB)	
			println("runtime:      t.spanKey=", t.spanKey, "t.spanKey.npages=", t.spanKey.npages)
  0x415e4f		488b442430		MOVQ 0x30(SP), AX		
  0x415e54		488b4020		MOVQ 0x20(AX), AX		
  0x415e58		4889442428		MOVQ AX, 0x28(SP)		
  0x415e5d		488b4820		MOVQ 0x20(AX), CX		
  0x415e61		48894c2410		MOVQ CX, 0x10(SP)		
  0x415e66		e855e00000		CALL runtime.printlock(SB)	
  0x415e6b		488d053db20500		LEAQ 0x5b23d(IP), AX		
  0x415e72		48890424		MOVQ AX, 0(SP)			
  0x415e76		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x415e7f		e86ce90000		CALL runtime.printstring(SB)	
  0x415e84		488b442428		MOVQ 0x28(SP), AX		
  0x415e89		48890424		MOVQ AX, 0(SP)			
  0x415e8d		e81ee90000		CALL runtime.printpointer(SB)	
  0x415e92		488d05bea40500		LEAQ 0x5a4be(IP), AX		
  0x415e99		48890424		MOVQ AX, 0(SP)			
  0x415e9d		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x415ea6		e845e90000		CALL runtime.printstring(SB)	
  0x415eab		488b442410		MOVQ 0x10(SP), AX		
  0x415eb0		48890424		MOVQ AX, 0(SP)			
  0x415eb4		e887e60000		CALL runtime.printuint(SB)	
  0x415eb9		e892e20000		CALL runtime.printnl(SB)	
  0x415ebe		e87de00000		CALL runtime.printunlock(SB)	
			throw("span and treap sizes do not match?")
  0x415ec3		488d052ac50500		LEAQ 0x5c52a(IP), AX	
  0x415eca		48890424		MOVQ AX, 0(SP)		
  0x415ece		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x415ed7		e8a4d50000		CALL runtime.throw(SB)	
  0x415edc		0f0b			UD2			
			throw("inserting span already in treap")
  0x415ede		488d05b3be0500		LEAQ 0x5beb3(IP), AX	
  0x415ee5		48890424		MOVQ AX, 0(SP)		
  0x415ee9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x415ef2		e889d50000		CALL runtime.throw(SB)	
  0x415ef7		0f0b			UD2			
func (root *mTreap) insert(span *mspan) {
  0x415ef9		e882190300		CALL runtime.morestack_noctxt(SB)	
  0x415efe		e93dfdffff		JMP runtime.(*mTreap).insert(SB)	

TEXT runtime.(*mTreap).removeNode(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) removeNode(t *treapNode) {
  0x415f10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x415f19		483b6110		CMPQ 0x10(CX), SP	
  0x415f1d		0f8601010000		JBE 0x416024		
  0x415f23		4883ec18		SUBQ $0x18, SP		
  0x415f27		48896c2410		MOVQ BP, 0x10(SP)	
  0x415f2c		488d6c2410		LEAQ 0x10(SP), BP	
	if t.spanKey.npages != t.npagesKey {
  0x415f31		488b442428		MOVQ 0x28(SP), AX	
  0x415f36		488b4820		MOVQ 0x20(AX), CX	
  0x415f3a		488b5018		MOVQ 0x18(AX), DX	
  0x415f3e		48395120		CMPQ DX, 0x20(CX)	
  0x415f42		0f85c1000000		JNE 0x416009		
	for t.right != nil || t.left != nil {
  0x415f48		488b4c2420		MOVQ 0x20(SP), CX	
  0x415f4d		eb10			JMP 0x415f5f		
  0x415f4f		488b542428		MOVQ 0x28(SP), DX	
  0x415f54		488b5c2420		MOVQ 0x20(SP), BX	
  0x415f59		4889d0			MOVQ DX, AX		
			root.rotateRight(t)
  0x415f5c		4889d9			MOVQ BX, CX		
	for t.right != nil || t.left != nil {
  0x415f5f		488b10			MOVQ 0(AX), DX		
  0x415f62		4885d2			TESTQ DX, DX		
  0x415f65		743c			JE 0x415fa3		
		if t.right == nil || t.left != nil && t.left.priority < t.right.priority {
  0x415f67		7416			JE 0x415f7f		
  0x415f69		488b5808		MOVQ 0x8(AX), BX	
  0x415f6d		4885db			TESTQ BX, BX		
  0x415f70		742d			JE 0x415f9f		
  0x415f72		8b5228			MOVL 0x28(DX), DX	
  0x415f75		395328			CMPL DX, 0x28(BX)	
  0x415f78		0f92c2			SETB DL			
  0x415f7b		84d2			TESTL DL, DL		
  0x415f7d		7410			JE 0x415f8f		
			root.rotateRight(t)
  0x415f7f		48890c24		MOVQ CX, 0(SP)				
  0x415f83		4889442408		MOVQ AX, 0x8(SP)			
  0x415f88		e8e3020000		CALL runtime.(*mTreap).rotateRight(SB)	
  0x415f8d		ebc0			JMP 0x415f4f				
			root.rotateLeft(t)
  0x415f8f		48890c24		MOVQ CX, 0(SP)				
  0x415f93		4889442408		MOVQ AX, 0x8(SP)			
  0x415f98		e813020000		CALL runtime.(*mTreap).rotateLeft(SB)	
  0x415f9d		ebb0			JMP 0x415f4f				
  0x415f9f		31d2			XORL DX, DX				
		if t.right == nil || t.left != nil && t.left.priority < t.right.priority {
  0x415fa1		ebd8			JMP 0x415f7b		
	for t.right != nil || t.left != nil {
  0x415fa3		4883780800		CMPQ $0x0, 0x8(AX)	
  0x415fa8		7405			JE 0x415faf		
  0x415faa		4885d2			TESTQ DX, DX		
  0x415fad		ebb8			JMP 0x415f67		
	if t.parent != nil {
  0x415faf		488b5010		MOVQ 0x10(AX), DX	
  0x415fb3		4885d2			TESTQ DX, DX		
  0x415fb6		7448			JE 0x416000		
		if t.parent.left == t {
  0x415fb8		48394208		CMPQ AX, 0x8(DX)	
  0x415fbc		7539			JNE 0x415ff7		
			t.parent.left = nil
  0x415fbe		48c7420800000000	MOVQ $0x0, 0x8(DX)	
	mheap_.treapalloc.free(unsafe.Pointer(t))
  0x415fc6		90			NOPL			
	f.inuse -= f.size
  0x415fc7		488b0d322c0b00		MOVQ runtime.mheap_+9664(SB), CX	
  0x415fce		482b0dfb2b0b00		SUBQ runtime.mheap_+9616(SB), CX	
  0x415fd5		48890d242c0b00		MOVQ CX, runtime.mheap_+9664(SB)	
	v.next = f.list
  0x415fdc		488b0d052c0b00		MOVQ runtime.mheap_+9640(SB), CX	
  0x415fe3		488908			MOVQ CX, 0(AX)				
	f.list = v
  0x415fe6		488905fb2b0b00		MOVQ AX, runtime.mheap_+9640(SB)	
  0x415fed		488b6c2410		MOVQ 0x10(SP), BP			
  0x415ff2		4883c418		ADDQ $0x18, SP				
  0x415ff6		c3			RET					
			t.parent.right = nil
  0x415ff7		48c70200000000		MOVQ $0x0, 0(DX)	
  0x415ffe		ebc6			JMP 0x415fc6		
		root.treap = nil
  0x416000		48c70100000000		MOVQ $0x0, 0(CX)	
  0x416007		ebbd			JMP 0x415fc6		
		throw("span and treap node npages do not match")
  0x416009		488d05c4c80500		LEAQ 0x5c8c4(IP), AX	
  0x416010		48890424		MOVQ AX, 0(SP)		
  0x416014		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x41601d		e85ed40000		CALL runtime.throw(SB)	
  0x416022		0f0b			UD2			
func (root *mTreap) removeNode(t *treapNode) {
  0x416024		e857180300		CALL runtime.morestack_noctxt(SB)	
  0x416029		e9e2feffff		JMP runtime.(*mTreap).removeNode(SB)	

TEXT runtime.(*mTreap).find(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) find(npages uintptr) *treapNode {
  0x416030		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416039		483b6110		CMPQ 0x10(CX), SP	
  0x41603d		0f8683000000		JBE 0x4160c6		
  0x416043		4883ec18		SUBQ $0x18, SP		
  0x416047		48896c2410		MOVQ BP, 0x10(SP)	
  0x41604c		488d6c2410		LEAQ 0x10(SP), BP	
	t := root.treap
  0x416051		488b442420		MOVQ 0x20(SP), AX	
  0x416056		488b00			MOVQ 0(AX), AX		
	for t != nil {
  0x416059		488b4c2428		MOVQ 0x28(SP), CX	
  0x41605e		4885c0			TESTQ AX, AX		
  0x416061		7435			JE 0x416098		
		if t.spanKey == nil {
  0x416063		4883782000		CMPQ $0x0, 0x20(AX)	
  0x416068		7441			JE 0x4160ab		
		if t.npagesKey < npages {
  0x41606a		48394818		CMPQ CX, 0x18(AX)	
  0x41606e		7305			JAE 0x416075		
			t = t.right
  0x416070		488b00			MOVQ 0(AX), AX		
  0x416073		ebe9			JMP 0x41605e		
		} else if t.left != nil && t.left.npagesKey >= npages {
  0x416075		488b5008		MOVQ 0x8(AX), DX	
  0x416079		4885d2			TESTQ DX, DX		
  0x41607c		740b			JE 0x416089		
  0x41607e		48394a18		CMPQ CX, 0x18(DX)	
  0x416082		7205			JB 0x416089		
	for t != nil {
  0x416084		4889d0			MOVQ DX, AX		
  0x416087		ebd5			JMP 0x41605e		
			return t
  0x416089		4889442430		MOVQ AX, 0x30(SP)	
  0x41608e		488b6c2410		MOVQ 0x10(SP), BP	
  0x416093		4883c418		ADDQ $0x18, SP		
  0x416097		c3			RET			
	return nil
  0x416098		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x4160a1		488b6c2410		MOVQ 0x10(SP), BP	
  0x4160a6		4883c418		ADDQ $0x18, SP		
  0x4160aa		c3			RET			
			throw("treap node with nil spanKey found")
  0x4160ab		488d0533c20500		LEAQ 0x5c233(IP), AX	
  0x4160b2		48890424		MOVQ AX, 0(SP)		
  0x4160b6		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x4160bf		e8bcd30000		CALL runtime.throw(SB)	
  0x4160c4		0f0b			UD2			
func (root *mTreap) find(npages uintptr) *treapNode {
  0x4160c6		e8b5170300		CALL runtime.morestack_noctxt(SB)	
  0x4160cb		e960ffffff		JMP runtime.(*mTreap).find(SB)		

TEXT runtime.(*mTreap).removeSpan(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) removeSpan(span *mspan) {
  0x4160d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4160d9		483b6110		CMPQ 0x10(CX), SP	
  0x4160dd		7674			JBE 0x416153		
  0x4160df		4883ec18		SUBQ $0x18, SP		
  0x4160e3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4160e8		488d6c2410		LEAQ 0x10(SP), BP	
	npages := span.npages
  0x4160ed		488b442428		MOVQ 0x28(SP), AX	
  0x4160f2		488b4820		MOVQ 0x20(AX), CX	
	t := root.treap
  0x4160f6		488b542420		MOVQ 0x20(SP), DX	
  0x4160fb		488b1a			MOVQ 0(DX), BX		
	for t.spanKey != span {
  0x4160fe		488b7320		MOVQ 0x20(BX), SI	
  0x416102		4839c6			CMPQ AX, SI		
  0x416105		7434			JE 0x41613b		
		if t.npagesKey < npages {
  0x416107		488b7b18		MOVQ 0x18(BX), DI	
  0x41610b		4839cf			CMPQ CX, DI		
  0x41610e		7305			JAE 0x416115		
			t = t.right
  0x416110		488b1b			MOVQ 0(BX), BX		
  0x416113		ebe9			JMP 0x4160fe		
		} else if t.npagesKey > npages {
  0x416115		7606			JBE 0x41611d		
			t = t.left
  0x416117		488b5b08		MOVQ 0x8(BX), BX	
  0x41611b		ebe1			JMP 0x4160fe		
		} else if t.spanKey.base() < span.base() {
  0x41611d		90			NOPL			
  0x41611e		90			NOPL			
	return s.startAddr
  0x41611f		488b7618		MOVQ 0x18(SI), SI	
  0x416123		488b7818		MOVQ 0x18(AX), DI	
		} else if t.spanKey.base() < span.base() {
  0x416127		4839fe			CMPQ DI, SI		
  0x41612a		7305			JAE 0x416131		
			t = t.right
  0x41612c		488b1b			MOVQ 0(BX), BX		
  0x41612f		ebcd			JMP 0x4160fe		
		} else if t.spanKey.base() > span.base() {
  0x416131		90			NOPL			
  0x416132		90			NOPL			
  0x416133		76c9			JBE 0x4160fe		
			t = t.left
  0x416135		488b5b08		MOVQ 0x8(BX), BX	
  0x416139		ebc3			JMP 0x4160fe		
	root.removeNode(t)
  0x41613b		48891424		MOVQ DX, 0(SP)				
  0x41613f		48895c2408		MOVQ BX, 0x8(SP)			
  0x416144		e8c7fdffff		CALL runtime.(*mTreap).removeNode(SB)	
}
  0x416149		488b6c2410		MOVQ 0x10(SP), BP	
  0x41614e		4883c418		ADDQ $0x18, SP		
  0x416152		c3			RET			
func (root *mTreap) removeSpan(span *mspan) {
  0x416153		e828170300		CALL runtime.morestack_noctxt(SB)	
  0x416158		e973ffffff		JMP runtime.(*mTreap).removeSpan(SB)	

TEXT runtime.(*mTreap).erase(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) erase(i treapIter) {
  0x416160		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416169		483b6110		CMPQ 0x10(CX), SP	
  0x41616d		7630			JBE 0x41619f		
  0x41616f		4883ec18		SUBQ $0x18, SP		
  0x416173		48896c2410		MOVQ BP, 0x10(SP)	
  0x416178		488d6c2410		LEAQ 0x10(SP), BP	
	root.removeNode(i.t)
  0x41617d		488b442420		MOVQ 0x20(SP), AX			
  0x416182		48890424		MOVQ AX, 0(SP)				
  0x416186		488b442428		MOVQ 0x28(SP), AX			
  0x41618b		4889442408		MOVQ AX, 0x8(SP)			
  0x416190		e87bfdffff		CALL runtime.(*mTreap).removeNode(SB)	
}
  0x416195		488b6c2410		MOVQ 0x10(SP), BP	
  0x41619a		4883c418		ADDQ $0x18, SP		
  0x41619e		c3			RET			
func (root *mTreap) erase(i treapIter) {
  0x41619f		e8dc160300		CALL runtime.morestack_noctxt(SB)	
  0x4161a4		ebba			JMP runtime.(*mTreap).erase(SB)		

TEXT runtime.(*mTreap).rotateLeft(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) rotateLeft(x *treapNode) {
  0x4161b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4161b9		483b6110		CMPQ 0x10(CX), SP	
  0x4161bd		0f869e000000		JBE 0x416261		
  0x4161c3		4883ec18		SUBQ $0x18, SP		
  0x4161c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4161cc		488d6c2410		LEAQ 0x10(SP), BP	
	a, y := x.left, x.right
  0x4161d1		488b442428		MOVQ 0x28(SP), AX	
  0x4161d6		488b08			MOVQ 0(AX), CX		
	p := x.parent
  0x4161d9		488b5010		MOVQ 0x10(AX), DX	
	a, y := x.left, x.right
  0x4161dd		488b5808		MOVQ 0x8(AX), BX	
	b, c := y.left, y.right
  0x4161e1		488b7108		MOVQ 0x8(CX), SI	
  0x4161e5		488b39			MOVQ 0(CX), DI		
	y.left = x
  0x4161e8		48894108		MOVQ AX, 0x8(CX)	
	x.parent = y
  0x4161ec		48894810		MOVQ CX, 0x10(AX)	
	y.right = c
  0x4161f0		488939			MOVQ DI, 0(CX)		
	if c != nil {
  0x4161f3		4885ff			TESTQ DI, DI		
  0x4161f6		7404			JE 0x4161fc		
		c.parent = y
  0x4161f8		48894f10		MOVQ CX, 0x10(DI)	
	x.left = a
  0x4161fc		48895808		MOVQ BX, 0x8(AX)	
	if a != nil {
  0x416200		4885db			TESTQ BX, BX		
  0x416203		7404			JE 0x416209		
		a.parent = x
  0x416205		48894310		MOVQ AX, 0x10(BX)	
	x.right = b
  0x416209		488930			MOVQ SI, 0(AX)		
	if b != nil {
  0x41620c		4885f6			TESTQ SI, SI		
  0x41620f		7404			JE 0x416215		
		b.parent = x
  0x416211		48894610		MOVQ AX, 0x10(SI)	
	y.parent = p
  0x416215		48895110		MOVQ DX, 0x10(CX)	
	if p == nil {
  0x416219		4885d2			TESTQ DX, DX		
  0x41621c		741e			JE 0x41623c		
	} else if p.left == x {
  0x41621e		48394208		CMPQ AX, 0x8(DX)	
  0x416222		750e			JNE 0x416232		
		p.left = y
  0x416224		48894a08		MOVQ CX, 0x8(DX)	
  0x416228		488b6c2410		MOVQ 0x10(SP), BP	
  0x41622d		4883c418		ADDQ $0x18, SP		
  0x416231		c3			RET			
		if p.right != x {
  0x416232		483902			CMPQ AX, 0(DX)		
  0x416235		750f			JNE 0x416246		
		p.right = y
  0x416237		48890a			MOVQ CX, 0(DX)		
  0x41623a		ebec			JMP 0x416228		
		root.treap = y
  0x41623c		488b442420		MOVQ 0x20(SP), AX	
  0x416241		488908			MOVQ CX, 0(AX)		
  0x416244		ebe2			JMP 0x416228		
			throw("large span treap rotateLeft")
  0x416246		488d0587b10500		LEAQ 0x5b187(IP), AX	
  0x41624d		48890424		MOVQ AX, 0(SP)		
  0x416251		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x41625a		e821d20000		CALL runtime.throw(SB)	
  0x41625f		0f0b			UD2			
func (root *mTreap) rotateLeft(x *treapNode) {
  0x416261		e81a160300		CALL runtime.morestack_noctxt(SB)	
  0x416266		e945ffffff		JMP runtime.(*mTreap).rotateLeft(SB)	

TEXT runtime.(*mTreap).rotateRight(SB) /usr/local/go/src/runtime/mgclarge.go
func (root *mTreap) rotateRight(y *treapNode) {
  0x416270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416279		483b6110		CMPQ 0x10(CX), SP	
  0x41627d		0f869a000000		JBE 0x41631d		
  0x416283		4883ec18		SUBQ $0x18, SP		
  0x416287		48896c2410		MOVQ BP, 0x10(SP)	
  0x41628c		488d6c2410		LEAQ 0x10(SP), BP	
	p := y.parent
  0x416291		488b442428		MOVQ 0x28(SP), AX	
	x, c := y.left, y.right
  0x416296		488b4808		MOVQ 0x8(AX), CX	
	p := y.parent
  0x41629a		488b5010		MOVQ 0x10(AX), DX	
	x, c := y.left, y.right
  0x41629e		488b18			MOVQ 0(AX), BX		
	a, b := x.left, x.right
  0x4162a1		488b7108		MOVQ 0x8(CX), SI	
  0x4162a5		488b39			MOVQ 0(CX), DI		
	if a != nil {
  0x4162a8		4885f6			TESTQ SI, SI		
  0x4162ab		7404			JE 0x4162b1		
		a.parent = x
  0x4162ad		48894e10		MOVQ CX, 0x10(SI)	
	x.right = y
  0x4162b1		488901			MOVQ AX, 0(CX)		
	y.parent = x
  0x4162b4		48894810		MOVQ CX, 0x10(AX)	
	y.left = b
  0x4162b8		48897808		MOVQ DI, 0x8(AX)	
	if b != nil {
  0x4162bc		4885ff			TESTQ DI, DI		
  0x4162bf		7404			JE 0x4162c5		
		b.parent = y
  0x4162c1		48894710		MOVQ AX, 0x10(DI)	
	y.right = c
  0x4162c5		488918			MOVQ BX, 0(AX)		
	if c != nil {
  0x4162c8		4885db			TESTQ BX, BX		
  0x4162cb		7404			JE 0x4162d1		
		c.parent = y
  0x4162cd		48894310		MOVQ AX, 0x10(BX)	
	x.parent = p
  0x4162d1		48895110		MOVQ DX, 0x10(CX)	
	if p == nil {
  0x4162d5		4885d2			TESTQ DX, DX		
  0x4162d8		741e			JE 0x4162f8		
	} else if p.left == y {
  0x4162da		48394208		CMPQ AX, 0x8(DX)	
  0x4162de		750e			JNE 0x4162ee		
		p.left = x
  0x4162e0		48894a08		MOVQ CX, 0x8(DX)	
  0x4162e4		488b6c2410		MOVQ 0x10(SP), BP	
  0x4162e9		4883c418		ADDQ $0x18, SP		
  0x4162ed		c3			RET			
		if p.right != y {
  0x4162ee		483902			CMPQ AX, 0(DX)		
  0x4162f1		750f			JNE 0x416302		
		p.right = x
  0x4162f3		48890a			MOVQ CX, 0(DX)		
  0x4162f6		ebec			JMP 0x4162e4		
		root.treap = x
  0x4162f8		488b442420		MOVQ 0x20(SP), AX	
  0x4162fd		488908			MOVQ CX, 0(AX)		
  0x416300		ebe2			JMP 0x4162e4		
			throw("large span treap rotateRight")
  0x416302		488d05e5b30500		LEAQ 0x5b3e5(IP), AX	
  0x416309		48890424		MOVQ AX, 0(SP)		
  0x41630d		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x416316		e865d10000		CALL runtime.throw(SB)	
  0x41631b		0f0b			UD2			
func (root *mTreap) rotateRight(y *treapNode) {
  0x41631d		e85e150300		CALL runtime.morestack_noctxt(SB)	
  0x416322		e949ffffff		JMP runtime.(*mTreap).rotateRight(SB)	

TEXT runtime.gcMarkRootPrepare(SB) /usr/local/go/src/runtime/mgcmark.go
	work.nDataRoots = 0
  0x416330		0f57c0			XORPS X0, X0			
  0x416333		0f1105eebc0a00		MOVUPS X0, runtime.work+168(SB)	
	work.nBSSRoots = 0
  0x41633a		48c705f3bc0a0000000000	MOVQ $0x0, runtime.work+184(SB)	
	for _, datap := range activeModules() {
  0x416345		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x416346		488b052bb60a00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x41634d		4885c0			TESTQ AX, AX		
  0x416350		0f8416010000		JE 0x41646c		
	return *p
  0x416356		488b08			MOVQ 0(AX), CX		
  0x416359		488b4008		MOVQ 0x8(AX), AX	
	for _, datap := range activeModules() {
  0x41635d		31d2			XORL DX, DX		
  0x41635f		eb03			JMP 0x416364		
  0x416361		48ffc2			INCQ DX			
  0x416364		4839c2			CMPQ AX, DX		
  0x416367		7d30			JGE 0x416399		
  0x416369		488b1cd1		MOVQ 0(CX)(DX*8), BX	
		nDataRoots := nBlocks(datap.edata - datap.data)
  0x41636d		90			NOPL			
  0x41636e		488bb388000000		MOVQ 0x88(BX), SI	
  0x416375		482bb380000000		SUBQ 0x80(BX), SI	
		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)
  0x41637c		488d9effff0300		LEAQ 0x3ffff(SI), BX	
  0x416383		48c1eb12		SHRQ $0x12, BX		
		if nDataRoots > work.nDataRoots {
  0x416387		48391da2bc0a00		CMPQ BX, runtime.work+176(SB)	
  0x41638e		7dd1			JGE 0x416361			
			work.nDataRoots = nDataRoots
  0x416390		48891d99bc0a00		MOVQ BX, runtime.work+176(SB)	
  0x416397		ebc8			JMP 0x416361			
	for _, datap := range activeModules() {
  0x416399		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x41639a		488b05d7b50a00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x4163a1		4885c0			TESTQ AX, AX		
  0x4163a4		0f84b9000000		JE 0x416463		
	return *p
  0x4163aa		488b4808		MOVQ 0x8(AX), CX	
  0x4163ae		488b00			MOVQ 0(AX), AX		
	for _, datap := range activeModules() {
  0x4163b1		31d2			XORL DX, DX		
  0x4163b3		eb03			JMP 0x4163b8		
  0x4163b5		48ffc2			INCQ DX			
  0x4163b8		4839ca			CMPQ CX, DX		
  0x4163bb		7d30			JGE 0x4163ed		
  0x4163bd		488b1cd0		MOVQ 0(AX)(DX*8), BX	
		nBSSRoots := nBlocks(datap.ebss - datap.bss)
  0x4163c1		90			NOPL			
  0x4163c2		488bb398000000		MOVQ 0x98(BX), SI	
  0x4163c9		482bb390000000		SUBQ 0x90(BX), SI	
		return int((bytes + rootBlockBytes - 1) / rootBlockBytes)
  0x4163d0		488d9effff0300		LEAQ 0x3ffff(SI), BX	
  0x4163d7		48c1eb12		SHRQ $0x12, BX		
		if nBSSRoots > work.nBSSRoots {
  0x4163db		48391d56bc0a00		CMPQ BX, runtime.work+184(SB)	
  0x4163e2		7dd1			JGE 0x4163b5			
			work.nBSSRoots = nBSSRoots
  0x4163e4		48891d4dbc0a00		MOVQ BX, runtime.work+184(SB)	
  0x4163eb		ebc8			JMP 0x4163b5			
	work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()
  0x4163ed		8b0565020b00		MOVL runtime.mheap_+24(SB), AX	
  0x4163f3		d1e8			SHRL $0x1, AX			
  0x4163f5		83e001			ANDL $0x1, AX			
  0x4163f8		488d0480		LEAQ 0(AX)(AX*4), AX		
  0x4163fc		90			NOPL				
	return int((atomic.Load(&b.index) + gcSweepBlockEntries - 1) / gcSweepBlockEntries)
  0x4163fd		488d0d7c020b00		LEAQ runtime.mheap_+64(SB), CX	
  0x416404		488d04c1		LEAQ 0(CX)(AX*8), AX		
  0x416408		488d4020		LEAQ 0x20(AX), AX		
  0x41640c		8b00			MOVL 0(AX), AX			
  0x41640e		05ff010000		ADDL $0x1ff, AX			
  0x416413		c1e809			SHRL $0x9, AX			
	work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()
  0x416416		48890523bc0a00		MOVQ AX, runtime.work+192(SB)	
	work.nStackRoots = int(atomic.Loaduintptr(&allglen))
  0x41641d		488b05f4680c00		MOVQ runtime.allglen(SB), AX	
  0x416424		4889051dbc0a00		MOVQ AX, runtime.work+200(SB)	
	work.markrootNext = 0
  0x41642b		c705d3bb0a0000000000	MOVL $0x0, runtime.work+136(SB)	
	work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)
  0x416435		488b05ecbb0a00		MOVQ runtime.work+168(SB), AX	
  0x41643c		480305edbb0a00		ADDQ runtime.work+176(SB), AX	
  0x416443		480305eebb0a00		ADDQ runtime.work+184(SB), AX	
  0x41644a		480305efbb0a00		ADDQ runtime.work+192(SB), AX	
  0x416451		480305f0bb0a00		ADDQ runtime.work+200(SB), AX	
  0x416458		4883c002		ADDQ $0x2, AX			
  0x41645c		8905aabb0a00		MOVL AX, runtime.work+140(SB)	
}
  0x416462		c3			RET			
  0x416463		31c0			XORL AX, AX		
  0x416465		31c9			XORL CX, CX		
	for _, datap := range activeModules() {
  0x416467		e945ffffff		JMP 0x4163b1		
  0x41646c		31c0			XORL AX, AX		
  0x41646e		31c9			XORL CX, CX		
	for _, datap := range activeModules() {
  0x416470		e9e8feffff		JMP 0x41635d		

TEXT runtime.gcMarkRootCheck(SB) /usr/local/go/src/runtime/mgcmark.go
func gcMarkRootCheck() {
  0x416480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416489		483b6110		CMPQ 0x10(CX), SP	
  0x41648d		0f862e020000		JBE 0x4166c1		
  0x416493		4883ec38		SUBQ $0x38, SP		
  0x416497		48896c2430		MOVQ BP, 0x30(SP)	
  0x41649c		488d6c2430		LEAQ 0x30(SP), BP	
	if work.markrootNext < work.markrootJobs {
  0x4164a1		8b0561bb0a00		MOVL runtime.work+136(SB), AX	
  0x4164a7		8b0d5fbb0a00		MOVL runtime.work+140(SB), CX	
  0x4164ad		39c8			CMPL CX, AX			
  0x4164af		0f8293010000		JB 0x416648			
	lock(&allglock)
  0x4164b5		488d0564680c00		LEAQ runtime.allglock(SB), AX	
  0x4164bc		48890424		MOVQ AX, 0(SP)			
  0x4164c0		e81b22ffff		CALL runtime.lock(SB)		
  0x4164c5		31c0			XORL AX, AX			
	for i := 0; i < work.nStackRoots; i++ {
  0x4164c7		eb03			JMP 0x4164cc			
  0x4164c9		48ffc0			INCQ AX				
  0x4164cc		48390575bb0a00		CMPQ AX, runtime.work+200(SB)	
  0x4164d3		7e23			JLE 0x4164f8			
		gp = allgs[i]
  0x4164d5		488b0d24b50a00		MOVQ runtime.allgs(SB), CX	
  0x4164dc		48390525b50a00		CMPQ AX, runtime.allgs+8(SB)	
  0x4164e3		0f8658010000		JBE 0x416641			
  0x4164e9		488b0cc1		MOVQ 0(CX)(AX*8), CX		
		if !gp.gcscandone {
  0x4164ed		80b9b400000000		CMPB $0x0, 0xb4(CX)	
  0x4164f4		75d3			JNE 0x4164c9		
  0x4164f6		eb1a			JMP 0x416512		
	unlock(&allglock)
  0x4164f8		488d0521680c00		LEAQ runtime.allglock(SB), AX	
  0x4164ff		48890424		MOVQ AX, 0(SP)			
  0x416503		e88823ffff		CALL runtime.unlock(SB)		
	return
  0x416508		488b6c2430		MOVQ 0x30(SP), BP	
  0x41650d		4883c438		ADDQ $0x38, SP		
  0x416511		c3			RET			
		gp = allgs[i]
  0x416512		48894c2428		MOVQ CX, 0x28(SP)	
		"status", readgstatus(gp),
  0x416517		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x416518		8b8190000000		MOVL 0x90(CX), AX	
  0x41651e		89442414		MOVL AX, 0x14(SP)	
	println("gp", gp, "goid", gp.goid,
  0x416522		488b9198000000		MOVQ 0x98(CX), DX	
  0x416529		4889542420		MOVQ DX, 0x20(SP)	
		"gcscandone", gp.gcscandone,
  0x41652e		0fb699b4000000		MOVZX 0xb4(CX), BX	
  0x416535		885c2413		MOVB BL, 0x13(SP)	
		"gcscanvalid", gp.gcscanvalid)
  0x416539		0fb6b1b5000000		MOVZX 0xb5(CX), SI	
  0x416540		4088742412		MOVB SI, 0x12(SP)	
	println("gp", gp, "goid", gp.goid,
  0x416545		e876d90000		CALL runtime.printlock(SB)	
  0x41654a		488d05988b0500		LEAQ 0x58b98(IP), AX		
  0x416551		48890424		MOVQ AX, 0(SP)			
  0x416555		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x41655e		e88de20000		CALL runtime.printstring(SB)	
  0x416563		488b442428		MOVQ 0x28(SP), AX		
  0x416568		48890424		MOVQ AX, 0(SP)			
  0x41656c		e83fe20000		CALL runtime.printpointer(SB)	
  0x416571		488d05c68c0500		LEAQ 0x58cc6(IP), AX		
  0x416578		48890424		MOVQ AX, 0(SP)			
  0x41657c		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x416585		e866e20000		CALL runtime.printstring(SB)	
  0x41658a		488b442420		MOVQ 0x20(SP), AX		
  0x41658f		48890424		MOVQ AX, 0(SP)			
  0x416593		e8a8e00000		CALL runtime.printint(SB)	
  0x416598		488d05918e0500		LEAQ 0x58e91(IP), AX		
  0x41659f		48890424		MOVQ AX, 0(SP)			
  0x4165a3		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4165ac		e83fe20000		CALL runtime.printstring(SB)	
  0x4165b1		8b442414		MOVL 0x14(SP), AX		
  0x4165b5		89c0			MOVL AX, AX			
  0x4165b7		48890424		MOVQ AX, 0(SP)			
  0x4165bb		e880df0000		CALL runtime.printuint(SB)	
  0x4165c0		488d05de930500		LEAQ 0x593de(IP), AX		
  0x4165c7		48890424		MOVQ AX, 0(SP)			
  0x4165cb		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4165d4		e817e20000		CALL runtime.printstring(SB)	
  0x4165d9		0fb6442413		MOVZX 0x13(SP), AX		
  0x4165de		880424			MOVB AL, 0(SP)			
  0x4165e1		e8badb0000		CALL runtime.printbool(SB)	
  0x4165e6		488d05aa950500		LEAQ 0x595aa(IP), AX		
  0x4165ed		48890424		MOVQ AX, 0(SP)			
  0x4165f1		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4165fa		e8f1e10000		CALL runtime.printstring(SB)	
  0x4165ff		0fb6442412		MOVZX 0x12(SP), AX		
  0x416604		880424			MOVB AL, 0(SP)			
  0x416607		e894db0000		CALL runtime.printbool(SB)	
  0x41660c		e83fdb0000		CALL runtime.printnl(SB)	
  0x416611		e82ad90000		CALL runtime.printunlock(SB)	
	unlock(&allglock) // Avoid self-deadlock with traceback.
  0x416616		488d0503670c00		LEAQ runtime.allglock(SB), AX	
  0x41661d		48890424		MOVQ AX, 0(SP)			
  0x416621		e86a22ffff		CALL runtime.unlock(SB)		
	throw("scan missed a g")
  0x416626		488d05bd980500		LEAQ 0x598bd(IP), AX	
  0x41662d		48890424		MOVQ AX, 0(SP)		
  0x416631		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x41663a		e841ce0000		CALL runtime.throw(SB)	
  0x41663f		0f0b			UD2			
		gp = allgs[i]
  0x416641		e8dab80000		CALL runtime.panicindex(SB)	
  0x416646		0f0b			UD2				
	if work.markrootNext < work.markrootJobs {
  0x416648		8944241c		MOVL AX, 0x1c(SP)	
  0x41664c		894c2418		MOVL CX, 0x18(SP)	
		print(work.markrootNext, " of ", work.markrootJobs, " markroot jobs done\n")
  0x416650		e86bd80000		CALL runtime.printlock(SB)	
  0x416655		8b44241c		MOVL 0x1c(SP), AX		
  0x416659		48890424		MOVQ AX, 0(SP)			
  0x41665d		e8dede0000		CALL runtime.printuint(SB)	
  0x416662		488d05a08a0500		LEAQ 0x58aa0(IP), AX		
  0x416669		48890424		MOVQ AX, 0(SP)			
  0x41666d		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x416676		e875e10000		CALL runtime.printstring(SB)	
  0x41667b		8b442418		MOVL 0x18(SP), AX		
  0x41667f		48890424		MOVQ AX, 0(SP)			
  0x416683		e8b8de0000		CALL runtime.printuint(SB)	
  0x416688		488d05b69e0500		LEAQ 0x59eb6(IP), AX		
  0x41668f		48890424		MOVQ AX, 0(SP)			
  0x416693		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x41669c		e84fe10000		CALL runtime.printstring(SB)	
  0x4166a1		e89ad80000		CALL runtime.printunlock(SB)	
		throw("left over markroot jobs")
  0x4166a6		488d05b7a50500		LEAQ 0x5a5b7(IP), AX	
  0x4166ad		48890424		MOVQ AX, 0(SP)		
  0x4166b1		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4166ba		e8c1cd0000		CALL runtime.throw(SB)	
  0x4166bf		0f0b			UD2			
func gcMarkRootCheck() {
  0x4166c1		e8ba110300		CALL runtime.morestack_noctxt(SB)	
  0x4166c6		e9b5fdffff		JMP runtime.gcMarkRootCheck(SB)		

TEXT runtime.markroot(SB) /usr/local/go/src/runtime/mgcmark.go
func markroot(gcw *gcWork, i uint32) {
  0x4166d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4166d9		483b6110		CMPQ 0x10(CX), SP	
  0x4166dd		0f8647030000		JBE 0x416a2a		
  0x4166e3		4883ec78		SUBQ $0x78, SP		
  0x4166e7		48896c2470		MOVQ BP, 0x70(SP)	
  0x4166ec		488d6c2470		LEAQ 0x70(SP), BP	
	baseData := baseFlushCache + uint32(work.nFlushCacheRoots)
  0x4166f1		488b0530b90a00		MOVQ runtime.work+168(SB), AX	
  0x4166f8		8d4802			LEAL 0x2(AX), CX		
	baseBSS := baseData + uint32(work.nDataRoots)
  0x4166fb		488b152eb90a00		MOVQ runtime.work+176(SB), DX	
  0x416702		8d1c02			LEAL 0(DX)(AX*1), BX		
  0x416705		8d5b02			LEAL 0x2(BX), BX		
  0x416708		01d0			ADDL DX, AX			
	baseSpans := baseBSS + uint32(work.nBSSRoots)
  0x41670a		488b1527b90a00		MOVQ runtime.work+184(SB), DX	
  0x416711		8d3410			LEAL 0(AX)(DX*1), SI		
  0x416714		8d7602			LEAL 0x2(SI), SI		
  0x416717		01d0			ADDL DX, AX			
	baseStacks := baseSpans + uint32(work.nSpanRoots)
  0x416719		488b1520b90a00		MOVQ runtime.work+192(SB), DX	
  0x416720		8d3c10			LEAL 0(AX)(DX*1), DI		
  0x416723		8d7f02			LEAL 0x2(DI), DI		
  0x416726		01d0			ADDL DX, AX			
	end := baseStacks + uint32(work.nStackRoots)
  0x416728		488b1519b90a00		MOVQ runtime.work+200(SB), DX	
  0x41672f		8d0410			LEAL 0(AX)(DX*1), AX		
  0x416732		8d4002			LEAL 0x2(AX), AX		
	case baseFlushCache <= i && i < baseData:
  0x416735		8b942488000000		MOVL 0x88(SP), DX	
  0x41673c		83fa02			CMPL $0x2, DX		
  0x41673f		7208			JB 0x416749		
  0x416741		39ca			CMPL CX, DX		
	switch {
  0x416743		0f82ae020000		JB 0x4169f7		
	case baseData <= i && i < baseBSS:
  0x416749		39d1			CMPL DX, CX		
  0x41674b		0f87b0000000		JA 0x416801		
  0x416751		39da			CMPL BX, DX		
	switch {
  0x416753		0f83a8000000		JAE 0x416801		
		for _, datap := range activeModules() {
  0x416759		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x41675a		488b0517b20a00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x416761		4885c0			TESTQ AX, AX		
  0x416764		0f848e000000		JE 0x4167f8		
	return *p
  0x41676a		488b18			MOVQ 0(AX), BX		
  0x41676d		488b4008		MOVQ 0x8(AX), AX	
	baseData := baseFlushCache + uint32(work.nFlushCacheRoots)
  0x416771		894c2428		MOVL CX, 0x28(SP)	
		for _, datap := range activeModules() {
  0x416775		4889442430		MOVQ AX, 0x30(SP)	
  0x41677a		48895c2450		MOVQ BX, 0x50(SP)	
  0x41677f		31f6			XORL SI, SI		
  0x416781		eb66			JMP 0x4167e9		
  0x416783		4889742440		MOVQ SI, 0x40(SP)	
  0x416788		488b04f3		MOVQ 0(BX)(SI*8), AX	
			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData))
  0x41678c		488bb880000000		MOVQ 0x80(AX), DI		
  0x416793		4c8b8088000000		MOVQ 0x88(AX), R8		
  0x41679a		488b8098010000		MOVQ 0x198(AX), AX		
  0x4167a1		48893c24		MOVQ DI, 0(SP)			
  0x4167a5		4929f8			SUBQ DI, R8			
  0x4167a8		4c89442408		MOVQ R8, 0x8(SP)		
  0x4167ad		4889442410		MOVQ AX, 0x10(SP)		
  0x4167b2		488b842480000000	MOVQ 0x80(SP), AX		
  0x4167ba		4889442418		MOVQ AX, 0x18(SP)		
  0x4167bf		29ca			SUBL CX, DX			
  0x4167c1		4889542420		MOVQ DX, 0x20(SP)		
  0x4167c6		e875020000		CALL runtime.markrootBlock(SB)	
		for _, datap := range activeModules() {
  0x4167cb		488b442440		MOVQ 0x40(SP), AX	
  0x4167d0		488d7001		LEAQ 0x1(AX), SI	
  0x4167d4		488b442430		MOVQ 0x30(SP), AX	
			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData))
  0x4167d9		8b4c2428		MOVL 0x28(SP), CX	
  0x4167dd		8b942488000000		MOVL 0x88(SP), DX	
		for _, datap := range activeModules() {
  0x4167e4		488b5c2450		MOVQ 0x50(SP), BX	
  0x4167e9		4839c6			CMPQ AX, SI		
  0x4167ec		7c95			JL 0x416783		
  0x4167ee		488b6c2470		MOVQ 0x70(SP), BP	
  0x4167f3		4883c478		ADDQ $0x78, SP		
  0x4167f7		c3			RET			
  0x4167f8		31c0			XORL AX, AX		
  0x4167fa		31db			XORL BX, BX		
  0x4167fc		e970ffffff		JMP 0x416771		
	case baseBSS <= i && i < baseSpans:
  0x416801		39d3			CMPL DX, BX		
  0x416803		0f87ab000000		JA 0x4168b4		
  0x416809		39f2			CMPL SI, DX		
	switch {
  0x41680b		0f83a3000000		JAE 0x4168b4		
		for _, datap := range activeModules() {
  0x416811		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x416812		488b055fb10a00		MOVQ runtime.modulesSlice(SB), AX	
	if p == nil {
  0x416819		4885c0			TESTQ AX, AX		
  0x41681c		0f8489000000		JE 0x4168ab		
	return *p
  0x416822		488b4808		MOVQ 0x8(AX), CX	
  0x416826		488b00			MOVQ 0(AX), AX		
	baseBSS := baseData + uint32(work.nDataRoots)
  0x416829		895c242c		MOVL BX, 0x2c(SP)	
		for _, datap := range activeModules() {
  0x41682d		48894c2438		MOVQ CX, 0x38(SP)	
  0x416832		4889442450		MOVQ AX, 0x50(SP)	
  0x416837		31f6			XORL SI, SI		
  0x416839		eb66			JMP 0x4168a1		
  0x41683b		4889742440		MOVQ SI, 0x40(SP)	
  0x416840		488b0cf0		MOVQ 0(AX)(SI*8), CX	
			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS))
  0x416844		488bb990000000		MOVQ 0x90(CX), DI		
  0x41684b		4c8b8198000000		MOVQ 0x98(CX), R8		
  0x416852		488b89a8010000		MOVQ 0x1a8(CX), CX		
  0x416859		48893c24		MOVQ DI, 0(SP)			
  0x41685d		4929f8			SUBQ DI, R8			
  0x416860		4c89442408		MOVQ R8, 0x8(SP)		
  0x416865		48894c2410		MOVQ CX, 0x10(SP)		
  0x41686a		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x416872		48894c2418		MOVQ CX, 0x18(SP)		
  0x416877		29da			SUBL BX, DX			
  0x416879		4889542420		MOVQ DX, 0x20(SP)		
  0x41687e		e8bd010000		CALL runtime.markrootBlock(SB)	
		for _, datap := range activeModules() {
  0x416883		488b442440		MOVQ 0x40(SP), AX	
  0x416888		488d7001		LEAQ 0x1(AX), SI	
  0x41688c		488b442450		MOVQ 0x50(SP), AX	
  0x416891		488b4c2438		MOVQ 0x38(SP), CX	
			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS))
  0x416896		8b942488000000		MOVL 0x88(SP), DX	
  0x41689d		8b5c242c		MOVL 0x2c(SP), BX	
		for _, datap := range activeModules() {
  0x4168a1		4839ce			CMPQ CX, SI		
  0x4168a4		7c95			JL 0x41683b		
  0x4168a6		e943ffffff		JMP 0x4167ee		
  0x4168ab		31c9			XORL CX, CX		
  0x4168ad		31c0			XORL AX, AX		
  0x4168af		e975ffffff		JMP 0x416829		
	case i == fixedRootFinalizers:
  0x4168b4		85d2			TESTL DX, DX		
  0x4168b6		7561			JNE 0x416919		
		for fb := allfin; fb != nil; fb = fb.alllink {
  0x4168b8		488b0551b00a00		MOVQ runtime.allfin(SB), AX	
  0x4168bf		eb4e			JMP 0x41690f			
  0x4168c1		4889442448		MOVQ AX, 0x48(SP)		
			cnt := uintptr(atomic.Load(&fb.cnt))
  0x4168c6		8b4810			MOVL 0x10(AX), CX	
			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw, nil)
  0x4168c9		488d5018		LEAQ 0x18(AX), DX	
  0x4168cd		48891424		MOVQ DX, 0(SP)		
			cnt := uintptr(atomic.Load(&fb.cnt))
  0x4168d1		89c9			MOVL CX, CX		
			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], gcw, nil)
  0x4168d3		488d0c89		LEAQ 0(CX)(CX*4), CX		
  0x4168d7		48c1e103		SHLQ $0x3, CX			
  0x4168db		48894c2408		MOVQ CX, 0x8(SP)		
  0x4168e0		488d0d39660c00		LEAQ runtime.finptrmask(SB), CX	
  0x4168e7		48894c2410		MOVQ CX, 0x10(SP)		
  0x4168ec		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x4168f4		48894c2418		MOVQ CX, 0x18(SP)		
  0x4168f9		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x416902		e8e91d0000		CALL runtime.scanblock(SB)	
		for fb := allfin; fb != nil; fb = fb.alllink {
  0x416907		488b442448		MOVQ 0x48(SP), AX	
  0x41690c		488b00			MOVQ 0(AX), AX		
  0x41690f		4885c0			TESTQ AX, AX		
  0x416912		75ad			JNE 0x4168c1		
  0x416914		e9d5feffff		JMP 0x4167ee		
	case i == fixedRootFreeGStacks:
  0x416919		83fa01			CMPL $0x1, DX		
  0x41691c		0f84c0000000		JE 0x4169e2		
	case baseSpans <= i && i < baseStacks:
  0x416922		39d6			CMPL DX, SI		
  0x416924		7708			JA 0x41692e		
  0x416926		39fa			CMPL DI, DX		
	switch {
  0x416928		0f8297000000		JB 0x4169c5		
		if baseStacks <= i && i < end {
  0x41692e		39d7			CMPL DX, DI		
  0x416930		0f87d9000000		JA 0x416a0f		
  0x416936		39c2			CMPL AX, DX		
  0x416938		0f83d1000000		JAE 0x416a0f		
			gp = allgs[i-baseStacks]
  0x41693e		488b05bbb00a00		MOVQ runtime.allgs(SB), AX	
  0x416945		29fa			SUBL DI, DX			
  0x416947		483915bab00a00		CMPQ DX, runtime.allgs+8(SB)	
  0x41694e		0f86b4000000		JBE 0x416a08			
  0x416954		488b04d0		MOVQ 0(AX)(DX*8), AX		
		status := readgstatus(gp) // We are not in a scan state
  0x416958		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x416959		8b8890000000		MOVL 0x90(AX), CX	
		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
  0x41695f		83f904			CMPL $0x4, CX		
  0x416962		755a			JNE 0x4169be		
  0x416964		4883b8a800000000	CMPQ $0x0, 0xa8(AX)	
  0x41696c		750e			JNE 0x41697c		
			gp.waitsince = work.tstart
  0x41696e		488b0da3b60a00		MOVQ runtime.work+152(SB), CX	
  0x416975		488988a8000000		MOVQ CX, 0xa8(AX)		
		systemstack(func() {
  0x41697c		0f57c0			XORPS X0, X0				
  0x41697f		0f11442458		MOVUPS X0, 0x58(SP)			
  0x416984		48c744246800000000	MOVQ $0x0, 0x68(SP)			
  0x41698d		488d0dfce90200		LEAQ runtime.markroot.func1(SB), CX	
  0x416994		48894c2458		MOVQ CX, 0x58(SP)			
  0x416999		4889442460		MOVQ AX, 0x60(SP)			
  0x41699e		488b842480000000	MOVQ 0x80(SP), AX			
  0x4169a6		4889442468		MOVQ AX, 0x68(SP)			
  0x4169ab		488d442458		LEAQ 0x58(SP), AX			
  0x4169b0		48890424		MOVQ AX, 0(SP)				
  0x4169b4		e8770d0300		CALL runtime.systemstack(SB)		
	switch {
  0x4169b9		e930feffff		JMP 0x4167ee		
		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
  0x4169be		83f903			CMPL $0x3, CX		
  0x4169c1		74a1			JE 0x416964		
  0x4169c3		ebb7			JMP 0x41697c		
		markrootSpans(gcw, int(i-baseSpans))
  0x4169c5		488b842480000000	MOVQ 0x80(SP), AX		
  0x4169cd		48890424		MOVQ AX, 0(SP)			
  0x4169d1		29f2			SUBL SI, DX			
  0x4169d3		4889542408		MOVQ DX, 0x8(SP)		
  0x4169d8		e853020000		CALL runtime.markrootSpans(SB)	
	switch {
  0x4169dd		e90cfeffff		JMP 0x4167ee		
		systemstack(markrootFreeGStacks)
  0x4169e2		488d05afce0500		LEAQ 0x5ceaf(IP), AX		
  0x4169e9		48890424		MOVQ AX, 0(SP)			
  0x4169ed		e83e0d0300		CALL runtime.systemstack(SB)	
	switch {
  0x4169f2		e9f7fdffff		JMP 0x4167ee		
		flushmcache(int(i - baseFlushCache))
  0x4169f7		8d42fe			LEAL -0x2(DX), AX		
  0x4169fa		48890424		MOVQ AX, 0(SP)			
  0x4169fe		e8cd9e0000		CALL runtime.flushmcache(SB)	
	switch {
  0x416a03		e9e6fdffff		JMP 0x4167ee		
			gp = allgs[i-baseStacks]
  0x416a08		e813b50000		CALL runtime.panicindex(SB)	
  0x416a0d		0f0b			UD2				
			throw("markroot: bad index")
  0x416a0f		488d05ff990500		LEAQ 0x599ff(IP), AX	
  0x416a16		48890424		MOVQ AX, 0(SP)		
  0x416a1a		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x416a23		e858ca0000		CALL runtime.throw(SB)	
  0x416a28		0f0b			UD2			
func markroot(gcw *gcWork, i uint32) {
  0x416a2a		e8510e0300		CALL runtime.morestack_noctxt(SB)	
  0x416a2f		e99cfcffff		JMP runtime.markroot(SB)		

TEXT runtime.markrootBlock(SB) /usr/local/go/src/runtime/mgcmark.go
func markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int) {
  0x416a40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416a49		483b6110		CMPQ 0x10(CX), SP	
  0x416a4d		0f8694000000		JBE 0x416ae7		
  0x416a53		4883ec30		SUBQ $0x30, SP		
  0x416a57		48896c2428		MOVQ BP, 0x28(SP)	
  0x416a5c		488d6c2428		LEAQ 0x28(SP), BP	
	b := b0 + uintptr(shard)*rootBlockBytes
  0x416a61		488b442458		MOVQ 0x58(SP), AX	
  0x416a66		4889c1			MOVQ AX, CX		
  0x416a69		48c1e012		SHLQ $0x12, AX		
  0x416a6d		488b542438		MOVQ 0x38(SP), DX	
  0x416a72		488d1c10		LEAQ 0(AX)(DX*1), BX	
	if b >= b0+n0 {
  0x416a76		488b742440		MOVQ 0x40(SP), SI	
  0x416a7b		4801d6			ADDQ DX, SI		
  0x416a7e		4839f3			CMPQ SI, BX		
  0x416a81		720a			JB 0x416a8d		
		return
  0x416a83		488b6c2428		MOVQ 0x28(SP), BP	
  0x416a88		4883c430		ADDQ $0x30, SP		
  0x416a8c		c3			RET			
	ptrmask := (*uint8)(add(unsafe.Pointer(ptrmask0), uintptr(shard)*(rootBlockBytes/(8*sys.PtrSize))))
  0x416a8d		90			NOPL			
	scanblock(b, n, ptrmask, gcw, nil)
  0x416a8e		48891c24		MOVQ BX, 0(SP)		
	if b+n > b0+n0 {
  0x416a92		488d0402		LEAQ 0(DX)(AX*1), AX	
  0x416a96		488d8000000400		LEAQ 0x40000(AX), AX	
		n = b0 + n0 - b
  0x416a9d		4889f2			MOVQ SI, DX		
  0x416aa0		4829de			SUBQ BX, SI		
	if b+n > b0+n0 {
  0x416aa3		4839d0			CMPQ DX, AX		
	scanblock(b, n, ptrmask, gcw, nil)
  0x416aa6		b800000400		MOVL $0x40000, AX	
  0x416aab		480f47c6		CMOVA SI, AX		
  0x416aaf		4889442408		MOVQ AX, 0x8(SP)	
	ptrmask := (*uint8)(add(unsafe.Pointer(ptrmask0), uintptr(shard)*(rootBlockBytes/(8*sys.PtrSize))))
  0x416ab4		48c1e10c		SHLQ $0xc, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x416ab8		488b442448		MOVQ 0x48(SP), AX	
  0x416abd		4801c8			ADDQ CX, AX		
	scanblock(b, n, ptrmask, gcw, nil)
  0x416ac0		4889442410		MOVQ AX, 0x10(SP)		
  0x416ac5		488b442450		MOVQ 0x50(SP), AX		
  0x416aca		4889442418		MOVQ AX, 0x18(SP)		
  0x416acf		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x416ad8		e8131c0000		CALL runtime.scanblock(SB)	
	if b+n > b0+n0 {
  0x416add		488b6c2428		MOVQ 0x28(SP), BP	
  0x416ae2		4883c430		ADDQ $0x30, SP		
  0x416ae6		c3			RET			
func markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int) {
  0x416ae7		e8940d0300		CALL runtime.morestack_noctxt(SB)	
  0x416aec		e94fffffff		JMP runtime.markrootBlock(SB)		

TEXT runtime.markrootFreeGStacks(SB) /usr/local/go/src/runtime/mgcmark.go
func markrootFreeGStacks() {
  0x416b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416b09		483b6110		CMPQ 0x10(CX), SP	
  0x416b0d		0f860b010000		JBE 0x416c1e		
  0x416b13		4883ec40		SUBQ $0x40, SP		
  0x416b17		48896c2438		MOVQ BP, 0x38(SP)	
  0x416b1c		488d6c2438		LEAQ 0x38(SP), BP	
	lock(&sched.gFree.lock)
  0x416b21		488d0508b20a00		LEAQ runtime.sched+144(SB), AX	
  0x416b28		48890424		MOVQ AX, 0(SP)			
  0x416b2c		e8af1bffff		CALL runtime.lock(SB)		
	list := sched.gFree.stack
  0x416b31		488b0500b20a00		MOVQ runtime.sched+152(SB), AX	
  0x416b38		4889442408		MOVQ AX, 0x8(SP)		
	sched.gFree.stack = gList{}
  0x416b3d		48c705f0b10a0000000000	MOVQ $0x0, runtime.sched+152(SB)	
	unlock(&sched.gFree.lock)
  0x416b48		488d05e1b10a00		LEAQ runtime.sched+144(SB), AX	
  0x416b4f		48890424		MOVQ AX, 0(SP)			
  0x416b53		e8381dffff		CALL runtime.unlock(SB)		
	if list.empty() {
  0x416b58		90			NOPL			
	return l.head == 0
  0x416b59		48837c240800		CMPQ $0x0, 0x8(SP)	
	if list.empty() {
  0x416b5f		0f84af000000		JE 0x416c14		
	q := gQueue{list.head, list.head}
  0x416b65		0f57c0			XORPS X0, X0		
  0x416b68		0f11442420		MOVUPS X0, 0x20(SP)	
  0x416b6d		488b442408		MOVQ 0x8(SP), AX	
  0x416b72		4889442420		MOVQ AX, 0x20(SP)	
  0x416b77		488b442408		MOVQ 0x8(SP), AX	
  0x416b7c		4889442428		MOVQ AX, 0x28(SP)	
	for gp := list.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {
  0x416b81		488b442408		MOVQ 0x8(SP), AX	
  0x416b86		90			NOPL			
  0x416b87		eb24			JMP 0x416bad		
  0x416b89		4889442430		MOVQ AX, 0x30(SP)	
		shrinkstack(gp)
  0x416b8e		48890424		MOVQ AX, 0(SP)			
  0x416b92		e8791f0200		CALL runtime.shrinkstack(SB)	
		q.tail.set(gp)
  0x416b97		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x416b98		488b442430		MOVQ 0x30(SP), AX	
  0x416b9d		4889c1			MOVQ AX, CX		
  0x416ba0		4889442428		MOVQ AX, 0x28(SP)	
	for gp := list.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {
  0x416ba5		488b81a0000000		MOVQ 0xa0(CX), AX	
  0x416bac		90			NOPL			
  0x416bad		4885c0			TESTQ AX, AX		
  0x416bb0		75d7			JNE 0x416b89		
	lock(&sched.gFree.lock)
  0x416bb2		488d0577b10a00		LEAQ runtime.sched+144(SB), AX	
  0x416bb9		48890424		MOVQ AX, 0(SP)			
  0x416bbd		e81e1bffff		CALL runtime.lock(SB)		
	sched.gFree.noStack.pushAll(q)
  0x416bc2		488b442428		MOVQ 0x28(SP), AX	
  0x416bc7		488b4c2420		MOVQ 0x20(SP), CX	
  0x416bcc		48894c2410		MOVQ CX, 0x10(SP)	
  0x416bd1		4889442418		MOVQ AX, 0x18(SP)	
  0x416bd6		90			NOPL			
	if !q.empty() {
  0x416bd7		90			NOPL			
	return q.head == 0
  0x416bd8		4885c9			TESTQ CX, CX		
	if !q.empty() {
  0x416bdb		751a			JNE 0x416bf7		
	unlock(&sched.gFree.lock)
  0x416bdd		488d054cb10a00		LEAQ runtime.sched+144(SB), AX	
  0x416be4		48890424		MOVQ AX, 0(SP)			
  0x416be8		e8a31cffff		CALL runtime.unlock(SB)		
}
  0x416bed		488b6c2438		MOVQ 0x38(SP), BP	
  0x416bf2		4883c440		ADDQ $0x40, SP		
  0x416bf6		c3			RET			
		q.tail.ptr().schedlink = l.head
  0x416bf7		90			NOPL				
  0x416bf8		488b0d41b10a00		MOVQ runtime.sched+160(SB), CX	
  0x416bff		488988a0000000		MOVQ CX, 0xa0(AX)		
		l.head = q.head
  0x416c06		488b442410		MOVQ 0x10(SP), AX		
  0x416c0b		4889052eb10a00		MOVQ AX, runtime.sched+160(SB)	
  0x416c12		ebc9			JMP 0x416bdd			
		return
  0x416c14		488b6c2438		MOVQ 0x38(SP), BP	
  0x416c19		4883c440		ADDQ $0x40, SP		
  0x416c1d		c3			RET			
func markrootFreeGStacks() {
  0x416c1e		e85d0c0300		CALL runtime.morestack_noctxt(SB)	
  0x416c23		e9d8feffff		JMP runtime.markrootFreeGStacks(SB)	

TEXT runtime.markrootSpans(SB) /usr/local/go/src/runtime/mgcmark.go
func markrootSpans(gcw *gcWork, shard int) {
  0x416c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416c39		483b6110		CMPQ 0x10(CX), SP	
  0x416c3d		0f8610020000		JBE 0x416e53		
  0x416c43		4883ec68		SUBQ $0x68, SP		
  0x416c47		48896c2460		MOVQ BP, 0x60(SP)	
  0x416c4c		488d6c2460		LEAQ 0x60(SP), BP	
	sg := mheap_.sweepgen
  0x416c51		8b0501fa0a00		MOVL runtime.mheap_+24(SB), AX	
  0x416c57		89442428		MOVL AX, 0x28(SP)		
	spans := mheap_.sweepSpans[mheap_.sweepgen/2%2].block(shard)
  0x416c5b		d1e8			SHRL $0x1, AX				
  0x416c5d		83e001			ANDL $0x1, AX				
  0x416c60		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x416c64		488d1515fa0a00		LEAQ runtime.mheap_+64(SB), DX		
  0x416c6b		488d04c2		LEAQ 0(DX)(AX*8), AX			
  0x416c6f		48890424		MOVQ AX, 0(SP)				
  0x416c73		488b442478		MOVQ 0x78(SP), AX			
  0x416c78		4889442408		MOVQ AX, 0x8(SP)			
  0x416c7d		e86e470000		CALL runtime.(*gcSweepBuf).block(SB)	
  0x416c82		488b442418		MOVQ 0x18(SP), AX			
  0x416c87		4889442430		MOVQ AX, 0x30(SP)			
  0x416c8c		488b4c2410		MOVQ 0x10(SP), CX			
  0x416c91		48894c2440		MOVQ CX, 0x40(SP)			
	for _, s := range spans {
  0x416c96		8b542428		MOVL 0x28(SP), DX	
  0x416c9a		31db			XORL BX, BX		
  0x416c9c		eb03			JMP 0x416ca1		
  0x416c9e		48ffc3			INCQ BX			
  0x416ca1		4839c3			CMPQ AX, BX		
  0x416ca4		0f8d32010000		JGE 0x416ddc		
  0x416caa		488b34d9		MOVQ 0(CX)(BX*8), SI	
		if s.state != mSpanInUse {
  0x416cae		807e6301		CMPB $0x1, 0x63(SI)	
  0x416cb2		75ea			JNE 0x416c9e		
		if !useCheckmark && !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x416cb4		803dfb5f0c0000		CMPB $0x0, runtime.useCheckmark(SB)	
  0x416cbb		0f84f6000000		JE 0x416db7				
		if s.specials == nil {
  0x416cc1		4883be8800000000	CMPQ $0x0, 0x88(SI)	
  0x416cc9		74d3			JE 0x416c9e		
	for _, s := range spans {
  0x416ccb		48895c2438		MOVQ BX, 0x38(SP)	
  0x416cd0		4889742448		MOVQ SI, 0x48(SP)	
		lock(&s.speciallock)
  0x416cd5		488d8680000000		LEAQ 0x80(SI), AX	
  0x416cdc		4889442458		MOVQ AX, 0x58(SP)	
  0x416ce1		48890424		MOVQ AX, 0(SP)		
  0x416ce5		e8f619ffff		CALL runtime.lock(SB)	
		for sp := s.specials; sp != nil; sp = sp.next {
  0x416cea		488b442448		MOVQ 0x48(SP), AX	
  0x416cef		488b8888000000		MOVQ 0x88(AX), CX	
  0x416cf6		eb03			JMP 0x416cfb		
  0x416cf8		488b09			MOVQ 0(CX), CX		
  0x416cfb		4885c9			TESTQ CX, CX		
  0x416cfe		0f848d000000		JE 0x416d91		
			if sp.kind != _KindSpecialFinalizer {
  0x416d04		80790a01		CMPB $0x1, 0xa(CX)	
  0x416d08		75ee			JNE 0x416cf8		
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x416d0a		90			NOPL			
  0x416d0b		0fb75108		MOVZX 0x8(CX), DX	
  0x416d0f		488b5868		MOVQ 0x68(AX), BX	
	return s.startAddr
  0x416d13		488b7018		MOVQ 0x18(AX), SI	
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x416d17		4885db			TESTQ BX, BX		
  0x416d1a		0f84c6000000		JE 0x416de6		
		for sp := s.specials; sp != nil; sp = sp.next {
  0x416d20		48894c2450		MOVQ CX, 0x50(SP)	
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x416d25		4889d0			MOVQ DX, AX		
  0x416d28		31d2			XORL DX, DX		
  0x416d2a		48f7f3			DIVQ BX			
  0x416d2d		480fafc3		IMULQ BX, AX		
  0x416d31		488d0c06		LEAQ 0(SI)(AX*1), CX	
			scanobject(p, gcw)
  0x416d35		48890c24		MOVQ CX, 0(SP)			
  0x416d39		488b4c2470		MOVQ 0x70(SP), CX		
  0x416d3e		48894c2408		MOVQ CX, 0x8(SP)		
  0x416d43		e8281b0000		CALL runtime.scanobject(SB)	
			scanblock(uintptr(unsafe.Pointer(&spf.fn)), sys.PtrSize, &oneptrmask[0], gcw, nil)
  0x416d48		488b4c2450		MOVQ 0x50(SP), CX		
  0x416d4d		488d5110		LEAQ 0x10(CX), DX		
  0x416d51		48891424		MOVQ DX, 0(SP)			
  0x416d55		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x416d5e		488d159b820a00		LEAQ 0xa829b(IP), DX		
  0x416d65		4889542410		MOVQ DX, 0x10(SP)		
  0x416d6a		488b542470		MOVQ 0x70(SP), DX		
  0x416d6f		4889542418		MOVQ DX, 0x18(SP)		
  0x416d74		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x416d7d		e86e190000		CALL runtime.scanblock(SB)	
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x416d82		488b442448		MOVQ 0x48(SP), AX	
		for sp := s.specials; sp != nil; sp = sp.next {
  0x416d87		488b4c2450		MOVQ 0x50(SP), CX	
			scanblock(uintptr(unsafe.Pointer(&spf.fn)), sys.PtrSize, &oneptrmask[0], gcw, nil)
  0x416d8c		e967ffffff		JMP 0x416cf8		
		unlock(&s.speciallock)
  0x416d91		488b442458		MOVQ 0x58(SP), AX	
  0x416d96		48890424		MOVQ AX, 0(SP)		
  0x416d9a		e8f11affff		CALL runtime.unlock(SB)	
	for _, s := range spans {
  0x416d9f		488b442430		MOVQ 0x30(SP), AX	
  0x416da4		488b4c2440		MOVQ 0x40(SP), CX	
		if !useCheckmark && !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x416da9		8b542428		MOVL 0x28(SP), DX	
	for _, s := range spans {
  0x416dad		488b5c2438		MOVQ 0x38(SP), BX	
		unlock(&s.speciallock)
  0x416db2		e9e7feffff		JMP 0x416c9e		
		if !useCheckmark && !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x416db7		8b7e58			MOVL 0x58(SI), DI	
  0x416dba		39d7			CMPL DX, DI		
  0x416dbc		7511			JNE 0x416dcf		
  0x416dbe		41b801000000		MOVL $0x1, R8		
  0x416dc4		4584c0			TESTL R8, R8		
  0x416dc7		0f85f4feffff		JNE 0x416cc1		
  0x416dcd		eb1e			JMP 0x416ded		
  0x416dcf		448d4a03		LEAL 0x3(DX), R9	
  0x416dd3		4139f9			CMPL DI, R9		
  0x416dd6		410f94c0		SETE R8			
  0x416dda		ebe8			JMP 0x416dc4		
  0x416ddc		488b6c2460		MOVQ 0x60(SP), BP	
  0x416de1		4883c468		ADDQ $0x68, SP		
  0x416de5		c3			RET			
			p := s.base() + uintptr(spf.special.offset)/s.elemsize*s.elemsize
  0x416de6		e895b30000		CALL runtime.panicdivide(SB)	
  0x416deb		0f0b			UD2				
		if !useCheckmark && !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x416ded		897c242c		MOVL DI, 0x2c(SP)	
			print("sweep ", s.sweepgen, " ", sg, "\n")
  0x416df1		e8cad00000		CALL runtime.printlock(SB)	
  0x416df6		488d05a1840500		LEAQ 0x584a1(IP), AX		
  0x416dfd		48890424		MOVQ AX, 0(SP)			
  0x416e01		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x416e0a		e8e1d90000		CALL runtime.printstring(SB)	
  0x416e0f		8b44242c		MOVL 0x2c(SP), AX		
  0x416e13		48890424		MOVQ AX, 0(SP)			
  0x416e17		e824d70000		CALL runtime.printuint(SB)	
  0x416e1c		e8dfd20000		CALL runtime.printsp(SB)	
  0x416e21		8b442428		MOVL 0x28(SP), AX		
  0x416e25		48890424		MOVQ AX, 0(SP)			
  0x416e29		e812d70000		CALL runtime.printuint(SB)	
  0x416e2e		e81dd30000		CALL runtime.printnl(SB)	
  0x416e33		e808d10000		CALL runtime.printunlock(SB)	
			throw("gc: unswept span")
  0x416e38		488d05a8910500		LEAQ 0x591a8(IP), AX	
  0x416e3f		48890424		MOVQ AX, 0(SP)		
  0x416e43		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x416e4c		e82fc60000		CALL runtime.throw(SB)	
  0x416e51		0f0b			UD2			
func markrootSpans(gcw *gcWork, shard int) {
  0x416e53		e8280a0300		CALL runtime.morestack_noctxt(SB)	
  0x416e58		e9d3fdffff		JMP runtime.markrootSpans(SB)		

TEXT runtime.gcAssistAlloc(SB) /usr/local/go/src/runtime/mgcmark.go
func gcAssistAlloc(gp *g) {
  0x416e60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x416e69		483b6110		CMPQ 0x10(CX), SP	
  0x416e6d		0f86ae020000		JBE 0x417121		
  0x416e73		4883ec58		SUBQ $0x58, SP		
  0x416e77		48896c2450		MOVQ BP, 0x50(SP)	
  0x416e7c		488d6c2450		LEAQ 0x50(SP), BP	
	if getg() == gp.m.g0 {
  0x416e81		488b442460		MOVQ 0x60(SP), AX	
  0x416e86		488b4830		MOVQ 0x30(AX), CX	
  0x416e8a		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x416e93		483911			CMPQ DX, 0(CX)		
  0x416e96		0f847b020000		JE 0x417117		
	if mp := getg().m; mp.locks > 0 || mp.preemptoff != "" {
  0x416e9c		488b4a30		MOVQ 0x30(DX), CX	
  0x416ea0		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x416ea7		0f8f60020000		JG 0x41710d		
  0x416ead		4883b90001000000	CMPQ $0x0, 0x100(CX)	
  0x416eb5		0f8552020000		JNE 0x41710d		
  0x416ebb		31c9			XORL CX, CX		
	debtBytes := -gp.gcAssistBytes
  0x416ebd		eb0f			JMP 0x416ece		
			goto retry
  0x416ebf		488b542460		MOVQ 0x60(SP), DX	
  0x416ec4		0fb65c242f		MOVZX 0x2f(SP), BX	
	debtBytes := -gp.gcAssistBytes
  0x416ec9		4889d0			MOVQ DX, AX		
	if traced {
  0x416ecc		89d9			MOVL BX, CX		
	debtBytes := -gp.gcAssistBytes
  0x416ece		488b9070010000		MOVQ 0x170(AX), DX	
  0x416ed5		48f7da			NEGQ DX			
	scanWork := int64(gcController.assistWorkPerByte * float64(debtBytes))
  0x416ed8		0f57c0			XORPS X0, X0				
  0x416edb		f2480f2ac2		CVTSI2SDQ DX, X0			
  0x416ee0		f20f5905d8620c00	MULSD runtime.gcController+64(SB), X0	
  0x416ee8		f2480f2cd8		CVTTSD2SIQ X0, BX			
	if scanWork < gcOverAssistWork {
  0x416eed		4881fb00000100		CMPQ $0x10000, BX	
  0x416ef4		7d1e			JGE 0x416f14		
		debtBytes = int64(gcController.assistBytesPerWork * float64(scanWork))
  0x416ef6		f20f1005ca620c00	MOVSD_XMM runtime.gcController+72(SB), X0	
  0x416efe		f20f100df25d0600	MOVSD_XMM $f64.40f0000000000000(SB), X1		
  0x416f06		f20f59c8		MULSD X0, X1					
  0x416f0a		f2480f2cd1		CVTTSD2SIQ X1, DX				
  0x416f0f		bb00000100		MOVL $0x10000, BX				
	bgScanCredit := atomic.Loadint64(&gcController.bgScanCredit)
  0x416f14		488b356d620c00		MOVQ runtime.gcController+8(SB), SI	
	if bgScanCredit > 0 {
  0x416f1b		4885f6			TESTQ SI, SI		
  0x416f1e		7e4d			JLE 0x416f6d		
		if bgScanCredit < scanWork {
  0x416f20		4839de			CMPQ BX, SI		
  0x416f23		0f8dd5010000		JGE 0x4170fe		
			gp.gcAssistBytes += 1 + int64(gcController.assistBytesPerWork*float64(stolen))
  0x416f29		0f57c0			XORPS X0, X0				
  0x416f2c		f2480f2ac6		CVTSI2SDQ SI, X0			
  0x416f31		f20f59058f620c00	MULSD runtime.gcController+72(SB), X0	
  0x416f39		f2480f2cd0		CVTTSD2SIQ X0, DX			
  0x416f3e		48039070010000		ADDQ 0x170(AX), DX			
  0x416f45		48ffc2			INCQ DX					
  0x416f48		48899070010000		MOVQ DX, 0x170(AX)			
		atomic.Xaddint64(&gcController.bgScanCredit, -stolen)
  0x416f4f		4889f2			MOVQ SI, DX				
  0x416f52		48f7de			NEGQ SI					
  0x416f55		488d3d2c620c00		LEAQ runtime.gcController+8(SB), DI	
  0x416f5c		f0480fc137		LOCK XADDQ SI, 0(DI)			
		scanWork -= stolen
  0x416f61		4829d3			SUBQ DX, BX		
		if scanWork == 0 {
  0x416f64		4885db			TESTQ BX, BX		
  0x416f67		0f845d010000		JE 0x4170ca		
	if trace.enabled && !traced {
  0x416f6d		803d5c5c0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x416f74		7408			JE 0x416f7e			
	if traced {
  0x416f76		84c9			TESTL CL, CL		
	if trace.enabled && !traced {
  0x416f78		0f840f010000		JE 0x41708d		
	if traced {
  0x416f7e		884c242f		MOVB CL, 0x2f(SP)	
	systemstack(func() {
  0x416f82		0f57c0			XORPS X0, X0					
  0x416f85		0f11442438		MOVUPS X0, 0x38(SP)				
  0x416f8a		48c744244800000000	MOVQ $0x0, 0x48(SP)				
  0x416f93		488d15e6e40200		LEAQ runtime.gcAssistAlloc.func1(SB), DX	
  0x416f9a		4889542438		MOVQ DX, 0x38(SP)				
  0x416f9f		4889442440		MOVQ AX, 0x40(SP)				
  0x416fa4		48895c2448		MOVQ BX, 0x48(SP)				
  0x416fa9		488d5c2438		LEAQ 0x38(SP), BX				
  0x416fae		48891c24		MOVQ BX, 0(SP)					
  0x416fb2		e879070300		CALL runtime.systemstack(SB)			
	completed := gp.param != nil
  0x416fb7		488b442460		MOVQ 0x60(SP), AX	
  0x416fbc		488b8888000000		MOVQ 0x88(AX), CX	
  0x416fc3		4883f900		CMPQ $0x0, CX		
	gp.param = nil
  0x416fc7		833d525e0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x416fce		0f859c000000		JNE 0x417070				
  0x416fd4		48c7808800000000000000	MOVQ $0x0, 0x88(AX)			
	completed := gp.param != nil
  0x416fdf		4883f900		CMPQ $0x0, CX		
	if completed {
  0x416fe3		757c			JNE 0x417061		
	if gp.gcAssistBytes < 0 {
  0x416fe5		4883b87001000000	CMPQ $0x0, 0x170(AX)	
  0x416fed		7d39			JGE 0x417028		
		if gp.preempt {
  0x416fef		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x416ff6		7421			JE 0x417019		
			Gosched()
  0x416ff8		90			NOPL			
	checkTimeouts()
  0x416ff9		90			NOPL			
	mcall(gosched_m)
  0x416ffa		488d0557c80500		LEAQ 0x5c857(IP), AX	
  0x417001		48890424		MOVQ AX, 0(SP)		
  0x417005		e8a6060300		CALL runtime.mcall(SB)	
			goto retry
  0x41700a		488b442460		MOVQ 0x60(SP), AX	
  0x41700f		0fb64c242f		MOVZX 0x2f(SP), CX	
  0x417014		e9b5feffff		JMP 0x416ece		
		if !gcParkAssist() {
  0x417019		e8e2040000		CALL runtime.gcParkAssist(SB)	
  0x41701e		803c2400		CMPB $0x0, 0(SP)		
  0x417022		0f8497feffff		JE 0x416ebf			
	if traced {
  0x417028		0fb644242f		MOVZX 0x2f(SP), AX	
  0x41702d		84c0			TESTL AL, AL		
  0x41702f		750a			JNE 0x41703b		
  0x417031		488b6c2450		MOVQ 0x50(SP), BP	
  0x417036		4883c458		ADDQ $0x58, SP		
  0x41703a		c3			RET			
		traceGCMarkAssistDone()
  0x41703b		90			NOPL			
	traceEvent(traceEvGCMarkAssistDone, -1)
  0x41703c		c604242c		MOVB $0x2c, 0(SP)		
  0x417040		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x417049		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x417052		0f57c0			XORPS X0, X0			
  0x417055		0f11442418		MOVUPS X0, 0x18(SP)		
  0x41705a		e8414e0200		CALL runtime.traceEvent(SB)	
  0x41705f		ebd0			JMP 0x417031			
		gcMarkDone()
  0x417061		e81ac9ffff		CALL runtime.gcMarkDone(SB)	
	if gp.gcAssistBytes < 0 {
  0x417066		488b442460		MOVQ 0x60(SP), AX	
		gcMarkDone()
  0x41706b		e975ffffff		JMP 0x416fe5		
	completed := gp.param != nil
  0x417070		488db888000000		LEAQ 0x88(AX), DI	
func gcAssistAlloc(gp *g) {
  0x417077		4889c2			MOVQ AX, DX		
	gp.param = nil
  0x41707a		31c0			XORL AX, AX			
  0x41707c		e8ff250300		CALL runtime.gcWriteBarrier(SB)	
	completed := gp.param != nil
  0x417081		4883f900		CMPQ $0x0, CX		
	if gp.gcAssistBytes < 0 {
  0x417085		4889d0			MOVQ DX, AX		
	gp.param = nil
  0x417088		e956ffffff		JMP 0x416fe3		
	systemstack(func() {
  0x41708d		48895c2430		MOVQ BX, 0x30(SP)	
		traceGCMarkAssistStart()
  0x417092		90			NOPL			
	traceEvent(traceEvGCMarkAssistStart, 1)
  0x417093		c604242b		MOVB $0x2b, 0(SP)		
  0x417097		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4170a0		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4170a9		0f57c0			XORPS X0, X0			
  0x4170ac		0f11442418		MOVUPS X0, 0x18(SP)		
  0x4170b1		e8ea4d0200		CALL runtime.traceEvent(SB)	
	systemstack(func() {
  0x4170b6		488b442460		MOVQ 0x60(SP), AX	
  0x4170bb		488b5c2430		MOVQ 0x30(SP), BX	
  0x4170c0		b901000000		MOVL $0x1, CX		
  0x4170c5		e9b4feffff		JMP 0x416f7e		
	if traced {
  0x4170ca		84c9			TESTL CL, CL		
			if traced {
  0x4170cc		750a			JNE 0x4170d8		
			return
  0x4170ce		488b6c2450		MOVQ 0x50(SP), BP	
  0x4170d3		4883c458		ADDQ $0x58, SP		
  0x4170d7		c3			RET			
				traceGCMarkAssistDone()
  0x4170d8		90			NOPL			
	traceEvent(traceEvGCMarkAssistDone, -1)
  0x4170d9		c604242c		MOVB $0x2c, 0(SP)		
  0x4170dd		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4170e6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4170ef		0f57c0			XORPS X0, X0			
  0x4170f2		0f11442418		MOVUPS X0, 0x18(SP)		
  0x4170f7		e8a44d0200		CALL runtime.traceEvent(SB)	
			return
  0x4170fc		ebd0			JMP 0x4170ce		
			gp.gcAssistBytes += debtBytes
  0x4170fe		48019070010000		ADDQ DX, 0x170(AX)	
		atomic.Xaddint64(&gcController.bgScanCredit, -stolen)
  0x417105		4889de			MOVQ BX, SI		
			gp.gcAssistBytes += debtBytes
  0x417108		e942feffff		JMP 0x416f4f		
		return
  0x41710d		488b6c2450		MOVQ 0x50(SP), BP	
  0x417112		4883c458		ADDQ $0x58, SP		
  0x417116		c3			RET			
		return
  0x417117		488b6c2450		MOVQ 0x50(SP), BP	
  0x41711c		4883c458		ADDQ $0x58, SP		
  0x417120		c3			RET			
func gcAssistAlloc(gp *g) {
  0x417121		e85a070300		CALL runtime.morestack_noctxt(SB)	
  0x417126		e935fdffff		JMP runtime.gcAssistAlloc(SB)		

TEXT runtime.gcAssistAlloc1(SB) /usr/local/go/src/runtime/mgcmark.go
func gcAssistAlloc1(gp *g, scanWork int64) {
  0x417130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417139		483b6118		CMPQ 0x18(CX), SP	
  0x41713d		0f862a030000		JBE 0x41746d		
  0x417143		4883ec48		SUBQ $0x48, SP		
  0x417147		48896c2440		MOVQ BP, 0x40(SP)	
  0x41714c		488d6c2440		LEAQ 0x40(SP), BP	
	gp.param = nil
  0x417151		488b4c2450		MOVQ 0x50(SP), CX			
  0x417156		8401			TESTB AL, 0(CX)				
  0x417158		488db988000000		LEAQ 0x88(CX), DI			
  0x41715f		833dba5c0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x417166		0f85f9010000		JNE 0x417365				
  0x41716c		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
	if atomic.Load(&gcBlackenEnabled) == 0 {
  0x417177		8b05535b0c00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x41717d		85c0			TESTL AX, AX				
  0x41717f		7515			JNE 0x417196				
		gp.gcAssistBytes = 0
  0x417181		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
		return
  0x41718c		488b6c2440		MOVQ 0x40(SP), BP	
  0x417191		4883c448		ADDQ $0x48, SP		
  0x417195		c3			RET			
	gp.param = nil
  0x417196		48897c2438		MOVQ DI, 0x38(SP)	
	startTime := nanotime()
  0x41719b		e8103f0300		CALL runtime.nanotime(SB)	
  0x4171a0		488b0424		MOVQ 0(SP), AX			
	decnwait := atomic.Xadd(&work.nwait, -1)
  0x4171a4		b9ffffffff		MOVL $-0x1, CX			
  0x4171a9		488d1570ae0a00		LEAQ runtime.work+160(SB), DX	
  0x4171b0		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x4171b4		ffc9			DECL CX				
	if decnwait == work.nproc {
  0x4171b6		8b1d54ae0a00		MOVL runtime.work+144(SB), BX	
  0x4171bc		39d9			CMPL BX, CX			
  0x4171be		0f842b020000		JE 0x4173ef			
	startTime := nanotime()
  0x4171c4		4889442430		MOVQ AX, 0x30(SP)	
	casgstatus(gp, _Grunning, _Gwaiting)
  0x4171c9		488b442450		MOVQ 0x50(SP), AX		
  0x4171ce		48890424		MOVQ AX, 0(SP)			
  0x4171d2		48b90200000004000000	MOVQ $0x400000002, CX		
  0x4171dc		48894c2408		MOVQ CX, 0x8(SP)		
  0x4171e1		e8bafa0000		CALL runtime.casgstatus(SB)	
	gp.waitreason = waitReasonGCAssistMarking
  0x4171e6		488b442450		MOVQ 0x50(SP), AX	
  0x4171eb		c680b000000001		MOVB $0x1, 0xb0(AX)	
	gcw := &getg().m.p.ptr().gcw
  0x4171f2		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4171fb		488b4930		MOVQ 0x30(CX), CX	
  0x4171ff		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x417206		8402			TESTB AL, 0(DX)		
  0x417208		8401			TESTB AL, 0(CX)		
  0x41720a		488d8a70120000		LEAQ 0x1270(DX), CX	
  0x417211		90			NOPL			
	workDone := gcDrainN(gcw, scanWork)
  0x417212		48890c24		MOVQ CX, 0(SP)			
  0x417216		488b4c2458		MOVQ 0x58(SP), CX		
  0x41721b		48894c2408		MOVQ CX, 0x8(SP)		
  0x417220		e89b120000		CALL runtime.gcDrainN(SB)	
  0x417225		488b442410		MOVQ 0x10(SP), AX		
  0x41722a		4889442428		MOVQ AX, 0x28(SP)		
	casgstatus(gp, _Gwaiting, _Grunning)
  0x41722f		488b4c2450		MOVQ 0x50(SP), CX		
  0x417234		48890c24		MOVQ CX, 0(SP)			
  0x417238		48ba0400000002000000	MOVQ $0x200000004, DX		
  0x417242		4889542408		MOVQ DX, 0x8(SP)		
  0x417247		e854fa0000		CALL runtime.casgstatus(SB)	
	gp.gcAssistBytes += 1 + int64(gcController.assistBytesPerWork*float64(workDone))
  0x41724c		488b442428		MOVQ 0x28(SP), AX			
  0x417251		0f57c0			XORPS X0, X0				
  0x417254		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x417259		f20f5905675f0c00	MULSD runtime.gcController+72(SB), X0	
  0x417261		f2480f2cc0		CVTTSD2SIQ X0, AX			
  0x417266		488b4c2450		MOVQ 0x50(SP), CX			
  0x41726b		48038170010000		ADDQ 0x170(CX), AX			
  0x417272		48ffc0			INCQ AX					
  0x417275		48898170010000		MOVQ AX, 0x170(CX)			
	incnwait := atomic.Xadd(&work.nwait, +1)
  0x41727c		b801000000		MOVL $0x1, AX			
  0x417281		488d1598ad0a00		LEAQ runtime.work+160(SB), DX	
  0x417288		f00fc102		LOCK XADDL AX, 0(DX)		
  0x41728c		ffc0			INCL AX				
	if incnwait > work.nproc {
  0x41728e		8b157cad0a00		MOVL runtime.work+144(SB), DX	
  0x417294		39d0			CMPL DX, AX			
  0x417296		0f87d5000000		JA 0x417371			
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x41729c		0f85bc000000		JNE 0x41735e		
  0x4172a2		90			NOPL			
	if !work.full.empty() {
  0x4172a3		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x4172a4		488b15d5ac0a00		MOVQ runtime.work(SB), DX	
  0x4172ab		4885d2			TESTQ DX, DX			
	if !work.full.empty() {
  0x4172ae		0f85a0000000		JNE 0x417354		
	if work.markrootNext < work.markrootJobs {
  0x4172b4		8b1552ad0a00		MOVL runtime.work+140(SB), DX	
  0x4172ba		391548ad0a00		CMPL DX, runtime.work+136(SB)	
  0x4172c0		0f8387000000		JAE 0x41734d			
  0x4172c6		b801000000		MOVL $0x1, AX			
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x4172cb		83f001			XORL $0x1, AX		
  0x4172ce		84c0			TESTL AL, AL		
  0x4172d0		7410			JE 0x4172e2		
		gp.param = unsafe.Pointer(gp)
  0x4172d2		833d475b0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4172d9		7563			JNE 0x41733e				
  0x4172db		48898988000000		MOVQ CX, 0x88(CX)			
	duration := nanotime() - startTime
  0x4172e2		e8c93d0300		CALL runtime.nanotime(SB)	
	_p_ := gp.m.p.ptr()
  0x4172e7		488b442450		MOVQ 0x50(SP), AX	
  0x4172ec		488b4030		MOVQ 0x30(AX), AX	
  0x4172f0		488b80d0000000		MOVQ 0xd0(AX), AX	
	_p_.gcAssistTime += duration
  0x4172f7		8400			TESTB AL, 0(AX)		
	duration := nanotime() - startTime
  0x4172f9		488b0c24		MOVQ 0(SP), CX		
  0x4172fd		488b542430		MOVQ 0x30(SP), DX	
  0x417302		4829d1			SUBQ DX, CX		
	_p_ := gp.m.p.ptr()
  0x417305		90			NOPL			
	_p_.gcAssistTime += duration
  0x417306		48038848120000		ADDQ 0x1248(AX), CX	
  0x41730d		48898848120000		MOVQ CX, 0x1248(AX)	
	if _p_.gcAssistTime > gcAssistTimeSlack {
  0x417314		4881f988130000		CMPQ $0x1388, CX	
  0x41731b		7e17			JLE 0x417334		
		atomic.Xaddint64(&gcController.assistTime, _p_.gcAssistTime)
  0x41731d		488d156c5e0c00		LEAQ runtime.gcController+16(SB), DX	
  0x417324		f0480fc10a		LOCK XADDQ CX, 0(DX)			
		_p_.gcAssistTime = 0
  0x417329		48c7804812000000000000	MOVQ $0x0, 0x1248(AX)	
  0x417334		488b6c2440		MOVQ 0x40(SP), BP	
  0x417339		4883c448		ADDQ $0x48, SP		
  0x41733d		c3			RET			
		gp.param = unsafe.Pointer(gp)
  0x41733e		488b7c2438		MOVQ 0x38(SP), DI		
  0x417343		4889c8			MOVQ CX, AX			
  0x417346		e835230300		CALL runtime.gcWriteBarrier(SB)	
  0x41734b		eb95			JMP 0x4172e2			
  0x41734d		31c0			XORL AX, AX			
	if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
  0x41734f		e977ffffff		JMP 0x4172cb		
  0x417354		b801000000		MOVL $0x1, AX		
  0x417359		e96dffffff		JMP 0x4172cb		
  0x41735e		31c0			XORL AX, AX		
  0x417360		e969ffffff		JMP 0x4172ce		
	gp.param = nil
  0x417365		31c0			XORL AX, AX			
  0x417367		e814230300		CALL runtime.gcWriteBarrier(SB)	
  0x41736c		e906feffff		JMP 0x417177			
	incnwait := atomic.Xadd(&work.nwait, +1)
  0x417371		8944241c		MOVL AX, 0x1c(SP)	
	if incnwait > work.nproc {
  0x417375		89542424		MOVL DX, 0x24(SP)	
		println("runtime: work.nwait=", incnwait,
  0x417379		e842cb0000		CALL runtime.printlock(SB)	
  0x41737e		488d053c950500		LEAQ 0x5953c(IP), AX		
  0x417385		48890424		MOVQ AX, 0(SP)			
  0x417389		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x417392		e859d40000		CALL runtime.printstring(SB)	
  0x417397		8b44241c		MOVL 0x1c(SP), AX		
  0x41739b		48890424		MOVQ AX, 0(SP)			
  0x41739f		e89cd10000		CALL runtime.printuint(SB)	
  0x4173a4		488d0554880500		LEAQ 0x58854(IP), AX		
  0x4173ab		48890424		MOVQ AX, 0(SP)			
  0x4173af		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4173b8		e833d40000		CALL runtime.printstring(SB)	
  0x4173bd		8b442424		MOVL 0x24(SP), AX		
  0x4173c1		48890424		MOVQ AX, 0(SP)			
  0x4173c5		e876d10000		CALL runtime.printuint(SB)	
  0x4173ca		e881cd0000		CALL runtime.printnl(SB)	
  0x4173cf		e86ccb0000		CALL runtime.printunlock(SB)	
		throw("work.nwait > work.nproc")
  0x4173d4		488d05109a0500		LEAQ 0x59a10(IP), AX	
  0x4173db		48890424		MOVQ AX, 0(SP)		
  0x4173df		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4173e8		e893c00000		CALL runtime.throw(SB)	
  0x4173ed		0f0b			UD2			
	decnwait := atomic.Xadd(&work.nwait, -1)
  0x4173ef		894c2420		MOVL CX, 0x20(SP)	
	if decnwait == work.nproc {
  0x4173f3		895c2424		MOVL BX, 0x24(SP)	
		println("runtime: work.nwait =", decnwait, "work.nproc=", work.nproc)
  0x4173f7		e8c4ca0000		CALL runtime.printlock(SB)	
  0x4173fc		488d0572960500		LEAQ 0x59672(IP), AX		
  0x417403		48890424		MOVQ AX, 0(SP)			
  0x417407		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x417410		e8dbd30000		CALL runtime.printstring(SB)	
  0x417415		8b442420		MOVL 0x20(SP), AX		
  0x417419		48890424		MOVQ AX, 0(SP)			
  0x41741d		e81ed10000		CALL runtime.printuint(SB)	
  0x417422		488d05d6870500		LEAQ 0x587d6(IP), AX		
  0x417429		48890424		MOVQ AX, 0(SP)			
  0x41742d		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x417436		e8b5d30000		CALL runtime.printstring(SB)	
  0x41743b		8b442424		MOVL 0x24(SP), AX		
  0x41743f		48890424		MOVQ AX, 0(SP)			
  0x417443		e8f8d00000		CALL runtime.printuint(SB)	
  0x417448		e803cd0000		CALL runtime.printnl(SB)	
  0x41744d		e8eeca0000		CALL runtime.printunlock(SB)	
		throw("nwait > work.nprocs")
  0x417452		488d05f58f0500		LEAQ 0x58ff5(IP), AX	
  0x417459		48890424		MOVQ AX, 0(SP)		
  0x41745d		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x417466		e815c00000		CALL runtime.throw(SB)	
  0x41746b		0f0b			UD2			
func gcAssistAlloc1(gp *g, scanWork int64) {
  0x41746d		e85e220200		CALL runtime.morestackc(SB)	
  0x417472		e9b9fcffff		JMP runtime.gcAssistAlloc1(SB)	

TEXT runtime.gcWakeAllAssists(SB) /usr/local/go/src/runtime/mgcmark.go
func gcWakeAllAssists() {
  0x417480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417489		483b6110		CMPQ 0x10(CX), SP	
  0x41748d		765d			JBE 0x4174ec		
  0x41748f		4883ec18		SUBQ $0x18, SP		
  0x417493		48896c2410		MOVQ BP, 0x10(SP)	
  0x417498		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&work.assistQueue.lock)
  0x41749d		488d05e4ab0a00		LEAQ runtime.work+264(SB), AX	
  0x4174a4		48890424		MOVQ AX, 0(SP)			
  0x4174a8		e83312ffff		CALL runtime.lock(SB)		
	list := work.assistQueue.q.popList()
  0x4174ad		90			NOPL			
	stack := gList{q.head}
  0x4174ae		488b05dbab0a00		MOVQ runtime.work+272(SB), AX	
	*q = gQueue{}
  0x4174b5		0f57c0			XORPS X0, X0			
  0x4174b8		0f1105d1ab0a00		MOVUPS X0, runtime.work+272(SB)	
	list := work.assistQueue.q.popList()
  0x4174bf		4889442408		MOVQ AX, 0x8(SP)	
	injectglist(&list)
  0x4174c4		488d442408		LEAQ 0x8(SP), AX		
  0x4174c9		48890424		MOVQ AX, 0(SP)			
  0x4174cd		e89e330100		CALL runtime.injectglist(SB)	
	unlock(&work.assistQueue.lock)
  0x4174d2		488d05afab0a00		LEAQ runtime.work+264(SB), AX	
  0x4174d9		48890424		MOVQ AX, 0(SP)			
  0x4174dd		e8ae13ffff		CALL runtime.unlock(SB)		
}
  0x4174e2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4174e7		4883c418		ADDQ $0x18, SP		
  0x4174eb		c3			RET			
func gcWakeAllAssists() {
  0x4174ec		e88f030300		CALL runtime.morestack_noctxt(SB)	
  0x4174f1		eb8d			JMP runtime.gcWakeAllAssists(SB)	

TEXT runtime.gcParkAssist(SB) /usr/local/go/src/runtime/mgcmark.go
func gcParkAssist() bool {
  0x417500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417509		483b6110		CMPQ 0x10(CX), SP	
  0x41750d		0f8627010000		JBE 0x41763a		
  0x417513		4883ec28		SUBQ $0x28, SP		
  0x417517		48896c2420		MOVQ BP, 0x20(SP)	
  0x41751c		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&work.assistQueue.lock)
  0x417521		488d0560ab0a00		LEAQ runtime.work+264(SB), AX	
  0x417528		48890424		MOVQ AX, 0(SP)			
  0x41752c		e8af11ffff		CALL runtime.lock(SB)		
	if atomic.Load(&gcBlackenEnabled) == 0 {
  0x417531		8b0599570c00		MOVL runtime.gcBlackenEnabled(SB), AX	
  0x417537		85c0			TESTL AX, AX				
  0x417539		0f84dc000000		JE 0x41761b				
	gp := getg()
  0x41753f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	oldList := work.assistQueue.q
  0x417548		488b0d49ab0a00		MOVQ runtime.work+280(SB), CX	
  0x41754f		488b153aab0a00		MOVQ runtime.work+272(SB), DX	
	work.assistQueue.q.pushBack(gp)
  0x417556		90			NOPL			
	gp.schedlink = 0
  0x417557		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x417562		488b1d2fab0a00		MOVQ runtime.work+280(SB), BX	
  0x417569		4885db			TESTQ BX, BX			
  0x41756c		0f8499000000		JE 0x41760b			
		q.tail.ptr().schedlink.set(gp)
  0x417572		90			NOPL			
  0x417573		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x417574		4889c6			MOVQ AX, SI		
  0x417577		488983a0000000		MOVQ AX, 0xa0(BX)	
	q.tail.set(gp)
  0x41757e		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41757f		48893512ab0a00		MOVQ SI, runtime.work+280(SB)	
	if atomic.Loadint64(&gcController.bgScanCredit) > 0 {
  0x417586		488b05fb5b0c00		MOVQ runtime.gcController+8(SB), AX	
  0x41758d		4885c0			TESTQ AX, AX				
  0x417590		7e3d			JLE 0x4175cf				
		work.assistQueue.q = oldList
  0x417592		488915f7aa0a00		MOVQ DX, runtime.work+272(SB)	
  0x417599		48890df8aa0a00		MOVQ CX, runtime.work+280(SB)	
		if oldList.tail != 0 {
  0x4175a0		4885c9			TESTQ CX, CX		
  0x4175a3		740b			JE 0x4175b0		
			oldList.tail.ptr().schedlink.set(nil)
  0x4175a5		90			NOPL			
  0x4175a6		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4175a7		31c0			XORL AX, AX		
  0x4175a9		488981a0000000		MOVQ AX, 0xa0(CX)	
		unlock(&work.assistQueue.lock)
  0x4175b0		488d05d1aa0a00		LEAQ runtime.work+264(SB), AX	
  0x4175b7		48890424		MOVQ AX, 0(SP)			
  0x4175bb		e8d012ffff		CALL runtime.unlock(SB)		
		return false
  0x4175c0		c644243000		MOVB $0x0, 0x30(SP)	
  0x4175c5		488b6c2420		MOVQ 0x20(SP), BP	
  0x4175ca		4883c428		ADDQ $0x28, SP		
  0x4175ce		c3			RET			
	goparkunlock(&work.assistQueue.lock, waitReasonGCAssistWait, traceEvGoBlockGC, 2)
  0x4175cf		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x4175d0		488d0559c30500		LEAQ 0x5c359(IP), AX		
  0x4175d7		48890424		MOVQ AX, 0(SP)			
  0x4175db		488d05a6aa0a00		LEAQ runtime.work+264(SB), AX	
  0x4175e2		4889442408		MOVQ AX, 0x8(SP)		
  0x4175e7		66c74424100b2a		MOVW $0x2a0b, 0x10(SP)		
  0x4175ee		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x4175f7		e854db0000		CALL runtime.gopark(SB)		
	return true
  0x4175fc		c644243001		MOVB $0x1, 0x30(SP)	
  0x417601		488b6c2420		MOVQ 0x20(SP), BP	
  0x417606		4883c428		ADDQ $0x28, SP		
  0x41760a		c3			RET			
		q.head.set(gp)
  0x41760b		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41760c		4889c6			MOVQ AX, SI			
  0x41760f		4889057aaa0a00		MOVQ AX, runtime.work+272(SB)	
	q.tail.set(gp)
  0x417616		e963ffffff		JMP 0x41757e		
		unlock(&work.assistQueue.lock)
  0x41761b		488d0566aa0a00		LEAQ runtime.work+264(SB), AX	
  0x417622		48890424		MOVQ AX, 0(SP)			
  0x417626		e86512ffff		CALL runtime.unlock(SB)		
		return true
  0x41762b		c644243001		MOVB $0x1, 0x30(SP)	
  0x417630		488b6c2420		MOVQ 0x20(SP), BP	
  0x417635		4883c428		ADDQ $0x28, SP		
  0x417639		c3			RET			
func gcParkAssist() bool {
  0x41763a		e841020300		CALL runtime.morestack_noctxt(SB)	
  0x41763f		e9bcfeffff		JMP runtime.gcParkAssist(SB)		

TEXT runtime.gcFlushBgCredit(SB) /usr/local/go/src/runtime/mgcmark.go
func gcFlushBgCredit(scanWork int64) {
  0x417650		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417659		483b6110		CMPQ 0x10(CX), SP	
  0x41765d		0f8664010000		JBE 0x4177c7		
  0x417663		4883ec30		SUBQ $0x30, SP		
  0x417667		48896c2428		MOVQ BP, 0x28(SP)	
  0x41766c		488d6c2428		LEAQ 0x28(SP), BP	
	if work.assistQueue.q.empty() {
  0x417671		90			NOPL				
  0x417672		48833d16aa0a0000	CMPQ $0x0, runtime.work+272(SB)	
  0x41767a		0f842c010000		JE 0x4177ac			
	scanBytes := int64(float64(scanWork) * gcController.assistBytesPerWork)
  0x417680		488b442438		MOVQ 0x38(SP), AX			
  0x417685		0f57c0			XORPS X0, X0				
  0x417688		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x41768d		f20f5905335b0c00	MULSD runtime.gcController+72(SB), X0	
  0x417695		f20f11442420		MOVSD_XMM X0, 0x20(SP)			
	lock(&work.assistQueue.lock)
  0x41769b		488d05e6a90a00		LEAQ runtime.work+264(SB), AX	
  0x4176a2		48890424		MOVQ AX, 0(SP)			
  0x4176a6		e83510ffff		CALL runtime.lock(SB)		
	scanBytes := int64(float64(scanWork) * gcController.assistBytesPerWork)
  0x4176ab		f20f10442420		MOVSD_XMM 0x20(SP), X0	
  0x4176b1		f2480f2cc0		CVTTSD2SIQ X0, AX	
	for !work.assistQueue.q.empty() && scanBytes > 0 {
  0x4176b6		eb2c			JMP 0x4176e4		
		if scanBytes+gp.gcAssistBytes >= 0 {
  0x4176b8		4889442418		MOVQ AX, 0x18(SP)	
			gp.gcAssistBytes = 0
  0x4176bd		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
			ready(gp, 0, false)
  0x4176c8		48890c24		MOVQ CX, 0(SP)		
  0x4176cc		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x4176d5		c644241000		MOVB $0x0, 0x10(SP)	
  0x4176da		e811ed0000		CALL runtime.ready(SB)	
	for !work.assistQueue.q.empty() && scanBytes > 0 {
  0x4176df		488b442418		MOVQ 0x18(SP), AX	
  0x4176e4		90			NOPL			
	return q.head == 0
  0x4176e5		488b0da4a90a00		MOVQ runtime.work+272(SB), CX	
  0x4176ec		4885c9			TESTQ CX, CX			
	for !work.assistQueue.q.empty() && scanBytes > 0 {
  0x4176ef		746e			JE 0x41775f		
  0x4176f1		4885c0			TESTQ AX, AX		
  0x4176f4		7e69			JLE 0x41775f		
		gp := work.assistQueue.q.pop()
  0x4176f6		90			NOPL			
	gp := q.head.ptr()
  0x4176f7		90			NOPL			
	if gp != nil {
  0x4176f8		4885c9			TESTQ CX, CX		
  0x4176fb		741e			JE 0x41771b		
		q.head = gp.schedlink
  0x4176fd		488b91a0000000		MOVQ 0xa0(CX), DX		
  0x417704		48891585a90a00		MOVQ DX, runtime.work+272(SB)	
		if q.head == 0 {
  0x41770b		4885d2			TESTQ DX, DX		
  0x41770e		750b			JNE 0x41771b		
			q.tail = 0
  0x417710		48c7057da90a0000000000	MOVQ $0x0, runtime.work+280(SB)	
		if scanBytes+gp.gcAssistBytes >= 0 {
  0x41771b		488b9170010000		MOVQ 0x170(CX), DX	
  0x417722		4801d0			ADDQ DX, AX		
  0x417725		4885c0			TESTQ AX, AX		
  0x417728		7d8e			JGE 0x4176b8		
			gp.gcAssistBytes += scanBytes
  0x41772a		48898170010000		MOVQ AX, 0x170(CX)	
			work.assistQueue.q.pushBack(gp)
  0x417731		90			NOPL			
	gp.schedlink = 0
  0x417732		48c781a000000000000000	MOVQ $0x0, 0xa0(CX)	
	if q.tail != 0 {
  0x41773d		488b0554a90a00		MOVQ runtime.work+280(SB), AX	
  0x417744		4885c0			TESTQ AX, AX			
  0x417747		7456			JE 0x41779f			
		q.tail.ptr().schedlink.set(gp)
  0x417749		90			NOPL			
  0x41774a		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x41774b		4889ca			MOVQ CX, DX		
  0x41774e		488988a0000000		MOVQ CX, 0xa0(AX)	
	q.tail.set(gp)
  0x417755		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x417756		4889153ba90a00		MOVQ DX, runtime.work+280(SB)	
  0x41775d		31c0			XORL AX, AX			
	if scanBytes > 0 {
  0x41775f		4885c0			TESTQ AX, AX		
  0x417762		7e21			JLE 0x417785		
		scanWork = int64(float64(scanBytes) * gcController.assistWorkPerByte)
  0x417764		0f57c0			XORPS X0, X0				
  0x417767		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x41776c		f20f59054c5a0c00	MULSD runtime.gcController+64(SB), X0	
  0x417774		f2480f2cc0		CVTTSD2SIQ X0, AX			
		atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
  0x417779		488d0d085a0c00		LEAQ runtime.gcController+8(SB), CX	
  0x417780		f0480fc101		LOCK XADDQ AX, 0(CX)			
	unlock(&work.assistQueue.lock)
  0x417785		488d05fca80a00		LEAQ runtime.work+264(SB), AX	
  0x41778c		48890424		MOVQ AX, 0(SP)			
  0x417790		e8fb10ffff		CALL runtime.unlock(SB)		
}
  0x417795		488b6c2428		MOVQ 0x28(SP), BP	
  0x41779a		4883c430		ADDQ $0x30, SP		
  0x41779e		c3			RET			
		q.head.set(gp)
  0x41779f		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4177a0		4889ca			MOVQ CX, DX			
  0x4177a3		48890de6a80a00		MOVQ CX, runtime.work+272(SB)	
	q.tail.set(gp)
  0x4177aa		eba9			JMP 0x417755		
		atomic.Xaddint64(&gcController.bgScanCredit, scanWork)
  0x4177ac		488b442438		MOVQ 0x38(SP), AX			
  0x4177b1		488d0dd0590c00		LEAQ runtime.gcController+8(SB), CX	
  0x4177b8		f0480fc101		LOCK XADDQ AX, 0(CX)			
		return
  0x4177bd		488b6c2428		MOVQ 0x28(SP), BP	
  0x4177c2		4883c430		ADDQ $0x30, SP		
  0x4177c6		c3			RET			
func gcFlushBgCredit(scanWork int64) {
  0x4177c7		e8b4000300		CALL runtime.morestack_noctxt(SB)	
  0x4177cc		e97ffeffff		JMP runtime.gcFlushBgCredit(SB)		

TEXT runtime.scanstack(SB) /usr/local/go/src/runtime/mgcmark.go
func scanstack(gp *g, gcw *gcWork) {
  0x4177e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4177e9		488d842490feffff	LEAQ 0xfffffe90(SP), AX	
  0x4177f1		483b4118		CMPQ 0x18(CX), AX	
  0x4177f5		0f8699060000		JBE 0x417e94		
  0x4177fb		4881ecf0010000		SUBQ $0x1f0, SP		
  0x417802		4889ac24e8010000	MOVQ BP, 0x1e8(SP)	
  0x41780a		488dac24e8010000	LEAQ 0x1e8(SP), BP	
	if gp.gcscanvalid {
  0x417812		488b8424f8010000	MOVQ 0x1f8(SP), AX	
  0x41781a		80b8b500000000		CMPB $0x0, 0xb5(AX)	
  0x417821		0f85f9030000		JNE 0x417c20		
	if readgstatus(gp)&_Gscan == 0 {
  0x417827		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x417828		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp)&_Gscan == 0 {
  0x41782e		0fbae10c		BTL $0xc, CX		
  0x417832		0f83a2050000		JAE 0x417dda		
	switch readgstatus(gp) &^ _Gscan {
  0x417838		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x417839		8b8890000000		MOVL 0x90(AX), CX	
	switch readgstatus(gp) &^ _Gscan {
  0x41783f		0fbaf10c		BTRL $0xc, CX		
  0x417843		83f902			CMPL $0x2, CX		
  0x417846		0f87af030000		JA 0x417bfb		
	case _Grunnable, _Gsyscall, _Gwaiting:
  0x41784c		83f901			CMPL $0x1, CX		
  0x41784f		0f859b030000		JNE 0x417bf0		
	if gp == getg() {
  0x417855		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41785e		4839c8			CMPQ CX, AX		
  0x417861		0f84e4030000		JE 0x417c4b		
	shrinkstack(gp)
  0x417867		48890424		MOVQ AX, 0(SP)			
  0x41786b		e8a0120200		CALL runtime.shrinkstack(SB)	
	var state stackScanState
  0x417870		488dbc24a8000000	LEAQ 0xa8(SP), DI	
  0x417878		0f57c0			XORPS X0, X0		
  0x41787b		48896c24f0		MOVQ BP, -0x10(SP)	
  0x417880		488d6c24f0		LEAQ -0x10(SP), BP	
  0x417885		e837280300		CALL 0x44a0c1		
  0x41788a		488b6d00		MOVQ 0(BP), BP		
	state.stack = gp.stack
  0x41788e		488b8424f8010000	MOVQ 0x1f8(SP), AX	
  0x417896		488b4808		MOVQ 0x8(AX), CX	
  0x41789a		488b10			MOVQ 0(AX), DX		
  0x41789d		48899424a8010000	MOVQ DX, 0x1a8(SP)	
  0x4178a5		48898c24b0010000	MOVQ CX, 0x1b0(SP)	
	if gp.sched.ctxt != nil {
  0x4178ad		4883785000		CMPQ $0x0, 0x50(AX)	
  0x4178b2		0f85ec020000		JNE 0x417ba4		
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x4178b8		0f11842490000000		MOVUPS X0, 0x90(SP)			
  0x4178c0		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)			
  0x4178cc		488d0dfddb0200			LEAQ runtime.scanstack.func1(SB), CX	
  0x4178d3		48898c2490000000		MOVQ CX, 0x90(SP)			
  0x4178db		488d8c24a8000000		LEAQ 0xa8(SP), CX			
  0x4178e3		48898c2498000000		MOVQ CX, 0x98(SP)			
  0x4178eb		488b942400020000		MOVQ 0x200(SP), DX			
  0x4178f3		48899424a0000000		MOVQ DX, 0xa0(SP)			
	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)
  0x4178fb		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x417903		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x41790c		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x417915		4889442418		MOVQ AX, 0x18(SP)		
  0x41791a		0f11442420		MOVUPS X0, 0x20(SP)		
  0x41791f		48c7442430ffffff7f	MOVQ $0x7fffffff, 0x30(SP)	
  0x417928		488d9c2490000000	LEAQ 0x90(SP), BX		
  0x417930		48895c2438		MOVQ BX, 0x38(SP)		
  0x417935		0f11442440		MOVUPS X0, 0x40(SP)		
  0x41793a		e8815e0200		CALL runtime.gentraceback(SB)	
	tracebackdefers(gp, scanframe, nil)
  0x41793f		488b8424f8010000	MOVQ 0x1f8(SP), AX			
  0x417947		48890424		MOVQ AX, 0(SP)				
  0x41794b		488d8c2490000000	LEAQ 0x90(SP), CX			
  0x417953		48894c2408		MOVQ CX, 0x8(SP)			
  0x417958		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x417961		e82a5c0200		CALL runtime.tracebackdefers(SB)	
	for d := gp._defer; d != nil; d = d.link {
  0x417966		488b8424f8010000	MOVQ 0x1f8(SP), AX	
  0x41796e		488b4828		MOVQ 0x28(AX), CX	
  0x417972		eb04			JMP 0x417978		
  0x417974		488b4928		MOVQ 0x28(CX), CX	
  0x417978		4885c9			TESTQ CX, CX		
  0x41797b		745d			JE 0x4179da		
		if d.fn != nil {
  0x41797d		4883791800		CMPQ $0x0, 0x18(CX)	
  0x417982		74f0			JE 0x417974		
	for d := gp._defer; d != nil; d = d.link {
  0x417984		48898c2488000000	MOVQ CX, 0x88(SP)	
		if d.fn != nil {
  0x41798c		488d4118		LEAQ 0x18(CX), AX	
			scanblock(uintptr(unsafe.Pointer(&d.fn)), sys.PtrSize, &oneptrmask[0], gcw, &state)
  0x417990		48890424		MOVQ AX, 0(SP)			
  0x417994		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x41799d		488d055c760a00		LEAQ 0xa765c(IP), AX		
  0x4179a4		4889442410		MOVQ AX, 0x10(SP)		
  0x4179a9		488b842400020000	MOVQ 0x200(SP), AX		
  0x4179b1		4889442418		MOVQ AX, 0x18(SP)		
  0x4179b6		488d9424a8000000	LEAQ 0xa8(SP), DX		
  0x4179be		4889542420		MOVQ DX, 0x20(SP)		
  0x4179c3		e8280d0000		CALL runtime.scanblock(SB)	
	if gp._panic != nil {
  0x4179c8		488b8424f8010000	MOVQ 0x1f8(SP), AX	
	for d := gp._defer; d != nil; d = d.link {
  0x4179d0		488b8c2488000000	MOVQ 0x88(SP), CX	
			scanblock(uintptr(unsafe.Pointer(&d.fn)), sys.PtrSize, &oneptrmask[0], gcw, &state)
  0x4179d8		eb9a			JMP 0x417974		
	if gp._panic != nil {
  0x4179da		488b4820		MOVQ 0x20(AX), CX	
  0x4179de		4885c9			TESTQ CX, CX		
  0x4179e1		0f85a2010000		JNE 0x417b89		
	state.buildIndex()
  0x4179e7		90			NOPL			
	s.root, _, _ = binarySearchTree(s.head, 0, s.nobjs)
  0x4179e8		488b8424c8010000	MOVQ 0x1c8(SP), AX			
  0x4179f0		488b8c24d8010000	MOVQ 0x1d8(SP), CX			
  0x4179f8		48890424		MOVQ AX, 0(SP)				
  0x4179fc		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x417a05		48894c2410		MOVQ CX, 0x10(SP)			
  0x417a0a		e8a1240000		CALL runtime.binarySearchTree(SB)	
  0x417a0f		488b442418		MOVQ 0x18(SP), AX			
  0x417a14		48898424e0010000	MOVQ AX, 0x1e0(SP)			
		p := state.getPtr()
  0x417a1c		488d8424a8000000	LEAQ 0xa8(SP), AX				
  0x417a24		48890424		MOVQ AX, 0(SP)					
  0x417a28		e813220000		CALL runtime.(*stackScanState).getPtr(SB)	
  0x417a2d		48837c240800		CMPQ $0x0, 0x8(SP)				
		if p == 0 {
  0x417a33		0f8406010000		JE 0x417b3f		
		obj := state.findObject(p)
  0x417a39		488d8424a8000000	LEAQ 0xa8(SP), AX				
  0x417a41		48890424		MOVQ AX, 0(SP)					
  0x417a45		e8c6250000		CALL runtime.(*stackScanState).findObject(SB)	
  0x417a4a		488b442410		MOVQ 0x10(SP), AX				
		if obj == nil {
  0x417a4f		4885c0			TESTQ AX, AX		
  0x417a52		74c8			JE 0x417a1c		
		t := obj.typ
  0x417a54		488b4808		MOVQ 0x8(AX), CX	
		if t == nil {
  0x417a58		4885c9			TESTQ CX, CX		
  0x417a5b		74bf			JE 0x417a1c		
		obj.setType(nil) // Don't scan it again.
  0x417a5d		90			NOPL			
	*(*uintptr)(unsafe.Pointer(&obj.typ)) = uintptr(unsafe.Pointer(typ))
  0x417a5e		31d2			XORL DX, DX		
  0x417a60		48895008		MOVQ DX, 0x8(AX)	
		gcdata := t.gcdata
  0x417a64		488b5120		MOVQ 0x20(CX), DX	
		if t.kind&kindGCProg != 0 {
  0x417a68		0fb65917		MOVZX 0x17(CX), BX	
  0x417a6c		f6c340			TESTL $0x40, BL		
  0x417a6f		7577			JNE 0x417ae8		
  0x417a71		31db			XORL BX, BX		
		if s != nil {
  0x417a73		48895c2478		MOVQ BX, 0x78(SP)	
		scanblock(state.stack.lo+uintptr(obj.off), t.ptrdata, gcdata, gcw, &state)
  0x417a78		8b00			MOVL 0(AX), AX			
  0x417a7a		48038424a8010000	ADDQ 0x1a8(SP), AX		
  0x417a82		488b4908		MOVQ 0x8(CX), CX		
  0x417a86		48890424		MOVQ AX, 0(SP)			
  0x417a8a		48894c2408		MOVQ CX, 0x8(SP)		
  0x417a8f		4889542410		MOVQ DX, 0x10(SP)		
  0x417a94		488b842400020000	MOVQ 0x200(SP), AX		
  0x417a9c		4889442418		MOVQ AX, 0x18(SP)		
  0x417aa1		488d8c24a8000000	LEAQ 0xa8(SP), CX		
  0x417aa9		48894c2420		MOVQ CX, 0x20(SP)		
  0x417aae		e83d0c0000		CALL runtime.scanblock(SB)	
		if s != nil {
  0x417ab3		488b442478		MOVQ 0x78(SP), AX	
  0x417ab8		4885c0			TESTQ AX, AX		
  0x417abb		0f845bffffff		JE 0x417a1c		
			dematerializeGCProg(s)
  0x417ac1		90			NOPL			
	mheap_.freeManual(s, &memstats.gc_sys)
  0x417ac2		488d0d77eb0a00		LEAQ runtime.mheap_(SB), CX		
  0x417ac9		48890c24		MOVQ CX, 0(SP)				
  0x417acd		4889442408		MOVQ AX, 0x8(SP)			
  0x417ad2		488d051f620c00		LEAQ runtime.memstats+152(SB), AX	
  0x417ad9		4889442410		MOVQ AX, 0x10(SP)			
  0x417ade		e8ad640000		CALL runtime.(*mheap).freeManual(SB)	
		p := state.getPtr()
  0x417ae3		e934ffffff		JMP 0x417a1c		
		obj := state.findObject(p)
  0x417ae8		4889842480000000	MOVQ AX, 0x80(SP)	
		t := obj.typ
  0x417af0		48894c2470		MOVQ CX, 0x70(SP)	
			s = materializeGCProg(t.ptrdata, gcdata)
  0x417af5		488b4108		MOVQ 0x8(CX), AX			
  0x417af9		48890424		MOVQ AX, 0(SP)				
  0x417afd		4889542408		MOVQ DX, 0x8(SP)			
  0x417b02		e8598bffff		CALL runtime.materializeGCProg(SB)	
  0x417b07		488b5c2410		MOVQ 0x10(SP), BX			
			gcdata = (*byte)(unsafe.Pointer(s.startAddr))
  0x417b0c		488b5318		MOVQ 0x18(BX), DX	
		scanblock(state.stack.lo+uintptr(obj.off), t.ptrdata, gcdata, gcw, &state)
  0x417b10		488b842480000000	MOVQ 0x80(SP), AX	
  0x417b18		488b4c2470		MOVQ 0x70(SP), CX	
			gcdata = (*byte)(unsafe.Pointer(s.startAddr))
  0x417b1d		e951ffffff		JMP 0x417a73		
		state.head = x.next
  0x417b22		488b4818		MOVQ 0x18(AX), CX	
  0x417b26		48898c24c8010000	MOVQ CX, 0x1c8(SP)	
		x.nobj = 0
  0x417b2e		48c7401000000000	MOVQ $0x0, 0x10(AX)	
		putempty((*workbuf)(unsafe.Pointer(x)))
  0x417b36		48890424		MOVQ AX, 0(SP)			
  0x417b3a		e8d1420000		CALL runtime.putempty(SB)	
	for state.head != nil {
  0x417b3f		488b8424c8010000	MOVQ 0x1c8(SP), AX	
  0x417b47		4885c0			TESTQ AX, AX		
  0x417b4a		75d6			JNE 0x417b22		
	if state.buf != nil || state.freeBuf != nil {
  0x417b4c		4883bc24b801000000	CMPQ $0x0, 0x1b8(SP)	
  0x417b55		0f85d5000000		JNE 0x417c30		
  0x417b5b		4883bc24c001000000	CMPQ $0x0, 0x1c0(SP)	
  0x417b64		0f85c6000000		JNE 0x417c30		
	gp.gcscanvalid = true
  0x417b6a		488b8424f8010000	MOVQ 0x1f8(SP), AX	
  0x417b72		c680b500000001		MOVB $0x1, 0xb5(AX)	
}
  0x417b79		488bac24e8010000	MOVQ 0x1e8(SP), BP	
  0x417b81		4881c4f0010000		ADDQ $0x1f0, SP		
  0x417b88		c3			RET			
		state.putPtr(uintptr(unsafe.Pointer(gp._panic)))
  0x417b89		488d8424a8000000	LEAQ 0xa8(SP), AX				
  0x417b91		48890424		MOVQ AX, 0(SP)					
  0x417b95		48894c2408		MOVQ CX, 0x8(SP)				
  0x417b9a		e8911f0000		CALL runtime.(*stackScanState).putPtr(SB)	
  0x417b9f		e943feffff		JMP 0x4179e7					
	if gp.sched.ctxt != nil {
  0x417ba4		488d4850		LEAQ 0x50(AX), CX	
		scanblock(uintptr(unsafe.Pointer(&gp.sched.ctxt)), sys.PtrSize, &oneptrmask[0], gcw, &state)
  0x417ba8		48890c24		MOVQ CX, 0(SP)			
  0x417bac		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x417bb5		488d0d44740a00		LEAQ 0xa7444(IP), CX		
  0x417bbc		48894c2410		MOVQ CX, 0x10(SP)		
  0x417bc1		488b8c2400020000	MOVQ 0x200(SP), CX		
  0x417bc9		48894c2418		MOVQ CX, 0x18(SP)		
  0x417bce		488d9424a8000000	LEAQ 0xa8(SP), DX		
  0x417bd6		4889542420		MOVQ DX, 0x20(SP)		
  0x417bdb		e8100b0000		CALL runtime.scanblock(SB)	
	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)
  0x417be0		488b8424f8010000	MOVQ 0x1f8(SP), AX	
	var state stackScanState
  0x417be8		0f57c0			XORPS X0, X0		
		scanblock(uintptr(unsafe.Pointer(&gp.sched.ctxt)), sys.PtrSize, &oneptrmask[0], gcw, &state)
  0x417beb		e9c8fcffff		JMP 0x4178b8		
	switch readgstatus(gp) &^ _Gscan {
  0x417bf0		83f902			CMPL $0x2, CX		
	case _Grunning:
  0x417bf3		0f8527010000		JNE 0x417d20		
  0x417bf9		eb6b			JMP 0x417c66		
	case _Grunnable, _Gsyscall, _Gwaiting:
  0x417bfb		8d51fd			LEAL -0x3(CX), DX	
  0x417bfe		83fa01			CMPL $0x1, DX		
  0x417c01		0f864efcffff		JBE 0x417855		
	case _Gdead:
  0x417c07		83f906			CMPL $0x6, CX		
  0x417c0a		0f8510010000		JNE 0x417d20		
		return
  0x417c10		488bac24e8010000	MOVQ 0x1e8(SP), BP	
  0x417c18		4881c4f0010000		ADDQ $0x1f0, SP		
  0x417c1f		c3			RET			
		return
  0x417c20		488bac24e8010000	MOVQ 0x1e8(SP), BP	
  0x417c28		4881c4f0010000		ADDQ $0x1f0, SP		
  0x417c2f		c3			RET			
		throw("remaining pointer buffers")
  0x417c30		488d055f940500		LEAQ 0x5945f(IP), AX	
  0x417c37		48890424		MOVQ AX, 0(SP)		
  0x417c3b		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x417c44		e837b80000		CALL runtime.throw(SB)	
  0x417c49		0f0b			UD2			
		throw("can't scan our own stack")
  0x417c4b		488d0510920500		LEAQ 0x59210(IP), AX	
  0x417c52		48890424		MOVQ AX, 0(SP)		
  0x417c56		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x417c5f		e81cb80000		CALL runtime.throw(SB)	
  0x417c64		0f0b			UD2			
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x417c66		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x417c67		8b8890000000		MOVL 0x90(AX), CX	
  0x417c6d		894c245c		MOVL CX, 0x5c(SP)	
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x417c71		488b9098000000		MOVQ 0x98(AX), DX		
  0x417c78		4889542468		MOVQ DX, 0x68(SP)		
  0x417c7d		e83ec20000		CALL runtime.printlock(SB)	
  0x417c82		488d05a87e0500		LEAQ 0x57ea8(IP), AX		
  0x417c89		48890424		MOVQ AX, 0(SP)			
  0x417c8d		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x417c96		e855cb0000		CALL runtime.printstring(SB)	
  0x417c9b		488b8424f8010000	MOVQ 0x1f8(SP), AX		
  0x417ca3		48890424		MOVQ AX, 0(SP)			
  0x417ca7		e804cb0000		CALL runtime.printpointer(SB)	
  0x417cac		488d0529760500		LEAQ 0x57629(IP), AX		
  0x417cb3		48890424		MOVQ AX, 0(SP)			
  0x417cb7		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x417cc0		e82bcb0000		CALL runtime.printstring(SB)	
  0x417cc5		488b442468		MOVQ 0x68(SP), AX		
  0x417cca		48890424		MOVQ AX, 0(SP)			
  0x417cce		e86dc90000		CALL runtime.printint(SB)	
  0x417cd3		488d05a3860500		LEAQ 0x586a3(IP), AX		
  0x417cda		48890424		MOVQ AX, 0(SP)			
  0x417cde		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x417ce7		e804cb0000		CALL runtime.printstring(SB)	
  0x417cec		8b44245c		MOVL 0x5c(SP), AX		
  0x417cf0		89c0			MOVL AX, AX			
  0x417cf2		48890424		MOVQ AX, 0(SP)			
  0x417cf6		e845c80000		CALL runtime.printuint(SB)	
  0x417cfb		e850c40000		CALL runtime.printnl(SB)	
  0x417d00		e83bc20000		CALL runtime.printunlock(SB)	
		throw("scanstack: goroutine not stopped")
  0x417d05		488d0505a30500		LEAQ 0x5a305(IP), AX	
  0x417d0c		48890424		MOVQ AX, 0(SP)		
  0x417d10		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x417d19		e862b70000		CALL runtime.throw(SB)	
  0x417d1e		0f0b			UD2			
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x417d20		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x417d21		8b8890000000		MOVL 0x90(AX), CX	
  0x417d27		894c2460		MOVL CX, 0x60(SP)	
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x417d2b		488b9098000000		MOVQ 0x98(AX), DX		
  0x417d32		4889542468		MOVQ DX, 0x68(SP)		
  0x417d37		e884c10000		CALL runtime.printlock(SB)	
  0x417d3c		488d05ee7d0500		LEAQ 0x57dee(IP), AX		
  0x417d43		48890424		MOVQ AX, 0(SP)			
  0x417d47		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x417d50		e89bca0000		CALL runtime.printstring(SB)	
  0x417d55		488b8424f8010000	MOVQ 0x1f8(SP), AX		
  0x417d5d		48890424		MOVQ AX, 0(SP)			
  0x417d61		e84aca0000		CALL runtime.printpointer(SB)	
  0x417d66		488d056f750500		LEAQ 0x5756f(IP), AX		
  0x417d6d		48890424		MOVQ AX, 0(SP)			
  0x417d71		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x417d7a		e871ca0000		CALL runtime.printstring(SB)	
  0x417d7f		488b442468		MOVQ 0x68(SP), AX		
  0x417d84		48890424		MOVQ AX, 0(SP)			
  0x417d88		e8b3c80000		CALL runtime.printint(SB)	
  0x417d8d		488d05e9850500		LEAQ 0x585e9(IP), AX		
  0x417d94		48890424		MOVQ AX, 0(SP)			
  0x417d98		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x417da1		e84aca0000		CALL runtime.printstring(SB)	
  0x417da6		8b442460		MOVL 0x60(SP), AX		
  0x417daa		89c0			MOVL AX, AX			
  0x417dac		48890424		MOVQ AX, 0(SP)			
  0x417db0		e88bc70000		CALL runtime.printuint(SB)	
  0x417db5		e896c30000		CALL runtime.printnl(SB)	
  0x417dba		e881c10000		CALL runtime.printunlock(SB)	
		throw("mark - bad status")
  0x417dbf		488d05dc830500		LEAQ 0x583dc(IP), AX	
  0x417dc6		48890424		MOVQ AX, 0(SP)		
  0x417dca		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x417dd3		e8a8b60000		CALL runtime.throw(SB)	
  0x417dd8		0f0b			UD2			
		print("runtime:scanstack: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", hex(readgstatus(gp)), "\n")
  0x417dda		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x417ddb		8b8890000000		MOVL 0x90(AX), CX	
  0x417de1		894c2464		MOVL CX, 0x64(SP)	
		print("runtime:scanstack: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", hex(readgstatus(gp)), "\n")
  0x417de5		488b9098000000		MOVQ 0x98(AX), DX		
  0x417dec		4889542468		MOVQ DX, 0x68(SP)		
  0x417df1		e8cac00000		CALL runtime.printlock(SB)	
  0x417df6		488d058e8c0500		LEAQ 0x58c8e(IP), AX		
  0x417dfd		48890424		MOVQ AX, 0(SP)			
  0x417e01		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x417e0a		e8e1c90000		CALL runtime.printstring(SB)	
  0x417e0f		488b8424f8010000	MOVQ 0x1f8(SP), AX		
  0x417e17		48890424		MOVQ AX, 0(SP)			
  0x417e1b		e890c90000		CALL runtime.printpointer(SB)	
  0x417e20		488d05b5740500		LEAQ 0x574b5(IP), AX		
  0x417e27		48890424		MOVQ AX, 0(SP)			
  0x417e2b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x417e34		e8b7c90000		CALL runtime.printstring(SB)	
  0x417e39		488b442468		MOVQ 0x68(SP), AX		
  0x417e3e		48890424		MOVQ AX, 0(SP)			
  0x417e42		e8f9c70000		CALL runtime.printint(SB)	
  0x417e47		488d052f850500		LEAQ 0x5852f(IP), AX		
  0x417e4e		48890424		MOVQ AX, 0(SP)			
  0x417e52		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x417e5b		e890c90000		CALL runtime.printstring(SB)	
  0x417e60		8b442464		MOVL 0x64(SP), AX		
  0x417e64		89c0			MOVL AX, AX			
  0x417e66		48890424		MOVQ AX, 0(SP)			
  0x417e6a		e841c80000		CALL runtime.printhex(SB)	
  0x417e6f		e8dcc20000		CALL runtime.printnl(SB)	
  0x417e74		e8c7c00000		CALL runtime.printunlock(SB)	
		throw("scanstack - bad status")
  0x417e79		488d05378c0500		LEAQ 0x58c37(IP), AX	
  0x417e80		48890424		MOVQ AX, 0(SP)		
  0x417e84		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x417e8d		e8eeb50000		CALL runtime.throw(SB)	
  0x417e92		0f0b			UD2			
func scanstack(gp *g, gcw *gcWork) {
  0x417e94		e837180200		CALL runtime.morestackc(SB)	
  0x417e99		e942f9ffff		JMP runtime.scanstack(SB)	

TEXT runtime.scanframeworker(SB) /usr/local/go/src/runtime/mgcmark.go
func scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork) {
  0x417ea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x417ea9		488d4424f8		LEAQ -0x8(SP), AX	
  0x417eae		483b4110		CMPQ 0x10(CX), AX	
  0x417eb2		0f86b4010000		JBE 0x41806c		
  0x417eb8		4881ec88000000		SUBQ $0x88, SP		
  0x417ebf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x417ec7		488dac2480000000	LEAQ 0x80(SP), BP	
	locals, args, objs := getStackMap(frame, &state.cache, false)
  0x417ecf		488b842498000000	MOVQ 0x98(SP), AX		
  0x417ed7		8400			TESTB AL, 0(AX)			
  0x417ed9		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x417ee1		48890c24		MOVQ CX, 0(SP)			
  0x417ee5		4889442408		MOVQ AX, 0x8(SP)		
  0x417eea		c644241000		MOVB $0x0, 0x10(SP)		
  0x417eef		e83c0f0200		CALL runtime.getStackMap(SB)	
  0x417ef4		488b442438		MOVQ 0x38(SP), AX		
  0x417ef9		4889442468		MOVQ AX, 0x68(SP)		
  0x417efe		488b4c2440		MOVQ 0x40(SP), CX		
  0x417f03		48894c2458		MOVQ CX, 0x58(SP)		
  0x417f08		488b542430		MOVQ 0x30(SP), DX		
  0x417f0d		8b5c2428		MOVL 0x28(SP), BX		
  0x417f11		488b742420		MOVQ 0x20(SP), SI		
  0x417f16		8b7c2418		MOVL 0x18(SP), DI		
	if locals.n > 0 {
  0x417f1a		85ff			TESTL DI, DI		
  0x417f1c		0f8fe6000000		JG 0x418008		
	if args.n > 0 {
  0x417f22		85db			TESTL BX, BX		
  0x417f24		0f8f8f000000		JG 0x417fb9		
	if frame.varp != 0 {
  0x417f2a		488b942490000000	MOVQ 0x90(SP), DX	
  0x417f32		48837a3800		CMPQ $0x0, 0x38(DX)	
  0x417f37		7432			JE 0x417f6b		
		for _, obj := range objs {
  0x417f39		4885c9			TESTQ CX, CX		
  0x417f3c		7e2d			JLE 0x417f6b		
  0x417f3e		31db			XORL BX, BX		
  0x417f40		eb04			JMP 0x417f46		
  0x417f42		4883c010		ADDQ $0x10, AX		
  0x417f46		488b7008		MOVQ 0x8(AX), SI	
  0x417f4a		488b38			MOVQ 0(AX), DI		
			base := frame.varp // locals base pointer
  0x417f4d		4c8b4238		MOVQ 0x38(DX), R8	
			if off >= 0 {
  0x417f51		4885ff			TESTQ DI, DI		
  0x417f54		7c04			JL 0x417f5a		
				base = frame.argp // arguments and return values base pointer
  0x417f56		4c8b4240		MOVQ 0x40(DX), R8	
			ptr := base + uintptr(off)
  0x417f5a		4c01c7			ADDQ R8, DI		
			if ptr < frame.sp {
  0x417f5d		48397a28		CMPQ DI, 0x28(DX)	
  0x417f61		7618			JBE 0x417f7b		
		for _, obj := range objs {
  0x417f63		48ffc3			INCQ BX			
  0x417f66		4839cb			CMPQ CX, BX		
  0x417f69		7cd7			JL 0x417f42		
  0x417f6b		488bac2480000000	MOVQ 0x80(SP), BP	
  0x417f73		4881c488000000		ADDQ $0x88, SP		
  0x417f7a		c3			RET			
  0x417f7b		4889442478		MOVQ AX, 0x78(SP)	
  0x417f80		48895c2460		MOVQ BX, 0x60(SP)	
			state.addObject(ptr, obj.typ)
  0x417f85		488b842498000000	MOVQ 0x98(SP), AX				
  0x417f8d		48890424		MOVQ AX, 0(SP)					
  0x417f91		48897c2408		MOVQ DI, 0x8(SP)				
  0x417f96		4889742410		MOVQ SI, 0x10(SP)				
  0x417f9b		e8a01d0000		CALL runtime.(*stackScanState).addObject(SB)	
		for _, obj := range objs {
  0x417fa0		488b442478		MOVQ 0x78(SP), AX	
  0x417fa5		488b4c2458		MOVQ 0x58(SP), CX	
			base := frame.varp // locals base pointer
  0x417faa		488b942490000000	MOVQ 0x90(SP), DX	
		for _, obj := range objs {
  0x417fb2		488b5c2460		MOVQ 0x60(SP), BX	
			state.addObject(ptr, obj.typ)
  0x417fb7		ebaa			JMP 0x417f63		
		scanblock(frame.argp, uintptr(args.n)*sys.PtrSize, args.bytedata, gcw, state)
  0x417fb9		488b842490000000	MOVQ 0x90(SP), AX		
  0x417fc1		488b4840		MOVQ 0x40(AX), CX		
  0x417fc5		48890c24		MOVQ CX, 0(SP)			
  0x417fc9		4863cb			MOVSXD BX, CX			
  0x417fcc		48c1e103		SHLQ $0x3, CX			
  0x417fd0		48894c2408		MOVQ CX, 0x8(SP)		
  0x417fd5		4889542410		MOVQ DX, 0x10(SP)		
  0x417fda		488b8c24a0000000	MOVQ 0xa0(SP), CX		
  0x417fe2		48894c2418		MOVQ CX, 0x18(SP)		
  0x417fe7		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x417fef		48894c2420		MOVQ CX, 0x20(SP)		
  0x417ff4		e8f7060000		CALL runtime.scanblock(SB)	
		for _, obj := range objs {
  0x417ff9		488b442468		MOVQ 0x68(SP), AX	
  0x417ffe		488b4c2458		MOVQ 0x58(SP), CX	
		scanblock(frame.argp, uintptr(args.n)*sys.PtrSize, args.bytedata, gcw, state)
  0x418003		e922ffffff		JMP 0x417f2a		
	locals, args, objs := getStackMap(frame, &state.cache, false)
  0x418008		4889542470		MOVQ DX, 0x70(SP)	
  0x41800d		895c2454		MOVL BX, 0x54(SP)	
		size := uintptr(locals.n) * sys.PtrSize
  0x418011		4863c7			MOVSXD DI, AX		
  0x418014		48c1e003		SHLQ $0x3, AX		
		scanblock(frame.varp-size, size, locals.bytedata, gcw, state)
  0x418018		488b8c2490000000	MOVQ 0x90(SP), CX		
  0x418020		488b5138		MOVQ 0x38(CX), DX		
  0x418024		4829c2			SUBQ AX, DX			
  0x418027		48891424		MOVQ DX, 0(SP)			
  0x41802b		4889442408		MOVQ AX, 0x8(SP)		
  0x418030		4889742410		MOVQ SI, 0x10(SP)		
  0x418035		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x41803d		4889442418		MOVQ AX, 0x18(SP)		
  0x418042		488b942498000000	MOVQ 0x98(SP), DX		
  0x41804a		4889542420		MOVQ DX, 0x20(SP)		
  0x41804f		e89c060000		CALL runtime.scanblock(SB)	
		for _, obj := range objs {
  0x418054		488b442468		MOVQ 0x68(SP), AX	
  0x418059		488b4c2458		MOVQ 0x58(SP), CX	
		scanblock(frame.argp, uintptr(args.n)*sys.PtrSize, args.bytedata, gcw, state)
  0x41805e		488b542470		MOVQ 0x70(SP), DX	
	if args.n > 0 {
  0x418063		8b5c2454		MOVL 0x54(SP), BX	
		scanblock(frame.varp-size, size, locals.bytedata, gcw, state)
  0x418067		e9b6feffff		JMP 0x417f22		
func scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork) {
  0x41806c		e80ff80200		CALL runtime.morestack_noctxt(SB)	
  0x418071		e92afeffff		JMP runtime.scanframeworker(SB)		

TEXT runtime.gcDrain(SB) /usr/local/go/src/runtime/mgcmark.go
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
  0x418080		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418089		483b6110		CMPQ 0x10(CX), SP	
  0x41808d		0f8614040000		JBE 0x4184a7		
  0x418093		4883ec50		SUBQ $0x50, SP		
  0x418097		48896c2448		MOVQ BP, 0x48(SP)	
  0x41809c		488d6c2448		LEAQ 0x48(SP), BP	
	if !writeBarrier.needed {
  0x4180a1		803d7c4d0c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x4180a8		0f84de030000		JE 0x41848c				
	gp := getg().m.curg
  0x4180ae		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4180b7		488b4030		MOVQ 0x30(AX), AX	
  0x4180bb		488b80c0000000		MOVQ 0xc0(AX), AX	
	initScanWork := gcw.scanWork
  0x4180c2		488b4c2458		MOVQ 0x58(SP), CX	
  0x4180c7		488b5118		MOVQ 0x18(CX), DX	
	if flags&(gcDrainIdle|gcDrainFractional) != 0 {
  0x4180cb		488b5c2460		MOVQ 0x60(SP), BX	
  0x4180d0		48f7c30c000000		TESTQ $0xc, BX		
  0x4180d7		0f8497030000		JE 0x418474		
	idle := flags&gcDrainIdle != 0
  0x4180dd		0fbae302		BTL $0x2, BX		
		if idle {
  0x4180e1		0f8371030000		JAE 0x418458		
  0x4180e7		488d3552b80500		LEAQ 0x5b852(IP), SI	
		checkWork = initScanWork + drainCheckThreshold
  0x4180ee		488dbaa0860100		LEAQ 0x186a0(DX), DI	
	gp := getg().m.curg
  0x4180f5		4889442438		MOVQ AX, 0x38(SP)	
				if check != nil && check() {
  0x4180fa		4889742440		MOVQ SI, 0x40(SP)	
	if work.markrootNext < work.markrootJobs {
  0x4180ff		448b05069f0a00		MOVL runtime.work+140(SB), R8	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418106		0fbae300		BTL $0x0, BX		
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x41810a		0fbae301		BTL $0x1, BX		
	if work.markrootNext < work.markrootJobs {
  0x41810e		443905f39e0a00		CMPL R8, runtime.work+136(SB)	
  0x418115		0f8334030000		JAE 0x41844f			
	initScanWork := gcw.scanWork
  0x41811b		4889542410		MOVQ DX, 0x10(SP)	
			checkWork -= gcw.scanWork
  0x418120		48897c2418		MOVQ DI, 0x18(SP)	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418125		0fbae300		BTL $0x0, BX		
		for !(preemptible && gp.preempt) {
  0x418129		eb28			JMP 0x418153		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x41812b		488b5c2460		MOVQ 0x60(SP), BX	
  0x418130		0fbae300		BTL $0x0, BX		
		for !(preemptible && gp.preempt) {
  0x418134		4c8b442458		MOVQ 0x58(SP), R8	
  0x418139		4c8b4c2438		MOVQ 0x38(SP), R9	
  0x41813e		4c89c8			MOVQ R9, AX		
			markroot(gcw, job)
  0x418141		4c89c1			MOVQ R8, CX		
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418144		488b542410		MOVQ 0x10(SP), DX	
			if check != nil && check() {
  0x418149		488b742440		MOVQ 0x40(SP), SI	
			checkWork -= gcw.scanWork
  0x41814e		488b7c2418		MOVQ 0x18(SP), DI	
		for !(preemptible && gp.preempt) {
  0x418153		730d			JAE 0x418162		
  0x418155		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41815c		0f85e4020000		JNE 0x418446		
			job := atomic.Xadd(&work.markrootNext, +1) - 1
  0x418162		41b801000000		MOVL $0x1, R8			
  0x418168		4c8d0d999e0a00		LEAQ runtime.work+136(SB), R9	
  0x41816f		f0450fc101		LOCK XADDL R8, 0(R9)		
			if job >= work.markrootJobs {
  0x418174		448b15919e0a00		MOVL runtime.work+140(SB), R10	
  0x41817b		4539d0			CMPL R10, R8			
  0x41817e		0f8381000000		JAE 0x418205			
			markroot(gcw, job)
  0x418184		48890c24		MOVQ CX, 0(SP)			
  0x418188		4489442408		MOVL R8, 0x8(SP)		
  0x41818d		e83ee5ffff		CALL runtime.markroot(SB)	
			if check != nil && check() {
  0x418192		488b542440		MOVQ 0x40(SP), DX	
  0x418197		4885d2			TESTQ DX, DX		
  0x41819a		7559			JNE 0x4181f5		
  0x41819c		31c0			XORL AX, AX		
  0x41819e		84c0			TESTL AL, AL		
  0x4181a0		7489			JE 0x41812b		
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4181a2		488b442410		MOVQ 0x10(SP), AX	
	if gcw.scanWork > 0 {
  0x4181a7		488b4c2458		MOVQ 0x58(SP), CX	
  0x4181ac		488b5118		MOVQ 0x18(CX), DX	
  0x4181b0		4885d2			TESTQ DX, DX		
  0x4181b3		7e1f			JLE 0x4181d4		
		atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x4181b5		488d1dc44f0c00		LEAQ runtime.gcController(SB), BX	
  0x4181bc		f0480fc113		LOCK XADDQ DX, 0(BX)			
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x4181c1		488b542460		MOVQ 0x60(SP), DX	
  0x4181c6		0fbae201		BTL $0x1, DX		
		if flushBgCredit {
  0x4181ca		7212			JB 0x4181de		
		gcw.scanWork = 0
  0x4181cc		48c7411800000000	MOVQ $0x0, 0x18(CX)	
  0x4181d4		488b6c2448		MOVQ 0x48(SP), BP	
  0x4181d9		4883c450		ADDQ $0x50, SP		
  0x4181dd		c3			RET			
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4181de		488b5118		MOVQ 0x18(CX), DX			
  0x4181e2		4829c2			SUBQ AX, DX				
  0x4181e5		48891424		MOVQ DX, 0(SP)				
  0x4181e9		e862f4ffff		CALL runtime.gcFlushBgCredit(SB)	
		gcw.scanWork = 0
  0x4181ee		488b4c2458		MOVQ 0x58(SP), CX	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4181f3		ebd7			JMP 0x4181cc		
			if check != nil && check() {
  0x4181f5		488b02			MOVQ 0(DX), AX		
  0x4181f8		ffd0			CALL AX			
  0x4181fa		0fb60424		MOVZX 0(SP), AX		
  0x4181fe		488b542440		MOVQ 0x40(SP), DX	
  0x418203		eb99			JMP 0x41819e		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418205		0fbae300		BTL $0x0, BX		
				break
  0x418209		eb1a			JMP 0x418225		
	for !(preemptible && gp.preempt) {
  0x41820b		4c8b442438		MOVQ 0x38(SP), R8	
  0x418210		4c89c0			MOVQ R8, AX		
	wbuf := w.wbuf1
  0x418213		488b4c2458		MOVQ 0x58(SP), CX	
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x418218		488b5c2460		MOVQ 0x60(SP), BX	
			checkWork -= gcw.scanWork
  0x41821d		4889f7			MOVQ SI, DI		
				if check != nil && check() {
  0x418220		488b742440		MOVQ 0x40(SP), SI	
	for !(preemptible && gp.preempt) {
  0x418225		730d			JAE 0x418234		
  0x418227		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41822e		0f8507020000		JNE 0x41843b		
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418234		4889542430		MOVQ DX, 0x30(SP)	
			checkWork -= gcw.scanWork
  0x418239		48897c2418		MOVQ DI, 0x18(SP)	
		if work.full == 0 {
  0x41823e		48833d3a9d0a0000	CMPQ $0x0, runtime.work(SB)	
  0x418246		0f84c3010000		JE 0x41840f			
		b := gcw.tryGetFast()
  0x41824c		90			NOPL			
	wbuf := w.wbuf1
  0x41824d		4c8b01			MOVQ 0(CX), R8		
	if wbuf == nil {
  0x418250		4d85c0			TESTQ R8, R8		
  0x418253		0f84ae010000		JE 0x418407		
	if wbuf.nobj == 0 {
  0x418259		4d8b4810		MOVQ 0x10(R8), R9	
  0x41825d		4d85c9			TESTQ R9, R9		
  0x418260		0f8582010000		JNE 0x4183e8		
  0x418266		4531c0			XORL R8, R8		
		if b == 0 {
  0x418269		4d85c0			TESTQ R8, R8		
  0x41826c		0f841c010000		JE 0x41838e		
		if b == 0 {
  0x418272		4d85c0			TESTQ R8, R8		
  0x418275		0f8408010000		JE 0x418383		
		scanobject(b, gcw)
  0x41827b		4c890424		MOVQ R8, 0(SP)			
  0x41827f		48894c2408		MOVQ CX, 0x8(SP)		
  0x418284		e8e7050000		CALL runtime.scanobject(SB)	
		if gcw.scanWork >= gcCreditSlack {
  0x418289		488b442458		MOVQ 0x58(SP), AX	
  0x41828e		488b4818		MOVQ 0x18(AX), CX	
  0x418292		4881f9d0070000		CMPQ $0x7d0, CX		
  0x418299		0f8cc7000000		JL 0x418366		
			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x41829f		488d1dda4e0c00		LEAQ runtime.gcController(SB), BX	
  0x4182a6		f0480fc10b		LOCK XADDQ CX, 0(BX)			
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x4182ab		488b4c2460		MOVQ 0x60(SP), CX	
  0x4182b0		0fbae101		BTL $0x1, CX		
			if flushBgCredit {
  0x4182b4		0f8286000000		JB 0x418340		
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4182ba		488b542430		MOVQ 0x30(SP), DX	
			checkWork -= gcw.scanWork
  0x4182bf		488b5818		MOVQ 0x18(AX), BX	
			gcw.scanWork = 0
  0x4182c3		48c7401800000000	MOVQ $0x0, 0x18(AX)	
			checkWork -= gcw.scanWork
  0x4182cb		488b742418		MOVQ 0x18(SP), SI	
  0x4182d0		4829de			SUBQ BX, SI		
			if checkWork <= 0 {
  0x4182d3		4885f6			TESTQ SI, SI		
  0x4182d6		7f5a			JG 0x418332		
				if check != nil && check() {
  0x4182d8		488b5c2440		MOVQ 0x40(SP), BX	
  0x4182dd		4885db			TESTQ BX, BX		
  0x4182e0		751f			JNE 0x418301		
  0x4182e2		31ff			XORL DI, DI		
  0x4182e4		4084ff			TESTL DI, DI		
  0x4182e7		7510			JNE 0x4182f9		
				checkWork += drainCheckThreshold
  0x4182e9		4881c6a0860100		ADDQ $0x186a0, SI	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4182f0		0fbae100		BTL $0x0, CX		
	for !(preemptible && gp.preempt) {
  0x4182f4		e912ffffff		JMP 0x41820b		
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4182f9		4889d0			MOVQ DX, AX		
	if gcw.scanWork > 0 {
  0x4182fc		e9a6feffff		JMP 0x4181a7		
			checkWork -= gcw.scanWork
  0x418301		4889742428		MOVQ SI, 0x28(SP)	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418306		4889542420		MOVQ DX, 0x20(SP)	
				if check != nil && check() {
  0x41830b		488b03			MOVQ 0(BX), AX		
  0x41830e		4889da			MOVQ BX, DX		
  0x418311		ffd0			CALL AX			
  0x418313		0fb63c24		MOVZX 0(SP), DI		
	wbuf := w.wbuf1
  0x418317		488b442458		MOVQ 0x58(SP), AX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x41831c		488b4c2460		MOVQ 0x60(SP), CX	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418321		488b542420		MOVQ 0x20(SP), DX	
				if check != nil && check() {
  0x418326		488b5c2440		MOVQ 0x40(SP), BX	
				checkWork += drainCheckThreshold
  0x41832b		488b742428		MOVQ 0x28(SP), SI	
				if check != nil && check() {
  0x418330		ebb2			JMP 0x4182e4		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418332		0fbae100		BTL $0x0, CX		
				if check != nil && check() {
  0x418336		488b5c2440		MOVQ 0x40(SP), BX	
			if checkWork <= 0 {
  0x41833b		e9cbfeffff		JMP 0x41820b		
				gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418340		488b4818		MOVQ 0x18(AX), CX			
  0x418344		488b542430		MOVQ 0x30(SP), DX			
  0x418349		4829d1			SUBQ DX, CX				
  0x41834c		48890c24		MOVQ CX, 0(SP)				
  0x418350		e8fbf2ffff		CALL runtime.gcFlushBgCredit(SB)	
			checkWork -= gcw.scanWork
  0x418355		488b442458		MOVQ 0x58(SP), AX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x41835a		488b4c2460		MOVQ 0x60(SP), CX	
  0x41835f		31d2			XORL DX, DX		
				initScanWork = 0
  0x418361		e959ffffff		JMP 0x4182bf		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418366		488b4c2460		MOVQ 0x60(SP), CX	
  0x41836b		0fbae100		BTL $0x0, CX		
				if check != nil && check() {
  0x41836f		488b5c2440		MOVQ 0x40(SP), BX	
			checkWork -= gcw.scanWork
  0x418374		488b742418		MOVQ 0x18(SP), SI	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418379		488b542430		MOVQ 0x30(SP), DX	
		if gcw.scanWork >= gcCreditSlack {
  0x41837e		e988feffff		JMP 0x41820b		
	if gcw.scanWork > 0 {
  0x418383		4889c8			MOVQ CX, AX		
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x418386		4889d9			MOVQ BX, CX		
			break
  0x418389		e96bffffff		JMP 0x4182f9		
			b = gcw.tryGet()
  0x41838e		48890c24		MOVQ CX, 0(SP)				
  0x418392		e8a9340000		CALL runtime.(*gcWork).tryGet(SB)	
  0x418397		488b442408		MOVQ 0x8(SP), AX			
			if b == 0 {
  0x41839c		4885c0			TESTQ AX, AX		
  0x41839f		7426			JE 0x4183c7		
		scanobject(b, gcw)
  0x4183a1		488b4c2458		MOVQ 0x58(SP), CX	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x4183a6		488b542430		MOVQ 0x30(SP), DX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x4183ab		488b5c2460		MOVQ 0x60(SP), BX	
				if check != nil && check() {
  0x4183b0		488b742440		MOVQ 0x40(SP), SI	
			checkWork -= gcw.scanWork
  0x4183b5		488b7c2418		MOVQ 0x18(SP), DI	
		if b == 0 {
  0x4183ba		4989c0			MOVQ AX, R8		
	for !(preemptible && gp.preempt) {
  0x4183bd		488b442438		MOVQ 0x38(SP), AX	
		if b == 0 {
  0x4183c2		e9abfeffff		JMP 0x418272		
				wbBufFlush(nil, 0)
  0x4183c7		0f57c0			XORPS X0, X0			
  0x4183ca		0f110424		MOVUPS X0, 0(SP)		
  0x4183ce		e82d880000		CALL runtime.wbBufFlush(SB)	
				b = gcw.tryGet()
  0x4183d3		488b442458		MOVQ 0x58(SP), AX			
  0x4183d8		48890424		MOVQ AX, 0(SP)				
  0x4183dc		e85f340000		CALL runtime.(*gcWork).tryGet(SB)	
  0x4183e1		488b442408		MOVQ 0x8(SP), AX			
  0x4183e6		ebb9			JMP 0x4183a1				
	wbuf.nobj--
  0x4183e8		4d8d51ff		LEAQ -0x1(R9), R10	
  0x4183ec		4d895010		MOVQ R10, 0x10(R8)	
	return wbuf.obj[wbuf.nobj]
  0x4183f0		4981fafd000000		CMPQ $0xfd, R10		
  0x4183f7		0f8388000000		JAE 0x418485		
  0x4183fd		4f8b44c810		MOVQ 0x10(R8)(R9*8), R8	
		b := gcw.tryGetFast()
  0x418402		e962feffff		JMP 0x418269		
  0x418407		4531c0			XORL R8, R8		
  0x41840a		e95afeffff		JMP 0x418269		
			gcw.balance()
  0x41840f		48890c24		MOVQ CX, 0(SP)				
  0x418413		e808360000		CALL runtime.(*gcWork).balance(SB)	
	for !(preemptible && gp.preempt) {
  0x418418		488b442438		MOVQ 0x38(SP), AX	
	wbuf := w.wbuf1
  0x41841d		488b4c2458		MOVQ 0x58(SP), CX	
			gcFlushBgCredit(gcw.scanWork - initScanWork)
  0x418422		488b542430		MOVQ 0x30(SP), DX	
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418427		488b5c2460		MOVQ 0x60(SP), BX	
				if check != nil && check() {
  0x41842c		488b742440		MOVQ 0x40(SP), SI	
			checkWork -= gcw.scanWork
  0x418431		488b7c2418		MOVQ 0x18(SP), DI	
			gcw.balance()
  0x418436		e911feffff		JMP 0x41824c		
	if gcw.scanWork > 0 {
  0x41843b		4889c8			MOVQ CX, AX		
	flushBgCredit := flags&gcDrainFlushBgCredit != 0
  0x41843e		4889d9			MOVQ BX, CX		
	for !(preemptible && gp.preempt) {
  0x418441		e9b3feffff		JMP 0x4182f9		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x418446		0fbae300		BTL $0x0, BX		
		for !(preemptible && gp.preempt) {
  0x41844a		e9d6fdffff		JMP 0x418225		
	preemptible := flags&gcDrainUntilPreempt != 0
  0x41844f		0fbae300		BTL $0x0, BX		
	if work.markrootNext < work.markrootJobs {
  0x418453		e9cdfdffff		JMP 0x418225		
		} else if flags&gcDrainFractional != 0 {
  0x418458		48f7c308000000		TESTQ $0x8, BX		
				if check != nil && check() {
  0x41845f		be00000000		MOVL $0x0, SI		
  0x418464		488d3dcdb40500		LEAQ 0x5b4cd(IP), DI	
  0x41846b		480f45f7		CMOVNE DI, SI		
		} else if flags&gcDrainFractional != 0 {
  0x41846f		e97afcffff		JMP 0x4180ee			
  0x418474		48bfffffffffffffff7f	MOVQ $0x7fffffffffffffff, DI	
  0x41847e		31f6			XORL SI, SI			
	if flags&(gcDrainIdle|gcDrainFractional) != 0 {
  0x418480		e970fcffff		JMP 0x4180f5		
	return wbuf.obj[wbuf.nobj]
  0x418485		e8969a0000		CALL runtime.panicindex(SB)	
  0x41848a		0f0b			UD2				
		throw("gcDrain phase incorrect")
  0x41848c		488d05a3870500		LEAQ 0x587a3(IP), AX	
  0x418493		48890424		MOVQ AX, 0(SP)		
  0x418497		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4184a0		e8dbaf0000		CALL runtime.throw(SB)	
  0x4184a5		0f0b			UD2			
func gcDrain(gcw *gcWork, flags gcDrainFlags) {
  0x4184a7		e8d4f30200		CALL runtime.morestack_noctxt(SB)	
  0x4184ac		e9cffbffff		JMP runtime.gcDrain(SB)			

TEXT runtime.gcDrainN(SB) /usr/local/go/src/runtime/mgcmark.go
func gcDrainN(gcw *gcWork, scanWork int64) int64 {
  0x4184c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4184c9		483b6118		CMPQ 0x18(CX), SP	
  0x4184cd		0f8612020000		JBE 0x4186e5		
  0x4184d3		4883ec28		SUBQ $0x28, SP		
  0x4184d7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4184dc		488d6c2420		LEAQ 0x20(SP), BP	
	if !writeBarrier.needed {
  0x4184e1		803d3c490c0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x4184e8		0f84dc010000		JE 0x4186ca				
	gp := getg().m.curg
  0x4184ee		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4184f7		488b4030		MOVQ 0x30(AX), AX	
	workFlushed := -gcw.scanWork
  0x4184fb		488b4c2430		MOVQ 0x30(SP), CX	
  0x418500		488b5118		MOVQ 0x18(CX), DX	
  0x418504		48f7da			NEGQ DX			
	gp := getg().m.curg
  0x418507		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x41850e		4889442418		MOVQ AX, 0x18(SP)	
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x418513		488b5c2438		MOVQ 0x38(SP), BX	
  0x418518		eb1b			JMP 0x418535		
  0x41851a		488b742418		MOVQ 0x18(SP), SI	
  0x41851f		488b7c2430		MOVQ 0x30(SP), DI	
  0x418524		4c8b442438		MOVQ 0x38(SP), R8	
  0x418529		4889f9			MOVQ DI, CX		
  0x41852c		4c89c3			MOVQ R8, BX		
			workFlushed += gcw.scanWork
  0x41852f		4889c2			MOVQ AX, DX		
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x418532		4889f0			MOVQ SI, AX		
  0x418535		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41853c		0f8588000000		JNE 0x4185ca		
  0x418542		488b7118		MOVQ 0x18(CX), SI	
  0x418546		4801d6			ADDQ DX, SI		
  0x418549		4839de			CMPQ BX, SI		
  0x41854c		7d7c			JGE 0x4185ca		
			workFlushed += gcw.scanWork
  0x41854e		4889542410		MOVQ DX, 0x10(SP)	
		if work.full == 0 {
  0x418553		48833d259a0a0000	CMPQ $0x0, runtime.work(SB)	
  0x41855b		0f8440010000		JE 0x4186a1			
		b := gcw.tryGetFast()
  0x418561		90			NOPL			
	wbuf := w.wbuf1
  0x418562		488b31			MOVQ 0(CX), SI		
	if wbuf == nil {
  0x418565		4885f6			TESTQ SI, SI		
  0x418568		0f842c010000		JE 0x41869a		
	if wbuf.nobj == 0 {
  0x41856e		488b7e10		MOVQ 0x10(SI), DI	
  0x418572		4885ff			TESTQ DI, DI		
  0x418575		0f8504010000		JNE 0x41867f		
  0x41857b		31f6			XORL SI, SI		
		if b == 0 {
  0x41857d		4885f6			TESTQ SI, SI		
  0x418580		0f84a9000000		JE 0x41862f		
		if b == 0 {
  0x418586		4885f6			TESTQ SI, SI		
  0x418589		7555			JNE 0x4185e0		
			if work.markrootNext < work.markrootJobs {
  0x41858b		8b357b9a0a00		MOVL runtime.work+140(SB), SI	
  0x418591		3935719a0a00		CMPL SI, runtime.work+136(SB)	
  0x418597		7331			JAE 0x4185ca			
				job := atomic.Xadd(&work.markrootNext, +1) - 1
  0x418599		be01000000		MOVL $0x1, SI			
  0x41859e		488d3d639a0a00		LEAQ runtime.work+136(SB), DI	
  0x4185a5		f00fc137		LOCK XADDL SI, 0(DI)		
				if job < work.markrootJobs {
  0x4185a9		8b3d5d9a0a00		MOVL runtime.work+140(SB), DI	
  0x4185af		39fe			CMPL DI, SI			
  0x4185b1		7317			JAE 0x4185ca			
					markroot(gcw, job)
  0x4185b3		48890c24		MOVQ CX, 0(SP)			
  0x4185b7		89742408		MOVL SI, 0x8(SP)		
  0x4185bb		e810e1ffff		CALL runtime.markroot(SB)	
			workFlushed += gcw.scanWork
  0x4185c0		488b442410		MOVQ 0x10(SP), AX	
					continue
  0x4185c5		e950ffffff		JMP 0x41851a		
	return workFlushed + gcw.scanWork
  0x4185ca		488b4118		MOVQ 0x18(CX), AX	
  0x4185ce		4801d0			ADDQ DX, AX		
  0x4185d1		4889442440		MOVQ AX, 0x40(SP)	
  0x4185d6		488b6c2420		MOVQ 0x20(SP), BP	
  0x4185db		4883c428		ADDQ $0x28, SP		
  0x4185df		c3			RET			
		scanobject(b, gcw)
  0x4185e0		48893424		MOVQ SI, 0(SP)			
  0x4185e4		48894c2408		MOVQ CX, 0x8(SP)		
  0x4185e9		e882020000		CALL runtime.scanobject(SB)	
		if gcw.scanWork >= gcCreditSlack {
  0x4185ee		488b442430		MOVQ 0x30(SP), AX	
  0x4185f3		488b4818		MOVQ 0x18(AX), CX	
  0x4185f7		4881f9d0070000		CMPQ $0x7d0, CX		
  0x4185fe		7c28			JL 0x418628		
			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
  0x418600		488d15794b0c00		LEAQ runtime.gcController(SB), DX	
  0x418607		f0480fc10a		LOCK XADDQ CX, 0(DX)			
			workFlushed += gcw.scanWork
  0x41860c		488b4818		MOVQ 0x18(AX), CX	
			gcw.scanWork = 0
  0x418610		48c7401800000000	MOVQ $0x0, 0x18(AX)	
			workFlushed += gcw.scanWork
  0x418618		488b542410		MOVQ 0x10(SP), DX	
  0x41861d		4801d1			ADDQ DX, CX		
  0x418620		4889c8			MOVQ CX, AX		
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x418623		e9f2feffff		JMP 0x41851a		
			workFlushed += gcw.scanWork
  0x418628		488b4c2410		MOVQ 0x10(SP), CX	
		if gcw.scanWork >= gcCreditSlack {
  0x41862d		ebf1			JMP 0x418620		
			b = gcw.tryGet()
  0x41862f		48890c24		MOVQ CX, 0(SP)				
  0x418633		e808320000		CALL runtime.(*gcWork).tryGet(SB)	
  0x418638		488b442408		MOVQ 0x8(SP), AX			
			if b == 0 {
  0x41863d		4885c0			TESTQ AX, AX		
  0x418640		741c			JE 0x41865e		
					markroot(gcw, job)
  0x418642		488b4c2430		MOVQ 0x30(SP), CX	
			workFlushed += gcw.scanWork
  0x418647		488b542410		MOVQ 0x10(SP), DX	
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x41864c		488b5c2438		MOVQ 0x38(SP), BX	
		if b == 0 {
  0x418651		4889c6			MOVQ AX, SI		
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x418654		488b442418		MOVQ 0x18(SP), AX	
		if b == 0 {
  0x418659		e928ffffff		JMP 0x418586		
				wbBufFlush(nil, 0)
  0x41865e		0f57c0			XORPS X0, X0			
  0x418661		0f110424		MOVUPS X0, 0(SP)		
  0x418665		e896850000		CALL runtime.wbBufFlush(SB)	
				b = gcw.tryGet()
  0x41866a		488b442430		MOVQ 0x30(SP), AX			
  0x41866f		48890424		MOVQ AX, 0(SP)				
  0x418673		e8c8310000		CALL runtime.(*gcWork).tryGet(SB)	
  0x418678		488b442408		MOVQ 0x8(SP), AX			
  0x41867d		ebc3			JMP 0x418642				
	wbuf.nobj--
  0x41867f		4c8d47ff		LEAQ -0x1(DI), R8	
  0x418683		4c894610		MOVQ R8, 0x10(SI)	
	return wbuf.obj[wbuf.nobj]
  0x418687		4981f8fd000000		CMPQ $0xfd, R8		
  0x41868e		7333			JAE 0x4186c3		
  0x418690		488b74fe10		MOVQ 0x10(SI)(DI*8), SI	
		b := gcw.tryGetFast()
  0x418695		e9e3feffff		JMP 0x41857d		
  0x41869a		31f6			XORL SI, SI		
  0x41869c		e9dcfeffff		JMP 0x41857d		
			gcw.balance()
  0x4186a1		48890c24		MOVQ CX, 0(SP)				
  0x4186a5		e876330000		CALL runtime.(*gcWork).balance(SB)	
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x4186aa		488b442418		MOVQ 0x18(SP), AX	
	wbuf := w.wbuf1
  0x4186af		488b4c2430		MOVQ 0x30(SP), CX	
			workFlushed += gcw.scanWork
  0x4186b4		488b542410		MOVQ 0x10(SP), DX	
	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
  0x4186b9		488b5c2438		MOVQ 0x38(SP), BX	
			gcw.balance()
  0x4186be		e99efeffff		JMP 0x418561		
	return wbuf.obj[wbuf.nobj]
  0x4186c3		e858980000		CALL runtime.panicindex(SB)	
  0x4186c8		0f0b			UD2				
		throw("gcDrainN phase incorrect")
  0x4186ca		488d05c1870500		LEAQ 0x587c1(IP), AX	
  0x4186d1		48890424		MOVQ AX, 0(SP)		
  0x4186d5		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x4186de		e89dad0000		CALL runtime.throw(SB)	
  0x4186e3		0f0b			UD2			
func gcDrainN(gcw *gcWork, scanWork int64) int64 {
  0x4186e5		e8e60f0200		CALL runtime.morestackc(SB)	
  0x4186ea		e9d1fdffff		JMP runtime.gcDrainN(SB)	

TEXT runtime.scanblock(SB) /usr/local/go/src/runtime/mgcmark.go
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState) {
  0x4186f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4186f9		483b6110		CMPQ 0x10(CX), SP	
  0x4186fd		0f8655010000		JBE 0x418858		
  0x418703		4883ec58		SUBQ $0x58, SP		
  0x418707		48896c2450		MOVQ BP, 0x50(SP)	
  0x41870c		488d6c2450		LEAQ 0x50(SP), BP	
	for i := uintptr(0); i < n; {
  0x418711		488b442470		MOVQ 0x70(SP), AX	
  0x418716		488b4c2468		MOVQ 0x68(SP), CX	
  0x41871b		488b542460		MOVQ 0x60(SP), DX	
  0x418720		31db			XORL BX, BX		
  0x418722		4839cb			CMPQ CX, BX		
  0x418725		0f8323010000		JAE 0x41884e		
		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
  0x41872b		4889de			MOVQ BX, SI		
  0x41872e		48c1eb06		SHRQ $0x6, BX		
  0x418732		0fb61c18		MOVZX 0(AX)(BX*1), BX	
  0x418736		90			NOPL			
		if bits == 0 {
  0x418737		85db			TESTL BX, BX		
  0x418739		7506			JNE 0x418741		
			i += sys.PtrSize * 8
  0x41873b		488d5e40		LEAQ 0x40(SI), BX	
			continue
  0x41873f		ebe1			JMP 0x418722		
  0x418741		31ff			XORL DI, DI		
		for j := 0; j < 8 && i < n; j++ {
  0x418743		eb09			JMP 0x41874e		
  0x418745		48ffc7			INCQ DI			
			bits >>= 1
  0x418748		d1eb			SHRL $0x1, BX		
			i += sys.PtrSize
  0x41874a		4883c608		ADDQ $0x8, SI		
		for j := 0; j < 8 && i < n; j++ {
  0x41874e		4883ff08		CMPQ $0x8, DI		
  0x418752		0f8dee000000		JGE 0x418846		
  0x418758		4839ce			CMPQ CX, SI		
  0x41875b		0f83e5000000		JAE 0x418846		
			if bits&1 != 0 {
  0x418761		0fbae300		BTL $0x0, BX		
  0x418765		73de			JAE 0x418745		
				p := *(*uintptr)(unsafe.Pointer(b + i))
  0x418767		4c8d0416		LEAQ 0(SI)(DX*1), R8	
  0x41876b		4d8b00			MOVQ 0(R8), R8		
				if p != 0 {
  0x41876e		4d85c0			TESTQ R8, R8		
  0x418771		74d2			JE 0x418745		
		for j := 0; j < 8 && i < n; j++ {
  0x418773		48897c2440		MOVQ DI, 0x40(SP)	
				p := *(*uintptr)(unsafe.Pointer(b + i))
  0x418778		4c89442438		MOVQ R8, 0x38(SP)	
  0x41877d		4889742448		MOVQ SI, 0x48(SP)	
			if bits&1 != 0 {
  0x418782		895c2434		MOVL BX, 0x34(SP)	
					if obj, span, objIndex := findObject(p, b, i); obj != 0 {
  0x418786		4c890424		MOVQ R8, 0(SP)			
  0x41878a		4889542408		MOVQ DX, 0x8(SP)		
  0x41878f		4889742410		MOVQ SI, 0x10(SP)		
  0x418794		e80754ffff		CALL runtime.findObject(SB)	
  0x418799		488b442418		MOVQ 0x18(SP), AX		
  0x41879e		488b4c2420		MOVQ 0x20(SP), CX		
  0x4187a3		488b542428		MOVQ 0x28(SP), DX		
  0x4187a8		4885c0			TESTQ AX, AX			
  0x4187ab		755e			JNE 0x41880b			
					} else if stk != nil && p >= stk.stack.lo && p < stk.stack.hi {
  0x4187ad		488b842480000000	MOVQ 0x80(SP), AX	
  0x4187b5		4885c0			TESTQ AX, AX		
  0x4187b8		7417			JE 0x4187d1		
  0x4187ba		488b4c2438		MOVQ 0x38(SP), CX	
  0x4187bf		48398800010000		CMPQ CX, 0x100(AX)	
  0x4187c6		7709			JA 0x4187d1		
  0x4187c8		48398808010000		CMPQ CX, 0x108(AX)	
  0x4187cf		7722			JA 0x4187f3		
		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
  0x4187d1		488b442470		MOVQ 0x70(SP), AX	
		for j := 0; j < 8 && i < n; j++ {
  0x4187d6		488b4c2468		MOVQ 0x68(SP), CX	
				p := *(*uintptr)(unsafe.Pointer(b + i))
  0x4187db		488b542460		MOVQ 0x60(SP), DX	
			bits >>= 1
  0x4187e0		8b5c2434		MOVL 0x34(SP), BX	
			i += sys.PtrSize
  0x4187e4		488b742448		MOVQ 0x48(SP), SI	
		for j := 0; j < 8 && i < n; j++ {
  0x4187e9		488b7c2440		MOVQ 0x40(SP), DI	
			bits >>= 1
  0x4187ee		e952ffffff		JMP 0x418745		
						stk.putPtr(p)
  0x4187f3		48890424		MOVQ AX, 0(SP)					
  0x4187f7		48894c2408		MOVQ CX, 0x8(SP)				
  0x4187fc		e82f130000		CALL runtime.(*stackScanState).putPtr(SB)	
					} else if stk != nil && p >= stk.stack.lo && p < stk.stack.hi {
  0x418801		488b842480000000	MOVQ 0x80(SP), AX	
						stk.putPtr(p)
  0x418809		ebc6			JMP 0x4187d1		
						greyobject(obj, b, i, span, gcw, objIndex)
  0x41880b		48890424		MOVQ AX, 0(SP)			
  0x41880f		488b442460		MOVQ 0x60(SP), AX		
  0x418814		4889442408		MOVQ AX, 0x8(SP)		
  0x418819		488b5c2448		MOVQ 0x48(SP), BX		
  0x41881e		48895c2410		MOVQ BX, 0x10(SP)		
  0x418823		48894c2418		MOVQ CX, 0x18(SP)		
  0x418828		488b4c2478		MOVQ 0x78(SP), CX		
  0x41882d		48894c2420		MOVQ CX, 0x20(SP)		
  0x418832		4889542428		MOVQ DX, 0x28(SP)		
  0x418837		e894040000		CALL runtime.greyobject(SB)	
					} else if stk != nil && p >= stk.stack.lo && p < stk.stack.hi {
  0x41883c		488b842480000000	MOVQ 0x80(SP), AX	
						greyobject(obj, b, i, span, gcw, objIndex)
  0x418844		eb8b			JMP 0x4187d1		
	for i := uintptr(0); i < n; {
  0x418846		4889f3			MOVQ SI, BX		
  0x418849		e9d4feffff		JMP 0x418722		
  0x41884e		488b6c2450		MOVQ 0x50(SP), BP	
  0x418853		4883c458		ADDQ $0x58, SP		
  0x418857		c3			RET			
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState) {
  0x418858		e823f00200		CALL runtime.morestack_noctxt(SB)	
  0x41885d		e98efeffff		JMP runtime.scanblock(SB)		

TEXT runtime.scanobject(SB) /usr/local/go/src/runtime/mgcmark.go
func scanobject(b uintptr, gcw *gcWork) {
  0x418870		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418879		488d4424f8		LEAQ -0x8(SP), AX	
  0x41887e		483b4110		CMPQ 0x10(CX), AX	
  0x418882		0f868c030000		JBE 0x418c14		
  0x418888		4881ec88000000		SUBQ $0x88, SP		
  0x41888f		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x418897		488dac2480000000	LEAQ 0x80(SP), BP	
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41889f		488b05aae00a00		MOVQ runtime.mheap_+784(SB), AX	
  0x4188a6		8400			TESTB AL, 0(AX)			
	hbits := heapBitsForAddr(b)
  0x4188a8		90			NOPL			
	arena := arenaIndex(addr)
  0x4188a9		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x4188aa		90			NOPL			
  0x4188ab		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4188ac		488b942490000000	MOVQ 0x90(SP), DX		
  0x4188b4		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x4188be		4801d3			ADDQ DX, BX			
  0x4188c1		48c1eb1a		SHRQ $0x1a, BX			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x4188c5		4881fb00004000		CMPQ $0x400000, BX	
  0x4188cc		0f833b030000		JAE 0x418c0d		
  0x4188d2		488b04d8		MOVQ 0(AX)(BX*8), AX	
	if ha == nil {
  0x4188d6		4885c0			TESTQ AX, AX		
  0x4188d9		0f84fb020000		JE 0x418bda		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x4188df		4889d6			MOVQ DX, SI		
  0x4188e2		48c1ea05		SHRQ $0x5, DX		
  0x4188e6		4881e2ffff1f00		ANDQ $0x1fffff, DX	
  0x4188ed		4801c2			ADDQ AX, DX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x4188f0		4889f7			MOVQ SI, DI		
  0x4188f3		48c1ee03		SHRQ $0x3, SI		
  0x4188f7		4883e603		ANDQ $0x3, SI		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x4188fb		4c8d80ffff1f00		LEAQ 0x1fffff(AX), R8	
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x418902		4989f9			MOVQ DI, R9			
  0x418905		48c1ef0d		SHRQ $0xd, DI			
  0x418909		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x418910		488bbcf800002000	MOVQ 0x200000(AX)(DI*8), DI	
  0x418918		8400			TESTB AL, 0(AX)			
	s := spanOfUnchecked(b)
  0x41891a		90			NOPL			
	n := s.elemsize
  0x41891b		488b4768		MOVQ 0x68(DI), AX	
	ai := arenaIndex(p)
  0x41891f		90			NOPL			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x418920		90			NOPL			
  0x418921		90			NOPL			
	if n == 0 {
  0x418922		4885c0			TESTQ AX, AX		
  0x418925		0f84c7020000		JE 0x418bf2		
	if n > maxObletBytes {
  0x41892b		483d00000200		CMPQ $0x20000, AX	
  0x418931		0f8696020000		JBE 0x418bcd		
		if b == s.base() {
  0x418937		90			NOPL			
	return s.startAddr
  0x418938		4c394f18		CMPQ R9, 0x18(DI)	
		if b == s.base() {
  0x41893c		0f857e020000		JNE 0x418bc0		
			if s.spanclass.noscan() {
  0x418942		440fb65762		MOVZX 0x62(DI), R10	
  0x418947		90			NOPL			
	return sc&1 != 0
  0x418948		41f6c201		TESTL $0x1, R10		
			if s.spanclass.noscan() {
  0x41894c		0f8552020000		JNE 0x418ba4		
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x418952		48897c2458		MOVQ DI, 0x58(SP)	
	hbits := heapBitsForAddr(b)
  0x418957		4c89442460		MOVQ R8, 0x60(SP)	
  0x41895c		895c2434		MOVL BX, 0x34(SP)	
  0x418960		89742430		MOVL SI, 0x30(SP)	
  0x418964		4889542468		MOVQ DX, 0x68(SP)	
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
  0x418969		498d8100000200		LEAQ 0x20000(R9), AX	
  0x418970		4c8b942498000000	MOVQ 0x98(SP), R10	
  0x418978		eb06			JMP 0x418980		
  0x41897a		480500000200		ADDQ $0x20000, AX	
  0x418980		90			NOPL			
  0x418981		4c8b5f68		MOVQ 0x68(DI), R11	
  0x418985		4c035f18		ADDQ 0x18(DI), R11	
  0x418989		4c39d8			CMPQ R11, AX		
  0x41898c		7378			JAE 0x418a06		
				if !gcw.putFast(oblet) {
  0x41898e		90			NOPL			
	w.checkPut(obj, nil)
  0x41898f		90			NOPL			
	wbuf := w.wbuf1
  0x418990		4d8b1a			MOVQ 0(R10), R11	
	if wbuf == nil {
  0x418993		4d85db			TESTQ R11, R11		
  0x418996		746a			JE 0x418a02		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x418998		4d8b6310		MOVQ 0x10(R11), R12	
  0x41899c		4981fcfd000000		CMPQ $0xfd, R12		
  0x4189a3		7547			JNE 0x4189ec		
  0x4189a5		31c9			XORL CX, CX		
				if !gcw.putFast(oblet) {
  0x4189a7		84c9			TESTL CL, CL		
  0x4189a9		75cf			JNE 0x41897a		
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
  0x4189ab		4889442440		MOVQ AX, 0x40(SP)	
					gcw.put(oblet)
  0x4189b0		4c891424		MOVQ R10, 0(SP)			
  0x4189b4		4889442408		MOVQ AX, 0x8(SP)		
  0x4189b9		e8a22b0000		CALL runtime.(*gcWork).put(SB)	
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
  0x4189be		488b442440		MOVQ 0x40(SP), AX	
			hbits = hbits.next()
  0x4189c3		488b542468		MOVQ 0x68(SP), DX	
  0x4189c8		8b5c2434		MOVL 0x34(SP), BX	
  0x4189cc		8b742430		MOVL 0x30(SP), SI	
			for oblet := b + maxObletBytes; oblet < s.base()+s.elemsize; oblet += maxObletBytes {
  0x4189d0		488b7c2458		MOVQ 0x58(SP), DI	
			hbits = hbits.next()
  0x4189d5		4c8b442460		MOVQ 0x60(SP), R8	
		n = s.base() + s.elemsize - b
  0x4189da		4c8b8c2490000000	MOVQ 0x90(SP), R9	
	wbuf := w.wbuf1
  0x4189e2		4c8b942498000000	MOVQ 0x98(SP), R10	
					gcw.put(oblet)
  0x4189ea		eb8e			JMP 0x41897a		
	wbuf.obj[wbuf.nobj] = obj
  0x4189ec		0f83f9010000		JAE 0x418beb			
  0x4189f2		4b8944e318		MOVQ AX, 0x18(R11)(R12*8)	
	wbuf.nobj++
  0x4189f7		49ff4310		INCQ 0x10(R11)		
  0x4189fb		b901000000		MOVL $0x1, CX		
				if !gcw.putFast(oblet) {
  0x418a00		eba5			JMP 0x4189a7		
  0x418a02		31c9			XORL CX, CX		
  0x418a04		eba1			JMP 0x4189a7		
		n = s.base() + s.elemsize - b
  0x418a06		488b4768		MOVQ 0x68(DI), AX	
  0x418a0a		48034718		ADDQ 0x18(DI), AX	
  0x418a0e		4c29c8			SUBQ R9, AX		
		if n > maxObletBytes {
  0x418a11		483d00000200		CMPQ $0x20000, AX	
	for i = 0; i < n; i += sys.PtrSize {
  0x418a17		bf00000200		MOVL $0x20000, DI	
  0x418a1c		480f47c7		CMOVA DI, AX		
		n = s.base() + s.elemsize - b
  0x418a20		90			NOPL			
	for i = 0; i < n; i += sys.PtrSize {
  0x418a21		4889442448		MOVQ AX, 0x48(SP)	
  0x418a26		31c9			XORL CX, CX		
  0x418a28		eb07			JMP 0x418a31		
  0x418a2a		498d7b08		LEAQ 0x8(R11), DI	
  0x418a2e		4889f9			MOVQ DI, CX		
  0x418a31		4839c1			CMPQ AX, CX		
  0x418a34		0f8365010000		JAE 0x418b9f		
  0x418a3a		48894c2450		MOVQ CX, 0x50(SP)	
		if i != 0 {
  0x418a3f		4885c9			TESTQ CX, CX		
  0x418a42		740c			JE 0x418a50		
			hbits = hbits.next()
  0x418a44		90			NOPL			
	if h.shift < 3*heapBitsShift {
  0x418a45		83fe03			CMPL $0x3, SI		
  0x418a48		0f83fa000000		JAE 0x418b48		
		h.shift += heapBitsShift
  0x418a4e		ffc6			INCL SI			
		bits := hbits.bits()
  0x418a50		90			NOPL			
	return uint32(*h.bitp) >> (h.shift & 31)
  0x418a51		0fb63a			MOVZX 0(DX), DI		
	for i = 0; i < n; i += sys.PtrSize {
  0x418a54		4989cb			MOVQ CX, R11		
	return uint32(*h.bitp) >> (h.shift & 31)
  0x418a57		89f1			MOVL SI, CX		
  0x418a59		4189fc			MOVL DI, R12		
  0x418a5c		d3ef			SHRL CL, DI		
		if i != 1*sys.PtrSize && bits&bitScan == 0 {
  0x418a5e		4983fb08		CMPQ $0x8, R11		
  0x418a62		740a			JE 0x418a6e		
  0x418a64		0fbae704		BTL $0x4, DI		
  0x418a68		0f83c2000000		JAE 0x418b30		
		if bits&bitPointer == 0 {
  0x418a6e		410fa3cc		BTL CX, R12		
  0x418a72		73b6			JAE 0x418a2a		
		obj := *(*uintptr)(unsafe.Pointer(b + i))
  0x418a74		4b8d3c0b		LEAQ 0(R11)(R9*1), DI	
  0x418a78		488b3f			MOVQ 0(DI), DI		
		if obj != 0 && obj-b >= n {
  0x418a7b		4885ff			TESTQ DI, DI		
  0x418a7e		74aa			JE 0x418a2a		
  0x418a80		4989fc			MOVQ DI, R12		
  0x418a83		4c29cf			SUBQ R9, DI		
  0x418a86		4839c7			CMPQ AX, DI		
  0x418a89		729f			JB 0x418a2a		
		bits := hbits.bits()
  0x418a8b		4c89442470		MOVQ R8, 0x70(SP)	
  0x418a90		895c2438		MOVL BX, 0x38(SP)	
  0x418a94		894c243c		MOVL CX, 0x3c(SP)	
  0x418a98		4889542478		MOVQ DX, 0x78(SP)	
			if obj, span, objIndex := findObject(obj, b, i); obj != 0 {
  0x418a9d		4c892424		MOVQ R12, 0(SP)			
  0x418aa1		4c894c2408		MOVQ R9, 0x8(SP)		
  0x418aa6		4c895c2410		MOVQ R11, 0x10(SP)		
  0x418aab		e8f050ffff		CALL runtime.findObject(SB)	
  0x418ab0		488b442418		MOVQ 0x18(SP), AX		
  0x418ab5		488b4c2420		MOVQ 0x20(SP), CX		
  0x418aba		488b542428		MOVQ 0x28(SP), DX		
  0x418abf		4885c0			TESTQ AX, AX			
  0x418ac2		7533			JNE 0x418af7			
	for i = 0; i < n; i += sys.PtrSize {
  0x418ac4		488b442448		MOVQ 0x48(SP), AX	
			hbits = hbits.next()
  0x418ac9		8b4c243c		MOVL 0x3c(SP), CX	
  0x418acd		488b542478		MOVQ 0x78(SP), DX	
  0x418ad2		8b5c2438		MOVL 0x38(SP), BX	
  0x418ad6		89ce			MOVL CX, SI		
  0x418ad8		4c8b442470		MOVQ 0x70(SP), R8	
		obj := *(*uintptr)(unsafe.Pointer(b + i))
  0x418add		4c8b8c2490000000	MOVQ 0x90(SP), R9	
	gcw.bytesMarked += uint64(n)
  0x418ae5		4c8b942498000000	MOVQ 0x98(SP), R10	
	for i = 0; i < n; i += sys.PtrSize {
  0x418aed		4c8b5c2450		MOVQ 0x50(SP), R11	
  0x418af2		e933ffffff		JMP 0x418a2a		
				greyobject(obj, b, i, span, gcw, objIndex)
  0x418af7		48890424		MOVQ AX, 0(SP)			
  0x418afb		488b842490000000	MOVQ 0x90(SP), AX		
  0x418b03		4889442408		MOVQ AX, 0x8(SP)		
  0x418b08		488b5c2450		MOVQ 0x50(SP), BX		
  0x418b0d		48895c2410		MOVQ BX, 0x10(SP)		
  0x418b12		48894c2418		MOVQ CX, 0x18(SP)		
  0x418b17		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x418b1f		48894c2420		MOVQ CX, 0x20(SP)		
  0x418b24		4889542428		MOVQ DX, 0x28(SP)		
  0x418b29		e8a2010000		CALL runtime.greyobject(SB)	
  0x418b2e		eb94			JMP 0x418ac4			
	gcw.bytesMarked += uint64(n)
  0x418b30		49014210		ADDQ AX, 0x10(R10)	
	gcw.scanWork += int64(i)
  0x418b34		4d015a18		ADDQ R11, 0x18(R10)	
}
  0x418b38		488bac2480000000	MOVQ 0x80(SP), BP	
  0x418b40		4881c488000000		ADDQ $0x88, SP		
  0x418b47		c3			RET			
	} else if h.bitp != h.last {
  0x418b48		4c39c2			CMPQ R8, DX		
  0x418b4b		740b			JE 0x418b58		
		h.bitp, h.shift = add1(h.bitp), 0
  0x418b4d		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))
  0x418b4e		48ffc2			INCQ DX			
  0x418b51		31f6			XORL SI, SI		
			hbits = hbits.next()
  0x418b53		e9f8feffff		JMP 0x418a50		
		return h.nextArena()
  0x418b58		48891424		MOVQ DX, 0(SP)				
  0x418b5c		89742408		MOVL SI, 0x8(SP)			
  0x418b60		895c240c		MOVL BX, 0xc(SP)			
  0x418b64		4c89442410		MOVQ R8, 0x10(SP)			
  0x418b69		e80254ffff		CALL runtime.heapBits.nextArena(SB)	
  0x418b6e		4c8b442428		MOVQ 0x28(SP), R8			
  0x418b73		8b5c2424		MOVL 0x24(SP), BX			
  0x418b77		8b742420		MOVL 0x20(SP), SI			
  0x418b7b		488b542418		MOVQ 0x18(SP), DX			
		if obj != 0 && obj-b >= n {
  0x418b80		488b442448		MOVQ 0x48(SP), AX	
		if i != 1*sys.PtrSize && bits&bitScan == 0 {
  0x418b85		488b4c2450		MOVQ 0x50(SP), CX	
		obj := *(*uintptr)(unsafe.Pointer(b + i))
  0x418b8a		4c8b8c2490000000	MOVQ 0x90(SP), R9	
	gcw.bytesMarked += uint64(n)
  0x418b92		4c8b942498000000	MOVQ 0x98(SP), R10	
			hbits = hbits.next()
  0x418b9a		e9b1feffff		JMP 0x418a50		
	gcw.scanWork += int64(i)
  0x418b9f		4989cb			MOVQ CX, R11		
	for i = 0; i < n; i += sys.PtrSize {
  0x418ba2		eb8c			JMP 0x418b30		
				gcw.bytesMarked += uint64(n)
  0x418ba4		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x418bac		48014110		ADDQ AX, 0x10(CX)	
				return
  0x418bb0		488bac2480000000	MOVQ 0x80(SP), BP	
  0x418bb8		4881c488000000		ADDQ $0x88, SP		
  0x418bbf		c3			RET			
	gcw.bytesMarked += uint64(n)
  0x418bc0		4c8b942498000000	MOVQ 0x98(SP), R10	
		if b == s.base() {
  0x418bc8		e939feffff		JMP 0x418a06		
	gcw.bytesMarked += uint64(n)
  0x418bcd		4c8b942498000000	MOVQ 0x98(SP), R10	
	if n > maxObletBytes {
  0x418bd5		e947feffff		JMP 0x418a21		
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x418bda		4889d7			MOVQ DX, DI		
  0x418bdd		4531c0			XORL R8, R8		
  0x418be0		31db			XORL BX, BX		
  0x418be2		31f6			XORL SI, SI		
  0x418be4		31d2			XORL DX, DX		
	hbits := heapBitsForAddr(b)
  0x418be6		e917fdffff		JMP 0x418902		
	wbuf.obj[wbuf.nobj] = obj
  0x418beb		e830930000		CALL runtime.panicindex(SB)	
  0x418bf0		0f0b			UD2				
		throw("scanobject n == 0")
  0x418bf2		488d0531760500		LEAQ 0x57631(IP), AX	
  0x418bf9		48890424		MOVQ AX, 0(SP)		
  0x418bfd		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x418c06		e875a80000		CALL runtime.throw(SB)	
  0x418c0b		0f0b			UD2			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x418c0d		e80e930000		CALL runtime.panicindex(SB)	
  0x418c12		0f0b			UD2				
func scanobject(b uintptr, gcw *gcWork) {
  0x418c14		e867ec0200		CALL runtime.morestack_noctxt(SB)	
  0x418c19		e952fcffff		JMP runtime.scanobject(SB)		

TEXT runtime.shade(SB) /usr/local/go/src/runtime/mgcmark.go
func shade(b uintptr) {
  0x418c20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418c29		483b6110		CMPQ 0x10(CX), SP	
  0x418c2d		0f8684000000		JBE 0x418cb7		
  0x418c33		4883ec38		SUBQ $0x38, SP		
  0x418c37		48896c2430		MOVQ BP, 0x30(SP)	
  0x418c3c		488d6c2430		LEAQ 0x30(SP), BP	
	if obj, span, objIndex := findObject(b, 0, 0); obj != 0 {
  0x418c41		488b442440		MOVQ 0x40(SP), AX		
  0x418c46		48890424		MOVQ AX, 0(SP)			
  0x418c4a		0f57c0			XORPS X0, X0			
  0x418c4d		0f11442408		MOVUPS X0, 0x8(SP)		
  0x418c52		e8494fffff		CALL runtime.findObject(SB)	
  0x418c57		488b442418		MOVQ 0x18(SP), AX		
  0x418c5c		488b4c2420		MOVQ 0x20(SP), CX		
  0x418c61		488b542428		MOVQ 0x28(SP), DX		
  0x418c66		4885c0			TESTQ AX, AX			
  0x418c69		750a			JNE 0x418c75			
  0x418c6b		488b6c2430		MOVQ 0x30(SP), BP		
  0x418c70		4883c438		ADDQ $0x38, SP			
  0x418c74		c3			RET				
		gcw := &getg().m.p.ptr().gcw
  0x418c75		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x418c7e		488b5b30		MOVQ 0x30(BX), BX	
  0x418c82		488bb3d0000000		MOVQ 0xd0(BX), SI	
  0x418c89		8406			TESTB AL, 0(SI)		
  0x418c8b		8403			TESTB AL, 0(BX)		
  0x418c8d		90			NOPL			
		greyobject(obj, 0, 0, span, gcw, objIndex)
  0x418c8e		48890424		MOVQ AX, 0(SP)		
  0x418c92		0f57c0			XORPS X0, X0		
  0x418c95		0f11442408		MOVUPS X0, 0x8(SP)	
  0x418c9a		48894c2418		MOVQ CX, 0x18(SP)	
		gcw := &getg().m.p.ptr().gcw
  0x418c9f		488d8670120000		LEAQ 0x1270(SI), AX	
		greyobject(obj, 0, 0, span, gcw, objIndex)
  0x418ca6		4889442420		MOVQ AX, 0x20(SP)		
  0x418cab		4889542428		MOVQ DX, 0x28(SP)		
  0x418cb0		e81b000000		CALL runtime.greyobject(SB)	
  0x418cb5		ebb4			JMP 0x418c6b			
func shade(b uintptr) {
  0x418cb7		e8c4eb0200		CALL runtime.morestack_noctxt(SB)	
  0x418cbc		e95fffffff		JMP runtime.shade(SB)			

TEXT runtime.greyobject(SB) /usr/local/go/src/runtime/mgcmark.go
func greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr) {
  0x418cd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x418cd9		483b6110		CMPQ 0x10(CX), SP	
  0x418cdd		0f868f050000		JBE 0x419272		
  0x418ce3		4883ec28		SUBQ $0x28, SP		
  0x418ce7		48896c2420		MOVQ BP, 0x20(SP)	
  0x418cec		488d6c2420		LEAQ 0x20(SP), BP	
	if obj&(sys.PtrSize-1) != 0 {
  0x418cf1		488b442430		MOVQ 0x30(SP), AX	
  0x418cf6		48a907000000		TESTQ $0x7, AX		
  0x418cfc		0f8555050000		JNE 0x419257		
	mbits := span.markBitsForIndex(objIndex)
  0x418d02		90			NOPL			
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x418d03		488b542448		MOVQ 0x48(SP), DX	
  0x418d08		488b5a50		MOVQ 0x50(DX), BX	
  0x418d0c		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x418d0d		90			NOPL			
  0x418d0e		488b4c2458		MOVQ 0x58(SP), CX	
  0x418d13		4889ce			MOVQ CX, SI		
  0x418d16		48c1e903		SHRQ $0x3, CX		
  0x418d1a		4889f7			MOVQ SI, DI		
  0x418d1d		4883e607		ANDQ $0x7, SI		
  0x418d21		4989c8			MOVQ CX, R8		
  0x418d24		4889f1			MOVQ SI, CX		
  0x418d27		41b901000000		MOVL $0x1, R9		
  0x418d2d		41d3e1			SHLL CL, R9		
	return addb((*uint8)(b), n)
  0x418d30		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x418d31		4a8d3403		LEAQ 0(BX)(R8*1), SI	
	if useCheckmark {
  0x418d35		803d7a3f0c0000		CMPB $0x0, runtime.useCheckmark(SB)	
  0x418d3c		0f849d010000		JE 0x418edf				
		if !mbits.isMarked() {
  0x418d42		90			NOPL			
	return *m.bytep&m.mask != 0
  0x418d43		410fb61c18		MOVZX 0(R8)(BX*1), BX	
  0x418d48		4484cb			TESTL R9, BL		
		if !mbits.isMarked() {
  0x418d4b		0f84d2030000		JE 0x419123		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x418d51		488b1df8db0a00		MOVQ runtime.mheap_+784(SB), BX	
  0x418d58		8403			TESTB AL, 0(BX)			
		hbits := heapBitsForAddr(obj)
  0x418d5a		90			NOPL			
	arena := arenaIndex(addr)
  0x418d5b		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x418d5c		90			NOPL			
  0x418d5d		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x418d5e		48be0000000000800000	MOVQ $0x800000000000, SI	
  0x418d68		4801c6			ADDQ AX, SI			
  0x418d6b		48c1ee1a		SHRQ $0x1a, SI			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x418d6f		4881fe00004000		CMPQ $0x400000, SI	
  0x418d76		0f83a0030000		JAE 0x41911c		
  0x418d7c		488b1cf3		MOVQ 0(BX)(SI*8), BX	
	if ha == nil {
  0x418d80		4885db			TESTQ BX, BX		
  0x418d83		0f844a010000		JE 0x418ed3		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x418d89		4889c6			MOVQ AX, SI		
  0x418d8c		48c1e805		SHRQ $0x5, AX		
  0x418d90		4825ffff1f00		ANDQ $0x1fffff, AX	
  0x418d96		4801d8			ADDQ BX, AX		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x418d99		4889f3			MOVQ SI, BX		
  0x418d9c		48c1ee03		SHRQ $0x3, SI		
  0x418da0		4883e603		ANDQ $0x3, SI		
		if hbits.isCheckmarked(span.elemsize) {
  0x418da4		90			NOPL			
  0x418da5		488b7a68		MOVQ 0x68(DX), DI	
  0x418da9		4883ff08		CMPQ $0x8, DI		
	if size == sys.PtrSize {
  0x418dad		0f85fe000000		JNE 0x418eb1		
		return (*h.bitp>>h.shift)&bitPointer != 0
  0x418db3		83fe08			CMPL $0x8, SI		
  0x418db6		4519c0			SBBL R8, R8		
  0x418db9		440fb608		MOVZX 0(AX), R9		
  0x418dbd		89f1			MOVL SI, CX		
  0x418dbf		41d2e9			SHRL CL, R9		
  0x418dc2		4521c1			ANDL R8, R9		
  0x418dc5		41f6c101		TESTL $0x1, R9		
  0x418dc9		410f95c0		SETNE R8		
		if hbits.isCheckmarked(span.elemsize) {
  0x418dcd		4584c0			TESTL R8, R8		
  0x418dd0		0f85d1000000		JNE 0x418ea7		
		hbits.setCheckmarked(span.elemsize)
  0x418dd6		90			NOPL			
		if hbits.isCheckmarked(span.elemsize) {
  0x418dd7		4883ff08		CMPQ $0x8, DI		
	if size == sys.PtrSize {
  0x418ddb		0f85a4000000		JNE 0x418e85		
		atomic.Or8(h.bitp, bitPointer<<h.shift)
  0x418de1		83f920			CMPL $0x20, CX		
  0x418de4		19ff			SBBL DI, DI		
  0x418de6		41b801000000		MOVL $0x1, R8		
  0x418dec		41d3e0			SHLL CL, R8		
  0x418def		4121f8			ANDL DI, R8		
  0x418df2		f0440800		LOCK ORB R8, 0(AX)	
		if !hbits.isCheckmarked(span.elemsize) {
  0x418df6		90			NOPL			
  0x418df7		48837a6808		CMPQ $0x8, 0x68(DX)	
	if size == sys.PtrSize {
  0x418dfc		756f			JNE 0x418e6d		
		return (*h.bitp>>h.shift)&bitPointer != 0
  0x418dfe		83f908			CMPL $0x8, CX		
  0x418e01		19d2			SBBL DX, DX		
  0x418e03		0fb600			MOVZX 0(AX), AX		
  0x418e06		d2e8			SHRL CL, AL		
  0x418e08		21d0			ANDL DX, AX		
  0x418e0a		a801			TESTL $0x1, AL		
  0x418e0c		0f95c0			SETNE AL		
		if !hbits.isCheckmarked(span.elemsize) {
  0x418e0f		84c0			TESTL AL, AL		
  0x418e11		0f84ea020000		JE 0x419101		
	if !gcw.putFast(obj) {
  0x418e17		90			NOPL			
	w.checkPut(obj, nil)
  0x418e18		90			NOPL			
	wbuf := w.wbuf1
  0x418e19		488b442450		MOVQ 0x50(SP), AX	
  0x418e1e		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x418e21		4885c9			TESTQ CX, CX		
  0x418e24		7443			JE 0x418e69		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x418e26		488b5110		MOVQ 0x10(CX), DX	
  0x418e2a		4881fafd000000		CMPQ $0xfd, DX		
  0x418e31		7520			JNE 0x418e53		
  0x418e33		31c9			XORL CX, CX		
	if !gcw.putFast(obj) {
  0x418e35		84c9			TESTL CL, CL		
  0x418e37		740a			JE 0x418e43		
  0x418e39		488b6c2420		MOVQ 0x20(SP), BP	
  0x418e3e		4883c428		ADDQ $0x28, SP		
  0x418e42		c3			RET			
		gcw.put(obj)
  0x418e43		48890424		MOVQ AX, 0(SP)			
  0x418e47		48895c2408		MOVQ BX, 0x8(SP)		
  0x418e4c		e80f270000		CALL runtime.(*gcWork).put(SB)	
  0x418e51		ebe6			JMP 0x418e39			
	wbuf.obj[wbuf.nobj] = obj
  0x418e53		0f837a010000		JAE 0x418fd3		
  0x418e59		48895cd118		MOVQ BX, 0x18(CX)(DX*8)	
	wbuf.nobj++
  0x418e5e		48ff4110		INCQ 0x10(CX)		
  0x418e62		b901000000		MOVL $0x1, CX		
	if !gcw.putFast(obj) {
  0x418e67		ebcc			JMP 0x418e35		
  0x418e69		31c9			XORL CX, CX		
  0x418e6b		ebc8			JMP 0x418e35		
	return (*h.bitp>>(heapBitsShift+h.shift))&bitScan != 0
  0x418e6d		ffc1			INCL CX			
  0x418e6f		83f908			CMPL $0x8, CX		
  0x418e72		19d2			SBBL DX, DX		
  0x418e74		0fb630			MOVZX 0(AX), SI		
  0x418e77		40d2ee			SHRL CL, SI		
  0x418e7a		21d6			ANDL DX, SI		
  0x418e7c		40f6c610		TESTL $0x10, SI		
  0x418e80		0f95c0			SETNE AL		
		if !hbits.isCheckmarked(span.elemsize) {
  0x418e83		eb8a			JMP 0x418e0f		
	atomic.Or8(h.bitp, bitScan<<(heapBitsShift+h.shift))
  0x418e85		8d7901			LEAL 0x1(CX), DI	
  0x418e88		83ff20			CMPL $0x20, DI		
  0x418e8b		4519c0			SBBL R8, R8		
  0x418e8e		89f9			MOVL DI, CX		
  0x418e90		41b910000000		MOVL $0x10, R9		
  0x418e96		41d3e1			SHLL CL, R9		
  0x418e99		4521c8			ANDL R9, R8		
  0x418e9c		f0440800		LOCK ORB R8, 0(AX)	
		return (*h.bitp>>h.shift)&bitPointer != 0
  0x418ea0		89f1			MOVL SI, CX		
		hbits.setCheckmarked(span.elemsize)
  0x418ea2		e94fffffff		JMP 0x418df6		
			return
  0x418ea7		488b6c2420		MOVQ 0x20(SP), BP	
  0x418eac		4883c428		ADDQ $0x28, SP		
  0x418eb0		c3			RET			
	return (*h.bitp>>(heapBitsShift+h.shift))&bitScan != 0
  0x418eb1		8d4e01			LEAL 0x1(SI), CX	
  0x418eb4		83f908			CMPL $0x8, CX		
  0x418eb7		4519c9			SBBL R9, R9		
  0x418eba		440fb610		MOVZX 0(AX), R10	
  0x418ebe		41d2ea			SHRL CL, R10		
  0x418ec1		4521ca			ANDL R9, R10		
  0x418ec4		41f6c210		TESTL $0x10, R10	
  0x418ec8		410f95c0		SETNE R8		
		atomic.Or8(h.bitp, bitPointer<<h.shift)
  0x418ecc		89f1			MOVL SI, CX		
		if hbits.isCheckmarked(span.elemsize) {
  0x418ece		e9fafeffff		JMP 0x418dcd		
	wbuf.obj[wbuf.nobj] = obj
  0x418ed3		4889c3			MOVQ AX, BX		
  0x418ed6		31f6			XORL SI, SI		
  0x418ed8		31c0			XORL AX, AX		
		hbits := heapBitsForAddr(obj)
  0x418eda		e9c5feffff		JMP 0x418da4		
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
  0x418edf		833d0a400c0000		CMPL $0x0, runtime.debug+16(SB)	
  0x418ee6		7e15			JLE 0x418efd			
  0x418ee8		90			NOPL				
	if index < s.freeindex {
  0x418ee9		48397a30		CMPQ DI, 0x30(DX)	
  0x418eed		0f86c9000000		JBE 0x418fbc		
  0x418ef3		31c9			XORL CX, CX		
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
  0x418ef5		84c9			TESTL CL, CL		
  0x418ef7		0f85e4000000		JNE 0x418fe1		
		if mbits.isMarked() {
  0x418efd		90			NOPL			
	return *m.bytep&m.mask != 0
  0x418efe		410fb61c18		MOVZX 0(R8)(BX*1), BX	
  0x418f03		4484cb			TESTL R9, BL		
		if mbits.isMarked() {
  0x418f06		0f85a6000000		JNE 0x418fb2		
		mbits.setMarked()
  0x418f0c		90			NOPL			
	atomic.Or8(m.bytep, m.mask)
  0x418f0d		f044080e		LOCK ORB R9, 0(SI)	
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x418f11		488b1d38da0a00		MOVQ runtime.mheap_+784(SB), BX	
  0x418f18		8403			TESTB AL, 0(BX)			
		arena, pageIdx, pageMask := pageIndexOf(span.base())
  0x418f1a		90			NOPL			
  0x418f1b		90			NOPL			
	return s.startAddr
  0x418f1c		488b4a18		MOVQ 0x18(DX), CX	
	ai := arenaIndex(p)
  0x418f20		90			NOPL			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x418f21		90			NOPL			
  0x418f22		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x418f23		48be0000000000800000	MOVQ $0x800000000000, SI	
  0x418f2d		4801ce			ADDQ CX, SI			
  0x418f30		48c1ee1a		SHRQ $0x1a, SI			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x418f34		4881fe00004000		CMPQ $0x400000, SI	
  0x418f3b		0f8399000000		JAE 0x418fda		
  0x418f41		488b1cf3		MOVQ 0(BX)(SI*8), BX	
		if arena.pageMarks[pageIdx]&pageMask == 0 {
  0x418f45		8403			TESTB AL, 0(BX)		
	pageIdx = ((p / pageSize) / 8) % uintptr(len(arena.pageInUse))
  0x418f47		4889ce			MOVQ CX, SI		
  0x418f4a		48c1e910		SHRQ $0x10, CX		
  0x418f4e		4881e1ff030000		ANDQ $0x3ff, CX		
		if arena.pageMarks[pageIdx]&pageMask == 0 {
  0x418f55		0fb6bc0b00042100	MOVZX 0x210400(BX)(CX*1), DI	
  0x418f5d		488d1c0b		LEAQ 0(BX)(CX*1), BX		
  0x418f61		488d9b00042100		LEAQ 0x210400(BX), BX		
	pageMask = byte(1 << ((p / pageSize) % 8))
  0x418f68		48c1ee0d		SHRQ $0xd, SI		
  0x418f6c		4883e607		ANDQ $0x7, SI		
  0x418f70		4889f1			MOVQ SI, CX		
  0x418f73		41b801000000		MOVL $0x1, R8		
  0x418f79		41d3e0			SHLL CL, R8		
		if arena.pageMarks[pageIdx]&pageMask == 0 {
  0x418f7c		4184f8			TESTL DI, R8		
  0x418f7f		7504			JNE 0x418f85		
			atomic.Or8(&arena.pageMarks[pageIdx], pageMask)
  0x418f81		f0440803		LOCK ORB R8, 0(BX)	
		if span.spanclass.noscan() {
  0x418f85		0fb64a62		MOVZX 0x62(DX), CX	
  0x418f89		90			NOPL			
	return sc&1 != 0
  0x418f8a		f6c101			TESTL $0x1, CL		
		if span.spanclass.noscan() {
  0x418f8d		7508			JNE 0x418f97		
	wbuf.obj[wbuf.nobj] = obj
  0x418f8f		4889c3			MOVQ AX, BX		
	if !gcw.putFast(obj) {
  0x418f92		e980feffff		JMP 0x418e17		
			gcw.bytesMarked += uint64(span.elemsize)
  0x418f97		488b442450		MOVQ 0x50(SP), AX	
  0x418f9c		488b4810		MOVQ 0x10(AX), CX	
  0x418fa0		48034a68		ADDQ 0x68(DX), CX	
  0x418fa4		48894810		MOVQ CX, 0x10(AX)	
			return
  0x418fa8		488b6c2420		MOVQ 0x20(SP), BP	
  0x418fad		4883c428		ADDQ $0x28, SP		
  0x418fb1		c3			RET			
			return
  0x418fb2		488b6c2420		MOVQ 0x20(SP), BP	
  0x418fb7		4883c428		ADDQ $0x28, SP		
  0x418fbb		c3			RET			
	bytep, mask := s.allocBits.bitp(index)
  0x418fbc		488b7a48		MOVQ 0x48(DX), DI	
	return *bytep&mask == 0
  0x418fc0		410fb63c38		MOVZX 0(R8)(DI*1), DI	
  0x418fc5		4484cf			TESTL R9, DI		
  0x418fc8		0f94c1			SETE CL			
	bytep, mask := s.allocBits.bitp(index)
  0x418fcb		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x418fcc		90			NOPL			
	return addb((*uint8)(b), n)
  0x418fcd		90			NOPL			
		if debug.gccheckmark > 0 && span.isFree(objIndex) {
  0x418fce		e922ffffff		JMP 0x418ef5		
	wbuf.obj[wbuf.nobj] = obj
  0x418fd3		e8488f0000		CALL runtime.panicindex(SB)	
  0x418fd8		0f0b			UD2				
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x418fda		e8418f0000		CALL runtime.panicindex(SB)	
  0x418fdf		0f0b			UD2				
			print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n")
  0x418fe1		e8daae0000		CALL runtime.printlock(SB)	
  0x418fe6		488d0539890500		LEAQ 0x58939(IP), AX		
  0x418fed		48890424		MOVQ AX, 0(SP)			
  0x418ff1		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x418ffa		e8f1b70000		CALL runtime.printstring(SB)	
  0x418fff		488b442430		MOVQ 0x30(SP), AX		
  0x419004		48890424		MOVQ AX, 0(SP)			
  0x419008		e8a3b60000		CALL runtime.printhex(SB)	
  0x41900d		488d0585690500		LEAQ 0x56985(IP), AX		
  0x419014		48890424		MOVQ AX, 0(SP)			
  0x419018		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x419021		e8cab70000		CALL runtime.printstring(SB)	
  0x419026		488b442438		MOVQ 0x38(SP), AX		
  0x41902b		48890424		MOVQ AX, 0(SP)			
  0x41902f		e87cb60000		CALL runtime.printhex(SB)	
  0x419034		488d0548600500		LEAQ 0x56048(IP), AX		
  0x41903b		48890424		MOVQ AX, 0(SP)			
  0x41903f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x419048		e8a3b70000		CALL runtime.printstring(SB)	
  0x41904d		488b442440		MOVQ 0x40(SP), AX		
  0x419052		48890424		MOVQ AX, 0(SP)			
  0x419056		e855b60000		CALL runtime.printhex(SB)	
  0x41905b		488d0538600500		LEAQ 0x56038(IP), AX		
  0x419062		48890424		MOVQ AX, 0(SP)			
  0x419066		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41906f		e87cb70000		CALL runtime.printstring(SB)	
  0x419074		e8c7ae0000		CALL runtime.printunlock(SB)	
			gcDumpObject("base", base, off)
  0x419079		488d05c1600500		LEAQ 0x560c1(IP), AX		
  0x419080		48890424		MOVQ AX, 0(SP)			
  0x419084		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x41908d		488b442438		MOVQ 0x38(SP), AX		
  0x419092		4889442410		MOVQ AX, 0x10(SP)		
  0x419097		488b442440		MOVQ 0x40(SP), AX		
  0x41909c		4889442418		MOVQ AX, 0x18(SP)		
  0x4190a1		e8da010000		CALL runtime.gcDumpObject(SB)	
			gcDumpObject("obj", obj, ^uintptr(0))
  0x4190a6		488d0542600500		LEAQ 0x56042(IP), AX		
  0x4190ad		48890424		MOVQ AX, 0(SP)			
  0x4190b1		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x4190ba		488b442430		MOVQ 0x30(SP), AX		
  0x4190bf		4889442410		MOVQ AX, 0x10(SP)		
  0x4190c4		48c7442418ffffffff	MOVQ $-0x1, 0x18(SP)		
  0x4190cd		e8ae010000		CALL runtime.gcDumpObject(SB)	
			getg().m.traceback = 2
  0x4190d2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4190db		488b4030		MOVQ 0x30(AX), AX	
  0x4190df		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("marking free object")
  0x4190e6		488d0515730500		LEAQ 0x57315(IP), AX	
  0x4190ed		48890424		MOVQ AX, 0(SP)		
  0x4190f1		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x4190fa		e881a30000		CALL runtime.throw(SB)	
  0x4190ff		0f0b			UD2			
			throw("setCheckmarked and isCheckmarked disagree")
  0x419101		488d05009a0500		LEAQ 0x59a00(IP), AX	
  0x419108		48890424		MOVQ AX, 0(SP)		
  0x41910c		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x419115		e866a30000		CALL runtime.throw(SB)	
  0x41911a		0f0b			UD2			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41911c		e8ff8d0000		CALL runtime.panicindex(SB)	
  0x419121		0f0b			UD2				
			printlock()
  0x419123		e898ad0000		CALL runtime.printlock(SB)	
			print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n")
  0x419128		e893ad0000		CALL runtime.printlock(SB)	
  0x41912d		488d05f3a40500		LEAQ 0x5a4f3(IP), AX		
  0x419134		48890424		MOVQ AX, 0(SP)			
  0x419138		48c744240844000000	MOVQ $0x44, 0x8(SP)		
  0x419141		e8aab60000		CALL runtime.printstring(SB)	
  0x419146		488b442430		MOVQ 0x30(SP), AX		
  0x41914b		48890424		MOVQ AX, 0(SP)			
  0x41914f		e85cb50000		CALL runtime.printhex(SB)	
  0x419154		e8f7af0000		CALL runtime.printnl(SB)	
  0x419159		e8e2ad0000		CALL runtime.printunlock(SB)	
			print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n")
  0x41915e		e85dad0000		CALL runtime.printlock(SB)	
  0x419163		488d05a07d0500		LEAQ 0x57da0(IP), AX		
  0x41916a		48890424		MOVQ AX, 0(SP)			
  0x41916e		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x419177		e874b60000		CALL runtime.printstring(SB)	
  0x41917c		488b442438		MOVQ 0x38(SP), AX		
  0x419181		48890424		MOVQ AX, 0(SP)			
  0x419185		e826b50000		CALL runtime.printhex(SB)	
  0x41918a		488d05f25e0500		LEAQ 0x55ef2(IP), AX		
  0x419191		48890424		MOVQ AX, 0(SP)			
  0x419195		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41919e		e84db60000		CALL runtime.printstring(SB)	
  0x4191a3		488b442440		MOVQ 0x40(SP), AX		
  0x4191a8		48890424		MOVQ AX, 0(SP)			
  0x4191ac		e8ffb40000		CALL runtime.printhex(SB)	
  0x4191b1		488d05e25e0500		LEAQ 0x55ee2(IP), AX		
  0x4191b8		48890424		MOVQ AX, 0(SP)			
  0x4191bc		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4191c5		e826b60000		CALL runtime.printstring(SB)	
  0x4191ca		e871ad0000		CALL runtime.printunlock(SB)	
			gcDumpObject("base", base, off)
  0x4191cf		488d056b5f0500		LEAQ 0x55f6b(IP), AX		
  0x4191d6		48890424		MOVQ AX, 0(SP)			
  0x4191da		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4191e3		488b442438		MOVQ 0x38(SP), AX		
  0x4191e8		4889442410		MOVQ AX, 0x10(SP)		
  0x4191ed		488b442440		MOVQ 0x40(SP), AX		
  0x4191f2		4889442418		MOVQ AX, 0x18(SP)		
  0x4191f7		e884000000		CALL runtime.gcDumpObject(SB)	
			gcDumpObject("obj", obj, ^uintptr(0))
  0x4191fc		488d05ec5e0500		LEAQ 0x55eec(IP), AX		
  0x419203		48890424		MOVQ AX, 0(SP)			
  0x419207		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x419210		488b442430		MOVQ 0x30(SP), AX		
  0x419215		4889442410		MOVQ AX, 0x10(SP)		
  0x41921a		48c7442418ffffffff	MOVQ $-0x1, 0x18(SP)		
  0x419223		e858000000		CALL runtime.gcDumpObject(SB)	
			getg().m.traceback = 2
  0x419228		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x419231		488b4030		MOVQ 0x30(AX), AX	
  0x419235		c6802901000002		MOVB $0x2, 0x129(AX)	
			throw("checkmark found unmarked object")
  0x41923c		488d05178b0500		LEAQ 0x58b17(IP), AX	
  0x419243		48890424		MOVQ AX, 0(SP)		
  0x419247		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x419250		e82ba20000		CALL runtime.throw(SB)	
  0x419255		0f0b			UD2			
		throw("greyobject: obj not pointer-aligned")
  0x419257		488d05fe910500		LEAQ 0x591fe(IP), AX	
  0x41925e		48890424		MOVQ AX, 0(SP)		
  0x419262		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x41926b		e810a20000		CALL runtime.throw(SB)	
  0x419270		0f0b			UD2			
func greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr) {
  0x419272		e809e60200		CALL runtime.morestack_noctxt(SB)	
  0x419277		e954faffff		JMP runtime.greyobject(SB)		

TEXT runtime.gcDumpObject(SB) /usr/local/go/src/runtime/mgcmark.go
func gcDumpObject(label string, obj, off uintptr) {
  0x419280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419289		483b6110		CMPQ 0x10(CX), SP	
  0x41928d		0f867a040000		JBE 0x41970d		
  0x419293		4883ec68		SUBQ $0x68, SP		
  0x419297		48896c2460		MOVQ BP, 0x60(SP)	
  0x41929c		488d6c2460		LEAQ 0x60(SP), BP	
	s := spanOf(obj)
  0x4192a1		90			NOPL			
	ri := arenaIndex(p)
  0x4192a2		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x4192a3		90			NOPL			
	s := spanOf(obj)
  0x4192a4		488b842480000000	MOVQ 0x80(SP), AX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4192ac		48b90000000000800000	MOVQ $0x800000000000, CX	
  0x4192b6		4801c1			ADDQ AX, CX			
  0x4192b9		48c1e91a		SHRQ $0x1a, CX			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x4192bd		4881f900004000		CMPQ $0x400000, CX	
  0x4192c4		0f8211040000		JB 0x4196db		
  0x4192ca		31c9			XORL CX, CX		
	s := spanOf(obj)
  0x4192cc		48894c2450		MOVQ CX, 0x50(SP)	
	print(label, "=", hex(obj))
  0x4192d1		e8eaab0000		CALL runtime.printlock(SB)	
  0x4192d6		488b442470		MOVQ 0x70(SP), AX		
  0x4192db		48890424		MOVQ AX, 0(SP)			
  0x4192df		488b4c2478		MOVQ 0x78(SP), CX		
  0x4192e4		48894c2408		MOVQ CX, 0x8(SP)		
  0x4192e9		e802b50000		CALL runtime.printstring(SB)	
  0x4192ee		488d05955d0500		LEAQ 0x55d95(IP), AX		
  0x4192f5		48890424		MOVQ AX, 0(SP)			
  0x4192f9		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x419302		e8e9b40000		CALL runtime.printstring(SB)	
  0x419307		488b842480000000	MOVQ 0x80(SP), AX		
  0x41930f		48890424		MOVQ AX, 0(SP)			
  0x419313		e898b30000		CALL runtime.printhex(SB)	
  0x419318		e823ac0000		CALL runtime.printunlock(SB)	
	if s == nil {
  0x41931d		488b442450		MOVQ 0x50(SP), AX	
  0x419322		4885c0			TESTQ AX, AX		
  0x419325		0f8483030000		JE 0x4196ae		
	print(" s.base()=", hex(s.base()), " s.limit=", hex(s.limit), " s.spanclass=", s.spanclass, " s.elemsize=", s.elemsize, " s.state=")
  0x41932b		90			NOPL			
  0x41932c		488b4878		MOVQ 0x78(AX), CX	
  0x419330		48894c2448		MOVQ CX, 0x48(SP)	
  0x419335		0fb65062		MOVZX 0x62(AX), DX	
  0x419339		4889542440		MOVQ DX, 0x40(SP)	
  0x41933e		488b5868		MOVQ 0x68(AX), BX	
  0x419342		48895c2438		MOVQ BX, 0x38(SP)	
	return s.startAddr
  0x419347		488b7018		MOVQ 0x18(AX), SI	
  0x41934b		4889742418		MOVQ SI, 0x18(SP)	
	print(" s.base()=", hex(s.base()), " s.limit=", hex(s.limit), " s.spanclass=", s.spanclass, " s.elemsize=", s.elemsize, " s.state=")
  0x419350		e86bab0000		CALL runtime.printlock(SB)	
  0x419355		488d05e8630500		LEAQ 0x563e8(IP), AX		
  0x41935c		48890424		MOVQ AX, 0(SP)			
  0x419360		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x419369		e882b40000		CALL runtime.printstring(SB)	
  0x41936e		488b442418		MOVQ 0x18(SP), AX		
  0x419373		48890424		MOVQ AX, 0(SP)			
  0x419377		e834b30000		CALL runtime.printhex(SB)	
  0x41937c		488d0567610500		LEAQ 0x56167(IP), AX		
  0x419383		48890424		MOVQ AX, 0(SP)			
  0x419387		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x419390		e85bb40000		CALL runtime.printstring(SB)	
  0x419395		488b442448		MOVQ 0x48(SP), AX		
  0x41939a		48890424		MOVQ AX, 0(SP)			
  0x41939e		e80db30000		CALL runtime.printhex(SB)	
  0x4193a3		488d052e680500		LEAQ 0x5682e(IP), AX		
  0x4193aa		48890424		MOVQ AX, 0(SP)			
  0x4193ae		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4193b7		e834b40000		CALL runtime.printstring(SB)	
  0x4193bc		488b442440		MOVQ 0x40(SP), AX		
  0x4193c1		48890424		MOVQ AX, 0(SP)			
  0x4193c5		e876b10000		CALL runtime.printuint(SB)	
  0x4193ca		488d0528660500		LEAQ 0x56628(IP), AX		
  0x4193d1		48890424		MOVQ AX, 0(SP)			
  0x4193d5		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x4193de		e80db40000		CALL runtime.printstring(SB)	
  0x4193e3		488b442438		MOVQ 0x38(SP), AX		
  0x4193e8		48890424		MOVQ AX, 0(SP)			
  0x4193ec		e84fb10000		CALL runtime.printuint(SB)	
  0x4193f1		488d05fb600500		LEAQ 0x560fb(IP), AX		
  0x4193f8		48890424		MOVQ AX, 0(SP)			
  0x4193fc		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x419405		e8e6b30000		CALL runtime.printstring(SB)	
  0x41940a		e831ab0000		CALL runtime.printunlock(SB)	
	if 0 <= s.state && int(s.state) < len(mSpanStateNames) {
  0x41940f		488b442450		MOVQ 0x50(SP), AX			
  0x419414		0fb64863		MOVZX 0x63(AX), CX			
  0x419418		884c2417		MOVB CL, 0x17(SP)			
  0x41941c		84c9			TESTL CL, CL				
  0x41941e		7214			JB 0x419434				
  0x419420		488b15a9680a00		MOVQ runtime.mSpanStateNames(SB), DX	
  0x419427		48390daa680a00		CMPQ CX, runtime.mSpanStateNames+8(SB)	
  0x41942e		0f8f37020000		JG 0x41966b				
		print("unknown(", s.state, ")\n")
  0x419434		e887aa0000		CALL runtime.printlock(SB)	
  0x419439		488d0548600500		LEAQ 0x56048(IP), AX		
  0x419440		48890424		MOVQ AX, 0(SP)			
  0x419444		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x41944d		e89eb30000		CALL runtime.printstring(SB)	
  0x419452		0fb6442417		MOVZX 0x17(SP), AX		
  0x419457		48890424		MOVQ AX, 0(SP)			
  0x41945b		e8e0b00000		CALL runtime.printuint(SB)	
  0x419460		488d05335c0500		LEAQ 0x55c33(IP), AX		
  0x419467		48890424		MOVQ AX, 0(SP)			
  0x41946b		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x419474		e877b30000		CALL runtime.printstring(SB)	
  0x419479		e8c2aa0000		CALL runtime.printunlock(SB)	
	size := s.elemsize
  0x41947e		488b442450		MOVQ 0x50(SP), AX	
  0x419483		488b4868		MOVQ 0x68(AX), CX	
	if s.state == mSpanManual && size == 0 {
  0x419487		80786302		CMPB $0x2, 0x63(AX)	
  0x41948b		0f85cd010000		JNE 0x41965e		
  0x419491		4885c9			TESTQ CX, CX		
  0x419494		0f85c4010000		JNE 0x41965e		
		size = off + sys.PtrSize
  0x41949a		488b842488000000	MOVQ 0x88(SP), AX	
  0x4194a2		488d4808		LEAQ 0x8(AX), CX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x4194a6		48894c2420		MOVQ CX, 0x20(SP)	
  0x4194ab		31d2			XORL DX, DX		
  0x4194ad		31db			XORL BX, BX		
  0x4194af		eb04			JMP 0x4194b5		
  0x4194b1		4883c208		ADDQ $0x8, DX		
  0x4194b5		4839ca			CMPQ CX, DX		
  0x4194b8		0f836d010000		JAE 0x41962b		
		if !(i < 128*sys.PtrSize || off-16*sys.PtrSize < i && i < off+16*sys.PtrSize) {
  0x4194be		4881fa00040000		CMPQ $0x400, DX		
  0x4194c5		7227			JB 0x4194ee		
  0x4194c7		488d7080		LEAQ -0x80(AX), SI	
  0x4194cb		4839d6			CMPQ DX, SI		
  0x4194ce		0f8350010000		JAE 0x419624		
  0x4194d4		488db080000000		LEAQ 0x80(AX), SI	
  0x4194db		4839f2			CMPQ SI, DX		
  0x4194de		400f92c6		SETB SI			
  0x4194e2		4084f6			TESTL SI, SI		
  0x4194e5		7507			JNE 0x4194ee		
  0x4194e7		bb01000000		MOVL $0x1, BX		
			continue
  0x4194ec		ebc3			JMP 0x4194b1		
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x4194ee		4889542428		MOVQ DX, 0x28(SP)	
		if skipped {
  0x4194f3		84db			TESTL BL, BL		
  0x4194f5		0f85fc000000		JNE 0x4195f7		
		print(" *(", label, "+", i, ") = ", hex(*(*uintptr)(unsafe.Pointer(obj + i))))
  0x4194fb		488b842480000000	MOVQ 0x80(SP), AX		
  0x419503		488d0c02		LEAQ 0(DX)(AX*1), CX		
  0x419507		488b09			MOVQ 0(CX), CX			
  0x41950a		48894c2448		MOVQ CX, 0x48(SP)		
  0x41950f		e8aca90000		CALL runtime.printlock(SB)	
  0x419514		488d059e5b0500		LEAQ 0x55b9e(IP), AX		
  0x41951b		48890424		MOVQ AX, 0(SP)			
  0x41951f		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x419528		e8c3b20000		CALL runtime.printstring(SB)	
  0x41952d		488b442470		MOVQ 0x70(SP), AX		
  0x419532		48890424		MOVQ AX, 0(SP)			
  0x419536		488b4c2478		MOVQ 0x78(SP), CX		
  0x41953b		48894c2408		MOVQ CX, 0x8(SP)		
  0x419540		e8abb20000		CALL runtime.printstring(SB)	
  0x419545		488d05375b0500		LEAQ 0x55b37(IP), AX		
  0x41954c		48890424		MOVQ AX, 0(SP)			
  0x419550		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x419559		e892b20000		CALL runtime.printstring(SB)	
  0x41955e		488b442428		MOVQ 0x28(SP), AX		
  0x419563		48890424		MOVQ AX, 0(SP)			
  0x419567		e8d4af0000		CALL runtime.printuint(SB)	
  0x41956c		488d05a65b0500		LEAQ 0x55ba6(IP), AX		
  0x419573		48890424		MOVQ AX, 0(SP)			
  0x419577		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x419580		e86bb20000		CALL runtime.printstring(SB)	
  0x419585		488b442448		MOVQ 0x48(SP), AX		
  0x41958a		48890424		MOVQ AX, 0(SP)			
  0x41958e		e81db10000		CALL runtime.printhex(SB)	
  0x419593		e8a8a90000		CALL runtime.printunlock(SB)	
		if i == off {
  0x419598		488b442428		MOVQ 0x28(SP), AX	
  0x41959d		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x4195a5		4839c8			CMPQ CX, AX		
  0x4195a8		7428			JE 0x4195d2		
		print("\n")
  0x4195aa		e811a90000		CALL runtime.printlock(SB)	
  0x4195af		e89cab0000		CALL runtime.printnl(SB)	
  0x4195b4		e887a90000		CALL runtime.printunlock(SB)	
		if !(i < 128*sys.PtrSize || off-16*sys.PtrSize < i && i < off+16*sys.PtrSize) {
  0x4195b9		488b842488000000	MOVQ 0x88(SP), AX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x4195c1		488b4c2420		MOVQ 0x20(SP), CX	
  0x4195c6		488b542428		MOVQ 0x28(SP), DX	
  0x4195cb		31db			XORL BX, BX		
		print("\n")
  0x4195cd		e9dffeffff		JMP 0x4194b1		
			print(" <==")
  0x4195d2		e8e9a80000		CALL runtime.printlock(SB)	
  0x4195d7		488d05175b0500		LEAQ 0x55b17(IP), AX		
  0x4195de		48890424		MOVQ AX, 0(SP)			
  0x4195e2		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4195eb		e800b20000		CALL runtime.printstring(SB)	
  0x4195f0		e84ba90000		CALL runtime.printunlock(SB)	
  0x4195f5		ebb3			JMP 0x4195aa			
			print(" ...\n")
  0x4195f7		e8c4a80000		CALL runtime.printlock(SB)	
  0x4195fc		488d05865b0500		LEAQ 0x55b86(IP), AX		
  0x419603		48890424		MOVQ AX, 0(SP)			
  0x419607		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x419610		e8dbb10000		CALL runtime.printstring(SB)	
  0x419615		e826a90000		CALL runtime.printunlock(SB)	
		print(" *(", label, "+", i, ") = ", hex(*(*uintptr)(unsafe.Pointer(obj + i))))
  0x41961a		488b542428		MOVQ 0x28(SP), DX	
			skipped = false
  0x41961f		e9d7feffff		JMP 0x4194fb		
  0x419624		31f6			XORL SI, SI		
		if !(i < 128*sys.PtrSize || off-16*sys.PtrSize < i && i < off+16*sys.PtrSize) {
  0x419626		e9b7feffff		JMP 0x4194e2		
		if skipped {
  0x41962b		84db			TESTL BL, BL		
	if skipped {
  0x41962d		750a			JNE 0x419639		
  0x41962f		488b6c2460		MOVQ 0x60(SP), BP	
  0x419634		4883c468		ADDQ $0x68, SP		
  0x419638		c3			RET			
		print(" ...\n")
  0x419639		e882a80000		CALL runtime.printlock(SB)	
  0x41963e		488d05445b0500		LEAQ 0x55b44(IP), AX		
  0x419645		48890424		MOVQ AX, 0(SP)			
  0x419649		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x419652		e899b10000		CALL runtime.printstring(SB)	
  0x419657		e8e4a80000		CALL runtime.printunlock(SB)	
  0x41965c		ebd1			JMP 0x41962f			
		if !(i < 128*sys.PtrSize || off-16*sys.PtrSize < i && i < off+16*sys.PtrSize) {
  0x41965e		488b842488000000	MOVQ 0x88(SP), AX	
	for i := uintptr(0); i < size; i += sys.PtrSize {
  0x419666		e93bfeffff		JMP 0x4194a6		
		print(mSpanStateNames[s.state], "\n")
  0x41966b		48c1e104		SHLQ $0x4, CX			
  0x41966f		488b040a		MOVQ 0(DX)(CX*1), AX		
  0x419673		4889442458		MOVQ AX, 0x58(SP)		
  0x419678		488b4c0a08		MOVQ 0x8(DX)(CX*1), CX		
  0x41967d		48894c2430		MOVQ CX, 0x30(SP)		
  0x419682		e839a80000		CALL runtime.printlock(SB)	
  0x419687		488b442458		MOVQ 0x58(SP), AX		
  0x41968c		48890424		MOVQ AX, 0(SP)			
  0x419690		488b442430		MOVQ 0x30(SP), AX		
  0x419695		4889442408		MOVQ AX, 0x8(SP)		
  0x41969a		e851b10000		CALL runtime.printstring(SB)	
  0x41969f		e8acaa0000		CALL runtime.printnl(SB)	
  0x4196a4		e897a80000		CALL runtime.printunlock(SB)	
  0x4196a9		e9d0fdffff		JMP 0x41947e			
		print(" s=nil\n")
  0x4196ae		e80da80000		CALL runtime.printlock(SB)	
  0x4196b3		488d051b5c0500		LEAQ 0x55c1b(IP), AX		
  0x4196ba		48890424		MOVQ AX, 0(SP)			
  0x4196be		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4196c7		e824b10000		CALL runtime.printstring(SB)	
  0x4196cc		e86fa80000		CALL runtime.printunlock(SB)	
		return
  0x4196d1		488b6c2460		MOVQ 0x60(SP), BP	
  0x4196d6		4883c468		ADDQ $0x68, SP		
  0x4196da		c3			RET			
	l2 := mheap_.arenas[ri.l1()]
  0x4196db		488b156ed20a00		MOVQ runtime.mheap_+784(SB), DX	
	ha := l2[ri.l2()]
  0x4196e2		8402			TESTB AL, 0(DX)		
	l2 := mheap_.arenas[ri.l1()]
  0x4196e4		90			NOPL			
	ha := l2[ri.l2()]
  0x4196e5		488b0cca		MOVQ 0(DX)(CX*8), CX	
  0x4196e9		90			NOPL			
	if ha == nil {
  0x4196ea		4885c9			TESTQ CX, CX		
  0x4196ed		7417			JE 0x419706		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x4196ef		48c1e80d		SHRQ $0xd, AX			
  0x4196f3		4825ff1f0000		ANDQ $0x1fff, AX		
  0x4196f9		488b8cc100002000	MOVQ 0x200000(CX)(AX*8), CX	
	s := spanOf(obj)
  0x419701		e9c6fbffff		JMP 0x4192cc		
  0x419706		31c9			XORL CX, CX		
  0x419708		e9bffbffff		JMP 0x4192cc		
func gcDumpObject(label string, obj, off uintptr) {
  0x41970d		e86ee10200		CALL runtime.morestack_noctxt(SB)	
  0x419712		e969fbffff		JMP runtime.gcDumpObject(SB)		

TEXT runtime.gcmarknewobject(SB) /usr/local/go/src/runtime/mgcmark.go
func gcmarknewobject(obj, size, scanSize uintptr) {
  0x419720		4883ec28		SUBQ $0x28, SP		
  0x419724		48896c2420		MOVQ BP, 0x20(SP)	
  0x419729		488d6c2420		LEAQ 0x20(SP), BP	
	if useCheckmark { // The world should be stopped so this should not happen.
  0x41972e		803d81350c0000		CMPB $0x0, runtime.useCheckmark(SB)	
  0x419735		7557			JNE 0x41978e				
	markBitsForAddr(obj).setMarked()
  0x419737		488b442430		MOVQ 0x30(SP), AX			
  0x41973c		48890424		MOVQ AX, 0(SP)				
  0x419740		e86b43ffff		CALL runtime.markBitsForAddr(SB)	
  0x419745		0fb6442410		MOVZX 0x10(SP), AX			
  0x41974a		488b4c2408		MOVQ 0x8(SP), CX			
  0x41974f		90			NOPL					
	atomic.Or8(m.bytep, m.mask)
  0x419750		f00801			LOCK ORB AL, 0(CX)	
	gcw := &getg().m.p.ptr().gcw
  0x419753		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41975c		488b4030		MOVQ 0x30(AX), AX	
  0x419760		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x419767		8401			TESTB AL, 0(CX)		
  0x419769		8400			TESTB AL, 0(AX)		
  0x41976b		90			NOPL			
	gcw.bytesMarked += uint64(size)
  0x41976c		488b442438		MOVQ 0x38(SP), AX	
  0x419771		48018180120000		ADDQ AX, 0x1280(CX)	
	gcw.scanWork += int64(scanSize)
  0x419778		488b442440		MOVQ 0x40(SP), AX	
  0x41977d		48018188120000		ADDQ AX, 0x1288(CX)	
}
  0x419784		488b6c2420		MOVQ 0x20(SP), BP	
  0x419789		4883c428		ADDQ $0x28, SP		
  0x41978d		c3			RET			
		throw("gcmarknewobject called while doing checkmark")
  0x41978e		488d0542960500		LEAQ 0x59642(IP), AX	
  0x419795		48890424		MOVQ AX, 0(SP)		
  0x419799		48c74424082c000000	MOVQ $0x2c, 0x8(SP)	
  0x4197a2		e8d99c0000		CALL runtime.throw(SB)	
  0x4197a7		0f0b			UD2			

TEXT runtime.gcMarkTinyAllocs(SB) /usr/local/go/src/runtime/mgcmark.go
func gcMarkTinyAllocs() {
  0x4197b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4197b9		483b6110		CMPQ 0x10(CX), SP	
  0x4197bd		0f86c9000000		JBE 0x41988c		
  0x4197c3		4883ec60		SUBQ $0x60, SP		
  0x4197c7		48896c2458		MOVQ BP, 0x58(SP)	
  0x4197cc		488d6c2458		LEAQ 0x58(SP), BP	
	for _, p := range allp {
  0x4197d1		488b0550820a00		MOVQ runtime.allp+8(SB), AX	
  0x4197d8		4889442438		MOVQ AX, 0x38(SP)		
  0x4197dd		488b0d3c820a00		MOVQ runtime.allp(SB), CX	
  0x4197e4		48894c2450		MOVQ CX, 0x50(SP)		
  0x4197e9		31d2			XORL DX, DX			
  0x4197eb		eb03			JMP 0x4197f0			
  0x4197ed		48ffc2			INCQ DX				
  0x4197f0		4839c2			CMPQ AX, DX			
  0x4197f3		0f8d89000000		JGE 0x419882			
  0x4197f9		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		c := p.mcache
  0x4197fd		488b7348		MOVQ 0x48(BX), SI	
		if c == nil || c.tiny == 0 {
  0x419801		4885f6			TESTQ SI, SI		
  0x419804		74e7			JE 0x4197ed		
  0x419806		488b7e10		MOVQ 0x10(SI), DI	
  0x41980a		4885ff			TESTQ DI, DI		
  0x41980d		74de			JE 0x4197ed		
	for _, p := range allp {
  0x41980f		4889542430		MOVQ DX, 0x30(SP)	
  0x419814		48895c2440		MOVQ BX, 0x40(SP)	
		c := p.mcache
  0x419819		4889742448		MOVQ SI, 0x48(SP)	
		_, span, objIndex := findObject(c.tiny, 0, 0)
  0x41981e		48893c24		MOVQ DI, 0(SP)			
  0x419822		0f57c0			XORPS X0, X0			
  0x419825		0f11442408		MOVUPS X0, 0x8(SP)		
  0x41982a		e87143ffff		CALL runtime.findObject(SB)	
  0x41982f		488b442428		MOVQ 0x28(SP), AX		
  0x419834		488b4c2420		MOVQ 0x20(SP), CX		
		greyobject(c.tiny, 0, 0, span, gcw, objIndex)
  0x419839		488b542448		MOVQ 0x48(SP), DX	
  0x41983e		488b5210		MOVQ 0x10(DX), DX	
  0x419842		48891424		MOVQ DX, 0(SP)		
  0x419846		0f57c0			XORPS X0, X0		
  0x419849		0f11442408		MOVUPS X0, 0x8(SP)	
  0x41984e		48894c2418		MOVQ CX, 0x18(SP)	
		gcw := &p.gcw
  0x419853		488b4c2440		MOVQ 0x40(SP), CX	
  0x419858		4881c170120000		ADDQ $0x1270, CX	
		greyobject(c.tiny, 0, 0, span, gcw, objIndex)
  0x41985f		48894c2420		MOVQ CX, 0x20(SP)		
  0x419864		4889442428		MOVQ AX, 0x28(SP)		
  0x419869		e862f4ffff		CALL runtime.greyobject(SB)	
	for _, p := range allp {
  0x41986e		488b442438		MOVQ 0x38(SP), AX	
  0x419873		488b4c2450		MOVQ 0x50(SP), CX	
  0x419878		488b542430		MOVQ 0x30(SP), DX	
		greyobject(c.tiny, 0, 0, span, gcw, objIndex)
  0x41987d		e96bffffff		JMP 0x4197ed		
  0x419882		488b6c2458		MOVQ 0x58(SP), BP	
  0x419887		4883c460		ADDQ $0x60, SP		
  0x41988b		c3			RET			
func gcMarkTinyAllocs() {
  0x41988c		e8efdf0200		CALL runtime.morestack_noctxt(SB)	
  0x419891		e91affffff		JMP runtime.gcMarkTinyAllocs(SB)	

TEXT runtime.initCheckmarks(SB) /usr/local/go/src/runtime/mgcmark.go
func initCheckmarks() {
  0x4198a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4198a9		483b6110		CMPQ 0x10(CX), SP	
  0x4198ad		0f861c010000		JBE 0x4199cf		
  0x4198b3		4883ec50		SUBQ $0x50, SP		
  0x4198b7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4198bc		488d6c2448		LEAQ 0x48(SP), BP	
	useCheckmark = true
  0x4198c1		c605ee330c0001		MOVB $0x1, runtime.useCheckmark(SB)	
	for _, s := range mheap_.allspans {
  0x4198c8		488b0da1cd0a00		MOVQ runtime.mheap_+48(SB), CX	
  0x4198cf		48894c2438		MOVQ CX, 0x38(SP)		
  0x4198d4		488b158dcd0a00		MOVQ runtime.mheap_+40(SB), DX	
  0x4198db		4889542440		MOVQ DX, 0x40(SP)		
  0x4198e0		31c0			XORL AX, AX			
  0x4198e2		eb03			JMP 0x4198e7			
  0x4198e4		48ffc0			INCQ AX				
  0x4198e7		4839c8			CMPQ CX, AX			
  0x4198ea		0f8dce000000		JGE 0x4199be			
  0x4198f0		488b1cc2		MOVQ 0(DX)(AX*8), BX		
		if s.state == mSpanInUse {
  0x4198f4		807b6301		CMPB $0x1, 0x63(BX)	
  0x4198f8		75ea			JNE 0x4198e4		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x4198fa		488b354fd00a00		MOVQ runtime.mheap_+784(SB), SI	
  0x419901		8406			TESTB AL, 0(SI)			
			heapBitsForAddr(s.base()).initCheckmarkSpan(s.layout())
  0x419903		90			NOPL			
  0x419904		90			NOPL			
	return s.startAddr
  0x419905		488b7b18		MOVQ 0x18(BX), DI	
	arena := arenaIndex(addr)
  0x419909		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41990a		90			NOPL			
  0x41990b		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41990c		49b80000000000800000	MOVQ $0x800000000000, R8	
  0x419916		4e8d0c07		LEAQ 0(DI)(R8*1), R9		
  0x41991a		49c1e91a		SHRQ $0x1a, R9			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x41991e		4981f900004000		CMPQ $0x400000, R9	
  0x419925		0f839d000000		JAE 0x4199c8		
  0x41992b		4a8b34ce		MOVQ 0(SI)(R9*8), SI	
	if ha == nil {
  0x41992f		4885f6			TESTQ SI, SI		
  0x419932		747e			JE 0x4199b2		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x419934		4989fa			MOVQ DI, R10		
  0x419937		48c1ef05		SHRQ $0x5, DI		
  0x41993b		4881e7ffff1f00		ANDQ $0x1fffff, DI	
  0x419942		4801f7			ADDQ SI, DI		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x419945		49c1ea03		SHRQ $0x3, R10		
  0x419949		4983e203		ANDQ $0x3, R10		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x41994d		4881c6ffff1f00		ADDQ $0x1fffff, SI	
	for _, s := range mheap_.allspans {
  0x419954		4889442430		MOVQ AX, 0x30(SP)	
			heapBitsForAddr(s.base()).initCheckmarkSpan(s.layout())
  0x419959		90			NOPL			
	total = s.npages << _PageShift
  0x41995a		4c8b5b20		MOVQ 0x20(BX), R11	
  0x41995e		49c1e30d		SHLQ $0xd, R11		
	size = s.elemsize
  0x419962		488b5b68		MOVQ 0x68(BX), BX	
	if size > 0 {
  0x419966		4885db			TESTQ BX, BX		
  0x419969		7643			JBE 0x4199ae		
		n = total / size
  0x41996b		4c89d8			MOVQ R11, AX		
  0x41996e		31d2			XORL DX, DX		
  0x419970		48f7f3			DIVQ BX			
			heapBitsForAddr(s.base()).initCheckmarkSpan(s.layout())
  0x419973		48893c24		MOVQ DI, 0(SP)					
  0x419977		4489542408		MOVL R10, 0x8(SP)				
  0x41997c		44894c240c		MOVL R9, 0xc(SP)				
  0x419981		4889742410		MOVQ SI, 0x10(SP)				
  0x419986		48895c2418		MOVQ BX, 0x18(SP)				
  0x41998b		4889442420		MOVQ AX, 0x20(SP)				
  0x419990		4c895c2428		MOVQ R11, 0x28(SP)				
  0x419995		e8f654ffff		CALL runtime.heapBits.initCheckmarkSpan(SB)	
	for _, s := range mheap_.allspans {
  0x41999a		488b442430		MOVQ 0x30(SP), AX	
  0x41999f		488b4c2438		MOVQ 0x38(SP), CX	
  0x4199a4		488b542440		MOVQ 0x40(SP), DX	
			heapBitsForAddr(s.base()).initCheckmarkSpan(s.layout())
  0x4199a9		e936ffffff		JMP 0x4198e4		
  0x4199ae		31c0			XORL AX, AX		
	if size > 0 {
  0x4199b0		ebc1			JMP 0x419973		
  0x4199b2		31f6			XORL SI, SI		
  0x4199b4		4531c9			XORL R9, R9		
  0x4199b7		4531d2			XORL R10, R10		
  0x4199ba		31ff			XORL DI, DI		
			heapBitsForAddr(s.base()).initCheckmarkSpan(s.layout())
  0x4199bc		eb96			JMP 0x419954		
  0x4199be		488b6c2448		MOVQ 0x48(SP), BP	
  0x4199c3		4883c450		ADDQ $0x50, SP		
  0x4199c7		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x4199c8		e853850000		CALL runtime.panicindex(SB)	
  0x4199cd		0f0b			UD2				
func initCheckmarks() {
  0x4199cf		e8acde0200		CALL runtime.morestack_noctxt(SB)	
  0x4199d4		e9c7feffff		JMP runtime.initCheckmarks(SB)		

TEXT runtime.clearCheckmarks(SB) /usr/local/go/src/runtime/mgcmark.go
func clearCheckmarks() {
  0x4199e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4199e9		483b6110		CMPQ 0x10(CX), SP	
  0x4199ed		0f861c010000		JBE 0x419b0f		
  0x4199f3		4883ec50		SUBQ $0x50, SP		
  0x4199f7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4199fc		488d6c2448		LEAQ 0x48(SP), BP	
	useCheckmark = false
  0x419a01		c605ae320c0000		MOVB $0x0, runtime.useCheckmark(SB)	
	for _, s := range mheap_.allspans {
  0x419a08		488b0d61cc0a00		MOVQ runtime.mheap_+48(SB), CX	
  0x419a0f		48894c2438		MOVQ CX, 0x38(SP)		
  0x419a14		488b154dcc0a00		MOVQ runtime.mheap_+40(SB), DX	
  0x419a1b		4889542440		MOVQ DX, 0x40(SP)		
  0x419a20		31c0			XORL AX, AX			
  0x419a22		eb03			JMP 0x419a27			
  0x419a24		48ffc0			INCQ AX				
  0x419a27		4839c8			CMPQ CX, AX			
  0x419a2a		0f8dce000000		JGE 0x419afe			
  0x419a30		488b1cc2		MOVQ 0(DX)(AX*8), BX		
		if s.state == mSpanInUse {
  0x419a34		807b6301		CMPB $0x1, 0x63(BX)	
  0x419a38		75ea			JNE 0x419a24		
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x419a3a		488b350fcf0a00		MOVQ runtime.mheap_+784(SB), SI	
  0x419a41		8406			TESTB AL, 0(SI)			
			heapBitsForAddr(s.base()).clearCheckmarkSpan(s.layout())
  0x419a43		90			NOPL			
  0x419a44		90			NOPL			
	return s.startAddr
  0x419a45		488b7b18		MOVQ 0x18(BX), DI	
	arena := arenaIndex(addr)
  0x419a49		90			NOPL			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x419a4a		90			NOPL			
  0x419a4b		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x419a4c		49b80000000000800000	MOVQ $0x800000000000, R8	
  0x419a56		4e8d0c07		LEAQ 0(DI)(R8*1), R9		
  0x419a5a		49c1e91a		SHRQ $0x1a, R9			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x419a5e		4981f900004000		CMPQ $0x400000, R9	
  0x419a65		0f839d000000		JAE 0x419b08		
  0x419a6b		4a8b34ce		MOVQ 0(SI)(R9*8), SI	
	if ha == nil {
  0x419a6f		4885f6			TESTQ SI, SI		
  0x419a72		747e			JE 0x419af2		
	h.bitp = &ha.bitmap[(addr/(sys.PtrSize*4))%heapArenaBitmapBytes]
  0x419a74		4989fa			MOVQ DI, R10		
  0x419a77		48c1ef05		SHRQ $0x5, DI		
  0x419a7b		4881e7ffff1f00		ANDQ $0x1fffff, DI	
  0x419a82		4801f7			ADDQ SI, DI		
	h.shift = uint32((addr / sys.PtrSize) & 3)
  0x419a85		49c1ea03		SHRQ $0x3, R10		
  0x419a89		4983e203		ANDQ $0x3, R10		
	h.last = &ha.bitmap[len(ha.bitmap)-1]
  0x419a8d		4881c6ffff1f00		ADDQ $0x1fffff, SI	
	for _, s := range mheap_.allspans {
  0x419a94		4889442430		MOVQ AX, 0x30(SP)	
			heapBitsForAddr(s.base()).clearCheckmarkSpan(s.layout())
  0x419a99		90			NOPL			
	total = s.npages << _PageShift
  0x419a9a		4c8b5b20		MOVQ 0x20(BX), R11	
  0x419a9e		49c1e30d		SHLQ $0xd, R11		
	size = s.elemsize
  0x419aa2		488b5b68		MOVQ 0x68(BX), BX	
	if size > 0 {
  0x419aa6		4885db			TESTQ BX, BX		
  0x419aa9		7643			JBE 0x419aee		
		n = total / size
  0x419aab		4c89d8			MOVQ R11, AX		
  0x419aae		31d2			XORL DX, DX		
  0x419ab0		48f7f3			DIVQ BX			
			heapBitsForAddr(s.base()).clearCheckmarkSpan(s.layout())
  0x419ab3		48893c24		MOVQ DI, 0(SP)					
  0x419ab7		4489542408		MOVL R10, 0x8(SP)				
  0x419abc		44894c240c		MOVL R9, 0xc(SP)				
  0x419ac1		4889742410		MOVQ SI, 0x10(SP)				
  0x419ac6		48895c2418		MOVQ BX, 0x18(SP)				
  0x419acb		4889442420		MOVQ AX, 0x20(SP)				
  0x419ad0		4c895c2428		MOVQ R11, 0x28(SP)				
  0x419ad5		e8f654ffff		CALL runtime.heapBits.clearCheckmarkSpan(SB)	
	for _, s := range mheap_.allspans {
  0x419ada		488b442430		MOVQ 0x30(SP), AX	
  0x419adf		488b4c2438		MOVQ 0x38(SP), CX	
  0x419ae4		488b542440		MOVQ 0x40(SP), DX	
			heapBitsForAddr(s.base()).clearCheckmarkSpan(s.layout())
  0x419ae9		e936ffffff		JMP 0x419a24		
  0x419aee		31c0			XORL AX, AX		
	if size > 0 {
  0x419af0		ebc1			JMP 0x419ab3		
  0x419af2		31f6			XORL SI, SI		
  0x419af4		4531c9			XORL R9, R9		
  0x419af7		4531d2			XORL R10, R10		
  0x419afa		31ff			XORL DI, DI		
			heapBitsForAddr(s.base()).clearCheckmarkSpan(s.layout())
  0x419afc		eb96			JMP 0x419a94		
  0x419afe		488b6c2448		MOVQ 0x48(SP), BP	
  0x419b03		4883c450		ADDQ $0x50, SP		
  0x419b07		c3			RET			
	ha := mheap_.arenas[arena.l1()][arena.l2()]
  0x419b08		e813840000		CALL runtime.panicindex(SB)	
  0x419b0d		0f0b			UD2				
func clearCheckmarks() {
  0x419b0f		e86cdd0200		CALL runtime.morestack_noctxt(SB)	
  0x419b14		e9c7feffff		JMP runtime.clearCheckmarks(SB)		

TEXT runtime.init.1(SB) /usr/local/go/src/runtime/mgcstack.go
func init() {
  0x419b20		c3			RET			

TEXT runtime.(*stackScanState).putPtr(SB) /usr/local/go/src/runtime/mgcstack.go
func (s *stackScanState) putPtr(p uintptr) {
  0x419b30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419b39		483b6110		CMPQ 0x10(CX), SP	
  0x419b3d		0f86f3000000		JBE 0x419c36		
  0x419b43		4883ec18		SUBQ $0x18, SP		
  0x419b47		48896c2410		MOVQ BP, 0x10(SP)	
  0x419b4c		488d6c2410		LEAQ 0x10(SP), BP	
	if p < s.stack.lo || p >= s.stack.hi {
  0x419b51		488b442428		MOVQ 0x28(SP), AX	
  0x419b56		488b4c2420		MOVQ 0x20(SP), CX	
  0x419b5b		48398100010000		CMPQ AX, 0x100(CX)	
  0x419b62		0f87b3000000		JA 0x419c1b		
  0x419b68		48398108010000		CMPQ AX, 0x108(CX)	
  0x419b6f		0f86a6000000		JBE 0x419c1b		
	buf := s.buf
  0x419b75		488b9110010000		MOVQ 0x110(CX), DX	
	if buf == nil {
  0x419b7c		4885d2			TESTQ DX, DX		
  0x419b7f		7470			JE 0x419bf1		
	} else if buf.nobj == len(buf.obj) {
  0x419b81		48817a10fc000000	CMPQ $0xfc, 0x10(DX)	
  0x419b89		7531			JNE 0x419bbc		
		if s.freeBuf != nil {
  0x419b8b		488b9118010000		MOVQ 0x118(CX), DX	
  0x419b92		4885d2			TESTQ DX, DX		
  0x419b95		7445			JE 0x419bdc		
			s.freeBuf = nil
  0x419b97		48c7811801000000000000	MOVQ $0x0, 0x118(CX)	
		buf.nobj = 0
  0x419ba2		48c7421000000000	MOVQ $0x0, 0x10(DX)	
		buf.next = s.buf
  0x419baa		488b9910010000		MOVQ 0x110(CX), BX	
  0x419bb1		48895a18		MOVQ BX, 0x18(DX)	
		s.buf = buf
  0x419bb5		48899110010000		MOVQ DX, 0x110(CX)	
	buf.obj[buf.nobj] = p
  0x419bbc		488b4a10		MOVQ 0x10(DX), CX	
  0x419bc0		4881f9fc000000		CMPQ $0xfc, CX		
  0x419bc7		734b			JAE 0x419c14		
  0x419bc9		488944ca20		MOVQ AX, 0x20(DX)(CX*8)	
	buf.nobj++
  0x419bce		48ff4210		INCQ 0x10(DX)		
}
  0x419bd2		488b6c2410		MOVQ 0x10(SP), BP	
  0x419bd7		4883c418		ADDQ $0x18, SP		
  0x419bdb		c3			RET			
			buf = (*stackWorkBuf)(unsafe.Pointer(getempty()))
  0x419bdc		e8ff1f0000		CALL runtime.getempty(SB)	
  0x419be1		488b1424		MOVQ 0(SP), DX			
	buf.obj[buf.nobj] = p
  0x419be5		488b442428		MOVQ 0x28(SP), AX	
		buf.next = s.buf
  0x419bea		488b4c2420		MOVQ 0x20(SP), CX	
			buf = (*stackWorkBuf)(unsafe.Pointer(getempty()))
  0x419bef		ebb1			JMP 0x419ba2		
		buf = (*stackWorkBuf)(unsafe.Pointer(getempty()))
  0x419bf1		e8ea1f0000		CALL runtime.getempty(SB)	
  0x419bf6		488b1424		MOVQ 0(SP), DX			
		buf.next = nil
  0x419bfa		0f57c0			XORPS X0, X0		
  0x419bfd		0f114210		MOVUPS X0, 0x10(DX)	
		s.buf = buf
  0x419c01		488b442420		MOVQ 0x20(SP), AX	
  0x419c06		48899010010000		MOVQ DX, 0x110(AX)	
	buf.obj[buf.nobj] = p
  0x419c0d		488b442428		MOVQ 0x28(SP), AX	
		s.buf = buf
  0x419c12		eba8			JMP 0x419bbc		
	buf.obj[buf.nobj] = p
  0x419c14		e807830000		CALL runtime.panicindex(SB)	
  0x419c19		0f0b			UD2				
		throw("address not a stack address")
  0x419c1b		488d052b770500		LEAQ 0x5772b(IP), AX	
  0x419c22		48890424		MOVQ AX, 0(SP)		
  0x419c26		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x419c2f		e84c980000		CALL runtime.throw(SB)	
  0x419c34		0f0b			UD2			
func (s *stackScanState) putPtr(p uintptr) {
  0x419c36		e845dc0200		CALL runtime.morestack_noctxt(SB)		
  0x419c3b		e9f0feffff		JMP runtime.(*stackScanState).putPtr(SB)	

TEXT runtime.(*stackScanState).getPtr(SB) /usr/local/go/src/runtime/mgcstack.go
func (s *stackScanState) getPtr() uintptr {
  0x419c40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419c49		483b6110		CMPQ 0x10(CX), SP	
  0x419c4d		0f86e2000000		JBE 0x419d35		
  0x419c53		4883ec18		SUBQ $0x18, SP		
  0x419c57		48896c2410		MOVQ BP, 0x10(SP)	
  0x419c5c		488d6c2410		LEAQ 0x10(SP), BP	
	buf := s.buf
  0x419c61		488b442420		MOVQ 0x20(SP), AX	
  0x419c66		488b8810010000		MOVQ 0x110(AX), CX	
	if buf == nil {
  0x419c6d		4885c9			TESTQ CX, CX		
  0x419c70		0f84a5000000		JE 0x419d1b		
	if buf.nobj == 0 {
  0x419c76		4883791000		CMPQ $0x0, 0x10(CX)	
  0x419c7b		0f8595000000		JNE 0x419d16		
		if s.freeBuf != nil {
  0x419c81		488b9018010000		MOVQ 0x118(AX), DX	
  0x419c88		4885d2			TESTQ DX, DX		
  0x419c8b		756c			JNE 0x419cf9		
		s.freeBuf = buf
  0x419c8d		48898818010000		MOVQ CX, 0x118(AX)	
		buf = buf.next
  0x419c94		488b5118		MOVQ 0x18(CX), DX	
		s.buf = buf
  0x419c98		48899010010000		MOVQ DX, 0x110(AX)	
		if buf == nil {
  0x419c9f		4885d2			TESTQ DX, DX		
  0x419ca2		7429			JE 0x419ccd		
	buf.nobj--
  0x419ca4		488b4210		MOVQ 0x10(DX), AX	
  0x419ca8		488d48ff		LEAQ -0x1(AX), CX	
  0x419cac		48894a10		MOVQ CX, 0x10(DX)	
	return buf.obj[buf.nobj]
  0x419cb0		4881f9fc000000		CMPQ $0xfc, CX		
  0x419cb7		7375			JAE 0x419d2e		
  0x419cb9		488b44c218		MOVQ 0x18(DX)(AX*8), AX	
  0x419cbe		4889442428		MOVQ AX, 0x28(SP)	
  0x419cc3		488b6c2410		MOVQ 0x10(SP), BP	
  0x419cc8		4883c418		ADDQ $0x18, SP		
  0x419ccc		c3			RET			
			putempty((*workbuf)(unsafe.Pointer(s.freeBuf)))
  0x419ccd		48890c24		MOVQ CX, 0(SP)			
  0x419cd1		e83a210000		CALL runtime.putempty(SB)	
			s.freeBuf = nil
  0x419cd6		488b442420		MOVQ 0x20(SP), AX	
  0x419cdb		48c7801801000000000000	MOVQ $0x0, 0x118(AX)	
			return 0
  0x419ce6		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x419cef		488b6c2410		MOVQ 0x10(SP), BP	
  0x419cf4		4883c418		ADDQ $0x18, SP		
  0x419cf8		c3			RET			
	buf := s.buf
  0x419cf9		48894c2408		MOVQ CX, 0x8(SP)	
			putempty((*workbuf)(unsafe.Pointer(s.freeBuf)))
  0x419cfe		48891424		MOVQ DX, 0(SP)			
  0x419d02		e809210000		CALL runtime.putempty(SB)	
		s.freeBuf = buf
  0x419d07		488b442420		MOVQ 0x20(SP), AX	
  0x419d0c		488b4c2408		MOVQ 0x8(SP), CX	
			putempty((*workbuf)(unsafe.Pointer(s.freeBuf)))
  0x419d11		e977ffffff		JMP 0x419c8d		
	buf.nobj--
  0x419d16		4889ca			MOVQ CX, DX		
	if buf.nobj == 0 {
  0x419d19		eb89			JMP 0x419ca4		
		return 0
  0x419d1b		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x419d24		488b6c2410		MOVQ 0x10(SP), BP	
  0x419d29		4883c418		ADDQ $0x18, SP		
  0x419d2d		c3			RET			
	return buf.obj[buf.nobj]
  0x419d2e		e8ed810000		CALL runtime.panicindex(SB)	
  0x419d33		0f0b			UD2				
func (s *stackScanState) getPtr() uintptr {
  0x419d35		e846db0200		CALL runtime.morestack_noctxt(SB)		
  0x419d3a		e901ffffff		JMP runtime.(*stackScanState).getPtr(SB)	

TEXT runtime.(*stackScanState).addObject(SB) /usr/local/go/src/runtime/mgcstack.go
func (s *stackScanState) addObject(addr uintptr, typ *_type) {
  0x419d40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419d49		483b6110		CMPQ 0x10(CX), SP	
  0x419d4d		0f8647010000		JBE 0x419e9a		
  0x419d53		4883ec20		SUBQ $0x20, SP		
  0x419d57		48896c2418		MOVQ BP, 0x18(SP)	
  0x419d5c		488d6c2418		LEAQ 0x18(SP), BP	
	x := s.tail
  0x419d61		488b442428		MOVQ 0x28(SP), AX	
  0x419d66		488b8828010000		MOVQ 0x128(AX), CX	
	if x == nil {
  0x419d6d		4885c9			TESTQ CX, CX		
  0x419d70		0f84d2000000		JE 0x419e48		
	if x.nobj > 0 && uint32(addr-s.stack.lo) < x.obj[x.nobj-1].off+x.obj[x.nobj-1].size {
  0x419d76		488b5110		MOVQ 0x10(CX), DX	
  0x419d7a		4885d2			TESTQ DX, DX		
  0x419d7d		0f8ebb000000		JLE 0x419e3e		
  0x419d83		488b9800010000		MOVQ 0x100(AX), BX	
  0x419d8a		488b742430		MOVQ 0x30(SP), SI	
  0x419d8f		4889f7			MOVQ SI, DI		
  0x419d92		4829de			SUBQ BX, SI		
  0x419d95		488d5aff		LEAQ -0x1(DX), BX	
  0x419d99		4883fb3f		CMPQ $0x3f, BX		
  0x419d9d		0f83f0000000		JAE 0x419e93		
  0x419da3		48c1e305		SHLQ $0x5, BX		
  0x419da7		448b441920		MOVL 0x20(CX)(BX*1), R8	
  0x419dac		8b5c1924		MOVL 0x24(CX)(BX*1), BX	
  0x419db0		4401c3			ADDL R8, BX		
  0x419db3		39de			CMPL BX, SI		
  0x419db5		0f82bd000000		JB 0x419e78		
	if x.nobj == len(x.obj) {
  0x419dbb		4883fa3f		CMPQ $0x3f, DX		
  0x419dbf		744b			JE 0x419e0c		
	obj := &x.obj[x.nobj]
  0x419dc1		488b5110		MOVQ 0x10(CX), DX	
  0x419dc5		4883fa3f		CMPQ $0x3f, DX		
  0x419dc9		0f83a2000000		JAE 0x419e71		
	x.nobj++
  0x419dcf		488d5a01		LEAQ 0x1(DX), BX	
  0x419dd3		48895910		MOVQ BX, 0x10(CX)	
	obj := &x.obj[x.nobj]
  0x419dd7		48c1e205		SHLQ $0x5, DX		
	obj.off = uint32(addr - s.stack.lo)
  0x419ddb		488b9800010000		MOVQ 0x100(AX), BX	
  0x419de2		4829df			SUBQ BX, DI		
  0x419de5		897c1120		MOVL DI, 0x20(CX)(DX*1)	
	obj.size = uint32(typ.size)
  0x419de9		488b5c2438		MOVQ 0x38(SP), BX	
  0x419dee		488b33			MOVQ 0(BX), SI		
  0x419df1		89741124		MOVL SI, 0x24(CX)(DX*1)	
	obj.setType(typ)
  0x419df5		90			NOPL			
	*(*uintptr)(unsafe.Pointer(&obj.typ)) = uintptr(unsafe.Pointer(typ))
  0x419df6		48895c1128		MOVQ BX, 0x28(CX)(DX*1)	
	s.nobjs++
  0x419dfb		48ff8030010000		INCQ 0x130(AX)		
}
  0x419e02		488b6c2418		MOVQ 0x18(SP), BP	
  0x419e07		4883c420		ADDQ $0x20, SP		
  0x419e0b		c3			RET			
	if x.nobj > 0 && uint32(addr-s.stack.lo) < x.obj[x.nobj-1].off+x.obj[x.nobj-1].size {
  0x419e0c		48894c2410		MOVQ CX, 0x10(SP)	
		y := (*stackObjectBuf)(unsafe.Pointer(getempty()))
  0x419e11		e8ca1d0000		CALL runtime.getempty(SB)	
  0x419e16		488b0c24		MOVQ 0(SP), CX			
		y.next = nil
  0x419e1a		48c7411800000000	MOVQ $0x0, 0x18(CX)	
		x.next = y
  0x419e22		488b442410		MOVQ 0x10(SP), AX	
  0x419e27		48894818		MOVQ CX, 0x18(AX)	
		s.tail = y
  0x419e2b		488b442428		MOVQ 0x28(SP), AX	
  0x419e30		48898828010000		MOVQ CX, 0x128(AX)	
	obj.off = uint32(addr - s.stack.lo)
  0x419e37		488b7c2430		MOVQ 0x30(SP), DI	
		x = y
  0x419e3c		eb83			JMP 0x419dc1		
	obj.off = uint32(addr - s.stack.lo)
  0x419e3e		488b7c2430		MOVQ 0x30(SP), DI	
	if x.nobj > 0 && uint32(addr-s.stack.lo) < x.obj[x.nobj-1].off+x.obj[x.nobj-1].size {
  0x419e43		e973ffffff		JMP 0x419dbb		
		x = (*stackObjectBuf)(unsafe.Pointer(getempty()))
  0x419e48		e8931d0000		CALL runtime.getempty(SB)	
  0x419e4d		488b0c24		MOVQ 0(SP), CX			
		x.next = nil
  0x419e51		48c7411800000000	MOVQ $0x0, 0x18(CX)	
		s.head = x
  0x419e59		488b442428		MOVQ 0x28(SP), AX	
  0x419e5e		48898820010000		MOVQ CX, 0x120(AX)	
		s.tail = x
  0x419e65		48898828010000		MOVQ CX, 0x128(AX)	
  0x419e6c		e905ffffff		JMP 0x419d76		
	obj := &x.obj[x.nobj]
  0x419e71		e8aa800000		CALL runtime.panicindex(SB)	
  0x419e76		0f0b			UD2				
		throw("objects added out of order or overlapping")
  0x419e78		488d05378c0500		LEAQ 0x58c37(IP), AX	
  0x419e7f		48890424		MOVQ AX, 0(SP)		
  0x419e83		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x419e8c		e8ef950000		CALL runtime.throw(SB)	
  0x419e91		0f0b			UD2			
	if x.nobj > 0 && uint32(addr-s.stack.lo) < x.obj[x.nobj-1].off+x.obj[x.nobj-1].size {
  0x419e93		e888800000		CALL runtime.panicindex(SB)	
  0x419e98		0f0b			UD2				
func (s *stackScanState) addObject(addr uintptr, typ *_type) {
  0x419e9a		e8e1d90200		CALL runtime.morestack_noctxt(SB)		
  0x419e9f		e99cfeffff		JMP runtime.(*stackScanState).addObject(SB)	

TEXT runtime.binarySearchTree(SB) /usr/local/go/src/runtime/mgcstack.go
func binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int) {
  0x419eb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x419eb9		483b6110		CMPQ 0x10(CX), SP	
  0x419ebd		0f8641010000		JBE 0x41a004		
  0x419ec3		4883ec58		SUBQ $0x58, SP		
  0x419ec7		48896c2450		MOVQ BP, 0x50(SP)	
  0x419ecc		488d6c2450		LEAQ 0x50(SP), BP	
	if n == 0 {
  0x419ed1		488b442470		MOVQ 0x70(SP), AX	
  0x419ed6		4885c0			TESTQ AX, AX		
  0x419ed9		0f84f1000000		JE 0x419fd0		
	left, x, idx = binarySearchTree(x, idx, n/2)
  0x419edf		488b4c2460		MOVQ 0x60(SP), CX			
  0x419ee4		48890c24		MOVQ CX, 0(SP)				
  0x419ee8		488b4c2468		MOVQ 0x68(SP), CX			
  0x419eed		48894c2408		MOVQ CX, 0x8(SP)			
  0x419ef2		4889c1			MOVQ AX, CX				
  0x419ef5		48c1e83f		SHRQ $0x3f, AX				
  0x419ef9		4801c8			ADDQ CX, AX				
  0x419efc		48d1f8			SARQ $0x1, AX				
  0x419eff		4889442438		MOVQ AX, 0x38(SP)			
  0x419f04		4889442410		MOVQ AX, 0x10(SP)			
  0x419f09		e8a2ffffff		CALL runtime.binarySearchTree(SB)	
  0x419f0e		488b442420		MOVQ 0x20(SP), AX			
	root = &x.obj[idx]
  0x419f13		8400			TESTB AL, 0(AX)		
	left, x, idx = binarySearchTree(x, idx, n/2)
  0x419f15		488b4c2428		MOVQ 0x28(SP), CX	
  0x419f1a		488b542418		MOVQ 0x18(SP), DX	
	root = &x.obj[idx]
  0x419f1f		4883f93f		CMPQ $0x3f, CX		
  0x419f23		0f83d4000000		JAE 0x419ffd		
	left, x, idx = binarySearchTree(x, idx, n/2)
  0x419f29		4889542440		MOVQ DX, 0x40(SP)	
  0x419f2e		4889442460		MOVQ AX, 0x60(SP)	
	root = &x.obj[idx]
  0x419f33		4889cb			MOVQ CX, BX		
  0x419f36		48c1e105		SHLQ $0x5, CX		
  0x419f3a		48894c2430		MOVQ CX, 0x30(SP)	
  0x419f3f		488d3408		LEAQ 0(AX)(CX*1), SI	
  0x419f43		488d7620		LEAQ 0x20(SI), SI	
  0x419f47		4889742448		MOVQ SI, 0x48(SP)	
	idx++
  0x419f4c		488d7b01		LEAQ 0x1(BX), DI	
	if idx == len(x.obj) {
  0x419f50		4883fb3e		CMPQ $0x3e, BX		
  0x419f54		7575			JNE 0x419fcb		
		x = x.next
  0x419f56		488b5818		MOVQ 0x18(AX), BX	
  0x419f5a		31ff			XORL DI, DI		
	right, x, idx = binarySearchTree(x, idx, n-n/2-1)
  0x419f5c		48891c24		MOVQ BX, 0(SP)				
  0x419f60		48897c2408		MOVQ DI, 0x8(SP)			
  0x419f65		488b442470		MOVQ 0x70(SP), AX			
  0x419f6a		488b4c2438		MOVQ 0x38(SP), CX			
  0x419f6f		4829c8			SUBQ CX, AX				
  0x419f72		48ffc8			DECQ AX					
  0x419f75		4889442410		MOVQ AX, 0x10(SP)			
  0x419f7a		e831ffffff		CALL runtime.binarySearchTree(SB)	
  0x419f7f		488b442420		MOVQ 0x20(SP), AX			
  0x419f84		488b4c2428		MOVQ 0x28(SP), CX			
  0x419f89		488b542418		MOVQ 0x18(SP), DX			
	root.left = left
  0x419f8e		488b5c2430		MOVQ 0x30(SP), BX	
  0x419f93		488b742440		MOVQ 0x40(SP), SI	
  0x419f98		488b7c2460		MOVQ 0x60(SP), DI	
  0x419f9d		4889741f30		MOVQ SI, 0x30(DI)(BX*1)	
	root.right = right
  0x419fa2		4889541f38		MOVQ DX, 0x38(DI)(BX*1)	
	return root, x, idx
  0x419fa7		488b542448		MOVQ 0x48(SP), DX	
  0x419fac		4889542478		MOVQ DX, 0x78(SP)	
  0x419fb1		4889842480000000	MOVQ AX, 0x80(SP)	
  0x419fb9		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x419fc1		488b6c2450		MOVQ 0x50(SP), BP	
  0x419fc6		4883c458		ADDQ $0x58, SP		
  0x419fca		c3			RET			
	right, x, idx = binarySearchTree(x, idx, n-n/2-1)
  0x419fcb		4889c3			MOVQ AX, BX		
	if idx == len(x.obj) {
  0x419fce		eb8c			JMP 0x419f5c		
		return nil, x, idx
  0x419fd0		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x419fd9		488b442460		MOVQ 0x60(SP), AX	
  0x419fde		4889842480000000	MOVQ AX, 0x80(SP)	
  0x419fe6		488b442468		MOVQ 0x68(SP), AX	
  0x419feb		4889842488000000	MOVQ AX, 0x88(SP)	
  0x419ff3		488b6c2450		MOVQ 0x50(SP), BP	
  0x419ff8		4883c458		ADDQ $0x58, SP		
  0x419ffc		c3			RET			
	root = &x.obj[idx]
  0x419ffd		e81e7f0000		CALL runtime.panicindex(SB)	
  0x41a002		0f0b			UD2				
func binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int) {
  0x41a004		e877d80200		CALL runtime.morestack_noctxt(SB)	
  0x41a009		e9a2feffff		JMP runtime.binarySearchTree(SB)	

TEXT runtime.(*stackScanState).findObject(SB) /usr/local/go/src/runtime/mgcstack.go
	off := uint32(a - s.stack.lo)
  0x41a010		488b442410		MOVQ 0x10(SP), AX	
  0x41a015		488b4c2408		MOVQ 0x8(SP), CX	
  0x41a01a		482b8100010000		SUBQ 0x100(CX), AX	
	obj := s.root
  0x41a021		488b8938010000		MOVQ 0x138(CX), CX	
		if obj == nil {
  0x41a028		4885c9			TESTQ CX, CX		
  0x41a02b		7421			JE 0x41a04e		
		if off < obj.off {
  0x41a02d		8b11			MOVL 0(CX), DX		
  0x41a02f		39d0			CMPL DX, AX		
  0x41a031		7306			JAE 0x41a039		
			obj = obj.left
  0x41a033		488b4910		MOVQ 0x10(CX), CX	
			continue
  0x41a037		ebef			JMP 0x41a028		
		if off >= obj.off+obj.size {
  0x41a039		8b5904			MOVL 0x4(CX), BX	
  0x41a03c		01da			ADDL BX, DX		
  0x41a03e		39d0			CMPL DX, AX		
  0x41a040		7206			JB 0x41a048		
			obj = obj.right
  0x41a042		488b4918		MOVQ 0x18(CX), CX	
			continue
  0x41a046		ebe0			JMP 0x41a028		
		return obj
  0x41a048		48894c2418		MOVQ CX, 0x18(SP)	
  0x41a04d		c3			RET			
			return nil
  0x41a04e		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x41a057		c3			RET			

TEXT runtime.finishsweep_m(SB) /usr/local/go/src/runtime/mgcsweep.go
func finishsweep_m() {
  0x41a060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a069		483b6110		CMPQ 0x10(CX), SP	
  0x41a06d		7631			JBE 0x41a0a0		
  0x41a06f		4883ec10		SUBQ $0x10, SP		
  0x41a073		48896c2408		MOVQ BP, 0x8(SP)	
  0x41a078		488d6c2408		LEAQ 0x8(SP), BP	
	for sweepone() != ^uintptr(0) {
  0x41a07d		eb06			JMP 0x41a085		
		sweep.npausesweep++
  0x41a07f		ff05f37a0a00		INCL runtime.sweep+24(SB)	
	for sweepone() != ^uintptr(0) {
  0x41a085		e896010000		CALL runtime.sweepone(SB)	
  0x41a08a		48833c24ff		CMPQ $-0x1, 0(SP)		
  0x41a08f		75ee			JNE 0x41a07f			
	nextMarkBitArenaEpoch()
  0x41a091		e85a530000		CALL runtime.nextMarkBitArenaEpoch(SB)	
}
  0x41a096		488b6c2408		MOVQ 0x8(SP), BP	
  0x41a09b		4883c410		ADDQ $0x10, SP		
  0x41a09f		c3			RET			
func finishsweep_m() {
  0x41a0a0		e8dbd70200		CALL runtime.morestack_noctxt(SB)	
  0x41a0a5		ebb9			JMP runtime.finishsweep_m(SB)		

TEXT runtime.bgsweep(SB) /usr/local/go/src/runtime/mgcsweep.go
func bgsweep(c chan int) {
  0x41a0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a0b9		483b6110		CMPQ 0x10(CX), SP	
  0x41a0bd		0f8649010000		JBE 0x41a20c		
  0x41a0c3		4883ec28		SUBQ $0x28, SP		
  0x41a0c7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41a0cc		488d6c2420		LEAQ 0x20(SP), BP	
	sweep.g = getg()
  0x41a0d1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x41a0da		833d3f2d0c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41a0e1		0f8514010000		JNE 0x41a1fb				
  0x41a0e7		4889057a7a0a00		MOVQ AX, runtime.sweep+8(SB)		
	lock(&sweep.lock)
  0x41a0ee		488d056b7a0a00		LEAQ runtime.sweep(SB), AX	
  0x41a0f5		48890424		MOVQ AX, 0(SP)			
  0x41a0f9		e8e2e5feff		CALL runtime.lock(SB)		
	sweep.parked = true
  0x41a0fe		c6056b7a0a0001		MOVB $0x1, runtime.sweep+16(SB)	
	c <- 1
  0x41a105		488b442430		MOVQ 0x30(SP), AX			
  0x41a10a		48890424		MOVQ AX, 0(SP)				
  0x41a10e		488d052b2c0600		LEAQ runtime.statictmp_18(SB), AX	
  0x41a115		4889442408		MOVQ AX, 0x8(SP)			
  0x41a11a		e841a4feff		CALL runtime.chansend1(SB)		
	goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1)
  0x41a11f		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x41a120		488d0509980500		LEAQ 0x59809(IP), AX		
  0x41a127		48890424		MOVQ AX, 0(SP)			
  0x41a12b		488d0d2e7a0a00		LEAQ runtime.sweep(SB), CX	
  0x41a132		48894c2408		MOVQ CX, 0x8(SP)		
  0x41a137		66c74424100c14		MOVW $0x140c, 0x10(SP)		
  0x41a13e		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x41a147		e804b00000		CALL runtime.gopark(SB)		
		for sweepone() != ^uintptr(0) {
  0x41a14c		eb18			JMP 0x41a166		
			sweep.nbgsweep++
  0x41a14e		ff05207a0a00		INCL runtime.sweep+20(SB)	
			Gosched()
  0x41a154		90			NOPL			
	checkTimeouts()
  0x41a155		90			NOPL			
	mcall(gosched_m)
  0x41a156		488d05fb960500		LEAQ 0x596fb(IP), AX	
  0x41a15d		48890424		MOVQ AX, 0(SP)		
  0x41a161		e84ad50200		CALL runtime.mcall(SB)	
		for sweepone() != ^uintptr(0) {
  0x41a166		e8b5000000		CALL runtime.sweepone(SB)	
  0x41a16b		48833c24ff		CMPQ $-0x1, 0(SP)		
  0x41a170		75dc			JNE 0x41a14e			
  0x41a172		eb12			JMP 0x41a186			
			Gosched()
  0x41a174		90			NOPL			
	checkTimeouts()
  0x41a175		90			NOPL			
	mcall(gosched_m)
  0x41a176		488d05db960500		LEAQ 0x596db(IP), AX	
  0x41a17d		48890424		MOVQ AX, 0(SP)		
  0x41a181		e82ad50200		CALL runtime.mcall(SB)	
		for freeSomeWbufs(true) {
  0x41a186		c6042401		MOVB $0x1, 0(SP)		
  0x41a18a		e8211f0000		CALL runtime.freeSomeWbufs(SB)	
  0x41a18f		807c240800		CMPB $0x0, 0x8(SP)		
  0x41a194		75de			JNE 0x41a174			
		lock(&sweep.lock)
  0x41a196		488d05c3790a00		LEAQ runtime.sweep(SB), AX	
  0x41a19d		48890424		MOVQ AX, 0(SP)			
  0x41a1a1		e83ae5feff		CALL runtime.lock(SB)		
		if !isSweepDone() {
  0x41a1a6		90			NOPL			
	return mheap_.sweepdone != 0
  0x41a1a7		833daec40a0000		CMPL $0x0, runtime.mheap_+28(SB)	
		if !isSweepDone() {
  0x41a1ae		7436			JE 0x41a1e6		
		sweep.parked = true
  0x41a1b0		c605b9790a0001		MOVB $0x1, runtime.sweep+16(SB)	
		goparkunlock(&sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, 1)
  0x41a1b7		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x41a1b8		488d0571970500		LEAQ 0x59771(IP), AX		
  0x41a1bf		48890424		MOVQ AX, 0(SP)			
  0x41a1c3		488d0d96790a00		LEAQ runtime.sweep(SB), CX	
  0x41a1ca		48894c2408		MOVQ CX, 0x8(SP)		
  0x41a1cf		66c74424100c14		MOVW $0x140c, 0x10(SP)		
  0x41a1d6		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x41a1df		e86caf0000		CALL runtime.gopark(SB)		
		for sweepone() != ^uintptr(0) {
  0x41a1e4		eb80			JMP 0x41a166		
			unlock(&sweep.lock)
  0x41a1e6		488d0573790a00		LEAQ runtime.sweep(SB), AX	
  0x41a1ed		48890424		MOVQ AX, 0(SP)			
  0x41a1f1		e89ae6feff		CALL runtime.unlock(SB)		
			continue
  0x41a1f6		e96bffffff		JMP 0x41a166		
	sweep.g = getg()
  0x41a1fb		488d3d66790a00		LEAQ runtime.sweep+8(SB), DI	
  0x41a202		e879f40200		CALL runtime.gcWriteBarrier(SB)	
  0x41a207		e9e2feffff		JMP 0x41a0ee			
func bgsweep(c chan int) {
  0x41a20c		e86fd60200		CALL runtime.morestack_noctxt(SB)	
  0x41a211		e99afeffff		JMP runtime.bgsweep(SB)			

TEXT runtime.sweepone(SB) /usr/local/go/src/runtime/mgcsweep.go
func sweepone() uintptr {
  0x41a220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a229		483b6110		CMPQ 0x10(CX), SP	
  0x41a22d		0f86c0030000		JBE 0x41a5f3		
  0x41a233		4883ec60		SUBQ $0x60, SP		
  0x41a237		48896c2458		MOVQ BP, 0x58(SP)	
  0x41a23c		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x41a241		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x41a24a		488b5130		MOVQ 0x30(CX), DX	
	sweepRatio := mheap_.sweepPagesPerByte // For debugging
  0x41a24e		f20f1005a2c40a00	MOVSD_XMM runtime.mheap_+184(SB), X0	
	_g_.m.locks++
  0x41a256		ff8208010000		INCL 0x108(DX)		
	if atomic.Load(&mheap_.sweepdone) != 0 {
  0x41a25c		8b15fac30a00		MOVL runtime.mheap_+28(SB), DX	
  0x41a262		85d2			TESTL DX, DX			
  0x41a264		0f85bc020000		JNE 0x41a526			
	atomic.Xadd(&mheap_.sweepers, +1)
  0x41a26a		ba01000000		MOVL $0x1, DX			
  0x41a26f		488d1deac30a00		LEAQ runtime.mheap_+32(SB), BX	
  0x41a276		f00fc113		LOCK XADDL DX, 0(BX)		
	sg := mheap_.sweepgen
  0x41a27a		8b15d8c30a00		MOVL runtime.mheap_+24(SB), DX	
	for {
  0x41a280		eb02			JMP 0x41a284		
		s = mheap_.sweepSpans[1-sg/2%2].pop()
  0x41a282		89f2			MOVL SI, DX		
  0x41a284		89d6			MOVL DX, SI		
  0x41a286		d1ea			SHRL $0x1, DX		
  0x41a288		83e201			ANDL $0x1, DX		
  0x41a28b		ffca			DECL DX			
  0x41a28d		f7da			NEGL DX			
  0x41a28f		4883fa02		CMPQ $0x2, DX		
  0x41a293		0f8353030000		JAE 0x41a5ec		
  0x41a299		488d1492		LEAQ 0(DX)(DX*4), DX	
  0x41a29d		90			NOPL			
	cursor := atomic.Xadd(&b.index, -1)
  0x41a29e		488d3ddbc30a00		LEAQ runtime.mheap_+64(SB), DI	
  0x41a2a5		4c8d04d7		LEAQ 0(DI)(DX*8), R8		
  0x41a2a9		4d8d4020		LEAQ 0x20(R8), R8		
  0x41a2ad		41b9ffffffff		MOVL $-0x1, R9			
  0x41a2b3		f0450fc108		LOCK XADDL R9, 0(R8)		
  0x41a2b8		41ffc9			DECL R9				
	if int32(cursor) < 0 {
  0x41a2bb		4585c9			TESTL R9, R9		
  0x41a2be		0f8d37020000		JGE 0x41a4fb		
		atomic.Xadd(&b.index, +1)
  0x41a2c4		ba01000000		MOVL $0x1, DX		
  0x41a2c9		f0410fc110		LOCK XADDL DX, 0(R8)	
  0x41a2ce		31c0			XORL AX, AX		
		if s == nil {
  0x41a2d0		4885c0			TESTQ AX, AX		
  0x41a2d3		0f840c020000		JE 0x41a4e5		
		if s.state != mSpanInUse {
  0x41a2d9		0fb65063		MOVZX 0x63(AX), DX	
  0x41a2dd		80fa01			CMPL $0x1, DL		
  0x41a2e0		7415			JE 0x41a2f7		
			if !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x41a2e2		8b7858			MOVL 0x58(AX), DI	
  0x41a2e5		39f7			CMPL SI, DI		
  0x41a2e7		7499			JE 0x41a282		
  0x41a2e9		448d4603		LEAL 0x3(SI), R8	
  0x41a2ed		4139f8			CMPL DI, R8		
  0x41a2f0		7490			JE 0x41a282		
  0x41a2f2		e94c020000		JMP 0x41a543		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a2f7		8d56fe			LEAL -0x2(SI), DX	
  0x41a2fa		395058			CMPL DX, 0x58(AX)	
  0x41a2fd		0f85d8010000		JNE 0x41a4db		
  0x41a303		8d7eff			LEAL -0x1(SI), DI	
		s = mheap_.sweepSpans[1-sg/2%2].pop()
  0x41a306		4989c0			MOVQ AX, R8		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a309		89d0			MOVL DX, AX			
  0x41a30b		f0410fb17858		LOCK CMPXCHGL DI, 0x58(R8)	
  0x41a311		0f94c2			SETE DL				
  0x41a314		84d2			TESTL DL, DL			
  0x41a316		0f8466ffffff		JE 0x41a282			
		if s == nil {
  0x41a31c		4d85c0			TESTQ R8, R8		
	_g_ := getg()
  0x41a31f		48894c2450		MOVQ CX, 0x50(SP)	
	sweepRatio := mheap_.sweepPagesPerByte // For debugging
  0x41a324		f20f11442428		MOVSD_XMM X0, 0x28(SP)	
	if s != nil {
  0x41a32a		0f855b010000		JNE 0x41a48b		
  0x41a330		48c7c0ffffffff		MOVQ $-0x1, AX		
	if atomic.Xadd(&mheap_.sweepers, -1) == 0 && atomic.Load(&mheap_.sweepdone) != 0 {
  0x41a337		baffffffff		MOVL $-0x1, DX			
  0x41a33c		f00fc113		LOCK XADDL DX, 0(BX)		
  0x41a340		ffca			DECL DX				
  0x41a342		85d2			TESTL DX, DX			
  0x41a344		0f853a010000		JNE 0x41a484			
  0x41a34a		8b150cc30a00		MOVL runtime.mheap_+28(SB), DX	
  0x41a350		85d2			TESTL DX, DX			
  0x41a352		0f95c2			SETNE DL			
  0x41a355		84d2			TESTL DL, DL			
  0x41a357		7409			JE 0x41a362			
		if debug.gcpacertrace > 0 {
  0x41a359		833d942b0c0000		CMPL $0x0, runtime.debug+20(SB)	
  0x41a360		7f19			JG 0x41a37b			
	_g_.m.locks--
  0x41a362		488b4930		MOVQ 0x30(CX), CX	
  0x41a366		ff8908010000		DECL 0x108(CX)		
	return npages
  0x41a36c		4889442468		MOVQ AX, 0x68(SP)	
  0x41a371		488b6c2458		MOVQ 0x58(SP), BP	
  0x41a376		4883c460		ADDQ $0x60, SP		
  0x41a37a		c3			RET			
  0x41a37b		4889442430		MOVQ AX, 0x30(SP)	
			print("pacer: sweep done at heap size ", memstats.heap_live>>20, "MB; allocated ", (memstats.heap_live-mheap_.sweepHeapLiveBasis)>>20, "MB during sweep; swept ", mheap_.pagesSwept, " pages at ", sweepRatio, " pages/byte\n")
  0x41a380		488b0519500c00		MOVQ runtime.memstats+5952(SB), AX	
  0x41a387		4889442448		MOVQ AX, 0x48(SP)			
  0x41a38c		488b0d5dc30a00		MOVQ runtime.mheap_+176(SB), CX		
  0x41a393		48894c2440		MOVQ CX, 0x40(SP)			
  0x41a398		488b1541c30a00		MOVQ runtime.mheap_+160(SB), DX		
  0x41a39f		4889542438		MOVQ DX, 0x38(SP)			
  0x41a3a4		e8179b0000		CALL runtime.printlock(SB)		
  0x41a3a9		488d05457a0500		LEAQ 0x57a45(IP), AX			
  0x41a3b0		48890424		MOVQ AX, 0(SP)				
  0x41a3b4		48c74424081f000000	MOVQ $0x1f, 0x8(SP)			
  0x41a3bd		e82ea40000		CALL runtime.printstring(SB)		
  0x41a3c2		488b442448		MOVQ 0x48(SP), AX			
  0x41a3c7		48c1e814		SHRQ $0x14, AX				
  0x41a3cb		48890424		MOVQ AX, 0(SP)				
  0x41a3cf		e86ca10000		CALL runtime.printuint(SB)		
  0x41a3d4		488d058b590500		LEAQ 0x5598b(IP), AX			
  0x41a3db		48890424		MOVQ AX, 0(SP)				
  0x41a3df		48c74424080e000000	MOVQ $0xe, 0x8(SP)			
  0x41a3e8		e803a40000		CALL runtime.printstring(SB)		
  0x41a3ed		488b442448		MOVQ 0x48(SP), AX			
  0x41a3f2		488b4c2440		MOVQ 0x40(SP), CX			
  0x41a3f7		4829c8			SUBQ CX, AX				
  0x41a3fa		48c1e814		SHRQ $0x14, AX				
  0x41a3fe		48890424		MOVQ AX, 0(SP)				
  0x41a402		e839a10000		CALL runtime.printuint(SB)		
  0x41a407		488d0570670500		LEAQ 0x56770(IP), AX			
  0x41a40e		48890424		MOVQ AX, 0(SP)				
  0x41a412		48c744240817000000	MOVQ $0x17, 0x8(SP)			
  0x41a41b		e8d0a30000		CALL runtime.printstring(SB)		
  0x41a420		488b442438		MOVQ 0x38(SP), AX			
  0x41a425		48890424		MOVQ AX, 0(SP)				
  0x41a429		e812a10000		CALL runtime.printuint(SB)		
  0x41a42e		488d05e7520500		LEAQ 0x552e7(IP), AX			
  0x41a435		48890424		MOVQ AX, 0(SP)				
  0x41a439		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x41a442		e8a9a30000		CALL runtime.printstring(SB)		
  0x41a447		f20f10442428		MOVSD_XMM 0x28(SP), X0			
  0x41a44d		f20f110424		MOVSD_XMM X0, 0(SP)			
  0x41a452		e8b99d0000		CALL runtime.printfloat(SB)		
  0x41a457		488d0583550500		LEAQ 0x55583(IP), AX			
  0x41a45e		48890424		MOVQ AX, 0(SP)				
  0x41a462		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x41a46b		e880a30000		CALL runtime.printstring(SB)		
  0x41a470		e8cb9a0000		CALL runtime.printunlock(SB)		
	return npages
  0x41a475		488b442430		MOVQ 0x30(SP), AX	
	_g_.m.locks--
  0x41a47a		488b4c2450		MOVQ 0x50(SP), CX	
			print("pacer: sweep done at heap size ", memstats.heap_live>>20, "MB; allocated ", (memstats.heap_live-mheap_.sweepHeapLiveBasis)>>20, "MB during sweep; swept ", mheap_.pagesSwept, " pages at ", sweepRatio, " pages/byte\n")
  0x41a47f		e9defeffff		JMP 0x41a362		
  0x41a484		31d2			XORL DX, DX		
	if atomic.Xadd(&mheap_.sweepers, -1) == 0 && atomic.Load(&mheap_.sweepdone) != 0 {
  0x41a486		e9cafeffff		JMP 0x41a355		
		npages = s.npages
  0x41a48b		498b4020		MOVQ 0x20(R8), AX	
  0x41a48f		4889442430		MOVQ AX, 0x30(SP)	
		if s.sweep(false) {
  0x41a494		4c890424		MOVQ R8, 0(SP)			
  0x41a498		c644240800		MOVB $0x0, 0x8(SP)		
  0x41a49d		e85e020000		CALL runtime.(*mspan).sweep(SB)	
  0x41a4a2		807c241000		CMPB $0x0, 0x10(SP)		
  0x41a4a7		742e			JE 0x41a4d7			
			atomic.Xadduintptr(&mheap_.reclaimCredit, npages)
  0x41a4a9		488b442430		MOVQ 0x30(SP), AX		
  0x41a4ae		488d0d53c20a00		LEAQ runtime.mheap_+200(SB), CX	
  0x41a4b5		4889c2			MOVQ AX, DX			
  0x41a4b8		f0480fc101		LOCK XADDQ AX, 0(CX)		
	_g_.m.locks--
  0x41a4bd		488b4c2450		MOVQ 0x50(SP), CX	
	atomic.Xadd(&mheap_.sweepers, +1)
  0x41a4c2		488d1d97c10a00		LEAQ runtime.mheap_+32(SB), BX	
			print("pacer: sweep done at heap size ", memstats.heap_live>>20, "MB; allocated ", (memstats.heap_live-mheap_.sweepHeapLiveBasis)>>20, "MB during sweep; swept ", mheap_.pagesSwept, " pages at ", sweepRatio, " pages/byte\n")
  0x41a4c9		f20f10442428		MOVSD_XMM 0x28(SP), X0	
	return npages
  0x41a4cf		4889d0			MOVQ DX, AX		
	if atomic.Xadd(&mheap_.sweepers, -1) == 0 && atomic.Load(&mheap_.sweepdone) != 0 {
  0x41a4d2		e960feffff		JMP 0x41a337		
  0x41a4d7		31d2			XORL DX, DX		
  0x41a4d9		ebe2			JMP 0x41a4bd		
		if s == nil {
  0x41a4db		4989c0			MOVQ AX, R8		
  0x41a4de		31d2			XORL DX, DX		
		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a4e0		e92ffeffff		JMP 0x41a314		
			atomic.Store(&mheap_.sweepdone, 1)
  0x41a4e5		ba01000000		MOVL $0x1, DX			
  0x41a4ea		488d356bc10a00		LEAQ runtime.mheap_+28(SB), SI	
  0x41a4f1		8716			XCHGL DX, 0(SI)			
		npages = s.npages
  0x41a4f3		4989c0			MOVQ AX, R8		
			break
  0x41a4f6		e924feffff		JMP 0x41a31f		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41a4fb		4589c8			MOVL R9, R8		
  0x41a4fe		41c1e909		SHRL $0x9, R9		
	blockp := (**gcSweepBlock)(add(b.spine, sys.PtrSize*uintptr(top)))
  0x41a502		488b54d708		MOVQ 0x8(DI)(DX*8), DX	
	block := *blockp
  0x41a507		4a8b14ca		MOVQ 0(DX)(R9*8), DX	
	s := block.spans[bottom]
  0x41a50b		8402			TESTB AL, 0(DX)		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41a50d		4181e0ff010000		ANDL $0x1ff, R8		
	blockp := (**gcSweepBlock)(add(b.spine, sys.PtrSize*uintptr(top)))
  0x41a514		90			NOPL			
	s := block.spans[bottom]
  0x41a515		4a8b04c2		MOVQ 0(DX)(R8*8), AX	
	block.spans[bottom] = nil
  0x41a519		4ac704c200000000	MOVQ $0x0, 0(DX)(R8*8)	
		s = mheap_.sweepSpans[1-sg/2%2].pop()
  0x41a521		e9aafdffff		JMP 0x41a2d0		
		_g_.m.locks--
  0x41a526		488b4130		MOVQ 0x30(CX), AX	
  0x41a52a		ff8808010000		DECL 0x108(AX)		
		return ^uintptr(0)
  0x41a530		48c7442468ffffffff	MOVQ $-0x1, 0x68(SP)	
  0x41a539		488b6c2458		MOVQ 0x58(SP), BP	
  0x41a53e		4883c460		ADDQ $0x60, SP		
  0x41a542		c3			RET			
	sg := mheap_.sweepgen
  0x41a543		89742424		MOVL SI, 0x24(SP)	
		if s.state != mSpanInUse {
  0x41a547		8854241f		MOVB DL, 0x1f(SP)	
			if !(s.sweepgen == sg || s.sweepgen == sg+3) {
  0x41a54b		897c2420		MOVL DI, 0x20(SP)	
				print("runtime: bad span s.state=", s.state, " s.sweepgen=", s.sweepgen, " sweepgen=", sg, "\n")
  0x41a54f		e86c990000		CALL runtime.printlock(SB)	
  0x41a554		488d056d6d0500		LEAQ 0x56d6d(IP), AX		
  0x41a55b		48890424		MOVQ AX, 0(SP)			
  0x41a55f		48c74424081a000000	MOVQ $0x1a, 0x8(SP)		
  0x41a568		e883a20000		CALL runtime.printstring(SB)	
  0x41a56d		0fb644241f		MOVZX 0x1f(SP), AX		
  0x41a572		48890424		MOVQ AX, 0(SP)			
  0x41a576		e8c59f0000		CALL runtime.printuint(SB)	
  0x41a57b		488d0583540500		LEAQ 0x55483(IP), AX		
  0x41a582		48890424		MOVQ AX, 0(SP)			
  0x41a586		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x41a58f		e85ca20000		CALL runtime.printstring(SB)	
  0x41a594		8b442420		MOVL 0x20(SP), AX		
  0x41a598		48890424		MOVQ AX, 0(SP)			
  0x41a59c		e89f9f0000		CALL runtime.printuint(SB)	
  0x41a5a1		488d05c4510500		LEAQ 0x551c4(IP), AX		
  0x41a5a8		48890424		MOVQ AX, 0(SP)			
  0x41a5ac		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41a5b5		e836a20000		CALL runtime.printstring(SB)	
  0x41a5ba		8b442424		MOVL 0x24(SP), AX		
  0x41a5be		48890424		MOVQ AX, 0(SP)			
  0x41a5c2		e8799f0000		CALL runtime.printuint(SB)	
  0x41a5c7		e8849b0000		CALL runtime.printnl(SB)	
  0x41a5cc		e86f990000		CALL runtime.printunlock(SB)	
				throw("non in-use span in unswept list")
  0x41a5d1		488d05fe770500		LEAQ 0x577fe(IP), AX	
  0x41a5d8		48890424		MOVQ AX, 0(SP)		
  0x41a5dc		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41a5e5		e8968e0000		CALL runtime.throw(SB)	
  0x41a5ea		0f0b			UD2			
		s = mheap_.sweepSpans[1-sg/2%2].pop()
  0x41a5ec		e82f790000		CALL runtime.panicindex(SB)	
  0x41a5f1		0f0b			UD2				
func sweepone() uintptr {
  0x41a5f3		e888d20200		CALL runtime.morestack_noctxt(SB)	
  0x41a5f8		e923fcffff		JMP runtime.sweepone(SB)		

TEXT runtime.(*mspan).ensureSwept(SB) /usr/local/go/src/runtime/mgcsweep.go
func (s *mspan) ensureSwept() {
  0x41a600		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a609		483b6110		CMPQ 0x10(CX), SP	
  0x41a60d		0f86d5000000		JBE 0x41a6e8		
  0x41a613		4883ec28		SUBQ $0x28, SP		
  0x41a617		48896c2420		MOVQ BP, 0x20(SP)	
  0x41a61c		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x41a621		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if _g_.m.locks == 0 && _g_.m.mallocing == 0 && _g_ != _g_.m.g0 {
  0x41a62a		488b5130		MOVQ 0x30(CX), DX	
  0x41a62e		83ba0801000000		CMPL $0x0, 0x108(DX)	
  0x41a635		7512			JNE 0x41a649		
  0x41a637		83baf000000000		CMPL $0x0, 0xf0(DX)	
  0x41a63e		7509			JNE 0x41a649		
  0x41a640		48390a			CMPQ CX, 0(DX)		
  0x41a643		0f8584000000		JNE 0x41a6cd		
	sg := mheap_.sweepgen
  0x41a649		8b0d09c00a00		MOVL runtime.mheap_+24(SB), CX	
	spangen := atomic.Load(&s.sweepgen)
  0x41a64f		488b542430		MOVQ 0x30(SP), DX	
  0x41a654		8b5a58			MOVL 0x58(DX), BX	
	if spangen == sg || spangen == sg+3 {
  0x41a657		39cb			CMPL CX, BX		
  0x41a659		7468			JE 0x41a6c3		
  0x41a65b		8d7103			LEAL 0x3(CX), SI	
  0x41a65e		39f3			CMPL SI, BX		
  0x41a660		7461			JE 0x41a6c3		
	if atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41a662		8d41fe			LEAL -0x2(CX), AX		
  0x41a665		8d59ff			LEAL -0x1(CX), BX		
  0x41a668		f00fb15a58		LOCK CMPXCHGL BX, 0x58(DX)	
  0x41a66d		0f94c3			SETE BL				
  0x41a670		84db			TESTL BL, BL			
  0x41a672		7537			JNE 0x41a6ab			
	sg := mheap_.sweepgen
  0x41a674		894c2418		MOVL CX, 0x18(SP)	
	if spangen == sg || spangen == sg+3 {
  0x41a678		8974241c		MOVL SI, 0x1c(SP)	
		spangen := atomic.Load(&s.sweepgen)
  0x41a67c		eb18			JMP 0x41a696		
		osyield()
  0x41a67e		e86d0f0300		CALL runtime.osyield(SB)	
		spangen := atomic.Load(&s.sweepgen)
  0x41a683		8b442418		MOVL 0x18(SP), AX	
  0x41a687		8b4c241c		MOVL 0x1c(SP), CX	
  0x41a68b		488b542430		MOVQ 0x30(SP), DX	
		if spangen == sg || spangen == sg+3 {
  0x41a690		89c1			MOVL AX, CX		
  0x41a692		8b74241c		MOVL 0x1c(SP), SI	
		spangen := atomic.Load(&s.sweepgen)
  0x41a696		8b4258			MOVL 0x58(DX), AX	
		if spangen == sg || spangen == sg+3 {
  0x41a699		39c8			CMPL CX, AX		
  0x41a69b		7404			JE 0x41a6a1		
  0x41a69d		39f0			CMPL SI, AX		
  0x41a69f		75dd			JNE 0x41a67e		
  0x41a6a1		488b6c2420		MOVQ 0x20(SP), BP	
  0x41a6a6		4883c428		ADDQ $0x28, SP		
  0x41a6aa		c3			RET			
		s.sweep(false)
  0x41a6ab		48891424		MOVQ DX, 0(SP)			
  0x41a6af		c644240800		MOVB $0x0, 0x8(SP)		
  0x41a6b4		e847000000		CALL runtime.(*mspan).sweep(SB)	
		return
  0x41a6b9		488b6c2420		MOVQ 0x20(SP), BP	
  0x41a6be		4883c428		ADDQ $0x28, SP		
  0x41a6c2		c3			RET			
		return
  0x41a6c3		488b6c2420		MOVQ 0x20(SP), BP	
  0x41a6c8		4883c428		ADDQ $0x28, SP		
  0x41a6cc		c3			RET			
		throw("mspan.ensureSwept: m is not locked")
  0x41a6cd		488d05767c0500		LEAQ 0x57c76(IP), AX	
  0x41a6d4		48890424		MOVQ AX, 0(SP)		
  0x41a6d8		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x41a6e1		e89a8d0000		CALL runtime.throw(SB)	
  0x41a6e6		0f0b			UD2			
func (s *mspan) ensureSwept() {
  0x41a6e8		e893d10200		CALL runtime.morestack_noctxt(SB)	
  0x41a6ed		e90effffff		JMP runtime.(*mspan).ensureSwept(SB)	

TEXT runtime.(*mspan).sweep(SB) /usr/local/go/src/runtime/mgcsweep.go
func (s *mspan) sweep(preserve bool) bool {
  0x41a700		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41a709		488d4424a8		LEAQ -0x58(SP), AX	
  0x41a70e		483b4110		CMPQ 0x10(CX), AX	
  0x41a712		0f8684090000		JBE 0x41b09c		
  0x41a718		4881ecd8000000		SUBQ $0xd8, SP		
  0x41a71f		4889ac24d0000000	MOVQ BP, 0xd0(SP)	
  0x41a727		488dac24d0000000	LEAQ 0xd0(SP), BP	
	_g_ := getg()
  0x41a72f		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	if _g_.m.locks == 0 && _g_.m.mallocing == 0 && _g_ != _g_.m.g0 {
  0x41a738		488b5a30		MOVQ 0x30(DX), BX	
  0x41a73c		83bb0801000000		CMPL $0x0, 0x108(BX)	
  0x41a743		7512			JNE 0x41a757		
  0x41a745		83bbf000000000		CMPL $0x0, 0xf0(BX)	
  0x41a74c		7509			JNE 0x41a757		
  0x41a74e		483913			CMPQ DX, 0(BX)		
  0x41a751		0f852a090000		JNE 0x41b081		
	sweepgen := mheap_.sweepgen
  0x41a757		8b1dfbbe0a00		MOVL runtime.mheap_+24(SB), BX	
  0x41a75d		895c2440		MOVL BX, 0x40(SP)		
	if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41a761		488bb424e0000000	MOVQ 0xe0(SP), SI	
  0x41a769		0fb67e63		MOVZX 0x63(SI), DI	
  0x41a76d		40887c243b		MOVB DI, 0x3b(SP)	
  0x41a772		4080ff01		CMPL $0x1, DI		
  0x41a776		0f855f080000		JNE 0x41afdb		
  0x41a77c		448d43ff		LEAL -0x1(BX), R8	
  0x41a780		44394658		CMPL R8, 0x58(SI)	
  0x41a784		0f8551080000		JNE 0x41afdb		
  0x41a78a		4489442444		MOVL R8, 0x44(SP)	
	if trace.enabled {
  0x41a78f		803d3a240b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41a796		0f856d060000		JNE 0x41ae09			
	atomic.Xadd64(&mheap_.pagesSwept, int64(s.npages))
  0x41a79c		488b7e20		MOVQ 0x20(SI), DI		
  0x41a7a0		4c8d0d39bf0a00		LEAQ runtime.mheap_+160(SB), R9	
  0x41a7a7		f0490fc139		LOCK XADDQ DI, 0(R9)		
	c := _g_.m.mcache
  0x41a7ac		488b5230		MOVQ 0x30(DX), DX	
	spc := s.spanclass
  0x41a7b0		0fb67e62		MOVZX 0x62(SI), DI	
  0x41a7b4		40887c2436		MOVB DI, 0x36(SP)	
	size := s.elemsize
  0x41a7b9		4c8b4e68		MOVQ 0x68(SI), R9	
  0x41a7bd		4c894c2450		MOVQ R9, 0x50(SP)	
	c := _g_.m.mcache
  0x41a7c2		488b9260010000		MOVQ 0x160(DX), DX	
  0x41a7c9		4889942490000000	MOVQ DX, 0x90(SP)	
	specialp := &s.specials
  0x41a7d1		4c8d9688000000		LEAQ 0x88(SI), R10	
	special := *specialp
  0x41a7d8		4c8b9e88000000		MOVQ 0x88(SI), R11	
	for special != nil {
  0x41a7df		eb09			JMP 0x41a7ea		
					*specialp = special
  0x41a7e1		4d89da			MOVQ R11, R10		
	for special != nil {
  0x41a7e4		4989d3			MOVQ DX, R11		
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41a7e7		4c89ea			MOVQ R13, DX		
	for special != nil {
  0x41a7ea		4d85db			TESTQ R11, R11		
  0x41a7ed		0f844d010000		JE 0x41a940		
		objIndex := uintptr(special.offset) / size
  0x41a7f3		410fb74308		MOVZX 0x8(R11), AX	
  0x41a7f8		4d85c9			TESTQ R9, R9		
  0x41a7fb		0f84d3070000		JE 0x41afd4		
	c := _g_.m.mcache
  0x41a801		4889d1			MOVQ DX, CX		
		objIndex := uintptr(special.offset) / size
  0x41a804		31d2			XORL DX, DX		
  0x41a806		49f7f1			DIVQ R9			
		p := s.base() + objIndex*size
  0x41a809		90			NOPL			
  0x41a80a		4889c2			MOVQ AX, DX		
  0x41a80d		490fafc1		IMULQ R9, AX		
		mbits := s.markBitsForIndex(objIndex)
  0x41a811		90			NOPL			
		if !mbits.isMarked() {
  0x41a812		90			NOPL			
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x41a813		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x41a814		90			NOPL			
  0x41a815		4989d4			MOVQ DX, R12		
  0x41a818		48c1ea03		SHRQ $0x3, DX		
  0x41a81c		4983e407		ANDQ $0x7, R12		
	c := _g_.m.mcache
  0x41a820		4989cd			MOVQ CX, R13		
	return b.bytep(n / 8), 1 << (n % 8)
  0x41a823		4c89e1			MOVQ R12, CX		
  0x41a826		41be01000000		MOVL $0x1, R14		
  0x41a82c		41d3e6			SHLL CL, R14		
	return addb((*uint8)(b), n)
  0x41a82f		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x41a830		48035650		ADDQ 0x50(SI), DX	
	return *m.bytep&m.mask != 0
  0x41a834		440fb63a		MOVZX 0(DX), R15	
  0x41a838		4584f7			TESTL R14, R15		
		if !mbits.isMarked() {
  0x41a83b		7405			JE 0x41a842		
			special = *specialp
  0x41a83d		498b13			MOVQ 0(R11), DX		
  0x41a840		eb9f			JMP 0x41a7e1		
			endOffset := p - s.base() + size
  0x41a842		90			NOPL			
  0x41a843		4e8d3408		LEAQ 0(AX)(R9*1), R14	
	for special != nil {
  0x41a847		4c89d8			MOVQ R11, AX		
			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
  0x41a84a		eb0b			JMP 0x41a857		
  0x41a84c		4d8b1b			MOVQ 0(R11), R11	
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41a84f		4c8bac2490000000	MOVQ 0x90(SP), R13	
			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
  0x41a857		4d85db			TESTQ R11, R11		
  0x41a85a		0f84d9000000		JE 0x41a939		
  0x41a860		450fb76b08		MOVZX 0x8(R11), R13	
  0x41a865		4d39f5			CMPQ R14, R13		
  0x41a868		0f83c4000000		JAE 0x41a932		
				if tmp.kind == _KindSpecialFinalizer {
  0x41a86e		41807b0a01		CMPB $0x1, 0xa(R11)	
  0x41a873		75d7			JNE 0x41a84c		
					mbits.setMarkedNonAtomic()
  0x41a875		90			NOPL			
	*m.bytep |= m.mask
  0x41a876		410fabcf		BTSL CX, R15		
  0x41a87a		44883a			MOVB R15, 0(DX)		
  0x41a87d		b901000000		MOVL $0x1, CX		
			endOffset := p - s.base() + size
  0x41a882		4c89742460		MOVQ R14, 0x60(SP)	
				if special.kind == _KindSpecialFinalizer || !hasFin {
  0x41a887		884c2438		MOVB CL, 0x38(SP)	
			for special != nil && uintptr(special.offset) < endOffset {
  0x41a88b		eb06			JMP 0x41a893		
					*specialp = special
  0x41a88d		4989c2			MOVQ AX, R10		
			for special != nil && uintptr(special.offset) < endOffset {
  0x41a890		4889d0			MOVQ DX, AX		
  0x41a893		4885c0			TESTQ AX, AX		
  0x41a896		0f8483000000		JE 0x41a91f		
  0x41a89c		0fb75008		MOVZX 0x8(AX), DX	
  0x41a8a0		4c39f2			CMPQ R14, DX		
  0x41a8a3		737a			JAE 0x41a91f		
				p := s.base() + uintptr(special.offset)
  0x41a8a5		90			NOPL			
	return s.startAddr
  0x41a8a6		4c8b5e18		MOVQ 0x18(SI), R11	
				p := s.base() + uintptr(special.offset)
  0x41a8aa		4c01da			ADDQ R11, DX		
				if special.kind == _KindSpecialFinalizer || !hasFin {
  0x41a8ad		80780a01		CMPB $0x1, 0xa(AX)	
  0x41a8b1		7409			JE 0x41a8bc		
  0x41a8b3		84c9			TESTL CL, CL		
  0x41a8b5		7405			JE 0x41a8bc		
					special = *specialp
  0x41a8b7		488b10			MOVQ 0(AX), DX		
  0x41a8ba		ebd1			JMP 0x41a88d		
					*specialp = special
  0x41a8bc		4c89942480000000	MOVQ R10, 0x80(SP)	
					special = special.next
  0x41a8c4		488b08			MOVQ 0(AX), CX		
  0x41a8c7		48898c2488000000	MOVQ CX, 0x88(SP)	
					*specialp = special
  0x41a8cf		49890a			MOVQ CX, 0(R10)		
					freespecial(y, unsafe.Pointer(p), size)
  0x41a8d2		48890424		MOVQ AX, 0(SP)			
  0x41a8d6		4889542408		MOVQ DX, 0x8(SP)		
  0x41a8db		4c894c2410		MOVQ R9, 0x10(SP)		
  0x41a8e0		e87b460000		CALL runtime.freespecial(SB)	
				if special.kind == _KindSpecialFinalizer || !hasFin {
  0x41a8e5		0fb64c2438		MOVZX 0x38(SP), CX	
		atomic.Store(&s.sweepgen, sweepgen)
  0x41a8ea		8b5c2440		MOVL 0x40(SP), BX	
	return s.startAddr
  0x41a8ee		488bb424e0000000	MOVQ 0xe0(SP), SI	
	return int8(sc >> 1)
  0x41a8f6		0fb67c2436		MOVZX 0x36(SP), DI	
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41a8fb		448b442444		MOVL 0x44(SP), R8	
					freespecial(y, unsafe.Pointer(p), size)
  0x41a900		4c8b4c2450		MOVQ 0x50(SP), R9	
			for special != nil && uintptr(special.offset) < endOffset {
  0x41a905		4c8b742460		MOVQ 0x60(SP), R14	
  0x41a90a		488b942488000000	MOVQ 0x88(SP), DX	
					*specialp = special
  0x41a912		488b842480000000	MOVQ 0x80(SP), AX	
					freespecial(y, unsafe.Pointer(p), size)
  0x41a91a		e96effffff		JMP 0x41a88d		
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41a91f		4c8bac2490000000	MOVQ 0x90(SP), R13	
	for special != nil {
  0x41a927		4889c2			MOVQ AX, DX		
					*specialp = special
  0x41a92a		4d89d3			MOVQ R10, R11		
	for special != nil {
  0x41a92d		e9affeffff		JMP 0x41a7e1		
  0x41a932		31c9			XORL CX, CX		
			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
  0x41a934		e949ffffff		JMP 0x41a882		
  0x41a939		31c9			XORL CX, CX		
  0x41a93b		e942ffffff		JMP 0x41a882		
	if debug.allocfreetrace != 0 || debug.clobberfree != 0 || raceenabled || msanenabled {
  0x41a940		833d99250c0000		CMPL $0x0, runtime.debug(SB)	
  0x41a947		0f84aa040000		JE 0x41adf7			
		mbits := s.markBitsForBase()
  0x41a94d		90			NOPL			
	return markBits{(*uint8)(s.gcmarkBits), uint8(1), 0}
  0x41a94e		488b4650		MOVQ 0x50(SI), AX	
		mbits := s.markBitsForBase()
  0x41a952		48898424a0000000		MOVQ AX, 0xa0(SP)	
  0x41a95a		c68424a800000001		MOVB $0x1, 0xa8(SP)	
  0x41a962		48c78424b000000000000000	MOVQ $0x0, 0xb0(SP)	
		abits := s.allocBitsForIndex(0)
  0x41a96e		90			NOPL			
	bytep, mask := s.allocBits.bitp(allocBitIndex)
  0x41a96f		488b4648		MOVQ 0x48(SI), AX	
  0x41a973		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x41a974		90			NOPL			
	return addb((*uint8)(b), n)
  0x41a975		90			NOPL			
		abits := s.allocBitsForIndex(0)
  0x41a976		48898424b8000000		MOVQ AX, 0xb8(SP)	
  0x41a97e		c68424c000000001		MOVB $0x1, 0xc0(SP)	
  0x41a986		48c78424c800000000000000	MOVQ $0x0, 0xc8(SP)	
  0x41a992		31c0				XORL AX, AX		
		for i := uintptr(0); i < s.nelems; i++ {
  0x41a994		eb0b			JMP 0x41a9a1		
	m.index++
  0x41a996		48ff8424c8000000	INCQ 0xc8(SP)		
		for i := uintptr(0); i < s.nelems; i++ {
  0x41a99e		48ffc0			INCQ AX			
  0x41a9a1		48394638		CMPQ AX, 0x38(SI)	
  0x41a9a5		0f865a010000		JBE 0x41ab05		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41a9ab		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x41a9b3		90			NOPL			
  0x41a9b4		440fb69424a8000000	MOVZX 0xa8(SP), R10	
	return *m.bytep&m.mask != 0
  0x41a9bd		0fb609			MOVZX 0(CX), CX		
  0x41a9c0		4484d1			TESTL R10, CL		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41a9c3		745c			JE 0x41aa21		
			mbits.advance()
  0x41a9c5		90			NOPL			
	if m.mask == 1<<7 {
  0x41a9c6		0fb68c24a8000000	MOVZX 0xa8(SP), CX	
  0x41a9ce		80f980			CMPL $0x80, CL		
  0x41a9d1		7543			JNE 0x41aa16		
		m.bytep = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.bytep)) + 1))
  0x41a9d3		48ff8424a0000000	INCQ 0xa0(SP)		
		m.mask = 1
  0x41a9db		c68424a800000001	MOVB $0x1, 0xa8(SP)	
	m.index++
  0x41a9e3		48ff8424b0000000	INCQ 0xb0(SP)		
			abits.advance()
  0x41a9eb		90			NOPL			
	if m.mask == 1<<7 {
  0x41a9ec		0fb68c24c0000000	MOVZX 0xc0(SP), CX	
  0x41a9f4		80f980			CMPL $0x80, CL		
  0x41a9f7		7512			JNE 0x41aa0b		
		m.bytep = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.bytep)) + 1))
  0x41a9f9		48ff8424b8000000	INCQ 0xb8(SP)		
		m.mask = 1
  0x41aa01		c68424c000000001	MOVB $0x1, 0xc0(SP)	
  0x41aa09		eb8b			JMP 0x41a996		
		m.mask = m.mask << 1
  0x41aa0b		d1e1			SHLL $0x1, CX		
  0x41aa0d		888c24c0000000		MOVB CL, 0xc0(SP)	
  0x41aa14		eb80			JMP 0x41a996		
  0x41aa16		d1e1			SHLL $0x1, CX		
  0x41aa18		888c24a8000000		MOVB CL, 0xa8(SP)	
  0x41aa1f		ebc2			JMP 0x41a9e3		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41aa21		488b4e30		MOVQ 0x30(SI), CX	
  0x41aa25		48398c24c8000000	CMPQ CX, 0xc8(SP)	
  0x41aa2d		0f83b1000000		JAE 0x41aae4		
  0x41aa33		b901000000		MOVL $0x1, CX		
  0x41aa38		84c9			TESTL CL, CL		
  0x41aa3a		7489			JE 0x41a9c5		
		for i := uintptr(0); i < s.nelems; i++ {
  0x41aa3c		4889442458		MOVQ AX, 0x58(SP)	
				x := s.base() + i*s.elemsize
  0x41aa41		90			NOPL			
  0x41aa42		488b4e68		MOVQ 0x68(SI), CX	
  0x41aa46		480fafc8		IMULQ AX, CX		
  0x41aa4a		48034e18		ADDQ 0x18(SI), CX	
				if debug.allocfreetrace != 0 {
  0x41aa4e		833d8b240c0000		CMPL $0x0, runtime.debug(SB)	
  0x41aa55		7548			JNE 0x41aa9f			
				if debug.clobberfree != 0 {
  0x41aa57		833d8a240c0000		CMPL $0x0, runtime.debug+8(SB)	
  0x41aa5e		0f8461ffffff		JE 0x41a9c5			
					clobberfree(unsafe.Pointer(x), size)
  0x41aa64		48890c24		MOVQ CX, 0(SP)			
  0x41aa68		4c894c2408		MOVQ R9, 0x8(SP)		
  0x41aa6d		e89e070000		CALL runtime.clobberfree(SB)	
		for i := uintptr(0); i < s.nelems; i++ {
  0x41aa72		488b442458		MOVQ 0x58(SP), AX	
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41aa77		488b942490000000	MOVQ 0x90(SP), DX	
		atomic.Store(&s.sweepgen, sweepgen)
  0x41aa7f		8b5c2440		MOVL 0x40(SP), BX	
		for i := uintptr(0); i < s.nelems; i++ {
  0x41aa83		488bb424e0000000	MOVQ 0xe0(SP), SI	
	return int8(sc >> 1)
  0x41aa8b		0fb67c2436		MOVZX 0x36(SP), DI	
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41aa90		448b442444		MOVL 0x44(SP), R8	
					tracefree(unsafe.Pointer(x), size)
  0x41aa95		4c8b4c2450		MOVQ 0x50(SP), R9	
					clobberfree(unsafe.Pointer(x), size)
  0x41aa9a		e926ffffff		JMP 0x41a9c5		
				x := s.base() + i*s.elemsize
  0x41aa9f		48894c2448		MOVQ CX, 0x48(SP)	
					tracefree(unsafe.Pointer(x), size)
  0x41aaa4		48890c24		MOVQ CX, 0(SP)			
  0x41aaa8		4c894c2408		MOVQ R9, 0x8(SP)		
  0x41aaad		e8be5a0000		CALL runtime.tracefree(SB)	
		for i := uintptr(0); i < s.nelems; i++ {
  0x41aab2		488b442458		MOVQ 0x58(SP), AX	
					clobberfree(unsafe.Pointer(x), size)
  0x41aab7		488b4c2448		MOVQ 0x48(SP), CX	
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41aabc		488b942490000000	MOVQ 0x90(SP), DX	
		atomic.Store(&s.sweepgen, sweepgen)
  0x41aac4		8b5c2440		MOVL 0x40(SP), BX	
		for i := uintptr(0); i < s.nelems; i++ {
  0x41aac8		488bb424e0000000	MOVQ 0xe0(SP), SI	
	return int8(sc >> 1)
  0x41aad0		0fb67c2436		MOVZX 0x36(SP), DI	
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41aad5		448b442444		MOVL 0x44(SP), R8	
					clobberfree(unsafe.Pointer(x), size)
  0x41aada		4c8b4c2450		MOVQ 0x50(SP), R9	
					tracefree(unsafe.Pointer(x), size)
  0x41aadf		e973ffffff		JMP 0x41aa57		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41aae4		4c8b9424b8000000	MOVQ 0xb8(SP), R10	
  0x41aaec		440fb69c24c0000000	MOVZX 0xc0(SP), R11	
	return *m.bytep&m.mask != 0
  0x41aaf5		450fb612		MOVZX 0(R10), R10	
  0x41aaf9		4584da			TESTL R11, R10		
  0x41aafc		0f95c1			SETNE CL		
			if !mbits.isMarked() && (abits.index < s.freeindex || abits.isMarked()) {
  0x41aaff		90			NOPL			
  0x41ab00		e933ffffff		JMP 0x41aa38		
	nalloc := uint16(s.countAlloc())
  0x41ab05		48893424		MOVQ SI, 0(SP)				
  0x41ab09		e87245ffff		CALL runtime.(*mspan).countAlloc(SB)	
  0x41ab0e		488b442408		MOVQ 0x8(SP), AX			
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x41ab13		90			NOPL			
	return int8(sc >> 1)
  0x41ab14		0fb64c2436		MOVZX 0x36(SP), CX	
  0x41ab19		89ca			MOVL CX, DX		
  0x41ab1b		d0e9			SHRL $0x1, CL		
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x41ab1d		84c9			TESTL CL, CL		
  0x41ab1f		0f85c3020000		JNE 0x41ade8		
  0x41ab25		6685c0			TESTW AX, AX		
  0x41ab28		0f85ba020000		JNE 0x41ade8		
		s.needzero = 1
  0x41ab2e		488b9c24e0000000	MOVQ 0xe0(SP), BX	
  0x41ab36		c6436401		MOVB $0x1, 0x64(BX)	
  0x41ab3a		be01000000		MOVL $0x1, SI		
	nfreed := s.allocCount - nalloc
  0x41ab3f		0fb77b60		MOVZX 0x60(BX), DI	
  0x41ab43		4189f8			MOVL DI, R8		
  0x41ab46		29c7			SUBL AX, DI		
  0x41ab48		66897c243c		MOVW DI, 0x3c(SP)	
	if nalloc > s.allocCount {
  0x41ab4d		664439c0		CMPW R8, AX		
  0x41ab51		0f879d030000		JA 0x41aef4		
	return int8(sc >> 1)
  0x41ab57		884c243a		MOVB CL, 0x3a(SP)	
	if freeToHeap || nfreed == 0 {
  0x41ab5b		4088742439		MOVB SI, 0x39(SP)	
	s.allocCount = nalloc
  0x41ab60		66894360		MOVW AX, 0x60(BX)	
	wasempty := s.nextFreeIndex() == s.nelems
  0x41ab64		48891c24		MOVQ BX, 0(SP)				
  0x41ab68		e8c32dffff		CALL runtime.(*mspan).nextFreeIndex(SB)	
  0x41ab6d		488b8424e0000000	MOVQ 0xe0(SP), AX			
  0x41ab75		488b4838		MOVQ 0x38(AX), CX			
  0x41ab79		48894c2478		MOVQ CX, 0x78(SP)			
  0x41ab7e		488b542408		MOVQ 0x8(SP), DX			
  0x41ab83		4889542470		MOVQ DX, 0x70(SP)			
  0x41ab88		4839ca			CMPQ CX, DX				
	s.freeindex = 0 // reset allocation index to start of span.
  0x41ab8b		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	if trace.enabled {
  0x41ab93		803d36200b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41ab9a		742e			JE 0x41abca			
		getg().m.p.ptr().traceReclaimed += uintptr(nfreed) * s.elemsize
  0x41ab9c		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x41aba5		488b5b30		MOVQ 0x30(BX), BX	
  0x41aba9		488b9bd0000000		MOVQ 0xd0(BX), BX	
  0x41abb0		8403			TESTB AL, 0(BX)		
  0x41abb2		90			NOPL			
  0x41abb3		0fb774243c		MOVZX 0x3c(SP), SI	
  0x41abb8		0fb7fe			MOVZX SI, DI		
  0x41abbb		4c8b4068		MOVQ 0x68(AX), R8	
  0x41abbf		4c0fafc7		IMULQ DI, R8		
  0x41abc3		4c018330120000		ADDQ R8, 0x1230(BX)	
	s.allocBits = s.gcmarkBits
  0x41abca		488b4850		MOVQ 0x50(AX), CX	
  0x41abce		48894848		MOVQ CX, 0x48(AX)	
	s.gcmarkBits = newMarkBits(s.nelems)
  0x41abd2		488b4838		MOVQ 0x38(AX), CX		
  0x41abd6		48890c24		MOVQ CX, 0(SP)			
  0x41abda		e8d1440000		CALL runtime.newMarkBits(SB)	
  0x41abdf		488b442408		MOVQ 0x8(SP), AX		
  0x41abe4		488b8c24e0000000	MOVQ 0xe0(SP), CX		
  0x41abec		48894150		MOVQ AX, 0x50(CX)		
	s.refillAllocCache(0)
  0x41abf0		48890c24		MOVQ CX, 0(SP)					
  0x41abf4		48c744240800000000	MOVQ $0x0, 0x8(SP)				
  0x41abfd		e80e2dffff		CALL runtime.(*mspan).refillAllocCache(SB)	
	if freeToHeap || nfreed == 0 {
  0x41ac02		0fb6442439		MOVZX 0x39(SP), AX	
  0x41ac07		84c0			TESTL AL, AL		
  0x41ac09		0f84ba010000		JE 0x41adc9		
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41ac0f		488b8c24e0000000	MOVQ 0xe0(SP), CX	
  0x41ac17		0fb65163		MOVZX 0x63(CX), DX	
  0x41ac1b		8854243b		MOVB DL, 0x3b(SP)	
  0x41ac1f		80fa01			CMPL $0x1, DL		
  0x41ac22		0f8526020000		JNE 0x41ae4e		
  0x41ac28		8b5c2444		MOVL 0x44(SP), BX	
  0x41ac2c		395958			CMPL BX, 0x58(CX)	
  0x41ac2f		0f8519020000		JNE 0x41ae4e		
		atomic.Store(&s.sweepgen, sweepgen)
  0x41ac35		8b542440		MOVL 0x40(SP), DX	
  0x41ac39		89d3			MOVL DX, BX		
  0x41ac3b		875158			XCHGL DX, 0x58(CX)	
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x41ac3e		0fb754243c		MOVZX 0x3c(SP), DX	
  0x41ac43		6685d2			TESTW DX, DX		
  0x41ac46		0f8676010000		JBE 0x41adc2		
  0x41ac4c		90			NOPL			
	if spc.sizeclass() == 0 && nalloc == 0 {
  0x41ac4d		0fb674243a		MOVZX 0x3a(SP), SI	
  0x41ac52		4084f6			TESTL SI, SI		
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x41ac55		0f84d4000000		JE 0x41ad2f		
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41ac5b		488b842490000000	MOVQ 0x90(SP), AX		
  0x41ac63		8400			TESTB AL, 0(AX)			
  0x41ac65		480fbef6		MOVSX SI, SI			
  0x41ac69		90			NOPL				
  0x41ac6a		4883fe43		CMPQ $0x43, SI			
  0x41ac6e		0f83d3010000		JAE 0x41ae47			
  0x41ac74		488bbcf0a8040000	MOVQ 0x4a8(AX)(SI*8), DI	
  0x41ac7c		0fb7d2			MOVZX DX, DX			
  0x41ac7f		4801fa			ADDQ DI, DX			
  0x41ac82		488994f0a8040000	MOVQ DX, 0x4a8(AX)(SI*8)	
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x41ac8a		0fb6442436		MOVZX 0x36(SP), AX		
  0x41ac8f		483d86000000		CMPQ $0x86, AX			
  0x41ac95		0f83a5010000		JAE 0x41ae40			
  0x41ac9b		48c1e006		SHLQ $0x6, AX			
  0x41ac9f		488d151abd0a00		LEAQ runtime.mheap_+896(SB), DX	
  0x41aca6		488d0402		LEAQ 0(DX)(AX*1), AX		
  0x41acaa		48890424		MOVQ AX, 0(SP)			
  0x41acae		48894c2408		MOVQ CX, 0x8(SP)		
  0x41acb3		0fb68424e8000000	MOVZX 0xe8(SP), AX		
  0x41acbb		88442410		MOVB AL, 0x10(SP)		
	wasempty := s.nextFreeIndex() == s.nelems
  0x41acbf		488b442470		MOVQ 0x70(SP), AX	
  0x41acc4		488b542478		MOVQ 0x78(SP), DX	
  0x41acc9		4839d0			CMPQ DX, AX		
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x41accc		0f94442411		SETE 0x11(SP)				
  0x41acd1		e80a64ffff		CALL runtime.(*mcentral).freeSpan(SB)	
  0x41acd6		0fb6442418		MOVZX 0x18(SP), AX			
	if !res {
  0x41acdb		84c0			TESTL AL, AL		
  0x41acdd		7417			JE 0x41acf6		
	return res
  0x41acdf		888424f0000000		MOVB AL, 0xf0(SP)	
  0x41ace6		488bac24d0000000	MOVQ 0xd0(SP), BP	
  0x41acee		4881c4d8000000		ADDQ $0xd8, SP		
  0x41acf5		c3			RET			
	if !res {
  0x41acf6		88442437		MOVB AL, 0x37(SP)	
		mheap_.sweepSpans[sweepgen/2%2].push(s)
  0x41acfa		8b442440		MOVL 0x40(SP), AX			
  0x41acfe		d1e8			SHRL $0x1, AX				
  0x41ad00		83e001			ANDL $0x1, AX				
  0x41ad03		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x41ad07		488d0d72b90a00		LEAQ runtime.mheap_+64(SB), CX		
  0x41ad0e		488d04c1		LEAQ 0(CX)(AX*8), AX			
  0x41ad12		48890424		MOVQ AX, 0(SP)				
  0x41ad16		488b8424e0000000	MOVQ 0xe0(SP), AX			
  0x41ad1e		4889442408		MOVQ AX, 0x8(SP)			
  0x41ad23		e808050000		CALL runtime.(*gcSweepBuf).push(SB)	
	return res
  0x41ad28		0fb6442437		MOVZX 0x37(SP), AX	
		mheap_.sweepSpans[sweepgen/2%2].push(s)
  0x41ad2d		ebb0			JMP 0x41acdf		
	if freeToHeap || nfreed == 0 {
  0x41ad2f		84c0			TESTL AL, AL		
	} else if freeToHeap {
  0x41ad31		0f8484000000		JE 0x41adbb		
		if debug.efence > 0 {
  0x41ad37		833dae210c0000		CMPL $0x0, runtime.debug+12(SB)	
  0x41ad3e		7e5f			JLE 0x41ad9f			
			s.limit = 0 // prevent mlookup from finding this span
  0x41ad40		48c7417800000000	MOVQ $0x0, 0x78(CX)	
			sysFault(unsafe.Pointer(s.base()), size)
  0x41ad48		90			NOPL			
	return s.startAddr
  0x41ad49		488b4118		MOVQ 0x18(CX), AX	
			sysFault(unsafe.Pointer(s.base()), size)
  0x41ad4d		90			NOPL			
	mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, -1, 0)
  0x41ad4e		48890424		MOVQ AX, 0(SP)		
  0x41ad52		488b442450		MOVQ 0x50(SP), AX	
  0x41ad57		4889442408		MOVQ AX, 0x8(SP)	
  0x41ad5c		48ba0000000032000000	MOVQ $0x3200000000, DX	
  0x41ad66		4889542410		MOVQ DX, 0x10(SP)	
  0x41ad6b		baffffffff		MOVL $-0x1, DX		
  0x41ad70		4889542418		MOVQ DX, 0x18(SP)	
  0x41ad75		e80687feff		CALL runtime.mmap(SB)	
		c.local_nlargefree++
  0x41ad7a		488b842490000000	MOVQ 0x90(SP), AX	
  0x41ad82		48ff80a0040000		INCQ 0x4a0(AX)		
		c.local_largefree += size
  0x41ad89		488b4c2450		MOVQ 0x50(SP), CX	
  0x41ad8e		48018898040000		ADDQ CX, 0x498(AX)	
  0x41ad95		b801000000		MOVL $0x1, AX		
		res = true
  0x41ad9a		e93cffffff		JMP 0x41acdb		
			mheap_.freeSpan(s, true)
  0x41ad9f		488d059ab80a00		LEAQ runtime.mheap_(SB), AX		
  0x41ada6		48890424		MOVQ AX, 0(SP)				
  0x41adaa		48894c2408		MOVQ CX, 0x8(SP)			
  0x41adaf		c644241001		MOVB $0x1, 0x10(SP)			
  0x41adb4		e857310000		CALL runtime.(*mheap).freeSpan(SB)	
  0x41adb9		ebbf			JMP 0x41ad7a				
  0x41adbb		31c0			XORL AX, AX				
	} else if freeToHeap {
  0x41adbd		e919ffffff		JMP 0x41acdb		
	if freeToHeap || nfreed == 0 {
  0x41adc2		84c0			TESTL AL, AL		
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x41adc4		e968ffffff		JMP 0x41ad31		
	if freeToHeap || nfreed == 0 {
  0x41adc9		0fb74c243c		MOVZX 0x3c(SP), CX	
  0x41adce		6685c9			TESTW CX, CX		
  0x41add1		0f8438feffff		JE 0x41ac0f		
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x41add7		488b8c24e0000000	MOVQ 0xe0(SP), CX	
		mheap_.sweepSpans[sweepgen/2%2].push(s)
  0x41addf		8b5c2440		MOVL 0x40(SP), BX	
	if nfreed > 0 && spc.sizeclass() != 0 {
  0x41ade3		e956feffff		JMP 0x41ac3e		
	nfreed := s.allocCount - nalloc
  0x41ade8		488b9c24e0000000	MOVQ 0xe0(SP), BX	
  0x41adf0		31f6			XORL SI, SI		
  0x41adf2		e948fdffff		JMP 0x41ab3f		
	if debug.allocfreetrace != 0 || debug.clobberfree != 0 || raceenabled || msanenabled {
  0x41adf7		833dea200c0000		CMPL $0x0, runtime.debug+8(SB)	
  0x41adfe		0f8549fbffff		JNE 0x41a94d			
  0x41ae04		e9fcfcffff		JMP 0x41ab05			
	_g_ := getg()
  0x41ae09		4889942498000000	MOVQ DX, 0x98(SP)	
		traceGCSweepSpan(s.npages * _PageSize)
  0x41ae11		488b4620		MOVQ 0x20(SI), AX			
  0x41ae15		48c1e00d		SHLQ $0xd, AX				
  0x41ae19		48890424		MOVQ AX, 0(SP)				
  0x41ae1d		e8ee1e0200		CALL runtime.traceGCSweepSpan(SB)	
	c := _g_.m.mcache
  0x41ae22		488b942498000000	MOVQ 0x98(SP), DX	
		atomic.Store(&s.sweepgen, sweepgen)
  0x41ae2a		8b5c2440		MOVL 0x40(SP), BX	
	atomic.Xadd64(&mheap_.pagesSwept, int64(s.npages))
  0x41ae2e		488bb424e0000000	MOVQ 0xe0(SP), SI	
		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
  0x41ae36		448b442444		MOVL 0x44(SP), R8	
		traceGCSweepSpan(s.npages * _PageSize)
  0x41ae3b		e95cf9ffff		JMP 0x41a79c		
		res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)
  0x41ae40		e8db700000		CALL runtime.panicindex(SB)	
  0x41ae45		0f0b			UD2				
		c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)
  0x41ae47		e8d4700000		CALL runtime.panicindex(SB)	
  0x41ae4c		0f0b			UD2				
			print("mspan.sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
  0x41ae4e		8b4158			MOVL 0x58(CX), AX		
  0x41ae51		4889442470		MOVQ AX, 0x70(SP)		
  0x41ae56		e865900000		CALL runtime.printlock(SB)	
  0x41ae5b		488d05c6550500		LEAQ 0x555c6(IP), AX		
  0x41ae62		48890424		MOVQ AX, 0(SP)			
  0x41ae66		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x41ae6f		e87c990000		CALL runtime.printstring(SB)	
  0x41ae74		0fb644243b		MOVZX 0x3b(SP), AX		
  0x41ae79		48890424		MOVQ AX, 0(SP)			
  0x41ae7d		e8be960000		CALL runtime.printuint(SB)	
  0x41ae82		488d05e3480500		LEAQ 0x548e3(IP), AX		
  0x41ae89		48890424		MOVQ AX, 0(SP)			
  0x41ae8d		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41ae96		e855990000		CALL runtime.printstring(SB)	
  0x41ae9b		488b442470		MOVQ 0x70(SP), AX		
  0x41aea0		48890424		MOVQ AX, 0(SP)			
  0x41aea4		e897960000		CALL runtime.printuint(SB)	
  0x41aea9		488d0577500500		LEAQ 0x55077(IP), AX		
  0x41aeb0		48890424		MOVQ AX, 0(SP)			
  0x41aeb4		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x41aebd		e82e990000		CALL runtime.printstring(SB)	
  0x41aec2		8b442440		MOVL 0x40(SP), AX		
  0x41aec6		48890424		MOVQ AX, 0(SP)			
  0x41aeca		e871960000		CALL runtime.printuint(SB)	
  0x41aecf		e87c920000		CALL runtime.printnl(SB)	
  0x41aed4		e867900000		CALL runtime.printunlock(SB)	
			throw("mspan.sweep: bad span state after sweep")
  0x41aed9		488d0558790500		LEAQ 0x57958(IP), AX	
  0x41aee0		48890424		MOVQ AX, 0(SP)		
  0x41aee4		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x41aeed		e88e850000		CALL runtime.throw(SB)	
  0x41aef2		0f0b			UD2			
	nalloc := uint16(s.countAlloc())
  0x41aef4		4889442468		MOVQ AX, 0x68(SP)	
	nfreed := s.allocCount - nalloc
  0x41aef9		66448944243e		MOVW R8, 0x3e(SP)	
		print("runtime: nelems=", s.nelems, " nalloc=", nalloc, " previous allocCount=", s.allocCount, " nfreed=", nfreed, "\n")
  0x41aeff		488b4338		MOVQ 0x38(BX), AX		
  0x41af03		4889442478		MOVQ AX, 0x78(SP)		
  0x41af08		e8b38f0000		CALL runtime.printlock(SB)	
  0x41af0d		488d0593510500		LEAQ 0x55193(IP), AX		
  0x41af14		48890424		MOVQ AX, 0(SP)			
  0x41af18		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x41af21		e8ca980000		CALL runtime.printstring(SB)	
  0x41af26		488b442478		MOVQ 0x78(SP), AX		
  0x41af2b		48890424		MOVQ AX, 0(SP)			
  0x41af2f		e80c960000		CALL runtime.printuint(SB)	
  0x41af34		488d05c5440500		LEAQ 0x544c5(IP), AX		
  0x41af3b		48890424		MOVQ AX, 0(SP)			
  0x41af3f		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x41af48		e8a3980000		CALL runtime.printstring(SB)	
  0x41af4d		488b442468		MOVQ 0x68(SP), AX		
  0x41af52		0fb7c0			MOVZX AX, AX			
  0x41af55		48890424		MOVQ AX, 0(SP)			
  0x41af59		e8e2950000		CALL runtime.printuint(SB)	
  0x41af5e		488d0575580500		LEAQ 0x55875(IP), AX		
  0x41af65		48890424		MOVQ AX, 0(SP)			
  0x41af69		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x41af72		e879980000		CALL runtime.printstring(SB)	
  0x41af77		0fb744243e		MOVZX 0x3e(SP), AX		
  0x41af7c		48890424		MOVQ AX, 0(SP)			
  0x41af80		e8bb950000		CALL runtime.printuint(SB)	
  0x41af85		488d0584440500		LEAQ 0x54484(IP), AX		
  0x41af8c		48890424		MOVQ AX, 0(SP)			
  0x41af90		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x41af99		e852980000		CALL runtime.printstring(SB)	
  0x41af9e		0fb744243c		MOVZX 0x3c(SP), AX		
  0x41afa3		0fb7c0			MOVZX AX, AX			
  0x41afa6		48890424		MOVQ AX, 0(SP)			
  0x41afaa		e891950000		CALL runtime.printuint(SB)	
  0x41afaf		e89c910000		CALL runtime.printnl(SB)	
  0x41afb4		e8878f0000		CALL runtime.printunlock(SB)	
		throw("sweep increased allocation count")
  0x41afb9		488d0571700500		LEAQ 0x57071(IP), AX	
  0x41afc0		48890424		MOVQ AX, 0(SP)		
  0x41afc4		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x41afcd		e8ae840000		CALL runtime.throw(SB)	
  0x41afd2		0f0b			UD2			
		objIndex := uintptr(special.offset) / size
  0x41afd4		e8a7710000		CALL runtime.panicdivide(SB)	
  0x41afd9		0f0b			UD2				
		print("mspan.sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
  0x41afdb		8b4658			MOVL 0x58(SI), AX		
  0x41afde		4889442470		MOVQ AX, 0x70(SP)		
  0x41afe3		e8d88e0000		CALL runtime.printlock(SB)	
  0x41afe8		488d0539540500		LEAQ 0x55439(IP), AX		
  0x41afef		48890424		MOVQ AX, 0(SP)			
  0x41aff3		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x41affc		e8ef970000		CALL runtime.printstring(SB)	
  0x41b001		0fb644243b		MOVZX 0x3b(SP), AX		
  0x41b006		48890424		MOVQ AX, 0(SP)			
  0x41b00a		e831950000		CALL runtime.printuint(SB)	
  0x41b00f		488d0556470500		LEAQ 0x54756(IP), AX		
  0x41b016		48890424		MOVQ AX, 0(SP)			
  0x41b01a		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41b023		e8c8970000		CALL runtime.printstring(SB)	
  0x41b028		488b442470		MOVQ 0x70(SP), AX		
  0x41b02d		48890424		MOVQ AX, 0(SP)			
  0x41b031		e80a950000		CALL runtime.printuint(SB)	
  0x41b036		488d05ea4e0500		LEAQ 0x54eea(IP), AX		
  0x41b03d		48890424		MOVQ AX, 0(SP)			
  0x41b041		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x41b04a		e8a1970000		CALL runtime.printstring(SB)	
  0x41b04f		8b442440		MOVL 0x40(SP), AX		
  0x41b053		48890424		MOVQ AX, 0(SP)			
  0x41b057		e8e4940000		CALL runtime.printuint(SB)	
  0x41b05c		e8ef900000		CALL runtime.printnl(SB)	
  0x41b061		e8da8e0000		CALL runtime.printunlock(SB)	
		throw("mspan.sweep: bad span state")
  0x41b066		488d05d3630500		LEAQ 0x563d3(IP), AX	
  0x41b06d		48890424		MOVQ AX, 0(SP)		
  0x41b071		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x41b07a		e801840000		CALL runtime.throw(SB)	
  0x41b07f		0f0b			UD2			
		throw("mspan.sweep: m is not locked")
  0x41b081		488d05ba660500		LEAQ 0x566ba(IP), AX	
  0x41b088		48890424		MOVQ AX, 0(SP)		
  0x41b08c		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x41b095		e8e6830000		CALL runtime.throw(SB)	
  0x41b09a		0f0b			UD2			
func (s *mspan) sweep(preserve bool) bool {
  0x41b09c		e8dfc70200		CALL runtime.morestack_noctxt(SB)	
  0x41b0a1		e95af6ffff		JMP runtime.(*mspan).sweep(SB)		

TEXT runtime.deductSweepCredit(SB) /usr/local/go/src/runtime/mgcsweep.go
func deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr) {
  0x41b0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b0b9		483b6110		CMPQ 0x10(CX), SP	
  0x41b0bd		0f863a010000		JBE 0x41b1fd		
  0x41b0c3		4883ec20		SUBQ $0x20, SP		
  0x41b0c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x41b0cc		488d6c2418		LEAQ 0x18(SP), BP	
	if mheap_.sweepPagesPerByte == 0 {
  0x41b0d1		f20f10051fb60a00	MOVSD_XMM runtime.mheap_+184(SB), X0	
  0x41b0d9		0f57c9			XORPS X1, X1				
  0x41b0dc		660f2ec1		UCOMISD X1, X0				
  0x41b0e0		7506			JNE 0x41b0e8				
  0x41b0e2		0f8b0b010000		JNP 0x41b1f3				
	if trace.enabled {
  0x41b0e8		803de11a0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41b0ef		0f85f1000000		JNE 0x41b1e6			
	sweptBasis := atomic.Load64(&mheap_.pagesSweptBasis)
  0x41b0f5		488b442428		MOVQ 0x28(SP), AX	
  0x41b0fa		488b4c2430		MOVQ 0x30(SP), CX	
  0x41b0ff		eb5a			JMP 0x41b15b		
	newHeapLive := uintptr(atomic.Load64(&memstats.heap_live)-mheap_.sweepHeapLiveBasis) + spanBytes
  0x41b101		488b442428		MOVQ 0x28(SP), AX	
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x41b106		488b4c2430		MOVQ 0x30(SP), CX	
	for pagesTarget > int64(atomic.Load64(&mheap_.pagesSwept)-sweptBasis) {
  0x41b10b		488b542408		MOVQ 0x8(SP), DX		
  0x41b110		488b5c2410		MOVQ 0x10(SP), BX		
  0x41b115		0f57c9			XORPS X1, X1			
  0x41b118		488b35c1b50a00		MOVQ runtime.mheap_+160(SB), SI	
  0x41b11f		4829d6			SUBQ DX, SI			
  0x41b122		4839f3			CMPQ SI, BX			
  0x41b125		0f8e86000000		JLE 0x41b1b1			
		if sweepone() == ^uintptr(0) {
  0x41b12b		e8f0f0ffff		CALL runtime.sweepone(SB)	
  0x41b130		48833c24ff		CMPQ $-0x1, 0(SP)		
  0x41b135		746f			JE 0x41b1a6			
		if atomic.Load64(&mheap_.pagesSweptBasis) != sweptBasis {
  0x41b137		488b05aab50a00		MOVQ runtime.mheap_+168(SB), AX	
  0x41b13e		488b4c2408		MOVQ 0x8(SP), CX		
  0x41b143		4839c8			CMPQ CX, AX			
  0x41b146		74b9			JE 0x41b101			
			goto retry
  0x41b148		488b542428		MOVQ 0x28(SP), DX	
  0x41b14d		488b5c2430		MOVQ 0x30(SP), BX	
	newHeapLive := uintptr(atomic.Load64(&memstats.heap_live)-mheap_.sweepHeapLiveBasis) + spanBytes
  0x41b152		4889d0			MOVQ DX, AX		
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x41b155		4889d9			MOVQ BX, CX		
  0x41b158		0f57c9			XORPS X1, X1		
	sweptBasis := atomic.Load64(&mheap_.pagesSweptBasis)
  0x41b15b		488b1586b50a00		MOVQ runtime.mheap_+168(SB), DX	
	newHeapLive := uintptr(atomic.Load64(&memstats.heap_live)-mheap_.sweepHeapLiveBasis) + spanBytes
  0x41b162		488b1d37420c00		MOVQ runtime.memstats+5952(SB), BX	
  0x41b169		488b3580b50a00		MOVQ runtime.mheap_+176(SB), SI		
  0x41b170		4829f3			SUBQ SI, BX				
  0x41b173		4801c3			ADDQ AX, BX				
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x41b176		f20f10057ab50a00	MOVSD_XMM runtime.mheap_+184(SB), X0	
  0x41b17e		4885db			TESTQ BX, BX				
  0x41b181		7c48			JL 0x41b1cb				
  0x41b183		0f57d2			XORPS X2, X2				
  0x41b186		f2480f2ad3		CVTSI2SDQ BX, X2			
	sweptBasis := atomic.Load64(&mheap_.pagesSweptBasis)
  0x41b18b		4889542408		MOVQ DX, 0x8(SP)	
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x41b190		f20f59c2		MULSD X2, X0		
  0x41b194		f2480f2cd8		CVTTSD2SIQ X0, BX	
  0x41b199		4829cb			SUBQ CX, BX		
  0x41b19c		48895c2410		MOVQ BX, 0x10(SP)	
	for pagesTarget > int64(atomic.Load64(&mheap_.pagesSwept)-sweptBasis) {
  0x41b1a1		e972ffffff		JMP 0x41b118		
			mheap_.sweepPagesPerByte = 0
  0x41b1a6		0f57c0			XORPS X0, X0				
  0x41b1a9		f20f110547b50a00	MOVSD_XMM X0, runtime.mheap_+184(SB)	
	if trace.enabled {
  0x41b1b1		803d181a0b0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41b1b8		750a			JNE 0x41b1c4			
  0x41b1ba		488b6c2418		MOVQ 0x18(SP), BP		
  0x41b1bf		4883c420		ADDQ $0x20, SP			
  0x41b1c3		c3			RET				
		traceGCSweepDone()
  0x41b1c4		e8e71b0200		CALL runtime.traceGCSweepDone(SB)	
  0x41b1c9		ebef			JMP 0x41b1ba				
	pagesTarget := int64(mheap_.sweepPagesPerByte*float64(newHeapLive)) - int64(callerSweepPages)
  0x41b1cb		4889de			MOVQ BX, SI		
  0x41b1ce		48d1eb			SHRQ $0x1, BX		
  0x41b1d1		4883e601		ANDQ $0x1, SI		
  0x41b1d5		4809f3			ORQ SI, BX		
  0x41b1d8		0f57d2			XORPS X2, X2		
  0x41b1db		f2480f2ad3		CVTSI2SDQ BX, X2	
  0x41b1e0		f20f58d2		ADDSD X2, X2		
  0x41b1e4		eba5			JMP 0x41b18b		
		traceGCSweepStart()
  0x41b1e6		e8a51a0200		CALL runtime.traceGCSweepStart(SB)	
  0x41b1eb		0f57c9			XORPS X1, X1				
  0x41b1ee		e902ffffff		JMP 0x41b0f5				
		return
  0x41b1f3		488b6c2418		MOVQ 0x18(SP), BP	
  0x41b1f8		4883c420		ADDQ $0x20, SP		
  0x41b1fc		c3			RET			
func deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr) {
  0x41b1fd		e87ec60200		CALL runtime.morestack_noctxt(SB)	
  0x41b202		e9a9feffff		JMP runtime.deductSweepCredit(SB)	

TEXT runtime.clobberfree(SB) /usr/local/go/src/runtime/mgcsweep.go
	for i := uintptr(0); i < size; i += 4 {
  0x41b210		488b442410		MOVQ 0x10(SP), AX	
  0x41b215		488b4c2408		MOVQ 0x8(SP), CX	
  0x41b21a		31d2			XORL DX, DX		
  0x41b21c		eb0c			JMP 0x41b22a		
		*(*uint32)(add(x, i)) = 0xdeadbeef
  0x41b21e		90			NOPL				
  0x41b21f		c70411efbeadde		MOVL $-0x21524111, 0(CX)(DX*1)	
	for i := uintptr(0); i < size; i += 4 {
  0x41b226		4883c204		ADDQ $0x4, DX		
  0x41b22a		4839c2			CMPQ AX, DX		
  0x41b22d		72ef			JB 0x41b21e		
  0x41b22f		c3			RET			

TEXT runtime.(*gcSweepBuf).push(SB) /usr/local/go/src/runtime/mgcsweepbuf.go
func (b *gcSweepBuf) push(s *mspan) {
  0x41b230		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b239		483b6110		CMPQ 0x10(CX), SP	
  0x41b23d		0f869e010000		JBE 0x41b3e1		
  0x41b243		4883ec58		SUBQ $0x58, SP		
  0x41b247		48896c2450		MOVQ BP, 0x50(SP)	
  0x41b24c		488d6c2450		LEAQ 0x50(SP), BP	
	cursor := uintptr(atomic.Xadd(&b.index, +1) - 1)
  0x41b251		b801000000		MOVL $0x1, AX		
  0x41b256		488b4c2460		MOVQ 0x60(SP), CX	
  0x41b25b		f00fc14120		LOCK XADDL AX, 0x20(CX)	
  0x41b260		89442424		MOVL AX, 0x24(SP)	
	spineLen := atomic.Loaduintptr(&b.spineLen)
  0x41b264		488b5110		MOVQ 0x10(CX), DX	
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41b268		89c3			MOVL AX, BX		
  0x41b26a		48c1e809		SHRQ $0x9, AX		
  0x41b26e		4889442438		MOVQ AX, 0x38(SP)	
retry:
  0x41b273		eb1c			JMP 0x41b291		
			unlock(&b.spineLock)
  0x41b275		48890424		MOVQ AX, 0(SP)		
  0x41b279		e812d6feff		CALL runtime.unlock(SB)	
	if top < spineLen {
  0x41b27e		488b442438		MOVQ 0x38(SP), AX	
		lock(&b.spineLock)
  0x41b283		488b4c2460		MOVQ 0x60(SP), CX	
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41b288		8b5c2424		MOVL 0x24(SP), BX	
	if top < spineLen {
  0x41b28c		488b542430		MOVQ 0x30(SP), DX	
  0x41b291		4839d0			CMPQ DX, AX		
  0x41b294		0f8233010000		JB 0x41b3cd		
		lock(&b.spineLock)
  0x41b29a		48890c24		MOVQ CX, 0(SP)		
  0x41b29e		e83dd4feff		CALL runtime.lock(SB)	
		spineLen = atomic.Loaduintptr(&b.spineLen)
  0x41b2a3		488b442460		MOVQ 0x60(SP), AX	
  0x41b2a8		488b4810		MOVQ 0x10(AX), CX	
  0x41b2ac		48894c2430		MOVQ CX, 0x30(SP)	
		if top < spineLen {
  0x41b2b1		488b542438		MOVQ 0x38(SP), DX	
  0x41b2b6		4839ca			CMPQ CX, DX		
  0x41b2b9		72ba			JB 0x41b275		
		if spineLen == b.spineCap {
  0x41b2bb		488b5818		MOVQ 0x18(AX), BX	
  0x41b2bf		4839d9			CMPQ BX, CX		
  0x41b2c2		747f			JE 0x41b343		
		block = (*gcSweepBlock)(persistentalloc(unsafe.Sizeof(gcSweepBlock{}), cpu.CacheLineSize, &memstats.gc_sys))
  0x41b2c4		48c7042400100000	MOVQ $0x1000, 0(SP)			
  0x41b2cc		488b054d3d0a00		MOVQ internal/cpu.CacheLineSize(SB), AX	
  0x41b2d3		4889442408		MOVQ AX, 0x8(SP)			
  0x41b2d8		488d05192a0c00		LEAQ runtime.memstats+152(SB), AX	
  0x41b2df		4889442410		MOVQ AX, 0x10(SP)			
  0x41b2e4		e887f7feff		CALL runtime.persistentalloc(SB)	
  0x41b2e9		488b442418		MOVQ 0x18(SP), AX			
  0x41b2ee		4889442448		MOVQ AX, 0x48(SP)			
		blockp := add(b.spine, sys.PtrSize*top)
  0x41b2f3		90			NOPL			
  0x41b2f4		488b4c2438		MOVQ 0x38(SP), CX	
  0x41b2f9		48c1e103		SHLQ $0x3, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x41b2fd		488b542460		MOVQ 0x60(SP), DX	
  0x41b302		48034a08		ADDQ 0x8(DX), CX	
		atomic.StorepNoWB(blockp, unsafe.Pointer(block))
  0x41b306		488701			XCHGQ AX, 0(CX)		
		atomic.Storeuintptr(&b.spineLen, spineLen+1)
  0x41b309		488b442430		MOVQ 0x30(SP), AX	
  0x41b30e		48ffc0			INCQ AX			
  0x41b311		48874210		XCHGQ AX, 0x10(DX)	
		unlock(&b.spineLock)
  0x41b315		48891424		MOVQ DX, 0(SP)		
  0x41b319		e872d5feff		CALL runtime.unlock(SB)	
	block.spans[bottom] = s
  0x41b31e		488b442448		MOVQ 0x48(SP), AX	
  0x41b323		8400			TESTB AL, 0(AX)		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41b325		8b4c2424		MOVL 0x24(SP), CX	
  0x41b329		4881e1ff010000		ANDQ $0x1ff, CX		
	block.spans[bottom] = s
  0x41b330		488b542468		MOVQ 0x68(SP), DX	
  0x41b335		488914c8		MOVQ DX, 0(AX)(CX*8)	
}
  0x41b339		488b6c2450		MOVQ 0x50(SP), BP	
  0x41b33e		4883c458		ADDQ $0x58, SP		
  0x41b342		c3			RET			
			newCap := b.spineCap * 2
  0x41b343		48d1e3			SHLQ $0x1, BX		
			if newCap == 0 {
  0x41b346		4885db			TESTQ BX, BX		
			newSpine := persistentalloc(newCap*sys.PtrSize, cpu.CacheLineSize, &memstats.gc_sys)
  0x41b349		b800010000		MOVL $0x100, AX				
  0x41b34e		480f44d8		CMOVE AX, BX				
  0x41b352		48895c2428		MOVQ BX, 0x28(SP)			
  0x41b357		48c1e303		SHLQ $0x3, BX				
  0x41b35b		48891c24		MOVQ BX, 0(SP)				
  0x41b35f		488b0dba3c0a00		MOVQ internal/cpu.CacheLineSize(SB), CX	
  0x41b366		48894c2408		MOVQ CX, 0x8(SP)			
  0x41b36b		488d0d86290c00		LEAQ runtime.memstats+152(SB), CX	
  0x41b372		48894c2410		MOVQ CX, 0x10(SP)			
  0x41b377		e8f4f6feff		CALL runtime.persistentalloc(SB)	
  0x41b37c		488b442418		MOVQ 0x18(SP), AX			
			if b.spineCap != 0 {
  0x41b381		488b4c2460		MOVQ 0x60(SP), CX	
  0x41b386		488b5118		MOVQ 0x18(CX), DX	
  0x41b38a		4885d2			TESTQ DX, DX		
			if newCap == 0 {
  0x41b38d		7512			JNE 0x41b3a1		
			atomic.StorepNoWB(unsafe.Pointer(&b.spine), newSpine)
  0x41b38f		48874108		XCHGQ AX, 0x8(CX)	
			b.spineCap = newCap
  0x41b393		488b442428		MOVQ 0x28(SP), AX	
  0x41b398		48894118		MOVQ AX, 0x18(CX)	
  0x41b39c		e923ffffff		JMP 0x41b2c4		
			newSpine := persistentalloc(newCap*sys.PtrSize, cpu.CacheLineSize, &memstats.gc_sys)
  0x41b3a1		4889442440		MOVQ AX, 0x40(SP)	
				memmove(newSpine, b.spine, b.spineCap*sys.PtrSize)
  0x41b3a6		488b5908		MOVQ 0x8(CX), BX		
  0x41b3aa		48890424		MOVQ AX, 0(SP)			
  0x41b3ae		48895c2408		MOVQ BX, 0x8(SP)		
  0x41b3b3		48c1e203		SHLQ $0x3, DX			
  0x41b3b7		4889542410		MOVQ DX, 0x10(SP)		
  0x41b3bc		e88ff30200		CALL runtime.memmove(SB)	
			atomic.StorepNoWB(unsafe.Pointer(&b.spine), newSpine)
  0x41b3c1		488b442440		MOVQ 0x40(SP), AX	
  0x41b3c6		488b4c2460		MOVQ 0x60(SP), CX	
				memmove(newSpine, b.spine, b.spineCap*sys.PtrSize)
  0x41b3cb		ebc2			JMP 0x41b38f		
		spine := atomic.Loadp(unsafe.Pointer(&b.spine))
  0x41b3cd		488b4908		MOVQ 0x8(CX), CX	
		blockp := add(spine, sys.PtrSize*top)
  0x41b3d1		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x41b3d2		488d0cc1		LEAQ 0(CX)(AX*8), CX	
		block = (*gcSweepBlock)(atomic.Loadp(blockp))
  0x41b3d6		488b09			MOVQ 0(CX), CX		
	block.spans[bottom] = s
  0x41b3d9		4889c8			MOVQ CX, AX		
		block = (*gcSweepBlock)(atomic.Loadp(blockp))
  0x41b3dc		e942ffffff		JMP 0x41b323		
func (b *gcSweepBuf) push(s *mspan) {
  0x41b3e1		e89ac40200		CALL runtime.morestack_noctxt(SB)	
  0x41b3e6		e945feffff		JMP runtime.(*gcSweepBuf).push(SB)	

TEXT runtime.(*gcSweepBuf).block(SB) /usr/local/go/src/runtime/mgcsweepbuf.go
func (b *gcSweepBuf) block(i int) []*mspan {
  0x41b3f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b3f9		483b6110		CMPQ 0x10(CX), SP	
  0x41b3fd		0f86cc000000		JBE 0x41b4cf		
  0x41b403		4883ec18		SUBQ $0x18, SP		
  0x41b407		48896c2410		MOVQ BP, 0x10(SP)	
  0x41b40c		488d6c2410		LEAQ 0x10(SP), BP	
	if i < 0 || uintptr(i) >= atomic.Loaduintptr(&b.spineLen) {
  0x41b411		488b442428		MOVQ 0x28(SP), AX	
  0x41b416		4885c0			TESTQ AX, AX		
  0x41b419		7d7e			JGE 0x41b499		
  0x41b41b		b901000000		MOVL $0x1, CX		
  0x41b420		84c9			TESTL CL, CL		
  0x41b422		0f858c000000		JNE 0x41b4b4		
	spine := atomic.Loadp(unsafe.Pointer(&b.spine))
  0x41b428		488b4c2420		MOVQ 0x20(SP), CX	
  0x41b42d		488b5108		MOVQ 0x8(CX), DX	
	blockp := add(spine, sys.PtrSize*uintptr(i))
  0x41b431		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x41b432		488d14c2		LEAQ 0(DX)(AX*8), DX	
	block := (*gcSweepBlock)(atomic.Loadp(blockp))
  0x41b436		488b12			MOVQ 0(DX), DX		
	cursor := uintptr(atomic.Load(&b.index))
  0x41b439		8b4920			MOVL 0x20(CX), CX	
  0x41b43c		89c9			MOVL CX, CX		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41b43e		4889cb			MOVQ CX, BX		
  0x41b441		48c1e909		SHRQ $0x9, CX		
	if uintptr(i) < top {
  0x41b445		4839c8			CMPQ CX, AX		
  0x41b448		7338			JAE 0x41b482		
		spans = block.spans[:]
  0x41b44a		8402			TESTB AL, 0(DX)		
  0x41b44c		b800020000		MOVL $0x200, AX		
  0x41b451		eb03			JMP 0x41b456		
	for len(spans) > 0 && spans[len(spans)-1] == nil {
  0x41b453		48ffc8			DECQ AX			
  0x41b456		4885c0			TESTQ AX, AX		
  0x41b459		7e0a			JLE 0x41b465		
  0x41b45b		488b4cc2f8		MOVQ -0x8(DX)(AX*8), CX	
  0x41b460		4885c9			TESTQ CX, CX		
  0x41b463		74ee			JE 0x41b453		
	return spans
  0x41b465		4889542430		MOVQ DX, 0x30(SP)	
  0x41b46a		4889442438		MOVQ AX, 0x38(SP)	
  0x41b46f		48c744244000020000	MOVQ $0x200, 0x40(SP)	
  0x41b478		488b6c2410		MOVQ 0x10(SP), BP	
  0x41b47d		4883c418		ADDQ $0x18, SP		
  0x41b481		c3			RET			
		spans = block.spans[:bottom]
  0x41b482		8402			TESTB AL, 0(DX)		
  0x41b484		48f7c3ff010000		TESTQ $0x1ff, BX	
  0x41b48b		7c20			JL 0x41b4ad		
	top, bottom := cursor/gcSweepBlockEntries, cursor%gcSweepBlockEntries
  0x41b48d		4881e3ff010000		ANDQ $0x1ff, BX		
	for len(spans) > 0 && spans[len(spans)-1] == nil {
  0x41b494		4889d8			MOVQ BX, AX		
		spans = block.spans[:bottom]
  0x41b497		ebbd			JMP 0x41b456		
	if i < 0 || uintptr(i) >= atomic.Loaduintptr(&b.spineLen) {
  0x41b499		488b542420		MOVQ 0x20(SP), DX	
  0x41b49e		488b5a10		MOVQ 0x10(DX), BX	
  0x41b4a2		4839d8			CMPQ BX, AX		
  0x41b4a5		0f93c1			SETAE CL		
  0x41b4a8		e973ffffff		JMP 0x41b420		
		spans = block.spans[:bottom]
  0x41b4ad		e89e6b0000		CALL runtime.panicslice(SB)	
  0x41b4b2		0f0b			UD2				
		throw("block index out of range")
  0x41b4b4		488d058f590500		LEAQ 0x5598f(IP), AX	
  0x41b4bb		48890424		MOVQ AX, 0(SP)		
  0x41b4bf		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x41b4c8		e8b37f0000		CALL runtime.throw(SB)	
  0x41b4cd		0f0b			UD2			
func (b *gcSweepBuf) block(i int) []*mspan {
  0x41b4cf		e8acc30200		CALL runtime.morestack_noctxt(SB)	
  0x41b4d4		e917ffffff		JMP runtime.(*gcSweepBuf).block(SB)	

TEXT runtime.init.2(SB) /usr/local/go/src/runtime/mgcwork.go
func init() {
  0x41b4e0		c3			RET			

TEXT runtime.(*gcWork).init(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) init() {
  0x41b4f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b4f9		483b6110		CMPQ 0x10(CX), SP	
  0x41b4fd		764b			JBE 0x41b54a		
  0x41b4ff		4883ec10		SUBQ $0x10, SP		
  0x41b503		48896c2408		MOVQ BP, 0x8(SP)	
  0x41b508		488d6c2408		LEAQ 0x8(SP), BP	
	w.wbuf1 = getempty()
  0x41b50d		e8ce060000		CALL runtime.getempty(SB)	
  0x41b512		488b0424		MOVQ 0(SP), AX			
  0x41b516		488b4c2418		MOVQ 0x18(SP), CX		
  0x41b51b		488901			MOVQ AX, 0(CX)			
	wbuf2 := trygetfull()
  0x41b51e		e8ad090000		CALL runtime.trygetfull(SB)	
  0x41b523		488b0424		MOVQ 0(SP), AX			
	if wbuf2 == nil {
  0x41b527		4885c0			TESTQ AX, AX		
  0x41b52a		7413			JE 0x41b53f		
	w.wbuf2 = wbuf2
  0x41b52c		488b4c2418		MOVQ 0x18(SP), CX	
  0x41b531		48894108		MOVQ AX, 0x8(CX)	
}
  0x41b535		488b6c2408		MOVQ 0x8(SP), BP	
  0x41b53a		4883c410		ADDQ $0x10, SP		
  0x41b53e		c3			RET			
		wbuf2 = getempty()
  0x41b53f		e89c060000		CALL runtime.getempty(SB)	
  0x41b544		488b0424		MOVQ 0(SP), AX			
  0x41b548		ebe2			JMP 0x41b52c			
func (w *gcWork) init() {
  0x41b54a		e831c30200		CALL runtime.morestack_noctxt(SB)	
  0x41b54f		eb9f			JMP runtime.(*gcWork).init(SB)		

TEXT runtime.(*gcWork).put(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) put(obj uintptr) {
  0x41b560		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b569		483b6110		CMPQ 0x10(CX), SP	
  0x41b56d		0f86ef000000		JBE 0x41b662		
  0x41b573		4883ec18		SUBQ $0x18, SP		
  0x41b577		48896c2410		MOVQ BP, 0x10(SP)	
  0x41b57c		488d6c2410		LEAQ 0x10(SP), BP	
	w.checkPut(obj, nil)
  0x41b581		90			NOPL			
  0x41b582		488b442420		MOVQ 0x20(SP), AX	
	wbuf := w.wbuf1
  0x41b587		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x41b58a		4885c9			TESTQ CX, CX		
  0x41b58d		0f84b0000000		JE 0x41b643		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x41b593		48817910fd000000	CMPQ $0xfd, 0x10(CX)	
  0x41b59b		0f8598000000		JNE 0x41b639		
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x41b5a1		488b5008		MOVQ 0x8(AX), DX	
  0x41b5a5		488910			MOVQ DX, 0(AX)		
  0x41b5a8		48894808		MOVQ CX, 0x8(AX)	
		if wbuf.nobj == len(wbuf.obj) {
  0x41b5ac		488b4a10		MOVQ 0x10(DX), CX	
  0x41b5b0		4881f9fd000000		CMPQ $0xfd, CX		
  0x41b5b7		744b			JE 0x41b604		
  0x41b5b9		0f94c0			SETE AL			
	wbuf.obj[wbuf.nobj] = obj
  0x41b5bc		488b4a10		MOVQ 0x10(DX), CX	
  0x41b5c0		4881f9fd000000		CMPQ $0xfd, CX		
  0x41b5c7		0f838e000000		JAE 0x41b65b		
  0x41b5cd		488b5c2428		MOVQ 0x28(SP), BX	
  0x41b5d2		48895cca18		MOVQ BX, 0x18(DX)(CX*8)	
	wbuf.nobj++
  0x41b5d7		48ff4210		INCQ 0x10(DX)		
	if flushed && gcphase == _GCmark {
  0x41b5db		84c0			TESTL AL, AL			
  0x41b5dd		7409			JE 0x41b5e8			
  0x41b5df		833df6160c0001		CMPL $0x1, runtime.gcphase(SB)	
  0x41b5e6		740a			JE 0x41b5f2			
  0x41b5e8		488b6c2410		MOVQ 0x10(SP), BP		
  0x41b5ed		4883c418		ADDQ $0x18, SP			
  0x41b5f1		c3			RET				
		gcController.enlistWorker()
  0x41b5f2		488d05871b0c00		LEAQ runtime.gcController(SB), AX			
  0x41b5f9		48890424		MOVQ AX, 0(SP)						
  0x41b5fd		e85e73ffff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x41b602		ebe4			JMP 0x41b5e8						
		if wbuf.nobj == len(wbuf.obj) {
  0x41b604		48894c2408		MOVQ CX, 0x8(SP)	
			putfull(wbuf)
  0x41b609		48891424		MOVQ DX, 0(SP)			
  0x41b60d		e85e080000		CALL runtime.putfull(SB)	
			w.flushedWork = true
  0x41b612		488b442420		MOVQ 0x20(SP), AX	
  0x41b617		c6402001		MOVB $0x1, 0x20(AX)	
			wbuf = getempty()
  0x41b61b		e8c0050000		CALL runtime.getempty(SB)	
  0x41b620		488b1424		MOVQ 0(SP), DX			
			w.wbuf1 = wbuf
  0x41b624		488b442420		MOVQ 0x20(SP), AX	
  0x41b629		488910			MOVQ DX, 0(AX)		
		if wbuf.nobj == len(wbuf.obj) {
  0x41b62c		488b442408		MOVQ 0x8(SP), AX	
  0x41b631		483dfd000000		CMPQ $0xfd, AX		
			flushed = true
  0x41b637		eb80			JMP 0x41b5b9		
	wbuf.obj[wbuf.nobj] = obj
  0x41b639		4889ca			MOVQ CX, DX		
  0x41b63c		31c0			XORL AX, AX		
	} else if wbuf.nobj == len(wbuf.obj) {
  0x41b63e		e979ffffff		JMP 0x41b5bc		
		w.init()
  0x41b643		48890424		MOVQ AX, 0(SP)			
  0x41b647		e8a4feffff		CALL runtime.(*gcWork).init(SB)	
		wbuf = w.wbuf1
  0x41b64c		488b442420		MOVQ 0x20(SP), AX	
  0x41b651		488b10			MOVQ 0(AX), DX		
  0x41b654		31c0			XORL AX, AX		
  0x41b656		e961ffffff		JMP 0x41b5bc		
	wbuf.obj[wbuf.nobj] = obj
  0x41b65b		e8c0680000		CALL runtime.panicindex(SB)	
  0x41b660		0f0b			UD2				
func (w *gcWork) put(obj uintptr) {
  0x41b662		e819c20200		CALL runtime.morestack_noctxt(SB)	
  0x41b667		e9f4feffff		JMP runtime.(*gcWork).put(SB)		

TEXT runtime.(*gcWork).putBatch(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) putBatch(obj []uintptr) {
  0x41b670		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b679		483b6110		CMPQ 0x10(CX), SP	
  0x41b67d		0f86a8010000		JBE 0x41b82b		
  0x41b683		4883ec40		SUBQ $0x40, SP		
  0x41b687		48896c2438		MOVQ BP, 0x38(SP)	
  0x41b68c		488d6c2438		LEAQ 0x38(SP), BP	
	if len(obj) == 0 {
  0x41b691		488b442458		MOVQ 0x58(SP), AX	
  0x41b696		4885c0			TESTQ AX, AX		
  0x41b699		0f8474010000		JE 0x41b813		
	w.checkPut(0, obj)
  0x41b69f		90			NOPL			
	wbuf := w.wbuf1
  0x41b6a0		488b4c2448		MOVQ 0x48(SP), CX	
  0x41b6a5		488b11			MOVQ 0(CX), DX		
	if wbuf == nil {
  0x41b6a8		4885d2			TESTQ DX, DX		
  0x41b6ab		0f8447010000		JE 0x41b7f8		
	for len(obj) > 0 {
  0x41b6b1		488b5c2450		MOVQ 0x50(SP), BX	
  0x41b6b6		488b742460		MOVQ 0x60(SP), SI	
  0x41b6bb		31ff			XORL DI, DI		
  0x41b6bd		e9a8000000		JMP 0x41b76a		
			putfull(wbuf)
  0x41b6c2		48891424		MOVQ DX, 0(SP)			
  0x41b6c6		e8a5070000		CALL runtime.putfull(SB)	
			w.flushedWork = true
  0x41b6cb		488b442448		MOVQ 0x48(SP), AX	
  0x41b6d0		c6402001		MOVB $0x1, 0x20(AX)	
			w.wbuf1, w.wbuf2 = w.wbuf2, getempty()
  0x41b6d4		e807050000		CALL runtime.getempty(SB)	
  0x41b6d9		488b4c2448		MOVQ 0x48(SP), CX		
  0x41b6de		488b5108		MOVQ 0x8(CX), DX		
  0x41b6e2		488b0424		MOVQ 0(SP), AX			
  0x41b6e6		488911			MOVQ DX, 0(CX)			
  0x41b6e9		48894108		MOVQ AX, 0x8(CX)		
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b6ed		488b442458		MOVQ 0x58(SP), AX	
  0x41b6f2		488b5c2430		MOVQ 0x30(SP), BX	
		obj = obj[n:]
  0x41b6f7		488b742460		MOVQ 0x60(SP), SI	
  0x41b6fc		bf01000000		MOVL $0x1, DI		
		for wbuf.nobj == len(wbuf.obj) {
  0x41b701		4c8b4210		MOVQ 0x10(DX), R8	
  0x41b705		4981f8fd000000		CMPQ $0xfd, R8		
  0x41b70c		74b4			JE 0x41b6c2		
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b70e		0f8710010000		JA 0x41b824		
  0x41b714		4d8d8803ffffff		LEAQ 0xffffff03(R8), R9	
  0x41b71b		4d89ca			MOVQ R9, R10		
  0x41b71e		49f7d9			NEGQ R9			
  0x41b721		4939c1			CMPQ AX, R9		
  0x41b724		4c0f4fc8		CMOVG AX, R9		
  0x41b728		49c1fa3f		SARQ $0x3f, R10		
  0x41b72c		49c1e003		SHLQ $0x3, R8		
  0x41b730		4d21c2			ANDQ R8, R10		
  0x41b733		4e8d0412		LEAQ 0(DX)(R10*1), R8	
  0x41b737		4d8d4018		LEAQ 0x18(R8), R8	
  0x41b73b		4939d8			CMPQ BX, R8		
  0x41b73e		7540			JNE 0x41b780		
		wbuf.nobj += n
  0x41b740		4c014a10		ADDQ R9, 0x10(DX)	
		obj = obj[n:]
  0x41b744		4939c1			CMPQ AX, R9		
  0x41b747		0f87d0000000		JA 0x41b81d		
  0x41b74d		4c29c8			SUBQ R9, AX		
  0x41b750		4c29ce			SUBQ R9, SI		
  0x41b753		4989f0			MOVQ SI, R8		
  0x41b756		48f7de			NEGQ SI			
  0x41b759		49c1e103		SHLQ $0x3, R9		
  0x41b75d		48c1fe3f		SARQ $0x3f, SI		
  0x41b761		4c21ce			ANDQ R9, SI		
  0x41b764		4801f3			ADDQ SI, BX		
	for len(obj) > 0 {
  0x41b767		4c89c6			MOVQ R8, SI		
  0x41b76a		4885c0			TESTQ AX, AX		
  0x41b76d		7e5f			JLE 0x41b7ce		
  0x41b76f		4889742460		MOVQ SI, 0x60(SP)	
  0x41b774		4889442458		MOVQ AX, 0x58(SP)	
  0x41b779		48895c2430		MOVQ BX, 0x30(SP)	
		for wbuf.nobj == len(wbuf.obj) {
  0x41b77e		eb81			JMP 0x41b701		
  0x41b780		4889542428		MOVQ DX, 0x28(SP)	
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b785		4c894c2420		MOVQ R9, 0x20(SP)	
	if flushed && gcphase == _GCmark {
  0x41b78a		40887c241f		MOVB DI, 0x1f(SP)	
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b78f		4c890424		MOVQ R8, 0(SP)			
  0x41b793		48895c2408		MOVQ BX, 0x8(SP)		
  0x41b798		49c1e103		SHLQ $0x3, R9			
  0x41b79c		4c894c2410		MOVQ R9, 0x10(SP)		
  0x41b7a1		e8aaef0200		CALL runtime.memmove(SB)	
		obj = obj[n:]
  0x41b7a6		488b442458		MOVQ 0x58(SP), AX	
			w.flushedWork = true
  0x41b7ab		488b4c2448		MOVQ 0x48(SP), CX	
		wbuf.nobj += n
  0x41b7b0		488b542428		MOVQ 0x28(SP), DX	
		obj = obj[n:]
  0x41b7b5		488b5c2430		MOVQ 0x30(SP), BX	
  0x41b7ba		488b742460		MOVQ 0x60(SP), SI	
	if flushed && gcphase == _GCmark {
  0x41b7bf		0fb67c241f		MOVZX 0x1f(SP), DI	
		wbuf.nobj += n
  0x41b7c4		4c8b4c2420		MOVQ 0x20(SP), R9	
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b7c9		e972ffffff		JMP 0x41b740		
	if flushed && gcphase == _GCmark {
  0x41b7ce		4084ff			TESTL DI, DI			
  0x41b7d1		7409			JE 0x41b7dc			
  0x41b7d3		833d02150c0001		CMPL $0x1, runtime.gcphase(SB)	
  0x41b7da		740a			JE 0x41b7e6			
  0x41b7dc		488b6c2438		MOVQ 0x38(SP), BP		
  0x41b7e1		4883c440		ADDQ $0x40, SP			
  0x41b7e5		c3			RET				
		gcController.enlistWorker()
  0x41b7e6		488d0593190c00		LEAQ runtime.gcController(SB), AX			
  0x41b7ed		48890424		MOVQ AX, 0(SP)						
  0x41b7f1		e86a71ffff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x41b7f6		ebe4			JMP 0x41b7dc						
		w.init()
  0x41b7f8		48890c24		MOVQ CX, 0(SP)			
  0x41b7fc		e8effcffff		CALL runtime.(*gcWork).init(SB)	
		wbuf = w.wbuf1
  0x41b801		488b4c2448		MOVQ 0x48(SP), CX	
  0x41b806		488b11			MOVQ 0(CX), DX		
	for len(obj) > 0 {
  0x41b809		488b442458		MOVQ 0x58(SP), AX	
		wbuf = w.wbuf1
  0x41b80e		e99efeffff		JMP 0x41b6b1		
		return
  0x41b813		488b6c2438		MOVQ 0x38(SP), BP	
  0x41b818		4883c440		ADDQ $0x40, SP		
  0x41b81c		c3			RET			
		obj = obj[n:]
  0x41b81d		e82e680000		CALL runtime.panicslice(SB)	
  0x41b822		0f0b			UD2				
		n := copy(wbuf.obj[wbuf.nobj:], obj)
  0x41b824		e827680000		CALL runtime.panicslice(SB)	
  0x41b829		0f0b			UD2				
func (w *gcWork) putBatch(obj []uintptr) {
  0x41b82b		e850c00200		CALL runtime.morestack_noctxt(SB)	
  0x41b830		e93bfeffff		JMP runtime.(*gcWork).putBatch(SB)	

TEXT runtime.(*gcWork).tryGet(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) tryGet() uintptr {
  0x41b840		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b849		483b6110		CMPQ 0x10(CX), SP	
  0x41b84d		0f86c9000000		JBE 0x41b91c		
  0x41b853		4883ec20		SUBQ $0x20, SP		
  0x41b857		48896c2418		MOVQ BP, 0x18(SP)	
  0x41b85c		488d6c2418		LEAQ 0x18(SP), BP	
	wbuf := w.wbuf1
  0x41b861		488b442428		MOVQ 0x28(SP), AX	
  0x41b866		488b08			MOVQ 0(AX), CX		
	if wbuf == nil {
  0x41b869		4885c9			TESTQ CX, CX		
  0x41b86c		0f848d000000		JE 0x41b8ff		
	if wbuf.nobj == 0 {
  0x41b872		4883791000		CMPQ $0x0, 0x10(CX)	
  0x41b877		7515			JNE 0x41b88e		
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x41b879		488b4808		MOVQ 0x8(AX), CX	
  0x41b87d		488b10			MOVQ 0(AX), DX		
  0x41b880		488908			MOVQ CX, 0(AX)		
  0x41b883		48895008		MOVQ DX, 0x8(AX)	
		if wbuf.nobj == 0 {
  0x41b887		4883791000		CMPQ $0x0, 0x10(CX)	
  0x41b88c		7429			JE 0x41b8b7		
	wbuf.nobj--
  0x41b88e		488b4110		MOVQ 0x10(CX), AX	
  0x41b892		488d50ff		LEAQ -0x1(AX), DX	
  0x41b896		48895110		MOVQ DX, 0x10(CX)	
	return wbuf.obj[wbuf.nobj]
  0x41b89a		4881fafd000000		CMPQ $0xfd, DX		
  0x41b8a1		7372			JAE 0x41b915		
  0x41b8a3		488b44c110		MOVQ 0x10(CX)(AX*8), AX	
  0x41b8a8		4889442430		MOVQ AX, 0x30(SP)	
  0x41b8ad		488b6c2418		MOVQ 0x18(SP), BP	
  0x41b8b2		4883c420		ADDQ $0x20, SP		
  0x41b8b6		c3			RET			
		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
  0x41b8b7		48894c2410		MOVQ CX, 0x10(SP)	
			wbuf = trygetfull()
  0x41b8bc		e80f060000		CALL runtime.trygetfull(SB)	
  0x41b8c1		488b0424		MOVQ 0(SP), AX			
			if wbuf == nil {
  0x41b8c5		4885c0			TESTQ AX, AX		
  0x41b8c8		7422			JE 0x41b8ec		
			wbuf = trygetfull()
  0x41b8ca		4889442408		MOVQ AX, 0x8(SP)	
			putempty(owbuf)
  0x41b8cf		488b442410		MOVQ 0x10(SP), AX		
  0x41b8d4		48890424		MOVQ AX, 0(SP)			
  0x41b8d8		e833050000		CALL runtime.putempty(SB)	
			w.wbuf1 = wbuf
  0x41b8dd		488b4c2408		MOVQ 0x8(SP), CX	
  0x41b8e2		488b442428		MOVQ 0x28(SP), AX	
  0x41b8e7		488908			MOVQ CX, 0(AX)		
  0x41b8ea		eba2			JMP 0x41b88e		
				return 0
  0x41b8ec		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x41b8f5		488b6c2418		MOVQ 0x18(SP), BP	
  0x41b8fa		4883c420		ADDQ $0x20, SP		
  0x41b8fe		c3			RET			
		w.init()
  0x41b8ff		48890424		MOVQ AX, 0(SP)			
  0x41b903		e8e8fbffff		CALL runtime.(*gcWork).init(SB)	
		wbuf = w.wbuf1
  0x41b908		488b442428		MOVQ 0x28(SP), AX	
  0x41b90d		488b08			MOVQ 0(AX), CX		
  0x41b910		e95dffffff		JMP 0x41b872		
	return wbuf.obj[wbuf.nobj]
  0x41b915		e806660000		CALL runtime.panicindex(SB)	
  0x41b91a		0f0b			UD2				
func (w *gcWork) tryGet() uintptr {
  0x41b91c		e85fbf0200		CALL runtime.morestack_noctxt(SB)	
  0x41b921		e91affffff		JMP runtime.(*gcWork).tryGet(SB)	

TEXT runtime.(*gcWork).dispose(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) dispose() {
  0x41b930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41b939		483b6110		CMPQ 0x10(CX), SP	
  0x41b93d		0f86cb000000		JBE 0x41ba0e		
  0x41b943		4883ec10		SUBQ $0x10, SP		
  0x41b947		48896c2408		MOVQ BP, 0x8(SP)	
  0x41b94c		488d6c2408		LEAQ 0x8(SP), BP	
	if wbuf := w.wbuf1; wbuf != nil {
  0x41b951		488b442418		MOVQ 0x18(SP), AX	
  0x41b956		488b08			MOVQ 0(AX), CX		
  0x41b959		4885c9			TESTQ CX, CX		
  0x41b95c		7441			JE 0x41b99f		
		if wbuf.nobj == 0 {
  0x41b95e		4883791000		CMPQ $0x0, 0x10(CX)	
  0x41b963		0f858e000000		JNE 0x41b9f7		
			putempty(wbuf)
  0x41b969		48890c24		MOVQ CX, 0(SP)			
  0x41b96d		e89e040000		CALL runtime.putempty(SB)	
		w.wbuf1 = nil
  0x41b972		488b442418		MOVQ 0x18(SP), AX	
  0x41b977		48c70000000000		MOVQ $0x0, 0(AX)	
		wbuf = w.wbuf2
  0x41b97e		488b4808		MOVQ 0x8(AX), CX	
		if wbuf.nobj == 0 {
  0x41b982		4883791000		CMPQ $0x0, 0x10(CX)	
  0x41b987		755a			JNE 0x41b9e3		
			putempty(wbuf)
  0x41b989		48890c24		MOVQ CX, 0(SP)			
  0x41b98d		e87e040000		CALL runtime.putempty(SB)	
		w.wbuf2 = nil
  0x41b992		488b442418		MOVQ 0x18(SP), AX	
  0x41b997		48c7400800000000	MOVQ $0x0, 0x8(AX)	
	if w.bytesMarked != 0 {
  0x41b99f		488b4810		MOVQ 0x10(AX), CX	
  0x41b9a3		4885c9			TESTQ CX, CX		
  0x41b9a6		7414			JE 0x41b9bc		
		atomic.Xadd64(&work.bytesMarked, int64(w.bytesMarked))
  0x41b9a8		488d1551660a00		LEAQ runtime.work+128(SB), DX	
  0x41b9af		f0480fc10a		LOCK XADDQ CX, 0(DX)		
		w.bytesMarked = 0
  0x41b9b4		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	if w.scanWork != 0 {
  0x41b9bc		488b4818		MOVQ 0x18(AX), CX	
  0x41b9c0		4885c9			TESTQ CX, CX		
  0x41b9c3		7414			JE 0x41b9d9		
		atomic.Xaddint64(&gcController.scanWork, w.scanWork)
  0x41b9c5		488d15b4170c00		LEAQ runtime.gcController(SB), DX	
  0x41b9cc		f0480fc10a		LOCK XADDQ CX, 0(DX)			
		w.scanWork = 0
  0x41b9d1		48c7401800000000	MOVQ $0x0, 0x18(AX)	
  0x41b9d9		488b6c2408		MOVQ 0x8(SP), BP	
  0x41b9de		4883c410		ADDQ $0x10, SP		
  0x41b9e2		c3			RET			
			putfull(wbuf)
  0x41b9e3		48890c24		MOVQ CX, 0(SP)			
  0x41b9e7		e884040000		CALL runtime.putfull(SB)	
			w.flushedWork = true
  0x41b9ec		488b442418		MOVQ 0x18(SP), AX	
  0x41b9f1		c6402001		MOVB $0x1, 0x20(AX)	
  0x41b9f5		eb9b			JMP 0x41b992		
			putfull(wbuf)
  0x41b9f7		48890c24		MOVQ CX, 0(SP)			
  0x41b9fb		e870040000		CALL runtime.putfull(SB)	
			w.flushedWork = true
  0x41ba00		488b442418		MOVQ 0x18(SP), AX	
  0x41ba05		c6402001		MOVB $0x1, 0x20(AX)	
  0x41ba09		e964ffffff		JMP 0x41b972		
func (w *gcWork) dispose() {
  0x41ba0e		e86dbe0200		CALL runtime.morestack_noctxt(SB)	
  0x41ba13		e918ffffff		JMP runtime.(*gcWork).dispose(SB)	

TEXT runtime.(*gcWork).balance(SB) /usr/local/go/src/runtime/mgcwork.go
func (w *gcWork) balance() {
  0x41ba20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ba29		483b6110		CMPQ 0x10(CX), SP	
  0x41ba2d		0f86db000000		JBE 0x41bb0e		
  0x41ba33		4883ec18		SUBQ $0x18, SP		
  0x41ba37		48896c2410		MOVQ BP, 0x10(SP)	
  0x41ba3c		488d6c2410		LEAQ 0x10(SP), BP	
	if w.wbuf1 == nil {
  0x41ba41		488b442420		MOVQ 0x20(SP), AX	
  0x41ba46		488b08			MOVQ 0(AX), CX		
  0x41ba49		4885c9			TESTQ CX, CX		
  0x41ba4c		0f84a4000000		JE 0x41baf6		
	if wbuf := w.wbuf2; wbuf.nobj != 0 {
  0x41ba52		488b5008		MOVQ 0x8(AX), DX	
  0x41ba56		488b5a10		MOVQ 0x10(DX), BX	
  0x41ba5a		4885db			TESTQ BX, BX		
  0x41ba5d		745d			JE 0x41babc		
		w.checkPut(0, wbuf.obj[:wbuf.nobj])
  0x41ba5f		0f8ca2000000		JL 0x41bb07		
  0x41ba65		4881fbfd000000		CMPQ $0xfd, BX		
  0x41ba6c		0f8795000000		JA 0x41bb07		
  0x41ba72		90			NOPL			
		putfull(wbuf)
  0x41ba73		48891424		MOVQ DX, 0(SP)			
  0x41ba77		e8f4030000		CALL runtime.putfull(SB)	
		w.flushedWork = true
  0x41ba7c		488b442420		MOVQ 0x20(SP), AX	
  0x41ba81		c6402001		MOVB $0x1, 0x20(AX)	
		w.wbuf2 = getempty()
  0x41ba85		e856010000		CALL runtime.getempty(SB)	
  0x41ba8a		488b0424		MOVQ 0(SP), AX			
  0x41ba8e		488b4c2420		MOVQ 0x20(SP), CX		
  0x41ba93		48894108		MOVQ AX, 0x8(CX)		
	if gcphase == _GCmark {
  0x41ba97		833d3e120c0001		CMPL $0x1, runtime.gcphase(SB)	
  0x41ba9e		740a			JE 0x41baaa			
  0x41baa0		488b6c2410		MOVQ 0x10(SP), BP		
  0x41baa5		4883c418		ADDQ $0x18, SP			
  0x41baa9		c3			RET				
		gcController.enlistWorker()
  0x41baaa		488d05cf160c00		LEAQ runtime.gcController(SB), AX			
  0x41bab1		48890424		MOVQ AX, 0(SP)						
  0x41bab5		e8a66effff		CALL runtime.(*gcControllerState).enlistWorker(SB)	
  0x41baba		ebe4			JMP 0x41baa0						
	} else if wbuf := w.wbuf1; wbuf.nobj > 4 {
  0x41babc		488b5110		MOVQ 0x10(CX), DX	
  0x41bac0		4883fa04		CMPQ $0x4, DX		
  0x41bac4		7e26			JLE 0x41baec		
		w.checkPut(0, wbuf.obj[:wbuf.nobj])
  0x41bac6		4881fafd000000		CMPQ $0xfd, DX		
  0x41bacd		7731			JA 0x41bb00		
  0x41bacf		90			NOPL			
		w.wbuf1 = handoff(wbuf)
  0x41bad0		48890c24		MOVQ CX, 0(SP)			
  0x41bad4		e867040000		CALL runtime.handoff(SB)	
  0x41bad9		488b442408		MOVQ 0x8(SP), AX		
  0x41bade		488b4c2420		MOVQ 0x20(SP), CX		
  0x41bae3		488901			MOVQ AX, 0(CX)			
		w.flushedWork = true // handoff did putfull
  0x41bae6		c6412001		MOVB $0x1, 0x20(CX)	
	if gcphase == _GCmark {
  0x41baea		ebab			JMP 0x41ba97		
		return
  0x41baec		488b6c2410		MOVQ 0x10(SP), BP	
  0x41baf1		4883c418		ADDQ $0x18, SP		
  0x41baf5		c3			RET			
		return
  0x41baf6		488b6c2410		MOVQ 0x10(SP), BP	
  0x41bafb		4883c418		ADDQ $0x18, SP		
  0x41baff		c3			RET			
		w.checkPut(0, wbuf.obj[:wbuf.nobj])
  0x41bb00		e84b650000		CALL runtime.panicslice(SB)	
  0x41bb05		0f0b			UD2				
		w.checkPut(0, wbuf.obj[:wbuf.nobj])
  0x41bb07		e844650000		CALL runtime.panicslice(SB)	
  0x41bb0c		0f0b			UD2				
func (w *gcWork) balance() {
  0x41bb0e		e86dbd0200		CALL runtime.morestack_noctxt(SB)	
  0x41bb13		e908ffffff		JMP runtime.(*gcWork).balance(SB)	

TEXT runtime.(*workbuf).checknonempty(SB) /usr/local/go/src/runtime/mgcwork.go
func (b *workbuf) checknonempty() {
  0x41bb20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bb29		483b6110		CMPQ 0x10(CX), SP	
  0x41bb2d		763f			JBE 0x41bb6e		
  0x41bb2f		4883ec18		SUBQ $0x18, SP		
  0x41bb33		48896c2410		MOVQ BP, 0x10(SP)	
  0x41bb38		488d6c2410		LEAQ 0x10(SP), BP	
	if b.nobj == 0 {
  0x41bb3d		488b442420		MOVQ 0x20(SP), AX	
  0x41bb42		4883781000		CMPQ $0x0, 0x10(AX)	
  0x41bb47		740a			JE 0x41bb53		
  0x41bb49		488b6c2410		MOVQ 0x10(SP), BP	
  0x41bb4e		4883c418		ADDQ $0x18, SP		
  0x41bb52		c3			RET			
		throw("workbuf is empty")
  0x41bb53		488d057d450500		LEAQ 0x5457d(IP), AX	
  0x41bb5a		48890424		MOVQ AX, 0(SP)		
  0x41bb5e		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41bb67		e814790000		CALL runtime.throw(SB)	
  0x41bb6c		0f0b			UD2			
func (b *workbuf) checknonempty() {
  0x41bb6e		e80dbd0200		CALL runtime.morestack_noctxt(SB)		
  0x41bb73		ebab			JMP runtime.(*workbuf).checknonempty(SB)	

TEXT runtime.(*workbuf).checkempty(SB) /usr/local/go/src/runtime/mgcwork.go
func (b *workbuf) checkempty() {
  0x41bb80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bb89		483b6110		CMPQ 0x10(CX), SP	
  0x41bb8d		763f			JBE 0x41bbce		
  0x41bb8f		4883ec18		SUBQ $0x18, SP		
  0x41bb93		48896c2410		MOVQ BP, 0x10(SP)	
  0x41bb98		488d6c2410		LEAQ 0x10(SP), BP	
	if b.nobj != 0 {
  0x41bb9d		488b442420		MOVQ 0x20(SP), AX	
  0x41bba2		4883781000		CMPQ $0x0, 0x10(AX)	
  0x41bba7		750a			JNE 0x41bbb3		
  0x41bba9		488b6c2410		MOVQ 0x10(SP), BP	
  0x41bbae		4883c418		ADDQ $0x18, SP		
  0x41bbb2		c3			RET			
		throw("workbuf is not empty")
  0x41bbb3		488d05e34b0500		LEAQ 0x54be3(IP), AX	
  0x41bbba		48890424		MOVQ AX, 0(SP)		
  0x41bbbe		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41bbc7		e8b4780000		CALL runtime.throw(SB)	
  0x41bbcc		0f0b			UD2			
func (b *workbuf) checkempty() {
  0x41bbce		e8adbc0200		CALL runtime.morestack_noctxt(SB)	
  0x41bbd3		ebab			JMP runtime.(*workbuf).checkempty(SB)	

TEXT runtime.getempty(SB) /usr/local/go/src/runtime/mgcwork.go
func getempty() *workbuf {
  0x41bbe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bbe9		483b6110		CMPQ 0x10(CX), SP	
  0x41bbed		0f860a020000		JBE 0x41bdfd		
  0x41bbf3		4883ec58		SUBQ $0x58, SP		
  0x41bbf7		48896c2450		MOVQ BP, 0x50(SP)	
  0x41bbfc		488d6c2450		LEAQ 0x50(SP), BP	
	if work.empty != 0 {
  0x41bc01		48833d7f630a0000	CMPQ $0x0, runtime.work+8(SB)	
  0x41bc09		0f859d010000		JNE 0x41bdac			
  0x41bc0f		31c0			XORL AX, AX			
	if b == nil {
  0x41bc11		4885c0			TESTQ AX, AX		
  0x41bc14		0f859b000000		JNE 0x41bcb5		
  0x41bc1a		4889442428		MOVQ AX, 0x28(SP)	
		var s *mspan
  0x41bc1f		48c744242000000000	MOVQ $0x0, 0x20(SP)	
		if work.wbufSpans.free.first != nil {
  0x41bc28		48833da8630a0000	CMPQ $0x0, runtime.work+88(SB)	
  0x41bc30		0f850a010000		JNE 0x41bd40			
		if s == nil {
  0x41bc36		48837c242000		CMPQ $0x0, 0x20(SP)	
  0x41bc3c		0f8482000000		JE 0x41bcc4		
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x41bc42		31c9			XORL CX, CX		
		for i := uintptr(0); i+_WorkbufSize <= workbufAlloc; i += _WorkbufSize {
  0x41bc44		eb05			JMP 0x41bc4b		
  0x41bc46		488b4c2418		MOVQ 0x18(SP), CX	
  0x41bc4b		488d9100080000		LEAQ 0x800(CX), DX	
  0x41bc52		4881fa00800000		CMPQ $0x8000, DX	
  0x41bc59		775a			JA 0x41bcb5		
  0x41bc5b		48894c2410		MOVQ CX, 0x10(SP)	
  0x41bc60		4889542418		MOVQ DX, 0x18(SP)	
	return b
  0x41bc65		4889442438		MOVQ AX, 0x38(SP)	
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x41bc6a		488b442420		MOVQ 0x20(SP), AX	
	return s.startAddr
  0x41bc6f		488b5018		MOVQ 0x18(AX), DX	
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x41bc73		4801ca			ADDQ CX, DX		
  0x41bc76		4889542430		MOVQ DX, 0x30(SP)	
	return s.startAddr
  0x41bc7b		8400			TESTB AL, 0(AX)		
			newb := (*workbuf)(unsafe.Pointer(s.base() + i))
  0x41bc7d		90			NOPL			
			newb.nobj = 0
  0x41bc7e		48c7421000000000	MOVQ $0x0, 0x10(DX)	
			lfnodeValidate(&newb.node)
  0x41bc86		48891424		MOVQ DX, 0(SP)			
  0x41bc8a		e891c9feff		CALL runtime.lfnodeValidate(SB)	
			if i == 0 {
  0x41bc8f		488b442410		MOVQ 0x10(SP), AX	
  0x41bc94		4885c0			TESTQ AX, AX		
  0x41bc97		7507			JNE 0x41bca0		
	return b
  0x41bc99		488b442430		MOVQ 0x30(SP), AX	
				b = newb
  0x41bc9e		eba6			JMP 0x41bc46		
				putempty(newb)
  0x41bca0		488b442430		MOVQ 0x30(SP), AX		
  0x41bca5		48890424		MOVQ AX, 0(SP)			
  0x41bca9		e862010000		CALL runtime.putempty(SB)	
	return b
  0x41bcae		488b442438		MOVQ 0x38(SP), AX	
				putempty(newb)
  0x41bcb3		eb91			JMP 0x41bc46		
	return b
  0x41bcb5		4889442460		MOVQ AX, 0x60(SP)	
  0x41bcba		488b6c2450		MOVQ 0x50(SP), BP	
  0x41bcbf		4883c458		ADDQ $0x58, SP		
  0x41bcc3		c3			RET			
			systemstack(func() {
  0x41bcc4		0f57c0			XORPS X0, X0				
  0x41bcc7		0f11442440		MOVUPS X0, 0x40(SP)			
  0x41bccc		488d055d980200		LEAQ runtime.getempty.func1(SB), AX	
  0x41bcd3		4889442440		MOVQ AX, 0x40(SP)			
  0x41bcd8		488d442420		LEAQ 0x20(SP), AX			
  0x41bcdd		4889442448		MOVQ AX, 0x48(SP)			
  0x41bce2		488d442440		LEAQ 0x40(SP), AX			
  0x41bce7		48890424		MOVQ AX, 0(SP)				
  0x41bceb		e840ba0200		CALL runtime.systemstack(SB)		
			if s == nil {
  0x41bcf0		48837c242000		CMPQ $0x0, 0x20(SP)	
  0x41bcf6		0f84e6000000		JE 0x41bde2		
			lock(&work.wbufSpans.lock)
  0x41bcfc		488d05cd620a00		LEAQ runtime.work+80(SB), AX	
  0x41bd03		48890424		MOVQ AX, 0(SP)			
  0x41bd07		e8d4c9feff		CALL runtime.lock(SB)		
			work.wbufSpans.busy.insert(s)
  0x41bd0c		488d05d5620a00		LEAQ runtime.work+104(SB), AX		
  0x41bd13		48890424		MOVQ AX, 0(SP)				
  0x41bd17		488b442420		MOVQ 0x20(SP), AX			
  0x41bd1c		4889442408		MOVQ AX, 0x8(SP)			
  0x41bd21		e81a2d0000		CALL runtime.(*mSpanList).insert(SB)	
			unlock(&work.wbufSpans.lock)
  0x41bd26		488d05a3620a00		LEAQ runtime.work+80(SB), AX	
  0x41bd2d		48890424		MOVQ AX, 0(SP)			
  0x41bd31		e85acbfeff		CALL runtime.unlock(SB)		
	return b
  0x41bd36		488b442428		MOVQ 0x28(SP), AX	
			unlock(&work.wbufSpans.lock)
  0x41bd3b		e902ffffff		JMP 0x41bc42		
			lock(&work.wbufSpans.lock)
  0x41bd40		488d0589620a00		LEAQ runtime.work+80(SB), AX	
  0x41bd47		48890424		MOVQ AX, 0(SP)			
  0x41bd4b		e890c9feff		CALL runtime.lock(SB)		
			s = work.wbufSpans.free.first
  0x41bd50		488b0581620a00		MOVQ runtime.work+88(SB), AX	
  0x41bd57		4889442420		MOVQ AX, 0x20(SP)		
			if s != nil {
  0x41bd5c		4885c0			TESTQ AX, AX		
  0x41bd5f		751a			JNE 0x41bd7b		
			unlock(&work.wbufSpans.lock)
  0x41bd61		488d0568620a00		LEAQ runtime.work+80(SB), AX	
  0x41bd68		48890424		MOVQ AX, 0(SP)			
  0x41bd6c		e81fcbfeff		CALL runtime.unlock(SB)		
	return b
  0x41bd71		488b442428		MOVQ 0x28(SP), AX	
			unlock(&work.wbufSpans.lock)
  0x41bd76		e9bbfeffff		JMP 0x41bc36		
				work.wbufSpans.free.remove(s)
  0x41bd7b		488d0d56620a00		LEAQ runtime.work+88(SB), CX		
  0x41bd82		48890c24		MOVQ CX, 0(SP)				
  0x41bd86		4889442408		MOVQ AX, 0x8(SP)			
  0x41bd8b		e8202b0000		CALL runtime.(*mSpanList).remove(SB)	
				work.wbufSpans.busy.insert(s)
  0x41bd90		488d0551620a00		LEAQ runtime.work+104(SB), AX		
  0x41bd97		48890424		MOVQ AX, 0(SP)				
  0x41bd9b		488b442420		MOVQ 0x20(SP), AX			
  0x41bda0		4889442408		MOVQ AX, 0x8(SP)			
  0x41bda5		e8962c0000		CALL runtime.(*mSpanList).insert(SB)	
  0x41bdaa		ebb5			JMP 0x41bd61				
		b = (*workbuf)(work.empty.pop())
  0x41bdac		488d05d5610a00		LEAQ runtime.work+8(SB), AX	
  0x41bdb3		48890424		MOVQ AX, 0(SP)			
  0x41bdb7		e824c8feff		CALL runtime.(*lfstack).pop(SB)	
  0x41bdbc		488b442408		MOVQ 0x8(SP), AX		
		if b != nil {
  0x41bdc1		4885c0			TESTQ AX, AX		
  0x41bdc4		0f8447feffff		JE 0x41bc11		
		b = (*workbuf)(work.empty.pop())
  0x41bdca		4889442430		MOVQ AX, 0x30(SP)	
			b.checkempty()
  0x41bdcf		48890424		MOVQ AX, 0(SP)				
  0x41bdd3		e8a8fdffff		CALL runtime.(*workbuf).checkempty(SB)	
	if b == nil {
  0x41bdd8		488b442430		MOVQ 0x30(SP), AX	
			b.checkempty()
  0x41bddd		e92ffeffff		JMP 0x41bc11		
				throw("out of memory")
  0x41bde2		488d05b23e0500		LEAQ 0x53eb2(IP), AX	
  0x41bde9		48890424		MOVQ AX, 0(SP)		
  0x41bded		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x41bdf6		e885760000		CALL runtime.throw(SB)	
  0x41bdfb		0f0b			UD2			
func getempty() *workbuf {
  0x41bdfd		e87eba0200		CALL runtime.morestack_noctxt(SB)	
  0x41be02		e9d9fdffff		JMP runtime.getempty(SB)		

TEXT runtime.putempty(SB) /usr/local/go/src/runtime/mgcwork.go
func putempty(b *workbuf) {
  0x41be10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41be19		483b6110		CMPQ 0x10(CX), SP	
  0x41be1d		7642			JBE 0x41be61		
  0x41be1f		4883ec18		SUBQ $0x18, SP		
  0x41be23		48896c2410		MOVQ BP, 0x10(SP)	
  0x41be28		488d6c2410		LEAQ 0x10(SP), BP	
	b.checkempty()
  0x41be2d		488b442420		MOVQ 0x20(SP), AX			
  0x41be32		48890424		MOVQ AX, 0(SP)				
  0x41be36		e845fdffff		CALL runtime.(*workbuf).checkempty(SB)	
	work.empty.push(&b.node)
  0x41be3b		488b442420		MOVQ 0x20(SP), AX			
  0x41be40		8400			TESTB AL, 0(AX)				
  0x41be42		488d0d3f610a00		LEAQ runtime.work+8(SB), CX		
  0x41be49		48890c24		MOVQ CX, 0(SP)				
  0x41be4d		4889442408		MOVQ AX, 0x8(SP)			
  0x41be52		e829c6feff		CALL runtime.(*lfstack).push(SB)	
}
  0x41be57		488b6c2410		MOVQ 0x10(SP), BP	
  0x41be5c		4883c418		ADDQ $0x18, SP		
  0x41be60		c3			RET			
func putempty(b *workbuf) {
  0x41be61		e81aba0200		CALL runtime.morestack_noctxt(SB)	
  0x41be66		eba8			JMP runtime.putempty(SB)		

TEXT runtime.putfull(SB) /usr/local/go/src/runtime/mgcwork.go
func putfull(b *workbuf) {
  0x41be70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41be79		483b6110		CMPQ 0x10(CX), SP	
  0x41be7d		7642			JBE 0x41bec1		
  0x41be7f		4883ec18		SUBQ $0x18, SP		
  0x41be83		48896c2410		MOVQ BP, 0x10(SP)	
  0x41be88		488d6c2410		LEAQ 0x10(SP), BP	
	b.checknonempty()
  0x41be8d		488b442420		MOVQ 0x20(SP), AX				
  0x41be92		48890424		MOVQ AX, 0(SP)					
  0x41be96		e885fcffff		CALL runtime.(*workbuf).checknonempty(SB)	
	work.full.push(&b.node)
  0x41be9b		488b442420		MOVQ 0x20(SP), AX			
  0x41bea0		8400			TESTB AL, 0(AX)				
  0x41bea2		488d0dd7600a00		LEAQ runtime.work(SB), CX		
  0x41bea9		48890c24		MOVQ CX, 0(SP)				
  0x41bead		4889442408		MOVQ AX, 0x8(SP)			
  0x41beb2		e8c9c5feff		CALL runtime.(*lfstack).push(SB)	
}
  0x41beb7		488b6c2410		MOVQ 0x10(SP), BP	
  0x41bebc		4883c418		ADDQ $0x18, SP		
  0x41bec0		c3			RET			
func putfull(b *workbuf) {
  0x41bec1		e8bab90200		CALL runtime.morestack_noctxt(SB)	
  0x41bec6		eba8			JMP runtime.putfull(SB)			

TEXT runtime.trygetfull(SB) /usr/local/go/src/runtime/mgcwork.go
func trygetfull() *workbuf {
  0x41bed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bed9		483b6110		CMPQ 0x10(CX), SP	
  0x41bedd		7659			JBE 0x41bf38		
  0x41bedf		4883ec20		SUBQ $0x20, SP		
  0x41bee3		48896c2418		MOVQ BP, 0x18(SP)	
  0x41bee8		488d6c2418		LEAQ 0x18(SP), BP	
	b := (*workbuf)(work.full.pop())
  0x41beed		488d058c600a00		LEAQ runtime.work(SB), AX	
  0x41bef4		48890424		MOVQ AX, 0(SP)			
  0x41bef8		e8e3c6feff		CALL runtime.(*lfstack).pop(SB)	
  0x41befd		488b442408		MOVQ 0x8(SP), AX		
	if b != nil {
  0x41bf02		4885c0			TESTQ AX, AX		
  0x41bf05		7422			JE 0x41bf29		
	b := (*workbuf)(work.full.pop())
  0x41bf07		4889442410		MOVQ AX, 0x10(SP)	
		b.checknonempty()
  0x41bf0c		48890424		MOVQ AX, 0(SP)					
  0x41bf10		e80bfcffff		CALL runtime.(*workbuf).checknonempty(SB)	
		return b
  0x41bf15		488b442410		MOVQ 0x10(SP), AX	
  0x41bf1a		4889442428		MOVQ AX, 0x28(SP)	
  0x41bf1f		488b6c2418		MOVQ 0x18(SP), BP	
  0x41bf24		4883c420		ADDQ $0x20, SP		
  0x41bf28		c3			RET			
	return b
  0x41bf29		4889442428		MOVQ AX, 0x28(SP)	
  0x41bf2e		488b6c2418		MOVQ 0x18(SP), BP	
  0x41bf33		4883c420		ADDQ $0x20, SP		
  0x41bf37		c3			RET			
func trygetfull() *workbuf {
  0x41bf38		e843b90200		CALL runtime.morestack_noctxt(SB)	
  0x41bf3d		eb91			JMP runtime.trygetfull(SB)		

TEXT runtime.handoff(SB) /usr/local/go/src/runtime/mgcwork.go
func handoff(b *workbuf) *workbuf {
  0x41bf40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41bf49		483b6110		CMPQ 0x10(CX), SP	
  0x41bf4d		0f8696000000		JBE 0x41bfe9		
  0x41bf53		4883ec28		SUBQ $0x28, SP		
  0x41bf57		48896c2420		MOVQ BP, 0x20(SP)	
  0x41bf5c		488d6c2420		LEAQ 0x20(SP), BP	
	b1 := getempty()
  0x41bf61		e87afcffff		CALL runtime.getempty(SB)	
  0x41bf66		488b0424		MOVQ 0(SP), AX			
	n := b.nobj / 2
  0x41bf6a		488b4c2430		MOVQ 0x30(SP), CX	
  0x41bf6f		488b5110		MOVQ 0x10(CX), DX	
  0x41bf73		4889d3			MOVQ DX, BX		
  0x41bf76		48c1ea3f		SHRQ $0x3f, DX		
  0x41bf7a		4801da			ADDQ BX, DX		
  0x41bf7d		48d1fa			SARQ $0x1, DX		
	b.nobj -= n
  0x41bf80		4829d3			SUBQ DX, BX		
  0x41bf83		48895910		MOVQ BX, 0x10(CX)	
	b1.nobj = n
  0x41bf87		48895010		MOVQ DX, 0x10(AX)	
	memmove(unsafe.Pointer(&b1.obj[0]), unsafe.Pointer(&b.obj[b.nobj]), uintptr(n)*unsafe.Sizeof(b1.obj[0]))
  0x41bf8b		488b5910		MOVQ 0x10(CX), BX	
  0x41bf8f		4881fbfd000000		CMPQ $0xfd, BX		
  0x41bf96		734a			JAE 0x41bfe2		
	b1 := getempty()
  0x41bf98		4889442418		MOVQ AX, 0x18(SP)	
	memmove(unsafe.Pointer(&b1.obj[0]), unsafe.Pointer(&b.obj[b.nobj]), uintptr(n)*unsafe.Sizeof(b1.obj[0]))
  0x41bf9d		488d7018		LEAQ 0x18(AX), SI		
  0x41bfa1		48893424		MOVQ SI, 0(SP)			
  0x41bfa5		488d1cd9		LEAQ 0(CX)(BX*8), BX		
  0x41bfa9		488d5b18		LEAQ 0x18(BX), BX		
  0x41bfad		48895c2408		MOVQ BX, 0x8(SP)		
  0x41bfb2		48c1e203		SHLQ $0x3, DX			
  0x41bfb6		4889542410		MOVQ DX, 0x10(SP)		
  0x41bfbb		e890e70200		CALL runtime.memmove(SB)	
	putfull(b)
  0x41bfc0		488b442430		MOVQ 0x30(SP), AX		
  0x41bfc5		48890424		MOVQ AX, 0(SP)			
  0x41bfc9		e8a2feffff		CALL runtime.putfull(SB)	
	return b1
  0x41bfce		488b442418		MOVQ 0x18(SP), AX	
  0x41bfd3		4889442438		MOVQ AX, 0x38(SP)	
  0x41bfd8		488b6c2420		MOVQ 0x20(SP), BP	
  0x41bfdd		4883c428		ADDQ $0x28, SP		
  0x41bfe1		c3			RET			
	memmove(unsafe.Pointer(&b1.obj[0]), unsafe.Pointer(&b.obj[b.nobj]), uintptr(n)*unsafe.Sizeof(b1.obj[0]))
  0x41bfe2		e8395f0000		CALL runtime.panicindex(SB)	
  0x41bfe7		0f0b			UD2				
func handoff(b *workbuf) *workbuf {
  0x41bfe9		e892b80200		CALL runtime.morestack_noctxt(SB)	
  0x41bfee		e94dffffff		JMP runtime.handoff(SB)			

TEXT runtime.prepareFreeWorkbufs(SB) /usr/local/go/src/runtime/mgcwork.go
func prepareFreeWorkbufs() {
  0x41c000		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c009		483b6110		CMPQ 0x10(CX), SP	
  0x41c00d		0f8684000000		JBE 0x41c097		
  0x41c013		4883ec18		SUBQ $0x18, SP		
  0x41c017		48896c2410		MOVQ BP, 0x10(SP)	
  0x41c01c		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&work.wbufSpans.lock)
  0x41c021		488d05a85f0a00		LEAQ runtime.work+80(SB), AX	
  0x41c028		48890424		MOVQ AX, 0(SP)			
  0x41c02c		e8afc6feff		CALL runtime.lock(SB)		
	if work.full != 0 {
  0x41c031		48833d475f0a0000	CMPQ $0x0, runtime.work(SB)	
  0x41c039		7541			JNE 0x41c07c			
	work.empty = 0
  0x41c03b		48c705425f0a0000000000	MOVQ $0x0, runtime.work+8(SB)	
	work.wbufSpans.free.takeAll(&work.wbufSpans.busy)
  0x41c046		488d058b5f0a00		LEAQ runtime.work+88(SB), AX		
  0x41c04d		48890424		MOVQ AX, 0(SP)				
  0x41c051		488d05905f0a00		LEAQ runtime.work+104(SB), AX		
  0x41c058		4889442408		MOVQ AX, 0x8(SP)			
  0x41c05d		e81e2c0000		CALL runtime.(*mSpanList).takeAll(SB)	
	unlock(&work.wbufSpans.lock)
  0x41c062		488d05675f0a00		LEAQ runtime.work+80(SB), AX	
  0x41c069		48890424		MOVQ AX, 0(SP)			
  0x41c06d		e81ec8feff		CALL runtime.unlock(SB)		
}
  0x41c072		488b6c2410		MOVQ 0x10(SP), BP	
  0x41c077		4883c418		ADDQ $0x18, SP		
  0x41c07b		c3			RET			
		throw("cannot free workbufs when work.full != 0")
  0x41c07c		488d05c7680500		LEAQ 0x568c7(IP), AX	
  0x41c083		48890424		MOVQ AX, 0(SP)		
  0x41c087		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x41c090		e8eb730000		CALL runtime.throw(SB)	
  0x41c095		0f0b			UD2			
func prepareFreeWorkbufs() {
  0x41c097		e8e4b70200		CALL runtime.morestack_noctxt(SB)	
  0x41c09c		e95fffffff		JMP runtime.prepareFreeWorkbufs(SB)	

TEXT runtime.freeSomeWbufs(SB) /usr/local/go/src/runtime/mgcwork.go
func freeSomeWbufs(preemptible bool) bool {
  0x41c0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c0b9		483b6110		CMPQ 0x10(CX), SP	
  0x41c0bd		0f86bb000000		JBE 0x41c17e		
  0x41c0c3		4883ec28		SUBQ $0x28, SP		
  0x41c0c7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41c0cc		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&work.wbufSpans.lock)
  0x41c0d1		488d05f85e0a00		LEAQ runtime.work+80(SB), AX	
  0x41c0d8		48890424		MOVQ AX, 0(SP)			
  0x41c0dc		e8ffc5feff		CALL runtime.lock(SB)		
	if gcphase != _GCoff || work.wbufSpans.free.isEmpty() {
  0x41c0e1		833df40b0c0000		CMPL $0x0, runtime.gcphase(SB)	
  0x41c0e8		741f			JE 0x41c109			
		unlock(&work.wbufSpans.lock)
  0x41c0ea		488d05df5e0a00		LEAQ runtime.work+80(SB), AX	
  0x41c0f1		48890424		MOVQ AX, 0(SP)			
  0x41c0f5		e896c7feff		CALL runtime.unlock(SB)		
		return false
  0x41c0fa		c644243800		MOVB $0x0, 0x38(SP)	
  0x41c0ff		488b6c2420		MOVQ 0x20(SP), BP	
  0x41c104		4883c428		ADDQ $0x28, SP		
  0x41c108		c3			RET			
	if gcphase != _GCoff || work.wbufSpans.free.isEmpty() {
  0x41c109		90			NOPL			
	return list.first == nil
  0x41c10a		48833dc65e0a0000	CMPQ $0x0, runtime.work+88(SB)	
	if gcphase != _GCoff || work.wbufSpans.free.isEmpty() {
  0x41c112		74d6			JE 0x41c0ea		
	systemstack(func() {
  0x41c114		48c744241000000000	MOVQ $0x0, 0x10(SP)				
  0x41c11d		c644241800		MOVB $0x0, 0x18(SP)				
  0x41c122		488d0577940200		LEAQ runtime.freeSomeWbufs.func1(SB), AX	
  0x41c129		4889442410		MOVQ AX, 0x10(SP)				
  0x41c12e		0fb6442430		MOVZX 0x30(SP), AX				
  0x41c133		88442418		MOVB AL, 0x18(SP)				
  0x41c137		488d442410		LEAQ 0x10(SP), AX				
  0x41c13c		48890424		MOVQ AX, 0(SP)					
  0x41c140		e8ebb50200		CALL runtime.systemstack(SB)			
	more := !work.wbufSpans.free.isEmpty()
  0x41c145		90			NOPL			
	return list.first == nil
  0x41c146		488b058b5e0a00		MOVQ runtime.work+88(SB), AX	
  0x41c14d		4889442408		MOVQ AX, 0x8(SP)		
  0x41c152		4883f800		CMPQ $0x0, AX			
	unlock(&work.wbufSpans.lock)
  0x41c156		488d0d735e0a00		LEAQ runtime.work+80(SB), CX	
  0x41c15d		48890c24		MOVQ CX, 0(SP)			
  0x41c161		e82ac7feff		CALL runtime.unlock(SB)		
	return list.first == nil
  0x41c166		488b442408		MOVQ 0x8(SP), AX	
  0x41c16b		4883f800		CMPQ $0x0, AX		
	return more
  0x41c16f		0f95442438		SETNE 0x38(SP)		
  0x41c174		488b6c2420		MOVQ 0x20(SP), BP	
  0x41c179		4883c428		ADDQ $0x28, SP		
  0x41c17d		c3			RET			
func freeSomeWbufs(preemptible bool) bool {
  0x41c17e		e8fdb60200		CALL runtime.morestack_noctxt(SB)	
  0x41c183		e928ffffff		JMP runtime.freeSomeWbufs(SB)		

TEXT runtime.(*mheap).coalesce(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) coalesce(s *mspan) {
  0x41c190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c199		483b6110		CMPQ 0x10(CX), SP	
  0x41c19d		0f864c020000		JBE 0x41c3ef		
  0x41c1a3		4883ec68		SUBQ $0x68, SP		
  0x41c1a7		48896c2460		MOVQ BP, 0x60(SP)	
  0x41c1ac		488d6c2460		LEAQ 0x60(SP), BP	
	needsScavenge := false
  0x41c1b1		c644241f00		MOVB $0x0, 0x1f(SP)	
	prescavenged := s.released() // number of bytes already scavenged.
  0x41c1b6		90			NOPL			
	if !s.scavenged {
  0x41c1b7		488b442478		MOVQ 0x78(SP), AX	
  0x41c1bc		80786700		CMPB $0x0, 0x67(AX)	
  0x41c1c0		0f8422020000		JE 0x41c3e8		
	start, end := s.physPageBounds()
  0x41c1c6		90			NOPL			
	start := s.base()
  0x41c1c7		90			NOPL			
	end := start + s.npages<<_PageShift
  0x41c1c8		488b4820		MOVQ 0x20(AX), CX	
  0x41c1cc		48c1e10d		SHLQ $0xd, CX		
	return s.startAddr
  0x41c1d0		488b5818		MOVQ 0x18(AX), BX	
	end := start + s.npages<<_PageShift
  0x41c1d4		4801d9			ADDQ BX, CX		
	if physPageSize > _PageSize {
  0x41c1d7		488b35ca0b0c00		MOVQ runtime.physPageSize(SB), SI	
  0x41c1de		4881fe00200000		CMPQ $0x2000, SI			
  0x41c1e5		0f86f5010000		JBE 0x41c3e0				
		start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41c1eb		488d1c33		LEAQ 0(BX)(SI*1), BX	
  0x41c1ef		488d5bff		LEAQ -0x1(BX), BX	
  0x41c1f3		48ffce			DECQ SI			
  0x41c1f6		48f7d6			NOTQ SI			
  0x41c1f9		4821f3			ANDQ SI, BX		
		end &^= physPageSize - 1
  0x41c1fc		4821ce			ANDQ CX, SI		
	return end - start
  0x41c1ff		4829de			SUBQ BX, SI		
	prescavenged := s.released() // number of bytes already scavenged.
  0x41c202		4889742420		MOVQ SI, 0x20(SP)	
	merge := func(other *mspan) {
  0x41c207		48c744243800000000	MOVQ $0x0, 0x38(SP)				
  0x41c210		0f57c0			XORPS X0, X0					
  0x41c213		0f11442440		MOVUPS X0, 0x40(SP)				
  0x41c218		0f11442450		MOVUPS X0, 0x50(SP)				
  0x41c21d		488d0d6c940200		LEAQ runtime.(*mheap).coalesce.func1(SB), CX	
  0x41c224		48894c2438		MOVQ CX, 0x38(SP)				
  0x41c229		4889442440		MOVQ AX, 0x40(SP)				
  0x41c22e		488b4c2470		MOVQ 0x70(SP), CX				
  0x41c233		48894c2448		MOVQ CX, 0x48(SP)				
  0x41c238		488d5c241f		LEAQ 0x1f(SP), BX				
  0x41c23d		48895c2450		MOVQ BX, 0x50(SP)				
  0x41c242		488d5c2420		LEAQ 0x20(SP), BX				
  0x41c247		48895c2458		MOVQ BX, 0x58(SP)				
	realign := func(a, b, other *mspan) {
  0x41c24c		0f11442428		MOVUPS X0, 0x28(SP)				
  0x41c251		488d1d58960200		LEAQ runtime.(*mheap).coalesce.func2(SB), BX	
  0x41c258		48895c2428		MOVQ BX, 0x28(SP)				
  0x41c25d		48894c2430		MOVQ CX, 0x30(SP)				
	if before := spanOf(s.base() - 1); before != nil && before.state == mSpanFree {
  0x41c262		90			NOPL			
  0x41c263		90			NOPL			
	return s.startAddr
  0x41c264		488b4818		MOVQ 0x18(AX), CX	
	ri := arenaIndex(p)
  0x41c268		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c269		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41c26a		48bbffffffffff7f0000	MOVQ $0x7fffffffffff, BX	
  0x41c274		4801cb			ADDQ CX, BX			
  0x41c277		48c1eb1a		SHRQ $0x1a, BX			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c27b		4881fb00004000		CMPQ $0x400000, BX	
  0x41c282		0f8221010000		JB 0x41c3a9		
  0x41c288		31c9			XORL CX, CX		
	if before := spanOf(s.base() - 1); before != nil && before.state == mSpanFree {
  0x41c28a		4885c9			TESTQ CX, CX		
  0x41c28d		7423			JE 0x41c2b2		
  0x41c28f		80796303		CMPB $0x3, 0x63(CX)	
  0x41c293		751d			JNE 0x41c2b2		
		if s.scavenged == before.scavenged {
  0x41c295		0fb65867		MOVZX 0x67(AX), BX	
  0x41c299		385967			CMPB BL, 0x67(CX)	
  0x41c29c		0f85e8000000		JNE 0x41c38a		
			merge(before)
  0x41c2a2		48890c24		MOVQ CX, 0(SP)		
  0x41c2a6		488b442438		MOVQ 0x38(SP), AX	
  0x41c2ab		488d542438		LEAQ 0x38(SP), DX	
  0x41c2b0		ffd0			CALL AX			
	if after := spanOf(s.base() + s.npages*pageSize); after != nil && after.state == mSpanFree {
  0x41c2b2		90			NOPL			
  0x41c2b3		90			NOPL			
  0x41c2b4		488b442478		MOVQ 0x78(SP), AX	
  0x41c2b9		488b4820		MOVQ 0x20(AX), CX	
  0x41c2bd		48c1e10d		SHLQ $0xd, CX		
  0x41c2c1		48034818		ADDQ 0x18(AX), CX	
	ri := arenaIndex(p)
  0x41c2c5		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c2c6		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41c2c7		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x41c2d1		4801cb			ADDQ CX, BX			
  0x41c2d4		48c1eb1a		SHRQ $0x1a, BX			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c2d8		4881fb00004000		CMPQ $0x400000, BX	
  0x41c2df		7276			JB 0x41c357		
  0x41c2e1		31c9			XORL CX, CX		
	if after := spanOf(s.base() + s.npages*pageSize); after != nil && after.state == mSpanFree {
  0x41c2e3		4885c9			TESTQ CX, CX		
  0x41c2e6		741f			JE 0x41c307		
  0x41c2e8		80796303		CMPB $0x3, 0x63(CX)	
  0x41c2ec		7519			JNE 0x41c307		
		if s.scavenged == after.scavenged {
  0x41c2ee		0fb65867		MOVZX 0x67(AX), BX	
  0x41c2f2		385967			CMPB BL, 0x67(CX)	
  0x41c2f5		7544			JNE 0x41c33b		
			merge(after)
  0x41c2f7		48890c24		MOVQ CX, 0(SP)		
  0x41c2fb		488b442438		MOVQ 0x38(SP), AX	
  0x41c300		488d542438		LEAQ 0x38(SP), DX	
  0x41c305		ffd0			CALL AX			
	if needsScavenge {
  0x41c307		807c241f00		CMPB $0x0, 0x1f(SP)	
  0x41c30c		750a			JNE 0x41c318		
  0x41c30e		488b6c2460		MOVQ 0x60(SP), BP	
  0x41c313		4883c468		ADDQ $0x68, SP		
  0x41c317		c3			RET			
		memstats.heap_released -= uint64(prescavenged)
  0x41c318		488b0591190c00		MOVQ runtime.memstats+80(SB), AX	
  0x41c31f		482b442420		SUBQ 0x20(SP), AX			
  0x41c324		48890585190c00		MOVQ AX, runtime.memstats+80(SB)	
		s.scavenge()
  0x41c32b		488b442478		MOVQ 0x78(SP), AX			
  0x41c330		48890424		MOVQ AX, 0(SP)				
  0x41c334		e8c7000000		CALL runtime.(*mspan).scavenge(SB)	
  0x41c339		ebd3			JMP 0x41c30e				
			realign(s, after, after)
  0x41c33b		48890424		MOVQ AX, 0(SP)		
  0x41c33f		48894c2408		MOVQ CX, 0x8(SP)	
  0x41c344		48894c2410		MOVQ CX, 0x10(SP)	
  0x41c349		488b4c2428		MOVQ 0x28(SP), CX	
  0x41c34e		488d542428		LEAQ 0x28(SP), DX	
  0x41c353		ffd1			CALL CX			
  0x41c355		ebb0			JMP 0x41c307		
	l2 := mheap_.arenas[ri.l1()]
  0x41c357		488b35f2a50a00		MOVQ runtime.mheap_+784(SB), SI	
	ha := l2[ri.l2()]
  0x41c35e		8406			TESTB AL, 0(SI)		
	l2 := mheap_.arenas[ri.l1()]
  0x41c360		90			NOPL			
	ha := l2[ri.l2()]
  0x41c361		488b1cde		MOVQ 0(SI)(BX*8), BX	
  0x41c365		90			NOPL			
	if ha == nil {
  0x41c366		4885db			TESTQ BX, BX		
  0x41c369		7418			JE 0x41c383		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x41c36b		48c1e90d		SHRQ $0xd, CX			
  0x41c36f		4881e1ff1f0000		ANDQ $0x1fff, CX		
  0x41c376		488b8ccb00002000	MOVQ 0x200000(BX)(CX*8), CX	
	if after := spanOf(s.base() + s.npages*pageSize); after != nil && after.state == mSpanFree {
  0x41c37e		e960ffffff		JMP 0x41c2e3		
  0x41c383		31c9			XORL CX, CX		
  0x41c385		e959ffffff		JMP 0x41c2e3		
			realign(before, s, before)
  0x41c38a		48890c24		MOVQ CX, 0(SP)		
  0x41c38e		4889442408		MOVQ AX, 0x8(SP)	
  0x41c393		48894c2410		MOVQ CX, 0x10(SP)	
  0x41c398		488b4c2428		MOVQ 0x28(SP), CX	
  0x41c39d		488d542428		LEAQ 0x28(SP), DX	
  0x41c3a2		ffd1			CALL CX			
  0x41c3a4		e909ffffff		JMP 0x41c2b2		
	l2 := mheap_.arenas[ri.l1()]
  0x41c3a9		488b35a0a50a00		MOVQ runtime.mheap_+784(SB), SI	
	ha := l2[ri.l2()]
  0x41c3b0		8406			TESTB AL, 0(SI)		
	l2 := mheap_.arenas[ri.l1()]
  0x41c3b2		90			NOPL			
	ha := l2[ri.l2()]
  0x41c3b3		488b1cde		MOVQ 0(SI)(BX*8), BX	
  0x41c3b7		90			NOPL			
	if ha == nil {
  0x41c3b8		4885db			TESTQ BX, BX		
  0x41c3bb		741c			JE 0x41c3d9		
	if before := spanOf(s.base() - 1); before != nil && before.state == mSpanFree {
  0x41c3bd		488d71ff		LEAQ -0x1(CX), SI	
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x41c3c1		48c1ee0d		SHRQ $0xd, SI			
  0x41c3c5		4881e6ff1f0000		ANDQ $0x1fff, SI		
  0x41c3cc		488b8cf300002000	MOVQ 0x200000(BX)(SI*8), CX	
	if before := spanOf(s.base() - 1); before != nil && before.state == mSpanFree {
  0x41c3d4		e9b1feffff		JMP 0x41c28a		
  0x41c3d9		31c9			XORL CX, CX		
  0x41c3db		e9aafeffff		JMP 0x41c28a		
	start, end := s.physPageBounds()
  0x41c3e0		4889ce			MOVQ CX, SI		
	if physPageSize > _PageSize {
  0x41c3e3		e917feffff		JMP 0x41c1ff		
  0x41c3e8		31f6			XORL SI, SI		
	prescavenged := s.released() // number of bytes already scavenged.
  0x41c3ea		e913feffff		JMP 0x41c202		
func (h *mheap) coalesce(s *mspan) {
  0x41c3ef		e88cb40200		CALL runtime.morestack_noctxt(SB)	
  0x41c3f4		e997fdffff		JMP runtime.(*mheap).coalesce(SB)	

TEXT runtime.(*mspan).scavenge(SB) /usr/local/go/src/runtime/mheap.go
func (s *mspan) scavenge() uintptr {
  0x41c400		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c409		483b6110		CMPQ 0x10(CX), SP	
  0x41c40d		0f869a000000		JBE 0x41c4ad		
  0x41c413		4883ec20		SUBQ $0x20, SP		
  0x41c417		48896c2418		MOVQ BP, 0x18(SP)	
  0x41c41c		488d6c2418		LEAQ 0x18(SP), BP	
	start, end := s.physPageBounds()
  0x41c421		90			NOPL			
	start := s.base()
  0x41c422		90			NOPL			
	start, end := s.physPageBounds()
  0x41c423		488b442428		MOVQ 0x28(SP), AX	
	end := start + s.npages<<_PageShift
  0x41c428		488b4820		MOVQ 0x20(AX), CX	
  0x41c42c		48c1e10d		SHLQ $0xd, CX		
	return s.startAddr
  0x41c430		488b5018		MOVQ 0x18(AX), DX	
	end := start + s.npages<<_PageShift
  0x41c434		4801d1			ADDQ DX, CX		
	if physPageSize > _PageSize {
  0x41c437		488b1d6a090c00		MOVQ runtime.physPageSize(SB), BX	
  0x41c43e		4881fb00200000		CMPQ $0x2000, BX			
  0x41c445		7661			JBE 0x41c4a8				
		start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41c447		488d141a		LEAQ 0(DX)(BX*1), DX	
  0x41c44b		488d52ff		LEAQ -0x1(DX), DX	
  0x41c44f		48ffcb			DECQ BX			
  0x41c452		48f7d3			NOTQ BX			
  0x41c455		4821da			ANDQ BX, DX		
		end &^= physPageSize - 1
  0x41c458		4821cb			ANDQ CX, BX		
	if end <= start {
  0x41c45b		4839d3			CMPQ DX, BX		
  0x41c45e		7713			JA 0x41c473		
		return 0
  0x41c460		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x41c469		488b6c2418		MOVQ 0x18(SP), BP	
  0x41c46e		4883c420		ADDQ $0x20, SP		
  0x41c472		c3			RET			
	released := end - start
  0x41c473		4829d3			SUBQ DX, BX		
  0x41c476		48895c2410		MOVQ BX, 0x10(SP)	
	memstats.heap_released += uint64(released)
  0x41c47b		48011d2e180c00		ADDQ BX, runtime.memstats+80(SB)	
	s.scavenged = true
  0x41c482		c6406701		MOVB $0x1, 0x67(AX)	
	sysUnused(unsafe.Pointer(start), released)
  0x41c486		48891424		MOVQ DX, 0(SP)			
  0x41c48a		48895c2408		MOVQ BX, 0x8(SP)		
  0x41c48f		e87c50ffff		CALL runtime.sysUnused(SB)	
	return released
  0x41c494		488b442410		MOVQ 0x10(SP), AX	
  0x41c499		4889442430		MOVQ AX, 0x30(SP)	
  0x41c49e		488b6c2418		MOVQ 0x18(SP), BP	
  0x41c4a3		4883c420		ADDQ $0x20, SP		
  0x41c4a7		c3			RET			
	start, end := s.physPageBounds()
  0x41c4a8		4889cb			MOVQ CX, BX		
	if physPageSize > _PageSize {
  0x41c4ab		ebae			JMP 0x41c45b		
func (s *mspan) scavenge() uintptr {
  0x41c4ad		e8ceb30200		CALL runtime.morestack_noctxt(SB)	
  0x41c4b2		e949ffffff		JMP runtime.(*mspan).scavenge(SB)	

TEXT runtime.recordspan(SB) /usr/local/go/src/runtime/mheap.go
func recordspan(vh unsafe.Pointer, p unsafe.Pointer) {
  0x41c4c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c4c9		483b6110		CMPQ 0x10(CX), SP	
  0x41c4cd		0f8694010000		JBE 0x41c667		
  0x41c4d3		4883ec40		SUBQ $0x40, SP		
  0x41c4d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x41c4dc		488d6c2438		LEAQ 0x38(SP), BP	
	if len(h.allspans) >= cap(h.allspans) {
  0x41c4e1		488b442448		MOVQ 0x48(SP), AX	
  0x41c4e6		488b4838		MOVQ 0x38(AX), CX	
  0x41c4ea		48394830		CMPQ CX, 0x30(AX)	
  0x41c4ee		7d42			JGE 0x41c532		
	h.allspans = h.allspans[:len(h.allspans)+1]
  0x41c4f0		488b4838		MOVQ 0x38(AX), CX	
  0x41c4f4		488b5030		MOVQ 0x30(AX), DX	
  0x41c4f8		488d5a01		LEAQ 0x1(DX), BX	
  0x41c4fc		4885db			TESTQ BX, BX		
  0x41c4ff		0f8c40010000		JL 0x41c645		
  0x41c505		4839cb			CMPQ CX, BX		
  0x41c508		0f8737010000		JA 0x41c645		
  0x41c50e		48895830		MOVQ BX, 0x30(AX)	
	h.allspans[len(h.allspans)-1] = s
  0x41c512		488b4028		MOVQ 0x28(AX), AX	
  0x41c516		4839da			CMPQ BX, DX		
  0x41c519		0f831f010000		JAE 0x41c63e		
  0x41c51f		488b4c2450		MOVQ 0x50(SP), CX	
  0x41c524		48890cd0		MOVQ CX, 0(AX)(DX*8)	
}
  0x41c528		488b6c2438		MOVQ 0x38(SP), BP	
  0x41c52d		4883c440		ADDQ $0x40, SP		
  0x41c531		c3			RET			
		var new []*mspan
  0x41c532		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x41c53b		0f57c0			XORPS X0, X0		
  0x41c53e		0f11442428		MOVUPS X0, 0x28(SP)	
		if n < cap(h.allspans)*3/2 {
  0x41c543		488d0449		LEAQ 0(CX)(CX*2), AX	
  0x41c547		4889c1			MOVQ AX, CX		
  0x41c54a		48c1e83f		SHRQ $0x3f, AX		
  0x41c54e		4801c8			ADDQ CX, AX		
  0x41c551		48d1f8			SARQ $0x1, AX		
  0x41c554		483d00200000		CMPQ $0x2000, AX	
		sp.array = sysAlloc(uintptr(n)*sys.PtrSize, &memstats.other_sys)
  0x41c55a		b900200000		MOVL $0x2000, CX			
  0x41c55f		480f4fc8		CMOVG AX, CX				
  0x41c563		48894c2418		MOVQ CX, 0x18(SP)			
  0x41c568		48c1e103		SHLQ $0x3, CX				
  0x41c56c		48890c24		MOVQ CX, 0(SP)				
  0x41c570		488d0d89170c00		LEAQ runtime.memstats+160(SB), CX	
  0x41c577		48894c2408		MOVQ CX, 0x8(SP)			
  0x41c57c		e87f4effff		CALL runtime.sysAlloc(SB)		
  0x41c581		488b442410		MOVQ 0x10(SP), AX			
  0x41c586		4889442420		MOVQ AX, 0x20(SP)			
		if sp.array == nil {
  0x41c58b		4885c0			TESTQ AX, AX		
		if n < cap(h.allspans)*3/2 {
  0x41c58e		0f84b8000000		JE 0x41c64c		
		sp.len = len(h.allspans)
  0x41c594		488b442448		MOVQ 0x48(SP), AX	
  0x41c599		488b4830		MOVQ 0x30(AX), CX	
  0x41c59d		48894c2428		MOVQ CX, 0x28(SP)	
		sp.cap = n
  0x41c5a2		488b542418		MOVQ 0x18(SP), DX	
  0x41c5a7		4889542430		MOVQ DX, 0x30(SP)	
		if len(h.allspans) > 0 {
  0x41c5ac		488b5028		MOVQ 0x28(AX), DX	
  0x41c5b0		488b5830		MOVQ 0x30(AX), BX	
  0x41c5b4		4885db			TESTQ BX, BX		
  0x41c5b7		7e11			JLE 0x41c5ca		
			copy(new, h.allspans)
  0x41c5b9		4839d9			CMPQ BX, CX		
  0x41c5bc		480f4fcb		CMOVG BX, CX		
  0x41c5c0		488b5c2420		MOVQ 0x20(SP), BX	
  0x41c5c5		4839d3			CMPQ DX, BX		
  0x41c5c8		7556			JNE 0x41c620		
		oldAllspans := h.allspans
  0x41c5ca		488b4838		MOVQ 0x38(AX), CX	
  0x41c5ce		488b5028		MOVQ 0x28(AX), DX	
		*(*notInHeapSlice)(unsafe.Pointer(&h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&new))
  0x41c5d2		488b5c2420		MOVQ 0x20(SP), BX	
  0x41c5d7		488b742430		MOVQ 0x30(SP), SI	
  0x41c5dc		488b7c2428		MOVQ 0x28(SP), DI	
		oldAllspans := h.allspans
  0x41c5e1		4883783000		CMPQ $0x0, 0x30(AX)	
		*(*notInHeapSlice)(unsafe.Pointer(&h.allspans)) = *(*notInHeapSlice)(unsafe.Pointer(&new))
  0x41c5e6		48897830		MOVQ DI, 0x30(AX)	
  0x41c5ea		48897038		MOVQ SI, 0x38(AX)	
  0x41c5ee		48895828		MOVQ BX, 0x28(AX)	
		if len(oldAllspans) != 0 {
  0x41c5f2		0f84f8feffff		JE 0x41c4f0		
			sysFree(unsafe.Pointer(&oldAllspans[0]), uintptr(cap(oldAllspans))*unsafe.Sizeof(oldAllspans[0]), &memstats.other_sys)
  0x41c5f8		48891424		MOVQ DX, 0(SP)				
  0x41c5fc		48c1e103		SHLQ $0x3, CX				
  0x41c600		48894c2408		MOVQ CX, 0x8(SP)			
  0x41c605		488d05f4160c00		LEAQ runtime.memstats+160(SB), AX	
  0x41c60c		4889442410		MOVQ AX, 0x10(SP)			
  0x41c611		e86a51ffff		CALL runtime.sysFree(SB)		
	h.allspans = h.allspans[:len(h.allspans)+1]
  0x41c616		488b442448		MOVQ 0x48(SP), AX	
			sysFree(unsafe.Pointer(&oldAllspans[0]), uintptr(cap(oldAllspans))*unsafe.Sizeof(oldAllspans[0]), &memstats.other_sys)
  0x41c61b		e9d0feffff		JMP 0x41c4f0		
			copy(new, h.allspans)
  0x41c620		48891c24		MOVQ BX, 0(SP)			
  0x41c624		4889542408		MOVQ DX, 0x8(SP)		
  0x41c629		48c1e103		SHLQ $0x3, CX			
  0x41c62d		48894c2410		MOVQ CX, 0x10(SP)		
  0x41c632		e819e10200		CALL runtime.memmove(SB)	
		oldAllspans := h.allspans
  0x41c637		488b442448		MOVQ 0x48(SP), AX	
			copy(new, h.allspans)
  0x41c63c		eb8c			JMP 0x41c5ca		
	h.allspans[len(h.allspans)-1] = s
  0x41c63e		e8dd580000		CALL runtime.panicindex(SB)	
  0x41c643		0f0b			UD2				
	h.allspans = h.allspans[:len(h.allspans)+1]
  0x41c645		e8065a0000		CALL runtime.panicslice(SB)	
  0x41c64a		0f0b			UD2				
			throw("runtime: cannot allocate memory")
  0x41c64c		488d05e0570500		LEAQ 0x557e0(IP), AX	
  0x41c653		48890424		MOVQ AX, 0(SP)		
  0x41c657		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41c660		e81b6e0000		CALL runtime.throw(SB)	
  0x41c665		0f0b			UD2			
func recordspan(vh unsafe.Pointer, p unsafe.Pointer) {
  0x41c667		e814b20200		CALL runtime.morestack_noctxt(SB)	
  0x41c66c		e94ffeffff		JMP runtime.recordspan(SB)		

TEXT runtime.inHeapOrStack(SB) /usr/local/go/src/runtime/mheap.go
	s := spanOf(b)
  0x41c680		90			NOPL			
	ri := arenaIndex(p)
  0x41c681		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c682		90			NOPL			
	s := spanOf(b)
  0x41c683		48b80000000000800000	MOVQ $0x800000000000, AX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41c68d		488b4c2408		MOVQ 0x8(SP), CX	
  0x41c692		4801c8			ADDQ CX, AX		
  0x41c695		48c1e81a		SHRQ $0x1a, AX		
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c699		483d00004000		CMPQ $0x400000, AX	
  0x41c69f		722f			JB 0x41c6d0		
  0x41c6a1		31c0			XORL AX, AX		
	if s == nil || b < s.base() {
  0x41c6a3		4885c0			TESTQ AX, AX		
  0x41c6a6		7407			JE 0x41c6af		
  0x41c6a8		90			NOPL			
	return s.startAddr
  0x41c6a9		48394818		CMPQ CX, 0x18(AX)	
	if s == nil || b < s.base() {
  0x41c6ad		7606			JBE 0x41c6b5		
		return false
  0x41c6af		c644241000		MOVB $0x0, 0x10(SP)	
  0x41c6b4		c3			RET			
	switch s.state {
  0x41c6b5		0fb65063		MOVZX 0x63(AX), DX	
	case mSpanInUse, mSpanManual:
  0x41c6b9		ffca			DECL DX			
  0x41c6bb		80fa01			CMPL $0x1, DL		
  0x41c6be		770a			JA 0x41c6ca		
		return b < s.limit
  0x41c6c0		48394878		CMPQ CX, 0x78(AX)	
  0x41c6c4		0f97442410		SETA 0x10(SP)		
  0x41c6c9		c3			RET			
		return false
  0x41c6ca		c644241000		MOVB $0x0, 0x10(SP)	
  0x41c6cf		c3			RET			
	l2 := mheap_.arenas[ri.l1()]
  0x41c6d0		488b1579a20a00		MOVQ runtime.mheap_+784(SB), DX	
	ha := l2[ri.l2()]
  0x41c6d7		8402			TESTB AL, 0(DX)		
	l2 := mheap_.arenas[ri.l1()]
  0x41c6d9		90			NOPL			
	ha := l2[ri.l2()]
  0x41c6da		488b04c2		MOVQ 0(DX)(AX*8), AX	
  0x41c6de		90			NOPL			
	if ha == nil {
  0x41c6df		4885c0			TESTQ AX, AX		
  0x41c6e2		741b			JE 0x41c6ff		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x41c6e4		4889ca			MOVQ CX, DX			
  0x41c6e7		48c1e90d		SHRQ $0xd, CX			
  0x41c6eb		4881e1ff1f0000		ANDQ $0x1fff, CX		
  0x41c6f2		488b84c800002000	MOVQ 0x200000(AX)(CX*8), AX	
	return s.startAddr
  0x41c6fa		4889d1			MOVQ DX, CX		
	s := spanOf(b)
  0x41c6fd		eba4			JMP 0x41c6a3		
  0x41c6ff		31c0			XORL AX, AX		
  0x41c701		eba0			JMP 0x41c6a3		

TEXT runtime.spanOfHeap(SB) /usr/local/go/src/runtime/mheap.go
	s := spanOf(p)
  0x41c710		90			NOPL			
	ri := arenaIndex(p)
  0x41c711		90			NOPL			
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c712		90			NOPL			
	s := spanOf(p)
  0x41c713		48b80000000000800000	MOVQ $0x800000000000, AX	
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41c71d		488b4c2408		MOVQ 0x8(SP), CX	
  0x41c722		4801c8			ADDQ CX, AX		
  0x41c725		48c1e81a		SHRQ $0x1a, AX		
		if ri.l2() >= uint(len(mheap_.arenas[0])) {
  0x41c729		483d00004000		CMPQ $0x400000, AX	
  0x41c72f		722a			JB 0x41c75b		
  0x41c731		31c0			XORL AX, AX		
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x41c733		4885c0			TESTQ AX, AX		
  0x41c736		7407			JE 0x41c73f		
  0x41c738		90			NOPL			
	return s.startAddr
  0x41c739		48394818		CMPQ CX, 0x18(AX)	
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x41c73d		760a			JBE 0x41c749		
		return nil
  0x41c73f		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x41c748		c3			RET			
	if s == nil || p < s.base() || p >= s.limit || s.state != mSpanInUse {
  0x41c749		48394878		CMPQ CX, 0x78(AX)	
  0x41c74d		76f0			JBE 0x41c73f		
  0x41c74f		80786301		CMPB $0x1, 0x63(AX)	
  0x41c753		75ea			JNE 0x41c73f		
	return s
  0x41c755		4889442410		MOVQ AX, 0x10(SP)	
  0x41c75a		c3			RET			
	l2 := mheap_.arenas[ri.l1()]
  0x41c75b		488b15eea10a00		MOVQ runtime.mheap_+784(SB), DX	
	ha := l2[ri.l2()]
  0x41c762		8402			TESTB AL, 0(DX)		
	l2 := mheap_.arenas[ri.l1()]
  0x41c764		90			NOPL			
	ha := l2[ri.l2()]
  0x41c765		488b04c2		MOVQ 0(DX)(AX*8), AX	
  0x41c769		90			NOPL			
	if ha == nil {
  0x41c76a		4885c0			TESTQ AX, AX		
  0x41c76d		741b			JE 0x41c78a		
	return ha.spans[(p/pageSize)%pagesPerArena]
  0x41c76f		4889ca			MOVQ CX, DX			
  0x41c772		48c1e90d		SHRQ $0xd, CX			
  0x41c776		4881e1ff1f0000		ANDQ $0x1fff, CX		
  0x41c77d		488b84c800002000	MOVQ 0x200000(AX)(CX*8), AX	
	return s.startAddr
  0x41c785		4889d1			MOVQ DX, CX		
	s := spanOf(p)
  0x41c788		eba9			JMP 0x41c733		
  0x41c78a		31c0			XORL AX, AX		
  0x41c78c		eba5			JMP 0x41c733		

TEXT runtime.(*mheap).init(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) init() {
  0x41c790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41c799		483b6110		CMPQ 0x10(CX), SP	
  0x41c79d		0f8636040000		JBE 0x41cbd9		
  0x41c7a3		4883ec08		SUBQ $0x8, SP		
  0x41c7a7		48892c24		MOVQ BP, 0(SP)		
  0x41c7ab		488d2c24		LEAQ 0(SP), BP		
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41c7af		488b4c2410		MOVQ 0x10(SP), CX	
  0x41c7b4		8401			TESTB AL, 0(CX)		
  0x41c7b6		90			NOPL			
	f.size = size
  0x41c7b7		48c7819025000030000000	MOVQ $0x30, 0x2590(CX)	
	f.first = first
  0x41c7c2		833d57060c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c7c9		0f85e9030000		JNE 0x41cbb8				
	f.arg = arg
  0x41c7cf		0f57c0			XORPS X0, X0		
  0x41c7d2		0f118198250000		MOVUPS X0, 0x2598(CX)	
	f.chunk = 0
  0x41c7d9		0f57c0			XORPS X0, X0		
  0x41c7dc		0f1181a8250000		MOVUPS X0, 0x25a8(CX)	
	f.nchunk = 0
  0x41c7e3		c781b825000000000000	MOVL $0x0, 0x25b8(CX)	
	f.inuse = 0
  0x41c7ed		48c781c025000000000000	MOVQ $0x0, 0x25c0(CX)	
	f.stat = stat
  0x41c7f8		833d21060c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c7ff		0f8598030000		JNE 0x41cb9d				
  0x41c805		488d05f4140c00		LEAQ runtime.memstats+160(SB), AX	
  0x41c80c		488981c8250000		MOVQ AX, 0x25c8(CX)			
	f.zero = true
  0x41c813		c681d025000001		MOVB $0x1, 0x25d0(CX)	
	h.spanalloc.init(unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &memstats.mspan_sys)
  0x41c81a		90			NOPL			
	f.size = size
  0x41c81b		48c7810025000090000000	MOVQ $0x90, 0x2500(CX)	
	f.first = first
  0x41c826		833df3050c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c82d		0f8539030000		JNE 0x41cb6c				
  0x41c833		488d1516710500		LEAQ 0x57116(IP), DX			
  0x41c83a		48899108250000		MOVQ DX, 0x2508(CX)			
	f.arg = arg
  0x41c841		48898910250000		MOVQ CX, 0x2510(CX)	
	f.chunk = 0
  0x41c848		0f118118250000		MOVUPS X0, 0x2518(CX)	
	f.nchunk = 0
  0x41c84f		c7812825000000000000	MOVL $0x0, 0x2528(CX)	
	f.inuse = 0
  0x41c859		48c7813025000000000000	MOVQ $0x0, 0x2530(CX)	
	f.stat = stat
  0x41c864		833db5050c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c86b		0f85d9020000		JNE 0x41cb4a				
  0x41c871		488d1560140c00		LEAQ runtime.memstats+120(SB), DX	
  0x41c878		48899138250000		MOVQ DX, 0x2538(CX)			
	f.zero = true
  0x41c87f		c6814025000001		MOVB $0x1, 0x2540(CX)	
	h.cachealloc.init(unsafe.Sizeof(mcache{}), nil, nil, &memstats.mcache_sys)
  0x41c886		90			NOPL			
	f.size = size
  0x41c887		48c78148250000c8060000	MOVQ $0x6c8, 0x2548(CX)	
	f.first = first
  0x41c892		833d87050c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c899		0f8580020000		JNE 0x41cb1f				
	f.arg = arg
  0x41c89f		0f118150250000		MOVUPS X0, 0x2550(CX)	
	f.chunk = 0
  0x41c8a6		0f118160250000		MOVUPS X0, 0x2560(CX)	
	f.nchunk = 0
  0x41c8ad		c7817025000000000000	MOVL $0x0, 0x2570(CX)	
	f.inuse = 0
  0x41c8b7		48c7817825000000000000	MOVQ $0x0, 0x2578(CX)	
	f.stat = stat
  0x41c8c2		833d57050c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c8c9		0f852e020000		JNE 0x41cafd				
  0x41c8cf		488d1512140c00		LEAQ runtime.memstats+136(SB), DX	
  0x41c8d6		48899180250000		MOVQ DX, 0x2580(CX)			
	f.zero = true
  0x41c8dd		c6818825000001		MOVB $0x1, 0x2588(CX)	
	h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer{}), nil, nil, &memstats.other_sys)
  0x41c8e4		90			NOPL			
	f.size = size
  0x41c8e5		48c781d825000030000000	MOVQ $0x30, 0x25d8(CX)	
	f.first = first
  0x41c8f0		833d29050c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c8f7		0f85d5010000		JNE 0x41cad2				
	f.arg = arg
  0x41c8fd		0f1181e0250000		MOVUPS X0, 0x25e0(CX)	
	f.chunk = 0
  0x41c904		0f1181f0250000		MOVUPS X0, 0x25f0(CX)	
	f.nchunk = 0
  0x41c90b		c7810026000000000000	MOVL $0x0, 0x2600(CX)	
	f.inuse = 0
  0x41c915		48c7810826000000000000	MOVQ $0x0, 0x2608(CX)	
	f.stat = stat
  0x41c920		833df9040c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c927		0f8591010000		JNE 0x41cabe				
  0x41c92d		48898110260000		MOVQ AX, 0x2610(CX)			
	f.zero = true
  0x41c934		c6811826000001		MOVB $0x1, 0x2618(CX)	
	h.specialprofilealloc.init(unsafe.Sizeof(specialprofile{}), nil, nil, &memstats.other_sys)
  0x41c93b		90			NOPL			
	f.size = size
  0x41c93c		48c7812026000018000000	MOVQ $0x18, 0x2620(CX)	
	f.first = first
  0x41c947		833dd2040c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c94e		0f853f010000		JNE 0x41ca93				
	f.arg = arg
  0x41c954		0f118128260000		MOVUPS X0, 0x2628(CX)	
	f.chunk = 0
  0x41c95b		0f118138260000		MOVUPS X0, 0x2638(CX)	
	f.nchunk = 0
  0x41c962		c7814826000000000000	MOVL $0x0, 0x2648(CX)	
	f.inuse = 0
  0x41c96c		48c7815026000000000000	MOVQ $0x0, 0x2650(CX)	
	f.stat = stat
  0x41c977		833da2040c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c97e		0f85fb000000		JNE 0x41ca7f				
  0x41c984		48898158260000		MOVQ AX, 0x2658(CX)			
	f.zero = true
  0x41c98b		c6816026000001		MOVB $0x1, 0x2660(CX)	
	h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint{}), nil, nil, &memstats.other_sys)
  0x41c992		90			NOPL			
	f.size = size
  0x41c993		48c7817026000018000000	MOVQ $0x18, 0x2670(CX)	
	f.first = first
  0x41c99e		833d7b040c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c9a5		0f85a9000000		JNE 0x41ca54				
	f.arg = arg
  0x41c9ab		0f118178260000		MOVUPS X0, 0x2678(CX)	
	f.chunk = 0
  0x41c9b2		0f118188260000		MOVUPS X0, 0x2688(CX)	
	f.nchunk = 0
  0x41c9b9		c7819826000000000000	MOVL $0x0, 0x2698(CX)	
	f.inuse = 0
  0x41c9c3		48c781a026000000000000	MOVQ $0x0, 0x26a0(CX)	
	f.stat = stat
  0x41c9ce		833d4b040c0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41c9d5		756f			JNE 0x41ca46				
  0x41c9d7		488981a8260000		MOVQ AX, 0x26a8(CX)			
	f.zero = true
  0x41c9de		c681b026000001		MOVB $0x1, 0x26b0(CX)	
	h.spanalloc.zero = false
  0x41c9e5		c6814025000000		MOVB $0x0, 0x2540(CX)	
  0x41c9ec		31c0			XORL AX, AX		
	for i := range h.central {
  0x41c9ee		eb45			JMP 0x41ca35		
		h.central[i].mcentral.init(spanClass(i))
  0x41c9f0		4889c2			MOVQ AX, DX		
  0x41c9f3		48c1e006		SHLQ $0x6, AX		
  0x41c9f7		90			NOPL			
	c.spanclass = spc
  0x41c9f8		88940188030000		MOVB DL, 0x388(CX)(AX*1)	
	c.nonempty.init()
  0x41c9ff		90			NOPL			
	list.first = nil
  0x41ca00		48c784019003000000000000	MOVQ $0x0, 0x390(CX)(AX*1)	
	list.last = nil
  0x41ca0c		48c784019803000000000000	MOVQ $0x0, 0x398(CX)(AX*1)	
	c.empty.init()
  0x41ca18		90			NOPL			
	list.first = nil
  0x41ca19		48c78401a003000000000000	MOVQ $0x0, 0x3a0(CX)(AX*1)	
	list.last = nil
  0x41ca25		48c78401a803000000000000	MOVQ $0x0, 0x3a8(CX)(AX*1)	
	for i := range h.central {
  0x41ca31		488d4201		LEAQ 0x1(DX), AX	
  0x41ca35		483d86000000		CMPQ $0x86, AX		
  0x41ca3b		7cb3			JL 0x41c9f0		
  0x41ca3d		488b2c24		MOVQ 0(SP), BP		
  0x41ca41		4883c408		ADDQ $0x8, SP		
  0x41ca45		c3			RET			
	f.stat = stat
  0x41ca46		488db9a8260000		LEAQ 0x26a8(CX), DI		
  0x41ca4d		e82ecc0200		CALL runtime.gcWriteBarrier(SB)	
  0x41ca52		eb8a			JMP 0x41c9de			
	f.first = first
  0x41ca54		488db978260000		LEAQ 0x2678(CX), DI		
  0x41ca5b		31c0			XORL AX, AX			
  0x41ca5d		e81ecc0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41ca62		488db980260000		LEAQ 0x2680(CX), DI		
  0x41ca69		31c0			XORL AX, AX			
  0x41ca6b		e810cc0200		CALL runtime.gcWriteBarrier(SB)	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41ca70		488d0589120c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41ca77		0f57c0			XORPS X0, X0		
	f.first = first
  0x41ca7a		e933ffffff		JMP 0x41c9b2		
	f.stat = stat
  0x41ca7f		488db958260000		LEAQ 0x2658(CX), DI		
  0x41ca86		e8f5cb0200		CALL runtime.gcWriteBarrier(SB)	
	f.list = nil
  0x41ca8b		0f57c0			XORPS X0, X0		
	f.stat = stat
  0x41ca8e		e9f8feffff		JMP 0x41c98b		
	f.first = first
  0x41ca93		488db928260000		LEAQ 0x2628(CX), DI		
  0x41ca9a		31c0			XORL AX, AX			
  0x41ca9c		e8dfcb0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41caa1		488db930260000		LEAQ 0x2630(CX), DI		
  0x41caa8		31c0			XORL AX, AX			
  0x41caaa		e8d1cb0200		CALL runtime.gcWriteBarrier(SB)	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41caaf		488d054a120c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41cab6		0f57c0			XORPS X0, X0		
	f.first = first
  0x41cab9		e99dfeffff		JMP 0x41c95b		
	f.stat = stat
  0x41cabe		488db910260000		LEAQ 0x2610(CX), DI		
  0x41cac5		e8b6cb0200		CALL runtime.gcWriteBarrier(SB)	
	f.list = nil
  0x41caca		0f57c0			XORPS X0, X0		
	f.stat = stat
  0x41cacd		e962feffff		JMP 0x41c934		
	f.first = first
  0x41cad2		488db9e0250000		LEAQ 0x25e0(CX), DI		
  0x41cad9		31c0			XORL AX, AX			
  0x41cadb		e8a0cb0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41cae0		488db9e8250000		LEAQ 0x25e8(CX), DI		
  0x41cae7		31c0			XORL AX, AX			
  0x41cae9		e892cb0200		CALL runtime.gcWriteBarrier(SB)	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41caee		488d050b120c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41caf5		0f57c0			XORPS X0, X0		
	f.first = first
  0x41caf8		e907feffff		JMP 0x41c904		
	f.stat = stat
  0x41cafd		488db980250000		LEAQ 0x2580(CX), DI			
  0x41cb04		488d05dd110c00		LEAQ runtime.memstats+136(SB), AX	
  0x41cb0b		e870cb0200		CALL runtime.gcWriteBarrier(SB)		
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41cb10		488d05e9110c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41cb17		0f57c0			XORPS X0, X0		
	f.stat = stat
  0x41cb1a		e9befdffff		JMP 0x41c8dd		
	f.first = first
  0x41cb1f		488db950250000		LEAQ 0x2550(CX), DI		
  0x41cb26		31c0			XORL AX, AX			
  0x41cb28		e853cb0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41cb2d		488db958250000		LEAQ 0x2558(CX), DI		
  0x41cb34		31c0			XORL AX, AX			
  0x41cb36		e845cb0200		CALL runtime.gcWriteBarrier(SB)	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41cb3b		488d05be110c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41cb42		0f57c0			XORPS X0, X0		
	f.first = first
  0x41cb45		e95cfdffff		JMP 0x41c8a6		
	f.stat = stat
  0x41cb4a		488db938250000		LEAQ 0x2538(CX), DI			
  0x41cb51		488d0580110c00		LEAQ runtime.memstats+120(SB), AX	
  0x41cb58		e823cb0200		CALL runtime.gcWriteBarrier(SB)		
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41cb5d		488d059c110c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41cb64		0f57c0			XORPS X0, X0		
	f.stat = stat
  0x41cb67		e913fdffff		JMP 0x41c87f		
	f.first = first
  0x41cb6c		488db908250000		LEAQ 0x2508(CX), DI		
  0x41cb73		488d05d66d0500		LEAQ 0x56dd6(IP), AX		
  0x41cb7a		e801cb0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41cb7f		488db910250000		LEAQ 0x2510(CX), DI		
  0x41cb86		4889c8			MOVQ CX, AX			
  0x41cb89		e8f2ca0200		CALL runtime.gcWriteBarrier(SB)	
	h.treapalloc.init(unsafe.Sizeof(treapNode{}), nil, nil, &memstats.other_sys)
  0x41cb8e		488d056b110c00		LEAQ runtime.memstats+160(SB), AX	
	f.list = nil
  0x41cb95		0f57c0			XORPS X0, X0		
	f.first = first
  0x41cb98		e9abfcffff		JMP 0x41c848		
	f.stat = stat
  0x41cb9d		488db9c8250000		LEAQ 0x25c8(CX), DI			
  0x41cba4		488d0555110c00		LEAQ runtime.memstats+160(SB), AX	
  0x41cbab		e8d0ca0200		CALL runtime.gcWriteBarrier(SB)		
	f.list = nil
  0x41cbb0		0f57c0			XORPS X0, X0		
	f.stat = stat
  0x41cbb3		e95bfcffff		JMP 0x41c813		
	f.first = first
  0x41cbb8		488db998250000		LEAQ 0x2598(CX), DI		
  0x41cbbf		31c0			XORL AX, AX			
  0x41cbc1		e8baca0200		CALL runtime.gcWriteBarrier(SB)	
	f.arg = arg
  0x41cbc6		488db9a0250000		LEAQ 0x25a0(CX), DI		
  0x41cbcd		31c0			XORL AX, AX			
  0x41cbcf		e8acca0200		CALL runtime.gcWriteBarrier(SB)	
	f.first = first
  0x41cbd4		e900fcffff		JMP 0x41c7d9		
func (h *mheap) init() {
  0x41cbd9		e8a2ac0200		CALL runtime.morestack_noctxt(SB)	
  0x41cbde		e9adfbffff		JMP runtime.(*mheap).init(SB)		

TEXT runtime.(*mheap).reclaim(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) reclaim(npage uintptr) {
  0x41cbf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41cbf9		483b6110		CMPQ 0x10(CX), SP	
  0x41cbfd		0f863b020000		JBE 0x41ce3e		
  0x41cc03		4883ec70		SUBQ $0x70, SP		
  0x41cc07		48896c2468		MOVQ BP, 0x68(SP)	
  0x41cc0c		488d6c2468		LEAQ 0x68(SP), BP	
	if atomic.Load64(&h.reclaimIndex) >= 1<<63 {
  0x41cc11		488b4c2478		MOVQ 0x78(SP), CX		
  0x41cc16		488b91c0000000		MOVQ 0xc0(CX), DX		
  0x41cc1d		48bb0000000000000080	MOVQ $0x8000000000000000, BX	
  0x41cc27		4839da			CMPQ BX, DX			
  0x41cc2a		0f8304020000		JAE 0x41ce34			
	_g_ := getg()
  0x41cc30		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++
  0x41cc39		488b7230		MOVQ 0x30(DX), SI	
	mp := acquirem()
  0x41cc3d		90			NOPL			
	_g_.m.locks++
  0x41cc3e		ff8608010000		INCL 0x108(SI)		
	return _g_.m
  0x41cc44		488b5230		MOVQ 0x30(DX), DX	
  0x41cc48		4889542458		MOVQ DX, 0x58(SP)	
	if trace.enabled {
  0x41cc4d		803d7cff0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41cc54		0f85bc010000		JNE 0x41ce16			
	arenas := h.sweepArenas
  0x41cc5a		488bb168030000		MOVQ 0x368(CX), SI	
  0x41cc61		4889742460		MOVQ SI, 0x60(SP)	
  0x41cc66		488bb978030000		MOVQ 0x378(CX), DI	
  0x41cc6d		48897c2448		MOVQ DI, 0x48(SP)	
  0x41cc72		4c8b8170030000		MOVQ 0x370(CX), R8	
  0x41cc79		4c89442440		MOVQ R8, 0x40(SP)	
	for npage > 0 {
  0x41cc7e		4c8b8c2480000000	MOVQ 0x80(SP), R9	
  0x41cc86		31c0			XORL AX, AX		
  0x41cc88		eb06			JMP 0x41cc90		
  0x41cc8a		4d89e1			MOVQ R12, R9		
		if !locked {
  0x41cc8d		4489e8			MOVL R13, AX		
	for npage > 0 {
  0x41cc90		4d85c9			TESTQ R9, R9		
  0x41cc93		0f861b010000		JBE 0x41cdb4		
		if credit := atomic.Loaduintptr(&h.reclaimCredit); credit > 0 {
  0x41cc99		4c8b91c8000000		MOVQ 0xc8(CX), R10	
  0x41cca0		4d85d2			TESTQ R10, R10		
  0x41cca3		7636			JBE 0x41ccdb		
			if take > npage {
  0x41cca5		4d39ca			CMPQ R9, R10		
			if atomic.Casuintptr(&h.reclaimCredit, credit, credit-take) {
  0x41cca8		4d89d3			MOVQ R10, R11		
  0x41ccab		4d0f47d1		CMOVA R9, R10		
  0x41ccaf		4d89dc			MOVQ R11, R12		
  0x41ccb2		4d29d3			SUBQ R10, R11		
		if !locked {
  0x41ccb5		4189c5			MOVL AX, R13		
			if atomic.Casuintptr(&h.reclaimCredit, credit, credit-take) {
  0x41ccb8		4c89e0			MOVQ R12, AX			
  0x41ccbb		f04c0fb199c8000000	LOCK CMPXCHGQ R11, 0xc8(CX)	
  0x41ccc4		410f94c3		SETE R11			
	for npage > 0 {
  0x41ccc8		450fb6db		MOVZX R11, R11		
				npage -= take
  0x41cccc		4d89cc			MOVQ R9, R12		
  0x41cccf		4d29d1			SUBQ R10, R9		
	for npage > 0 {
  0x41ccd2		4d85db			TESTQ R11, R11		
  0x41ccd5		4d0f45e1		CMOVNE R9, R12		
			if take > npage {
  0x41ccd9		ebaf			JMP 0x41cc8a		
		idx := uintptr(atomic.Xadd64(&h.reclaimIndex, pagesPerChunk) - pagesPerChunk)
  0x41ccdb		41ba00020000		MOVL $0x200, R10		
  0x41cce1		f04c0fc191c0000000	LOCK XADDQ R10, 0xc0(CX)	
		if idx/pagesPerArena >= uintptr(len(arenas)) {
  0x41ccea		4d89d3			MOVQ R10, R11		
  0x41cced		49c1ea0d		SHRQ $0xd, R10		
  0x41ccf1		4d39c2			CMPQ R8, R10		
  0x41ccf4		0f83b3000000		JAE 0x41cdad		
	for npage > 0 {
  0x41ccfa		4c894c2438		MOVQ R9, 0x38(SP)	
		if !locked {
  0x41ccff		84c0			TESTL AL, AL		
  0x41cd01		747e			JE 0x41cd81		
		nfound := h.reclaimChunk(arenas, idx, pagesPerChunk)
  0x41cd03		48890c24		MOVQ CX, 0(SP)				
  0x41cd07		4889742408		MOVQ SI, 0x8(SP)			
  0x41cd0c		4c89442410		MOVQ R8, 0x10(SP)			
  0x41cd11		48897c2418		MOVQ DI, 0x18(SP)			
  0x41cd16		4c895c2420		MOVQ R11, 0x20(SP)			
  0x41cd1b		48c744242800020000	MOVQ $0x200, 0x28(SP)			
  0x41cd24		e827010000		CALL runtime.(*mheap).reclaimChunk(SB)	
  0x41cd29		488b442430		MOVQ 0x30(SP), AX			
		if nfound <= npage {
  0x41cd2e		488b4c2438		MOVQ 0x38(SP), CX	
  0x41cd33		4839c8			CMPQ CX, AX		
  0x41cd36		7734			JA 0x41cd6c		
			npage -= nfound
  0x41cd38		4829c1			SUBQ AX, CX		
	mp.locks--
  0x41cd3b		488b542458		MOVQ 0x58(SP), DX		
  0x41cd40		48bb0000000000000080	MOVQ $0x8000000000000000, BX	
		nfound := h.reclaimChunk(arenas, idx, pagesPerChunk)
  0x41cd4a		488b742460		MOVQ 0x60(SP), SI	
  0x41cd4f		488b7c2448		MOVQ 0x48(SP), DI	
		if idx/pagesPerArena >= uintptr(len(arenas)) {
  0x41cd54		4c8b442440		MOVQ 0x40(SP), R8	
	for npage > 0 {
  0x41cd59		4989cc			MOVQ CX, R12		
  0x41cd5c		41bd01000000		MOVL $0x1, R13		
		if credit := atomic.Loaduintptr(&h.reclaimCredit); credit > 0 {
  0x41cd62		488b4c2478		MOVQ 0x78(SP), CX	
	for npage > 0 {
  0x41cd67		e91effffff		JMP 0x41cc8a		
			atomic.Xadduintptr(&h.reclaimCredit, nfound-npage)
  0x41cd6c		4829c8			SUBQ CX, AX		
  0x41cd6f		488b542478		MOVQ 0x78(SP), DX	
  0x41cd74		f0480fc182c8000000	LOCK XADDQ AX, 0xc8(DX)	
  0x41cd7d		31c9			XORL CX, CX		
			npage = 0
  0x41cd7f		ebba			JMP 0x41cd3b		
		idx := uintptr(atomic.Xadd64(&h.reclaimIndex, pagesPerChunk) - pagesPerChunk)
  0x41cd81		4c895c2450		MOVQ R11, 0x50(SP)	
			lock(&h.lock)
  0x41cd86		48890c24		MOVQ CX, 0(SP)		
  0x41cd8a		e851b9feff		CALL runtime.lock(SB)	
		nfound := h.reclaimChunk(arenas, idx, pagesPerChunk)
  0x41cd8f		488b4c2478		MOVQ 0x78(SP), CX	
  0x41cd94		488b742460		MOVQ 0x60(SP), SI	
  0x41cd99		488b7c2448		MOVQ 0x48(SP), DI	
  0x41cd9e		4c8b442440		MOVQ 0x40(SP), R8	
  0x41cda3		4c8b5c2450		MOVQ 0x50(SP), R11	
			locked = true
  0x41cda8		e956ffffff		JMP 0x41cd03		
			atomic.Store64(&h.reclaimIndex, 1<<63)
  0x41cdad		488799c0000000		XCHGQ BX, 0xc0(CX)	
		if !locked {
  0x41cdb4		84c0			TESTL AL, AL		
	if locked {
  0x41cdb6		754e			JNE 0x41ce06		
	if trace.enabled {
  0x41cdb8		803d11fe0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41cdbf		7539			JNE 0x41cdfa			
	releasem(mp)
  0x41cdc1		90			NOPL			
	_g_ := getg()
  0x41cdc2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x41cdcb		8b8a08010000		MOVL 0x108(DX), CX	
  0x41cdd1		8d59ff			LEAL -0x1(CX), BX	
  0x41cdd4		899a08010000		MOVL BX, 0x108(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x41cdda		83f901			CMPL $0x1, CX		
  0x41cddd		7511			JNE 0x41cdf0		
  0x41cddf		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41cde6		7408			JE 0x41cdf0		
		_g_.stackguard0 = stackPreempt
  0x41cde8		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x41cdf0		488b6c2468		MOVQ 0x68(SP), BP	
  0x41cdf5		4883c470		ADDQ $0x70, SP		
  0x41cdf9		c3			RET			
		traceGCSweepDone()
  0x41cdfa		e8b1ff0100		CALL runtime.traceGCSweepDone(SB)	
	mp.locks--
  0x41cdff		488b542458		MOVQ 0x58(SP), DX	
		traceGCSweepDone()
  0x41ce04		ebbb			JMP 0x41cdc1		
		unlock(&h.lock)
  0x41ce06		48890c24		MOVQ CX, 0(SP)		
  0x41ce0a		e881bafeff		CALL runtime.unlock(SB)	
	mp.locks--
  0x41ce0f		488b542458		MOVQ 0x58(SP), DX	
		unlock(&h.lock)
  0x41ce14		eba2			JMP 0x41cdb8		
		traceGCSweepStart()
  0x41ce16		e875fe0100		CALL runtime.traceGCSweepStart(SB)	
	arenas := h.sweepArenas
  0x41ce1b		488b4c2478		MOVQ 0x78(SP), CX	
	mp.locks--
  0x41ce20		488b542458		MOVQ 0x58(SP), DX		
  0x41ce25		48bb0000000000000080	MOVQ $0x8000000000000000, BX	
		traceGCSweepStart()
  0x41ce2f		e926feffff		JMP 0x41cc5a		
		return
  0x41ce34		488b6c2468		MOVQ 0x68(SP), BP	
  0x41ce39		4883c470		ADDQ $0x70, SP		
  0x41ce3d		c3			RET			
func (h *mheap) reclaim(npage uintptr) {
  0x41ce3e		e83daa0200		CALL runtime.morestack_noctxt(SB)	
  0x41ce43		e9a8fdffff		JMP runtime.(*mheap).reclaim(SB)	

TEXT runtime.(*mheap).reclaimChunk(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr {
  0x41ce50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ce59		488d4424e8		LEAQ -0x18(SP), AX	
  0x41ce5e		483b4110		CMPQ 0x10(CX), AX	
  0x41ce62		0f862b030000		JBE 0x41d193		
  0x41ce68		4881ec98000000		SUBQ $0x98, SP		
  0x41ce6f		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x41ce77		488dac2490000000	LEAQ 0x90(SP), BP	
	sg := h.sweepgen
  0x41ce7f		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x41ce87		8b5a18			MOVL 0x18(DX), BX	
  0x41ce8a		895c241c		MOVL BX, 0x1c(SP)	
	for n > 0 {
  0x41ce8e		488bb424c8000000	MOVQ 0xc8(SP), SI	
  0x41ce96		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x41ce9e		4c8b8424b0000000	MOVQ 0xb0(SP), R8	
  0x41cea6		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr {
  0x41ceae		4889f0			MOVQ SI, AX		
  0x41ceb1		31c9			XORL CX, CX		
	for n > 0 {
  0x41ceb3		e994010000		JMP 0x41d04c		
		for i := range inUse {
  0x41ceb8		49ffc6			INCQ R14		
		ha := h.arenas[ai.l1()][ai.l2()]
  0x41cebb		488b9424a0000000	MOVQ 0xa0(SP), DX	
		ai := arenas[pageIdx/pagesPerArena]
  0x41cec3		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x41cecb		4c8b8424b0000000	MOVQ 0xb0(SP), R8	
		for i := range inUse {
  0x41ced3		4939f6			CMPQ SI, R14		
  0x41ced6		0f8d62010000		JGE 0x41d03e		
			inUseUnmarked := inUse[i] &^ marked[i]
  0x41cedc		430fb63c2e		MOVZX 0(R14)(R13*1), DI	
  0x41cee1		0f8382020000		JAE 0x41d169		
  0x41cee7		430fb61416		MOVZX 0(R14)(R10*1), DX	
  0x41ceec		f7d2			NOTL DX			
  0x41ceee		8854241b		MOVB DL, 0x1b(SP)	
  0x41cef2		21fa			ANDL DI, DX		
			if inUseUnmarked == 0 {
  0x41cef4		440fb644241b		MOVZX 0x1b(SP), R8	
  0x41cefa		4184f8			TESTL DI, R8		
  0x41cefd		74b9			JE 0x41ceb8		
		for i := range inUse {
  0x41ceff		4c89742438		MOVQ R14, 0x38(SP)	
  0x41cf04		31ff			XORL DI, DI		
			for j := uint(0); j < 8; j++ {
  0x41cf06		eb1e			JMP 0x41cf26		
  0x41cf08		488d7901		LEAQ 0x1(CX), DI	
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41cf0c		488b8424c8000000	MOVQ 0xc8(SP), AX	
			inUseUnmarked := inUse[i] &^ marked[i]
  0x41cf14		4c8b542478		MOVQ 0x78(SP), R10	
		pageIdx += uintptr(len(inUse) * 8)
  0x41cf19		4c8b5c2458		MOVQ 0x58(SP), R11	
		n -= uintptr(len(inUse) * 8)
  0x41cf1e		4c8b7c2468		MOVQ 0x68(SP), R15	
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41cf23		4c89c1			MOVQ R8, CX		
			for j := uint(0); j < 8; j++ {
  0x41cf26		4883ff08		CMPQ $0x8, DI		
  0x41cf2a		738c			JAE 0x41ceb8		
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41cf2c		4989c8			MOVQ CX, R8		
				if inUseUnmarked&(1<<j) != 0 {
  0x41cf2f		4889f9			MOVQ DI, CX		
  0x41cf32		41bf01000000		MOVL $0x1, R15		
  0x41cf38		41d3e7			SHLL CL, R15		
  0x41cf3b		4184d7			TESTL DL, R15		
  0x41cf3e		74c8			JE 0x41cf08		
					s := ha.spans[arenaPage+uint(i)*8+j]
  0x41cf40		4f8d3cf4		LEAQ 0(R12)(R14*8), R15		
  0x41cf44		4901cf			ADDQ CX, R15			
  0x41cf47		4981ff00200000		CMPQ $0x2000, R15		
  0x41cf4e		0f830e020000		JAE 0x41d162			
  0x41cf54		4f8bbcf900002000	MOVQ 0x200000(R9)(R15*8), R15	
					if atomic.Load(&s.sweepgen) == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41cf5c		458b5f58		MOVL 0x58(R15), R11		
  0x41cf60		448d53fe		LEAL -0x2(BX), R10		
  0x41cf64		4539d3			CMPL R10, R11			
  0x41cf67		0f85c9000000		JNE 0x41d036			
  0x41cf6d		448d5bff		LEAL -0x1(BX), R11		
  0x41cf71		4489d0			MOVL R10, AX			
  0x41cf74		f0450fb15f58		LOCK CMPXCHGL R11, 0x58(R15)	
  0x41cf7a		410f94c2		SETE R10			
  0x41cf7e		4584d2			TESTL R10, R10			
  0x41cf81		7485			JE 0x41cf08			
			for j := uint(0); j < 8; j++ {
  0x41cf83		48894c2450		MOVQ CX, 0x50(SP)	
					s := ha.spans[arenaPage+uint(i)*8+j]
  0x41cf88		4c897c2470		MOVQ R15, 0x70(SP)	
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41cf8d		4c89442448		MOVQ R8, 0x48(SP)	
						npages := s.npages
  0x41cf92		498b4720		MOVQ 0x20(R15), AX	
  0x41cf96		4889442420		MOVQ AX, 0x20(SP)	
						unlock(&h.lock)
  0x41cf9b		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x41cfa3		48890c24		MOVQ CX, 0(SP)		
  0x41cfa7		e8e4b8feff		CALL runtime.unlock(SB)	
						if s.sweep(false) {
  0x41cfac		488b442470		MOVQ 0x70(SP), AX		
  0x41cfb1		48890424		MOVQ AX, 0(SP)			
  0x41cfb5		c644240800		MOVB $0x0, 0x8(SP)		
  0x41cfba		e841d7ffff		CALL runtime.(*mspan).sweep(SB)	
  0x41cfbf		0fb6442410		MOVZX 0x10(SP), AX		
  0x41cfc4		4889442440		MOVQ AX, 0x40(SP)		
						lock(&h.lock)
  0x41cfc9		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x41cfd1		48890c24		MOVQ CX, 0(SP)		
  0x41cfd5		e806b7feff		CALL runtime.lock(SB)	
							nFreed += npages
  0x41cfda		488b442420		MOVQ 0x20(SP), AX	
  0x41cfdf		4c8b442448		MOVQ 0x48(SP), R8	
  0x41cfe4		4c01c0			ADDQ R8, AX		
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41cfe7		488b4c2440		MOVQ 0x40(SP), CX	
  0x41cfec		4885c9			TESTQ CX, CX		
  0x41cfef		4c0f45c0		CMOVNE AX, R8		
						inUseUnmarked = inUse[i] &^ marked[i]
  0x41cff3		4c8bac2480000000	MOVQ 0x80(SP), R13	
  0x41cffb		4c8b742438		MOVQ 0x38(SP), R14	
  0x41d000		430fb6142e		MOVZX 0(R14)(R13*1), DX	
  0x41d005		488b442478		MOVQ 0x78(SP), AX	
  0x41d00a		410fb60c06		MOVZX 0(R14)(AX*1), CX	
  0x41d00f		f7d1			NOTL CX			
  0x41d011		21ca			ANDL CX, DX		
			for j := uint(0); j < 8; j++ {
  0x41d013		488b4c2450		MOVQ 0x50(SP), CX	
					if atomic.Load(&s.sweepgen) == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41d018		8b5c241c		MOVL 0x1c(SP), BX	
		for i := range inUse {
  0x41d01c		488b742430		MOVQ 0x30(SP), SI	
			for j := uint(0); j < 8; j++ {
  0x41d021		4889cf			MOVQ CX, DI		
					s := ha.spans[arenaPage+uint(i)*8+j]
  0x41d024		4c8b8c2488000000	MOVQ 0x88(SP), R9	
  0x41d02c		4c8b642460		MOVQ 0x60(SP), R12	
						inUseUnmarked = inUse[i] &^ marked[i]
  0x41d031		e9d2feffff		JMP 0x41cf08		
  0x41d036		4531d2			XORL R10, R10		
					if atomic.Load(&s.sweepgen) == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
  0x41d039		e940ffffff		JMP 0x41cf7e		
		pageIdx += uintptr(len(inUse) * 8)
  0x41d03e		4d8d0cf3		LEAQ 0(R11)(SI*8), R9	
  0x41d042		48c1e603		SHLQ $0x3, SI		
		n -= uintptr(len(inUse) * 8)
  0x41d046		4929f7			SUBQ SI, R15		
	for n > 0 {
  0x41d049		4c89fe			MOVQ R15, SI		
  0x41d04c		4885f6			TESTQ SI, SI		
  0x41d04f		0f86d0000000		JBE 0x41d125		
		ai := arenas[pageIdx/pagesPerArena]
  0x41d055		4d89ca			MOVQ R9, R10		
  0x41d058		49c1e90d		SHRQ $0xd, R9		
  0x41d05c		4d39c1			CMPQ R8, R9		
  0x41d05f		0f8327010000		JAE 0x41d18c		
		ha := h.arenas[ai.l1()][ai.l2()]
  0x41d065		4c8b9a10030000		MOVQ 0x310(DX), R11	
  0x41d06c		418403			TESTB AL, 0(R11)	
		ai := arenas[pageIdx/pagesPerArena]
  0x41d06f		4e8b0ccf		MOVQ 0(DI)(R9*8), R9	
		ha := h.arenas[ai.l1()][ai.l2()]
  0x41d073		90			NOPL			
  0x41d074		90			NOPL			
  0x41d075		4981f900004000		CMPQ $0x400000, R9	
  0x41d07c		0f8303010000		JAE 0x41d185		
  0x41d082		4f8b0ccb		MOVQ 0(R11)(R9*8), R9	
		inUse := ha.pageInUse[arenaPage/8:]
  0x41d086		418401			TESTB AL, 0(R9)		
		arenaPage := uint(pageIdx % pagesPerArena)
  0x41d089		4d89d3			MOVQ R10, R11		
  0x41d08c		4981e2ff1f0000		ANDQ $0x1fff, R10	
		inUse := ha.pageInUse[arenaPage/8:]
  0x41d093		4d89d4			MOVQ R10, R12			
  0x41d096		49c1ea03		SHRQ $0x3, R10			
  0x41d09a		4981fa00040000		CMPQ $0x400, R10		
  0x41d0a1		0f87d7000000		JA 0x41d17e			
  0x41d0a7		4d8daa00fcffff		LEAQ 0xfffffc00(R10), R13	
  0x41d0ae		4d89ee			MOVQ R13, R14			
  0x41d0b1		49c1fd3f		SARQ $0x3f, R13			
  0x41d0b5		4d21ea			ANDQ R13, R10			
  0x41d0b8		4f8d2c11		LEAQ 0(R9)(R10*1), R13		
  0x41d0bc		4d8dad00002100		LEAQ 0x210000(R13), R13		
  0x41d0c3		49f7de			NEGQ R14			
		marked := ha.pageMarks[arenaPage/8:]
  0x41d0c6		4f8d1411		LEAQ 0(R9)(R10*1), R10	
  0x41d0ca		4d8d9200042100		LEAQ 0x210400(R10), R10	
		if uintptr(len(inUse)) > n/8 {
  0x41d0d1		4989f7			MOVQ SI, R15		
  0x41d0d4		48c1ee03		SHRQ $0x3, SI		
  0x41d0d8		4939f6			CMPQ SI, R14		
  0x41d0db		7643			JBE 0x41d120		
			inUse = inUse[:n/8]
  0x41d0dd		4885f6			TESTQ SI, SI		
  0x41d0e0		0f8c91000000		JL 0x41d177		
			marked = marked[:n/8]
  0x41d0e6		4c39f6			CMPQ R14, SI		
  0x41d0e9		0f8781000000		JA 0x41d170		
	for n > 0 {
  0x41d0ef		4c897c2468		MOVQ R15, 0x68(SP)	
		ha := h.arenas[ai.l1()][ai.l2()]
  0x41d0f4		4c898c2488000000	MOVQ R9, 0x88(SP)	
		arenaPage := uint(pageIdx % pagesPerArena)
  0x41d0fc		4c89642460		MOVQ R12, 0x60(SP)	
		inUse := ha.pageInUse[arenaPage/8:]
  0x41d101		4c89ac2480000000	MOVQ R13, 0x80(SP)	
		marked := ha.pageMarks[arenaPage/8:]
  0x41d109		4c89542478		MOVQ R10, 0x78(SP)	
		for i := range inUse {
  0x41d10e		4889742430		MOVQ SI, 0x30(SP)	
		ai := arenas[pageIdx/pagesPerArena]
  0x41d113		4c895c2458		MOVQ R11, 0x58(SP)	
  0x41d118		4531f6			XORL R14, R14		
		for i := range inUse {
  0x41d11b		e9b3fdffff		JMP 0x41ced3		
  0x41d120		4c89f6			MOVQ R14, SI		
  0x41d123		ebca			JMP 0x41d0ef		
	if trace.enabled {
  0x41d125		803da4fa0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41d12c		7518			JNE 0x41d146			
	return nFreed
  0x41d12e		48898c24d0000000	MOVQ CX, 0xd0(SP)	
  0x41d136		488bac2490000000	MOVQ 0x90(SP), BP	
  0x41d13e		4881c498000000		ADDQ $0x98, SP		
  0x41d145		c3			RET			
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41d146		48894c2428		MOVQ CX, 0x28(SP)			
  0x41d14b		4829c8			SUBQ CX, AX				
  0x41d14e		48c1e00d		SHLQ $0xd, AX				
  0x41d152		48890424		MOVQ AX, 0(SP)				
  0x41d156		e8b5fb0100		CALL runtime.traceGCSweepSpan(SB)	
	return nFreed
  0x41d15b		488b4c2428		MOVQ 0x28(SP), CX	
		traceGCSweepSpan((n0 - nFreed) * pageSize)
  0x41d160		ebcc			JMP 0x41d12e		
					s := ha.spans[arenaPage+uint(i)*8+j]
  0x41d162		e8b94d0000		CALL runtime.panicindex(SB)	
  0x41d167		0f0b			UD2				
			inUseUnmarked := inUse[i] &^ marked[i]
  0x41d169		e8b24d0000		CALL runtime.panicindex(SB)	
  0x41d16e		0f0b			UD2				
			marked = marked[:n/8]
  0x41d170		e8db4e0000		CALL runtime.panicslice(SB)	
  0x41d175		0f0b			UD2				
			inUse = inUse[:n/8]
  0x41d177		e8d44e0000		CALL runtime.panicslice(SB)	
  0x41d17c		0f0b			UD2				
		inUse := ha.pageInUse[arenaPage/8:]
  0x41d17e		e8cd4e0000		CALL runtime.panicslice(SB)	
  0x41d183		0f0b			UD2				
		ha := h.arenas[ai.l1()][ai.l2()]
  0x41d185		e8964d0000		CALL runtime.panicindex(SB)	
  0x41d18a		0f0b			UD2				
		ai := arenas[pageIdx/pagesPerArena]
  0x41d18c		e88f4d0000		CALL runtime.panicindex(SB)	
  0x41d191		0f0b			UD2				
func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr {
  0x41d193		e8e8a60200		CALL runtime.morestack_noctxt(SB)	
  0x41d198		e9b3fcffff		JMP runtime.(*mheap).reclaimChunk(SB)	

TEXT runtime.(*mheap).alloc_m(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41d1a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d1a9		483b6118		CMPQ 0x18(CX), SP	
  0x41d1ad		0f86ec020000		JBE 0x41d49f		
  0x41d1b3		4883ec48		SUBQ $0x48, SP		
  0x41d1b7		48896c2440		MOVQ BP, 0x40(SP)	
  0x41d1bc		488d6c2440		LEAQ 0x40(SP), BP	
	_g_ := getg()
  0x41d1c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41d1ca		4889442438		MOVQ AX, 0x38(SP)	
	if h.sweepdone == 0 {
  0x41d1cf		488b4c2450		MOVQ 0x50(SP), CX	
  0x41d1d4		83791c00		CMPL $0x0, 0x1c(CX)	
  0x41d1d8		0f8496020000		JE 0x41d474		
	lock(&h.lock)
  0x41d1de		48890c24		MOVQ CX, 0(SP)		
  0x41d1e2		e8f9b4feff		CALL runtime.lock(SB)	
	memstats.heap_scan += uint64(_g_.m.mcache.local_scan)
  0x41d1e7		488b442438		MOVQ 0x38(SP), AX			
  0x41d1ec		488b4830		MOVQ 0x30(AX), CX			
  0x41d1f0		488b8960010000		MOVQ 0x160(CX), CX			
  0x41d1f7		488b4908		MOVQ 0x8(CX), CX			
  0x41d1fb		48010da6210c00		ADDQ CX, runtime.memstats+5960(SB)	
	_g_.m.mcache.local_scan = 0
  0x41d202		488b4830		MOVQ 0x30(AX), CX	
  0x41d206		488b8960010000		MOVQ 0x160(CX), CX	
  0x41d20d		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	memstats.tinyallocs += uint64(_g_.m.mcache.local_tinyallocs)
  0x41d215		488b4830		MOVQ 0x30(AX), CX			
  0x41d219		488b8960010000		MOVQ 0x160(CX), CX			
  0x41d220		488b4920		MOVQ 0x20(CX), CX			
  0x41d224		48010d5d210c00		ADDQ CX, runtime.memstats+5928(SB)	
	_g_.m.mcache.local_tinyallocs = 0
  0x41d22b		488b4030		MOVQ 0x30(AX), AX	
  0x41d22f		488b8060010000		MOVQ 0x160(AX), AX	
  0x41d236		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	s := h.allocSpanLocked(npage, &memstats.heap_inuse)
  0x41d23e		488b442450		MOVQ 0x50(SP), AX				
  0x41d243		48890424		MOVQ AX, 0(SP)					
  0x41d247		488b4c2458		MOVQ 0x58(SP), CX				
  0x41d24c		48894c2408		MOVQ CX, 0x8(SP)				
  0x41d251		488d15500a0c00		LEAQ runtime.memstats+72(SB), DX		
  0x41d258		4889542410		MOVQ DX, 0x10(SP)				
  0x41d25d		e82e060000		CALL runtime.(*mheap).allocSpanLocked(SB)	
  0x41d262		488b442418		MOVQ 0x18(SP), AX				
  0x41d267		4889442430		MOVQ AX, 0x30(SP)				
	if s != nil {
  0x41d26c		4885c0			TESTQ AX, AX		
  0x41d26f		0f8594000000		JNE 0x41d309		
	if gcBlackenEnabled != 0 {
  0x41d275		833d54fa0b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x41d27c		7571			JNE 0x41d2ef				
	if trace.enabled {
  0x41d27e		803d4bf90a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x41d285		7522			JNE 0x41d2a9			
	unlock(&h.lock)
  0x41d287		488b442450		MOVQ 0x50(SP), AX	
  0x41d28c		48890424		MOVQ AX, 0(SP)		
  0x41d290		e8fbb5feff		CALL runtime.unlock(SB)	
	return s
  0x41d295		488b442430		MOVQ 0x30(SP), AX	
  0x41d29a		4889442468		MOVQ AX, 0x68(SP)	
  0x41d29f		488b6c2440		MOVQ 0x40(SP), BP	
  0x41d2a4		4883c448		ADDQ $0x48, SP		
  0x41d2a8		c3			RET			
		traceHeapAlloc()
  0x41d2a9		90			NOPL			
	traceEvent(traceEvHeapAlloc, -1, memstats.heap_live)
  0x41d2aa		48c744242800000000	MOVQ $0x0, 0x28(SP)			
  0x41d2b3		488b05e6200c00		MOVQ runtime.memstats+5952(SB), AX	
  0x41d2ba		4889442428		MOVQ AX, 0x28(SP)			
  0x41d2bf		c6042421		MOVB $0x21, 0(SP)			
  0x41d2c3		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x41d2cc		488d442428		LEAQ 0x28(SP), AX			
  0x41d2d1		4889442410		MOVQ AX, 0x10(SP)			
  0x41d2d6		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x41d2df		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x41d2e8		e8b3eb0100		CALL runtime.traceEvent(SB)		
	unlock(&h.lock)
  0x41d2ed		eb98			JMP 0x41d287		
		gcController.revise()
  0x41d2ef		488d058afe0b00		LEAQ runtime.gcController(SB), AX		
  0x41d2f6		48890424		MOVQ AX, 0(SP)					
  0x41d2fa		e89150ffff		CALL runtime.(*gcControllerState).revise(SB)	
	return s
  0x41d2ff		488b442430		MOVQ 0x30(SP), AX	
		gcController.revise()
  0x41d304		e975ffffff		JMP 0x41d27e		
		atomic.Store(&s.sweepgen, h.sweepgen)
  0x41d309		488b4c2450		MOVQ 0x50(SP), CX	
  0x41d30e		8b5118			MOVL 0x18(CX), DX	
  0x41d311		875058			XCHGL DX, 0x58(AX)	
		h.sweepSpans[h.sweepgen/2%2].push(s) // Add to swept in-use list.
  0x41d314		8b5118			MOVL 0x18(CX), DX			
  0x41d317		d1ea			SHRL $0x1, DX				
  0x41d319		83e201			ANDL $0x1, DX				
  0x41d31c		488d1492		LEAQ 0(DX)(DX*4), DX			
  0x41d320		488d14d1		LEAQ 0(CX)(DX*8), DX			
  0x41d324		488d5240		LEAQ 0x40(DX), DX			
  0x41d328		48891424		MOVQ DX, 0(SP)				
  0x41d32c		4889442408		MOVQ AX, 0x8(SP)			
  0x41d331		e8fadeffff		CALL runtime.(*gcSweepBuf).push(SB)	
		s.state = mSpanInUse
  0x41d336		488b442430		MOVQ 0x30(SP), AX	
  0x41d33b		c6406301		MOVB $0x1, 0x63(AX)	
		s.allocCount = 0
  0x41d33f		66c740600000		MOVW $0x0, 0x60(AX)	
		s.spanclass = spanclass
  0x41d345		0fb64c2460		MOVZX 0x60(SP), CX	
  0x41d34a		884862			MOVB CL, 0x62(AX)	
		if sizeclass := spanclass.sizeclass(); sizeclass == 0 {
  0x41d34d		90			NOPL			
	return int8(sc >> 1)
  0x41d34e		d0e9			SHRL $0x1, CL		
		if sizeclass := spanclass.sizeclass(); sizeclass == 0 {
  0x41d350		84c9			TESTL CL, CL		
  0x41d352		0f85cb000000		JNE 0x41d423		
			s.elemsize = s.npages << _PageShift
  0x41d358		488b4820		MOVQ 0x20(AX), CX	
  0x41d35c		48c1e10d		SHLQ $0xd, CX		
  0x41d360		48894868		MOVQ CX, 0x68(AX)	
			s.divShift = 0
  0x41d364		c6406500		MOVB $0x0, 0x65(AX)	
			s.divMul = 0
  0x41d368		66c7405c0000		MOVW $0x0, 0x5c(AX)	
			s.divShift2 = 0
  0x41d36e		c6406600		MOVB $0x0, 0x66(AX)	
			s.baseMask = 0
  0x41d372		66c7405e0000		MOVW $0x0, 0x5e(AX)	
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41d378		488b0dd1950a00		MOVQ runtime.mheap_+784(SB), CX	
  0x41d37f		8401			TESTB AL, 0(CX)			
		arena, pageIdx, pageMask := pageIndexOf(s.base())
  0x41d381		90			NOPL			
  0x41d382		90			NOPL			
	return s.startAddr
  0x41d383		488b5018		MOVQ 0x18(AX), DX	
	ai := arenaIndex(p)
  0x41d387		90			NOPL			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41d388		90			NOPL			
  0x41d389		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41d38a		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x41d394		4801d3			ADDQ DX, BX			
  0x41d397		48c1eb1a		SHRQ $0x1a, BX			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41d39b		4881fb00004000		CMPQ $0x400000, BX	
  0x41d3a2		0f83e9000000		JAE 0x41d491		
  0x41d3a8		488b0cd9		MOVQ 0(CX)(BX*8), CX	
		arena.pageInUse[pageIdx] |= pageMask
  0x41d3ac		8401			TESTB AL, 0(CX)		
	pageIdx = ((p / pageSize) / 8) % uintptr(len(arena.pageInUse))
  0x41d3ae		4889d3			MOVQ DX, BX		
  0x41d3b1		48c1ea10		SHRQ $0x10, DX		
  0x41d3b5		4881e2ff030000		ANDQ $0x3ff, DX		
		arena.pageInUse[pageIdx] |= pageMask
  0x41d3bc		0fb6b41100002100	MOVZX 0x210000(CX)(DX*1), SI	
	pageMask = byte(1 << ((p / pageSize) % 8))
  0x41d3c4		48c1eb0d		SHRQ $0xd, BX		
  0x41d3c8		4883e307		ANDQ $0x7, BX		
		arena.pageInUse[pageIdx] |= pageMask
  0x41d3cc		0fabde			BTSL BX, SI			
  0x41d3cf		4088b41100002100	MOVB SI, 0x210000(CX)(DX*1)	
		h.pagesInUse += uint64(npage)
  0x41d3d7		488b4c2458		MOVQ 0x58(SP), CX	
  0x41d3dc		488b542450		MOVQ 0x50(SP), DX	
  0x41d3e1		48018a98000000		ADDQ CX, 0x98(DX)	
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41d3e8		0fb65c2461		MOVZX 0x61(SP), BX	
  0x41d3ed		84db			TESTL BL, BL		
		if large {
  0x41d3ef		0f8480feffff		JE 0x41d275		
			memstats.heap_objects++
  0x41d3f5		48ff05bc080c00		INCQ runtime.memstats+88(SB)	
			mheap_.largealloc += uint64(s.elemsize)
  0x41d3fc		488b5868		MOVQ 0x68(AX), BX		
  0x41d400		48011d11930a00		ADDQ BX, runtime.mheap_+216(SB)	
			mheap_.nlargealloc++
  0x41d407		48ff0512930a00		INCQ runtime.mheap_+224(SB)	
			atomic.Xadd64(&memstats.heap_live, int64(npage<<_PageShift))
  0x41d40e		48c1e10d		SHLQ $0xd, CX				
  0x41d412		488d1d871f0c00		LEAQ runtime.memstats+5952(SB), BX	
  0x41d419		f0480fc10b		LOCK XADDQ CX, 0(BX)			
  0x41d41e		e952feffff		JMP 0x41d275				
			s.elemsize = uintptr(class_to_size[sizeclass])
  0x41d423		480fbec9		MOVSX CL, CX				
  0x41d427		4883f943		CMPQ $0x43, CX				
  0x41d42b		736b			JAE 0x41d498				
  0x41d42d		488d15ac1d0a00		LEAQ runtime.class_to_size(SB), DX	
  0x41d434		0fb7144a		MOVZX 0(DX)(CX*2), DX			
  0x41d438		48895068		MOVQ DX, 0x68(AX)			
			m := &class_to_divmagic[sizeclass]
  0x41d43c		488d0c49		LEAQ 0(CX)(CX*2), CX	
  0x41d440		4889ca			MOVQ CX, DX		
  0x41d443		48d1e1			SHLQ $0x1, CX		
			s.divShift = m.shift
  0x41d446		488d1d53230a00		LEAQ runtime.class_to_divmagic(SB), BX	
  0x41d44d		0fb6340b		MOVZX 0(BX)(CX*1), SI			
  0x41d451		40887065		MOVB SI, 0x65(AX)			
			s.divMul = m.mul
  0x41d455		0fb7745302		MOVZX 0x2(BX)(DX*2), SI	
  0x41d45a		6689705c		MOVW SI, 0x5c(AX)	
			s.divShift2 = m.shift2
  0x41d45e		0fb64c0b01		MOVZX 0x1(BX)(CX*1), CX	
  0x41d463		884866			MOVB CL, 0x66(AX)	
			s.baseMask = m.baseMask
  0x41d466		0fb74c5304		MOVZX 0x4(BX)(DX*2), CX	
  0x41d46b		6689485e		MOVW CX, 0x5e(AX)	
  0x41d46f		e904ffffff		JMP 0x41d378		
		h.reclaim(npage)
  0x41d474		48890c24		MOVQ CX, 0(SP)				
  0x41d478		488b442458		MOVQ 0x58(SP), AX			
  0x41d47d		4889442408		MOVQ AX, 0x8(SP)			
  0x41d482		e869f7ffff		CALL runtime.(*mheap).reclaim(SB)	
	lock(&h.lock)
  0x41d487		488b4c2450		MOVQ 0x50(SP), CX	
		h.reclaim(npage)
  0x41d48c		e94dfdffff		JMP 0x41d1de		
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41d491		e88a4a0000		CALL runtime.panicindex(SB)	
  0x41d496		0f0b			UD2				
			s.elemsize = uintptr(class_to_size[sizeclass])
  0x41d498		e8834a0000		CALL runtime.panicindex(SB)	
  0x41d49d		0f0b			UD2				
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {
  0x41d49f		e82cc20100		CALL runtime.morestackc(SB)		
  0x41d4a4		e9f7fcffff		JMP runtime.(*mheap).alloc_m(SB)	

TEXT runtime.(*mheap).alloc(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41d4b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d4b9		483b6110		CMPQ 0x10(CX), SP	
  0x41d4bd		0f86ca000000		JBE 0x41d58d		
  0x41d4c3		4883ec48		SUBQ $0x48, SP		
  0x41d4c7		48896c2440		MOVQ BP, 0x40(SP)	
  0x41d4cc		488d6c2440		LEAQ 0x40(SP), BP	
	var s *mspan
  0x41d4d1		48c744241000000000	MOVQ $0x0, 0x10(SP)	
	systemstack(func() {
  0x41d4da		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41d4e3		0f57c0			XORPS X0, X0					
  0x41d4e6		0f11442420		MOVUPS X0, 0x20(SP)				
  0x41d4eb		0f11442430		MOVUPS X0, 0x30(SP)				
  0x41d4f0		488d0599850200		LEAQ runtime.(*mheap).alloc.func1(SB), AX	
  0x41d4f7		4889442418		MOVQ AX, 0x18(SP)				
  0x41d4fc		488b442450		MOVQ 0x50(SP), AX				
  0x41d501		4889442420		MOVQ AX, 0x20(SP)				
  0x41d506		488b442458		MOVQ 0x58(SP), AX				
  0x41d50b		4889442428		MOVQ AX, 0x28(SP)				
  0x41d510		0fb6442460		MOVZX 0x60(SP), AX				
  0x41d515		88442430		MOVB AL, 0x30(SP)				
  0x41d519		0fb6442461		MOVZX 0x61(SP), AX				
  0x41d51e		88442431		MOVB AL, 0x31(SP)				
  0x41d522		488d442410		LEAQ 0x10(SP), AX				
  0x41d527		4889442438		MOVQ AX, 0x38(SP)				
  0x41d52c		488d442418		LEAQ 0x18(SP), AX				
  0x41d531		48890424		MOVQ AX, 0(SP)					
  0x41d535		e8f6a10200		CALL runtime.systemstack(SB)			
	if s != nil {
  0x41d53a		488b442410		MOVQ 0x10(SP), AX	
  0x41d53f		4885c0			TESTQ AX, AX		
  0x41d542		7418			JE 0x41d55c		
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41d544		0fb64c2462		MOVZX 0x62(SP), CX	
  0x41d549		84c9			TESTL CL, CL		
		if needzero && s.needzero != 0 {
  0x41d54b		7406			JE 0x41d553		
  0x41d54d		80786400		CMPB $0x0, 0x64(AX)	
  0x41d551		751d			JNE 0x41d570		
		s.needzero = 0
  0x41d553		488b442410		MOVQ 0x10(SP), AX	
  0x41d558		c6406400		MOVB $0x0, 0x64(AX)	
	return s
  0x41d55c		488b442410		MOVQ 0x10(SP), AX	
  0x41d561		4889442468		MOVQ AX, 0x68(SP)	
  0x41d566		488b6c2440		MOVQ 0x40(SP), BP	
  0x41d56b		4883c448		ADDQ $0x48, SP		
  0x41d56f		c3			RET			
	return s.startAddr
  0x41d570		488b4818		MOVQ 0x18(AX), CX	
			memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41d574		90			NOPL					
  0x41d575		488b4020		MOVQ 0x20(AX), AX			
  0x41d579		48890c24		MOVQ CX, 0(SP)				
  0x41d57d		48c1e00d		SHLQ $0xd, AX				
  0x41d581		4889442408		MOVQ AX, 0x8(SP)			
  0x41d586		e835cf0200		CALL runtime.memclrNoHeapPointers(SB)	
  0x41d58b		ebc6			JMP 0x41d553				
func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {
  0x41d58d		e8eea20200		CALL runtime.morestack_noctxt(SB)	
  0x41d592		e919ffffff		JMP runtime.(*mheap).alloc(SB)		

TEXT runtime.(*mheap).allocManual(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41d5a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d5a9		483b6118		CMPQ 0x18(CX), SP	
  0x41d5ad		0f86b7000000		JBE 0x41d66a		
  0x41d5b3		4883ec30		SUBQ $0x30, SP		
  0x41d5b7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41d5bc		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&h.lock)
  0x41d5c1		488b442438		MOVQ 0x38(SP), AX	
  0x41d5c6		8400			TESTB AL, 0(AX)		
  0x41d5c8		48890424		MOVQ AX, 0(SP)		
  0x41d5cc		e80fb1feff		CALL runtime.lock(SB)	
	s := h.allocSpanLocked(npage, stat)
  0x41d5d1		488b442438		MOVQ 0x38(SP), AX				
  0x41d5d6		48890424		MOVQ AX, 0(SP)					
  0x41d5da		488b4c2440		MOVQ 0x40(SP), CX				
  0x41d5df		48894c2408		MOVQ CX, 0x8(SP)				
  0x41d5e4		488b4c2448		MOVQ 0x48(SP), CX				
  0x41d5e9		48894c2410		MOVQ CX, 0x10(SP)				
  0x41d5ee		e89d020000		CALL runtime.(*mheap).allocSpanLocked(SB)	
  0x41d5f3		488b442418		MOVQ 0x18(SP), AX				
  0x41d5f8		4889442420		MOVQ AX, 0x20(SP)				
	if s != nil {
  0x41d5fd		4885c0			TESTQ AX, AX		
  0x41d600		7446			JE 0x41d648		
		s.state = mSpanManual
  0x41d602		c6406302		MOVB $0x2, 0x63(AX)	
		s.manualFreeList = 0
  0x41d606		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		s.allocCount = 0
  0x41d60e		66c740600000		MOVW $0x0, 0x60(AX)	
		s.spanclass = 0
  0x41d614		c6406200		MOVB $0x0, 0x62(AX)	
		s.nelems = 0
  0x41d618		48c7403800000000	MOVQ $0x0, 0x38(AX)	
		s.elemsize = 0
  0x41d620		48c7406800000000	MOVQ $0x0, 0x68(AX)	
		s.limit = s.base() + s.npages<<_PageShift
  0x41d628		90			NOPL			
  0x41d629		488b4820		MOVQ 0x20(AX), CX	
  0x41d62d		48c1e10d		SHLQ $0xd, CX		
  0x41d631		48034818		ADDQ 0x18(AX), CX	
  0x41d635		48894878		MOVQ CX, 0x78(AX)	
		memstats.heap_sys -= uint64(s.npages << _PageShift)
  0x41d639		488b4820		MOVQ 0x20(AX), CX			
  0x41d63d		48c1e10d		SHLQ $0xd, CX				
  0x41d641		48290d50060c00		SUBQ CX, runtime.memstats+56(SB)	
	unlock(&h.lock)
  0x41d648		488b442438		MOVQ 0x38(SP), AX	
  0x41d64d		48890424		MOVQ AX, 0(SP)		
  0x41d651		e83ab2feff		CALL runtime.unlock(SB)	
	return s
  0x41d656		488b442420		MOVQ 0x20(SP), AX	
  0x41d65b		4889442450		MOVQ AX, 0x50(SP)	
  0x41d660		488b6c2428		MOVQ 0x28(SP), BP	
  0x41d665		4883c430		ADDQ $0x30, SP		
  0x41d669		c3			RET			
func (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan {
  0x41d66a		e861c00100		CALL runtime.morestackc(SB)		
  0x41d66f		e92cffffff		JMP runtime.(*mheap).allocManual(SB)	

TEXT runtime.(*mheap).setSpans(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) setSpans(base, npage uintptr, s *mspan) {
  0x41d680		4883ec08		SUBQ $0x8, SP		
  0x41d684		48892c24		MOVQ BP, 0(SP)		
  0x41d688		488d2c24		LEAQ 0(SP), BP		
	ha := h.arenas[ai.l1()][ai.l2()]
  0x41d68c		488b442410		MOVQ 0x10(SP), AX	
  0x41d691		488b8810030000		MOVQ 0x310(AX), CX	
  0x41d698		8401			TESTB AL, 0(CX)		
	ai := arenaIndex(base)
  0x41d69a		90			NOPL			
	ha := h.arenas[ai.l1()][ai.l2()]
  0x41d69b		90			NOPL			
  0x41d69c		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41d69d		488b542418		MOVQ 0x18(SP), DX		
  0x41d6a2		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x41d6ac		488d3413		LEAQ 0(BX)(DX*1), SI		
  0x41d6b0		48c1ee1a		SHRQ $0x1a, SI			
	ha := h.arenas[ai.l1()][ai.l2()]
  0x41d6b4		4881fe00004000		CMPQ $0x400000, SI	
  0x41d6bb		0f8382000000		JAE 0x41d743		
	p := base / pageSize
  0x41d6c1		4889d7			MOVQ DX, DI		
  0x41d6c4		48c1ea0d		SHRQ $0xd, DX		
	ha := h.arenas[ai.l1()][ai.l2()]
  0x41d6c8		488b0cf1		MOVQ 0(CX)(SI*8), CX	
	for n := uintptr(0); n < npage; n++ {
  0x41d6cc		488b742420		MOVQ 0x20(SP), SI	
  0x41d6d1		4c8b442428		MOVQ 0x28(SP), R8	
  0x41d6d6		4531c9			XORL R9, R9		
  0x41d6d9		eb15			JMP 0x41d6f0		
		ha.spans[i] = s
  0x41d6db		8401			TESTB AL, 0(CX)		
		i := (p + n) % pagesPerArena
  0x41d6dd		4981e2ff1f0000		ANDQ $0x1fff, R10	
		ha.spans[i] = s
  0x41d6e4		4e8984d100002000	MOVQ R8, 0x200000(CX)(R10*8)	
	for n := uintptr(0); n < npage; n++ {
  0x41d6ec		4d8d4b01		LEAQ 0x1(R11), R9	
  0x41d6f0		4939f1			CMPQ SI, R9		
  0x41d6f3		733e			JAE 0x41d733		
		i := (p + n) % pagesPerArena
  0x41d6f5		4e8d140a		LEAQ 0(DX)(R9*1), R10	
		if i == 0 {
  0x41d6f9		49f7c2ff1f0000		TESTQ $0x1fff, R10	
  0x41d700		752c			JNE 0x41d72e		
			ha = h.arenas[ai.l1()][ai.l2()]
  0x41d702		488b8810030000		MOVQ 0x310(AX), CX	
  0x41d709		8401			TESTB AL, 0(CX)		
			ai = arenaIndex(base + n*pageSize)
  0x41d70b		90			NOPL			
  0x41d70c		4d89cb			MOVQ R9, R11		
  0x41d70f		49c1e10d		SHLQ $0xd, R9		
  0x41d713		4901f9			ADDQ DI, R9		
			ha = h.arenas[ai.l1()][ai.l2()]
  0x41d716		90			NOPL			
  0x41d717		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41d718		4901d9			ADDQ BX, R9		
  0x41d71b		49c1e91a		SHRQ $0x1a, R9		
			ha = h.arenas[ai.l1()][ai.l2()]
  0x41d71f		4981f900004000		CMPQ $0x400000, R9	
  0x41d726		7314			JAE 0x41d73c		
  0x41d728		4a8b0cc9		MOVQ 0(CX)(R9*8), CX	
  0x41d72c		ebad			JMP 0x41d6db		
	for n := uintptr(0); n < npage; n++ {
  0x41d72e		4d89cb			MOVQ R9, R11		
		if i == 0 {
  0x41d731		eba8			JMP 0x41d6db		
  0x41d733		488b2c24		MOVQ 0(SP), BP		
  0x41d737		4883c408		ADDQ $0x8, SP		
  0x41d73b		c3			RET			
			ha = h.arenas[ai.l1()][ai.l2()]
  0x41d73c		e8df470000		CALL runtime.panicindex(SB)	
  0x41d741		0f0b			UD2				
	ha := h.arenas[ai.l1()][ai.l2()]
  0x41d743		e8d8470000		CALL runtime.panicindex(SB)	
  0x41d748		0f0b			UD2				

TEXT runtime.(*mheap).pickFreeSpan(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) pickFreeSpan(npage uintptr) *mspan {
  0x41d750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d759		483b6110		CMPQ 0x10(CX), SP	
  0x41d75d		0f8614010000		JBE 0x41d877		
  0x41d763		4883ec40		SUBQ $0x40, SP		
  0x41d767		48896c2438		MOVQ BP, 0x38(SP)	
  0x41d76c		488d6c2438		LEAQ 0x38(SP), BP	
	tf := h.free.find(npage)
  0x41d771		488b442448		MOVQ 0x48(SP), AX		
  0x41d776		8400			TESTB AL, 0(AX)			
  0x41d778		488d4808		LEAQ 0x8(AX), CX		
  0x41d77c		48894c2430		MOVQ CX, 0x30(SP)		
  0x41d781		48890c24		MOVQ CX, 0(SP)			
  0x41d785		488b542450		MOVQ 0x50(SP), DX		
  0x41d78a		4889542408		MOVQ DX, 0x8(SP)		
  0x41d78f		e89c88ffff		CALL runtime.(*mTreap).find(SB)	
  0x41d794		488b442410		MOVQ 0x10(SP), AX		
  0x41d799		4889442418		MOVQ AX, 0x18(SP)		
	ts := h.scav.find(npage)
  0x41d79e		488b4c2448		MOVQ 0x48(SP), CX		
  0x41d7a3		4883c110		ADDQ $0x10, CX			
  0x41d7a7		48894c2428		MOVQ CX, 0x28(SP)		
  0x41d7ac		48890c24		MOVQ CX, 0(SP)			
  0x41d7b0		488b542450		MOVQ 0x50(SP), DX		
  0x41d7b5		4889542408		MOVQ DX, 0x8(SP)		
  0x41d7ba		e87188ffff		CALL runtime.(*mTreap).find(SB)	
  0x41d7bf		488b442410		MOVQ 0x10(SP), AX		
	if tf != nil && (ts == nil || tf.spanKey.npages <= ts.spanKey.npages) {
  0x41d7c4		488b4c2418		MOVQ 0x18(SP), CX	
  0x41d7c9		4885c9			TESTQ CX, CX		
  0x41d7cc		7420			JE 0x41d7ee		
  0x41d7ce		4885c0			TESTQ AX, AX		
  0x41d7d1		0f8496000000		JE 0x41d86d		
  0x41d7d7		488b5120		MOVQ 0x20(CX), DX	
  0x41d7db		488b5820		MOVQ 0x20(AX), BX	
  0x41d7df		488b5b20		MOVQ 0x20(BX), BX	
  0x41d7e3		48395a20		CMPQ BX, 0x20(DX)	
  0x41d7e7		0f96c2			SETBE DL		
  0x41d7ea		84d2			TESTL DL, DL		
  0x41d7ec		755c			JNE 0x41d84a		
	} else if ts != nil && (tf == nil || tf.spanKey.npages > ts.spanKey.npages) {
  0x41d7ee		4885c0			TESTQ AX, AX		
  0x41d7f1		741c			JE 0x41d80f		
	if tf != nil && (ts == nil || tf.spanKey.npages <= ts.spanKey.npages) {
  0x41d7f3		4885c9			TESTQ CX, CX		
	} else if ts != nil && (tf == nil || tf.spanKey.npages > ts.spanKey.npages) {
  0x41d7f6		744b			JE 0x41d843		
  0x41d7f8		488b4920		MOVQ 0x20(CX), CX	
  0x41d7fc		488b5020		MOVQ 0x20(AX), DX	
  0x41d800		488b5220		MOVQ 0x20(DX), DX	
  0x41d804		48395120		CMPQ DX, 0x20(CX)	
  0x41d808		0f97c1			SETA CL			
  0x41d80b		84c9			TESTL CL, CL		
  0x41d80d		7511			JNE 0x41d820		
  0x41d80f		31c0			XORL AX, AX		
	return s
  0x41d811		4889442458		MOVQ AX, 0x58(SP)	
  0x41d816		488b6c2438		MOVQ 0x38(SP), BP	
  0x41d81b		4883c440		ADDQ $0x40, SP		
  0x41d81f		c3			RET			
		s = ts.spanKey
  0x41d820		488b4820		MOVQ 0x20(AX), CX	
  0x41d824		48894c2420		MOVQ CX, 0x20(SP)	
		h.scav.removeNode(ts)
  0x41d829		488b542428		MOVQ 0x28(SP), DX			
  0x41d82e		48891424		MOVQ DX, 0(SP)				
  0x41d832		4889442408		MOVQ AX, 0x8(SP)			
  0x41d837		e8d486ffff		CALL runtime.(*mTreap).removeNode(SB)	
	return s
  0x41d83c		488b442420		MOVQ 0x20(SP), AX	
		h.scav.removeNode(ts)
  0x41d841		ebce			JMP 0x41d811		
  0x41d843		b901000000		MOVL $0x1, CX		
	} else if ts != nil && (tf == nil || tf.spanKey.npages > ts.spanKey.npages) {
  0x41d848		ebc1			JMP 0x41d80b		
		s = tf.spanKey
  0x41d84a		488b4120		MOVQ 0x20(CX), AX	
  0x41d84e		4889442420		MOVQ AX, 0x20(SP)	
		h.free.removeNode(tf)
  0x41d853		488b542430		MOVQ 0x30(SP), DX			
  0x41d858		48891424		MOVQ DX, 0(SP)				
  0x41d85c		48894c2408		MOVQ CX, 0x8(SP)			
  0x41d861		e8aa86ffff		CALL runtime.(*mTreap).removeNode(SB)	
	return s
  0x41d866		488b442420		MOVQ 0x20(SP), AX	
		h.free.removeNode(tf)
  0x41d86b		eba4			JMP 0x41d811		
  0x41d86d		ba01000000		MOVL $0x1, DX		
	if tf != nil && (ts == nil || tf.spanKey.npages <= ts.spanKey.npages) {
  0x41d872		e973ffffff		JMP 0x41d7ea		
func (h *mheap) pickFreeSpan(npage uintptr) *mspan {
  0x41d877		e804a00200		CALL runtime.morestack_noctxt(SB)	
  0x41d87c		e9cffeffff		JMP runtime.(*mheap).pickFreeSpan(SB)	

TEXT runtime.(*mheap).allocSpanLocked(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {
  0x41d890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41d899		483b6110		CMPQ 0x10(CX), SP	
  0x41d89d		0f8657040000		JBE 0x41dcfa		
  0x41d8a3		4883ec30		SUBQ $0x30, SP		
  0x41d8a7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41d8ac		488d6c2428		LEAQ 0x28(SP), BP	
	s = h.pickFreeSpan(npage)
  0x41d8b1		488b442438		MOVQ 0x38(SP), AX			
  0x41d8b6		48890424		MOVQ AX, 0(SP)				
  0x41d8ba		488b4c2440		MOVQ 0x40(SP), CX			
  0x41d8bf		48894c2408		MOVQ CX, 0x8(SP)			
  0x41d8c4		e887feffff		CALL runtime.(*mheap).pickFreeSpan(SB)	
  0x41d8c9		488b442410		MOVQ 0x10(SP), AX			
	if s != nil {
  0x41d8ce		4885c0			TESTQ AX, AX		
  0x41d8d1		0f8448030000		JE 0x41dc1f		
	if s.state != mSpanFree {
  0x41d8d7		80786303		CMPB $0x3, 0x63(AX)	
  0x41d8db		0f85e3030000		JNE 0x41dcc4		
	if s.npages < npage {
  0x41d8e1		488b4820		MOVQ 0x20(AX), CX	
  0x41d8e5		488b542440		MOVQ 0x40(SP), DX	
  0x41d8ea		4839d1			CMPQ DX, CX		
  0x41d8ed		0f82b6030000		JB 0x41dca9		
	memstats.heap_released -= uint64(s.released())
  0x41d8f3		90			NOPL			
	if !s.scavenged {
  0x41d8f4		80786700		CMPB $0x0, 0x67(AX)	
  0x41d8f8		0f841a030000		JE 0x41dc18		
	start, end := s.physPageBounds()
  0x41d8fe		90			NOPL			
	start := s.base()
  0x41d8ff		90			NOPL			
	end := start + s.npages<<_PageShift
  0x41d900		48c1e10d		SHLQ $0xd, CX		
	return s.startAddr
  0x41d904		488b5818		MOVQ 0x18(AX), BX	
	end := start + s.npages<<_PageShift
  0x41d908		4801d9			ADDQ BX, CX		
	if physPageSize > _PageSize {
  0x41d90b		488b3596f40b00		MOVQ runtime.physPageSize(SB), SI	
  0x41d912		4881fe00200000		CMPQ $0x2000, SI			
  0x41d919		0f86f1020000		JBE 0x41dc10				
		start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41d91f		488d1c1e		LEAQ 0(SI)(BX*1), BX	
  0x41d923		488d5bff		LEAQ -0x1(BX), BX	
  0x41d927		48ffce			DECQ SI			
  0x41d92a		48f7d6			NOTQ SI			
  0x41d92d		4821f3			ANDQ SI, BX		
		end &^= physPageSize - 1
  0x41d930		4821ce			ANDQ CX, SI		
	return end - start
  0x41d933		4829de			SUBQ BX, SI		
	if s.state != mSpanFree {
  0x41d936		4889442420		MOVQ AX, 0x20(SP)	
	memstats.heap_released -= uint64(s.released())
  0x41d93b		4829356e030c00		SUBQ SI, runtime.memstats+80(SB)	
	if s.npages > npage {
  0x41d942		48395020		CMPQ DX, 0x20(AX)	
  0x41d946		0f87be000000		JA 0x41da0a		
	if s.scavenged {
  0x41d94c		80786700		CMPB $0x0, 0x67(AX)	
  0x41d950		7562			JNE 0x41d9b4		
	s.unusedsince = 0
  0x41d952		48c7407000000000	MOVQ $0x0, 0x70(AX)	
	h.setSpans(s.base(), npage, s)
  0x41d95a		90			NOPL			
	return s.startAddr
  0x41d95b		488b4818		MOVQ 0x18(AX), CX	
	h.setSpans(s.base(), npage, s)
  0x41d95f		488b5c2438		MOVQ 0x38(SP), BX			
  0x41d964		48891c24		MOVQ BX, 0(SP)				
  0x41d968		48894c2408		MOVQ CX, 0x8(SP)			
  0x41d96d		4889542410		MOVQ DX, 0x10(SP)			
  0x41d972		4889442418		MOVQ AX, 0x18(SP)			
  0x41d977		e804fdffff		CALL runtime.(*mheap).setSpans(SB)	
	*stat += uint64(npage << _PageShift)
  0x41d97c		488b442440		MOVQ 0x40(SP), AX	
  0x41d981		48c1e00d		SHLQ $0xd, AX		
  0x41d985		488b4c2448		MOVQ 0x48(SP), CX	
  0x41d98a		480101			ADDQ AX, 0(CX)		
	memstats.heap_idle -= uint64(npage << _PageShift)
  0x41d98d		4829050c030c00		SUBQ AX, runtime.memstats+64(SB)	
	if s.inList() {
  0x41d994		90			NOPL			
	return span.list != nil
  0x41d995		488b442420		MOVQ 0x20(SP), AX	
  0x41d99a		4883781000		CMPQ $0x0, 0x10(AX)	
	if s.inList() {
  0x41d99f		0f85d4020000		JNE 0x41dc79		
	return s
  0x41d9a5		4889442450		MOVQ AX, 0x50(SP)	
  0x41d9aa		488b6c2428		MOVQ 0x28(SP), BP	
  0x41d9af		4883c430		ADDQ $0x30, SP		
  0x41d9b3		c3			RET			
	return s.startAddr
  0x41d9b4		488b4818		MOVQ 0x18(AX), CX	
		sysUsed(unsafe.Pointer(s.base()), s.npages<<_PageShift)
  0x41d9b8		90			NOPL				
  0x41d9b9		488b5020		MOVQ 0x20(AX), DX		
  0x41d9bd		48890c24		MOVQ CX, 0(SP)			
  0x41d9c1		48c1e20d		SHLQ $0xd, DX			
  0x41d9c5		4889542408		MOVQ DX, 0x8(SP)		
  0x41d9ca		e8313dffff		CALL runtime.sysUsed(SB)	
		s.scavenged = false
  0x41d9cf		488b442420		MOVQ 0x20(SP), AX	
  0x41d9d4		c6406700		MOVB $0x0, 0x67(AX)	
		s.state = mSpanManual
  0x41d9d8		c6406302		MOVB $0x2, 0x63(AX)	
		h.scavengeLargest(s.npages * pageSize)
  0x41d9dc		488b4820		MOVQ 0x20(AX), CX				
  0x41d9e0		488b542438		MOVQ 0x38(SP), DX				
  0x41d9e5		48891424		MOVQ DX, 0(SP)					
  0x41d9e9		48c1e10d		SHLQ $0xd, CX					
  0x41d9ed		48894c2408		MOVQ CX, 0x8(SP)				
  0x41d9f2		e839090000		CALL runtime.(*mheap).scavengeLargest(SB)	
		s.state = mSpanFree
  0x41d9f7		488b442420		MOVQ 0x20(SP), AX	
  0x41d9fc		c6406303		MOVB $0x3, 0x63(AX)	
	h.setSpans(s.base(), npage, s)
  0x41da00		488b542440		MOVQ 0x40(SP), DX	
		s.state = mSpanFree
  0x41da05		e948ffffff		JMP 0x41d952		
		t := (*mspan)(h.spanalloc.alloc())
  0x41da0a		488b442438		MOVQ 0x38(SP), AX			
  0x41da0f		8400			TESTB AL, 0(AX)				
  0x41da11		488d8800250000		LEAQ 0x2500(AX), CX			
  0x41da18		48890c24		MOVQ CX, 0(SP)				
  0x41da1c		e86f41ffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41da21		488b442408		MOVQ 0x8(SP), AX			
		t.init(s.base()+npage<<_PageShift, s.npages-npage)
  0x41da26		90			NOPL			
  0x41da27		90			NOPL			
  0x41da28		488b4c2440		MOVQ 0x40(SP), CX	
  0x41da2d		4889ca			MOVQ CX, DX		
  0x41da30		48c1e10d		SHLQ $0xd, CX		
  0x41da34		488b5c2420		MOVQ 0x20(SP), BX	
  0x41da39		48034b18		ADDQ 0x18(BX), CX	
  0x41da3d		488b7320		MOVQ 0x20(BX), SI	
	span.prev = nil
  0x41da41		0f57c0			XORPS X0, X0		
  0x41da44		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41da47		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	span.startAddr = base
  0x41da4f		48894818		MOVQ CX, 0x18(AX)	
		t.init(s.base()+npage<<_PageShift, s.npages-npage)
  0x41da53		4829d6			SUBQ DX, SI		
	span.npages = npages
  0x41da56		48897020		MOVQ SI, 0x20(AX)	
	span.allocCount = 0
  0x41da5a		66c740600000		MOVW $0x0, 0x60(AX)	
	span.spanclass = 0
  0x41da60		c6406200		MOVB $0x0, 0x62(AX)	
	span.elemsize = 0
  0x41da64		48c7406800000000	MOVQ $0x0, 0x68(AX)	
	span.state = mSpanDead
  0x41da6c		c6406300		MOVB $0x0, 0x63(AX)	
	span.unusedsince = 0
  0x41da70		48c7407000000000	MOVQ $0x0, 0x70(AX)	
	span.scavenged = false
  0x41da78		c6406700		MOVB $0x0, 0x67(AX)	
	span.specials = nil
  0x41da7c		0f118080000000		MOVUPS X0, 0x80(AX)	
	span.needzero = 0
  0x41da83		c6406400		MOVB $0x0, 0x64(AX)	
	span.freeindex = 0
  0x41da87		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	span.gcmarkBits = nil
  0x41da8f		0f114048		MOVUPS X0, 0x48(AX)	
		s.npages = npage
  0x41da93		48895320		MOVQ DX, 0x20(BX)	
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41da97		488b4c2438		MOVQ 0x38(SP), CX	
  0x41da9c		488bb110030000		MOVQ 0x310(CX), SI	
  0x41daa3		8406			TESTB AL, 0(SI)		
		h.setSpan(t.base()-1, s)
  0x41daa5		90			NOPL			
  0x41daa6		90			NOPL			
	return s.startAddr
  0x41daa7		488b7818		MOVQ 0x18(AX), DI	
	ai := arenaIndex(base)
  0x41daab		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41daac		90			NOPL			
  0x41daad		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41daae		49b8ffffffffff7f0000	MOVQ $0x7fffffffffff, R8	
  0x41dab8		4d8d0c38		LEAQ 0(R8)(DI*1), R9		
  0x41dabc		49c1e91a		SHRQ $0x1a, R9			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41dac0		4981f900004000		CMPQ $0x400000, R9	
  0x41dac7		0f83d5010000		JAE 0x41dca2		
  0x41dacd		4a8b34ce		MOVQ 0(SI)(R9*8), SI	
  0x41dad1		8406			TESTB AL, 0(SI)		
		h.setSpan(t.base()-1, s)
  0x41dad3		48ffcf			DECQ DI			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41dad6		48c1ef0d		SHRQ $0xd, DI			
  0x41dada		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x41dae1		48899cfe00002000	MOVQ BX, 0x200000(SI)(DI*8)	
  0x41dae9		488bb110030000		MOVQ 0x310(CX), SI		
  0x41daf0		8406			TESTB AL, 0(SI)			
		h.setSpan(t.base(), t)
  0x41daf2		90			NOPL			
  0x41daf3		90			NOPL			
	return s.startAddr
  0x41daf4		488b7818		MOVQ 0x18(AX), DI	
	ai := arenaIndex(base)
  0x41daf8		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41daf9		90			NOPL			
  0x41dafa		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41dafb		49b90000000000800000	MOVQ $0x800000000000, R9	
  0x41db05		4901f9			ADDQ DI, R9			
  0x41db08		49c1e91a		SHRQ $0x1a, R9			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41db0c		4981f900004000		CMPQ $0x400000, R9		
  0x41db13		0f8382010000		JAE 0x41dc9b			
  0x41db19		4a8b34ce		MOVQ 0(SI)(R9*8), SI		
  0x41db1d		8406			TESTB AL, 0(SI)			
  0x41db1f		48c1ef0d		SHRQ $0xd, DI			
  0x41db23		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x41db2a		488984fe00002000	MOVQ AX, 0x200000(SI)(DI*8)	
  0x41db32		488bb110030000		MOVQ 0x310(CX), SI		
  0x41db39		8406			TESTB AL, 0(SI)			
		h.setSpan(t.base()+t.npages*pageSize-1, t)
  0x41db3b		90			NOPL			
  0x41db3c		90			NOPL			
  0x41db3d		488b7820		MOVQ 0x20(AX), DI	
  0x41db41		48c1e70d		SHLQ $0xd, DI		
  0x41db45		48037818		ADDQ 0x18(AX), DI	
	ai := arenaIndex(base)
  0x41db49		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41db4a		90			NOPL			
  0x41db4b		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41db4c		4901f8			ADDQ DI, R8		
  0x41db4f		49c1e81a		SHRQ $0x1a, R8		
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41db53		4981f800004000		CMPQ $0x400000, R8	
  0x41db5a		0f8334010000		JAE 0x41dc94		
  0x41db60		4a8b34c6		MOVQ 0(SI)(R8*8), SI	
  0x41db64		8406			TESTB AL, 0(SI)		
		h.setSpan(t.base()+t.npages*pageSize-1, t)
  0x41db66		48ffcf			DECQ DI			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41db69		48c1ef0d		SHRQ $0xd, DI			
  0x41db6d		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x41db74		488984fe00002000	MOVQ AX, 0x200000(SI)(DI*8)	
		t.needzero = s.needzero
  0x41db7c		0fb67364		MOVZX 0x64(BX), SI	
  0x41db80		40887064		MOVB SI, 0x64(AX)	
		start, end := t.physPageBounds()
  0x41db84		90			NOPL			
	start := s.base()
  0x41db85		90			NOPL			
	end := start + s.npages<<_PageShift
  0x41db86		488b7020		MOVQ 0x20(AX), SI	
  0x41db8a		48c1e60d		SHLQ $0xd, SI		
	return s.startAddr
  0x41db8e		488b7818		MOVQ 0x18(AX), DI	
	end := start + s.npages<<_PageShift
  0x41db92		4801fe			ADDQ DI, SI		
	if physPageSize > _PageSize {
  0x41db95		4c8b050cf20b00		MOVQ runtime.physPageSize(SB), R8	
  0x41db9c		4981f800200000		CMPQ $0x2000, R8			
  0x41dba3		7666			JBE 0x41dc0b				
		start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x41dba5		498d3c38		LEAQ 0(R8)(DI*1), DI	
  0x41dba9		488d7fff		LEAQ -0x1(DI), DI	
  0x41dbad		49ffc8			DECQ R8			
  0x41dbb0		49f7d0			NOTQ R8			
  0x41dbb3		4c21c7			ANDQ R8, DI		
		end &^= physPageSize - 1
  0x41dbb6		4921f0			ANDQ SI, R8		
		if s.scavenged && start < end {
  0x41dbb9		807b6700		CMPB $0x0, 0x67(BX)	
  0x41dbbd		7413			JE 0x41dbd2		
  0x41dbbf		4c39c7			CMPQ R8, DI		
  0x41dbc2		730e			JAE 0x41dbd2		
			memstats.heap_released += uint64(end - start)
  0x41dbc4		4929f8			SUBQ DI, R8				
  0x41dbc7		4c0105e2000c00		ADDQ R8, runtime.memstats+80(SB)	
			t.scavenged = true
  0x41dbce		c6406701		MOVB $0x1, 0x67(AX)	
		s.state = mSpanManual // prevent coalescing with s
  0x41dbd2		c6436302		MOVB $0x2, 0x63(BX)	
		t.state = mSpanManual
  0x41dbd6		c6406302		MOVB $0x2, 0x63(AX)	
		h.freeSpanLocked(t, false, false, s.unusedsince)
  0x41dbda		488b5370		MOVQ 0x70(BX), DX				
  0x41dbde		48890c24		MOVQ CX, 0(SP)					
  0x41dbe2		4889442408		MOVQ AX, 0x8(SP)				
  0x41dbe7		66c74424100000		MOVW $0x0, 0x10(SP)				
  0x41dbee		4889542418		MOVQ DX, 0x18(SP)				
  0x41dbf3		e848040000		CALL runtime.(*mheap).freeSpanLocked(SB)	
		s.state = mSpanFree
  0x41dbf8		488b442420		MOVQ 0x20(SP), AX	
  0x41dbfd		c6406303		MOVB $0x3, 0x63(AX)	
	h.setSpans(s.base(), npage, s)
  0x41dc01		488b542440		MOVQ 0x40(SP), DX	
		s.state = mSpanFree
  0x41dc06		e941fdffff		JMP 0x41d94c		
		start, end := t.physPageBounds()
  0x41dc0b		4989f0			MOVQ SI, R8		
	if physPageSize > _PageSize {
  0x41dc0e		eba9			JMP 0x41dbb9		
	start, end := s.physPageBounds()
  0x41dc10		4889ce			MOVQ CX, SI		
	if physPageSize > _PageSize {
  0x41dc13		e91bfdffff		JMP 0x41d933		
  0x41dc18		31f6			XORL SI, SI		
	memstats.heap_released -= uint64(s.released())
  0x41dc1a		e917fdffff		JMP 0x41d936		
	if !h.grow(npage) {
  0x41dc1f		488b442438		MOVQ 0x38(SP), AX		
  0x41dc24		48890424		MOVQ AX, 0(SP)			
  0x41dc28		488b4c2440		MOVQ 0x40(SP), CX		
  0x41dc2d		48894c2408		MOVQ CX, 0x8(SP)		
  0x41dc32		e8d9000000		CALL runtime.(*mheap).grow(SB)	
  0x41dc37		807c241000		CMPB $0x0, 0x10(SP)		
  0x41dc3c		7513			JNE 0x41dc51			
		return nil
  0x41dc3e		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x41dc47		488b6c2428		MOVQ 0x28(SP), BP	
  0x41dc4c		4883c430		ADDQ $0x30, SP		
  0x41dc50		c3			RET			
	s = h.pickFreeSpan(npage)
  0x41dc51		488b442438		MOVQ 0x38(SP), AX			
  0x41dc56		48890424		MOVQ AX, 0(SP)				
  0x41dc5a		488b4c2440		MOVQ 0x40(SP), CX			
  0x41dc5f		48894c2408		MOVQ CX, 0x8(SP)			
  0x41dc64		e8e7faffff		CALL runtime.(*mheap).pickFreeSpan(SB)	
  0x41dc69		488b442410		MOVQ 0x10(SP), AX			
	if s != nil {
  0x41dc6e		4885c0			TESTQ AX, AX		
  0x41dc71		0f8560fcffff		JNE 0x41d8d7		
  0x41dc77		eb66			JMP 0x41dcdf		
		throw("still in list")
  0x41dc79		488d0528200500		LEAQ 0x52028(IP), AX	
  0x41dc80		48890424		MOVQ AX, 0(SP)		
  0x41dc84		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x41dc8d		e8ee570000		CALL runtime.throw(SB)	
  0x41dc92		0f0b			UD2			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x41dc94		e887420000		CALL runtime.panicindex(SB)	
  0x41dc99		0f0b			UD2				
  0x41dc9b		e880420000		CALL runtime.panicindex(SB)	
  0x41dca0		0f0b			UD2				
  0x41dca2		e879420000		CALL runtime.panicindex(SB)	
  0x41dca7		0f0b			UD2				
		throw("candidate mspan for allocation is too small")
  0x41dca9		488d05fa4f0500		LEAQ 0x54ffa(IP), AX	
  0x41dcb0		48890424		MOVQ AX, 0(SP)		
  0x41dcb4		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x41dcbd		e8be570000		CALL runtime.throw(SB)	
  0x41dcc2		0f0b			UD2			
		throw("candidate mspan for allocation is not free")
  0x41dcc4		488d05e34e0500		LEAQ 0x54ee3(IP), AX	
  0x41dccb		48890424		MOVQ AX, 0(SP)		
  0x41dccf		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x41dcd8		e8a3570000		CALL runtime.throw(SB)	
  0x41dcdd		0f0b			UD2			
	throw("grew heap, but no adequate free span found")
  0x41dcdf		488d05f24e0500		LEAQ 0x54ef2(IP), AX	
  0x41dce6		48890424		MOVQ AX, 0(SP)		
  0x41dcea		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x41dcf3		e888570000		CALL runtime.throw(SB)	
  0x41dcf8		0f0b			UD2			
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {
  0x41dcfa		e8819b0200		CALL runtime.morestack_noctxt(SB)		
  0x41dcff		e98cfbffff		JMP runtime.(*mheap).allocSpanLocked(SB)	

TEXT runtime.(*mheap).grow(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) grow(npage uintptr) bool {
  0x41dd10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41dd19		483b6110		CMPQ 0x10(CX), SP	
  0x41dd1d		0f86e3010000		JBE 0x41df06		
  0x41dd23		4883ec50		SUBQ $0x50, SP		
  0x41dd27		48896c2448		MOVQ BP, 0x48(SP)	
  0x41dd2c		488d6c2448		LEAQ 0x48(SP), BP	
	ask := npage << _PageShift
  0x41dd31		488b442458		MOVQ 0x58(SP), AX	
	v, size := h.sysAlloc(ask)
  0x41dd36		48890424		MOVQ AX, 0(SP)		
	ask := npage << _PageShift
  0x41dd3a		488b4c2460		MOVQ 0x60(SP), CX	
  0x41dd3f		48c1e10d		SHLQ $0xd, CX		
  0x41dd43		48894c2430		MOVQ CX, 0x30(SP)	
	v, size := h.sysAlloc(ask)
  0x41dd48		48894c2408		MOVQ CX, 0x8(SP)			
  0x41dd4d		e80eb3feff		CALL runtime.(*mheap).sysAlloc(SB)	
  0x41dd52		488b442410		MOVQ 0x10(SP), AX			
  0x41dd57		488b4c2418		MOVQ 0x18(SP), CX			
	if v == nil {
  0x41dd5c		4885c0			TESTQ AX, AX		
  0x41dd5f		0f8415010000		JE 0x41de7a		
	v, size := h.sysAlloc(ask)
  0x41dd65		4889442438		MOVQ AX, 0x38(SP)	
  0x41dd6a		48894c2420		MOVQ CX, 0x20(SP)	
	h.scavengeLargest(size)
  0x41dd6f		488b442458		MOVQ 0x58(SP), AX				
  0x41dd74		48890424		MOVQ AX, 0(SP)					
  0x41dd78		48894c2408		MOVQ CX, 0x8(SP)				
  0x41dd7d		e8ae050000		CALL runtime.(*mheap).scavengeLargest(SB)	
	s := (*mspan)(h.spanalloc.alloc())
  0x41dd82		488b442458		MOVQ 0x58(SP), AX			
  0x41dd87		8400			TESTB AL, 0(AX)				
  0x41dd89		488d8800250000		LEAQ 0x2500(AX), CX			
  0x41dd90		48890c24		MOVQ CX, 0(SP)				
  0x41dd94		e8f73dffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41dd99		488b442408		MOVQ 0x8(SP), AX			
  0x41dd9e		4889442440		MOVQ AX, 0x40(SP)			
	s.init(uintptr(v), size/pageSize)
  0x41dda3		90			NOPL			
  0x41dda4		488b4c2438		MOVQ 0x38(SP), CX	
	span.prev = nil
  0x41dda9		0f57c0			XORPS X0, X0		
  0x41ddac		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41ddaf		48c7401000000000	MOVQ $0x0, 0x10(AX)	
	span.startAddr = base
  0x41ddb7		48894818		MOVQ CX, 0x18(AX)	
	s.init(uintptr(v), size/pageSize)
  0x41ddbb		488b4c2420		MOVQ 0x20(SP), CX	
  0x41ddc0		48c1e90d		SHRQ $0xd, CX		
	span.npages = npages
  0x41ddc4		48894820		MOVQ CX, 0x20(AX)	
	span.allocCount = 0
  0x41ddc8		66c740600000		MOVW $0x0, 0x60(AX)	
	span.spanclass = 0
  0x41ddce		c6406200		MOVB $0x0, 0x62(AX)	
	span.elemsize = 0
  0x41ddd2		48c7406800000000	MOVQ $0x0, 0x68(AX)	
	span.state = mSpanDead
  0x41ddda		c6406300		MOVB $0x0, 0x63(AX)	
	span.unusedsince = 0
  0x41ddde		48c7407000000000	MOVQ $0x0, 0x70(AX)	
	span.scavenged = false
  0x41dde6		c6406700		MOVB $0x0, 0x67(AX)	
	span.specials = nil
  0x41ddea		0f118080000000		MOVUPS X0, 0x80(AX)	
	span.needzero = 0
  0x41ddf1		c6406400		MOVB $0x0, 0x64(AX)	
	span.freeindex = 0
  0x41ddf5		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	span.gcmarkBits = nil
  0x41ddfd		0f114048		MOVUPS X0, 0x48(AX)	
	h.setSpans(s.base(), s.npages, s)
  0x41de01		90			NOPL			
  0x41de02		488b4820		MOVQ 0x20(AX), CX	
	return s.startAddr
  0x41de06		488b5018		MOVQ 0x18(AX), DX	
	h.setSpans(s.base(), s.npages, s)
  0x41de0a		488b5c2458		MOVQ 0x58(SP), BX			
  0x41de0f		48891c24		MOVQ BX, 0(SP)				
  0x41de13		4889542408		MOVQ DX, 0x8(SP)			
  0x41de18		48894c2410		MOVQ CX, 0x10(SP)			
  0x41de1d		4889442418		MOVQ AX, 0x18(SP)			
  0x41de22		e859f8ffff		CALL runtime.(*mheap).setSpans(SB)	
	atomic.Store(&s.sweepgen, h.sweepgen)
  0x41de27		488b442458		MOVQ 0x58(SP), AX	
  0x41de2c		8b4818			MOVL 0x18(AX), CX	
  0x41de2f		488b542440		MOVQ 0x40(SP), DX	
  0x41de34		874a58			XCHGL CX, 0x58(DX)	
	s.state = mSpanInUse
  0x41de37		c6426301		MOVB $0x1, 0x63(DX)	
	h.pagesInUse += uint64(s.npages)
  0x41de3b		488b8898000000		MOVQ 0x98(AX), CX	
  0x41de42		48034a20		ADDQ 0x20(DX), CX	
  0x41de46		48898898000000		MOVQ CX, 0x98(AX)	
	h.freeSpanLocked(s, false, true, 0)
  0x41de4d		48890424		MOVQ AX, 0(SP)					
  0x41de51		4889542408		MOVQ DX, 0x8(SP)				
  0x41de56		66c74424100001		MOVW $0x100, 0x10(SP)				
  0x41de5d		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41de66		e8d5010000		CALL runtime.(*mheap).freeSpanLocked(SB)	
	return true
  0x41de6b		c644246801		MOVB $0x1, 0x68(SP)	
  0x41de70		488b6c2448		MOVQ 0x48(SP), BP	
  0x41de75		4883c450		ADDQ $0x50, SP		
  0x41de79		c3			RET			
		print("runtime: out of memory: cannot allocate ", ask, "-byte block (", memstats.heap_sys, " in use)\n")
  0x41de7a		488b0517fe0b00		MOVQ runtime.memstats+56(SB), AX	
  0x41de81		4889442428		MOVQ AX, 0x28(SP)			
  0x41de86		e835600000		CALL runtime.printlock(SB)		
  0x41de8b		488d05304b0500		LEAQ 0x54b30(IP), AX			
  0x41de92		48890424		MOVQ AX, 0(SP)				
  0x41de96		48c744240828000000	MOVQ $0x28, 0x8(SP)			
  0x41de9f		e84c690000		CALL runtime.printstring(SB)		
  0x41dea4		488b442430		MOVQ 0x30(SP), AX			
  0x41dea9		48890424		MOVQ AX, 0(SP)				
  0x41dead		e88e660000		CALL runtime.printuint(SB)		
  0x41deb2		488d056d1d0500		LEAQ 0x51d6d(IP), AX			
  0x41deb9		48890424		MOVQ AX, 0(SP)				
  0x41debd		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x41dec6		e825690000		CALL runtime.printstring(SB)		
  0x41decb		488b442428		MOVQ 0x28(SP), AX			
  0x41ded0		48890424		MOVQ AX, 0(SP)				
  0x41ded4		e867660000		CALL runtime.printuint(SB)		
  0x41ded9		488d05d4150500		LEAQ 0x515d4(IP), AX			
  0x41dee0		48890424		MOVQ AX, 0(SP)				
  0x41dee4		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x41deed		e8fe680000		CALL runtime.printstring(SB)		
  0x41def2		e849600000		CALL runtime.printunlock(SB)		
		return false
  0x41def7		c644246800		MOVB $0x0, 0x68(SP)	
  0x41defc		488b6c2448		MOVQ 0x48(SP), BP	
  0x41df01		4883c450		ADDQ $0x50, SP		
  0x41df05		c3			RET			
func (h *mheap) grow(npage uintptr) bool {
  0x41df06		e875990200		CALL runtime.morestack_noctxt(SB)	
  0x41df0b		e900feffff		JMP runtime.(*mheap).grow(SB)		

TEXT runtime.(*mheap).freeSpan(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) freeSpan(s *mspan, large bool) {
  0x41df10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41df19		483b6110		CMPQ 0x10(CX), SP	
  0x41df1d		7665			JBE 0x41df84		
  0x41df1f		4883ec30		SUBQ $0x30, SP		
  0x41df23		48896c2428		MOVQ BP, 0x28(SP)	
  0x41df28		488d6c2428		LEAQ 0x28(SP), BP	
	systemstack(func() {
  0x41df2d		0f57c0			XORPS X0, X0					
  0x41df30		0f11442408		MOVUPS X0, 0x8(SP)				
  0x41df35		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41df3e		c644242000		MOVB $0x0, 0x20(SP)				
  0x41df43		488d05b67b0200		LEAQ runtime.(*mheap).freeSpan.func1(SB), AX	
  0x41df4a		4889442408		MOVQ AX, 0x8(SP)				
  0x41df4f		488b442438		MOVQ 0x38(SP), AX				
  0x41df54		4889442410		MOVQ AX, 0x10(SP)				
  0x41df59		488b442440		MOVQ 0x40(SP), AX				
  0x41df5e		4889442418		MOVQ AX, 0x18(SP)				
  0x41df63		0fb6442448		MOVZX 0x48(SP), AX				
  0x41df68		88442420		MOVB AL, 0x20(SP)				
  0x41df6c		488d442408		LEAQ 0x8(SP), AX				
  0x41df71		48890424		MOVQ AX, 0(SP)					
  0x41df75		e8b6970200		CALL runtime.systemstack(SB)			
}
  0x41df7a		488b6c2428		MOVQ 0x28(SP), BP	
  0x41df7f		4883c430		ADDQ $0x30, SP		
  0x41df83		c3			RET			
func (h *mheap) freeSpan(s *mspan, large bool) {
  0x41df84		e8f7980200		CALL runtime.morestack_noctxt(SB)	
  0x41df89		eb85			JMP runtime.(*mheap).freeSpan(SB)	

TEXT runtime.(*mheap).freeManual(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41df90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41df99		483b6118		CMPQ 0x18(CX), SP	
  0x41df9d		0f8686000000		JBE 0x41e029		
  0x41dfa3		4883ec28		SUBQ $0x28, SP		
  0x41dfa7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41dfac		488d6c2420		LEAQ 0x20(SP), BP	
	s.needzero = 1
  0x41dfb1		488b442438		MOVQ 0x38(SP), AX	
  0x41dfb6		c6406401		MOVB $0x1, 0x64(AX)	
	lock(&h.lock)
  0x41dfba		488b4c2430		MOVQ 0x30(SP), CX	
  0x41dfbf		8401			TESTB AL, 0(CX)		
  0x41dfc1		48890c24		MOVQ CX, 0(SP)		
  0x41dfc5		e816a7feff		CALL runtime.lock(SB)	
	*stat -= uint64(s.npages << _PageShift)
  0x41dfca		488b442438		MOVQ 0x38(SP), AX	
  0x41dfcf		488b4820		MOVQ 0x20(AX), CX	
  0x41dfd3		48c1e10d		SHLQ $0xd, CX		
  0x41dfd7		488b542440		MOVQ 0x40(SP), DX	
  0x41dfdc		48290a			SUBQ CX, 0(DX)		
	memstats.heap_sys += uint64(s.npages << _PageShift)
  0x41dfdf		488b4820		MOVQ 0x20(AX), CX			
  0x41dfe3		48c1e10d		SHLQ $0xd, CX				
  0x41dfe7		48010daafc0b00		ADDQ CX, runtime.memstats+56(SB)	
	h.freeSpanLocked(s, false, true, 0)
  0x41dfee		488b4c2430		MOVQ 0x30(SP), CX				
  0x41dff3		48890c24		MOVQ CX, 0(SP)					
  0x41dff7		4889442408		MOVQ AX, 0x8(SP)				
  0x41dffc		66c74424100001		MOVW $0x100, 0x10(SP)				
  0x41e003		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x41e00c		e82f000000		CALL runtime.(*mheap).freeSpanLocked(SB)	
	unlock(&h.lock)
  0x41e011		488b442430		MOVQ 0x30(SP), AX	
  0x41e016		48890424		MOVQ AX, 0(SP)		
  0x41e01a		e871a8feff		CALL runtime.unlock(SB)	
}
  0x41e01f		488b6c2420		MOVQ 0x20(SP), BP	
  0x41e024		4883c428		ADDQ $0x28, SP		
  0x41e028		c3			RET			
func (h *mheap) freeManual(s *mspan, stat *uint64) {
  0x41e029		e8a2b60100		CALL runtime.morestackc(SB)		
  0x41e02e		e95dffffff		JMP runtime.(*mheap).freeManual(SB)	

TEXT runtime.(*mheap).freeSpanLocked(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41e040		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e049		483b6110		CMPQ 0x10(CX), SP	
  0x41e04d		0f86d0020000		JBE 0x41e323		
  0x41e053		4883ec38		SUBQ $0x38, SP		
  0x41e057		48896c2430		MOVQ BP, 0x30(SP)	
  0x41e05c		488d6c2430		LEAQ 0x30(SP), BP	
	switch s.state {
  0x41e061		488b442448		MOVQ 0x48(SP), AX	
  0x41e066		0fb64863		MOVZX 0x63(AX), CX	
	case mSpanInUse:
  0x41e06a		80f901			CMPL $0x1, CL		
  0x41e06d		0f8549010000		JNE 0x41e1bc		
		if s.allocCount != 0 || s.sweepgen != h.sweepgen {
  0x41e073		0fb74860		MOVZX 0x60(AX), CX	
  0x41e077		66894c2416		MOVW CX, 0x16(SP)	
  0x41e07c		6685c9			TESTW CX, CX		
  0x41e07f		0f855c010000		JNE 0x41e1e1		
  0x41e085		488b542440		MOVQ 0x40(SP), DX	
  0x41e08a		8b5a18			MOVL 0x18(DX), BX	
  0x41e08d		395858			CMPL BX, 0x58(AX)	
  0x41e090		0f854b010000		JNE 0x41e1e1		
		h.pagesInUse -= uint64(s.npages)
  0x41e096		488b8a98000000		MOVQ 0x98(DX), CX	
  0x41e09d		482b4820		SUBQ 0x20(AX), CX	
  0x41e0a1		48898a98000000		MOVQ CX, 0x98(DX)	
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41e0a8		488b0da1880a00		MOVQ runtime.mheap_+784(SB), CX	
  0x41e0af		8401			TESTB AL, 0(CX)			
		arena, pageIdx, pageMask := pageIndexOf(s.base())
  0x41e0b1		90			NOPL			
  0x41e0b2		90			NOPL			
	return s.startAddr
  0x41e0b3		488b5818		MOVQ 0x18(AX), BX	
	ai := arenaIndex(p)
  0x41e0b7		90			NOPL			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41e0b8		90			NOPL			
  0x41e0b9		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x41e0ba		48be0000000000800000	MOVQ $0x800000000000, SI	
  0x41e0c4		4801de			ADDQ BX, SI			
  0x41e0c7		48c1ee1a		SHRQ $0x1a, SI			
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41e0cb		4881fe00004000		CMPQ $0x400000, SI	
  0x41e0d2		0f8302010000		JAE 0x41e1da		
  0x41e0d8		488b0cf1		MOVQ 0(CX)(SI*8), CX	
		arena.pageInUse[pageIdx] &^= pageMask
  0x41e0dc		8401			TESTB AL, 0(CX)		
	pageIdx = ((p / pageSize) / 8) % uintptr(len(arena.pageInUse))
  0x41e0de		4889de			MOVQ BX, SI		
  0x41e0e1		48c1eb10		SHRQ $0x10, BX		
  0x41e0e5		4881e3ff030000		ANDQ $0x3ff, BX		
		arena.pageInUse[pageIdx] &^= pageMask
  0x41e0ec		0fb6bc1900002100	MOVZX 0x210000(CX)(BX*1), DI	
	pageMask = byte(1 << ((p / pageSize) % 8))
  0x41e0f4		48c1ee0d		SHRQ $0xd, SI		
  0x41e0f8		4883e607		ANDQ $0x7, SI		
		arena.pageInUse[pageIdx] &^= pageMask
  0x41e0fc		0fb3f7			BTRL SI, DI			
  0x41e0ff		4088bc1900002100	MOVB DI, 0x210000(CX)(BX*1)	
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41e107		0fb64c2450		MOVZX 0x50(SP), CX	
  0x41e10c		84c9			TESTL CL, CL		
	if acctinuse {
  0x41e10e		740f			JE 0x41e11f		
		memstats.heap_inuse -= uint64(s.npages << _PageShift)
  0x41e110		488b4820		MOVQ 0x20(AX), CX			
  0x41e114		48c1e10d		SHLQ $0xd, CX				
  0x41e118		48290d89fb0b00		SUBQ CX, runtime.memstats+72(SB)	
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41e11f		0fb64c2451		MOVZX 0x51(SP), CX	
  0x41e124		84c9			TESTL CL, CL		
	if acctidle {
  0x41e126		740f			JE 0x41e137		
		memstats.heap_idle += uint64(s.npages << _PageShift)
  0x41e128		488b4820		MOVQ 0x20(AX), CX			
  0x41e12c		48c1e10d		SHLQ $0xd, CX				
  0x41e130		48010d69fb0b00		ADDQ CX, runtime.memstats+64(SB)	
	s.state = mSpanFree
  0x41e137		c6406303		MOVB $0x3, 0x63(AX)	
	s.unusedsince = unusedsince
  0x41e13b		488b4c2458		MOVQ 0x58(SP), CX	
  0x41e140		48894870		MOVQ CX, 0x70(AX)	
	if unusedsince == 0 {
  0x41e144		4885c9			TESTQ CX, CX		
  0x41e147		7457			JE 0x41e1a0		
	h.coalesce(s)
  0x41e149		48891424		MOVQ DX, 0(SP)				
  0x41e14d		4889442408		MOVQ AX, 0x8(SP)			
  0x41e152		e839e0ffff		CALL runtime.(*mheap).coalesce(SB)	
	if s.scavenged {
  0x41e157		488b442448		MOVQ 0x48(SP), AX	
  0x41e15c		80786700		CMPB $0x0, 0x67(AX)	
  0x41e160		7423			JE 0x41e185		
		h.scav.insert(s)
  0x41e162		488b4c2440		MOVQ 0x40(SP), CX			
  0x41e167		8401			TESTB AL, 0(CX)				
  0x41e169		4883c110		ADDQ $0x10, CX				
  0x41e16d		48890c24		MOVQ CX, 0(SP)				
  0x41e171		4889442408		MOVQ AX, 0x8(SP)			
  0x41e176		e8c57affff		CALL runtime.(*mTreap).insert(SB)	
  0x41e17b		488b6c2430		MOVQ 0x30(SP), BP			
  0x41e180		4883c438		ADDQ $0x38, SP				
  0x41e184		c3			RET					
		h.free.insert(s)
  0x41e185		488b4c2440		MOVQ 0x40(SP), CX			
  0x41e18a		8401			TESTB AL, 0(CX)				
  0x41e18c		4883c108		ADDQ $0x8, CX				
  0x41e190		48890c24		MOVQ CX, 0(SP)				
  0x41e194		4889442408		MOVQ AX, 0x8(SP)			
  0x41e199		e8a27affff		CALL runtime.(*mTreap).insert(SB)	
  0x41e19e		ebdb			JMP 0x41e17b				
		s.unusedsince = nanotime()
  0x41e1a0		e80bcf0200		CALL runtime.nanotime(SB)	
  0x41e1a5		488b0424		MOVQ 0(SP), AX			
  0x41e1a9		488b4c2448		MOVQ 0x48(SP), CX		
  0x41e1ae		48894170		MOVQ AX, 0x70(CX)		
	h.coalesce(s)
  0x41e1b2		4889c8			MOVQ CX, AX		
  0x41e1b5		488b542440		MOVQ 0x40(SP), DX	
		s.unusedsince = nanotime()
  0x41e1ba		eb8d			JMP 0x41e149		
	case mSpanManual:
  0x41e1bc		80f902			CMPL $0x2, CL		
  0x41e1bf		0f8543010000		JNE 0x41e308		
		if s.allocCount != 0 {
  0x41e1c5		6683786000		CMPW $0x0, 0x60(AX)	
  0x41e1ca		0f851d010000		JNE 0x41e2ed		
	h.coalesce(s)
  0x41e1d0		488b542440		MOVQ 0x40(SP), DX	
	switch s.state {
  0x41e1d5		e92dffffff		JMP 0x41e107		
	arena = mheap_.arenas[ai.l1()][ai.l2()]
  0x41e1da		e8413d0000		CALL runtime.panicindex(SB)	
  0x41e1df		0f0b			UD2				
			print("mheap.freeSpanLocked - span ", s, " ptr ", hex(s.base()), " allocCount ", s.allocCount, " sweepgen ", s.sweepgen, "/", h.sweepgen, "\n")
  0x41e1e1		90			NOPL			
  0x41e1e2		8b4858			MOVL 0x58(AX), CX	
  0x41e1e5		48894c2428		MOVQ CX, 0x28(SP)	
  0x41e1ea		488b542440		MOVQ 0x40(SP), DX	
  0x41e1ef		8b5218			MOVL 0x18(DX), DX	
  0x41e1f2		4889542420		MOVQ DX, 0x20(SP)	
	return s.startAddr
  0x41e1f7		488b5818		MOVQ 0x18(AX), BX	
  0x41e1fb		48895c2418		MOVQ BX, 0x18(SP)	
			print("mheap.freeSpanLocked - span ", s, " ptr ", hex(s.base()), " allocCount ", s.allocCount, " sweepgen ", s.sweepgen, "/", h.sweepgen, "\n")
  0x41e200		e8bb5c0000		CALL runtime.printlock(SB)	
  0x41e205		488d05fe340500		LEAQ 0x534fe(IP), AX		
  0x41e20c		48890424		MOVQ AX, 0(SP)			
  0x41e210		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x41e219		e8d2650000		CALL runtime.printstring(SB)	
  0x41e21e		488b442448		MOVQ 0x48(SP), AX		
  0x41e223		48890424		MOVQ AX, 0(SP)			
  0x41e227		e884650000		CALL runtime.printpointer(SB)	
  0x41e22c		488d05920f0500		LEAQ 0x50f92(IP), AX		
  0x41e233		48890424		MOVQ AX, 0(SP)			
  0x41e237		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x41e240		e8ab650000		CALL runtime.printstring(SB)	
  0x41e245		488b442418		MOVQ 0x18(SP), AX		
  0x41e24a		48890424		MOVQ AX, 0(SP)			
  0x41e24e		e85d640000		CALL runtime.printhex(SB)	
  0x41e253		488d0533170500		LEAQ 0x51733(IP), AX		
  0x41e25a		48890424		MOVQ AX, 0(SP)			
  0x41e25e		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x41e267		e884650000		CALL runtime.printstring(SB)	
  0x41e26c		0fb7442416		MOVZX 0x16(SP), AX		
  0x41e271		48890424		MOVQ AX, 0(SP)			
  0x41e275		e8c6620000		CALL runtime.printuint(SB)	
  0x41e27a		488d05e1140500		LEAQ 0x514e1(IP), AX		
  0x41e281		48890424		MOVQ AX, 0(SP)			
  0x41e285		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x41e28e		e85d650000		CALL runtime.printstring(SB)	
  0x41e293		488b442428		MOVQ 0x28(SP), AX		
  0x41e298		48890424		MOVQ AX, 0(SP)			
  0x41e29c		e89f620000		CALL runtime.printuint(SB)	
  0x41e2a1		488d05df0d0500		LEAQ 0x50ddf(IP), AX		
  0x41e2a8		48890424		MOVQ AX, 0(SP)			
  0x41e2ac		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x41e2b5		e836650000		CALL runtime.printstring(SB)	
  0x41e2ba		488b442420		MOVQ 0x20(SP), AX		
  0x41e2bf		48890424		MOVQ AX, 0(SP)			
  0x41e2c3		e878620000		CALL runtime.printuint(SB)	
  0x41e2c8		e8835e0000		CALL runtime.printnl(SB)	
  0x41e2cd		e86e5c0000		CALL runtime.printunlock(SB)	
			throw("mheap.freeSpanLocked - invalid free")
  0x41e2d2		488d05a6410500		LEAQ 0x541a6(IP), AX	
  0x41e2d9		48890424		MOVQ AX, 0(SP)		
  0x41e2dd		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x41e2e6		e895510000		CALL runtime.throw(SB)	
  0x41e2eb		0f0b			UD2			
			throw("mheap.freeSpanLocked - invalid stack free")
  0x41e2ed		488d0599470500		LEAQ 0x54799(IP), AX	
  0x41e2f4		48890424		MOVQ AX, 0(SP)		
  0x41e2f8		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x41e301		e87a510000		CALL runtime.throw(SB)	
  0x41e306		0f0b			UD2			
		throw("mheap.freeSpanLocked - invalid span state")
  0x41e308		488d0555470500		LEAQ 0x54755(IP), AX	
  0x41e30f		48890424		MOVQ AX, 0(SP)		
  0x41e313		48c744240829000000	MOVQ $0x29, 0x8(SP)	
  0x41e31c		e85f510000		CALL runtime.throw(SB)	
  0x41e321		0f0b			UD2			
func (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool, unusedsince int64) {
  0x41e323		e858950200		CALL runtime.morestack_noctxt(SB)	
  0x41e328		e913fdffff		JMP runtime.(*mheap).freeSpanLocked(SB)	

TEXT runtime.(*mheap).scavengeLargest(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) scavengeLargest(nbytes uintptr) {
  0x41e330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e339		483b6110		CMPQ 0x10(CX), SP	
  0x41e33d		0f8664010000		JBE 0x41e4a7		
  0x41e343		4883ec50		SUBQ $0x50, SP		
  0x41e347		48896c2448		MOVQ BP, 0x48(SP)	
  0x41e34c		488d6c2448		LEAQ 0x48(SP), BP	
	if nbytes > h.scavengeCredit {
  0x41e351		488b442458		MOVQ 0x58(SP), AX	
  0x41e356		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x41e35d		488b542460		MOVQ 0x60(SP), DX	
  0x41e362		4839ca			CMPQ CX, DX		
  0x41e365		0f8628010000		JBE 0x41e493		
  0x41e36b		48894c2420		MOVQ CX, 0x20(SP)	
		h.scavengeCredit = 0
  0x41e370		48c780d000000000000000	MOVQ $0x0, 0xd0(AX)	
	for t := h.free.end(); released < nbytes && t.valid(); {
  0x41e37b		488d4808		LEAQ 0x8(AX), CX		
  0x41e37f		48894c2440		MOVQ CX, 0x40(SP)		
  0x41e384		48890c24		MOVQ CX, 0(SP)			
  0x41e388		e88378ffff		CALL runtime.(*mTreap).end(SB)	
  0x41e38d		488b442408		MOVQ 0x8(SP), AX		
  0x41e392		4889442428		MOVQ AX, 0x28(SP)		
		nbytes -= h.scavengeCredit
  0x41e397		488b442460		MOVQ 0x60(SP), AX	
  0x41e39c		488b4c2420		MOVQ 0x20(SP), CX	
  0x41e3a1		4829c8			SUBQ CX, AX		
  0x41e3a4		4889442460		MOVQ AX, 0x60(SP)	
  0x41e3a9		31c9			XORL CX, CX		
	for t := h.free.end(); released < nbytes && t.valid(); {
  0x41e3ab		e985000000		JMP 0x41e435		
		r := s.scavenge()
  0x41e3b0		4889442418		MOVQ AX, 0x18(SP)	
		n := t.prev()
  0x41e3b5		488b442428		MOVQ 0x28(SP), AX		
  0x41e3ba		48890424		MOVQ AX, 0(SP)			
  0x41e3be		e8cd77ffff		CALL runtime.treapIter.prev(SB)	
  0x41e3c3		488b442408		MOVQ 0x8(SP), AX		
  0x41e3c8		4889442438		MOVQ AX, 0x38(SP)		
		h.free.erase(t)
  0x41e3cd		488b4c2440		MOVQ 0x40(SP), CX			
  0x41e3d2		48890c24		MOVQ CX, 0(SP)				
  0x41e3d6		488b542428		MOVQ 0x28(SP), DX			
  0x41e3db		4889542408		MOVQ DX, 0x8(SP)			
  0x41e3e0		e87b7dffff		CALL runtime.(*mTreap).erase(SB)	
		h.coalesce(s)
  0x41e3e5		488b442458		MOVQ 0x58(SP), AX			
  0x41e3ea		48890424		MOVQ AX, 0(SP)				
  0x41e3ee		488b4c2430		MOVQ 0x30(SP), CX			
  0x41e3f3		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e3f8		e893ddffff		CALL runtime.(*mheap).coalesce(SB)	
		t = n
  0x41e3fd		488b442438		MOVQ 0x38(SP), AX	
  0x41e402		4889442428		MOVQ AX, 0x28(SP)	
		h.scav.insert(s)
  0x41e407		488b442458		MOVQ 0x58(SP), AX			
  0x41e40c		488d4810		LEAQ 0x10(AX), CX			
  0x41e410		48890c24		MOVQ CX, 0(SP)				
  0x41e414		488b4c2430		MOVQ 0x30(SP), CX			
  0x41e419		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e41e		e81d78ffff		CALL runtime.(*mTreap).insert(SB)	
		released += r
  0x41e423		488b442418		MOVQ 0x18(SP), AX	
  0x41e428		488b4c2410		MOVQ 0x10(SP), CX	
  0x41e42d		4801c1			ADDQ AX, CX		
	for t := h.free.end(); released < nbytes && t.valid(); {
  0x41e430		488b442460		MOVQ 0x60(SP), AX	
  0x41e435		4839c1			CMPQ AX, CX		
  0x41e438		733e			JAE 0x41e478		
  0x41e43a		90			NOPL			
	return i.t != nil
  0x41e43b		488b542428		MOVQ 0x28(SP), DX	
  0x41e440		4885d2			TESTQ DX, DX		
	for t := h.free.end(); released < nbytes && t.valid(); {
  0x41e443		7430			JE 0x41e475		
  0x41e445		48894c2410		MOVQ CX, 0x10(SP)	
		s := t.span()
  0x41e44a		90			NOPL			
	return i.t.spanKey
  0x41e44b		488b4220		MOVQ 0x20(DX), AX	
  0x41e44f		4889442430		MOVQ AX, 0x30(SP)	
		r := s.scavenge()
  0x41e454		48890424		MOVQ AX, 0(SP)				
  0x41e458		e8a3dfffff		CALL runtime.(*mspan).scavenge(SB)	
  0x41e45d		488b442408		MOVQ 0x8(SP), AX			
		if r == 0 {
  0x41e462		4885c0			TESTQ AX, AX		
  0x41e465		0f8545ffffff		JNE 0x41e3b0		
			return
  0x41e46b		488b6c2448		MOVQ 0x48(SP), BP	
  0x41e470		4883c450		ADDQ $0x50, SP		
  0x41e474		c3			RET			
	for t := h.free.end(); released < nbytes && t.valid(); {
  0x41e475		4839c1			CMPQ AX, CX		
	if released > nbytes {
  0x41e478		760f			JBE 0x41e489		
		h.scavengeCredit += released - nbytes
  0x41e47a		4829c1			SUBQ AX, CX		
  0x41e47d		488b442458		MOVQ 0x58(SP), AX	
  0x41e482		480188d0000000		ADDQ CX, 0xd0(AX)	
  0x41e489		488b6c2448		MOVQ 0x48(SP), BP	
  0x41e48e		4883c450		ADDQ $0x50, SP		
  0x41e492		c3			RET			
		h.scavengeCredit -= nbytes
  0x41e493		4829d1			SUBQ DX, CX		
  0x41e496		488988d0000000		MOVQ CX, 0xd0(AX)	
		return
  0x41e49d		488b6c2448		MOVQ 0x48(SP), BP	
  0x41e4a2		4883c450		ADDQ $0x50, SP		
  0x41e4a6		c3			RET			
func (h *mheap) scavengeLargest(nbytes uintptr) {
  0x41e4a7		e8d4930200		CALL runtime.morestack_noctxt(SB)		
  0x41e4ac		e97ffeffff		JMP runtime.(*mheap).scavengeLargest(SB)	

TEXT runtime.(*mheap).scavengeAll(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) scavengeAll(now, limit uint64) uintptr {
  0x41e4c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e4c9		483b6110		CMPQ 0x10(CX), SP	
  0x41e4cd		0f862c010000		JBE 0x41e5ff		
  0x41e4d3		4883ec48		SUBQ $0x48, SP		
  0x41e4d7		48896c2440		MOVQ BP, 0x40(SP)	
  0x41e4dc		488d6c2440		LEAQ 0x40(SP), BP	
	for t := h.free.start(); t.valid(); {
  0x41e4e1		488b442450		MOVQ 0x50(SP), AX			
  0x41e4e6		8400			TESTB AL, 0(AX)				
  0x41e4e8		488d4808		LEAQ 0x8(AX), CX			
  0x41e4ec		48894c2438		MOVQ CX, 0x38(SP)			
  0x41e4f1		48890c24		MOVQ CX, 0(SP)				
  0x41e4f5		e8e676ffff		CALL runtime.(*mTreap).start(SB)	
  0x41e4fa		488b442408		MOVQ 0x8(SP), AX			
  0x41e4ff		4889442420		MOVQ AX, 0x20(SP)			
  0x41e504		31c0			XORL AX, AX				
  0x41e506		eb05			JMP 0x41e50d				
		t = n
  0x41e508		48894c2420		MOVQ CX, 0x20(SP)	
	for t := h.free.start(); t.valid(); {
  0x41e50d		90			NOPL			
	return i.t != nil
  0x41e50e		488b4c2420		MOVQ 0x20(SP), CX	
  0x41e513		4885c9			TESTQ CX, CX		
	for t := h.free.start(); t.valid(); {
  0x41e516		0f84d4000000		JE 0x41e5f0		
				released += r
  0x41e51c		4889442410		MOVQ AX, 0x10(SP)	
		s := t.span()
  0x41e521		90			NOPL			
		n := t.next()
  0x41e522		90			NOPL			
	return i.t.spanKey
  0x41e523		488b4120		MOVQ 0x20(CX), AX	
  0x41e527		4889442428		MOVQ AX, 0x28(SP)	
	i.t = i.t.succ()
  0x41e52c		48890c24		MOVQ CX, 0(SP)				
  0x41e530		e84b75ffff		CALL runtime.(*treapNode).succ(SB)	
		if (now - uint64(s.unusedsince)) > limit {
  0x41e535		488b442428		MOVQ 0x28(SP), AX	
  0x41e53a		488b4870		MOVQ 0x70(AX), CX	
  0x41e53e		488b542458		MOVQ 0x58(SP), DX	
  0x41e543		4889d3			MOVQ DX, BX		
  0x41e546		4829ca			SUBQ CX, DX		
	i.t = i.t.succ()
  0x41e549		488b4c2408		MOVQ 0x8(SP), CX	
		if (now - uint64(s.unusedsince)) > limit {
  0x41e54e		488b742460		MOVQ 0x60(SP), SI	
  0x41e553		4839f2			CMPQ SI, DX		
  0x41e556		7707			JA 0x41e55f		
				released += r
  0x41e558		488b442410		MOVQ 0x10(SP), AX	
		if (now - uint64(s.unusedsince)) > limit {
  0x41e55d		eba9			JMP 0x41e508		
	i.t = i.t.succ()
  0x41e55f		48894c2430		MOVQ CX, 0x30(SP)	
			r := s.scavenge()
  0x41e564		48890424		MOVQ AX, 0(SP)				
  0x41e568		e893deffff		CALL runtime.(*mspan).scavenge(SB)	
  0x41e56d		488b442408		MOVQ 0x8(SP), AX			
			if r != 0 {
  0x41e572		4885c0			TESTQ AX, AX		
  0x41e575		7519			JNE 0x41e590		
				released += r
  0x41e577		488b442410		MOVQ 0x10(SP), AX	
		t = n
  0x41e57c		488b4c2430		MOVQ 0x30(SP), CX	
		if (now - uint64(s.unusedsince)) > limit {
  0x41e581		488b5c2458		MOVQ 0x58(SP), BX	
  0x41e586		488b742460		MOVQ 0x60(SP), SI	
		t = n
  0x41e58b		e978ffffff		JMP 0x41e508		
			r := s.scavenge()
  0x41e590		4889442418		MOVQ AX, 0x18(SP)	
				h.free.erase(t)
  0x41e595		488b442438		MOVQ 0x38(SP), AX			
  0x41e59a		48890424		MOVQ AX, 0(SP)				
  0x41e59e		488b4c2420		MOVQ 0x20(SP), CX			
  0x41e5a3		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e5a8		e8b37bffff		CALL runtime.(*mTreap).erase(SB)	
				h.coalesce(s)
  0x41e5ad		488b442450		MOVQ 0x50(SP), AX			
  0x41e5b2		48890424		MOVQ AX, 0(SP)				
  0x41e5b6		488b4c2428		MOVQ 0x28(SP), CX			
  0x41e5bb		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e5c0		e8cbdbffff		CALL runtime.(*mheap).coalesce(SB)	
				h.scav.insert(s)
  0x41e5c5		488b442450		MOVQ 0x50(SP), AX			
  0x41e5ca		488d4810		LEAQ 0x10(AX), CX			
  0x41e5ce		48890c24		MOVQ CX, 0(SP)				
  0x41e5d2		488b4c2428		MOVQ 0x28(SP), CX			
  0x41e5d7		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e5dc		e85f76ffff		CALL runtime.(*mTreap).insert(SB)	
				released += r
  0x41e5e1		488b442418		MOVQ 0x18(SP), AX	
  0x41e5e6		488b4c2410		MOVQ 0x10(SP), CX	
  0x41e5eb		4801c8			ADDQ CX, AX		
  0x41e5ee		eb8c			JMP 0x41e57c		
	return released
  0x41e5f0		4889442468		MOVQ AX, 0x68(SP)	
  0x41e5f5		488b6c2440		MOVQ 0x40(SP), BP	
  0x41e5fa		4883c448		ADDQ $0x48, SP		
  0x41e5fe		c3			RET			
func (h *mheap) scavengeAll(now, limit uint64) uintptr {
  0x41e5ff		e87c920200		CALL runtime.morestack_noctxt(SB)	
  0x41e604		e9b7feffff		JMP runtime.(*mheap).scavengeAll(SB)	

TEXT runtime.(*mheap).scavenge(SB) /usr/local/go/src/runtime/mheap.go
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41e610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e619		483b6110		CMPQ 0x10(CX), SP	
  0x41e61d		0f867b020000		JBE 0x41e89e		
  0x41e623		4883ec58		SUBQ $0x58, SP		
  0x41e627		48896c2450		MOVQ BP, 0x50(SP)	
  0x41e62c		488d6c2450		LEAQ 0x50(SP), BP	
	gp := getg()
  0x41e631		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x41e63a		4889442448		MOVQ AX, 0x48(SP)	
	gp.m.mallocing++
  0x41e63f		488b4830		MOVQ 0x30(AX), CX	
  0x41e643		ff81f0000000		INCL 0xf0(CX)		
	lock(&h.lock)
  0x41e649		488b4c2460		MOVQ 0x60(SP), CX	
  0x41e64e		8401			TESTB AL, 0(CX)		
  0x41e650		48890c24		MOVQ CX, 0(SP)		
  0x41e654		e887a0feff		CALL runtime.lock(SB)	
	released := h.scavengeAll(now, limit)
  0x41e659		488b442460		MOVQ 0x60(SP), AX			
  0x41e65e		48890424		MOVQ AX, 0(SP)				
  0x41e662		488b4c2470		MOVQ 0x70(SP), CX			
  0x41e667		48894c2408		MOVQ CX, 0x8(SP)			
  0x41e66c		488b4c2478		MOVQ 0x78(SP), CX			
  0x41e671		48894c2410		MOVQ CX, 0x10(SP)			
  0x41e676		e845feffff		CALL runtime.(*mheap).scavengeAll(SB)	
  0x41e67b		488b442418		MOVQ 0x18(SP), AX			
  0x41e680		4889442420		MOVQ AX, 0x20(SP)			
	unlock(&h.lock)
  0x41e685		488b4c2460		MOVQ 0x60(SP), CX	
  0x41e68a		48890c24		MOVQ CX, 0(SP)		
  0x41e68e		e8fda1feff		CALL runtime.unlock(SB)	
	gp.m.mallocing--
  0x41e693		488b442448		MOVQ 0x48(SP), AX	
  0x41e698		488b4030		MOVQ 0x30(AX), AX	
  0x41e69c		ff88f0000000		DECL 0xf0(AX)		
	if debug.gctrace > 0 {
  0x41e6a2		833d57e80b0000		CMPL $0x0, runtime.debug+32(SB)	
  0x41e6a9		0f8e69010000		JLE 0x41e818			
		if released > 0 {
  0x41e6af		488b442420		MOVQ 0x20(SP), AX	
  0x41e6b4		4885c0			TESTQ AX, AX		
  0x41e6b7		0f8765010000		JA 0x41e822		
		print("scvg", k, ": inuse: ", memstats.heap_inuse>>20, ", idle: ", memstats.heap_idle>>20, ", sys: ", memstats.heap_sys>>20, ", released: ", memstats.heap_released>>20, ", consumed: ", (memstats.heap_sys-memstats.heap_released)>>20, " (MB)\n")
  0x41e6bd		488b05e4f50b00		MOVQ runtime.memstats+72(SB), AX	
  0x41e6c4		4889442440		MOVQ AX, 0x40(SP)			
  0x41e6c9		488b0dd0f50b00		MOVQ runtime.memstats+64(SB), CX	
  0x41e6d0		48894c2438		MOVQ CX, 0x38(SP)			
  0x41e6d5		488b15bcf50b00		MOVQ runtime.memstats+56(SB), DX	
  0x41e6dc		4889542430		MOVQ DX, 0x30(SP)			
  0x41e6e1		488b1dc8f50b00		MOVQ runtime.memstats+80(SB), BX	
  0x41e6e8		48895c2428		MOVQ BX, 0x28(SP)			
  0x41e6ed		e8ce570000		CALL runtime.printlock(SB)		
  0x41e6f2		488d05800a0500		LEAQ 0x50a80(IP), AX			
  0x41e6f9		48890424		MOVQ AX, 0(SP)				
  0x41e6fd		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x41e706		e8e5600000		CALL runtime.printstring(SB)		
  0x41e70b		8b442468		MOVL 0x68(SP), AX			
  0x41e70f		4863c0			MOVSXD AX, AX				
  0x41e712		48890424		MOVQ AX, 0(SP)				
  0x41e716		e8255f0000		CALL runtime.printint(SB)		
  0x41e71b		488d05220e0500		LEAQ 0x50e22(IP), AX			
  0x41e722		48890424		MOVQ AX, 0(SP)				
  0x41e726		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x41e72f		e8bc600000		CALL runtime.printstring(SB)		
  0x41e734		488b442440		MOVQ 0x40(SP), AX			
  0x41e739		48c1e814		SHRQ $0x14, AX				
  0x41e73d		48890424		MOVQ AX, 0(SP)				
  0x41e741		e8fa5d0000		CALL runtime.printuint(SB)		
  0x41e746		488d05eb0c0500		LEAQ 0x50ceb(IP), AX			
  0x41e74d		48890424		MOVQ AX, 0(SP)				
  0x41e751		48c744240808000000	MOVQ $0x8, 0x8(SP)			
  0x41e75a		e891600000		CALL runtime.printstring(SB)		
  0x41e75f		488b442438		MOVQ 0x38(SP), AX			
  0x41e764		48c1e814		SHRQ $0x14, AX				
  0x41e768		48890424		MOVQ AX, 0(SP)				
  0x41e76c		e8cf5d0000		CALL runtime.printuint(SB)		
  0x41e771		488d056b0b0500		LEAQ 0x50b6b(IP), AX			
  0x41e778		48890424		MOVQ AX, 0(SP)				
  0x41e77c		48c744240807000000	MOVQ $0x7, 0x8(SP)			
  0x41e785		e866600000		CALL runtime.printstring(SB)		
  0x41e78a		488b442430		MOVQ 0x30(SP), AX			
  0x41e78f		48c1e814		SHRQ $0x14, AX				
  0x41e793		48890424		MOVQ AX, 0(SP)				
  0x41e797		e8a45d0000		CALL runtime.printuint(SB)		
  0x41e79c		488d05ce120500		LEAQ 0x512ce(IP), AX			
  0x41e7a3		48890424		MOVQ AX, 0(SP)				
  0x41e7a7		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x41e7b0		e83b600000		CALL runtime.printstring(SB)		
  0x41e7b5		488b442428		MOVQ 0x28(SP), AX			
  0x41e7ba		48c1e814		SHRQ $0x14, AX				
  0x41e7be		48890424		MOVQ AX, 0(SP)				
  0x41e7c2		e8795d0000		CALL runtime.printuint(SB)		
  0x41e7c7		488d0597120500		LEAQ 0x51297(IP), AX			
  0x41e7ce		48890424		MOVQ AX, 0(SP)				
  0x41e7d2		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x41e7db		e810600000		CALL runtime.printstring(SB)		
  0x41e7e0		488b442430		MOVQ 0x30(SP), AX			
  0x41e7e5		488b4c2428		MOVQ 0x28(SP), CX			
  0x41e7ea		4829c8			SUBQ CX, AX				
  0x41e7ed		48c1e814		SHRQ $0x14, AX				
  0x41e7f1		48890424		MOVQ AX, 0(SP)				
  0x41e7f5		e8465d0000		CALL runtime.printuint(SB)		
  0x41e7fa		488d05190a0500		LEAQ 0x50a19(IP), AX			
  0x41e801		48890424		MOVQ AX, 0(SP)				
  0x41e805		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x41e80e		e8dd5f0000		CALL runtime.printstring(SB)		
  0x41e813		e828570000		CALL runtime.printunlock(SB)		
  0x41e818		488b6c2450		MOVQ 0x50(SP), BP			
  0x41e81d		4883c458		ADDQ $0x58, SP				
  0x41e821		c3			RET					
			print("scvg", k, ": ", released>>20, " MB released\n")
  0x41e822		e899560000		CALL runtime.printlock(SB)	
  0x41e827		488d054b090500		LEAQ 0x5094b(IP), AX		
  0x41e82e		48890424		MOVQ AX, 0(SP)			
  0x41e832		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x41e83b		e8b05f0000		CALL runtime.printstring(SB)	
  0x41e840		8b442468		MOVL 0x68(SP), AX		
  0x41e844		4863c8			MOVSXD AX, CX			
  0x41e847		48890c24		MOVQ CX, 0(SP)			
  0x41e84b		e8f05d0000		CALL runtime.printint(SB)	
  0x41e850		488d0549080500		LEAQ 0x50849(IP), AX		
  0x41e857		48890424		MOVQ AX, 0(SP)			
  0x41e85b		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x41e864		e8875f0000		CALL runtime.printstring(SB)	
  0x41e869		488b442420		MOVQ 0x20(SP), AX		
  0x41e86e		48c1e814		SHRQ $0x14, AX			
  0x41e872		48890424		MOVQ AX, 0(SP)			
  0x41e876		e8c55c0000		CALL runtime.printuint(SB)	
  0x41e87b		488d05d4120500		LEAQ 0x512d4(IP), AX		
  0x41e882		48890424		MOVQ AX, 0(SP)			
  0x41e886		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x41e88f		e85c5f0000		CALL runtime.printstring(SB)	
  0x41e894		e8a7560000		CALL runtime.printunlock(SB)	
  0x41e899		e91ffeffff		JMP 0x41e6bd			
func (h *mheap) scavenge(k int32, now, limit uint64) {
  0x41e89e		e8dd8f0200		CALL runtime.morestack_noctxt(SB)	
  0x41e8a3		e968fdffff		JMP runtime.(*mheap).scavenge(SB)	

TEXT runtime.(*mSpanList).remove(SB) /usr/local/go/src/runtime/mheap.go
func (list *mSpanList) remove(span *mspan) {
  0x41e8b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41e8b9		483b6110		CMPQ 0x10(CX), SP	
  0x41e8bd		0f866f010000		JBE 0x41ea32		
  0x41e8c3		4883ec30		SUBQ $0x30, SP		
  0x41e8c7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41e8cc		488d6c2428		LEAQ 0x28(SP), BP	
	if span.list != list {
  0x41e8d1		488b442440		MOVQ 0x40(SP), AX	
  0x41e8d6		488b4810		MOVQ 0x10(AX), CX	
  0x41e8da		488b542438		MOVQ 0x38(SP), DX	
  0x41e8df		4839d1			CMPQ DX, CX		
  0x41e8e2		754a			JNE 0x41e92e		
	if list.first == span {
  0x41e8e4		483902			CMPQ AX, 0(DX)		
  0x41e8e7		7539			JNE 0x41e922		
		list.first = span.next
  0x41e8e9		488b08			MOVQ 0(AX), CX		
  0x41e8ec		48890a			MOVQ CX, 0(DX)		
	if list.last == span {
  0x41e8ef		48394208		CMPQ AX, 0x8(DX)	
  0x41e8f3		7520			JNE 0x41e915		
		list.last = span.prev
  0x41e8f5		488b4808		MOVQ 0x8(AX), CX	
  0x41e8f9		48894a08		MOVQ CX, 0x8(DX)	
	span.prev = nil
  0x41e8fd		0f57c0			XORPS X0, X0		
  0x41e900		0f1100			MOVUPS X0, 0(AX)	
	span.list = nil
  0x41e903		48c7401000000000	MOVQ $0x0, 0x10(AX)	
}
  0x41e90b		488b6c2428		MOVQ 0x28(SP), BP	
  0x41e910		4883c430		ADDQ $0x30, SP		
  0x41e914		c3			RET			
		span.next.prev = span.prev
  0x41e915		488b08			MOVQ 0(AX), CX		
  0x41e918		488b5008		MOVQ 0x8(AX), DX	
  0x41e91c		48895108		MOVQ DX, 0x8(CX)	
  0x41e920		ebdb			JMP 0x41e8fd		
		span.prev.next = span.next
  0x41e922		488b4808		MOVQ 0x8(AX), CX	
  0x41e926		488b18			MOVQ 0(AX), BX		
  0x41e929		488919			MOVQ BX, 0(CX)		
  0x41e92c		ebc1			JMP 0x41e8ef		
	if span.list != list {
  0x41e92e		48894c2420		MOVQ CX, 0x20(SP)	
		print("runtime: failed mSpanList.remove span.npages=", span.npages,
  0x41e933		488b4820		MOVQ 0x20(AX), CX	
  0x41e937		48894c2410		MOVQ CX, 0x10(SP)	
			" span=", span, " prev=", span.prev, " span.list=", span.list, " list=", list, "\n")
  0x41e93c		488b5008		MOVQ 0x8(AX), DX	
  0x41e940		4889542418		MOVQ DX, 0x18(SP)	
		print("runtime: failed mSpanList.remove span.npages=", span.npages,
  0x41e945		e876550000		CALL runtime.printlock(SB)	
  0x41e94a		488d0564450500		LEAQ 0x54564(IP), AX		
  0x41e951		48890424		MOVQ AX, 0(SP)			
  0x41e955		48c74424082d000000	MOVQ $0x2d, 0x8(SP)		
  0x41e95e		e88d5e0000		CALL runtime.printstring(SB)	
  0x41e963		488b442410		MOVQ 0x10(SP), AX		
  0x41e968		48890424		MOVQ AX, 0(SP)			
  0x41e96c		e8cf5b0000		CALL runtime.printuint(SB)	
  0x41e971		488d05f0080500		LEAQ 0x508f0(IP), AX		
  0x41e978		48890424		MOVQ AX, 0(SP)			
  0x41e97c		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41e985		e8665e0000		CALL runtime.printstring(SB)	
  0x41e98a		488b442440		MOVQ 0x40(SP), AX		
  0x41e98f		48890424		MOVQ AX, 0(SP)			
  0x41e993		e8185e0000		CALL runtime.printpointer(SB)	
  0x41e998		488d05c3080500		LEAQ 0x508c3(IP), AX		
  0x41e99f		48890424		MOVQ AX, 0(SP)			
  0x41e9a3		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41e9ac		e83f5e0000		CALL runtime.printstring(SB)	
  0x41e9b1		488b442418		MOVQ 0x18(SP), AX		
  0x41e9b6		48890424		MOVQ AX, 0(SP)			
  0x41e9ba		e8f15d0000		CALL runtime.printpointer(SB)	
  0x41e9bf		488d05f50e0500		LEAQ 0x50ef5(IP), AX		
  0x41e9c6		48890424		MOVQ AX, 0(SP)			
  0x41e9ca		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x41e9d3		e8185e0000		CALL runtime.printstring(SB)	
  0x41e9d8		488b442420		MOVQ 0x20(SP), AX		
  0x41e9dd		48890424		MOVQ AX, 0(SP)			
  0x41e9e1		e8ca5d0000		CALL runtime.printpointer(SB)	
  0x41e9e6		488d055d080500		LEAQ 0x5085d(IP), AX		
  0x41e9ed		48890424		MOVQ AX, 0(SP)			
  0x41e9f1		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x41e9fa		e8f15d0000		CALL runtime.printstring(SB)	
  0x41e9ff		488b442438		MOVQ 0x38(SP), AX		
  0x41ea04		48890424		MOVQ AX, 0(SP)			
  0x41ea08		e8a35d0000		CALL runtime.printpointer(SB)	
  0x41ea0d		e83e570000		CALL runtime.printnl(SB)	
  0x41ea12		e829550000		CALL runtime.printunlock(SB)	
		throw("mSpanList.remove")
  0x41ea17		488d0519160500		LEAQ 0x51619(IP), AX	
  0x41ea1e		48890424		MOVQ AX, 0(SP)		
  0x41ea22		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41ea2b		e8504a0000		CALL runtime.throw(SB)	
  0x41ea30		0f0b			UD2			
func (list *mSpanList) remove(span *mspan) {
  0x41ea32		e8498e0200		CALL runtime.morestack_noctxt(SB)	
  0x41ea37		e974feffff		JMP runtime.(*mSpanList).remove(SB)	

TEXT runtime.(*mSpanList).insert(SB) /usr/local/go/src/runtime/mheap.go
func (list *mSpanList) insert(span *mspan) {
  0x41ea40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ea49		483b6110		CMPQ 0x10(CX), SP	
  0x41ea4d		0f86f8000000		JBE 0x41eb4b		
  0x41ea53		4883ec30		SUBQ $0x30, SP		
  0x41ea57		48896c2428		MOVQ BP, 0x28(SP)	
  0x41ea5c		488d6c2428		LEAQ 0x28(SP), BP	
	if span.next != nil || span.prev != nil || span.list != nil {
  0x41ea61		488b442440		MOVQ 0x40(SP), AX	
  0x41ea66		488b08			MOVQ 0(AX), CX		
  0x41ea69		48894c2420		MOVQ CX, 0x20(SP)	
  0x41ea6e		4885c9			TESTQ CX, CX		
  0x41ea71		753c			JNE 0x41eaaf		
  0x41ea73		4883780800		CMPQ $0x0, 0x8(AX)	
  0x41ea78		7535			JNE 0x41eaaf		
  0x41ea7a		4883781000		CMPQ $0x0, 0x10(AX)	
  0x41ea7f		752e			JNE 0x41eaaf		
	span.next = list.first
  0x41ea81		488b4c2438		MOVQ 0x38(SP), CX	
  0x41ea86		488b11			MOVQ 0(CX), DX		
  0x41ea89		488910			MOVQ DX, 0(AX)		
	if list.first != nil {
  0x41ea8c		488b11			MOVQ 0(CX), DX		
  0x41ea8f		4885d2			TESTQ DX, DX		
  0x41ea92		7415			JE 0x41eaa9		
		list.first.prev = span
  0x41ea94		48894208		MOVQ AX, 0x8(DX)	
	list.first = span
  0x41ea98		488901			MOVQ AX, 0(CX)		
	span.list = list
  0x41ea9b		48894810		MOVQ CX, 0x10(AX)	
}
  0x41ea9f		488b6c2428		MOVQ 0x28(SP), BP	
  0x41eaa4		4883c430		ADDQ $0x30, SP		
  0x41eaa8		c3			RET			
		list.last = span
  0x41eaa9		48894108		MOVQ AX, 0x8(CX)	
  0x41eaad		ebe9			JMP 0x41ea98		
		println("runtime: failed mSpanList.insert", span, span.next, span.prev, span.list)
  0x41eaaf		488b4808		MOVQ 0x8(AX), CX		
  0x41eab3		48894c2418		MOVQ CX, 0x18(SP)		
  0x41eab8		488b5010		MOVQ 0x10(AX), DX		
  0x41eabc		4889542410		MOVQ DX, 0x10(SP)		
  0x41eac1		e8fa530000		CALL runtime.printlock(SB)	
  0x41eac6		488d05ef360500		LEAQ 0x536ef(IP), AX		
  0x41eacd		48890424		MOVQ AX, 0(SP)			
  0x41ead1		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x41eada		e8115d0000		CALL runtime.printstring(SB)	
  0x41eadf		488b442440		MOVQ 0x40(SP), AX		
  0x41eae4		48890424		MOVQ AX, 0(SP)			
  0x41eae8		e8c35c0000		CALL runtime.printpointer(SB)	
  0x41eaed		e80e560000		CALL runtime.printsp(SB)	
  0x41eaf2		488b442420		MOVQ 0x20(SP), AX		
  0x41eaf7		48890424		MOVQ AX, 0(SP)			
  0x41eafb		e8b05c0000		CALL runtime.printpointer(SB)	
  0x41eb00		e8fb550000		CALL runtime.printsp(SB)	
  0x41eb05		488b442418		MOVQ 0x18(SP), AX		
  0x41eb0a		48890424		MOVQ AX, 0(SP)			
  0x41eb0e		e89d5c0000		CALL runtime.printpointer(SB)	
  0x41eb13		e8e8550000		CALL runtime.printsp(SB)	
  0x41eb18		488b442410		MOVQ 0x10(SP), AX		
  0x41eb1d		48890424		MOVQ AX, 0(SP)			
  0x41eb21		e88a5c0000		CALL runtime.printpointer(SB)	
  0x41eb26		e825560000		CALL runtime.printnl(SB)	
  0x41eb2b		e810540000		CALL runtime.printunlock(SB)	
		throw("mSpanList.insert")
  0x41eb30		488d05f0140500		LEAQ 0x514f0(IP), AX	
  0x41eb37		48890424		MOVQ AX, 0(SP)		
  0x41eb3b		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41eb44		e837490000		CALL runtime.throw(SB)	
  0x41eb49		0f0b			UD2			
func (list *mSpanList) insert(span *mspan) {
  0x41eb4b		e8308d0200		CALL runtime.morestack_noctxt(SB)	
  0x41eb50		e9ebfeffff		JMP runtime.(*mSpanList).insert(SB)	

TEXT runtime.(*mSpanList).insertBack(SB) /usr/local/go/src/runtime/mheap.go
func (list *mSpanList) insertBack(span *mspan) {
  0x41eb60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41eb69		483b6110		CMPQ 0x10(CX), SP	
  0x41eb6d		0f86fa000000		JBE 0x41ec6d		
  0x41eb73		4883ec30		SUBQ $0x30, SP		
  0x41eb77		48896c2428		MOVQ BP, 0x28(SP)	
  0x41eb7c		488d6c2428		LEAQ 0x28(SP), BP	
	if span.next != nil || span.prev != nil || span.list != nil {
  0x41eb81		488b442440		MOVQ 0x40(SP), AX	
  0x41eb86		488b08			MOVQ 0(AX), CX		
  0x41eb89		48894c2420		MOVQ CX, 0x20(SP)	
  0x41eb8e		4885c9			TESTQ CX, CX		
  0x41eb91		753e			JNE 0x41ebd1		
  0x41eb93		4883780800		CMPQ $0x0, 0x8(AX)	
  0x41eb98		7537			JNE 0x41ebd1		
  0x41eb9a		4883781000		CMPQ $0x0, 0x10(AX)	
  0x41eb9f		7530			JNE 0x41ebd1		
	span.prev = list.last
  0x41eba1		488b4c2438		MOVQ 0x38(SP), CX	
  0x41eba6		488b5108		MOVQ 0x8(CX), DX	
  0x41ebaa		48895008		MOVQ DX, 0x8(AX)	
	if list.last != nil {
  0x41ebae		488b5108		MOVQ 0x8(CX), DX	
  0x41ebb2		4885d2			TESTQ DX, DX		
  0x41ebb5		7415			JE 0x41ebcc		
		list.last.next = span
  0x41ebb7		488902			MOVQ AX, 0(DX)		
	list.last = span
  0x41ebba		48894108		MOVQ AX, 0x8(CX)	
	span.list = list
  0x41ebbe		48894810		MOVQ CX, 0x10(AX)	
}
  0x41ebc2		488b6c2428		MOVQ 0x28(SP), BP	
  0x41ebc7		4883c430		ADDQ $0x30, SP		
  0x41ebcb		c3			RET			
		list.first = span
  0x41ebcc		488901			MOVQ AX, 0(CX)		
  0x41ebcf		ebe9			JMP 0x41ebba		
		println("runtime: failed mSpanList.insertBack", span, span.next, span.prev, span.list)
  0x41ebd1		488b4808		MOVQ 0x8(AX), CX		
  0x41ebd5		48894c2418		MOVQ CX, 0x18(SP)		
  0x41ebda		488b5010		MOVQ 0x10(AX), DX		
  0x41ebde		4889542410		MOVQ DX, 0x10(SP)		
  0x41ebe3		e8d8520000		CALL runtime.printlock(SB)	
  0x41ebe8		488d05f43a0500		LEAQ 0x53af4(IP), AX		
  0x41ebef		48890424		MOVQ AX, 0(SP)			
  0x41ebf3		48c744240825000000	MOVQ $0x25, 0x8(SP)		
  0x41ebfc		e8ef5b0000		CALL runtime.printstring(SB)	
  0x41ec01		488b442440		MOVQ 0x40(SP), AX		
  0x41ec06		48890424		MOVQ AX, 0(SP)			
  0x41ec0a		e8a15b0000		CALL runtime.printpointer(SB)	
  0x41ec0f		e8ec540000		CALL runtime.printsp(SB)	
  0x41ec14		488b442420		MOVQ 0x20(SP), AX		
  0x41ec19		48890424		MOVQ AX, 0(SP)			
  0x41ec1d		e88e5b0000		CALL runtime.printpointer(SB)	
  0x41ec22		e8d9540000		CALL runtime.printsp(SB)	
  0x41ec27		488b442418		MOVQ 0x18(SP), AX		
  0x41ec2c		48890424		MOVQ AX, 0(SP)			
  0x41ec30		e87b5b0000		CALL runtime.printpointer(SB)	
  0x41ec35		e8c6540000		CALL runtime.printsp(SB)	
  0x41ec3a		488b442410		MOVQ 0x10(SP), AX		
  0x41ec3f		48890424		MOVQ AX, 0(SP)			
  0x41ec43		e8685b0000		CALL runtime.printpointer(SB)	
  0x41ec48		e803550000		CALL runtime.printnl(SB)	
  0x41ec4d		e8ee520000		CALL runtime.printunlock(SB)	
		throw("mSpanList.insertBack")
  0x41ec52		488d05401a0500		LEAQ 0x51a40(IP), AX	
  0x41ec59		48890424		MOVQ AX, 0(SP)		
  0x41ec5d		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41ec66		e815480000		CALL runtime.throw(SB)	
  0x41ec6b		0f0b			UD2			
func (list *mSpanList) insertBack(span *mspan) {
  0x41ec6d		e80e8c0200		CALL runtime.morestack_noctxt(SB)	
  0x41ec72		e9e9feffff		JMP runtime.(*mSpanList).insertBack(SB)	

TEXT runtime.(*mSpanList).takeAll(SB) /usr/local/go/src/runtime/mheap.go
	if other.isEmpty() {
  0x41ec80		90			NOPL			
  0x41ec81		488b442410		MOVQ 0x10(SP), AX	
	return list.first == nil
  0x41ec86		488b08			MOVQ 0(AX), CX		
  0x41ec89		4885c9			TESTQ CX, CX		
	if other.isEmpty() {
  0x41ec8c		744b			JE 0x41ecd9		
	for s := other.first; s != nil; s = s.next {
  0x41ec8e		488b542408		MOVQ 0x8(SP), DX	
  0x41ec93		eb07			JMP 0x41ec9c		
		s.list = list
  0x41ec95		48895110		MOVQ DX, 0x10(CX)	
	for s := other.first; s != nil; s = s.next {
  0x41ec99		488b09			MOVQ 0(CX), CX		
  0x41ec9c		4885c9			TESTQ CX, CX		
  0x41ec9f		75f4			JNE 0x41ec95		
	if list.isEmpty() {
  0x41eca1		90			NOPL			
	return list.first == nil
  0x41eca2		488b0a			MOVQ 0(DX), CX		
  0x41eca5		4885c9			TESTQ CX, CX		
	if list.isEmpty() {
  0x41eca8		741f			JE 0x41ecc9		
		other.last.next = list.first
  0x41ecaa		488b5808		MOVQ 0x8(AX), BX	
  0x41ecae		48890b			MOVQ CX, 0(BX)		
		list.first.prev = other.last
  0x41ecb1		488b0a			MOVQ 0(DX), CX		
  0x41ecb4		488b5808		MOVQ 0x8(AX), BX	
  0x41ecb8		48895908		MOVQ BX, 0x8(CX)	
		list.first = other.first
  0x41ecbc		488b08			MOVQ 0(AX), CX		
  0x41ecbf		48890a			MOVQ CX, 0(DX)		
	other.first, other.last = nil, nil
  0x41ecc2		0f57c0			XORPS X0, X0		
  0x41ecc5		0f1100			MOVUPS X0, 0(AX)	
}
  0x41ecc8		c3			RET			
		*list = *other
  0x41ecc9		488b4808		MOVQ 0x8(AX), CX	
  0x41eccd		488b18			MOVQ 0(AX), BX		
  0x41ecd0		48891a			MOVQ BX, 0(DX)		
  0x41ecd3		48894a08		MOVQ CX, 0x8(DX)	
  0x41ecd7		ebe9			JMP 0x41ecc2		
		return
  0x41ecd9		c3			RET			

TEXT runtime.addspecial(SB) /usr/local/go/src/runtime/mheap.go
func addspecial(p unsafe.Pointer, s *special) bool {
  0x41ece0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ece9		483b6110		CMPQ 0x10(CX), SP	
  0x41eced		0f86a1010000		JBE 0x41ee94		
  0x41ecf3		4883ec40		SUBQ $0x40, SP		
  0x41ecf7		48896c2438		MOVQ BP, 0x38(SP)	
  0x41ecfc		488d6c2438		LEAQ 0x38(SP), BP	
	span := spanOfHeap(uintptr(p))
  0x41ed01		488b442448		MOVQ 0x48(SP), AX		
  0x41ed06		48890424		MOVQ AX, 0(SP)			
  0x41ed0a		e801daffff		CALL runtime.spanOfHeap(SB)	
  0x41ed0f		488b442408		MOVQ 0x8(SP), AX		
	if span == nil {
  0x41ed14		4885c0			TESTQ AX, AX		
  0x41ed17		0f845c010000		JE 0x41ee79		
	span := spanOfHeap(uintptr(p))
  0x41ed1d		4889442420		MOVQ AX, 0x20(SP)	
	_g_ := getg()
  0x41ed22		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x41ed2b		488b5130		MOVQ 0x30(CX), DX	
	mp := acquirem()
  0x41ed2f		90			NOPL			
	_g_.m.locks++
  0x41ed30		ff8208010000		INCL 0x108(DX)		
	return _g_.m
  0x41ed36		488b4930		MOVQ 0x30(CX), CX	
  0x41ed3a		48894c2428		MOVQ CX, 0x28(SP)	
	span.ensureSwept()
  0x41ed3f		48890424		MOVQ AX, 0(SP)				
  0x41ed43		e8b8b8ffff		CALL runtime.(*mspan).ensureSwept(SB)	
	offset := uintptr(p) - span.base()
  0x41ed48		488b442448		MOVQ 0x48(SP), AX	
  0x41ed4d		488b4c2420		MOVQ 0x20(SP), CX	
  0x41ed52		482b4118		SUBQ 0x18(CX), AX	
  0x41ed56		4889442418		MOVQ AX, 0x18(SP)	
  0x41ed5b		90			NOPL			
	kind := s.kind
  0x41ed5c		488b542450		MOVQ 0x50(SP), DX	
  0x41ed61		0fb65a0a		MOVZX 0xa(DX), BX	
  0x41ed65		885c2417		MOVB BL, 0x17(SP)	
	lock(&span.speciallock)
  0x41ed69		488db180000000		LEAQ 0x80(CX), SI	
  0x41ed70		4889742430		MOVQ SI, 0x30(SP)	
  0x41ed75		48893424		MOVQ SI, 0(SP)		
  0x41ed79		e86299feff		CALL runtime.lock(SB)	
	t := &span.specials
  0x41ed7e		488b442420		MOVQ 0x20(SP), AX	
  0x41ed83		480588000000		ADDQ $0x88, AX		
	for {
  0x41ed89		0fb64c2417		MOVZX 0x17(SP), CX	
  0x41ed8e		488b542418		MOVQ 0x18(SP), DX	
  0x41ed93		eb03			JMP 0x41ed98		
		x := *t
  0x41ed95		4889d8			MOVQ BX, AX		
  0x41ed98		488b18			MOVQ 0(AX), BX		
		if x == nil {
  0x41ed9b		4885db			TESTQ BX, BX		
  0x41ed9e		7421			JE 0x41edc1		
		if offset == uintptr(x.offset) && kind == x.kind {
  0x41eda0		0fb77308		MOVZX 0x8(BX), SI	
  0x41eda4		4839f2			CMPQ SI, DX		
  0x41eda7		7508			JNE 0x41edb1		
  0x41eda9		384b0a			CMPB CL, 0xa(BX)	
  0x41edac		747a			JE 0x41ee28		
  0x41edae		4839f2			CMPQ SI, DX		
		if offset < uintptr(x.offset) || (offset == uintptr(x.offset) && kind < x.kind) {
  0x41edb1		720e			JB 0x41edc1		
  0x41edb3		756f			JNE 0x41ee24		
  0x41edb5		384b0a			CMPB CL, 0xa(BX)	
  0x41edb8		400f97c6		SETA SI			
  0x41edbc		4084f6			TESTL SI, SI		
  0x41edbf		74d4			JE 0x41ed95		
	s.offset = uint16(offset)
  0x41edc1		488b4c2450		MOVQ 0x50(SP), CX	
  0x41edc6		66895108		MOVW DX, 0x8(CX)	
	s.next = *t
  0x41edca		488b10			MOVQ 0(AX), DX		
  0x41edcd		488911			MOVQ DX, 0(CX)		
	*t = s
  0x41edd0		488908			MOVQ CX, 0(AX)		
	unlock(&span.speciallock)
  0x41edd3		488b442430		MOVQ 0x30(SP), AX	
  0x41edd8		48890424		MOVQ AX, 0(SP)		
  0x41eddc		e8af9afeff		CALL runtime.unlock(SB)	
	releasem(mp)
  0x41ede1		90			NOPL			
	_g_ := getg()
  0x41ede2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x41edeb		488b4c2428		MOVQ 0x28(SP), CX	
  0x41edf0		8b9108010000		MOVL 0x108(CX), DX	
  0x41edf6		8d5aff			LEAL -0x1(DX), BX	
  0x41edf9		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x41edff		83fa01			CMPL $0x1, DX		
  0x41ee02		7511			JNE 0x41ee15		
  0x41ee04		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41ee0b		7408			JE 0x41ee15		
		_g_.stackguard0 = stackPreempt
  0x41ee0d		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return true
  0x41ee15		c644245801		MOVB $0x1, 0x58(SP)	
  0x41ee1a		488b6c2438		MOVQ 0x38(SP), BP	
  0x41ee1f		4883c440		ADDQ $0x40, SP		
  0x41ee23		c3			RET			
  0x41ee24		31f6			XORL SI, SI		
		if offset < uintptr(x.offset) || (offset == uintptr(x.offset) && kind < x.kind) {
  0x41ee26		eb94			JMP 0x41edbc		
			unlock(&span.speciallock)
  0x41ee28		488b442430		MOVQ 0x30(SP), AX	
  0x41ee2d		48890424		MOVQ AX, 0(SP)		
  0x41ee31		e85a9afeff		CALL runtime.unlock(SB)	
			releasem(mp)
  0x41ee36		90			NOPL			
	_g_ := getg()
  0x41ee37		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x41ee40		488b4c2428		MOVQ 0x28(SP), CX	
  0x41ee45		8b9108010000		MOVL 0x108(CX), DX	
  0x41ee4b		8d5aff			LEAL -0x1(DX), BX	
  0x41ee4e		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x41ee54		83fa01			CMPL $0x1, DX		
  0x41ee57		7511			JNE 0x41ee6a		
  0x41ee59		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x41ee60		7408			JE 0x41ee6a		
		_g_.stackguard0 = stackPreempt
  0x41ee62		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
			return false // already exists
  0x41ee6a		c644245800		MOVB $0x0, 0x58(SP)	
  0x41ee6f		488b6c2438		MOVQ 0x38(SP), BP	
  0x41ee74		4883c440		ADDQ $0x40, SP		
  0x41ee78		c3			RET			
		throw("addspecial on invalid pointer")
  0x41ee79		488d05f8290500		LEAQ 0x529f8(IP), AX	
  0x41ee80		48890424		MOVQ AX, 0(SP)		
  0x41ee84		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x41ee8d		e8ee450000		CALL runtime.throw(SB)	
  0x41ee92		0f0b			UD2			
func addspecial(p unsafe.Pointer, s *special) bool {
  0x41ee94		e8e7890200		CALL runtime.morestack_noctxt(SB)	
  0x41ee99		e942feffff		JMP runtime.addspecial(SB)		

TEXT runtime.setprofilebucket(SB) /usr/local/go/src/runtime/mheap.go
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41eea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41eea9		483b6110		CMPQ 0x10(CX), SP	
  0x41eead		0f8699000000		JBE 0x41ef4c		
  0x41eeb3		4883ec28		SUBQ $0x28, SP		
  0x41eeb7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41eebc		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&mheap_.speciallock)
  0x41eec1		488d05e09d0a00		LEAQ runtime.mheap_+9832(SB), AX	
  0x41eec8		48890424		MOVQ AX, 0(SP)				
  0x41eecc		e80f98feff		CALL runtime.lock(SB)			
	s := (*specialprofile)(mheap_.specialprofilealloc.alloc())
  0x41eed1		488d05889d0a00		LEAQ runtime.mheap_+9760(SB), AX	
  0x41eed8		48890424		MOVQ AX, 0(SP)				
  0x41eedc		e8af2cffff		CALL runtime.(*fixalloc).alloc(SB)	
  0x41eee1		488b442408		MOVQ 0x8(SP), AX			
  0x41eee6		4889442418		MOVQ AX, 0x18(SP)			
	unlock(&mheap_.speciallock)
  0x41eeeb		488d0db69d0a00		LEAQ runtime.mheap_+9832(SB), CX	
  0x41eef2		48890c24		MOVQ CX, 0(SP)				
  0x41eef6		e89599feff		CALL runtime.unlock(SB)			
	s.special.kind = _KindSpecialProfile
  0x41eefb		488b442418		MOVQ 0x18(SP), AX	
  0x41ef00		c6400a02		MOVB $0x2, 0xa(AX)	
	s.b = b
  0x41ef04		488b4c2438		MOVQ 0x38(SP), CX	
  0x41ef09		48894810		MOVQ CX, 0x10(AX)	
	if !addspecial(p, &s.special) {
  0x41ef0d		488b4c2430		MOVQ 0x30(SP), CX		
  0x41ef12		48890c24		MOVQ CX, 0(SP)			
  0x41ef16		4889442408		MOVQ AX, 0x8(SP)		
  0x41ef1b		e8c0fdffff		CALL runtime.addspecial(SB)	
  0x41ef20		807c241000		CMPB $0x0, 0x10(SP)		
  0x41ef25		740a			JE 0x41ef31			
  0x41ef27		488b6c2420		MOVQ 0x20(SP), BP		
  0x41ef2c		4883c428		ADDQ $0x28, SP			
  0x41ef30		c3			RET				
		throw("setprofilebucket: profile already set")
  0x41ef31		488d05d0370500		LEAQ 0x537d0(IP), AX	
  0x41ef38		48890424		MOVQ AX, 0(SP)		
  0x41ef3c		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x41ef45		e836450000		CALL runtime.throw(SB)	
  0x41ef4a		0f0b			UD2			
func setprofilebucket(p unsafe.Pointer, b *bucket) {
  0x41ef4c		e82f890200		CALL runtime.morestack_noctxt(SB)	
  0x41ef51		e94affffff		JMP runtime.setprofilebucket(SB)	

TEXT runtime.freespecial(SB) /usr/local/go/src/runtime/mheap.go
func freespecial(s *special, p unsafe.Pointer, size uintptr) {
  0x41ef60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ef69		483b6110		CMPQ 0x10(CX), SP	
  0x41ef6d		0f8630010000		JBE 0x41f0a3		
  0x41ef73		4883ec30		SUBQ $0x30, SP		
  0x41ef77		48896c2428		MOVQ BP, 0x28(SP)	
  0x41ef7c		488d6c2428		LEAQ 0x28(SP), BP	
	switch s.kind {
  0x41ef81		488b442438		MOVQ 0x38(SP), AX	
  0x41ef86		0fb6480a		MOVZX 0xa(AX), CX	
	case _KindSpecialFinalizer:
  0x41ef8a		80f901			CMPL $0x1, CL		
  0x41ef8d		7476			JE 0x41f005		
	case _KindSpecialProfile:
  0x41ef8f		80f902			CMPL $0x2, CL		
  0x41ef92		0f85f0000000		JNE 0x41f088		
		mProf_Free(sp.b, size)
  0x41ef98		488b4810		MOVQ 0x10(AX), CX		
  0x41ef9c		48890c24		MOVQ CX, 0(SP)			
  0x41efa0		488b4c2448		MOVQ 0x48(SP), CX		
  0x41efa5		48894c2408		MOVQ CX, 0x8(SP)		
  0x41efaa		e8e10e0000		CALL runtime.mProf_Free(SB)	
		lock(&mheap_.speciallock)
  0x41efaf		488d05f29c0a00		LEAQ runtime.mheap_+9832(SB), AX	
  0x41efb6		48890424		MOVQ AX, 0(SP)				
  0x41efba		e82197feff		CALL runtime.lock(SB)			
		mheap_.specialprofilealloc.free(unsafe.Pointer(sp))
  0x41efbf		90			NOPL			
	f.inuse -= f.size
  0x41efc0		488b05c99c0a00		MOVQ runtime.mheap_+9808(SB), AX	
  0x41efc7		482b05929c0a00		SUBQ runtime.mheap_+9760(SB), AX	
  0x41efce		488905bb9c0a00		MOVQ AX, runtime.mheap_+9808(SB)	
	v.next = f.list
  0x41efd5		488b059c9c0a00		MOVQ runtime.mheap_+9784(SB), AX	
  0x41efdc		488b4c2438		MOVQ 0x38(SP), CX			
  0x41efe1		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x41efe4		48890d8d9c0a00		MOVQ CX, runtime.mheap_+9784(SB)	
		unlock(&mheap_.speciallock)
  0x41efeb		488d05b69c0a00		LEAQ runtime.mheap_+9832(SB), AX	
  0x41eff2		48890424		MOVQ AX, 0(SP)				
  0x41eff6		e89598feff		CALL runtime.unlock(SB)			
  0x41effb		488b6c2428		MOVQ 0x28(SP), BP			
  0x41f000		4883c430		ADDQ $0x30, SP				
  0x41f004		c3			RET					
		queuefinalizer(p, sf.fn, sf.nret, sf.fint, sf.ot)
  0x41f005		488b4810		MOVQ 0x10(AX), CX		
  0x41f009		488b5018		MOVQ 0x18(AX), DX		
  0x41f00d		488b5820		MOVQ 0x20(AX), BX		
  0x41f011		488b7028		MOVQ 0x28(AX), SI		
  0x41f015		488b7c2440		MOVQ 0x40(SP), DI		
  0x41f01a		48893c24		MOVQ DI, 0(SP)			
  0x41f01e		48894c2408		MOVQ CX, 0x8(SP)		
  0x41f023		4889542410		MOVQ DX, 0x10(SP)		
  0x41f028		48895c2418		MOVQ BX, 0x18(SP)		
  0x41f02d		4889742420		MOVQ SI, 0x20(SP)		
  0x41f032		e87928ffff		CALL runtime.queuefinalizer(SB)	
		lock(&mheap_.speciallock)
  0x41f037		488d056a9c0a00		LEAQ runtime.mheap_+9832(SB), AX	
  0x41f03e		48890424		MOVQ AX, 0(SP)				
  0x41f042		e89996feff		CALL runtime.lock(SB)			
		mheap_.specialfinalizeralloc.free(unsafe.Pointer(sf))
  0x41f047		90			NOPL			
	f.inuse -= f.size
  0x41f048		488b05f99b0a00		MOVQ runtime.mheap_+9736(SB), AX	
  0x41f04f		482b05c29b0a00		SUBQ runtime.mheap_+9688(SB), AX	
  0x41f056		488905eb9b0a00		MOVQ AX, runtime.mheap_+9736(SB)	
	v.next = f.list
  0x41f05d		488b05cc9b0a00		MOVQ runtime.mheap_+9712(SB), AX	
  0x41f064		488b4c2438		MOVQ 0x38(SP), CX			
  0x41f069		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x41f06c		48890dbd9b0a00		MOVQ CX, runtime.mheap_+9712(SB)	
		unlock(&mheap_.speciallock)
  0x41f073		488d052e9c0a00		LEAQ runtime.mheap_+9832(SB), AX	
  0x41f07a		48890424		MOVQ AX, 0(SP)				
  0x41f07e		e80d98feff		CALL runtime.unlock(SB)			
	switch s.kind {
  0x41f083		e973ffffff		JMP 0x41effb		
		throw("bad special kind")
  0x41f088		488d05280f0500		LEAQ 0x50f28(IP), AX	
  0x41f08f		48890424		MOVQ AX, 0(SP)		
  0x41f093		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x41f09c		e8df430000		CALL runtime.throw(SB)	
  0x41f0a1		0f0b			UD2			
func freespecial(s *special, p unsafe.Pointer, size uintptr) {
  0x41f0a3		e8d8870200		CALL runtime.morestack_noctxt(SB)	
  0x41f0a8		e9b3feffff		JMP runtime.freespecial(SB)		

TEXT runtime.newMarkBits(SB) /usr/local/go/src/runtime/mheap.go
func newMarkBits(nelems uintptr) *gcBits {
  0x41f0b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f0b9		483b6110		CMPQ 0x10(CX), SP	
  0x41f0bd		0f8621030000		JBE 0x41f3e4		
  0x41f0c3		4883ec40		SUBQ $0x40, SP		
  0x41f0c7		48896c2438		MOVQ BP, 0x38(SP)	
  0x41f0cc		488d6c2438		LEAQ 0x38(SP), BP	
	head := (*gcBitsArena)(atomic.Loadp(unsafe.Pointer(&gcBitsArenas.next)))
  0x41f0d1		488b05b82a0a00		MOVQ runtime.gcBitsArenas+16(SB), AX	
	blocksNeeded := uintptr((nelems + 63) / 64)
  0x41f0d8		488b4c2448		MOVQ 0x48(SP), CX	
  0x41f0dd		4883c13f		ADDQ $0x3f, CX		
  0x41f0e1		48c1e906		SHRQ $0x6, CX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41f0e5		90			NOPL			
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f0e6		4885c0			TESTQ AX, AX		
  0x41f0e9		0f84b4020000		JE 0x41f3a3		
  0x41f0ef		488b10			MOVQ 0(AX), DX		
  0x41f0f2		488d14ca		LEAQ 0(DX)(CX*8), DX	
  0x41f0f6		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41f0fd		0f97c2			SETA DL			
	bytesNeeded := blocksNeeded * 8
  0x41f100		4889cb			MOVQ CX, BX		
  0x41f103		48c1e103		SHLQ $0x3, CX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f107		84d2			TESTL DL, DL		
  0x41f109		0f8459020000		JE 0x41f368		
  0x41f10f		31c0			XORL AX, AX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41f111		4885c0			TESTQ AX, AX		
  0x41f114		0f853f020000		JNE 0x41f359		
	bytesNeeded := blocksNeeded * 8
  0x41f11a		48894c2418		MOVQ CX, 0x18(SP)	
	blocksNeeded := uintptr((nelems + 63) / 64)
  0x41f11f		48895c2410		MOVQ BX, 0x10(SP)	
	lock(&gcBitsArenas.lock)
  0x41f124		488d05552a0a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f12b		48890424		MOVQ AX, 0(SP)				
  0x41f12f		e8ac95feff		CALL runtime.lock(SB)			
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f134		488b05552a0a00		MOVQ runtime.gcBitsArenas+16(SB), AX	
  0x41f13b		90			NOPL					
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f13c		4885c0			TESTQ AX, AX		
  0x41f13f		0f8405020000		JE 0x41f34a		
  0x41f145		488b08			MOVQ 0(AX), CX		
  0x41f148		488b542410		MOVQ 0x10(SP), DX	
  0x41f14d		488d0cd1		LEAQ 0(CX)(DX*8), CX	
  0x41f151		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f158		0f97c1			SETA CL			
  0x41f15b		84c9			TESTL CL, CL		
  0x41f15d		0f84a9010000		JE 0x41f30c		
  0x41f163		31c0			XORL AX, AX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f165		4885c0			TESTQ AX, AX		
  0x41f168		0f8575010000		JNE 0x41f2e3		
	fresh := newArenaMayUnlock()
  0x41f16e		e83d030000		CALL runtime.newArenaMayUnlock(SB)	
  0x41f173		488b0424		MOVQ 0(SP), AX				
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f177		488b0d122a0a00		MOVQ runtime.gcBitsArenas+16(SB), CX	
  0x41f17e		90			NOPL					
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f17f		4885c9			TESTQ CX, CX		
  0x41f182		0f844c010000		JE 0x41f2d4		
  0x41f188		488b11			MOVQ 0(CX), DX		
  0x41f18b		488b5c2410		MOVQ 0x10(SP), BX	
  0x41f190		488d14da		LEAQ 0(DX)(BX*8), DX	
  0x41f194		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41f19b		0f97c2			SETA DL			
  0x41f19e		84d2			TESTL DL, DL		
  0x41f1a0		0f84f0000000		JE 0x41f296		
  0x41f1a6		31c9			XORL CX, CX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f1a8		4885c9			TESTQ CX, CX		
  0x41f1ab		0f85aa000000		JNE 0x41f25b		
	p := fresh.tryAlloc(bytesNeeded)
  0x41f1b1		90			NOPL			
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f1b2		4885c0			TESTQ AX, AX		
  0x41f1b5		0f8496000000		JE 0x41f251		
  0x41f1bb		488b08			MOVQ 0(AX), CX		
  0x41f1be		488d0cd9		LEAQ 0(CX)(BX*8), CX	
  0x41f1c2		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f1c9		0f97c1			SETA CL			
  0x41f1cc		84c9			TESTL CL, CL		
  0x41f1ce		7449			JE 0x41f219		
  0x41f1d0		31c9			XORL CX, CX		
	if p == nil {
  0x41f1d2		4885c9			TESTQ CX, CX		
  0x41f1d5		0f84d2010000		JE 0x41f3ad		
	p := fresh.tryAlloc(bytesNeeded)
  0x41f1db		48894c2420		MOVQ CX, 0x20(SP)	
	fresh.next = gcBitsArenas.next
  0x41f1e0		488b0da9290a00		MOVQ runtime.gcBitsArenas+16(SB), CX	
  0x41f1e7		48894808		MOVQ CX, 0x8(AX)			
	atomic.StorepNoWB(unsafe.Pointer(&gcBitsArenas.next), unsafe.Pointer(fresh))
  0x41f1eb		488d0d9e290a00		LEAQ runtime.gcBitsArenas+16(SB), CX	
  0x41f1f2		488701			XCHGQ AX, 0(CX)				
	unlock(&gcBitsArenas.lock)
  0x41f1f5		488d0584290a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f1fc		48890424		MOVQ AX, 0(SP)				
  0x41f200		e88b96feff		CALL runtime.unlock(SB)			
	return p
  0x41f205		488b442420		MOVQ 0x20(SP), AX	
  0x41f20a		4889442450		MOVQ AX, 0x50(SP)	
  0x41f20f		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f214		4883c440		ADDQ $0x40, SP		
  0x41f218		c3			RET			
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f219		488b4c2418		MOVQ 0x18(SP), CX	
  0x41f21e		4889ca			MOVQ CX, DX		
  0x41f221		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41f226		488d0cd9		LEAQ 0(CX)(BX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41f22a		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f231		7604			JBE 0x41f237		
  0x41f233		31c9			XORL CX, CX		
	p := fresh.tryAlloc(bytesNeeded)
  0x41f235		eb9b			JMP 0x41f1d2		
	start := end - bytes
  0x41f237		4829d1			SUBQ DX, CX		
	return &b.bits[start]
  0x41f23a		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f241		0f8381010000		JAE 0x41f3c8		
  0x41f247		488d0c08		LEAQ 0(AX)(CX*1), CX	
  0x41f24b		488d4910		LEAQ 0x10(CX), CX	
	p := fresh.tryAlloc(bytesNeeded)
  0x41f24f		eb81			JMP 0x41f1d2		
  0x41f251		b901000000		MOVL $0x1, CX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f256		e971ffffff		JMP 0x41f1cc		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f25b		48894c2428		MOVQ CX, 0x28(SP)	
		fresh.next = gcBitsArenas.free
  0x41f260		488b0d21290a00		MOVQ runtime.gcBitsArenas+8(SB), CX	
  0x41f267		48894808		MOVQ CX, 0x8(AX)			
		gcBitsArenas.free = fresh
  0x41f26b		48890516290a00		MOVQ AX, runtime.gcBitsArenas+8(SB)	
		unlock(&gcBitsArenas.lock)
  0x41f272		488d0507290a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f279		48890424		MOVQ AX, 0(SP)				
  0x41f27d		e80e96feff		CALL runtime.unlock(SB)			
		return p
  0x41f282		488b442428		MOVQ 0x28(SP), AX	
  0x41f287		4889442450		MOVQ AX, 0x50(SP)	
  0x41f28c		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f291		4883c440		ADDQ $0x40, SP		
  0x41f295		c3			RET			
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f296		488b542418		MOVQ 0x18(SP), DX	
  0x41f29b		4889d6			MOVQ DX, SI		
  0x41f29e		f0480fc111		LOCK XADDQ DX, 0(CX)	
  0x41f2a3		488d14da		LEAQ 0(DX)(BX*8), DX	
	if end > uintptr(len(b.bits)) {
  0x41f2a7		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41f2ae		7607			JBE 0x41f2b7		
  0x41f2b0		31c9			XORL CX, CX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f2b2		e9f1feffff		JMP 0x41f1a8		
	start := end - bytes
  0x41f2b7		4829f2			SUBQ SI, DX		
	return &b.bits[start]
  0x41f2ba		4881faf0ff0000		CMPQ $0xfff0, DX	
  0x41f2c1		0f8308010000		JAE 0x41f3cf		
  0x41f2c7		488d0c0a		LEAQ 0(DX)(CX*1), CX	
  0x41f2cb		488d4910		LEAQ 0x10(CX), CX	
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f2cf		e9d4feffff		JMP 0x41f1a8		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f2d4		488b5c2410		MOVQ 0x10(SP), BX	
  0x41f2d9		ba01000000		MOVL $0x1, DX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f2de		e9bbfeffff		JMP 0x41f19e		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f2e3		4889442430		MOVQ AX, 0x30(SP)	
		unlock(&gcBitsArenas.lock)
  0x41f2e8		488d0591280a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f2ef		48890424		MOVQ AX, 0(SP)				
  0x41f2f3		e89895feff		CALL runtime.unlock(SB)			
		return p
  0x41f2f8		488b442430		MOVQ 0x30(SP), AX	
  0x41f2fd		4889442450		MOVQ AX, 0x50(SP)	
  0x41f302		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f307		4883c440		ADDQ $0x40, SP		
  0x41f30b		c3			RET			
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f30c		488b4c2418		MOVQ 0x18(SP), CX	
  0x41f311		4889cb			MOVQ CX, BX		
  0x41f314		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41f319		488d0cd1		LEAQ 0(CX)(DX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41f31d		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f324		7607			JBE 0x41f32d		
  0x41f326		31c0			XORL AX, AX		
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f328		e938feffff		JMP 0x41f165		
	start := end - bytes
  0x41f32d		4829d9			SUBQ BX, CX		
	return &b.bits[start]
  0x41f330		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f337		0f8399000000		JAE 0x41f3d6		
  0x41f33d		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x41f341		488d4010		LEAQ 0x10(AX), AX	
	if p := gcBitsArenas.next.tryAlloc(bytesNeeded); p != nil {
  0x41f345		e91bfeffff		JMP 0x41f165		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f34a		488b542410		MOVQ 0x10(SP), DX	
  0x41f34f		b901000000		MOVL $0x1, CX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f354		e902feffff		JMP 0x41f15b		
		return p
  0x41f359		4889442450		MOVQ AX, 0x50(SP)	
  0x41f35e		488b6c2438		MOVQ 0x38(SP), BP	
  0x41f363		4883c440		ADDQ $0x40, SP		
  0x41f367		c3			RET			
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f368		4889ca			MOVQ CX, DX		
  0x41f36b		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x41f370		488d0cd9		LEAQ 0(CX)(BX*8), CX	
	if end > uintptr(len(b.bits)) {
  0x41f374		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f37b		760a			JBE 0x41f387		
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f37d		4889d1			MOVQ DX, CX		
  0x41f380		31c0			XORL AX, AX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41f382		e98afdffff		JMP 0x41f111		
	start := end - bytes
  0x41f387		4829d1			SUBQ DX, CX		
	return &b.bits[start]
  0x41f38a		4881f9f0ff0000		CMPQ $0xfff0, CX	
  0x41f391		734a			JAE 0x41f3dd		
  0x41f393		488d0408		LEAQ 0(AX)(CX*1), AX	
  0x41f397		488d4010		LEAQ 0x10(AX), AX	
	end := atomic.Xadduintptr(&b.free, bytes)
  0x41f39b		4889d1			MOVQ DX, CX		
	if p := head.tryAlloc(bytesNeeded); p != nil {
  0x41f39e		e96efdffff		JMP 0x41f111		
  0x41f3a3		ba01000000		MOVL $0x1, DX		
	if b == nil || atomic.Loaduintptr(&b.free)+bytes > uintptr(len(b.bits)) {
  0x41f3a8		e953fdffff		JMP 0x41f100		
		throw("markBits overflow")
  0x41f3ad		488d05ff0d0500		LEAQ 0x50dff(IP), AX	
  0x41f3b4		48890424		MOVQ AX, 0(SP)		
  0x41f3b8		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x41f3c1		e8ba400000		CALL runtime.throw(SB)	
  0x41f3c6		0f0b			UD2			
	return &b.bits[start]
  0x41f3c8		e8532b0000		CALL runtime.panicindex(SB)	
  0x41f3cd		0f0b			UD2				
  0x41f3cf		e84c2b0000		CALL runtime.panicindex(SB)	
  0x41f3d4		0f0b			UD2				
  0x41f3d6		e8452b0000		CALL runtime.panicindex(SB)	
  0x41f3db		0f0b			UD2				
  0x41f3dd		e83e2b0000		CALL runtime.panicindex(SB)	
  0x41f3e2		0f0b			UD2				
func newMarkBits(nelems uintptr) *gcBits {
  0x41f3e4		e897840200		CALL runtime.morestack_noctxt(SB)	
  0x41f3e9		e9c2fcffff		JMP runtime.newMarkBits(SB)		

TEXT runtime.nextMarkBitArenaEpoch(SB) /usr/local/go/src/runtime/mheap.go
func nextMarkBitArenaEpoch() {
  0x41f3f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f3f9		483b6110		CMPQ 0x10(CX), SP	
  0x41f3fd		0f86a1000000		JBE 0x41f4a4		
  0x41f403		4883ec10		SUBQ $0x10, SP		
  0x41f407		48896c2408		MOVQ BP, 0x8(SP)	
  0x41f40c		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&gcBitsArenas.lock)
  0x41f411		488d0568270a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f418		48890424		MOVQ AX, 0(SP)				
  0x41f41c		e8bf92feff		CALL runtime.lock(SB)			
	if gcBitsArenas.previous != nil {
  0x41f421		488b0578270a00		MOVQ runtime.gcBitsArenas+32(SB), AX	
  0x41f428		4885c0			TESTQ AX, AX				
  0x41f42b		742c			JE 0x41f459				
		if gcBitsArenas.free == nil {
  0x41f42d		488b0d54270a00		MOVQ runtime.gcBitsArenas+8(SB), CX	
  0x41f434		4885c9			TESTQ CX, CX				
  0x41f437		7505			JNE 0x41f43e				
  0x41f439		eb60			JMP 0x41f49b				
			for last = gcBitsArenas.previous; last.next != nil; last = last.next {
  0x41f43b		4889d0			MOVQ DX, AX		
  0x41f43e		488b5008		MOVQ 0x8(AX), DX	
  0x41f442		4885d2			TESTQ DX, DX		
  0x41f445		75f4			JNE 0x41f43b		
			last.next = gcBitsArenas.free
  0x41f447		48894808		MOVQ CX, 0x8(AX)	
			gcBitsArenas.free = gcBitsArenas.previous
  0x41f44b		488b054e270a00		MOVQ runtime.gcBitsArenas+32(SB), AX	
  0x41f452		4889052f270a00		MOVQ AX, runtime.gcBitsArenas+8(SB)	
	gcBitsArenas.previous = gcBitsArenas.current
  0x41f459		488b0538270a00		MOVQ runtime.gcBitsArenas+24(SB), AX	
  0x41f460		48890539270a00		MOVQ AX, runtime.gcBitsArenas+32(SB)	
	gcBitsArenas.current = gcBitsArenas.next
  0x41f467		488b0522270a00		MOVQ runtime.gcBitsArenas+16(SB), AX	
  0x41f46e		48890523270a00		MOVQ AX, runtime.gcBitsArenas+24(SB)	
	atomic.StorepNoWB(unsafe.Pointer(&gcBitsArenas.next), nil) // newMarkBits calls newArena when needed
  0x41f475		31c0			XORL AX, AX				
  0x41f477		488d0d12270a00		LEAQ runtime.gcBitsArenas+16(SB), CX	
  0x41f47e		488701			XCHGQ AX, 0(CX)				
	unlock(&gcBitsArenas.lock)
  0x41f481		488d05f8260a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f488		48890424		MOVQ AX, 0(SP)				
  0x41f48c		e8ff93feff		CALL runtime.unlock(SB)			
}
  0x41f491		488b6c2408		MOVQ 0x8(SP), BP	
  0x41f496		4883c410		ADDQ $0x10, SP		
  0x41f49a		c3			RET			
			gcBitsArenas.free = gcBitsArenas.previous
  0x41f49b		488905e6260a00		MOVQ AX, runtime.gcBitsArenas+8(SB)	
  0x41f4a2		ebb5			JMP 0x41f459				
func nextMarkBitArenaEpoch() {
  0x41f4a4		e8d7830200		CALL runtime.morestack_noctxt(SB)	
  0x41f4a9		e942ffffff		JMP runtime.nextMarkBitArenaEpoch(SB)	

TEXT runtime.newArenaMayUnlock(SB) /usr/local/go/src/runtime/mheap.go
func newArenaMayUnlock() *gcBitsArena {
  0x41f4b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f4b9		483b6110		CMPQ 0x10(CX), SP	
  0x41f4bd		0f86c9000000		JBE 0x41f58c		
  0x41f4c3		4883ec30		SUBQ $0x30, SP		
  0x41f4c7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41f4cc		488d6c2428		LEAQ 0x28(SP), BP	
	if gcBitsArenas.free == nil {
  0x41f4d1		488b05b0260a00		MOVQ runtime.gcBitsArenas+8(SB), AX	
  0x41f4d8		4885c0			TESTQ AX, AX				
  0x41f4db		7445			JE 0x41f522				
  0x41f4dd		4889442420		MOVQ AX, 0x20(SP)			
		gcBitsArenas.free = gcBitsArenas.free.next
  0x41f4e2		488b4808		MOVQ 0x8(AX), CX			
  0x41f4e6		48890d9b260a00		MOVQ CX, runtime.gcBitsArenas+8(SB)	
		memclrNoHeapPointers(unsafe.Pointer(result), gcBitsChunkBytes)
  0x41f4ed		48890424		MOVQ AX, 0(SP)				
  0x41f4f1		48c744240800000100	MOVQ $0x10000, 0x8(SP)			
  0x41f4fa		e8c1af0200		CALL runtime.memclrNoHeapPointers(SB)	
	result.next = nil
  0x41f4ff		488b442420		MOVQ 0x20(SP), AX	
  0x41f504		48c7400800000000	MOVQ $0x0, 0x8(AX)	
		result.free = 0
  0x41f50c		48c70000000000		MOVQ $0x0, 0(AX)	
	return result
  0x41f513		4889442438		MOVQ AX, 0x38(SP)	
  0x41f518		488b6c2428		MOVQ 0x28(SP), BP	
  0x41f51d		4883c430		ADDQ $0x30, SP		
  0x41f521		c3			RET			
		unlock(&gcBitsArenas.lock)
  0x41f522		488d0557260a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f529		48890424		MOVQ AX, 0(SP)				
  0x41f52d		e85e93feff		CALL runtime.unlock(SB)			
		result = (*gcBitsArena)(sysAlloc(gcBitsChunkBytes, &memstats.gc_sys))
  0x41f532		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x41f53a		488d05b7e70b00		LEAQ runtime.memstats+152(SB), AX	
  0x41f541		4889442408		MOVQ AX, 0x8(SP)			
  0x41f546		e8b51effff		CALL runtime.sysAlloc(SB)		
  0x41f54b		488b442410		MOVQ 0x10(SP), AX			
		if result == nil {
  0x41f550		4885c0			TESTQ AX, AX		
  0x41f553		741c			JE 0x41f571		
		result = (*gcBitsArena)(sysAlloc(gcBitsChunkBytes, &memstats.gc_sys))
  0x41f555		4889442418		MOVQ AX, 0x18(SP)	
		lock(&gcBitsArenas.lock)
  0x41f55a		488d051f260a00		LEAQ runtime.gcBitsArenas(SB), AX	
  0x41f561		48890424		MOVQ AX, 0(SP)				
  0x41f565		e87691feff		CALL runtime.lock(SB)			
	result.next = nil
  0x41f56a		488b442418		MOVQ 0x18(SP), AX	
		lock(&gcBitsArenas.lock)
  0x41f56f		eb93			JMP 0x41f504		
			throw("runtime: cannot allocate memory")
  0x41f571		488d05bb280500		LEAQ 0x528bb(IP), AX	
  0x41f578		48890424		MOVQ AX, 0(SP)		
  0x41f57c		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41f585		e8f63e0000		CALL runtime.throw(SB)	
  0x41f58a		0f0b			UD2			
func newArenaMayUnlock() *gcBitsArena {
  0x41f58c		e8ef820200		CALL runtime.morestack_noctxt(SB)	
  0x41f591		e91affffff		JMP runtime.newArenaMayUnlock(SB)	

TEXT runtime.newBucket(SB) /usr/local/go/src/runtime/mprof.go
func newBucket(typ bucketType, nstk int) *bucket {
  0x41f5a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f5a9		483b6110		CMPQ 0x10(CX), SP	
  0x41f5ad		0f86a8000000		JBE 0x41f65b		
  0x41f5b3		4883ec30		SUBQ $0x30, SP		
  0x41f5b7		48896c2428		MOVQ BP, 0x28(SP)	
  0x41f5bc		488d6c2428		LEAQ 0x28(SP), BP	
	size := unsafe.Sizeof(bucket{}) + uintptr(nstk)*unsafe.Sizeof(uintptr(0))
  0x41f5c1		488b442440		MOVQ 0x40(SP), AX	
  0x41f5c6		48c1e003		SHLQ $0x3, AX		
	case memProfile:
  0x41f5ca		488b542438		MOVQ 0x38(SP), DX	
  0x41f5cf		4883fa01		CMPQ $0x1, DX		
  0x41f5d3		755b			JNE 0x41f630		
		size += unsafe.Sizeof(memRecord{})
  0x41f5d5		4805b0000000		ADDQ $0xb0, AX		
	b := (*bucket)(persistentalloc(size, 0, &memstats.buckhash_sys))
  0x41f5db		4889442420		MOVQ AX, 0x20(SP)			
  0x41f5e0		48890424		MOVQ AX, 0(SP)				
  0x41f5e4		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x41f5ed		488d0dfce60b00		LEAQ runtime.memstats+144(SB), CX	
  0x41f5f4		48894c2410		MOVQ CX, 0x10(SP)			
  0x41f5f9		e872b4feff		CALL runtime.persistentalloc(SB)	
  0x41f5fe		488b442418		MOVQ 0x18(SP), AX			
	bucketmem += size
  0x41f603		488b4c2420		MOVQ 0x20(SP), CX		
  0x41f608		48010d29d70b00		ADDQ CX, runtime.bucketmem(SB)	
	b.typ = typ
  0x41f60f		488b4c2438		MOVQ 0x38(SP), CX	
  0x41f614		48894810		MOVQ CX, 0x10(AX)	
	b.nstk = uintptr(nstk)
  0x41f618		488b4c2440		MOVQ 0x40(SP), CX	
  0x41f61d		48894828		MOVQ CX, 0x28(AX)	
	return b
  0x41f621		4889442448		MOVQ AX, 0x48(SP)	
  0x41f626		488b6c2428		MOVQ 0x28(SP), BP	
  0x41f62b		4883c430		ADDQ $0x30, SP		
  0x41f62f		c3			RET			
	case blockProfile, mutexProfile:
  0x41f630		488d5afe		LEAQ -0x2(DX), BX	
  0x41f634		4883fb01		CMPQ $0x1, BX		
  0x41f638		7706			JA 0x41f640		
		size += unsafe.Sizeof(blockRecord{})
  0x41f63a		4883c040		ADDQ $0x40, AX		
	switch typ {
  0x41f63e		eb9b			JMP 0x41f5db		
		throw("invalid profile bucket type")
  0x41f640		488d05721d0500		LEAQ 0x51d72(IP), AX	
  0x41f647		48890424		MOVQ AX, 0(SP)		
  0x41f64b		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x41f654		e8273e0000		CALL runtime.throw(SB)	
  0x41f659		0f0b			UD2			
func newBucket(typ bucketType, nstk int) *bucket {
  0x41f65b		e820820200		CALL runtime.morestack_noctxt(SB)	
  0x41f660		e93bffffff		JMP runtime.newBucket(SB)		

TEXT runtime.(*bucket).mp(SB) /usr/local/go/src/runtime/mprof.go
func (b *bucket) mp() *memRecord {
  0x41f670		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f679		483b6110		CMPQ 0x10(CX), SP	
  0x41f67d		7651			JBE 0x41f6d0		
  0x41f67f		4883ec18		SUBQ $0x18, SP		
  0x41f683		48896c2410		MOVQ BP, 0x10(SP)	
  0x41f688		488d6c2410		LEAQ 0x10(SP), BP	
	if b.typ != memProfile {
  0x41f68d		488b442420		MOVQ 0x20(SP), AX	
  0x41f692		4883781001		CMPQ $0x1, 0x10(AX)	
  0x41f697		751c			JNE 0x41f6b5		
	data := add(unsafe.Pointer(b), unsafe.Sizeof(*b)+b.nstk*unsafe.Sizeof(uintptr(0)))
  0x41f699		90			NOPL			
  0x41f69a		488b4828		MOVQ 0x28(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x41f69e		488d04c8		LEAQ 0(AX)(CX*8), AX	
  0x41f6a2		488d4030		LEAQ 0x30(AX), AX	
	return (*memRecord)(data)
  0x41f6a6		4889442428		MOVQ AX, 0x28(SP)	
  0x41f6ab		488b6c2410		MOVQ 0x10(SP), BP	
  0x41f6b0		4883c418		ADDQ $0x18, SP		
  0x41f6b4		c3			RET			
		throw("bad use of bucket.mp")
  0x41f6b5		488d053d0f0500		LEAQ 0x50f3d(IP), AX	
  0x41f6bc		48890424		MOVQ AX, 0(SP)		
  0x41f6c0		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41f6c9		e8b23d0000		CALL runtime.throw(SB)	
  0x41f6ce		0f0b			UD2			
func (b *bucket) mp() *memRecord {
  0x41f6d0		e8ab810200		CALL runtime.morestack_noctxt(SB)	
  0x41f6d5		eb99			JMP runtime.(*bucket).mp(SB)		

TEXT runtime.(*bucket).bp(SB) /usr/local/go/src/runtime/mprof.go
func (b *bucket) bp() *blockRecord {
  0x41f6e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f6e9		483b6110		CMPQ 0x10(CX), SP	
  0x41f6ed		765a			JBE 0x41f749		
  0x41f6ef		4883ec18		SUBQ $0x18, SP		
  0x41f6f3		48896c2410		MOVQ BP, 0x10(SP)	
  0x41f6f8		488d6c2410		LEAQ 0x10(SP), BP	
	if b.typ != blockProfile && b.typ != mutexProfile {
  0x41f6fd		488b442420		MOVQ 0x20(SP), AX	
  0x41f702		488b4810		MOVQ 0x10(AX), CX	
  0x41f706		4883f902		CMPQ $0x2, CX		
  0x41f70a		7406			JE 0x41f712		
  0x41f70c		4883f903		CMPQ $0x3, CX		
  0x41f710		751c			JNE 0x41f72e		
	data := add(unsafe.Pointer(b), unsafe.Sizeof(*b)+b.nstk*unsafe.Sizeof(uintptr(0)))
  0x41f712		90			NOPL			
  0x41f713		488b4828		MOVQ 0x28(AX), CX	
	return unsafe.Pointer(uintptr(p) + x)
  0x41f717		488d04c8		LEAQ 0(AX)(CX*8), AX	
  0x41f71b		488d4030		LEAQ 0x30(AX), AX	
	return (*blockRecord)(data)
  0x41f71f		4889442428		MOVQ AX, 0x28(SP)	
  0x41f724		488b6c2410		MOVQ 0x10(SP), BP	
  0x41f729		4883c418		ADDQ $0x18, SP		
  0x41f72d		c3			RET			
		throw("bad use of bucket.bp")
  0x41f72e		488d05b00e0500		LEAQ 0x50eb0(IP), AX	
  0x41f735		48890424		MOVQ AX, 0(SP)		
  0x41f739		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x41f742		e8393d0000		CALL runtime.throw(SB)	
  0x41f747		0f0b			UD2			
func (b *bucket) bp() *blockRecord {
  0x41f749		e832810200		CALL runtime.morestack_noctxt(SB)	
  0x41f74e		eb90			JMP runtime.(*bucket).bp(SB)		

TEXT runtime.stkbucket(SB) /usr/local/go/src/runtime/mprof.go
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41f750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41f759		483b6110		CMPQ 0x10(CX), SP	
  0x41f75d		0f862f030000		JBE 0x41fa92		
  0x41f763		4883ec58		SUBQ $0x58, SP		
  0x41f767		48896c2450		MOVQ BP, 0x50(SP)	
  0x41f76c		488d6c2450		LEAQ 0x50(SP), BP	
	if buckhash == nil {
  0x41f771		48833db7210a0000	CMPQ $0x0, runtime.buckhash(SB)	
  0x41f779		0f8497020000		JE 0x41fa16			
	for _, pc := range stk {
  0x41f77f		488b4c2470		MOVQ 0x70(SP), CX	
  0x41f784		488b542478		MOVQ 0x78(SP), DX	
  0x41f789		31c0			XORL AX, AX		
  0x41f78b		31db			XORL BX, BX		
  0x41f78d		eb1f			JMP 0x41f7ae		
  0x41f78f		488b34c1		MOVQ 0(CX)(AX*8), SI	
  0x41f793		48ffc0			INCQ AX			
		h += pc
  0x41f796		4801de			ADDQ BX, SI		
		h += h << 10
  0x41f799		4889f7			MOVQ SI, DI		
  0x41f79c		48c1e60a		SHLQ $0xa, SI		
  0x41f7a0		488d1c37		LEAQ 0(DI)(SI*1), BX	
		h ^= h >> 6
  0x41f7a4		4889de			MOVQ BX, SI		
  0x41f7a7		48c1eb06		SHRQ $0x6, BX		
  0x41f7ab		4831f3			XORQ SI, BX		
	for _, pc := range stk {
  0x41f7ae		4839d0			CMPQ DX, AX		
  0x41f7b1		7cdc			JL 0x41f78f		
	for b := buckhash[i]; b != nil; b = b.next {
  0x41f7b3		488b3576210a00		MOVQ runtime.buckhash(SB), SI	
  0x41f7ba		8406			TESTB AL, 0(SI)			
	h += size
  0x41f7bc		488b7c2468		MOVQ 0x68(SP), DI	
  0x41f7c1		4801fb			ADDQ DI, BX		
	h += h << 10
  0x41f7c4		4989d8			MOVQ BX, R8		
  0x41f7c7		48c1e30a		SHLQ $0xa, BX		
  0x41f7cb		4c01c3			ADDQ R8, BX		
	h ^= h >> 6
  0x41f7ce		4989d8			MOVQ BX, R8		
  0x41f7d1		48c1eb06		SHRQ $0x6, BX		
  0x41f7d5		4931d8			XORQ BX, R8		
	h += h << 3
  0x41f7d8		4b8d1cc0		LEAQ 0(R8)(R8*8), BX	
	h ^= h >> 11
  0x41f7dc		4989d8			MOVQ BX, R8		
  0x41f7df		48c1eb0b		SHRQ $0xb, BX		
  0x41f7e3		4c31c3			XORQ R8, BX		
	i := int(h % buckHashSize)
  0x41f7e6		48b8921a1953bc1f6aba	MOVQ $0xba6a1fbc53191a92, AX	
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41f7f0		4989d0			MOVQ DX, R8		
	i := int(h % buckHashSize)
  0x41f7f3		48f7e3			MULQ BX			
  0x41f7f6		48c1ea11		SHRQ $0x11, DX		
  0x41f7fa		4869d21fbf0200		IMULQ $0x2bf1f, DX, DX	
  0x41f801		4989d9			MOVQ BX, R9		
  0x41f804		4829d3			SUBQ DX, BX		
	for b := buckhash[i]; b != nil; b = b.next {
  0x41f807		4881fb1fbf0200		CMPQ $0x2bf1f, BX	
  0x41f80e		0f835c020000		JAE 0x41fa70		
	h ^= h >> 11
  0x41f814		4c894c2440		MOVQ R9, 0x40(SP)	
	i := int(h % buckHashSize)
  0x41f819		48895c2438		MOVQ BX, 0x38(SP)	
	for b := buckhash[i]; b != nil; b = b.next {
  0x41f81e		488b04de		MOVQ 0(SI)(BX*8), AX	
  0x41f822		488b542460		MOVQ 0x60(SP), DX	
  0x41f827		eb03			JMP 0x41f82c		
  0x41f829		488b00			MOVQ 0(AX), AX		
  0x41f82c		4885c0			TESTQ AX, AX		
  0x41f82f		0f84ba000000		JE 0x41f8ef		
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f835		48395010		CMPQ DX, 0x10(AX)	
  0x41f839		0f85a9000000		JNE 0x41f8e8		
  0x41f83f		4c394818		CMPQ R9, 0x18(AX)	
  0x41f843		0f8598000000		JNE 0x41f8e1		
  0x41f849		48397820		CMPQ DI, 0x20(AX)	
  0x41f84d		7419			JE 0x41f868		
  0x41f84f		31f6			XORL SI, SI		
  0x41f851		4084f6			TESTL SI, SI		
  0x41f854		74d3			JE 0x41f829		
			return b
  0x41f856		4889842490000000	MOVQ AX, 0x90(SP)	
  0x41f85e		488b6c2450		MOVQ 0x50(SP), BP	
  0x41f863		4883c458		ADDQ $0x58, SP		
  0x41f867		c3			RET			
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f868		90			NOPL			
	stk := (*[maxStack]uintptr)(add(unsafe.Pointer(b), unsafe.Sizeof(*b)))
  0x41f869		90			NOPL			
	return stk[:b.nstk:b.nstk]
  0x41f86a		488b7028		MOVQ 0x28(AX), SI	
  0x41f86e		4885f6			TESTQ SI, SI		
  0x41f871		0f8cf2010000		JL 0x41fa69		
  0x41f877		4883fe20		CMPQ $0x20, SI		
  0x41f87b		0f87e8010000		JA 0x41fa69		
	for b := buckhash[i]; b != nil; b = b.next {
  0x41f881		4889442448		MOVQ AX, 0x48(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x41f886		488d5030		LEAQ 0x30(AX), DX	
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f88a		48891424		MOVQ DX, 0(SP)			
  0x41f88e		4889742408		MOVQ SI, 0x8(SP)		
  0x41f893		4889742410		MOVQ SI, 0x10(SP)		
  0x41f898		48894c2418		MOVQ CX, 0x18(SP)		
  0x41f89d		4c89442420		MOVQ R8, 0x20(SP)		
  0x41f8a2		488b942480000000	MOVQ 0x80(SP), DX		
  0x41f8aa		4889542428		MOVQ DX, 0x28(SP)		
  0x41f8af		e8ec010000		CALL runtime.eqslice(SB)	
  0x41f8b4		0fb6742430		MOVZX 0x30(SP), SI		
	for b := buckhash[i]; b != nil; b = b.next {
  0x41f8b9		488b442448		MOVQ 0x48(SP), AX	
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f8be		488b4c2470		MOVQ 0x70(SP), CX	
  0x41f8c3		488b542460		MOVQ 0x60(SP), DX	
	b.next = buckhash[i]
  0x41f8c8		488b5c2438		MOVQ 0x38(SP), BX	
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f8cd		488b7c2468		MOVQ 0x68(SP), DI	
	b := newBucket(typ, len(stk))
  0x41f8d2		4c8b442478		MOVQ 0x78(SP), R8	
		if b.typ == typ && b.hash == h && b.size == size && eqslice(b.stk(), stk) {
  0x41f8d7		4c8b4c2440		MOVQ 0x40(SP), R9	
  0x41f8dc		e970ffffff		JMP 0x41f851		
  0x41f8e1		31f6			XORL SI, SI		
  0x41f8e3		e969ffffff		JMP 0x41f851		
  0x41f8e8		31f6			XORL SI, SI		
  0x41f8ea		e962ffffff		JMP 0x41f851		
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41f8ef		0fb6842488000000	MOVZX 0x88(SP), AX	
  0x41f8f7		84c0			TESTL AL, AL		
	if !alloc {
  0x41f8f9		0f8401010000		JE 0x41fa00		
	b := newBucket(typ, len(stk))
  0x41f8ff		48891424		MOVQ DX, 0(SP)			
  0x41f903		4c89442408		MOVQ R8, 0x8(SP)		
  0x41f908		e893fcffff		CALL runtime.newBucket(SB)	
  0x41f90d		488b442410		MOVQ 0x10(SP), AX		
	copy(b.stk(), stk)
  0x41f912		90			NOPL			
	stk := (*[maxStack]uintptr)(add(unsafe.Pointer(b), unsafe.Sizeof(*b)))
  0x41f913		90			NOPL			
	return stk[:b.nstk:b.nstk]
  0x41f914		488b4828		MOVQ 0x28(AX), CX	
  0x41f918		4885c9			TESTQ CX, CX		
  0x41f91b		0f8c41010000		JL 0x41fa62		
  0x41f921		4883f920		CMPQ $0x20, CX		
  0x41f925		0f8737010000		JA 0x41fa62		
	copy(b.stk(), stk)
  0x41f92b		488b542478		MOVQ 0x78(SP), DX	
  0x41f930		4839d1			CMPQ DX, CX		
  0x41f933		480f4fca		CMOVG DX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x41f937		488d5030		LEAQ 0x30(AX), DX	
	copy(b.stk(), stk)
  0x41f93b		488b5c2470		MOVQ 0x70(SP), BX	
  0x41f940		4839da			CMPQ BX, DX		
  0x41f943		0f8591000000		JNE 0x41f9da		
	b.hash = h
  0x41f949		488b4c2440		MOVQ 0x40(SP), CX	
  0x41f94e		48894818		MOVQ CX, 0x18(AX)	
	b.size = size
  0x41f952		488b4c2468		MOVQ 0x68(SP), CX	
  0x41f957		48894820		MOVQ CX, 0x20(AX)	
	b.next = buckhash[i]
  0x41f95b		488b0dce1f0a00		MOVQ runtime.buckhash(SB), CX	
  0x41f962		8401			TESTB AL, 0(CX)			
  0x41f964		488b542438		MOVQ 0x38(SP), DX		
  0x41f969		488b0cd1		MOVQ 0(CX)(DX*8), CX		
  0x41f96d		488908			MOVQ CX, 0(AX)			
	buckhash[i] = b
  0x41f970		488b0db91f0a00		MOVQ runtime.buckhash(SB), CX	
  0x41f977		8401			TESTB AL, 0(CX)			
  0x41f979		488904d1		MOVQ AX, 0(CX)(DX*8)		
	if typ == memProfile {
  0x41f97d		488b4c2460		MOVQ 0x60(SP), CX	
  0x41f982		4883f901		CMPQ $0x1, CX		
  0x41f986		7524			JNE 0x41f9ac		
		b.allnext = mbuckets
  0x41f988		488b0de11f0a00		MOVQ runtime.mbuckets(SB), CX	
  0x41f98f		48894808		MOVQ CX, 0x8(AX)		
		mbuckets = b
  0x41f993		488905d61f0a00		MOVQ AX, runtime.mbuckets(SB)	
	return b
  0x41f99a		4889842490000000	MOVQ AX, 0x90(SP)	
  0x41f9a2		488b6c2450		MOVQ 0x50(SP), BP	
  0x41f9a7		4883c458		ADDQ $0x58, SP		
  0x41f9ab		c3			RET			
	} else if typ == mutexProfile {
  0x41f9ac		4883f903		CMPQ $0x3, CX		
  0x41f9b0		7514			JNE 0x41f9c6		
		b.allnext = xbuckets
  0x41f9b2		488b0d07200a00		MOVQ runtime.xbuckets(SB), CX	
  0x41f9b9		48894808		MOVQ CX, 0x8(AX)		
		xbuckets = b
  0x41f9bd		488905fc1f0a00		MOVQ AX, runtime.xbuckets(SB)	
  0x41f9c4		ebd4			JMP 0x41f99a			
		b.allnext = bbuckets
  0x41f9c6		488b0d5b1f0a00		MOVQ runtime.bbuckets(SB), CX	
  0x41f9cd		48894808		MOVQ CX, 0x8(AX)		
		bbuckets = b
  0x41f9d1		488905501f0a00		MOVQ AX, runtime.bbuckets(SB)	
  0x41f9d8		ebc0			JMP 0x41f99a			
	b := newBucket(typ, len(stk))
  0x41f9da		4889442448		MOVQ AX, 0x48(SP)	
	copy(b.stk(), stk)
  0x41f9df		48891424		MOVQ DX, 0(SP)			
  0x41f9e3		48895c2408		MOVQ BX, 0x8(SP)		
  0x41f9e8		48c1e103		SHLQ $0x3, CX			
  0x41f9ec		48894c2410		MOVQ CX, 0x10(SP)		
  0x41f9f1		e85aad0200		CALL runtime.memmove(SB)	
	b.hash = h
  0x41f9f6		488b442448		MOVQ 0x48(SP), AX	
	copy(b.stk(), stk)
  0x41f9fb		e949ffffff		JMP 0x41f949		
		return nil
  0x41fa00		48c784249000000000000000	MOVQ $0x0, 0x90(SP)	
  0x41fa0c		488b6c2450			MOVQ 0x50(SP), BP	
  0x41fa11		4883c458			ADDQ $0x58, SP		
  0x41fa15		c3				RET			
		buckhash = (*[buckHashSize]*bucket)(sysAlloc(unsafe.Sizeof(*buckhash), &memstats.buckhash_sys))
  0x41fa16		48c70424f8f81500	MOVQ $0x15f8f8, 0(SP)			
  0x41fa1e		488d05cbe20b00		LEAQ runtime.memstats+144(SB), AX	
  0x41fa25		4889442408		MOVQ AX, 0x8(SP)			
  0x41fa2a		e8d119ffff		CALL runtime.sysAlloc(SB)		
  0x41fa2f		488b442410		MOVQ 0x10(SP), AX			
  0x41fa34		833de5d30b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x41fa3b		7517			JNE 0x41fa54				
  0x41fa3d		488905ec1e0a00		MOVQ AX, runtime.buckhash(SB)		
		if buckhash == nil {
  0x41fa44		48833de41e0a0000	CMPQ $0x0, runtime.buckhash(SB)	
  0x41fa4c		0f852dfdffff		JNE 0x41f77f			
  0x41fa52		eb23			JMP 0x41fa77			
		buckhash = (*[buckHashSize]*bucket)(sysAlloc(unsafe.Sizeof(*buckhash), &memstats.buckhash_sys))
  0x41fa54		488d3dd51e0a00		LEAQ runtime.buckhash(SB), DI	
  0x41fa5b		e8209c0200		CALL runtime.gcWriteBarrier(SB)	
  0x41fa60		ebe2			JMP 0x41fa44			
	return stk[:b.nstk:b.nstk]
  0x41fa62		e8e9250000		CALL runtime.panicslice(SB)	
  0x41fa67		0f0b			UD2				
  0x41fa69		e8e2250000		CALL runtime.panicslice(SB)	
  0x41fa6e		0f0b			UD2				
	for b := buckhash[i]; b != nil; b = b.next {
  0x41fa70		e8ab240000		CALL runtime.panicindex(SB)	
  0x41fa75		0f0b			UD2				
			throw("runtime: cannot allocate memory")
  0x41fa77		488d05b5230500		LEAQ 0x523b5(IP), AX	
  0x41fa7e		48890424		MOVQ AX, 0(SP)		
  0x41fa82		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x41fa8b		e8f0390000		CALL runtime.throw(SB)	
  0x41fa90		0f0b			UD2			
func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket {
  0x41fa92		e8e97d0200		CALL runtime.morestack_noctxt(SB)	
  0x41fa97		e9b4fcffff		JMP runtime.stkbucket(SB)		

TEXT runtime.eqslice(SB) /usr/local/go/src/runtime/mprof.go
	if len(x) != len(y) {
  0x41faa0		488b442410		MOVQ 0x10(SP), AX	
  0x41faa5		488b4c2428		MOVQ 0x28(SP), CX	
  0x41faaa		4839c8			CMPQ CX, AX		
  0x41faad		752f			JNE 0x41fade		
	for i, xi := range x {
  0x41faaf		488b4c2420		MOVQ 0x20(SP), CX	
  0x41fab4		488b542408		MOVQ 0x8(SP), DX	
  0x41fab9		31db			XORL BX, BX		
  0x41fabb		eb03			JMP 0x41fac0		
  0x41fabd		48ffc3			INCQ BX			
  0x41fac0		4839c3			CMPQ AX, BX		
  0x41fac3		7d13			JGE 0x41fad8		
  0x41fac5		488b34da		MOVQ 0(DX)(BX*8), SI	
		if xi != y[i] {
  0x41fac9		488b3cd9		MOVQ 0(CX)(BX*8), DI	
  0x41facd		4839fe			CMPQ DI, SI		
  0x41fad0		74eb			JE 0x41fabd		
			return false
  0x41fad2		c644243800		MOVB $0x0, 0x38(SP)	
  0x41fad7		c3			RET			
	return true
  0x41fad8		c644243801		MOVB $0x1, 0x38(SP)	
  0x41fadd		c3			RET			
		return false
  0x41fade		c644243800		MOVB $0x0, 0x38(SP)	
  0x41fae3		c3			RET			

TEXT runtime.mProf_NextCycle(SB) /usr/local/go/src/runtime/mprof.go
func mProf_NextCycle() {
  0x41faf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41faf9		483b6110		CMPQ 0x10(CX), SP	
  0x41fafd		7662			JBE 0x41fb61		
  0x41faff		4883ec10		SUBQ $0x10, SP		
  0x41fb03		48896c2408		MOVQ BP, 0x8(SP)	
  0x41fb08		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&proflock)
  0x41fb0d		488d05acd20b00		LEAQ runtime.proflock(SB), AX	
  0x41fb14		48890424		MOVQ AX, 0(SP)			
  0x41fb18		e8c38bfeff		CALL runtime.lock(SB)		
	mProf.cycle = (mProf.cycle + 1) % mProfCycleWrap
  0x41fb1d		8b056dd20b00		MOVL runtime.mProf(SB), AX	
  0x41fb23		ffc0			INCL AX				
  0x41fb25		b9abaaaaaa		MOVL $-0x55555555, CX		
  0x41fb2a		480fafc8		IMULQ AX, CX			
  0x41fb2e		48c1e93a		SHRQ $0x3a, CX			
  0x41fb32		8d0c49			LEAL 0(CX)(CX*2), CX		
  0x41fb35		c1e119			SHLL $0x19, CX			
  0x41fb38		29c8			SUBL CX, AX			
  0x41fb3a		890550d20b00		MOVL AX, runtime.mProf(SB)	
	mProf.flushed = false
  0x41fb40		c6054dd20b0000		MOVB $0x0, runtime.mProf+4(SB)	
	unlock(&proflock)
  0x41fb47		488d0572d20b00		LEAQ runtime.proflock(SB), AX	
  0x41fb4e		48890424		MOVQ AX, 0(SP)			
  0x41fb52		e8398dfeff		CALL runtime.unlock(SB)		
}
  0x41fb57		488b6c2408		MOVQ 0x8(SP), BP	
  0x41fb5c		4883c410		ADDQ $0x10, SP		
  0x41fb60		c3			RET			
func mProf_NextCycle() {
  0x41fb61		e81a7d0200		CALL runtime.morestack_noctxt(SB)	
  0x41fb66		eb88			JMP runtime.mProf_NextCycle(SB)		

TEXT runtime.mProf_Flush(SB) /usr/local/go/src/runtime/mprof.go
func mProf_Flush() {
  0x41fb70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fb79		483b6110		CMPQ 0x10(CX), SP	
  0x41fb7d		764f			JBE 0x41fbce		
  0x41fb7f		4883ec10		SUBQ $0x10, SP		
  0x41fb83		48896c2408		MOVQ BP, 0x8(SP)	
  0x41fb88		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&proflock)
  0x41fb8d		488d052cd20b00		LEAQ runtime.proflock(SB), AX	
  0x41fb94		48890424		MOVQ AX, 0(SP)			
  0x41fb98		e8438bfeff		CALL runtime.lock(SB)		
	if !mProf.flushed {
  0x41fb9d		803df0d10b0000		CMPB $0x0, runtime.mProf+4(SB)	
  0x41fba4		741a			JE 0x41fbc0			
	unlock(&proflock)
  0x41fba6		488d0513d20b00		LEAQ runtime.proflock(SB), AX	
  0x41fbad		48890424		MOVQ AX, 0(SP)			
  0x41fbb1		e8da8cfeff		CALL runtime.unlock(SB)		
}
  0x41fbb6		488b6c2408		MOVQ 0x8(SP), BP	
  0x41fbbb		4883c410		ADDQ $0x10, SP		
  0x41fbbf		c3			RET			
		mProf_FlushLocked()
  0x41fbc0		e81b000000		CALL runtime.mProf_FlushLocked(SB)	
		mProf.flushed = true
  0x41fbc5		c605c8d10b0001		MOVB $0x1, runtime.mProf+4(SB)	
  0x41fbcc		ebd8			JMP 0x41fba6			
func mProf_Flush() {
  0x41fbce		e8ad7c0200		CALL runtime.morestack_noctxt(SB)	
  0x41fbd3		eb9b			JMP runtime.mProf_Flush(SB)		

TEXT runtime.mProf_FlushLocked(SB) /usr/local/go/src/runtime/mprof.go
func mProf_FlushLocked() {
  0x41fbe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fbe9		483b6110		CMPQ 0x10(CX), SP	
  0x41fbed		0f86b9000000		JBE 0x41fcac		
  0x41fbf3		4883ec28		SUBQ $0x28, SP		
  0x41fbf7		48896c2420		MOVQ BP, 0x20(SP)	
  0x41fbfc		488d6c2420		LEAQ 0x20(SP), BP	
	c := mProf.cycle
  0x41fc01		8b0589d10b00		MOVL runtime.mProf(SB), AX	
  0x41fc07		89442414		MOVL AX, 0x14(SP)		
	for b := mbuckets; b != nil; b = b.allnext {
  0x41fc0b		488b0d5e1d0a00		MOVQ runtime.mbuckets(SB), CX	
  0x41fc12		e982000000		JMP 0x41fc99			
  0x41fc17		48894c2418		MOVQ CX, 0x18(SP)		
		mp := b.mp()
  0x41fc1c		48890c24		MOVQ CX, 0(SP)			
  0x41fc20		e84bfaffff		CALL runtime.(*bucket).mp(SB)	
  0x41fc25		488b442408		MOVQ 0x8(SP), AX		
		mpc := &mp.future[c%uint32(len(mp.future))]
  0x41fc2a		b9abaaaaaa		MOVL $-0x55555555, CX	
  0x41fc2f		8b542414		MOVL 0x14(SP), DX	
  0x41fc33		480fafca		IMULQ DX, CX		
  0x41fc37		48c1e921		SHRQ $0x21, CX		
  0x41fc3b		8d0c49			LEAL 0(CX)(CX*2), CX	
  0x41fc3e		89d3			MOVL DX, BX		
  0x41fc40		29ca			SUBL CX, DX		
  0x41fc42		48c1e205		SHLQ $0x5, DX		
		mp.active.add(mpc)
  0x41fc46		90			NOPL			
	a.allocs += b.allocs
  0x41fc47		488b4c1020		MOVQ 0x20(AX)(DX*1), CX	
  0x41fc4c		480108			ADDQ CX, 0(AX)		
	a.frees += b.frees
  0x41fc4f		488b4c1028		MOVQ 0x28(AX)(DX*1), CX	
  0x41fc54		48014808		ADDQ CX, 0x8(AX)	
	a.alloc_bytes += b.alloc_bytes
  0x41fc58		488b4c1030		MOVQ 0x30(AX)(DX*1), CX	
  0x41fc5d		48014810		ADDQ CX, 0x10(AX)	
	a.free_bytes += b.free_bytes
  0x41fc61		488b4c1038		MOVQ 0x38(AX)(DX*1), CX	
  0x41fc66		48014818		ADDQ CX, 0x18(AX)	
		*mpc = memRecordCycle{}
  0x41fc6a		48c744102000000000	MOVQ $0x0, 0x20(AX)(DX*1)	
  0x41fc73		48c744102800000000	MOVQ $0x0, 0x28(AX)(DX*1)	
  0x41fc7c		48c744103000000000	MOVQ $0x0, 0x30(AX)(DX*1)	
  0x41fc85		48c744103800000000	MOVQ $0x0, 0x38(AX)(DX*1)	
	for b := mbuckets; b != nil; b = b.allnext {
  0x41fc8e		488b442418		MOVQ 0x18(SP), AX	
  0x41fc93		488b4808		MOVQ 0x8(AX), CX	
		mpc := &mp.future[c%uint32(len(mp.future))]
  0x41fc97		89d8			MOVL BX, AX		
	for b := mbuckets; b != nil; b = b.allnext {
  0x41fc99		4885c9			TESTQ CX, CX		
  0x41fc9c		0f8575ffffff		JNE 0x41fc17		
  0x41fca2		488b6c2420		MOVQ 0x20(SP), BP	
  0x41fca7		4883c428		ADDQ $0x28, SP		
  0x41fcab		c3			RET			
func mProf_FlushLocked() {
  0x41fcac		e8cf7b0200		CALL runtime.morestack_noctxt(SB)	
  0x41fcb1		e92affffff		JMP runtime.mProf_FlushLocked(SB)	

TEXT runtime.mProf_Malloc(SB) /usr/local/go/src/runtime/mprof.go
func mProf_Malloc(p unsafe.Pointer, size uintptr) {
  0x41fcc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fcc9		488d842410ffffff	LEAQ 0xffffff10(SP), AX	
  0x41fcd1		483b4110		CMPQ 0x10(CX), AX	
  0x41fcd5		0f86a8010000		JBE 0x41fe83		
  0x41fcdb		4881ec70010000		SUBQ $0x170, SP		
  0x41fce2		4889ac2468010000	MOVQ BP, 0x168(SP)	
  0x41fcea		488dac2468010000	LEAQ 0x168(SP), BP	
	var stk [maxStack]uintptr
  0x41fcf2		488d7c2448		LEAQ 0x48(SP), DI	
  0x41fcf7		0f57c0			XORPS X0, X0		
  0x41fcfa		48896c24f0		MOVQ BP, -0x10(SP)	
  0x41fcff		488d6c24f0		LEAQ -0x10(SP), BP	
  0x41fd04		e8cba30200		CALL 0x44a0d4		
  0x41fd09		488b6d00		MOVQ 0(BP), BP		
	nstk := callers(4, stk[:])
  0x41fd0d		48c7042404000000	MOVQ $0x4, 0(SP)		
  0x41fd15		488d442448		LEAQ 0x48(SP), AX		
  0x41fd1a		4889442408		MOVQ AX, 0x8(SP)		
  0x41fd1f		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x41fd28		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x41fd31		e8fa070200		CALL runtime.callers(SB)	
  0x41fd36		488b442420		MOVQ 0x20(SP), AX		
  0x41fd3b		4889442440		MOVQ AX, 0x40(SP)		
	lock(&proflock)
  0x41fd40		488d0d79d00b00		LEAQ runtime.proflock(SB), CX	
  0x41fd47		48890c24		MOVQ CX, 0(SP)			
  0x41fd4b		e89089feff		CALL runtime.lock(SB)		
	b := stkbucket(memProfile, size, stk[:nstk], true)
  0x41fd50		488b442440		MOVQ 0x40(SP), AX		
  0x41fd55		4885c0			TESTQ AX, AX			
  0x41fd58		0f8c1e010000		JL 0x41fe7c			
  0x41fd5e		4883f820		CMPQ $0x20, AX			
  0x41fd62		0f8714010000		JA 0x41fe7c			
  0x41fd68		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x41fd70		488b8c2480010000	MOVQ 0x180(SP), CX		
  0x41fd78		48894c2408		MOVQ CX, 0x8(SP)		
  0x41fd7d		488d542448		LEAQ 0x48(SP), DX		
  0x41fd82		4889542410		MOVQ DX, 0x10(SP)		
  0x41fd87		4889442418		MOVQ AX, 0x18(SP)		
  0x41fd8c		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x41fd95		c644242801		MOVB $0x1, 0x28(SP)		
  0x41fd9a		e8b1f9ffff		CALL runtime.stkbucket(SB)	
  0x41fd9f		488b442430		MOVQ 0x30(SP), AX		
  0x41fda4		4889842448010000	MOVQ AX, 0x148(SP)		
	c := mProf.cycle
  0x41fdac		8b0ddecf0b00		MOVL runtime.mProf(SB), CX	
  0x41fdb2		894c243c		MOVL CX, 0x3c(SP)		
	mp := b.mp()
  0x41fdb6		48890424		MOVQ AX, 0(SP)			
  0x41fdba		e8b1f8ffff		CALL runtime.(*bucket).mp(SB)	
  0x41fdbf		488b442408		MOVQ 0x8(SP), AX		
	mpc := &mp.future[(c+2)%uint32(len(mp.future))]
  0x41fdc4		8400			TESTB AL, 0(AX)		
  0x41fdc6		8b4c243c		MOVL 0x3c(SP), CX	
  0x41fdca		83c102			ADDL $0x2, CX		
  0x41fdcd		baabaaaaaa		MOVL $-0x55555555, DX	
  0x41fdd2		480fafd1		IMULQ CX, DX		
  0x41fdd6		48c1ea21		SHRQ $0x21, DX		
  0x41fdda		8d1452			LEAL 0(DX)(DX*2), DX	
  0x41fddd		29d1			SUBL DX, CX		
  0x41fddf		48c1e105		SHLQ $0x5, CX		
	mpc.allocs++
  0x41fde3		488b540820		MOVQ 0x20(AX)(CX*1), DX	
  0x41fde8		48ffc2			INCQ DX			
  0x41fdeb		4889540820		MOVQ DX, 0x20(AX)(CX*1)	
	mpc.alloc_bytes += size
  0x41fdf0		488b540830		MOVQ 0x30(AX)(CX*1), DX	
  0x41fdf5		488b9c2480010000	MOVQ 0x180(SP), BX	
  0x41fdfd		4801da			ADDQ BX, DX		
  0x41fe00		4889540830		MOVQ DX, 0x30(AX)(CX*1)	
	unlock(&proflock)
  0x41fe05		488d05b4cf0b00		LEAQ runtime.proflock(SB), AX	
  0x41fe0c		48890424		MOVQ AX, 0(SP)			
  0x41fe10		e87b8afeff		CALL runtime.unlock(SB)		
	systemstack(func() {
  0x41fe15		0f57c0				XORPS X0, X0				
  0x41fe18		0f11842450010000		MOVUPS X0, 0x150(SP)			
  0x41fe20		48c784246001000000000000	MOVQ $0x0, 0x160(SP)			
  0x41fe2c		488d05fd5d0200			LEAQ runtime.mProf_Malloc.func1(SB), AX	
  0x41fe33		4889842450010000		MOVQ AX, 0x150(SP)			
  0x41fe3b		488b842478010000		MOVQ 0x178(SP), AX			
  0x41fe43		4889842458010000		MOVQ AX, 0x158(SP)			
  0x41fe4b		488b842448010000		MOVQ 0x148(SP), AX			
  0x41fe53		4889842460010000		MOVQ AX, 0x160(SP)			
  0x41fe5b		488d842450010000		LEAQ 0x150(SP), AX			
  0x41fe63		48890424			MOVQ AX, 0(SP)				
  0x41fe67		e8c4780200			CALL runtime.systemstack(SB)		
}
  0x41fe6c		488bac2468010000	MOVQ 0x168(SP), BP	
  0x41fe74		4881c470010000		ADDQ $0x170, SP		
  0x41fe7b		c3			RET			
	b := stkbucket(memProfile, size, stk[:nstk], true)
  0x41fe7c		e8cf210000		CALL runtime.panicslice(SB)	
  0x41fe81		0f0b			UD2				
func mProf_Malloc(p unsafe.Pointer, size uintptr) {
  0x41fe83		e8f8790200		CALL runtime.morestack_noctxt(SB)	
  0x41fe88		e933feffff		JMP runtime.mProf_Malloc(SB)		

TEXT runtime.mProf_Free(SB) /usr/local/go/src/runtime/mprof.go
func mProf_Free(b *bucket, size uintptr) {
  0x41fe90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41fe99		483b6110		CMPQ 0x10(CX), SP	
  0x41fe9d		0f8692000000		JBE 0x41ff35		
  0x41fea3		4883ec20		SUBQ $0x20, SP		
  0x41fea7		48896c2418		MOVQ BP, 0x18(SP)	
  0x41feac		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&proflock)
  0x41feb1		488d0508cf0b00		LEAQ runtime.proflock(SB), AX	
  0x41feb8		48890424		MOVQ AX, 0(SP)			
  0x41febc		e81f88feff		CALL runtime.lock(SB)		
	c := mProf.cycle
  0x41fec1		8b05c9ce0b00		MOVL runtime.mProf(SB), AX	
  0x41fec7		89442414		MOVL AX, 0x14(SP)		
	mp := b.mp()
  0x41fecb		488b4c2428		MOVQ 0x28(SP), CX		
  0x41fed0		48890c24		MOVQ CX, 0(SP)			
  0x41fed4		e897f7ffff		CALL runtime.(*bucket).mp(SB)	
  0x41fed9		488b442408		MOVQ 0x8(SP), AX		
	mpc := &mp.future[(c+1)%uint32(len(mp.future))]
  0x41fede		8400			TESTB AL, 0(AX)		
  0x41fee0		8b4c2414		MOVL 0x14(SP), CX	
  0x41fee4		ffc1			INCL CX			
  0x41fee6		baabaaaaaa		MOVL $-0x55555555, DX	
  0x41feeb		480fafd1		IMULQ CX, DX		
  0x41feef		48c1ea21		SHRQ $0x21, DX		
  0x41fef3		8d1452			LEAL 0(DX)(DX*2), DX	
  0x41fef6		29d1			SUBL DX, CX		
  0x41fef8		48c1e105		SHLQ $0x5, CX		
	mpc.frees++
  0x41fefc		488b540828		MOVQ 0x28(AX)(CX*1), DX	
  0x41ff01		48ffc2			INCQ DX			
  0x41ff04		4889540828		MOVQ DX, 0x28(AX)(CX*1)	
	mpc.free_bytes += size
  0x41ff09		488b540838		MOVQ 0x38(AX)(CX*1), DX	
  0x41ff0e		488b5c2430		MOVQ 0x30(SP), BX	
  0x41ff13		4801da			ADDQ BX, DX		
  0x41ff16		4889540838		MOVQ DX, 0x38(AX)(CX*1)	
	unlock(&proflock)
  0x41ff1b		488d059ece0b00		LEAQ runtime.proflock(SB), AX	
  0x41ff22		48890424		MOVQ AX, 0(SP)			
  0x41ff26		e86589feff		CALL runtime.unlock(SB)		
}
  0x41ff2b		488b6c2418		MOVQ 0x18(SP), BP	
  0x41ff30		4883c420		ADDQ $0x20, SP		
  0x41ff34		c3			RET			
func mProf_Free(b *bucket, size uintptr) {
  0x41ff35		e846790200		CALL runtime.morestack_noctxt(SB)	
  0x41ff3a		e951ffffff		JMP runtime.mProf_Free(SB)		

TEXT runtime.blockevent(SB) /usr/local/go/src/runtime/mprof.go
func blockevent(cycles int64, skip int) {
  0x41ff40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x41ff49		483b6110		CMPQ 0x10(CX), SP	
  0x41ff4d		7664			JBE 0x41ffb3		
  0x41ff4f		4883ec20		SUBQ $0x20, SP		
  0x41ff53		48896c2418		MOVQ BP, 0x18(SP)	
  0x41ff58		488d6c2418		LEAQ 0x18(SP), BP	
	if cycles <= 0 {
  0x41ff5d		488b442428		MOVQ 0x28(SP), AX	
  0x41ff62		4885c0			TESTQ AX, AX		
	if blocksampled(cycles) {
  0x41ff65		b901000000		MOVL $0x1, CX			
  0x41ff6a		480f4ec1		CMOVLE CX, AX			
  0x41ff6e		4889442428		MOVQ AX, 0x28(SP)		
  0x41ff73		48890424		MOVQ AX, 0(SP)			
  0x41ff77		e844000000		CALL runtime.blocksampled(SB)	
  0x41ff7c		807c240800		CMPB $0x0, 0x8(SP)		
	if cycles <= 0 {
  0x41ff81		750a			JNE 0x41ff8d		
  0x41ff83		488b6c2418		MOVQ 0x18(SP), BP	
  0x41ff88		4883c420		ADDQ $0x20, SP		
  0x41ff8c		c3			RET			
		saveblockevent(cycles, skip+1, blockProfile)
  0x41ff8d		488b442428		MOVQ 0x28(SP), AX		
  0x41ff92		48890424		MOVQ AX, 0(SP)			
  0x41ff96		488b442430		MOVQ 0x30(SP), AX		
  0x41ff9b		48ffc0			INCQ AX				
  0x41ff9e		4889442408		MOVQ AX, 0x8(SP)		
  0x41ffa3		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x41ffac		e89f000000		CALL runtime.saveblockevent(SB)	
  0x41ffb1		ebd0			JMP 0x41ff83			
func blockevent(cycles int64, skip int) {
  0x41ffb3		e8c8780200		CALL runtime.morestack_noctxt(SB)	
  0x41ffb8		eb86			JMP runtime.blockevent(SB)		

TEXT runtime.blocksampled(SB) /usr/local/go/src/runtime/mprof.go
	rate := int64(atomic.Load64(&blockprofilerate))
  0x41ffc0		488b0d69cd0b00		MOVQ runtime.blockprofilerate(SB), CX	
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41ffc7		4885c9			TESTQ CX, CX		
  0x41ffca		7f15			JG 0x41ffe1		
  0x41ffcc		b801000000		MOVL $0x1, AX		
  0x41ffd1		84c0			TESTL AL, AL		
  0x41ffd3		7406			JE 0x41ffdb		
		return false
  0x41ffd5		c644241000		MOVB $0x0, 0x10(SP)	
  0x41ffda		c3			RET			
	return true
  0x41ffdb		c644241001		MOVB $0x1, 0x10(SP)	
  0x41ffe0		c3			RET			
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x41ffe1		488b542408		MOVQ 0x8(SP), DX	
  0x41ffe6		4839d1			CMPQ DX, CX		
  0x41ffe9		7e5a			JLE 0x420045		
	mp := getg().m
  0x41ffeb		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x41fff4		488b5b30		MOVQ 0x30(BX), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x41fff8		8bb320010000		MOVL 0x120(BX), SI	
  0x41fffe		8bbb24010000		MOVL 0x124(BX), DI	
	s1 ^= s1 << 17
  0x420004		4189f0			MOVL SI, R8		
  0x420007		c1e611			SHLL $0x11, SI		
  0x42000a		4431c6			XORL R8, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x42000d		4189f8			MOVL DI, R8		
  0x420010		31f7			XORL SI, DI		
  0x420012		c1ee07			SHRL $0x7, SI		
  0x420015		31fe			XORL DI, SI		
  0x420017		4489c7			MOVL R8, DI		
  0x42001a		41c1e810		SHRL $0x10, R8		
  0x42001e		4131f0			XORL SI, R8		
	return s0 + s1
  0x420021		428d0407		LEAL 0(DI)(R8*1), AX	
func blocksampled(cycles int64) bool {
  0x420025		4889d6			MOVQ DX, SI		
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x420028		4899			CQO			
  0x42002a		48f7f9			IDIVQ CX		
  0x42002d		90			NOPL			
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x42002e		89bb20010000		MOVL DI, 0x120(BX)	
  0x420034		44898324010000		MOVL R8, 0x124(BX)	
	if rate <= 0 || (rate > cycles && int64(fastrand())%rate > cycles) {
  0x42003b		4839f2			CMPQ SI, DX		
  0x42003e		0f9fc1			SETG CL			
  0x420041		89c8			MOVL CX, AX		
  0x420043		eb8c			JMP 0x41ffd1		
  0x420045		31c9			XORL CX, CX		
  0x420047		ebf8			JMP 0x420041		

TEXT runtime.saveblockevent(SB) /usr/local/go/src/runtime/mprof.go
func saveblockevent(cycles int64, skip int, which bucketType) {
  0x420050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420059		488d842430ffffff	LEAQ 0xffffff30(SP), AX	
  0x420061		483b4110		CMPQ 0x10(CX), AX	
  0x420065		0f868d010000		JBE 0x4201f8		
  0x42006b		4881ec50010000		SUBQ $0x150, SP		
  0x420072		4889ac2448010000	MOVQ BP, 0x148(SP)	
  0x42007a		488dac2448010000	LEAQ 0x148(SP), BP	
	gp := getg()
  0x420082		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	var stk [maxStack]uintptr
  0x42008b		488d7c2440		LEAQ 0x40(SP), DI	
  0x420090		0f57c0			XORPS X0, X0		
  0x420093		48896c24f0		MOVQ BP, -0x10(SP)	
  0x420098		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42009d		e832a00200		CALL 0x44a0d4		
  0x4200a2		488b6d00		MOVQ 0(BP), BP		
	if gp.m.curg == nil || gp.m.curg == gp {
  0x4200a6		488b4830		MOVQ 0x30(AX), CX	
  0x4200aa		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x4200b1		4885c9			TESTQ CX, CX		
  0x4200b4		7409			JE 0x4200bf		
  0x4200b6		4839c1			CMPQ AX, CX		
  0x4200b9		0f85f6000000		JNE 0x4201b5		
		nstk = callers(skip, stk[:])
  0x4200bf		488b842460010000	MOVQ 0x160(SP), AX		
  0x4200c7		48890424		MOVQ AX, 0(SP)			
  0x4200cb		488d442440		LEAQ 0x40(SP), AX		
  0x4200d0		4889442408		MOVQ AX, 0x8(SP)		
  0x4200d5		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x4200de		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x4200e7		e844040200		CALL runtime.callers(SB)	
  0x4200ec		488b442420		MOVQ 0x20(SP), AX		
	b := stkbucket(which, 0, stk[:nstk], true)
  0x4200f1		4889442438		MOVQ AX, 0x38(SP)	
	lock(&proflock)
  0x4200f6		488d0dc3cc0b00		LEAQ runtime.proflock(SB), CX	
  0x4200fd		48890c24		MOVQ CX, 0(SP)			
  0x420101		e8da85feff		CALL runtime.lock(SB)		
	b := stkbucket(which, 0, stk[:nstk], true)
  0x420106		488b442438		MOVQ 0x38(SP), AX		
  0x42010b		4885c0			TESTQ AX, AX			
  0x42010e		0f8cdd000000		JL 0x4201f1			
  0x420114		4883f820		CMPQ $0x20, AX			
  0x420118		0f87d3000000		JA 0x4201f1			
  0x42011e		488b8c2468010000	MOVQ 0x168(SP), CX		
  0x420126		48890c24		MOVQ CX, 0(SP)			
  0x42012a		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x420133		488d4c2440		LEAQ 0x40(SP), CX		
  0x420138		48894c2410		MOVQ CX, 0x10(SP)		
  0x42013d		4889442418		MOVQ AX, 0x18(SP)		
  0x420142		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x42014b		c644242801		MOVB $0x1, 0x28(SP)		
  0x420150		e8fbf5ffff		CALL runtime.stkbucket(SB)	
  0x420155		488b442430		MOVQ 0x30(SP), AX		
  0x42015a		4889842440010000	MOVQ AX, 0x140(SP)		
	b.bp().count++
  0x420162		48890424		MOVQ AX, 0(SP)			
  0x420166		e875f5ffff		CALL runtime.(*bucket).bp(SB)	
  0x42016b		488b442408		MOVQ 0x8(SP), AX		
  0x420170		48ff00			INCQ 0(AX)			
	b.bp().cycles += cycles
  0x420173		488b842440010000	MOVQ 0x140(SP), AX		
  0x42017b		48890424		MOVQ AX, 0(SP)			
  0x42017f		e85cf5ffff		CALL runtime.(*bucket).bp(SB)	
  0x420184		488b442408		MOVQ 0x8(SP), AX		
  0x420189		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x420191		48014808		ADDQ CX, 0x8(AX)		
	unlock(&proflock)
  0x420195		488d0524cc0b00		LEAQ runtime.proflock(SB), AX	
  0x42019c		48890424		MOVQ AX, 0(SP)			
  0x4201a0		e8eb86feff		CALL runtime.unlock(SB)		
}
  0x4201a5		488bac2448010000	MOVQ 0x148(SP), BP	
  0x4201ad		4881c450010000		ADDQ $0x150, SP		
  0x4201b4		c3			RET			
		nstk = gcallers(gp.m.curg, skip, stk[:])
  0x4201b5		48890c24		MOVQ CX, 0(SP)			
  0x4201b9		488b842460010000	MOVQ 0x160(SP), AX		
  0x4201c1		4889442408		MOVQ AX, 0x8(SP)		
  0x4201c6		488d442440		LEAQ 0x40(SP), AX		
  0x4201cb		4889442410		MOVQ AX, 0x10(SP)		
  0x4201d0		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x4201d9		48c744242020000000	MOVQ $0x20, 0x20(SP)		
  0x4201e2		e829040200		CALL runtime.gcallers(SB)	
  0x4201e7		488b442428		MOVQ 0x28(SP), AX		
  0x4201ec		e900ffffff		JMP 0x4200f1			
	b := stkbucket(which, 0, stk[:nstk], true)
  0x4201f1		e85a1e0000		CALL runtime.panicslice(SB)	
  0x4201f6		0f0b			UD2				
func saveblockevent(cycles int64, skip int, which bucketType) {
  0x4201f8		e883760200		CALL runtime.morestack_noctxt(SB)	
  0x4201fd		e94efeffff		JMP runtime.saveblockevent(SB)		

TEXT sync.event(SB) /usr/local/go/src/runtime/mprof.go
func mutexevent(cycles int64, skip int) {
  0x420210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420219		483b6110		CMPQ 0x10(CX), SP	
  0x42021d		0f86bb000000		JBE 0x4202de		
  0x420223		4883ec20		SUBQ $0x20, SP		
  0x420227		48896c2418		MOVQ BP, 0x18(SP)	
  0x42022c		488d6c2418		LEAQ 0x18(SP), BP	
	rate := int64(atomic.Load64(&mutexprofilerate))
  0x420231		488b0d60cb0b00		MOVQ runtime.mutexprofilerate(SB), CX	
	if cycles < 0 {
  0x420238		488b542428		MOVQ 0x28(SP), DX	
  0x42023d		4885d2			TESTQ DX, DX		
		saveblockevent(cycles, skip+1, mutexProfile)
  0x420240		bb00000000		MOVL $0x0, BX		
  0x420245		480f4cd3		CMOVL BX, DX		
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x420249		4885c9			TESTQ CX, CX		
	if cycles < 0 {
  0x42024c		0f8e85000000		JLE 0x4202d7		
	mp := getg().m
  0x420252		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x42025b		488b5b30		MOVQ 0x30(BX), BX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x42025f		8bb320010000		MOVL 0x120(BX), SI	
  0x420265		8bbb24010000		MOVL 0x124(BX), DI	
	s1 ^= s1 << 17
  0x42026b		4189f0			MOVL SI, R8		
  0x42026e		c1e611			SHLL $0x11, SI		
  0x420271		4431c6			XORL R8, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x420274		4189f8			MOVL DI, R8		
  0x420277		31f7			XORL SI, DI		
  0x420279		c1ee07			SHRL $0x7, SI		
  0x42027c		31fe			XORL DI, SI		
  0x42027e		4489c7			MOVL R8, DI		
  0x420281		41c1e810		SHRL $0x10, R8		
  0x420285		4131f0			XORL SI, R8		
	return s0 + s1
  0x420288		428d0407		LEAL 0(DI)(R8*1), AX	
		saveblockevent(cycles, skip+1, mutexProfile)
  0x42028c		4889d6			MOVQ DX, SI		
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x42028f		4899			CQO			
  0x420291		48f7f9			IDIVQ CX		
  0x420294		90			NOPL			
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x420295		89bb20010000		MOVL DI, 0x120(BX)	
  0x42029b		44898324010000		MOVL R8, 0x124(BX)	
	if rate > 0 && int64(fastrand())%rate == 0 {
  0x4202a2		4885d2			TESTQ DX, DX		
  0x4202a5		0f94c1			SETE CL			
  0x4202a8		84c9			TESTL CL, CL		
  0x4202aa		750a			JNE 0x4202b6		
  0x4202ac		488b6c2418		MOVQ 0x18(SP), BP	
  0x4202b1		4883c420		ADDQ $0x20, SP		
  0x4202b5		c3			RET			
		saveblockevent(cycles, skip+1, mutexProfile)
  0x4202b6		48893424		MOVQ SI, 0(SP)			
  0x4202ba		488b442430		MOVQ 0x30(SP), AX		
  0x4202bf		48ffc0			INCQ AX				
  0x4202c2		4889442408		MOVQ AX, 0x8(SP)		
  0x4202c7		48c744241003000000	MOVQ $0x3, 0x10(SP)		
  0x4202d0		e87bfdffff		CALL runtime.saveblockevent(SB)	
  0x4202d5		ebd5			JMP 0x4202ac			
  0x4202d7		4889d6			MOVQ DX, SI			
  0x4202da		31c9			XORL CX, CX			
	if cycles < 0 {
  0x4202dc		ebca			JMP 0x4202a8		
func mutexevent(cycles int64, skip int) {
  0x4202de		e89d750200		CALL runtime.morestack_noctxt(SB)	
  0x4202e3		e928ffffff		JMP sync.event(SB)			

TEXT runtime.tracealloc(SB) /usr/local/go/src/runtime/mprof.go
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type) {
  0x4202f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4202f9		483b6110		CMPQ 0x10(CX), SP	
  0x4202fd		0f865e020000		JBE 0x420561		
  0x420303		4883ec60		SUBQ $0x60, SP		
  0x420307		48896c2458		MOVQ BP, 0x58(SP)	
  0x42030c		488d6c2458		LEAQ 0x58(SP), BP	
	lock(&tracelock)
  0x420311		488d05e8ca0b00		LEAQ runtime.tracelock(SB), AX	
  0x420318		48890424		MOVQ AX, 0(SP)			
  0x42031c		e8bf83feff		CALL runtime.lock(SB)		
	gp := getg()
  0x420321		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42032a		4889442428		MOVQ AX, 0x28(SP)	
	gp.m.traceback = 2
  0x42032f		488b4830		MOVQ 0x30(AX), CX	
  0x420333		c6812901000002		MOVB $0x2, 0x129(CX)	
	if typ == nil {
  0x42033a		488b4c2478		MOVQ 0x78(SP), CX	
  0x42033f		4885c9			TESTQ CX, CX		
  0x420342		0f84a3010000		JE 0x4204eb		
		print("tracealloc(", p, ", ", hex(size), ", ", typ.string(), ")\n")
  0x420348		48890c24		MOVQ CX, 0(SP)				
  0x42034c		e89f130200		CALL runtime.(*_type).string(SB)	
  0x420351		488b442410		MOVQ 0x10(SP), AX			
  0x420356		4889442420		MOVQ AX, 0x20(SP)			
  0x42035b		488b4c2408		MOVQ 0x8(SP), CX			
  0x420360		48894c2430		MOVQ CX, 0x30(SP)			
  0x420365		e8563b0000		CALL runtime.printlock(SB)		
  0x42036a		488d05faf50400		LEAQ 0x4f5fa(IP), AX			
  0x420371		48890424		MOVQ AX, 0(SP)				
  0x420375		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42037e		e86d440000		CALL runtime.printstring(SB)		
  0x420383		488b442468		MOVQ 0x68(SP), AX			
  0x420388		48890424		MOVQ AX, 0(SP)				
  0x42038c		e81f440000		CALL runtime.printpointer(SB)		
  0x420391		488d0504ed0400		LEAQ 0x4ed04(IP), AX			
  0x420398		48890424		MOVQ AX, 0(SP)				
  0x42039c		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x4203a5		e846440000		CALL runtime.printstring(SB)		
  0x4203aa		488b442470		MOVQ 0x70(SP), AX			
  0x4203af		48890424		MOVQ AX, 0(SP)				
  0x4203b3		e8f8420000		CALL runtime.printhex(SB)		
  0x4203b8		488d05ddec0400		LEAQ 0x4ecdd(IP), AX			
  0x4203bf		48890424		MOVQ AX, 0(SP)				
  0x4203c3		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x4203cc		e81f440000		CALL runtime.printstring(SB)		
  0x4203d1		488b442430		MOVQ 0x30(SP), AX			
  0x4203d6		48890424		MOVQ AX, 0(SP)				
  0x4203da		488b442420		MOVQ 0x20(SP), AX			
  0x4203df		4889442408		MOVQ AX, 0x8(SP)			
  0x4203e4		e807440000		CALL runtime.printstring(SB)		
  0x4203e9		488d05aaec0400		LEAQ 0x4ecaa(IP), AX			
  0x4203f0		48890424		MOVQ AX, 0(SP)				
  0x4203f4		48c744240802000000	MOVQ $0x2, 0x8(SP)			
  0x4203fd		e8ee430000		CALL runtime.printstring(SB)		
  0x420402		e8393b0000		CALL runtime.printunlock(SB)		
	if gp.m.curg == nil || gp == gp.m.curg {
  0x420407		488b442428		MOVQ 0x28(SP), AX	
  0x42040c		488b4830		MOVQ 0x30(AX), CX	
  0x420410		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x420417		4885c9			TESTQ CX, CX		
  0x42041a		7409			JE 0x420425		
  0x42041c		4839c8			CMPQ CX, AX		
  0x42041f		0f8587000000		JNE 0x4204ac		
		goroutineheader(gp)
  0x420425		48890424		MOVQ AX, 0(SP)				
  0x420429		e862050200		CALL runtime.goroutineheader(SB)	
		systemstack(func() {
  0x42042e		0f57c0			XORPS X0, X0				
  0x420431		0f11442438		MOVUPS X0, 0x38(SP)			
  0x420436		0f11442448		MOVUPS X0, 0x48(SP)			
  0x42043b		488d053e580200		LEAQ runtime.tracealloc.func1(SB), AX	
  0x420442		4889442438		MOVQ AX, 0x38(SP)			
  0x420447		488b442460		MOVQ 0x60(SP), AX			
  0x42044c		4889442440		MOVQ AX, 0x40(SP)			
  0x420451		488d442468		LEAQ 0x68(SP), AX			
  0x420456		4889442448		MOVQ AX, 0x48(SP)			
  0x42045b		488b442428		MOVQ 0x28(SP), AX			
  0x420460		4889442450		MOVQ AX, 0x50(SP)			
  0x420465		488d4c2438		LEAQ 0x38(SP), CX			
  0x42046a		48890c24		MOVQ CX, 0(SP)				
  0x42046e		e8bd720200		CALL runtime.systemstack(SB)		
	print("\n")
  0x420473		e8483a0000		CALL runtime.printlock(SB)	
  0x420478		e8d33c0000		CALL runtime.printnl(SB)	
  0x42047d		e8be3a0000		CALL runtime.printunlock(SB)	
	gp.m.traceback = 0
  0x420482		488b442428		MOVQ 0x28(SP), AX	
  0x420487		488b4030		MOVQ 0x30(AX), AX	
  0x42048b		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x420492		488d0567c90b00		LEAQ runtime.tracelock(SB), AX	
  0x420499		48890424		MOVQ AX, 0(SP)			
  0x42049d		e8ee83feff		CALL runtime.unlock(SB)		
}
  0x4204a2		488b6c2458		MOVQ 0x58(SP), BP	
  0x4204a7		4883c460		ADDQ $0x60, SP		
  0x4204ab		c3			RET			
		goroutineheader(gp.m.curg)
  0x4204ac		48890c24		MOVQ CX, 0(SP)				
  0x4204b0		e8db040200		CALL runtime.goroutineheader(SB)	
		traceback(^uintptr(0), ^uintptr(0), 0, gp.m.curg)
  0x4204b5		488b442428		MOVQ 0x28(SP), AX		
  0x4204ba		488b4830		MOVQ 0x30(AX), CX		
  0x4204be		488b89c0000000		MOVQ 0xc0(CX), CX		
  0x4204c5		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x4204cd		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4204d6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4204df		48894c2418		MOVQ CX, 0x18(SP)		
  0x4204e4		e8c7f60100		CALL runtime.traceback(SB)	
  0x4204e9		eb88			JMP 0x420473			
		print("tracealloc(", p, ", ", hex(size), ")\n")
  0x4204eb		e8d0390000		CALL runtime.printlock(SB)	
  0x4204f0		488d0574f40400		LEAQ 0x4f474(IP), AX		
  0x4204f7		48890424		MOVQ AX, 0(SP)			
  0x4204fb		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x420504		e8e7420000		CALL runtime.printstring(SB)	
  0x420509		488b442468		MOVQ 0x68(SP), AX		
  0x42050e		48890424		MOVQ AX, 0(SP)			
  0x420512		e899420000		CALL runtime.printpointer(SB)	
  0x420517		488d057eeb0400		LEAQ 0x4eb7e(IP), AX		
  0x42051e		48890424		MOVQ AX, 0(SP)			
  0x420522		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42052b		e8c0420000		CALL runtime.printstring(SB)	
  0x420530		488b442470		MOVQ 0x70(SP), AX		
  0x420535		48890424		MOVQ AX, 0(SP)			
  0x420539		e872410000		CALL runtime.printhex(SB)	
  0x42053e		488d0555eb0400		LEAQ 0x4eb55(IP), AX		
  0x420545		48890424		MOVQ AX, 0(SP)			
  0x420549		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x420552		e899420000		CALL runtime.printstring(SB)	
  0x420557		e8e4390000		CALL runtime.printunlock(SB)	
  0x42055c		e9a6feffff		JMP 0x420407			
func tracealloc(p unsafe.Pointer, size uintptr, typ *_type) {
  0x420561		e81a730200		CALL runtime.morestack_noctxt(SB)	
  0x420566		e985fdffff		JMP runtime.tracealloc(SB)		

TEXT runtime.tracefree(SB) /usr/local/go/src/runtime/mprof.go
func tracefree(p unsafe.Pointer, size uintptr) {
  0x420570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420579		483b6110		CMPQ 0x10(CX), SP	
  0x42057d		0f8634010000		JBE 0x4206b7		
  0x420583		4883ec40		SUBQ $0x40, SP		
  0x420587		48896c2438		MOVQ BP, 0x38(SP)	
  0x42058c		488d6c2438		LEAQ 0x38(SP), BP	
	lock(&tracelock)
  0x420591		488d0568c80b00		LEAQ runtime.tracelock(SB), AX	
  0x420598		48890424		MOVQ AX, 0(SP)			
  0x42059c		e83f81feff		CALL runtime.lock(SB)		
	gp := getg()
  0x4205a1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4205aa		4889442410		MOVQ AX, 0x10(SP)	
	gp.m.traceback = 2
  0x4205af		488b4830		MOVQ 0x30(AX), CX	
  0x4205b3		c6812901000002		MOVB $0x2, 0x129(CX)	
	print("tracefree(", p, ", ", hex(size), ")\n")
  0x4205ba		e801390000		CALL runtime.printlock(SB)	
  0x4205bf		488d0532f20400		LEAQ 0x4f232(IP), AX		
  0x4205c6		48890424		MOVQ AX, 0(SP)			
  0x4205ca		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x4205d3		e818420000		CALL runtime.printstring(SB)	
  0x4205d8		488b442448		MOVQ 0x48(SP), AX		
  0x4205dd		48890424		MOVQ AX, 0(SP)			
  0x4205e1		e8ca410000		CALL runtime.printpointer(SB)	
  0x4205e6		488d05afea0400		LEAQ 0x4eaaf(IP), AX		
  0x4205ed		48890424		MOVQ AX, 0(SP)			
  0x4205f1		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4205fa		e8f1410000		CALL runtime.printstring(SB)	
  0x4205ff		488b442450		MOVQ 0x50(SP), AX		
  0x420604		48890424		MOVQ AX, 0(SP)			
  0x420608		e8a3400000		CALL runtime.printhex(SB)	
  0x42060d		488d0586ea0400		LEAQ 0x4ea86(IP), AX		
  0x420614		48890424		MOVQ AX, 0(SP)			
  0x420618		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x420621		e8ca410000		CALL runtime.printstring(SB)	
  0x420626		e815390000		CALL runtime.printunlock(SB)	
	goroutineheader(gp)
  0x42062b		488b442410		MOVQ 0x10(SP), AX			
  0x420630		48890424		MOVQ AX, 0(SP)				
  0x420634		e857030200		CALL runtime.goroutineheader(SB)	
	systemstack(func() {
  0x420639		0f57c0			XORPS X0, X0				
  0x42063c		0f11442418		MOVUPS X0, 0x18(SP)			
  0x420641		0f11442428		MOVUPS X0, 0x28(SP)			
  0x420646		488d0593560200		LEAQ runtime.tracefree.func1(SB), AX	
  0x42064d		4889442418		MOVQ AX, 0x18(SP)			
  0x420652		488b442440		MOVQ 0x40(SP), AX			
  0x420657		4889442420		MOVQ AX, 0x20(SP)			
  0x42065c		488d442448		LEAQ 0x48(SP), AX			
  0x420661		4889442428		MOVQ AX, 0x28(SP)			
  0x420666		488b442410		MOVQ 0x10(SP), AX			
  0x42066b		4889442430		MOVQ AX, 0x30(SP)			
  0x420670		488d4c2418		LEAQ 0x18(SP), CX			
  0x420675		48890c24		MOVQ CX, 0(SP)				
  0x420679		e8b2700200		CALL runtime.systemstack(SB)		
	print("\n")
  0x42067e		e83d380000		CALL runtime.printlock(SB)	
  0x420683		e8c83a0000		CALL runtime.printnl(SB)	
  0x420688		e8b3380000		CALL runtime.printunlock(SB)	
	gp.m.traceback = 0
  0x42068d		488b442410		MOVQ 0x10(SP), AX	
  0x420692		488b4030		MOVQ 0x30(AX), AX	
  0x420696		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x42069d		488d055cc70b00		LEAQ runtime.tracelock(SB), AX	
  0x4206a4		48890424		MOVQ AX, 0(SP)			
  0x4206a8		e8e381feff		CALL runtime.unlock(SB)		
}
  0x4206ad		488b6c2438		MOVQ 0x38(SP), BP	
  0x4206b2		4883c440		ADDQ $0x40, SP		
  0x4206b6		c3			RET			
func tracefree(p unsafe.Pointer, size uintptr) {
  0x4206b7		e8c4710200		CALL runtime.morestack_noctxt(SB)	
  0x4206bc		e9affeffff		JMP runtime.tracefree(SB)		

TEXT runtime.tracegc(SB) /usr/local/go/src/runtime/mprof.go
func tracegc() {
  0x4206d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4206d9		483b6110		CMPQ 0x10(CX), SP	
  0x4206dd		0f86c4000000		JBE 0x4207a7		
  0x4206e3		4883ec20		SUBQ $0x20, SP		
  0x4206e7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4206ec		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&tracelock)
  0x4206f1		488d0508c70b00		LEAQ runtime.tracelock(SB), AX	
  0x4206f8		48890424		MOVQ AX, 0(SP)			
  0x4206fc		e8df7ffeff		CALL runtime.lock(SB)		
	gp := getg()
  0x420701		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42070a		4889442410		MOVQ AX, 0x10(SP)	
	gp.m.traceback = 2
  0x42070f		488b4830		MOVQ 0x30(AX), CX	
  0x420713		c6812901000002		MOVB $0x2, 0x129(CX)	
	print("tracegc()\n")
  0x42071a		e8a1370000		CALL runtime.printlock(SB)	
  0x42071f		488d05dcf00400		LEAQ 0x4f0dc(IP), AX		
  0x420726		48890424		MOVQ AX, 0(SP)			
  0x42072a		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x420733		e8b8400000		CALL runtime.printstring(SB)	
  0x420738		e803380000		CALL runtime.printunlock(SB)	
	tracebackothers(gp)
  0x42073d		488b442410		MOVQ 0x10(SP), AX			
  0x420742		48890424		MOVQ AX, 0(SP)				
  0x420746		e825050200		CALL runtime.tracebackothers(SB)	
	print("end tracegc\n")
  0x42074b		e870370000		CALL runtime.printlock(SB)	
  0x420750		488d0592f30400		LEAQ 0x4f392(IP), AX		
  0x420757		48890424		MOVQ AX, 0(SP)			
  0x42075b		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x420764		e887400000		CALL runtime.printstring(SB)	
  0x420769		e8d2370000		CALL runtime.printunlock(SB)	
	print("\n")
  0x42076e		e84d370000		CALL runtime.printlock(SB)	
  0x420773		e8d8390000		CALL runtime.printnl(SB)	
  0x420778		e8c3370000		CALL runtime.printunlock(SB)	
	gp.m.traceback = 0
  0x42077d		488b442410		MOVQ 0x10(SP), AX	
  0x420782		488b4030		MOVQ 0x30(AX), AX	
  0x420786		c6802901000000		MOVB $0x0, 0x129(AX)	
	unlock(&tracelock)
  0x42078d		488d056cc60b00		LEAQ runtime.tracelock(SB), AX	
  0x420794		48890424		MOVQ AX, 0(SP)			
  0x420798		e8f380feff		CALL runtime.unlock(SB)		
}
  0x42079d		488b6c2418		MOVQ 0x18(SP), BP	
  0x4207a2		4883c420		ADDQ $0x20, SP		
  0x4207a6		c3			RET			
func tracegc() {
  0x4207a7		e8d4700200		CALL runtime.morestack_noctxt(SB)	
  0x4207ac		e91fffffff		JMP runtime.tracegc(SB)			

TEXT runtime.init.3(SB) /usr/local/go/src/runtime/mstats.go
func init() {
  0x4207c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4207c9		483b6110		CMPQ 0x10(CX), SP	
  0x4207cd		7671			JBE 0x420840		
  0x4207cf		4883ec18		SUBQ $0x18, SP		
  0x4207d3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4207d8		488d6c2410		LEAQ 0x10(SP), BP	
	if sizeof_C_MStats != unsafe.Sizeof(memStats) {
  0x4207dd		48813d70e8090090160000	CMPQ $0x1690, runtime.sizeof_C_MStats(SB)	
  0x4207e8		750a			JNE 0x4207f4					
  0x4207ea		488b6c2410		MOVQ 0x10(SP), BP				
  0x4207ef		4883c418		ADDQ $0x18, SP					
  0x4207f3		c3			RET						
		println(sizeof_C_MStats, unsafe.Sizeof(memStats))
  0x4207f4		e8c7360000		CALL runtime.printlock(SB)		
  0x4207f9		488b0558e80900		MOVQ runtime.sizeof_C_MStats(SB), AX	
  0x420800		48890424		MOVQ AX, 0(SP)				
  0x420804		e8373d0000		CALL runtime.printuint(SB)		
  0x420809		e8f2380000		CALL runtime.printsp(SB)		
  0x42080e		48c7042490160000	MOVQ $0x1690, 0(SP)			
  0x420816		e8253d0000		CALL runtime.printuint(SB)		
  0x42081b		e830390000		CALL runtime.printnl(SB)		
  0x420820		e81b370000		CALL runtime.printunlock(SB)		
		throw("MStats vs MemStatsType size mismatch")
  0x420825		488d05031d0500		LEAQ 0x51d03(IP), AX	
  0x42082c		48890424		MOVQ AX, 0(SP)		
  0x420830		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x420839		e8422c0000		CALL runtime.throw(SB)	
  0x42083e		0f0b			UD2			
func init() {
  0x420840		e83b700200		CALL runtime.morestack_noctxt(SB)	
  0x420845		e976ffffff		JMP runtime.init.3(SB)			

TEXT runtime.cachestats(SB) /usr/local/go/src/runtime/mstats.go
func cachestats() {
  0x420850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420859		483b6110		CMPQ 0x10(CX), SP	
  0x42085d		7668			JBE 0x4208c7		
  0x42085f		4883ec28		SUBQ $0x28, SP		
  0x420863		48896c2420		MOVQ BP, 0x20(SP)	
  0x420868		488d6c2420		LEAQ 0x20(SP), BP	
	for _, p := range allp {
  0x42086d		488b05ac110a00		MOVQ runtime.allp(SB), AX	
  0x420874		4889442418		MOVQ AX, 0x18(SP)		
  0x420879		488b0da8110a00		MOVQ runtime.allp+8(SB), CX	
  0x420880		48894c2410		MOVQ CX, 0x10(SP)		
  0x420885		31d2			XORL DX, DX			
  0x420887		eb03			JMP 0x42088c			
  0x420889		48ffc2			INCQ DX				
  0x42088c		4839ca			CMPQ CX, DX			
  0x42088f		7d2c			JGE 0x4208bd			
  0x420891		488b1cd0		MOVQ 0(AX)(DX*8), BX		
		c := p.mcache
  0x420895		488b5b48		MOVQ 0x48(BX), BX	
		if c == nil {
  0x420899		4885db			TESTQ BX, BX		
  0x42089c		74eb			JE 0x420889		
	for _, p := range allp {
  0x42089e		4889542408		MOVQ DX, 0x8(SP)	
		purgecachedstats(c)
  0x4208a3		48891c24		MOVQ BX, 0(SP)				
  0x4208a7		e8a4000000		CALL runtime.purgecachedstats(SB)	
	for _, p := range allp {
  0x4208ac		488b442418		MOVQ 0x18(SP), AX	
  0x4208b1		488b4c2410		MOVQ 0x10(SP), CX	
  0x4208b6		488b542408		MOVQ 0x8(SP), DX	
		purgecachedstats(c)
  0x4208bb		ebcc			JMP 0x420889		
  0x4208bd		488b6c2420		MOVQ 0x20(SP), BP	
  0x4208c2		4883c428		ADDQ $0x28, SP		
  0x4208c6		c3			RET			
func cachestats() {
  0x4208c7		e8b46f0200		CALL runtime.morestack_noctxt(SB)	
  0x4208cc		eb82			JMP runtime.cachestats(SB)		

TEXT runtime.flushmcache(SB) /usr/local/go/src/runtime/mstats.go
func flushmcache(i int) {
  0x4208d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4208d9		483b6110		CMPQ 0x10(CX), SP	
  0x4208dd		7667			JBE 0x420946		
  0x4208df		4883ec18		SUBQ $0x18, SP		
  0x4208e3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4208e8		488d6c2410		LEAQ 0x10(SP), BP	
	p := allp[i]
  0x4208ed		488b052c110a00		MOVQ runtime.allp(SB), AX	
  0x4208f4		488b4c2420		MOVQ 0x20(SP), CX		
  0x4208f9		48390d28110a00		CMPQ CX, runtime.allp+8(SB)	
  0x420900		763d			JBE 0x42093f			
  0x420902		488b04c8		MOVQ 0(AX)(CX*8), AX		
	c := p.mcache
  0x420906		488b4048		MOVQ 0x48(AX), AX	
	if c == nil {
  0x42090a		4885c0			TESTQ AX, AX		
  0x42090d		7426			JE 0x420935		
	c := p.mcache
  0x42090f		4889442408		MOVQ AX, 0x8(SP)	
	c.releaseAll()
  0x420914		48890424		MOVQ AX, 0(SP)				
  0x420918		e85300ffff		CALL runtime.(*mcache).releaseAll(SB)	
	stackcache_clear(c)
  0x42091d		488b442408		MOVQ 0x8(SP), AX			
  0x420922		48890424		MOVQ AX, 0(SP)				
  0x420926		e895600100		CALL runtime.stackcache_clear(SB)	
}
  0x42092b		488b6c2410		MOVQ 0x10(SP), BP	
  0x420930		4883c418		ADDQ $0x18, SP		
  0x420934		c3			RET			
		return
  0x420935		488b6c2410		MOVQ 0x10(SP), BP	
  0x42093a		4883c418		ADDQ $0x18, SP		
  0x42093e		c3			RET			
	p := allp[i]
  0x42093f		e8dc150000		CALL runtime.panicindex(SB)	
  0x420944		0f0b			UD2				
func flushmcache(i int) {
  0x420946		e8356f0200		CALL runtime.morestack_noctxt(SB)	
  0x42094b		eb83			JMP runtime.flushmcache(SB)		

TEXT runtime.purgecachedstats(SB) /usr/local/go/src/runtime/mstats.go
	memstats.heap_scan += uint64(c.local_scan)
  0x420950		488b442408		MOVQ 0x8(SP), AX			
  0x420955		488b4808		MOVQ 0x8(AX), CX			
  0x420959		48010d48ea0b00		ADDQ CX, runtime.memstats+5960(SB)	
	c.local_scan = 0
  0x420960		48c7400800000000	MOVQ $0x0, 0x8(AX)	
	memstats.tinyallocs += uint64(c.local_tinyallocs)
  0x420968		488b4820		MOVQ 0x20(AX), CX			
  0x42096c		48010d15ea0b00		ADDQ CX, runtime.memstats+5928(SB)	
	c.local_tinyallocs = 0
  0x420973		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	h.largefree += uint64(c.local_largefree)
  0x42097b		488b8898040000		MOVQ 0x498(AX), CX		
  0x420982		48010d9f5d0a00		ADDQ CX, runtime.mheap_+232(SB)	
	c.local_largefree = 0
  0x420989		48c7809804000000000000	MOVQ $0x0, 0x498(AX)	
	h.nlargefree += uint64(c.local_nlargefree)
  0x420994		488b88a0040000		MOVQ 0x4a0(AX), CX		
  0x42099b		48010d8e5d0a00		ADDQ CX, runtime.mheap_+240(SB)	
	c.local_nlargefree = 0
  0x4209a2		48c780a004000000000000	MOVQ $0x0, 0x4a0(AX)	
  0x4209ad		31c9			XORL CX, CX		
	for i := 0; i < len(c.local_nsmallfree); i++ {
  0x4209af		eb29			JMP 0x4209da		
		h.nsmallfree[i] += uint64(c.local_nsmallfree[i])
  0x4209b1		488d15805d0a00		LEAQ runtime.mheap_+248(SB), DX	
  0x4209b8		488b1cca		MOVQ 0(DX)(CX*8), BX		
  0x4209bc		488bb4c8a8040000	MOVQ 0x4a8(AX)(CX*8), SI	
  0x4209c4		4801f3			ADDQ SI, BX			
  0x4209c7		48891cca		MOVQ BX, 0(DX)(CX*8)		
		c.local_nsmallfree[i] = 0
  0x4209cb		48c784c8a804000000000000	MOVQ $0x0, 0x4a8(AX)(CX*8)	
	for i := 0; i < len(c.local_nsmallfree); i++ {
  0x4209d7		48ffc1			INCQ CX			
  0x4209da		4883f943		CMPQ $0x43, CX		
  0x4209de		7cd1			JL 0x4209b1		
  0x4209e0		c3			RET			

TEXT runtime.mSysStatInc(SB) /usr/local/go/src/runtime/mstats.go
func mSysStatInc(sysStat *uint64, n uintptr) {
  0x4209f0		4883ec20		SUBQ $0x20, SP		
  0x4209f4		48896c2418		MOVQ BP, 0x18(SP)	
  0x4209f9		488d6c2418		LEAQ 0x18(SP), BP	
	if sysStat == nil {
  0x4209fe		488b442428		MOVQ 0x28(SP), AX	
  0x420a03		4885c0			TESTQ AX, AX		
  0x420a06		0f8490000000		JE 0x420a9c		
	if val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), n); val < n {
  0x420a0c		488b4c2430		MOVQ 0x30(SP), CX	
  0x420a11		4889ca			MOVQ CX, DX		
  0x420a14		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x420a19		488d040a		LEAQ 0(DX)(CX*1), AX	
  0x420a1d		4839d0			CMPQ DX, AX		
  0x420a20		720a			JB 0x420a2c		
  0x420a22		488b6c2418		MOVQ 0x18(SP), BP	
  0x420a27		4883c420		ADDQ $0x20, SP		
  0x420a2b		c3			RET			
  0x420a2c		4889442410		MOVQ AX, 0x10(SP)	
		print("runtime: stat overflow: val ", val, ", n ", n, "\n")
  0x420a31		e88a340000		CALL runtime.printlock(SB)	
  0x420a36		488d05e50d0500		LEAQ 0x50de5(IP), AX		
  0x420a3d		48890424		MOVQ AX, 0(SP)			
  0x420a41		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x420a4a		e8a13d0000		CALL runtime.printstring(SB)	
  0x420a4f		488b442410		MOVQ 0x10(SP), AX		
  0x420a54		48890424		MOVQ AX, 0(SP)			
  0x420a58		e8e33a0000		CALL runtime.printuint(SB)	
  0x420a5d		488d05c1e60400		LEAQ 0x4e6c1(IP), AX		
  0x420a64		48890424		MOVQ AX, 0(SP)			
  0x420a68		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x420a71		e87a3d0000		CALL runtime.printstring(SB)	
  0x420a76		488b442430		MOVQ 0x30(SP), AX		
  0x420a7b		48890424		MOVQ AX, 0(SP)			
  0x420a7f		e8bc3a0000		CALL runtime.printuint(SB)	
  0x420a84		e8c7360000		CALL runtime.printnl(SB)	
  0x420a89		e8b2340000		CALL runtime.printunlock(SB)	
		exit(2)
  0x420a8e		c7042402000000		MOVL $0x2, 0(SP)	
  0x420a95		e886a30200		CALL runtime.exit(SB)	
  0x420a9a		eb86			JMP 0x420a22		
		return
  0x420a9c		488b6c2418		MOVQ 0x18(SP), BP	
  0x420aa1		4883c420		ADDQ $0x20, SP		
  0x420aa5		c3			RET			

TEXT runtime.mSysStatDec(SB) /usr/local/go/src/runtime/mstats.go
func mSysStatDec(sysStat *uint64, n uintptr) {
  0x420ab0		4883ec20		SUBQ $0x20, SP		
  0x420ab4		48896c2418		MOVQ BP, 0x18(SP)	
  0x420ab9		488d6c2418		LEAQ 0x18(SP), BP	
	if sysStat == nil {
  0x420abe		488b442428		MOVQ 0x28(SP), AX	
  0x420ac3		4885c0			TESTQ AX, AX		
  0x420ac6		0f8496000000		JE 0x420b62		
	if val := atomic.Xadduintptr((*uintptr)(unsafe.Pointer(sysStat)), uintptr(-int64(n))); val+n < n {
  0x420acc		488b4c2430		MOVQ 0x30(SP), CX	
  0x420ad1		4889ca			MOVQ CX, DX		
  0x420ad4		48f7d9			NEGQ CX			
  0x420ad7		f0480fc108		LOCK XADDQ CX, 0(AX)	
  0x420adc		4829d1			SUBQ DX, CX		
  0x420adf		488d0411		LEAQ 0(CX)(DX*1), AX	
  0x420ae3		4839d0			CMPQ DX, AX		
  0x420ae6		720a			JB 0x420af2		
  0x420ae8		488b6c2418		MOVQ 0x18(SP), BP	
  0x420aed		4883c420		ADDQ $0x20, SP		
  0x420af1		c3			RET			
  0x420af2		48894c2410		MOVQ CX, 0x10(SP)	
		print("runtime: stat underflow: val ", val, ", n ", n, "\n")
  0x420af7		e8c4330000		CALL runtime.printlock(SB)	
  0x420afc		488d05970e0500		LEAQ 0x50e97(IP), AX		
  0x420b03		48890424		MOVQ AX, 0(SP)			
  0x420b07		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x420b10		e8db3c0000		CALL runtime.printstring(SB)	
  0x420b15		488b442410		MOVQ 0x10(SP), AX		
  0x420b1a		48890424		MOVQ AX, 0(SP)			
  0x420b1e		e81d3a0000		CALL runtime.printuint(SB)	
  0x420b23		488d05fbe50400		LEAQ 0x4e5fb(IP), AX		
  0x420b2a		48890424		MOVQ AX, 0(SP)			
  0x420b2e		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x420b37		e8b43c0000		CALL runtime.printstring(SB)	
  0x420b3c		488b442430		MOVQ 0x30(SP), AX		
  0x420b41		48890424		MOVQ AX, 0(SP)			
  0x420b45		e8f6390000		CALL runtime.printuint(SB)	
  0x420b4a		e801360000		CALL runtime.printnl(SB)	
  0x420b4f		e8ec330000		CALL runtime.printunlock(SB)	
		exit(2)
  0x420b54		c7042402000000		MOVL $0x2, 0(SP)	
  0x420b5b		e8c0a20200		CALL runtime.exit(SB)	
  0x420b60		eb86			JMP 0x420ae8		
		return
  0x420b62		488b6c2418		MOVQ 0x18(SP), BP	
  0x420b67		4883c420		ADDQ $0x20, SP		
  0x420b6b		c3			RET			

TEXT runtime.(*wbBuf).reset(SB) /usr/local/go/src/runtime/mwbbuf.go
func (b *wbBuf) reset() {
  0x420b70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420b79		483b6110		CMPQ 0x10(CX), SP	
  0x420b7d		766d			JBE 0x420bec		
  0x420b7f		4883ec18		SUBQ $0x18, SP		
  0x420b83		48896c2410		MOVQ BP, 0x10(SP)	
  0x420b88		488d6c2410		LEAQ 0x10(SP), BP	
	start := uintptr(unsafe.Pointer(&b.buf[0]))
  0x420b8d		488b442420		MOVQ 0x20(SP), AX	
  0x420b92		488d4810		LEAQ 0x10(AX), CX	
	b.next = start
  0x420b96		488908			MOVQ CX, 0(AX)		
	if writeBarrier.cgo || (debugCachedWork && (throwOnGCWork || b.debugGen == atomic.Load(&gcWorkPauseGen))) {
  0x420b99		803d85c20b0000		CMPB $0x0, runtime.writeBarrier+5(SB)	
  0x420ba0		7422			JE 0x420bc4				
		b.end = uintptr(unsafe.Pointer(&b.buf[wbBufEntryPointers]))
  0x420ba2		488d4820		LEAQ 0x20(AX), CX	
  0x420ba6		48894808		MOVQ CX, 0x8(AX)	
	if (b.end-b.next)%(wbBufEntryPointers*unsafe.Sizeof(b.buf[0])) != 0 {
  0x420baa		488b4808		MOVQ 0x8(AX), CX	
  0x420bae		482b08			SUBQ 0(AX), CX		
  0x420bb1		48f7c10f000000		TESTQ $0xf, CX		
  0x420bb8		7517			JNE 0x420bd1		
  0x420bba		488b6c2410		MOVQ 0x10(SP), BP	
  0x420bbf		4883c418		ADDQ $0x18, SP		
  0x420bc3		c3			RET			
		b.end = start + uintptr(len(b.buf))*unsafe.Sizeof(b.buf[0])
  0x420bc4		4881c100100000		ADDQ $0x1000, CX	
  0x420bcb		48894808		MOVQ CX, 0x8(AX)	
	if (b.end-b.next)%(wbBufEntryPointers*unsafe.Sizeof(b.buf[0])) != 0 {
  0x420bcf		ebd9			JMP 0x420baa		
		throw("bad write barrier buffer bounds")
  0x420bd1		488d0525110500		LEAQ 0x51125(IP), AX	
  0x420bd8		48890424		MOVQ AX, 0(SP)		
  0x420bdc		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x420be5		e896280000		CALL runtime.throw(SB)	
  0x420bea		0f0b			UD2			
func (b *wbBuf) reset() {
  0x420bec		e88f6c0200		CALL runtime.morestack_noctxt(SB)	
  0x420bf1		e97affffff		JMP runtime.(*wbBuf).reset(SB)		

TEXT runtime.wbBufFlush(SB) /usr/local/go/src/runtime/mwbbuf.go
func wbBufFlush(dst *uintptr, src uintptr) {
  0x420c00		4883ec28		SUBQ $0x28, SP		
  0x420c04		48896c2420		MOVQ BP, 0x20(SP)	
  0x420c09		488d6c2420		LEAQ 0x20(SP), BP	
	if getg().m.dying > 0 {
  0x420c0e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x420c17		488b4030		MOVQ 0x30(AX), AX	
  0x420c1b		83b80c01000000		CMPL $0x0, 0x10c(AX)	
  0x420c22		0f8fa5000000		JG 0x420ccd		
	if writeBarrier.cgo && dst != nil {
  0x420c28		803df6c10b0000		CMPB $0x0, runtime.writeBarrier+5(SB)	
  0x420c2f		0f848e000000		JE 0x420cc3				
  0x420c35		488b442430		MOVQ 0x30(SP), AX			
  0x420c3a		4885c0			TESTQ AX, AX				
  0x420c3d		7531			JNE 0x420c70				
	systemstack(func() {
  0x420c3f		0f57c0			XORPS X0, X0				
  0x420c42		0f11442410		MOVUPS X0, 0x10(SP)			
  0x420c47		488d0df2500200		LEAQ runtime.wbBufFlush.func1(SB), CX	
  0x420c4e		48894c2410		MOVQ CX, 0x10(SP)			
  0x420c53		4889442418		MOVQ AX, 0x18(SP)			
  0x420c58		488d442410		LEAQ 0x10(SP), AX			
  0x420c5d		48890424		MOVQ AX, 0(SP)				
  0x420c61		e8ca6a0200		CALL runtime.systemstack(SB)		
}
  0x420c66		488b6c2420		MOVQ 0x20(SP), BP	
  0x420c6b		4883c428		ADDQ $0x28, SP		
  0x420c6f		c3			RET			
		cgoCheckWriteBarrier(dst, src)
  0x420c70		48890424		MOVQ AX, 0(SP)				
  0x420c74		488b4c2438		MOVQ 0x38(SP), CX			
  0x420c79		48894c2408		MOVQ CX, 0x8(SP)			
  0x420c7e		e84d2dfeff		CALL runtime.cgoCheckWriteBarrier(SB)	
		if !writeBarrier.needed {
  0x420c83		803d9ac10b0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x420c8a		7407			JE 0x420c93				
	systemstack(func() {
  0x420c8c		488b442430		MOVQ 0x30(SP), AX	
  0x420c91		ebac			JMP 0x420c3f		
			getg().m.p.ptr().wbBuf.discard()
  0x420c93		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x420c9c		488b4030		MOVQ 0x30(AX), AX	
  0x420ca0		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x420ca7		8400			TESTB AL, 0(AX)		
  0x420ca9		90			NOPL			
  0x420caa		90			NOPL			
	b.next = uintptr(unsafe.Pointer(&b.buf[0]))
  0x420cab		488d8830130000		LEAQ 0x1330(AX), CX	
  0x420cb2		48898820130000		MOVQ CX, 0x1320(AX)	
			return
  0x420cb9		488b6c2420		MOVQ 0x20(SP), BP	
  0x420cbe		4883c428		ADDQ $0x28, SP		
  0x420cc2		c3			RET			
	systemstack(func() {
  0x420cc3		488b442430		MOVQ 0x30(SP), AX	
	if writeBarrier.cgo && dst != nil {
  0x420cc8		e972ffffff		JMP 0x420c3f		
		getg().m.p.ptr().wbBuf.discard()
  0x420ccd		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x420cd4		8400			TESTB AL, 0(AX)		
  0x420cd6		90			NOPL			
  0x420cd7		90			NOPL			
	b.next = uintptr(unsafe.Pointer(&b.buf[0]))
  0x420cd8		488d8830130000		LEAQ 0x1330(AX), CX	
  0x420cdf		48898820130000		MOVQ CX, 0x1320(AX)	
		return
  0x420ce6		488b6c2420		MOVQ 0x20(SP), BP	
  0x420ceb		4883c428		ADDQ $0x28, SP		
  0x420cef		c3			RET			

TEXT runtime.wbBufFlush1(SB) /usr/local/go/src/runtime/mwbbuf.go
func wbBufFlush1(_p_ *p) {
  0x420cf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420cf9		483b6118		CMPQ 0x18(CX), SP	
  0x420cfd		0f8630020000		JBE 0x420f33		
  0x420d03		4883ec50		SUBQ $0x50, SP		
  0x420d07		48896c2448		MOVQ BP, 0x48(SP)	
  0x420d0c		488d6c2448		LEAQ 0x48(SP), BP	
	start := uintptr(unsafe.Pointer(&_p_.wbBuf.buf[0]))
  0x420d11		488b442458		MOVQ 0x58(SP), AX	
  0x420d16		8400			TESTB AL, 0(AX)		
  0x420d18		488d8830130000		LEAQ 0x1330(AX), CX	
	n := (_p_.wbBuf.next - start) / unsafe.Sizeof(_p_.wbBuf.buf[0])
  0x420d1f		488b9020130000		MOVQ 0x1320(AX), DX	
  0x420d26		4829ca			SUBQ CX, DX		
  0x420d29		48c1ea03		SHRQ $0x3, DX		
	ptrs := _p_.wbBuf.buf[:n]
  0x420d2d		4885d2			TESTQ DX, DX		
  0x420d30		0f8cf6010000		JL 0x420f2c		
  0x420d36		4881fa00020000		CMPQ $0x200, DX		
  0x420d3d		0f87e9010000		JA 0x420f2c		
	n := (_p_.wbBuf.next - start) / unsafe.Sizeof(_p_.wbBuf.buf[0])
  0x420d43		4889542440		MOVQ DX, 0x40(SP)	
	_p_.wbBuf.next = 0
  0x420d48		48c7802013000000000000	MOVQ $0x0, 0x1320(AX)	
	if useCheckmark {
  0x420d53		803d5cbf0b0000		CMPB $0x0, runtime.useCheckmark(SB)	
  0x420d5a		0f8573010000		JNE 0x420ed3				
  0x420d60		31c9			XORL CX, CX				
  0x420d62		31db			XORL BX, BX				
	for _, ptr := range ptrs {
  0x420d64		eb03			JMP 0x420d69			
  0x420d66		48ffc1			INCQ CX				
  0x420d69		4839d1			CMPQ DX, CX			
  0x420d6c		0f8d03010000		JGE 0x420e75			
  0x420d72		488bb4c830130000	MOVQ 0x1330(AX)(CX*8), SI	
		if ptr < minLegalPointer {
  0x420d7a		4881fe00100000		CMPQ $0x1000, SI	
  0x420d81		72e3			JB 0x420d66		
	for _, ptr := range ptrs {
  0x420d83		48894c2438		MOVQ CX, 0x38(SP)	
		ptrs[pos] = obj
  0x420d88		48895c2430		MOVQ BX, 0x30(SP)	
		obj, span, objIndex := findObject(ptr, 0, 0)
  0x420d8d		48893424		MOVQ SI, 0(SP)			
  0x420d91		0f57c0			XORPS X0, X0			
  0x420d94		0f11442408		MOVUPS X0, 0x8(SP)		
  0x420d99		e802cefeff		CALL runtime.findObject(SB)	
  0x420d9e		488b442418		MOVQ 0x18(SP), AX		
  0x420da3		488b4c2420		MOVQ 0x20(SP), CX		
  0x420da8		488b542428		MOVQ 0x28(SP), DX		
		if obj == 0 {
  0x420dad		4885c0			TESTQ AX, AX		
  0x420db0		7516			JNE 0x420dc8		
	for _, ptr := range ptrs {
  0x420db2		488b442458		MOVQ 0x58(SP), AX	
  0x420db7		488b4c2438		MOVQ 0x38(SP), CX	
  0x420dbc		488b542440		MOVQ 0x40(SP), DX	
		ptrs[pos] = obj
  0x420dc1		488b5c2430		MOVQ 0x30(SP), BX	
			continue
  0x420dc6		eb9e			JMP 0x420d66		
		mbits := span.markBitsForIndex(objIndex)
  0x420dc8		90			NOPL			
		if mbits.isMarked() {
  0x420dc9		90			NOPL			
	bytep, mask := s.gcmarkBits.bitp(objIndex)
  0x420dca		90			NOPL			
	return b.bytep(n / 8), 1 << (n % 8)
  0x420dcb		90			NOPL			
  0x420dcc		4889d3			MOVQ DX, BX		
  0x420dcf		48c1ea03		SHRQ $0x3, DX		
  0x420dd3		4883e307		ANDQ $0x7, BX		
		obj, span, objIndex := findObject(ptr, 0, 0)
  0x420dd7		4889ce			MOVQ CX, SI		
	return b.bytep(n / 8), 1 << (n % 8)
  0x420dda		4889d9			MOVQ BX, CX		
  0x420ddd		bf01000000		MOVL $0x1, DI		
  0x420de2		d3e7			SHLL CL, DI		
	return addb((*uint8)(b), n)
  0x420de4		90			NOPL			
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x420de5		48035650		ADDQ 0x50(SI), DX	
	return *m.bytep&m.mask != 0
  0x420de9		0fb61a			MOVZX 0(DX), BX		
  0x420dec		4084df			TESTL BL, DI		
		if mbits.isMarked() {
  0x420def		7419			JE 0x420e0a		
	for _, ptr := range ptrs {
  0x420df1		488b442458		MOVQ 0x58(SP), AX	
  0x420df6		488b4c2438		MOVQ 0x38(SP), CX	
  0x420dfb		488b542440		MOVQ 0x40(SP), DX	
		ptrs[pos] = obj
  0x420e00		488b5c2430		MOVQ 0x30(SP), BX	
			continue
  0x420e05		e95cffffff		JMP 0x420d66		
		mbits.setMarked()
  0x420e0a		90			NOPL			
	atomic.Or8(m.bytep, m.mask)
  0x420e0b		f040083a		LOCK ORB DI, 0(DX)	
		if span.spanclass.noscan() {
  0x420e0f		0fb64e62		MOVZX 0x62(SI), CX	
  0x420e13		90			NOPL			
	return sc&1 != 0
  0x420e14		f6c101			TESTL $0x1, CL		
		if span.spanclass.noscan() {
  0x420e17		742b			JE 0x420e44		
			gcw.bytesMarked += uint64(span.elemsize)
  0x420e19		488b442458		MOVQ 0x58(SP), AX	
  0x420e1e		488bb880120000		MOVQ 0x1280(AX), DI	
  0x420e25		48037e68		ADDQ 0x68(SI), DI	
  0x420e29		4889b880120000		MOVQ DI, 0x1280(AX)	
	for _, ptr := range ptrs {
  0x420e30		488b4c2438		MOVQ 0x38(SP), CX	
  0x420e35		488b542440		MOVQ 0x40(SP), DX	
		ptrs[pos] = obj
  0x420e3a		488b5c2430		MOVQ 0x30(SP), BX	
			continue
  0x420e3f		e922ffffff		JMP 0x420d66		
		ptrs[pos] = obj
  0x420e44		488b4c2430		MOVQ 0x30(SP), CX		
  0x420e49		488b542440		MOVQ 0x40(SP), DX		
  0x420e4e		4839d1			CMPQ DX, CX			
  0x420e51		0f83ce000000		JAE 0x420f25			
  0x420e57		488b742458		MOVQ 0x58(SP), SI		
  0x420e5c		488984ce30130000	MOVQ AX, 0x1330(SI)(CX*8)	
		pos++
  0x420e64		488d5901		LEAQ 0x1(CX), BX	
	for _, ptr := range ptrs {
  0x420e68		4889f0			MOVQ SI, AX		
  0x420e6b		488b4c2438		MOVQ 0x38(SP), CX	
		pos++
  0x420e70		e9f1feffff		JMP 0x420d66		
	gcw.putBatch(ptrs[:pos])
  0x420e75		4885db			TESTQ BX, BX		
  0x420e78		0f8ca0000000		JL 0x420f1e		
  0x420e7e		4881fb00020000		CMPQ $0x200, BX		
  0x420e85		0f8793000000		JA 0x420f1e		
	gcw := &_p_.gcw
  0x420e8b		488d8870120000		LEAQ 0x1270(AX), CX	
	gcw.putBatch(ptrs[:pos])
  0x420e92		48890c24		MOVQ CX, 0(SP)		
	ptrs := _p_.wbBuf.buf[:n]
  0x420e96		488d8830130000		LEAQ 0x1330(AX), CX	
	gcw.putBatch(ptrs[:pos])
  0x420e9d		48894c2408		MOVQ CX, 0x8(SP)			
  0x420ea2		48895c2410		MOVQ BX, 0x10(SP)			
  0x420ea7		48c744241800020000	MOVQ $0x200, 0x18(SP)			
  0x420eb0		e8bba7ffff		CALL runtime.(*gcWork).putBatch(SB)	
	_p_.wbBuf.reset()
  0x420eb5		488b442458		MOVQ 0x58(SP), AX		
  0x420eba		480520130000		ADDQ $0x1320, AX		
  0x420ec0		48890424		MOVQ AX, 0(SP)			
  0x420ec4		e8a7fcffff		CALL runtime.(*wbBuf).reset(SB)	
}
  0x420ec9		488b6c2448		MOVQ 0x48(SP), BP	
  0x420ece		4883c450		ADDQ $0x50, SP		
  0x420ed2		c3			RET			
  0x420ed3		31c9			XORL CX, CX		
		for _, ptr := range ptrs {
  0x420ed5		eb29			JMP 0x420f00			
  0x420ed7		48894c2438		MOVQ CX, 0x38(SP)		
  0x420edc		488b94c830130000	MOVQ 0x1330(AX)(CX*8), DX	
			shade(ptr)
  0x420ee4		48891424		MOVQ DX, 0(SP)		
  0x420ee8		e8337dffff		CALL runtime.shade(SB)	
		for _, ptr := range ptrs {
  0x420eed		488b442438		MOVQ 0x38(SP), AX	
  0x420ef2		488d4801		LEAQ 0x1(AX), CX	
  0x420ef6		488b442458		MOVQ 0x58(SP), AX	
  0x420efb		488b542440		MOVQ 0x40(SP), DX	
  0x420f00		4839d1			CMPQ DX, CX		
  0x420f03		7cd2			JL 0x420ed7		
		_p_.wbBuf.reset()
  0x420f05		480520130000		ADDQ $0x1320, AX		
  0x420f0b		48890424		MOVQ AX, 0(SP)			
  0x420f0f		e85cfcffff		CALL runtime.(*wbBuf).reset(SB)	
		return
  0x420f14		488b6c2448		MOVQ 0x48(SP), BP	
  0x420f19		4883c450		ADDQ $0x50, SP		
  0x420f1d		c3			RET			
	gcw.putBatch(ptrs[:pos])
  0x420f1e		e82d110000		CALL runtime.panicslice(SB)	
  0x420f23		0f0b			UD2				
		ptrs[pos] = obj
  0x420f25		e8f60f0000		CALL runtime.panicindex(SB)	
  0x420f2a		0f0b			UD2				
	ptrs := _p_.wbBuf.buf[:n]
  0x420f2c		e81f110000		CALL runtime.panicslice(SB)	
  0x420f31		0f0b			UD2				
func wbBufFlush1(_p_ *p) {
  0x420f33		e898870100		CALL runtime.morestackc(SB)	
  0x420f38		e9b3fdffff		JMP runtime.wbBufFlush1(SB)	

TEXT runtime.netpollready(SB) /usr/local/go/src/runtime/netpoll.go
func netpollready(toRun *gList, pd *pollDesc, mode int32) {
  0x420f40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x420f49		483b6110		CMPQ 0x10(CX), SP	
  0x420f4d		0f86ca000000		JBE 0x42101d		
  0x420f53		4883ec28		SUBQ $0x28, SP		
  0x420f57		48896c2420		MOVQ BP, 0x20(SP)	
  0x420f5c		488d6c2420		LEAQ 0x20(SP), BP	
	if mode == 'r' || mode == 'r'+'w' {
  0x420f61		8b442440		MOVL 0x40(SP), AX	
  0x420f65		83f872			CMPL $0x72, AX		
  0x420f68		0f859d000000		JNE 0x42100b		
		rg = netpollunblock(pd, 'r', true)
  0x420f6e		488b442438		MOVQ 0x38(SP), AX		
  0x420f73		48890424		MOVQ AX, 0(SP)			
  0x420f77		c744240872000000	MOVL $0x72, 0x8(SP)		
  0x420f7f		c644240c01		MOVB $0x1, 0xc(SP)		
  0x420f84		e8a7000000		CALL runtime.netpollunblock(SB)	
  0x420f89		488b442410		MOVQ 0x10(SP), AX		
	if rg != nil {
  0x420f8e		4889442418		MOVQ AX, 0x18(SP)	
	if mode == 'w' || mode == 'r'+'w' {
  0x420f93		8b4c2440		MOVL 0x40(SP), CX	
  0x420f97		83f977			CMPL $0x77, CX		
  0x420f9a		7563			JNE 0x420fff		
		wg = netpollunblock(pd, 'w', true)
  0x420f9c		488b442438		MOVQ 0x38(SP), AX		
  0x420fa1		48890424		MOVQ AX, 0(SP)			
  0x420fa5		c744240877000000	MOVL $0x77, 0x8(SP)		
  0x420fad		c644240c01		MOVB $0x1, 0xc(SP)		
  0x420fb2		e879000000		CALL runtime.netpollunblock(SB)	
  0x420fb7		488b442410		MOVQ 0x10(SP), AX		
	if rg != nil {
  0x420fbc		488b4c2418		MOVQ 0x18(SP), CX	
  0x420fc1		4885c9			TESTQ CX, CX		
  0x420fc4		7432			JE 0x420ff8		
		toRun.push(rg)
  0x420fc6		90			NOPL			
	gp.schedlink = l.head
  0x420fc7		488b542430		MOVQ 0x30(SP), DX	
  0x420fcc		488b1a			MOVQ 0(DX), BX		
  0x420fcf		488999a0000000		MOVQ BX, 0xa0(CX)	
	l.head.set(gp)
  0x420fd6		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x420fd7		48890a			MOVQ CX, 0(DX)		
	if wg != nil {
  0x420fda		4885c0			TESTQ AX, AX		
  0x420fdd		740f			JE 0x420fee		
		toRun.push(wg)
  0x420fdf		90			NOPL			
	gp.schedlink = l.head
  0x420fe0		488b0a			MOVQ 0(DX), CX		
  0x420fe3		488988a0000000		MOVQ CX, 0xa0(AX)	
	l.head.set(gp)
  0x420fea		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x420feb		488902			MOVQ AX, 0(DX)		
  0x420fee		488b6c2420		MOVQ 0x20(SP), BP	
  0x420ff3		4883c428		ADDQ $0x28, SP		
  0x420ff7		c3			RET			
	gp.schedlink = l.head
  0x420ff8		488b542430		MOVQ 0x30(SP), DX	
	if rg != nil {
  0x420ffd		ebdb			JMP 0x420fda		
	if mode == 'w' || mode == 'r'+'w' {
  0x420fff		81f9e9000000		CMPL $0xe9, CX		
  0x421005		7495			JE 0x420f9c		
  0x421007		31c0			XORL AX, AX		
	if rg != nil {
  0x421009		ebb1			JMP 0x420fbc		
	if mode == 'r' || mode == 'r'+'w' {
  0x42100b		3de9000000		CMPL $0xe9, AX		
  0x421010		0f8458ffffff		JE 0x420f6e		
  0x421016		31c0			XORL AX, AX		
	if mode == 'w' || mode == 'r'+'w' {
  0x421018		e971ffffff		JMP 0x420f8e		
func netpollready(toRun *gList, pd *pollDesc, mode int32) {
  0x42101d		e85e680200		CALL runtime.morestack_noctxt(SB)	
  0x421022		e919ffffff		JMP runtime.netpollready(SB)		

TEXT runtime.netpollunblock(SB) /usr/local/go/src/runtime/netpoll.go
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
  0x421030		4883ec10		SUBQ $0x10, SP		
  0x421034		48896c2408		MOVQ BP, 0x8(SP)	
  0x421039		488d6c2408		LEAQ 0x8(SP), BP	
	gpp := &pd.rg
  0x42103e		488b4c2418		MOVQ 0x18(SP), CX	
  0x421043		8401			TESTB AL, 0(CX)		
  0x421045		488d5128		LEAQ 0x28(CX), DX	
	if mode == 'w' {
  0x421049		8b5c2420		MOVL 0x20(SP), BX	
  0x42104d		83fb77			CMPL $0x77, BX		
  0x421050		7574			JNE 0x4210c6		
		gpp = &pd.wg
  0x421052		4881c180000000		ADDQ $0x80, CX		
		old := *gpp
  0x421059		0fb6542424		MOVZX 0x24(SP), DX	
  0x42105e		488b01			MOVQ 0(CX), AX		
		if old == pdReady {
  0x421061		4883f801		CMPQ $0x1, AX		
  0x421065		744c			JE 0x4210b3		
		if old == 0 && !ioready {
  0x421067		4885c0			TESTQ AX, AX		
  0x42106a		7504			JNE 0x421070		
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
  0x42106c		84d2			TESTL DL, DL		
		if old == 0 && !ioready {
  0x42106e		7430			JE 0x4210a0		
		old := *gpp
  0x421070		48890424		MOVQ AX, 0(SP)		
		if atomic.Casuintptr(gpp, old, new) {
  0x421074		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x421079		0f94c3			SETE BL			
  0x42107c		84db			TESTL BL, BL		
  0x42107e		74de			JE 0x42105e		
			if old == pdReady || old == pdWait {
  0x421080		488b0424		MOVQ 0(SP), AX		
  0x421084		4883f802		CMPQ $0x2, AX		
			return (*g)(unsafe.Pointer(old))
  0x421088		b900000000		MOVL $0x0, CX		
  0x42108d		480f44c1		CMOVE CX, AX		
  0x421091		4889442428		MOVQ AX, 0x28(SP)	
			if old == pdReady || old == pdWait {
  0x421096		488b6c2408		MOVQ 0x8(SP), BP	
  0x42109b		4883c410		ADDQ $0x10, SP		
  0x42109f		c3			RET			
			return nil
  0x4210a0		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x4210a9		488b6c2408		MOVQ 0x8(SP), BP	
  0x4210ae		4883c410		ADDQ $0x10, SP		
  0x4210b2		c3			RET			
			return nil
  0x4210b3		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x4210bc		488b6c2408		MOVQ 0x8(SP), BP	
  0x4210c1		4883c410		ADDQ $0x10, SP		
  0x4210c5		c3			RET			
		old := *gpp
  0x4210c6		4889d1			MOVQ DX, CX		
	if mode == 'w' {
  0x4210c9		eb8e			JMP 0x421059		

TEXT runtime.netpoll(SB) /usr/local/go/src/runtime/netpoll_epoll.go
func netpoll(block bool) gList {
  0x4210d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4210d9		488d842440faffff	LEAQ 0xfffffa40(SP), AX	
  0x4210e1		483b4110		CMPQ 0x10(CX), AX	
  0x4210e5		0f86f0010000		JBE 0x4212db		
  0x4210eb		4881ec40060000		SUBQ $0x640, SP		
  0x4210f2		4889ac2438060000	MOVQ BP, 0x638(SP)	
  0x4210fa		488dac2438060000	LEAQ 0x638(SP), BP	
	if epfd == -1 {
  0x421102		833dffde0900ff		CMPL $-0x1, runtime.epfd(SB)	
  0x421109		0f842b010000		JE 0x42123a			
	var events [128]epollevent
  0x42110f		488d7c2438		LEAQ 0x38(SP), DI	
  0x421114		b9c0000000		MOVL $0xc0, CX		
  0x421119		31c0			XORL AX, AX		
  0x42111b		f348ab			REP; STOSQ AX, ES:0(DI)	
	n := epollwait(epfd, &events[0], int32(len(events)), waitms)
  0x42111e		0fb6942448060000	MOVZX 0x648(SP), DX	
  0x421126		4885d2			TESTQ DX, DX		
  0x421129		bb00000000		MOVL $0x0, BX		
  0x42112e		beffffffff		MOVL $-0x1, SI		
  0x421133		0f45de			CMOVNE SI, BX		
  0x421136		895c2424		MOVL BX, 0x24(SP)	
	if !block {
  0x42113a		e993000000		JMP 0x4211d2		
	for i := int32(0); i < n; i++ {
  0x42113f		ffc1			INCL CX			
  0x421141		39c1			CMPL AX, CX		
  0x421143		7d74			JGE 0x4211b9		
		ev := &events[i]
  0x421145		4863d1			MOVSXD CX, DX		
  0x421148		4881fa80000000		CMPQ $0x80, DX		
  0x42114f		0f8301010000		JAE 0x421256		
  0x421155		488d1452		LEAQ 0(DX)(DX*2), DX	
		if ev.events == 0 {
  0x421159		8b5c9438		MOVL 0x38(SP)(DX*4), BX	
  0x42115d		85db			TESTL BX, BX		
  0x42115f		74de			JE 0x42113f		
		if ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
  0x421161		f7c319200000		TESTL $0x2019, BX	
			mode += 'w'
  0x421167		be00000000		MOVL $0x0, SI		
  0x42116c		bf72000000		MOVL $0x72, DI		
  0x421171		0f45f7			CMOVNE DI, SI		
  0x421174		448d4677		LEAL 0x77(SI), R8	
		if ev.events&(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
  0x421178		f7c31c000000		TESTL $0x1c, BX		
		if mode != 0 {
  0x42117e		410f45f0		CMOVNE R8, SI		
  0x421182		85f6			TESTL SI, SI		
		if ev.events&(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
  0x421184		74b9			JE 0x42113f		
	for i := int32(0); i < n; i++ {
  0x421186		894c242c		MOVL CX, 0x2c(SP)	
		ev := &events[i]
  0x42118a		48c1e202		SHLQ $0x2, DX		
			pd := *(**pollDesc)(unsafe.Pointer(&ev.data))
  0x42118e		488b44143c		MOVQ 0x3c(SP)(DX*1), AX	
			netpollready(&toRun, pd, mode)
  0x421193		488d4c2430		LEAQ 0x30(SP), CX		
  0x421198		48890c24		MOVQ CX, 0(SP)			
  0x42119c		4889442408		MOVQ AX, 0x8(SP)		
  0x4211a1		89742410		MOVL SI, 0x10(SP)		
  0x4211a5		e896fdffff		CALL runtime.netpollready(SB)	
	for i := int32(0); i < n; i++ {
  0x4211aa		8b442428		MOVL 0x28(SP), AX	
  0x4211ae		8b4c242c		MOVL 0x2c(SP), CX	
  0x4211b2		bf72000000		MOVL $0x72, DI		
			netpollready(&toRun, pd, mode)
  0x4211b7		eb86			JMP 0x42113f		
func netpoll(block bool) gList {
  0x4211b9		0fb6842448060000	MOVZX 0x648(SP), AX	
  0x4211c1		84c0			TESTL AL, AL		
	if block && toRun.empty() {
  0x4211c3		7458			JE 0x42121d		
  0x4211c5		90			NOPL			
	return l.head == 0
  0x4211c6		48837c243000		CMPQ $0x0, 0x30(SP)	
	if block && toRun.empty() {
  0x4211cc		754f			JNE 0x42121d		
	n := epollwait(epfd, &events[0], int32(len(events)), waitms)
  0x4211ce		8b5c2424		MOVL 0x24(SP), BX		
  0x4211d2		8b0530de0900		MOVL runtime.epfd(SB), AX	
  0x4211d8		890424			MOVL AX, 0(SP)			
  0x4211db		488d442438		LEAQ 0x38(SP), AX		
  0x4211e0		4889442408		MOVQ AX, 0x8(SP)		
  0x4211e5		c744241080000000	MOVL $0x80, 0x10(SP)		
  0x4211ed		895c2414		MOVL BX, 0x14(SP)		
  0x4211f1		e82aa40200		CALL runtime.epollwait(SB)	
  0x4211f6		8b442418		MOVL 0x18(SP), AX		
  0x4211fa		89442428		MOVL AX, 0x28(SP)		
	if n < 0 {
  0x4211fe		85c0			TESTL AX, AX		
  0x421200		7d0b			JGE 0x42120d		
		if n != -_EINTR {
  0x421202		83f8fc			CMPL $-0x4, AX		
  0x421205		7556			JNE 0x42125d		
	n := epollwait(epfd, &events[0], int32(len(events)), waitms)
  0x421207		8b5c2424		MOVL 0x24(SP), BX	
		goto retry
  0x42120b		ebc5			JMP 0x4211d2		
	var toRun gList
  0x42120d		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x421216		31c9			XORL CX, CX		
	for i := int32(0); i < n; i++ {
  0x421218		e924ffffff		JMP 0x421141		
	return toRun
  0x42121d		488b442430		MOVQ 0x30(SP), AX	
  0x421222		4889842450060000	MOVQ AX, 0x650(SP)	
  0x42122a		488bac2438060000	MOVQ 0x638(SP), BP	
  0x421232		4881c440060000		ADDQ $0x640, SP		
  0x421239		c3			RET			
		return gList{}
  0x42123a		48c784245006000000000000	MOVQ $0x0, 0x650(SP)	
  0x421246		488bac2438060000		MOVQ 0x638(SP), BP	
  0x42124e		4881c440060000			ADDQ $0x640, SP		
  0x421255		c3				RET			
		ev := &events[i]
  0x421256		e8c50c0000		CALL runtime.panicindex(SB)	
  0x42125b		0f0b			UD2				
			println("runtime: epollwait on fd", epfd, "failed with", -n)
  0x42125d		e85e2c0000		CALL runtime.printlock(SB)	
  0x421262		488d055ffe0400		LEAQ 0x4fe5f(IP), AX		
  0x421269		48890424		MOVQ AX, 0(SP)			
  0x42126d		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x421276		e875350000		CALL runtime.printstring(SB)	
  0x42127b		48630586dd0900		MOVSXD runtime.epfd(SB), AX	
  0x421282		48890424		MOVQ AX, 0(SP)			
  0x421286		e8b5330000		CALL runtime.printint(SB)	
  0x42128b		488d05ebe80400		LEAQ 0x4e8eb(IP), AX		
  0x421292		48890424		MOVQ AX, 0(SP)			
  0x421296		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x42129f		e84c350000		CALL runtime.printstring(SB)	
  0x4212a4		8b442428		MOVL 0x28(SP), AX		
  0x4212a8		f7d8			NEGL AX				
  0x4212aa		4863c0			MOVSXD AX, AX			
  0x4212ad		48890424		MOVQ AX, 0(SP)			
  0x4212b1		e88a330000		CALL runtime.printint(SB)	
  0x4212b6		e8952e0000		CALL runtime.printnl(SB)	
  0x4212bb		e8802c0000		CALL runtime.printunlock(SB)	
			throw("runtime: netpoll failed")
  0x4212c0		488d056cfa0400		LEAQ 0x4fa6c(IP), AX	
  0x4212c7		48890424		MOVQ AX, 0(SP)		
  0x4212cb		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4212d4		e8a7210000		CALL runtime.throw(SB)	
  0x4212d9		0f0b			UD2			
func netpoll(block bool) gList {
  0x4212db		e8a0650200		CALL runtime.morestack_noctxt(SB)	
  0x4212e0		e9ebfdffff		JMP runtime.netpoll(SB)			

TEXT runtime.futexsleep(SB) /usr/local/go/src/runtime/os_linux.go
func futexsleep(addr *uint32, val uint32, ns int64) {
  0x4212f0		4883ec48		SUBQ $0x48, SP		
  0x4212f4		48896c2440		MOVQ BP, 0x40(SP)	
  0x4212f9		488d6c2440		LEAQ 0x40(SP), BP	
	var ts timespec
  0x4212fe		0f57c0			XORPS X0, X0		
  0x421301		0f11442430		MOVUPS X0, 0x30(SP)	
	if ns < 0 {
  0x421306		488b4c2460		MOVQ 0x60(SP), CX	
  0x42130b		4885c9			TESTQ CX, CX		
  0x42130e		7d35			JGE 0x421345		
		futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, nil, nil, 0)
  0x421310		488b442450		MOVQ 0x50(SP), AX	
  0x421315		48890424		MOVQ AX, 0(SP)		
  0x421319		c744240880000000	MOVL $0x80, 0x8(SP)	
  0x421321		8b442458		MOVL 0x58(SP), AX	
  0x421325		8944240c		MOVL AX, 0xc(SP)	
  0x421329		0f11442410		MOVUPS X0, 0x10(SP)	
  0x42132e		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x421336		e875a10200		CALL runtime.futex(SB)	
		return
  0x42133b		488b6c2440		MOVQ 0x40(SP), BP	
  0x421340		4883c448		ADDQ $0x48, SP		
  0x421344		c3			RET			
		ts.set_sec(ns / 1000000000)
  0x421345		90			NOPL				
  0x421346		48b8cc525a9ba02fb844	MOVQ $0x44b82fa09b5a52cc, AX	
  0x421350		48f7e9			IMULQ CX			
  0x421353		48c1fa1c		SARQ $0x1c, DX			
  0x421357		4889cb			MOVQ CX, BX			
  0x42135a		48c1f93f		SARQ $0x3f, CX			
  0x42135e		4829ca			SUBQ CX, DX			
	ts.tv_sec = x
  0x421361		4889542430		MOVQ DX, 0x30(SP)	
		ts.set_nsec(int32(ns % 1000000000))
  0x421366		90			NOPL				
  0x421367		4869ca00ca9a3b		IMULQ $0x3b9aca00, DX, CX	
  0x42136e		4829cb			SUBQ CX, BX			
	ts.tv_nsec = int64(x)
  0x421371		4863cb			MOVSXD BX, CX		
  0x421374		48894c2438		MOVQ CX, 0x38(SP)	
	futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, unsafe.Pointer(&ts), nil, 0)
  0x421379		488b4c2450		MOVQ 0x50(SP), CX	
  0x42137e		48890c24		MOVQ CX, 0(SP)		
  0x421382		c744240880000000	MOVL $0x80, 0x8(SP)	
  0x42138a		8b4c2458		MOVL 0x58(SP), CX	
  0x42138e		894c240c		MOVL CX, 0xc(SP)	
  0x421392		488d4c2430		LEAQ 0x30(SP), CX	
  0x421397		48894c2410		MOVQ CX, 0x10(SP)	
  0x42139c		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x4213a5		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x4213ad		e8fea00200		CALL runtime.futex(SB)	
}
  0x4213b2		488b6c2440		MOVQ 0x40(SP), BP	
  0x4213b7		4883c448		ADDQ $0x48, SP		
  0x4213bb		c3			RET			

TEXT runtime.futexwakeup(SB) /usr/local/go/src/runtime/os_linux.go
func futexwakeup(addr *uint32, cnt uint32) {
  0x4213c0		4883ec50		SUBQ $0x50, SP		
  0x4213c4		48896c2448		MOVQ BP, 0x48(SP)	
  0x4213c9		488d6c2448		LEAQ 0x48(SP), BP	
	ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE_PRIVATE, cnt, nil, nil, 0)
  0x4213ce		488b442458		MOVQ 0x58(SP), AX	
  0x4213d3		48890424		MOVQ AX, 0(SP)		
  0x4213d7		c744240881000000	MOVL $0x81, 0x8(SP)	
  0x4213df		8b4c2460		MOVL 0x60(SP), CX	
  0x4213e3		894c240c		MOVL CX, 0xc(SP)	
  0x4213e7		0f57c0			XORPS X0, X0		
  0x4213ea		0f11442410		MOVUPS X0, 0x10(SP)	
  0x4213ef		c744242000000000	MOVL $0x0, 0x20(SP)	
  0x4213f7		e8b4a00200		CALL runtime.futex(SB)	
  0x4213fc		8b442428		MOVL 0x28(SP), AX	
	if ret >= 0 {
  0x421400		85c0			TESTL AX, AX		
  0x421402		7c0a			JL 0x42140e		
		return
  0x421404		488b6c2448		MOVQ 0x48(SP), BP	
  0x421409		4883c450		ADDQ $0x50, SP		
  0x42140d		c3			RET			
	systemstack(func() {
  0x42140e		0f57c0			XORPS X0, X0				
  0x421411		0f11442430		MOVUPS X0, 0x30(SP)			
  0x421416		c744244000000000	MOVL $0x0, 0x40(SP)			
  0x42141e		488d0d6b490200		LEAQ runtime.futexwakeup.func1(SB), CX	
  0x421425		48894c2430		MOVQ CX, 0x30(SP)			
  0x42142a		488b4c2458		MOVQ 0x58(SP), CX			
  0x42142f		48894c2438		MOVQ CX, 0x38(SP)			
  0x421434		89442440		MOVL AX, 0x40(SP)			
  0x421438		488d442430		LEAQ 0x30(SP), AX			
  0x42143d		48890424		MOVQ AX, 0(SP)				
  0x421441		e8ea620200		CALL runtime.systemstack(SB)		
	*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006
  0x421446		b806100000		MOVL $0x1006, AX	
  0x42144b		c70006100000		MOVL $0x1006, 0(AX)	
}
  0x421451		488b6c2448		MOVQ 0x48(SP), BP	
  0x421456		4883c450		ADDQ $0x50, SP		
  0x42145a		c3			RET			

TEXT runtime.getproccount(SB) /usr/local/go/src/runtime/os_linux.go
func getproccount() int32 {
  0x421460		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421469		488b7110		MOVQ 0x10(CX), SI	
  0x42146d		4881fedefaffff		CMPQ $-0x522, SI	
  0x421474		0f84dd000000		JE 0x421557		
  0x42147a		488d842470030000	LEAQ 0x370(SP), AX	
  0x421482		4829f0			SUBQ SI, AX		
  0x421485		483d18230000		CMPQ $0x2318, AX	
  0x42148b		0f86c6000000		JBE 0x421557		
  0x421491		4881ec28200000		SUBQ $0x2028, SP	
  0x421498		4889ac2420200000	MOVQ BP, 0x2020(SP)	
  0x4214a0		488dac2420200000	LEAQ 0x2020(SP), BP	
	var buf [maxCPUs / 8]byte
  0x4214a8		488d7c2420		LEAQ 0x20(SP), DI	
  0x4214ad		b900040000		MOVL $0x400, CX		
  0x4214b2		31c0			XORL AX, AX		
  0x4214b4		f348ab			REP; STOSQ AX, ES:0(DI)	
	r := sched_getaffinity(0, unsafe.Sizeof(buf), &buf[0])
  0x4214b7		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x4214bf		48c744240800200000	MOVQ $0x2000, 0x8(SP)			
  0x4214c8		488d542420		LEAQ 0x20(SP), DX			
  0x4214cd		4889542410		MOVQ DX, 0x10(SP)			
  0x4214d2		e829a10200		CALL runtime.sched_getaffinity(SB)	
  0x4214d7		8b542418		MOVL 0x18(SP), DX			
	if r < 0 {
  0x4214db		85d2			TESTL DX, DX		
  0x4214dd		7c56			JL 0x421535		
	for _, v := range buf[:r] {
  0x4214df		4863c2			MOVSXD DX, AX		
  0x4214e2		4885c0			TESTQ AX, AX		
  0x4214e5		7c69			JL 0x421550		
  0x4214e7		483d00200000		CMPQ $0x2000, AX	
  0x4214ed		7761			JA 0x421550		
  0x4214ef		31c9			XORL CX, CX		
  0x4214f1		31d2			XORL DX, DX		
  0x4214f3		eb13			JMP 0x421508		
			n += int32(v & 1)
  0x4214f5		89de			MOVL BX, SI		
  0x4214f7		83e301			ANDL $0x1, BX		
  0x4214fa		01da			ADDL BX, DX		
			v >>= 1
  0x4214fc		40d0ee			SHRL $0x1, SI		
		for v != 0 {
  0x4214ff		89f3			MOVL SI, BX		
  0x421501		84db			TESTL BL, BL		
  0x421503		75f0			JNE 0x4214f5		
	for _, v := range buf[:r] {
  0x421505		48ffc1			INCQ CX				
  0x421508		4839c1			CMPQ AX, CX			
  0x42150b		7d07			JGE 0x421514			
  0x42150d		0fb65c0c20		MOVZX 0x20(SP)(CX*1), BX	
		for v != 0 {
  0x421512		ebed			JMP 0x421501		
	if n == 0 {
  0x421514		85d2			TESTL DX, DX		
	return n
  0x421516		b801000000		MOVL $0x1, AX		
  0x42151b		0f44d0			CMOVE AX, DX		
  0x42151e		89942430200000		MOVL DX, 0x2030(SP)	
	if n == 0 {
  0x421525		488bac2420200000	MOVQ 0x2020(SP), BP	
  0x42152d		4881c428200000		ADDQ $0x2028, SP	
  0x421534		c3			RET			
		return 1
  0x421535		c784243020000001000000	MOVL $0x1, 0x2030(SP)	
  0x421540		488bac2420200000	MOVQ 0x2020(SP), BP	
  0x421548		4881c428200000		ADDQ $0x2028, SP	
  0x42154f		c3			RET			
	for _, v := range buf[:r] {
  0x421550		e8fb0a0000		CALL runtime.panicslice(SB)	
  0x421555		0f0b			UD2				
func getproccount() int32 {
  0x421557		e824630200		CALL runtime.morestack_noctxt(SB)	
  0x42155c		e9fffeffff		JMP runtime.getproccount(SB)		

TEXT runtime.newosproc(SB) /usr/local/go/src/runtime/os_linux.go
func newosproc(mp *m) {
  0x421570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421579		483b6110		CMPQ 0x10(CX), SP	
  0x42157d		0f86ac010000		JBE 0x42172f		
  0x421583		4883ec58		SUBQ $0x58, SP		
  0x421587		48896c2450		MOVQ BP, 0x50(SP)	
  0x42158c		488d6c2450		LEAQ 0x50(SP), BP	
	stk := unsafe.Pointer(mp.g0.stack.hi)
  0x421591		488b442460		MOVQ 0x60(SP), AX	
  0x421596		488b00			MOVQ 0(AX), AX		
  0x421599		488b4008		MOVQ 0x8(AX), AX	
  0x42159d		4889442448		MOVQ AX, 0x48(SP)	
	var oset sigset
  0x4215a2		48c744243800000000	MOVQ $0x0, 0x38(SP)	
	sigprocmask(_SIG_SETMASK, &sigset_all, &oset)
  0x4215ab		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x4215ac		c7042402000000		MOVL $0x2, 0(SP)		
  0x4215b3		488d0d96da0900		LEAQ runtime.sigset_all(SB), CX	
  0x4215ba		48894c2408		MOVQ CX, 0x8(SP)		
  0x4215bf		488d4c2438		LEAQ 0x38(SP), CX		
  0x4215c4		48894c2410		MOVQ CX, 0x10(SP)		
  0x4215c9		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x4215d1		e89a9b0200		CALL runtime.rtsigprocmask(SB)	
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x4215d6		488b442460		MOVQ 0x60(SP), AX	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x4215db		488d0d26230500		LEAQ 0x52326(IP), CX	
  0x4215e2		8401			TESTB AL, 0(CX)		
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x4215e4		488b00			MOVQ 0(AX), AX		
  0x4215e7		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x4215e8		488b0d19230500		MOVQ 0x52319(IP), CX	
  0x4215ef		90			NOPL			
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))
  0x4215f0		c70424000f0500		MOVL $0x50f00, 0(SP)	
  0x4215f7		488b542448		MOVQ 0x48(SP), DX	
  0x4215fc		4889542408		MOVQ DX, 0x8(SP)	
  0x421601		488b542460		MOVQ 0x60(SP), DX	
  0x421606		4889542410		MOVQ DX, 0x10(SP)	
  0x42160b		4889442418		MOVQ AX, 0x18(SP)	
  0x421610		48894c2420		MOVQ CX, 0x20(SP)	
  0x421615		e8c69e0200		CALL runtime.clone(SB)	
  0x42161a		8b442428		MOVL 0x28(SP), AX	
  0x42161e		89442434		MOVL AX, 0x34(SP)	
	sigprocmask(_SIG_SETMASK, &oset, nil)
  0x421622		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x421623		c7042402000000		MOVL $0x2, 0(SP)		
  0x42162a		488d4c2438		LEAQ 0x38(SP), CX		
  0x42162f		48894c2408		MOVQ CX, 0x8(SP)		
  0x421634		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42163d		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x421645		e8269b0200		CALL runtime.rtsigprocmask(SB)	
	if ret < 0 {
  0x42164a		8b442434		MOVL 0x34(SP), AX	
  0x42164e		85c0			TESTL AX, AX		
  0x421650		7c0a			JL 0x42165c		
  0x421652		488b6c2450		MOVQ 0x50(SP), BP	
  0x421657		4883c458		ADDQ $0x58, SP		
  0x42165b		c3			RET			
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", -ret, ")\n")
  0x42165c		90			NOPL			
	return int32(sched.mnext - sched.nmfreed)
  0x42165d		488b0564060a00		MOVQ runtime.sched+40(SB), AX	
  0x421664		482b056d060a00		SUBQ runtime.sched+56(SB), AX	
  0x42166b		4889442440		MOVQ AX, 0x40(SP)		
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", -ret, ")\n")
  0x421670		e84b280000		CALL runtime.printlock(SB)	
  0x421675		488d05f0180500		LEAQ 0x518f0(IP), AX		
  0x42167c		48890424		MOVQ AX, 0(SP)			
  0x421680		48c74424082e000000	MOVQ $0x2e, 0x8(SP)		
  0x421689		e862310000		CALL runtime.printstring(SB)	
  0x42168e		488b442440		MOVQ 0x40(SP), AX		
  0x421693		4863c0			MOVSXD AX, AX			
  0x421696		48890424		MOVQ AX, 0(SP)			
  0x42169a		e8a12f0000		CALL runtime.printint(SB)	
  0x42169f		488d0571e80400		LEAQ 0x4e871(IP), AX		
  0x4216a6		48890424		MOVQ AX, 0(SP)			
  0x4216aa		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4216b3		e838310000		CALL runtime.printstring(SB)	
  0x4216b8		8b442434		MOVL 0x34(SP), AX		
  0x4216bc		f7d8			NEGL AX				
  0x4216be		4863c0			MOVSXD AX, AX			
  0x4216c1		48890424		MOVQ AX, 0(SP)			
  0x4216c5		e8762f0000		CALL runtime.printint(SB)	
  0x4216ca		488d05c9d90400		LEAQ 0x4d9c9(IP), AX		
  0x4216d1		48890424		MOVQ AX, 0(SP)			
  0x4216d5		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4216de		e80d310000		CALL runtime.printstring(SB)	
  0x4216e3		e858280000		CALL runtime.printunlock(SB)	
		if ret == -_EAGAIN {
  0x4216e8		8b442434		MOVL 0x34(SP), AX	
  0x4216ec		83f8f5			CMPL $-0xb, AX		
  0x4216ef		7523			JNE 0x421714		
			println("runtime: may need to increase max user processes (ulimit -u)")
  0x4216f1		e8ca270000		CALL runtime.printlock(SB)	
  0x4216f6		488d05711e0500		LEAQ 0x51e71(IP), AX		
  0x4216fd		48890424		MOVQ AX, 0(SP)			
  0x421701		48c74424083d000000	MOVQ $0x3d, 0x8(SP)		
  0x42170a		e8e1300000		CALL runtime.printstring(SB)	
  0x42170f		e82c280000		CALL runtime.printunlock(SB)	
		throw("newosproc")
  0x421714		488d0583de0400		LEAQ 0x4de83(IP), AX	
  0x42171b		48890424		MOVQ AX, 0(SP)		
  0x42171f		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x421728		e8531d0000		CALL runtime.throw(SB)	
  0x42172d		0f0b			UD2			
func newosproc(mp *m) {
  0x42172f		e84c610200		CALL runtime.morestack_noctxt(SB)	
  0x421734		e937feffff		JMP runtime.newosproc(SB)		

TEXT runtime.sysargs(SB) /usr/local/go/src/runtime/os_linux.go
func sysargs(argc int32, argv **byte) {
  0x421740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421749		488d842430fcffff	LEAQ 0xfffffc30(SP), AX	
  0x421751		483b4110		CMPQ 0x10(CX), AX	
  0x421755		0f864c020000		JBE 0x4219a7		
  0x42175b		4881ec50040000		SUBQ $0x450, SP		
  0x421762		4889ac2448040000	MOVQ BP, 0x448(SP)	
  0x42176a		488dac2448040000	LEAQ 0x448(SP), BP	
	n := argc + 1
  0x421772		8b842458040000		MOVL 0x458(SP), AX	
  0x421779		ffc0			INCL AX			
	for argv_index(argv, n) != nil {
  0x42177b		488b8c2460040000	MOVQ 0x460(SP), CX	
  0x421783		eb02			JMP 0x421787		
		n++
  0x421785		ffc0			INCL AX			
	for argv_index(argv, n) != nil {
  0x421787		90			NOPL			
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x421788		4863d0			MOVSXD AX, DX		
  0x42178b		488b14d1		MOVQ 0(CX)(DX*8), DX	
  0x42178f		90			NOPL			
	for argv_index(argv, n) != nil {
  0x421790		4885d2			TESTQ DX, DX		
  0x421793		75f0			JNE 0x421785		
	n++
  0x421795		ffc0			INCL AX			
	auxv := (*[1 << 28]uintptr)(add(unsafe.Pointer(argv), uintptr(n)*sys.PtrSize))
  0x421797		90			NOPL			
  0x421798		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x42179b		488d04c1		LEAQ 0(CX)(AX*8), AX	
	if sysauxv(auxv[:]) != 0 {
  0x42179f		48890424		MOVQ AX, 0(SP)			
  0x4217a3		48c744240800000010	MOVQ $0x10000000, 0x8(SP)	
  0x4217ac		48c744241000000010	MOVQ $0x10000000, 0x10(SP)	
  0x4217b5		e806020000		CALL runtime.sysauxv(SB)	
  0x4217ba		48837c241800		CMPQ $0x0, 0x18(SP)		
  0x4217c0		0f85ca010000		JNE 0x421990			
	fd := open(&procAuxv[0], 0 /* O_RDONLY */, 0)
  0x4217c6		488b0523e50900		MOVQ runtime.procAuxv(SB), AX		
  0x4217cd		48833d23e5090000	CMPQ $0x0, runtime.procAuxv+8(SB)	
  0x4217d5		0f86c5010000		JBE 0x4219a0				
  0x4217db		48890424		MOVQ AX, 0(SP)				
  0x4217df		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x4217e8		e863960200		CALL runtime.open(SB)			
  0x4217ed		8b442410		MOVL 0x10(SP), AX			
	if fd < 0 {
  0x4217f1		85c0			TESTL AX, AX		
  0x4217f3		0f8df1000000		JGE 0x4218ea		
		p, err := mmap(nil, size, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x4217f9		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x421801		48c744240800000400	MOVQ $0x40000, 0x8(SP)	
  0x42180a		48b80300000022000000	MOVQ $0x2200000003, AX	
  0x421814		4889442410		MOVQ AX, 0x10(SP)	
  0x421819		b8ffffffff		MOVL $-0x1, AX		
  0x42181e		4889442418		MOVQ AX, 0x18(SP)	
  0x421823		e8581cfeff		CALL runtime.mmap(SB)	
  0x421828		488b442420		MOVQ 0x20(SP), AX	
  0x42182d		48837c242800		CMPQ $0x0, 0x28(SP)	
		if err != 0 {
  0x421833		0f85a1000000		JNE 0x4218da		
		p, err := mmap(nil, size, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
  0x421839		4889842440040000	MOVQ AX, 0x440(SP)	
  0x421841		b900100000		MOVL $0x1000, CX	
		for n = 4 << 10; n < size; n <<= 1 {
  0x421846		eb10			JMP 0x421858		
  0x421848		488b4c2438		MOVQ 0x38(SP), CX	
  0x42184d		48d1e1			SHLQ $0x1, CX		
			err := mincore(unsafe.Pointer(uintptr(p)+n), 1, &addrspace_vec[0])
  0x421850		488b842440040000	MOVQ 0x440(SP), AX	
		for n = 4 << 10; n < size; n <<= 1 {
  0x421858		4881f900000400		CMPQ $0x40000, CX	
  0x42185f		733a			JAE 0x42189b		
  0x421861		48894c2438		MOVQ CX, 0x38(SP)	
			err := mincore(unsafe.Pointer(uintptr(p)+n), 1, &addrspace_vec[0])
  0x421866		488d1401		LEAQ 0(CX)(AX*1), DX			
  0x42186a		48891424		MOVQ DX, 0(SP)				
  0x42186e		48c744240801000000	MOVQ $0x1, 0x8(SP)			
  0x421877		488d1525b40b00		LEAQ runtime.addrspace_vec(SB), DX	
  0x42187e		4889542410		MOVQ DX, 0x10(SP)			
  0x421883		e848970200		CALL runtime.mincore(SB)		
  0x421888		837c241800		CMPL $0x0, 0x18(SP)			
			if err == 0 {
  0x42188d		75b9			JNE 0x421848		
				physPageSize = n
  0x42188f		488b442438		MOVQ 0x38(SP), AX			
  0x421894		4889050db50b00		MOVQ AX, runtime.physPageSize(SB)	
		if physPageSize == 0 {
  0x42189b		48833d05b50b0000	CMPQ $0x0, runtime.physPageSize(SB)	
  0x4218a3		750b			JNE 0x4218b0				
			physPageSize = size
  0x4218a5		48c705f8b40b0000000400	MOVQ $0x40000, runtime.physPageSize(SB)	
		munmap(p, size)
  0x4218b0		488b842440040000	MOVQ 0x440(SP), AX	
  0x4218b8		48890424		MOVQ AX, 0(SP)		
  0x4218bc		48c744240800000400	MOVQ $0x40000, 0x8(SP)	
  0x4218c5		e8261dfeff		CALL runtime.munmap(SB)	
		return
  0x4218ca		488bac2448040000	MOVQ 0x448(SP), BP	
  0x4218d2		4881c450040000		ADDQ $0x450, SP		
  0x4218d9		c3			RET			
			return
  0x4218da		488bac2448040000	MOVQ 0x448(SP), BP	
  0x4218e2		4881c450040000		ADDQ $0x450, SP		
  0x4218e9		c3			RET			
	fd := open(&procAuxv[0], 0 /* O_RDONLY */, 0)
  0x4218ea		89442430		MOVL AX, 0x30(SP)	
	var buf [128]uintptr
  0x4218ee		488d7c2440		LEAQ 0x40(SP), DI		
  0x4218f3		0f57c0			XORPS X0, X0			
  0x4218f6		48896c24f0		MOVQ BP, -0x10(SP)		
  0x4218fb		488d6c24f0		LEAQ -0x10(SP), BP		
  0x421900		e8eb860200		CALL runtime.duffzero(SB)	
  0x421905		488b6d00		MOVQ 0(BP), BP			
	n = read(fd, noescape(unsafe.Pointer(&buf[0])), int32(unsafe.Sizeof(buf)))
  0x421909		90			NOPL			
  0x42190a		890424			MOVL AX, 0(SP)		
  0x42190d		488d4c2440		LEAQ 0x40(SP), CX	
  0x421912		48894c2408		MOVQ CX, 0x8(SP)	
  0x421917		c744241000040000	MOVL $0x400, 0x10(SP)	
  0x42191f		e8ac950200		CALL runtime.read(SB)	
  0x421924		8b442418		MOVL 0x18(SP), AX	
  0x421928		89442434		MOVL AX, 0x34(SP)	
  0x42192c		83f800			CMPL $0x0, AX		
	closefd(fd)
  0x42192f		8b4c2430		MOVL 0x30(SP), CX		
  0x421933		890c24			MOVL CX, 0(SP)			
  0x421936		e845950200		CALL runtime.closefd(SB)	
	n = read(fd, noescape(unsafe.Pointer(&buf[0])), int32(unsafe.Sizeof(buf)))
  0x42193b		8b442434		MOVL 0x34(SP), AX	
  0x42193f		83f800			CMPL $0x0, AX		
	if n < 0 {
  0x421942		7d10			JGE 0x421954		
		return
  0x421944		488bac2448040000	MOVQ 0x448(SP), BP	
  0x42194c		4881c450040000		ADDQ $0x450, SP		
  0x421953		c3			RET			
	buf[len(buf)-2] = _AT_NULL
  0x421954		48c784243004000000000000	MOVQ $0x0, 0x430(SP)	
	sysauxv(buf[:])
  0x421960		488d442440		LEAQ 0x40(SP), AX		
  0x421965		48890424		MOVQ AX, 0(SP)			
  0x421969		48c744240880000000	MOVQ $0x80, 0x8(SP)		
  0x421972		48c744241080000000	MOVQ $0x80, 0x10(SP)		
  0x42197b		e840000000		CALL runtime.sysauxv(SB)	
}
  0x421980		488bac2448040000	MOVQ 0x448(SP), BP	
  0x421988		4881c450040000		ADDQ $0x450, SP		
  0x42198f		c3			RET			
		return
  0x421990		488bac2448040000	MOVQ 0x448(SP), BP	
  0x421998		4881c450040000		ADDQ $0x450, SP		
  0x42199f		c3			RET			
	fd := open(&procAuxv[0], 0 /* O_RDONLY */, 0)
  0x4219a0		e87b050000		CALL runtime.panicindex(SB)	
  0x4219a5		0f0b			UD2				
func sysargs(argc int32, argv **byte) {
  0x4219a7		e8d45e0200		CALL runtime.morestack_noctxt(SB)	
  0x4219ac		e98ffdffff		JMP runtime.sysargs(SB)			

TEXT runtime.sysauxv(SB) /usr/local/go/src/runtime/os_linux.go
func sysauxv(auxv []uintptr) int {
  0x4219c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4219c9		483b6110		CMPQ 0x10(CX), SP	
  0x4219cd		0f86f0000000		JBE 0x421ac3		
  0x4219d3		4883ec20		SUBQ $0x20, SP		
  0x4219d7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4219dc		488d6c2418		LEAQ 0x18(SP), BP	
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x4219e1		488b4c2428		MOVQ 0x28(SP), CX	
  0x4219e6		488b542430		MOVQ 0x30(SP), DX	
  0x4219eb		31c0			XORL AX, AX		
  0x4219ed		eb22			JMP 0x421a11		
		archauxv(tag, val)
  0x4219ef		90			NOPL			
		vdsoauxv(tag, val)
  0x4219f0		48891c24		MOVQ BX, 0(SP)			
  0x4219f4		4889742408		MOVQ SI, 0x8(SP)		
  0x4219f9		e8422a0200		CALL runtime.vdsoauxv(SB)	
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x4219fe		488b442410		MOVQ 0x10(SP), AX	
  0x421a03		4883c002		ADDQ $0x2, AX		
  0x421a07		488b4c2428		MOVQ 0x28(SP), CX	
  0x421a0c		488b542430		MOVQ 0x30(SP), DX	
  0x421a11		4839d0			CMPQ DX, AX		
  0x421a14		0f83a2000000		JAE 0x421abc		
  0x421a1a		488b1cc1		MOVQ 0(CX)(AX*8), BX	
  0x421a1e		4885db			TESTQ BX, BX		
  0x421a21		7476			JE 0x421a99		
		tag, val := auxv[i], auxv[i+1]
  0x421a23		488d7001		LEAQ 0x1(AX), SI	
  0x421a27		4839d6			CMPQ DX, SI		
  0x421a2a		0f8385000000		JAE 0x421ab5		
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x421a30		4889442410		MOVQ AX, 0x10(SP)	
		tag, val := auxv[i], auxv[i+1]
  0x421a35		488b74c108		MOVQ 0x8(CX)(AX*8), SI	
		case _AT_PAGESZ:
  0x421a3a		4883fb06		CMPQ $0x6, BX		
  0x421a3e		7509			JNE 0x421a49		
			physPageSize = val
  0x421a40		48893561b30b00		MOVQ SI, runtime.physPageSize(SB)	
		switch tag {
  0x421a47		eba6			JMP 0x4219ef		
		case _AT_RANDOM:
  0x421a49		4883fb19		CMPQ $0x19, BX		
  0x421a4d		75a0			JNE 0x4219ef		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x421a4f		4989f0			MOVQ SI, R8					
  0x421a52		8406			TESTB AL, 0(SI)					
  0x421a54		48c70589000a0010000000	MOVQ $0x10, runtime.startupRandomData+8(SB)	
  0x421a5f		48c70586000a0010000000	MOVQ $0x10, runtime.startupRandomData+16(SB)	
  0x421a6a		833dafb30b0000		CMPL $0x0, runtime.writeBarrier(SB)		
  0x421a71		750f			JNE 0x421a82					
  0x421a73		48893566000a00		MOVQ SI, runtime.startupRandomData(SB)		
		vdsoauxv(tag, val)
  0x421a7a		4c89c6			MOVQ R8, SI		
		switch tag {
  0x421a7d		e96dffffff		JMP 0x4219ef		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x421a82		488d3d57000a00		LEAQ runtime.startupRandomData(SB), DI	
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x421a89		4989c1			MOVQ AX, R9		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x421a8c		4889f0			MOVQ SI, AX			
  0x421a8f		e8ec7b0200		CALL runtime.gcWriteBarrier(SB)	
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x421a94		4c89c8			MOVQ R9, AX		
			startupRandomData = (*[16]byte)(unsafe.Pointer(val))[:]
  0x421a97		ebe1			JMP 0x421a7a		
	return i / 2
  0x421a99		4889c1			MOVQ AX, CX		
  0x421a9c		48c1e83f		SHRQ $0x3f, AX		
  0x421aa0		4801c8			ADDQ CX, AX		
  0x421aa3		48d1f8			SARQ $0x1, AX		
  0x421aa6		4889442440		MOVQ AX, 0x40(SP)	
  0x421aab		488b6c2418		MOVQ 0x18(SP), BP	
  0x421ab0		4883c420		ADDQ $0x20, SP		
  0x421ab4		c3			RET			
		tag, val := auxv[i], auxv[i+1]
  0x421ab5		e866040000		CALL runtime.panicindex(SB)	
  0x421aba		0f0b			UD2				
	for ; auxv[i] != _AT_NULL; i += 2 {
  0x421abc		e85f040000		CALL runtime.panicindex(SB)	
  0x421ac1		0f0b			UD2				
func sysauxv(auxv []uintptr) int {
  0x421ac3		e8b85d0200		CALL runtime.morestack_noctxt(SB)	
  0x421ac8		e9f3feffff		JMP runtime.sysauxv(SB)			

TEXT runtime.osinit(SB) /usr/local/go/src/runtime/os_linux.go
func osinit() {
  0x421ad0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421ad9		483b6110		CMPQ 0x10(CX), SP	
  0x421add		7626			JBE 0x421b05		
  0x421adf		4883ec10		SUBQ $0x10, SP		
  0x421ae3		48896c2408		MOVQ BP, 0x8(SP)	
  0x421ae8		488d6c2408		LEAQ 0x8(SP), BP	
	ncpu = getproccount()
  0x421aed		e86ef9ffff		CALL runtime.getproccount(SB)	
  0x421af2		8b0424			MOVL 0(SP), AX			
  0x421af5		8905e9b10b00		MOVL AX, runtime.ncpu(SB)	
}
  0x421afb		488b6c2408		MOVQ 0x8(SP), BP	
  0x421b00		4883c410		ADDQ $0x10, SP		
  0x421b04		c3			RET			
func osinit() {
  0x421b05		e8765d0200		CALL runtime.morestack_noctxt(SB)	
  0x421b0a		ebc4			JMP runtime.osinit(SB)			

TEXT runtime.getRandomData(SB) /usr/local/go/src/runtime/os_linux.go
func getRandomData(r []byte) {
  0x421b10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421b19		483b6110		CMPQ 0x10(CX), SP	
  0x421b1d		0f8633010000		JBE 0x421c56		
  0x421b23		4883ec40		SUBQ $0x40, SP		
  0x421b27		48896c2438		MOVQ BP, 0x38(SP)	
  0x421b2c		488d6c2438		LEAQ 0x38(SP), BP	
	if startupRandomData != nil {
  0x421b31		488b05a8ff0900		MOVQ runtime.startupRandomData(SB), AX		
  0x421b38		488b0da9ff0900		MOVQ runtime.startupRandomData+8(SB), CX	
  0x421b3f		4885c0			TESTQ AX, AX					
  0x421b42		7469			JE 0x421bad					
		n := copy(r, startupRandomData)
  0x421b44		488b542450		MOVQ 0x50(SP), DX	
  0x421b49		4839ca			CMPQ CX, DX		
  0x421b4c		4889d3			MOVQ DX, BX		
  0x421b4f		480f4fd1		CMOVG CX, DX		
  0x421b53		488b4c2448		MOVQ 0x48(SP), CX	
  0x421b58		4839c8			CMPQ CX, AX		
  0x421b5b		7527			JNE 0x421b84		
		extendRandom(r, n)
  0x421b5d		48890c24		MOVQ CX, 0(SP)			
  0x421b61		48895c2408		MOVQ BX, 0x8(SP)		
  0x421b66		488b442458		MOVQ 0x58(SP), AX		
  0x421b6b		4889442410		MOVQ AX, 0x10(SP)		
  0x421b70		4889542418		MOVQ DX, 0x18(SP)		
  0x421b75		e836060100		CALL runtime.extendRandom(SB)	
		return
  0x421b7a		488b6c2438		MOVQ 0x38(SP), BP	
  0x421b7f		4883c440		ADDQ $0x40, SP		
  0x421b83		c3			RET			
		n := copy(r, startupRandomData)
  0x421b84		4889542428		MOVQ DX, 0x28(SP)		
  0x421b89		48890c24		MOVQ CX, 0(SP)			
  0x421b8d		4889442408		MOVQ AX, 0x8(SP)		
  0x421b92		4889542410		MOVQ DX, 0x10(SP)		
  0x421b97		e8b48b0200		CALL runtime.memmove(SB)	
		extendRandom(r, n)
  0x421b9c		488b4c2448		MOVQ 0x48(SP), CX	
  0x421ba1		488b542428		MOVQ 0x28(SP), DX	
  0x421ba6		488b5c2450		MOVQ 0x50(SP), BX	
		n := copy(r, startupRandomData)
  0x421bab		ebb0			JMP 0x421b5d		
	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
  0x421bad		488b055ce10900		MOVQ runtime.urandom_dev(SB), AX	
  0x421bb4		48833d5ce1090000	CMPQ $0x0, runtime.urandom_dev+8(SB)	
  0x421bbc		0f868d000000		JBE 0x421c4f				
  0x421bc2		48890424		MOVQ AX, 0(SP)				
  0x421bc6		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x421bcf		e87c920200		CALL runtime.open(SB)			
  0x421bd4		8b442410		MOVL 0x10(SP), AX			
	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
  0x421bd8		488b4c2450		MOVQ 0x50(SP), CX	
  0x421bdd		4885c9			TESTQ CX, CX		
  0x421be0		7666			JBE 0x421c48		
	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
  0x421be2		89442424		MOVL AX, 0x24(SP)	
	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
  0x421be6		890424			MOVL AX, 0(SP)		
  0x421be9		488b542448		MOVQ 0x48(SP), DX	
  0x421bee		4889542408		MOVQ DX, 0x8(SP)	
  0x421bf3		894c2410		MOVL CX, 0x10(SP)	
  0x421bf7		e8d4920200		CALL runtime.read(SB)	
  0x421bfc		4863442418		MOVSXD 0x18(SP), AX	
  0x421c01		4889442430		MOVQ AX, 0x30(SP)	
	closefd(fd)
  0x421c06		8b4c2424		MOVL 0x24(SP), CX		
  0x421c0a		890c24			MOVL CX, 0(SP)			
  0x421c0d		e86e920200		CALL runtime.closefd(SB)	
	extendRandom(r, int(n))
  0x421c12		488b442448		MOVQ 0x48(SP), AX		
  0x421c17		48890424		MOVQ AX, 0(SP)			
  0x421c1b		488b442450		MOVQ 0x50(SP), AX		
  0x421c20		4889442408		MOVQ AX, 0x8(SP)		
  0x421c25		488b442458		MOVQ 0x58(SP), AX		
  0x421c2a		4889442410		MOVQ AX, 0x10(SP)		
  0x421c2f		488b442430		MOVQ 0x30(SP), AX		
  0x421c34		4889442418		MOVQ AX, 0x18(SP)		
  0x421c39		e872050100		CALL runtime.extendRandom(SB)	
}
  0x421c3e		488b6c2438		MOVQ 0x38(SP), BP	
  0x421c43		4883c440		ADDQ $0x40, SP		
  0x421c47		c3			RET			
	n := read(fd, unsafe.Pointer(&r[0]), int32(len(r)))
  0x421c48		e8d3020000		CALL runtime.panicindex(SB)	
  0x421c4d		0f0b			UD2				
	fd := open(&urandom_dev[0], 0 /* O_RDONLY */, 0)
  0x421c4f		e8cc020000		CALL runtime.panicindex(SB)	
  0x421c54		0f0b			UD2				
func getRandomData(r []byte) {
  0x421c56		e8255c0200		CALL runtime.morestack_noctxt(SB)	
  0x421c5b		e9b0feffff		JMP runtime.getRandomData(SB)		

TEXT runtime.minit(SB) /usr/local/go/src/runtime/os_linux.go
func minit() {
  0x421c60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421c69		483b6110		CMPQ 0x10(CX), SP	
  0x421c6d		7636			JBE 0x421ca5		
  0x421c6f		4883ec10		SUBQ $0x10, SP		
  0x421c73		48896c2408		MOVQ BP, 0x8(SP)	
  0x421c78		488d6c2408		LEAQ 0x8(SP), BP	
	minitSignals()
  0x421c7d		e8ce3a0100		CALL runtime.minitSignals(SB)	
	getg().m.procid = uint64(gettid())
  0x421c82		e8c9920200		CALL runtime.gettid(SB)	
  0x421c87		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x421c90		488b4030		MOVQ 0x30(AX), AX	
  0x421c94		8b0c24			MOVL 0(SP), CX		
  0x421c97		48894848		MOVQ CX, 0x48(AX)	
}
  0x421c9b		488b6c2408		MOVQ 0x8(SP), BP	
  0x421ca0		4883c410		ADDQ $0x10, SP		
  0x421ca4		c3			RET			
func minit() {
  0x421ca5		e8d65b0200		CALL runtime.morestack_noctxt(SB)	
  0x421caa		ebb4			JMP runtime.minit(SB)			

TEXT runtime.setsig(SB) /usr/local/go/src/runtime/os_linux.go
func setsig(i uint32, fn uintptr) {
  0x421cb0		4883ec40		SUBQ $0x40, SP		
  0x421cb4		48896c2438		MOVQ BP, 0x38(SP)	
  0x421cb9		488d6c2438		LEAQ 0x38(SP), BP	
	var sa sigactiont
  0x421cbe		0f57c0			XORPS X0, X0		
  0x421cc1		0f11442418		MOVUPS X0, 0x18(SP)	
  0x421cc6		0f11442428		MOVUPS X0, 0x28(SP)	
	sa.sa_flags = _SA_SIGINFO | _SA_ONSTACK | _SA_RESTORER | _SA_RESTART
  0x421ccb		48c74424200400001c	MOVQ $0x1c000004, 0x20(SP)	
	sigfillset(&sa.sa_mask)
  0x421cd4		90			NOPL			
	*mask = ^uint64(0)
  0x421cd5		48c7442430ffffffff	MOVQ $-0x1, 0x30(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421cde		488d05931c0500		LEAQ 0x51c93(IP), AX	
  0x421ce5		8400			TESTB AL, 0(AX)		
		sa.sa_restorer = funcPC(sigreturn)
  0x421ce7		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421ce8		488b05891c0500		MOVQ 0x51c89(IP), AX	
  0x421cef		90			NOPL			
		sa.sa_restorer = funcPC(sigreturn)
  0x421cf0		4889442428		MOVQ AX, 0x28(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421cf5		488d056c1c0500		LEAQ 0x51c6c(IP), AX	
  0x421cfc		8400			TESTB AL, 0(AX)		
	if fn == funcPC(sighandler) {
  0x421cfe		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421cff		90			NOPL			
  0x421d00		488b442450		MOVQ 0x50(SP), AX	
  0x421d05		4839055c1c0500		CMPQ AX, 0x51c5c(IP)	
	if fn == funcPC(sighandler) {
  0x421d0c		751b			JNE 0x421d29		
		if iscgo {
  0x421d0e		803d99af0b0000		CMPB $0x0, runtime.iscgo(SB)	
  0x421d15		7440			JE 0x421d57			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421d17		488d055a1a0500		LEAQ 0x51a5a(IP), AX	
  0x421d1e		8400			TESTB AL, 0(AX)		
			fn = funcPC(cgoSigtramp)
  0x421d20		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421d21		488b05501a0500		MOVQ 0x51a50(IP), AX	
  0x421d28		90			NOPL			
	sa.sa_handler = fn
  0x421d29		4889442418		MOVQ AX, 0x18(SP)	
	sigaction(i, &sa, nil)
  0x421d2e		8b442448		MOVL 0x48(SP), AX		
  0x421d32		890424			MOVL AX, 0(SP)			
  0x421d35		488d442418		LEAQ 0x18(SP), AX		
  0x421d3a		4889442408		MOVQ AX, 0x8(SP)		
  0x421d3f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x421d48		e84319feff		CALL runtime.sigaction(SB)	
}
  0x421d4d		488b6c2438		MOVQ 0x38(SP), BP	
  0x421d52		4883c440		ADDQ $0x40, SP		
  0x421d56		c3			RET			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421d57		488d0d221c0500		LEAQ 0x51c22(IP), CX	
  0x421d5e		8401			TESTB AL, 0(CX)		
			fn = funcPC(sigtramp)
  0x421d60		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x421d61		488b05181c0500		MOVQ 0x51c18(IP), AX	
  0x421d68		90			NOPL			
			fn = funcPC(sigtramp)
  0x421d69		ebbe			JMP 0x421d29		

TEXT runtime.setsigstack(SB) /usr/local/go/src/runtime/os_linux.go
func setsigstack(i uint32) {
  0x421d70		4883ec40		SUBQ $0x40, SP		
  0x421d74		48896c2438		MOVQ BP, 0x38(SP)	
  0x421d79		488d6c2438		LEAQ 0x38(SP), BP	
	var sa sigactiont
  0x421d7e		0f57c0			XORPS X0, X0		
  0x421d81		0f11442418		MOVUPS X0, 0x18(SP)	
  0x421d86		0f11442428		MOVUPS X0, 0x28(SP)	
	sigaction(i, nil, &sa)
  0x421d8b		8b442448		MOVL 0x48(SP), AX		
  0x421d8f		890424			MOVL AX, 0(SP)			
  0x421d92		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x421d9b		488d4c2418		LEAQ 0x18(SP), CX		
  0x421da0		48894c2410		MOVQ CX, 0x10(SP)		
  0x421da5		e8e618feff		CALL runtime.sigaction(SB)	
	if sa.sa_flags&_SA_ONSTACK != 0 {
  0x421daa		488b442420		MOVQ 0x20(SP), AX	
  0x421daf		0fbae01b		BTL $0x1b, AX		
  0x421db3		730a			JAE 0x421dbf		
		return
  0x421db5		488b6c2438		MOVQ 0x38(SP), BP	
  0x421dba		4883c440		ADDQ $0x40, SP		
  0x421dbe		c3			RET			
	sa.sa_flags |= _SA_ONSTACK
  0x421dbf		480fbae81b		BTSQ $0x1b, AX		
  0x421dc4		4889442420		MOVQ AX, 0x20(SP)	
	sigaction(i, &sa, nil)
  0x421dc9		8b442448		MOVL 0x48(SP), AX		
  0x421dcd		890424			MOVL AX, 0(SP)			
  0x421dd0		488d442418		LEAQ 0x18(SP), AX		
  0x421dd5		4889442408		MOVQ AX, 0x8(SP)		
  0x421dda		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x421de3		e8a818feff		CALL runtime.sigaction(SB)	
}
  0x421de8		488b6c2438		MOVQ 0x38(SP), BP	
  0x421ded		4883c440		ADDQ $0x40, SP		
  0x421df1		c3			RET			

TEXT runtime.sysSigaction(SB) /usr/local/go/src/runtime/os_linux.go
func sysSigaction(sig uint32, new, old *sigactiont) {
  0x421e00		4883ec30		SUBQ $0x30, SP		
  0x421e04		48896c2428		MOVQ BP, 0x28(SP)	
  0x421e09		488d6c2428		LEAQ 0x28(SP), BP	
	if rt_sigaction(uintptr(sig), new, old, unsafe.Sizeof(sigactiont{}.sa_mask)) != 0 {
  0x421e0e		8b442438		MOVL 0x38(SP), AX		
  0x421e12		48890424		MOVQ AX, 0(SP)			
  0x421e16		488b4c2440		MOVQ 0x40(SP), CX		
  0x421e1b		48894c2408		MOVQ CX, 0x8(SP)		
  0x421e20		488b4c2448		MOVQ 0x48(SP), CX		
  0x421e25		48894c2410		MOVQ CX, 0x10(SP)		
  0x421e2a		48c744241808000000	MOVQ $0x8, 0x18(SP)		
  0x421e33		e868930200		CALL runtime.rt_sigaction(SB)	
  0x421e38		837c242000		CMPL $0x0, 0x20(SP)		
  0x421e3d		7413			JE 0x421e52			
		if sig != 32 && sig != 33 && sig != 64 {
  0x421e3f		8b442438		MOVL 0x38(SP), AX	
  0x421e43		83f820			CMPL $0x20, AX		
  0x421e46		740a			JE 0x421e52		
  0x421e48		83f821			CMPL $0x21, AX		
  0x421e4b		7405			JE 0x421e52		
  0x421e4d		83f840			CMPL $0x40, AX		
  0x421e50		750a			JNE 0x421e5c		
  0x421e52		488b6c2428		MOVQ 0x28(SP), BP	
  0x421e57		4883c430		ADDQ $0x30, SP		
  0x421e5b		c3			RET			
			systemstack(func() {
  0x421e5c		488d05451b0500		LEAQ 0x51b45(IP), AX		
  0x421e63		48890424		MOVQ AX, 0(SP)			
  0x421e67		e8c4580200		CALL runtime.systemstack(SB)	
  0x421e6c		ebe4			JMP 0x421e52			

TEXT runtime.panicCheckMalloc(SB) /usr/local/go/src/runtime/panic.go
func panicCheckMalloc(err error) {
  0x421e70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421e79		483b6110		CMPQ 0x10(CX), SP	
  0x421e7d		0f8688000000		JBE 0x421f0b		
  0x421e83		4883ec20		SUBQ $0x20, SP		
  0x421e87		48896c2418		MOVQ BP, 0x18(SP)	
  0x421e8c		488d6c2418		LEAQ 0x18(SP), BP	
	gp := getg()
  0x421e91		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != nil && gp.m != nil && gp.m.mallocing != 0 {
  0x421e9a		4885c0			TESTQ AX, AX		
  0x421e9d		7412			JE 0x421eb1		
  0x421e9f		488b4030		MOVQ 0x30(AX), AX	
  0x421ea3		4885c0			TESTQ AX, AX		
  0x421ea6		7409			JE 0x421eb1		
  0x421ea8		83b8f000000000		CMPL $0x0, 0xf0(AX)	
  0x421eaf		750a			JNE 0x421ebb		
  0x421eb1		488b6c2418		MOVQ 0x18(SP), BP	
  0x421eb6		4883c420		ADDQ $0x20, SP		
  0x421eba		c3			RET			
		throw(string(err.(errorString)))
  0x421ebb		488b442428		MOVQ 0x28(SP), AX				
  0x421ec0		488d0d19bc0500		LEAQ go.itab.runtime.errorString,error(SB), CX	
  0x421ec7		4839c8			CMPQ CX, AX					
  0x421eca		751c			JNE 0x421ee8					
  0x421ecc		488b442430		MOVQ 0x30(SP), AX				
  0x421ed1		488b4808		MOVQ 0x8(AX), CX				
  0x421ed5		488b00			MOVQ 0(AX), AX					
  0x421ed8		48890424		MOVQ AX, 0(SP)					
  0x421edc		48894c2408		MOVQ CX, 0x8(SP)				
  0x421ee1		e89a150000		CALL runtime.throw(SB)				
  0x421ee6		0f0b			UD2						
  0x421ee8		48890424		MOVQ AX, 0(SP)					
  0x421eec		488d05edd00300		LEAQ 0x3d0ed(IP), AX				
  0x421ef3		4889442408		MOVQ AX, 0x8(SP)				
  0x421ef8		488d0541df0300		LEAQ 0x3df41(IP), AX				
  0x421eff		4889442410		MOVQ AX, 0x10(SP)				
  0x421f04		e8a762feff		CALL runtime.panicdottypeI(SB)			
  0x421f09		0f0b			UD2						
func panicCheckMalloc(err error) {
  0x421f0b		e870590200		CALL runtime.morestack_noctxt(SB)	
  0x421f10		e95bffffff		JMP runtime.panicCheckMalloc(SB)	

TEXT runtime.panicindex(SB) /usr/local/go/src/runtime/panic.go
func panicindex() {
  0x421f20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x421f29		483b6110		CMPQ 0x10(CX), SP	
  0x421f2d		0f860d010000		JBE 0x422040		
  0x421f33		4883ec28		SUBQ $0x28, SP		
  0x421f37		48896c2420		MOVQ BP, 0x20(SP)	
  0x421f3c		488d6c2420		LEAQ 0x20(SP), BP	
	if hasPrefix(funcname(findfunc(getcallerpc())), "runtime.") {
  0x421f41		488b442428		MOVQ 0x28(SP), AX		
  0x421f46		48890424		MOVQ AX, 0(SP)			
  0x421f4a		e8b18b0100		CALL runtime.findfunc(SB)	
  0x421f4f		488b442408		MOVQ 0x8(SP), AX		
  0x421f54		488b4c2410		MOVQ 0x10(SP), CX		
  0x421f59		48890424		MOVQ AX, 0(SP)			
  0x421f5d		48894c2408		MOVQ CX, 0x8(SP)		
  0x421f62		e8d9920100		CALL runtime.funcname(SB)	
  0x421f67		90			NOPL				
  0x421f68		488b442410		MOVQ 0x10(SP), AX		
  0x421f6d		48837c241808		CMPQ $0x8, 0x18(SP)		
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x421f73		7d70			JGE 0x421fe5		
  0x421f75		31c0			XORL AX, AX		
	if hasPrefix(funcname(findfunc(getcallerpc())), "runtime.") {
  0x421f77		84c0			TESTL AL, AL		
  0x421f79		7435			JE 0x421fb0		
		throw(string(indexError.(errorString)))
  0x421f7b		488b051edc0900		MOVQ runtime.indexError(SB), AX			
  0x421f82		488b0d1fdc0900		MOVQ runtime.indexError+8(SB), CX		
  0x421f89		488d1550bb0500		LEAQ go.itab.runtime.errorString,error(SB), DX	
  0x421f90		4839d0			CMPQ DX, AX					
  0x421f93		0f8584000000		JNE 0x42201d					
  0x421f99		488b4108		MOVQ 0x8(CX), AX				
  0x421f9d		488b09			MOVQ 0(CX), CX					
  0x421fa0		48890c24		MOVQ CX, 0(SP)					
  0x421fa4		4889442408		MOVQ AX, 0x8(SP)				
  0x421fa9		e8d2140000		CALL runtime.throw(SB)				
  0x421fae		0f0b			UD2						
	panicCheckMalloc(indexError)
  0x421fb0		488b05f1db0900		MOVQ runtime.indexError+8(SB), AX	
  0x421fb7		488b0de2db0900		MOVQ runtime.indexError(SB), CX		
  0x421fbe		48890c24		MOVQ CX, 0(SP)				
  0x421fc2		4889442408		MOVQ AX, 0x8(SP)			
  0x421fc7		e8a4feffff		CALL runtime.panicCheckMalloc(SB)	
	panic(indexError)
  0x421fcc		488b05cddb0900		MOVQ runtime.indexError(SB), AX		
  0x421fd3		488b0dcedb0900		MOVQ runtime.indexError+8(SB), CX	
  0x421fda		4885c0			TESTQ AX, AX				
  0x421fdd		742e			JE 0x42200d				
  0x421fdf		488b4008		MOVQ 0x8(AX), AX			
  0x421fe3		eb28			JMP 0x42200d				
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x421fe5		48890424		MOVQ AX, 0(SP)			
  0x421fe9		488d0588d40400		LEAQ 0x4d488(IP), AX		
  0x421ff0		4889442408		MOVQ AX, 0x8(SP)		
  0x421ff5		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x421ffe		e81d02feff		CALL runtime.memequal(SB)	
  0x422003		0fb6442418		MOVZX 0x18(SP), AX		
  0x422008		e96affffff		JMP 0x421f77			
	panic(indexError)
  0x42200d		48890424		MOVQ AX, 0(SP)			
  0x422011		48894c2408		MOVQ CX, 0x8(SP)		
  0x422016		e8950e0000		CALL runtime.gopanic(SB)	
  0x42201b		0f0b			UD2				
		throw(string(indexError.(errorString)))
  0x42201d		48890424		MOVQ AX, 0(SP)			
  0x422021		488d05b8cf0300		LEAQ 0x3cfb8(IP), AX		
  0x422028		4889442408		MOVQ AX, 0x8(SP)		
  0x42202d		488d050cde0300		LEAQ 0x3de0c(IP), AX		
  0x422034		4889442410		MOVQ AX, 0x10(SP)		
  0x422039		e87261feff		CALL runtime.panicdottypeI(SB)	
  0x42203e		0f0b			UD2				
func panicindex() {
  0x422040		e83b580200		CALL runtime.morestack_noctxt(SB)	
  0x422045		e9d6feffff		JMP runtime.panicindex(SB)		

TEXT runtime.panicslice(SB) /usr/local/go/src/runtime/panic.go
func panicslice() {
  0x422050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422059		483b6110		CMPQ 0x10(CX), SP	
  0x42205d		0f860d010000		JBE 0x422170		
  0x422063		4883ec28		SUBQ $0x28, SP		
  0x422067		48896c2420		MOVQ BP, 0x20(SP)	
  0x42206c		488d6c2420		LEAQ 0x20(SP), BP	
	if hasPrefix(funcname(findfunc(getcallerpc())), "runtime.") {
  0x422071		488b442428		MOVQ 0x28(SP), AX		
  0x422076		48890424		MOVQ AX, 0(SP)			
  0x42207a		e8818a0100		CALL runtime.findfunc(SB)	
  0x42207f		488b442408		MOVQ 0x8(SP), AX		
  0x422084		488b4c2410		MOVQ 0x10(SP), CX		
  0x422089		48890424		MOVQ AX, 0(SP)			
  0x42208d		48894c2408		MOVQ CX, 0x8(SP)		
  0x422092		e8a9910100		CALL runtime.funcname(SB)	
  0x422097		90			NOPL				
  0x422098		488b442410		MOVQ 0x10(SP), AX		
  0x42209d		48837c241808		CMPQ $0x8, 0x18(SP)		
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4220a3		7d70			JGE 0x422115		
  0x4220a5		31c0			XORL AX, AX		
	if hasPrefix(funcname(findfunc(getcallerpc())), "runtime.") {
  0x4220a7		84c0			TESTL AL, AL		
  0x4220a9		7435			JE 0x4220e0		
		throw(string(sliceError.(errorString)))
  0x4220ab		488b052edb0900		MOVQ runtime.sliceError(SB), AX			
  0x4220b2		488b0d2fdb0900		MOVQ runtime.sliceError+8(SB), CX		
  0x4220b9		488d1520ba0500		LEAQ go.itab.runtime.errorString,error(SB), DX	
  0x4220c0		4839d0			CMPQ DX, AX					
  0x4220c3		0f8584000000		JNE 0x42214d					
  0x4220c9		488b4108		MOVQ 0x8(CX), AX				
  0x4220cd		488b09			MOVQ 0(CX), CX					
  0x4220d0		48890c24		MOVQ CX, 0(SP)					
  0x4220d4		4889442408		MOVQ AX, 0x8(SP)				
  0x4220d9		e8a2130000		CALL runtime.throw(SB)				
  0x4220de		0f0b			UD2						
	panicCheckMalloc(sliceError)
  0x4220e0		488b0501db0900		MOVQ runtime.sliceError+8(SB), AX	
  0x4220e7		488b0df2da0900		MOVQ runtime.sliceError(SB), CX		
  0x4220ee		48890c24		MOVQ CX, 0(SP)				
  0x4220f2		4889442408		MOVQ AX, 0x8(SP)			
  0x4220f7		e874fdffff		CALL runtime.panicCheckMalloc(SB)	
	panic(sliceError)
  0x4220fc		488b05ddda0900		MOVQ runtime.sliceError(SB), AX		
  0x422103		488b0ddeda0900		MOVQ runtime.sliceError+8(SB), CX	
  0x42210a		4885c0			TESTQ AX, AX				
  0x42210d		742e			JE 0x42213d				
  0x42210f		488b4008		MOVQ 0x8(AX), AX			
  0x422113		eb28			JMP 0x42213d				
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x422115		48890424		MOVQ AX, 0(SP)			
  0x422119		488d0558d30400		LEAQ 0x4d358(IP), AX		
  0x422120		4889442408		MOVQ AX, 0x8(SP)		
  0x422125		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x42212e		e8ed00feff		CALL runtime.memequal(SB)	
  0x422133		0fb6442418		MOVZX 0x18(SP), AX		
  0x422138		e96affffff		JMP 0x4220a7			
	panic(sliceError)
  0x42213d		48890424		MOVQ AX, 0(SP)			
  0x422141		48894c2408		MOVQ CX, 0x8(SP)		
  0x422146		e8650d0000		CALL runtime.gopanic(SB)	
  0x42214b		0f0b			UD2				
		throw(string(sliceError.(errorString)))
  0x42214d		48890424		MOVQ AX, 0(SP)			
  0x422151		488d0588ce0300		LEAQ 0x3ce88(IP), AX		
  0x422158		4889442408		MOVQ AX, 0x8(SP)		
  0x42215d		488d05dcdc0300		LEAQ 0x3dcdc(IP), AX		
  0x422164		4889442410		MOVQ AX, 0x10(SP)		
  0x422169		e84260feff		CALL runtime.panicdottypeI(SB)	
  0x42216e		0f0b			UD2				
func panicslice() {
  0x422170		e80b570200		CALL runtime.morestack_noctxt(SB)	
  0x422175		e9d6feffff		JMP runtime.panicslice(SB)		

TEXT runtime.panicdivide(SB) /usr/local/go/src/runtime/panic.go
func panicdivide() {
  0x422180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422189		483b6110		CMPQ 0x10(CX), SP	
  0x42218d		7651			JBE 0x4221e0		
  0x42218f		4883ec18		SUBQ $0x18, SP		
  0x422193		48896c2410		MOVQ BP, 0x10(SP)	
  0x422198		488d6c2410		LEAQ 0x10(SP), BP	
	panicCheckMalloc(divideError)
  0x42219d		488b05e4d90900		MOVQ runtime.divideError+8(SB), AX	
  0x4221a4		488b0dd5d90900		MOVQ runtime.divideError(SB), CX	
  0x4221ab		48890c24		MOVQ CX, 0(SP)				
  0x4221af		4889442408		MOVQ AX, 0x8(SP)			
  0x4221b4		e8b7fcffff		CALL runtime.panicCheckMalloc(SB)	
	panic(divideError)
  0x4221b9		488b05c0d90900		MOVQ runtime.divideError(SB), AX	
  0x4221c0		488b0dc1d90900		MOVQ runtime.divideError+8(SB), CX	
  0x4221c7		4885c0			TESTQ AX, AX				
  0x4221ca		7404			JE 0x4221d0				
  0x4221cc		488b4008		MOVQ 0x8(AX), AX			
  0x4221d0		48890424		MOVQ AX, 0(SP)				
  0x4221d4		48894c2408		MOVQ CX, 0x8(SP)			
  0x4221d9		e8d20c0000		CALL runtime.gopanic(SB)		
  0x4221de		0f0b			UD2					
func panicdivide() {
  0x4221e0		e89b560200		CALL runtime.morestack_noctxt(SB)	
  0x4221e5		eb99			JMP runtime.panicdivide(SB)		

TEXT runtime.throwinit(SB) /usr/local/go/src/runtime/panic.go
func throwinit() {
  0x4221f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4221f9		483b6110		CMPQ 0x10(CX), SP	
  0x4221fd		7629			JBE 0x422228		
  0x4221ff		4883ec18		SUBQ $0x18, SP		
  0x422203		48896c2410		MOVQ BP, 0x10(SP)	
  0x422208		488d6c2410		LEAQ 0x10(SP), BP	
	throw("recursive call during initialization - linker skew")
  0x42220d		488d05f30f0500		LEAQ 0x50ff3(IP), AX	
  0x422214		48890424		MOVQ AX, 0(SP)		
  0x422218		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x422221		e85a120000		CALL runtime.throw(SB)	
  0x422226		0f0b			UD2			
func throwinit() {
  0x422228		e853560200		CALL runtime.morestack_noctxt(SB)	
  0x42222d		ebc1			JMP runtime.throwinit(SB)		

TEXT runtime.deferproc(SB) /usr/local/go/src/runtime/panic.go
func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn
  0x422230		4883ec28		SUBQ $0x28, SP		
  0x422234		48896c2420		MOVQ BP, 0x20(SP)	
  0x422239		488d6c2420		LEAQ 0x20(SP), BP	
	if getg().m.curg != getg() {
  0x42223e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x422247		488b4830		MOVQ 0x30(AX), CX	
  0x42224b		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x422252		0f85df000000		JNE 0x422337		
	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
  0x422258		488d442438		LEAQ 0x38(SP), AX	
  0x42225d		4889442418		MOVQ AX, 0x18(SP)	
	d := newdefer(siz)
  0x422262		8b4c2430		MOVL 0x30(SP), CX		
  0x422266		890c24			MOVL CX, 0(SP)			
  0x422269		e8b2030000		CALL runtime.newdefer(SB)	
  0x42226e		488b442408		MOVQ 0x8(SP), AX		
	if d._panic != nil {
  0x422273		4883782000		CMPQ $0x0, 0x20(AX)	
  0x422278		0f859e000000		JNE 0x42231c		
	d.fn = fn
  0x42227e		488b4c2438		MOVQ 0x38(SP), CX			
  0x422283		833d96ab0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42228a		7579			JNE 0x422305				
  0x42228c		48894818		MOVQ CX, 0x18(AX)			
	d.pc = callerpc
  0x422290		488b4c2428		MOVQ 0x28(SP), CX	
  0x422295		48894810		MOVQ CX, 0x10(AX)	
	d.sp = sp
  0x422299		488d4c2430		LEAQ 0x30(SP), CX	
  0x42229e		48894808		MOVQ CX, 0x8(AX)	
	case 0:
  0x4222a2		8b4c2430		MOVL 0x30(SP), CX	
  0x4222a6		85c9			TESTL CX, CX		
  0x4222a8		750f			JNE 0x4222b9		
	return0()
  0x4222aa		e8b1730200		CALL runtime.return0(SB)	
}
  0x4222af		488b6c2420		MOVQ 0x20(SP), BP	
  0x4222b4		4883c428		ADDQ $0x28, SP		
  0x4222b8		c3			RET			
	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
  0x4222b9		488b542418		MOVQ 0x18(SP), DX	
  0x4222be		4883c208		ADDQ $0x8, DX		
	case sys.PtrSize:
  0x4222c2		83f908			CMPL $0x8, CX		
  0x4222c5		7517			JNE 0x4222de		
		*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
  0x4222c7		90			NOPL			
	if d.siz == 0 {
  0x4222c8		833800			CMPL $0x0, 0(AX)	
  0x4222cb		750a			JNE 0x4222d7		
  0x4222cd		31c0			XORL AX, AX		
		*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
  0x4222cf		488b0a			MOVQ 0(DX), CX		
  0x4222d2		488908			MOVQ CX, 0(AX)		
	switch siz {
  0x4222d5		ebd3			JMP 0x4222aa		
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x4222d7		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x4222d8		4883c030		ADDQ $0x30, AX		
		*(*uintptr)(deferArgs(d)) = *(*uintptr)(unsafe.Pointer(argp))
  0x4222dc		ebf1			JMP 0x4222cf		
		memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
  0x4222de		90			NOPL			
	if d.siz == 0 {
  0x4222df		833800			CMPL $0x0, 0(AX)	
  0x4222e2		751a			JNE 0x4222fe		
  0x4222e4		31c0			XORL AX, AX		
		memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
  0x4222e6		48890424		MOVQ AX, 0(SP)			
  0x4222ea		4889542408		MOVQ DX, 0x8(SP)		
  0x4222ef		4863c1			MOVSXD CX, AX			
  0x4222f2		4889442410		MOVQ AX, 0x10(SP)		
  0x4222f7		e854840200		CALL runtime.memmove(SB)	
	switch siz {
  0x4222fc		ebac			JMP 0x4222aa		
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x4222fe		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x4222ff		4883c030		ADDQ $0x30, AX		
		memmove(deferArgs(d), unsafe.Pointer(argp), uintptr(siz))
  0x422303		ebe1			JMP 0x4222e6		
	d.fn = fn
  0x422305		488d7818		LEAQ 0x18(AX), DI	
	d := newdefer(siz)
  0x422309		4889c2			MOVQ AX, DX		
	d.fn = fn
  0x42230c		4889c8			MOVQ CX, AX			
  0x42230f		e86c730200		CALL runtime.gcWriteBarrier(SB)	
	d.pc = callerpc
  0x422314		4889d0			MOVQ DX, AX		
	d.fn = fn
  0x422317		e974ffffff		JMP 0x422290		
		throw("deferproc: d.panic != nil after newdefer")
  0x42231c		488d054f060500		LEAQ 0x5064f(IP), AX	
  0x422323		48890424		MOVQ AX, 0(SP)		
  0x422327		48c744240828000000	MOVQ $0x28, 0x8(SP)	
  0x422330		e84b110000		CALL runtime.throw(SB)	
  0x422335		0f0b			UD2			
		throw("defer on system stack")
  0x422337		488d05f0e40400		LEAQ 0x4e4f0(IP), AX	
  0x42233e		48890424		MOVQ AX, 0(SP)		
  0x422342		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42234b		e830110000		CALL runtime.throw(SB)	
  0x422350		0f0b			UD2			

TEXT runtime.testdefersizes(SB) /usr/local/go/src/runtime/panic.go
func testdefersizes() {
  0x422360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422369		483b6110		CMPQ 0x10(CX), SP	
  0x42236d		0f8631020000		JBE 0x4225a4		
  0x422373		4883ec48		SUBQ $0x48, SP		
  0x422377		48896c2440		MOVQ BP, 0x40(SP)	
  0x42237c		488d6c2440		LEAQ 0x40(SP), BP	
	var m [len(p{}.deferpool)]int32
  0x422381		48c744242c00000000	MOVQ $0x0, 0x2c(SP)	
  0x42238a		0f57c0			XORPS X0, X0		
  0x42238d		0f11442430		MOVUPS X0, 0x30(SP)	
  0x422392		31c0			XORL AX, AX		
	for i := range m {
  0x422394		eb13			JMP 0x4223a9		
		m[i] = -1
  0x422396		4889c1			MOVQ AX, CX			
  0x422399		48c1e002		SHLQ $0x2, AX			
  0x42239d		c744042cffffffff	MOVL $-0x1, 0x2c(SP)(AX*1)	
	for i := range m {
  0x4223a5		488d4101		LEAQ 0x1(CX), AX	
  0x4223a9		4883f805		CMPQ $0x5, AX		
  0x4223ad		7ce7			JL 0x422396		
  0x4223af		31c0			XORL AX, AX		
		defersc := deferclass(i)
  0x4223b1		eb03			JMP 0x4223b6		
	for i := uintptr(0); ; i++ {
  0x4223b3		48ffc0			INCQ AX			
		defersc := deferclass(i)
  0x4223b6		90			NOPL			
	if siz <= minDeferArgs {
  0x4223b7		4885c0			TESTQ AX, AX		
  0x4223ba		0f871b010000		JA 0x4224db		
  0x4223c0		31c9			XORL CX, CX		
		if defersc >= uintptr(len(m)) {
  0x4223c2		4883f905		CMPQ $0x5, CX		
  0x4223c6		0f8305010000		JAE 0x4224d1		
		siz := roundupsize(totaldefersize(i))
  0x4223cc		90			NOPL			
	if siz <= minDeferArgs {
  0x4223cd		4885c0			TESTQ AX, AX		
	if siz <= minDeferArgs {
  0x4223d0		0f87f2000000		JA 0x4224c8		
  0x4223d6		ba30000000		MOVL $0x30, DX		
		siz := roundupsize(totaldefersize(i))
  0x4223db		90			NOPL			
	if size < _MaxSmallSize {
  0x4223dc		4881fa00800000		CMPQ $0x8000, DX	
  0x4223e3		0f83a1000000		JAE 0x42248a		
		if size <= smallSizeMax-8 {
  0x4223e9		4881faf8030000		CMPQ $0x3f8, DX		
  0x4223f0		7757			JA 0x422449		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x4223f2		4883c207		ADDQ $0x7, DX				
  0x4223f6		48c1ea03		SHRQ $0x3, DX				
  0x4223fa		4881fa81000000		CMPQ $0x81, DX				
  0x422401		0f8396010000		JAE 0x42259d				
  0x422407		488d1d32cd0900		LEAQ runtime.size_to_class8(SB), BX	
  0x42240e		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x422412		4883fa43		CMPQ $0x43, DX				
  0x422416		0f8381010000		JAE 0x42259d				
  0x42241c		488d35bdcd0900		LEAQ runtime.class_to_size(SB), SI	
  0x422423		0fb71456		MOVZX 0(SI)(DX*2), DX			
		if m[defersc] < 0 {
  0x422427		8b7c8c2c		MOVL 0x2c(SP)(CX*4), DI	
  0x42242b		85ff			TESTL DI, DI		
  0x42242d		7d0d			JGE 0x42243c		
  0x42242f		48c1e102		SHLQ $0x2, CX		
			m[defersc] = int32(siz)
  0x422433		89540c2c		MOVL DX, 0x2c(SP)(CX*1)	
			continue
  0x422437		e977ffffff		JMP 0x4223b3		
		if m[defersc] != int32(siz) {
  0x42243c		39d7			CMPL DX, DI		
  0x42243e		0f846fffffff		JE 0x4223b3		
  0x422444		e99f000000		JMP 0x4224e8		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x422449		4881c27ffcffff		ADDQ $-0x381, DX			
  0x422450		48c1ea07		SHRQ $0x7, DX				
  0x422454		4881faf9000000		CMPQ $0xf9, DX				
  0x42245b		0f8335010000		JAE 0x422596				
  0x422461		488d1d18ce0900		LEAQ runtime.size_to_class128(SB), BX	
  0x422468		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x42246c		4883fa43		CMPQ $0x43, DX				
  0x422470		0f8320010000		JAE 0x422596				
  0x422476		488d3563cd0900		LEAQ runtime.class_to_size(SB), SI	
  0x42247d		0fb71456		MOVZX 0(SI)(DX*2), DX			
  0x422481		488d1db8cc0900		LEAQ runtime.size_to_class8(SB), BX	
		siz := roundupsize(totaldefersize(i))
  0x422488		eb9d			JMP 0x422427		
	if size+_PageSize < size {
  0x42248a		488d9a00200000		LEAQ 0x2000(DX), BX			
  0x422491		4839d3			CMPQ DX, BX				
  0x422494		7310			JAE 0x4224a6				
  0x422496		488d1da3cc0900		LEAQ runtime.size_to_class8(SB), BX	
  0x42249d		488d353ccd0900		LEAQ runtime.class_to_size(SB), SI	
		siz := roundupsize(totaldefersize(i))
  0x4224a4		eb81			JMP 0x422427		
	return round(size, _PageSize)
  0x4224a6		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x4224a7		4881c2ff1f0000		ADDQ $0x1fff, DX			
  0x4224ae		4881e200e0ffff		ANDQ $-0x2000, DX			
  0x4224b5		488d1d84cc0900		LEAQ runtime.size_to_class8(SB), BX	
  0x4224bc		488d351dcd0900		LEAQ runtime.class_to_size(SB), SI	
		siz := roundupsize(totaldefersize(i))
  0x4224c3		e95fffffff		JMP 0x422427		
	return deferHeaderSize + siz
  0x4224c8		488d5030		LEAQ 0x30(AX), DX	
		siz := roundupsize(totaldefersize(i))
  0x4224cc		e90affffff		JMP 0x4223db		
  0x4224d1		488b6c2440		MOVQ 0x40(SP), BP	
  0x4224d6		4883c448		ADDQ $0x48, SP		
  0x4224da		c3			RET			
	return (siz - minDeferArgs + 15) / 16
  0x4224db		488d480f		LEAQ 0xf(AX), CX	
  0x4224df		48c1e904		SHRQ $0x4, CX		
		defersc := deferclass(i)
  0x4224e3		e9dafeffff		JMP 0x4223c2		
  0x4224e8		48894c2420		MOVQ CX, 0x20(SP)	
		siz := roundupsize(totaldefersize(i))
  0x4224ed		4889542410		MOVQ DX, 0x10(SP)	
		defersc := deferclass(i)
  0x4224f2		4889442418		MOVQ AX, 0x18(SP)	
			print("bad defer size class: i=", i, " siz=", siz, " defersc=", defersc, "\n")
  0x4224f7		e8c4190000		CALL runtime.printlock(SB)	
  0x4224fc		488d052fe90400		LEAQ 0x4e92f(IP), AX		
  0x422503		48890424		MOVQ AX, 0(SP)			
  0x422507		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x422510		e8db220000		CALL runtime.printstring(SB)	
  0x422515		488b442418		MOVQ 0x18(SP), AX		
  0x42251a		48890424		MOVQ AX, 0(SP)			
  0x42251e		e81d200000		CALL runtime.printuint(SB)	
  0x422523		488d05a0cc0400		LEAQ 0x4cca0(IP), AX		
  0x42252a		48890424		MOVQ AX, 0(SP)			
  0x42252e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x422537		e8b4220000		CALL runtime.printstring(SB)	
  0x42253c		488b442410		MOVQ 0x10(SP), AX		
  0x422541		48890424		MOVQ AX, 0(SP)			
  0x422545		e8f61f0000		CALL runtime.printuint(SB)	
  0x42254a		488d055acf0400		LEAQ 0x4cf5a(IP), AX		
  0x422551		48890424		MOVQ AX, 0(SP)			
  0x422555		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42255e		e88d220000		CALL runtime.printstring(SB)	
  0x422563		488b442420		MOVQ 0x20(SP), AX		
  0x422568		48890424		MOVQ AX, 0(SP)			
  0x42256c		e8cf1f0000		CALL runtime.printuint(SB)	
  0x422571		e8da1b0000		CALL runtime.printnl(SB)	
  0x422576		e8c5190000		CALL runtime.printunlock(SB)	
			throw("bad defer size class")
  0x42257b		488d053be00400		LEAQ 0x4e03b(IP), AX	
  0x422582		48890424		MOVQ AX, 0(SP)		
  0x422586		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x42258f		e8ec0e0000		CALL runtime.throw(SB)	
  0x422594		0f0b			UD2			
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x422596		e885f9ffff		CALL runtime.panicindex(SB)	
  0x42259b		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x42259d		e87ef9ffff		CALL runtime.panicindex(SB)	
  0x4225a2		0f0b			UD2				
func testdefersizes() {
  0x4225a4		e8d7520200		CALL runtime.morestack_noctxt(SB)	
  0x4225a9		e9b2fdffff		JMP runtime.testdefersizes(SB)		

TEXT runtime.init.4(SB) /usr/local/go/src/runtime/panic.go
func init() {
  0x4225b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4225b9		483b6110		CMPQ 0x10(CX), SP	
  0x4225bd		7659			JBE 0x422618		
  0x4225bf		4883ec18		SUBQ $0x18, SP		
  0x4225c3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4225c8		488d6c2410		LEAQ 0x10(SP), BP	
	var x interface{}
  0x4225cd		0f57c0			XORPS X0, X0		
  0x4225d0		0f110424		MOVUPS X0, 0(SP)	
	x = (*_defer)(nil)
  0x4225d4		488d0de54e0300		LEAQ 0x34ee5(IP), CX	
  0x4225db		48890c24		MOVQ CX, 0(SP)		
  0x4225df		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	deferType = (*(**ptrtype)(unsafe.Pointer(&x))).elem
  0x4225e8		488b0c24		MOVQ 0(SP), CX				
  0x4225ec		488b4130		MOVQ 0x30(CX), AX			
  0x4225f0		833d29a80b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4225f7		7511			JNE 0x42260a				
  0x4225f9		48890548f30900		MOVQ AX, runtime.deferType(SB)		
}
  0x422600		488b6c2410		MOVQ 0x10(SP), BP	
  0x422605		4883c418		ADDQ $0x18, SP		
  0x422609		c3			RET			
	deferType = (*(**ptrtype)(unsafe.Pointer(&x))).elem
  0x42260a		488d3d37f30900		LEAQ runtime.deferType(SB), DI	
  0x422611		e86a700200		CALL runtime.gcWriteBarrier(SB)	
  0x422616		ebe8			JMP 0x422600			
func init() {
  0x422618		e863520200		CALL runtime.morestack_noctxt(SB)	
  0x42261d		eb91			JMP runtime.init.4(SB)			

TEXT runtime.newdefer(SB) /usr/local/go/src/runtime/panic.go
func newdefer(siz int32) *_defer {
  0x422620		4883ec68		SUBQ $0x68, SP		
  0x422624		48896c2460		MOVQ BP, 0x60(SP)	
  0x422629		488d6c2460		LEAQ 0x60(SP), BP	
	var d *_defer
  0x42262e		48c744241800000000	MOVQ $0x0, 0x18(SP)	
	sc := deferclass(uintptr(siz))
  0x422637		90			NOPL			
  0x422638		8b4c2470		MOVL 0x70(SP), CX	
  0x42263c		4863d1			MOVSXD CX, DX		
	if siz <= minDeferArgs {
  0x42263f		4885d2			TESTQ DX, DX		
  0x422642		0f87cf010000		JA 0x422817		
  0x422648		31c0			XORL AX, AX		
	gp := getg()
  0x42264a		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x422653		4889542410		MOVQ DX, 0x10(SP)	
	if sc < uintptr(len(p{}.deferpool)) {
  0x422658		4883f805		CMPQ $0x5, AX		
  0x42265c		0f8395000000		JAE 0x4226f7		
		pp := gp.m.p.ptr()
  0x422662		488b5a30		MOVQ 0x30(DX), BX	
  0x422666		488b9bd0000000		MOVQ 0xd0(BX), BX	
		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
  0x42266d		8403			TESTB AL, 0(BX)		
		pp := gp.m.p.ptr()
  0x42266f		90			NOPL			
		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
  0x422670		488d3440		LEAQ 0(AX)(AX*2), SI		
  0x422674		4c8b44f360		MOVQ 0x60(BX)(SI*8), R8		
  0x422679		4c8d0cf3		LEAQ 0(BX)(SI*8), R9		
  0x42267d		4d8d4958		LEAQ 0x58(R9), R9		
  0x422681		4d85c0			TESTQ R8, R8			
  0x422684		7514			JNE 0x42269a			
  0x422686		4c8d05dbf60900		LEAQ runtime.sched+200(SB), R8	
  0x42268d		4d8b04c0		MOVQ 0(R8)(AX*8), R8		
  0x422691		4d85c0			TESTQ R8, R8			
  0x422694		0f851c010000		JNE 0x4227b6			
		if n := len(pp.deferpool[sc]); n > 0 {
  0x42269a		4c8b44f360		MOVQ 0x60(BX)(SI*8), R8		
  0x42269f		4c8b54f358		MOVQ 0x58(BX)(SI*8), R10	
  0x4226a4		4d85c0			TESTQ R8, R8			
  0x4226a7		7e4e			JLE 0x4226f7			
			d = pp.deferpool[sc][n-1]
  0x4226a9		4f8b54c2f8		MOVQ -0x8(R10)(R8*8), R10	
  0x4226ae		4c89542418		MOVQ R10, 0x18(SP)		
  0x4226b3		4d8d50ff		LEAQ -0x1(R8), R10		
			pp.deferpool[sc][n-1] = nil
  0x4226b7		4c8b5cf358		MOVQ 0x58(BX)(SI*8), R11		
  0x4226bc		4d395108		CMPQ R10, 0x8(R9)			
  0x4226c0		0f8665010000		JBE 0x42282b				
  0x4226c6		4b8d3cc3		LEAQ 0(R11)(R8*8), DI			
  0x4226ca		488d7ff8		LEAQ -0x8(DI), DI			
  0x4226ce		833d4ba70b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4226d5		0f85cf000000		JNE 0x4227aa				
  0x4226db		4bc744c3f800000000	MOVQ $0x0, -0x8(R11)(R8*8)		
			pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x4226e4		4c8b44f368		MOVQ 0x68(BX)(SI*8), R8		
  0x4226e9		4d39c2			CMPQ R8, R10			
  0x4226ec		0f8732010000		JA 0x422824			
  0x4226f2		4c8954f360		MOVQ R10, 0x60(BX)(SI*8)	
	if d == nil {
  0x4226f7		48837c241800		CMPQ $0x0, 0x18(SP)	
  0x4226fd		745b			JE 0x42275a		
	d.siz = siz
  0x4226ff		488b5c2418		MOVQ 0x18(SP), BX	
  0x422704		890b			MOVL CX, 0(BX)		
	d.link = gp._defer
  0x422706		488b4c2418		MOVQ 0x18(SP), CX			
  0x42270b		8401			TESTB AL, 0(CX)				
  0x42270d		488b4228		MOVQ 0x28(DX), AX			
  0x422711		833d08a70b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422718		7535			JNE 0x42274f				
  0x42271a		48894128		MOVQ AX, 0x28(CX)			
	gp._defer = d
  0x42271e		488b442418		MOVQ 0x18(SP), AX			
  0x422723		833df6a60b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42272a		7518			JNE 0x422744				
  0x42272c		48894228		MOVQ AX, 0x28(DX)			
	return d
  0x422730		488b442418		MOVQ 0x18(SP), AX	
  0x422735		4889442478		MOVQ AX, 0x78(SP)	
  0x42273a		488b6c2460		MOVQ 0x60(SP), BP	
  0x42273f		4883c468		ADDQ $0x68, SP		
  0x422743		c3			RET			
	d.link = gp._defer
  0x422744		488d7a28		LEAQ 0x28(DX), DI	
	gp._defer = d
  0x422748		e8336f0200		CALL runtime.gcWriteBarrier(SB)	
  0x42274d		ebe1			JMP 0x422730			
	d.link = gp._defer
  0x42274f		488d7928		LEAQ 0x28(CX), DI		
  0x422753		e8286f0200		CALL runtime.gcWriteBarrier(SB)	
  0x422758		ebc4			JMP 0x42271e			
		systemstack(func() {
  0x42275a		48c744243000000000	MOVQ $0x0, 0x30(SP)			
  0x422763		c744243800000000	MOVL $0x0, 0x38(SP)			
  0x42276b		48c744244000000000	MOVQ $0x0, 0x40(SP)			
  0x422774		488d05d5380200		LEAQ runtime.newdefer.func2(SB), AX	
  0x42277b		4889442430		MOVQ AX, 0x30(SP)			
  0x422780		894c2438		MOVL CX, 0x38(SP)			
  0x422784		488d442418		LEAQ 0x18(SP), AX			
  0x422789		4889442440		MOVQ AX, 0x40(SP)			
  0x42278e		488d442430		LEAQ 0x30(SP), AX			
  0x422793		48890424		MOVQ AX, 0(SP)				
  0x422797		e8944f0200		CALL runtime.systemstack(SB)		
	d.siz = siz
  0x42279c		8b4c2470		MOVL 0x70(SP), CX	
	d.link = gp._defer
  0x4227a0		488b542410		MOVQ 0x10(SP), DX	
	d.siz = siz
  0x4227a5		e955ffffff		JMP 0x4226ff		
			pp.deferpool[sc][n-1] = nil
  0x4227aa		31c0			XORL AX, AX			
  0x4227ac		e8cf6e0200		CALL runtime.gcWriteBarrier(SB)	
  0x4227b1		e92effffff		JMP 0x4226e4			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4227b6		48895c2428		MOVQ BX, 0x28(SP)	
		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
  0x4227bb		4c894c2420		MOVQ R9, 0x20(SP)	
  0x4227c0		4889742408		MOVQ SI, 0x8(SP)	
			systemstack(func() {
  0x4227c5		0f57c0			XORPS X0, X0				
  0x4227c8		0f11442448		MOVUPS X0, 0x48(SP)			
  0x4227cd		48c744245800000000	MOVQ $0x0, 0x58(SP)			
  0x4227d6		488d0da3360200		LEAQ runtime.newdefer.func1(SB), CX	
  0x4227dd		48894c2448		MOVQ CX, 0x48(SP)			
  0x4227e2		48895c2450		MOVQ BX, 0x50(SP)			
  0x4227e7		4889442458		MOVQ AX, 0x58(SP)			
  0x4227ec		488d442448		LEAQ 0x48(SP), AX			
  0x4227f1		48890424		MOVQ AX, 0(SP)				
  0x4227f5		e8364f0200		CALL runtime.systemstack(SB)		
	d.siz = siz
  0x4227fa		8b4c2470		MOVL 0x70(SP), CX	
	d.link = gp._defer
  0x4227fe		488b542410		MOVQ 0x10(SP), DX	
		if n := len(pp.deferpool[sc]); n > 0 {
  0x422803		488b5c2428		MOVQ 0x28(SP), BX	
  0x422808		488b742408		MOVQ 0x8(SP), SI	
			pp.deferpool[sc][n-1] = nil
  0x42280d		4c8b4c2420		MOVQ 0x20(SP), R9	
			systemstack(func() {
  0x422812		e983feffff		JMP 0x42269a		
	return (siz - minDeferArgs + 15) / 16
  0x422817		488d420f		LEAQ 0xf(DX), AX	
  0x42281b		48c1e804		SHRQ $0x4, AX		
	sc := deferclass(uintptr(siz))
  0x42281f		e926feffff		JMP 0x42264a		
			pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x422824		e827f8ffff		CALL runtime.panicslice(SB)	
  0x422829		0f0b			UD2				
			pp.deferpool[sc][n-1] = nil
  0x42282b		e8f0f6ffff		CALL runtime.panicindex(SB)	
  0x422830		0f0b			UD2				

TEXT runtime.freedefer(SB) /usr/local/go/src/runtime/panic.go
func freedefer(d *_defer) {
  0x422840		4883ec78		SUBQ $0x78, SP		
  0x422844		48896c2470		MOVQ BP, 0x70(SP)	
  0x422849		488d6c2470		LEAQ 0x70(SP), BP	
	if d._panic != nil {
  0x42284e		488b842480000000	MOVQ 0x80(SP), AX	
  0x422856		4883782000		CMPQ $0x0, 0x20(AX)	
  0x42285b		0f85cd010000		JNE 0x422a2e		
	if d.fn != nil {
  0x422861		4883781800		CMPQ $0x0, 0x18(AX)	
  0x422866		0f85b0010000		JNE 0x422a1c		
	sc := deferclass(uintptr(d.siz))
  0x42286c		90			NOPL			
  0x42286d		486308			MOVSXD 0(AX), CX	
	if siz <= minDeferArgs {
  0x422870		4885c9			TESTQ CX, CX		
  0x422873		0f8796010000		JA 0x422a0f		
  0x422879		31c9			XORL CX, CX		
	if sc >= uintptr(len(p{}.deferpool)) {
  0x42287b		4883f905		CMPQ $0x5, CX		
  0x42287f		0f8380010000		JAE 0x422a05		
	pp := getg().m.p.ptr()
  0x422885		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x42288e		488b5230		MOVQ 0x30(DX), DX	
  0x422892		488b92d0000000		MOVQ 0xd0(DX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x422899		4889542450		MOVQ DX, 0x50(SP)	
	if len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) {
  0x42289e		8402			TESTB AL, 0(DX)		
	pp := getg().m.p.ptr()
  0x4228a0		90			NOPL			
	if len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) {
  0x4228a1		488d1c49		LEAQ 0(CX)(CX*2), BX	
  0x4228a5		48895c2440		MOVQ BX, 0x40(SP)	
  0x4228aa		488d34da		LEAQ 0(DX)(BX*8), SI	
  0x4228ae		488d7658		LEAQ 0x58(SI), SI	
  0x4228b2		4889742448		MOVQ SI, 0x48(SP)	
  0x4228b7		4c8b44da68		MOVQ 0x68(DX)(BX*8), R8	
  0x4228bc		4c394608		CMPQ R8, 0x8(SI)	
  0x4228c0		0f84ee000000		JE 0x4229b4		
	d.siz = 0
  0x4228c6		c70000000000		MOVL $0x0, 0(AX)	
	d.started = false
  0x4228cc		c6400400		MOVB $0x0, 0x4(AX)	
	d.pc = 0
  0x4228d0		0f57c0			XORPS X0, X0		
  0x4228d3		0f114008		MOVUPS X0, 0x8(AX)	
	d.link = nil
  0x4228d7		833d42a50b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4228de		0f85ba000000		JNE 0x42299e				
  0x4228e4		48c7402800000000	MOVQ $0x0, 0x28(AX)			
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x4228ec		488b4cda60		MOVQ 0x60(DX)(BX*8), CX			
  0x4228f1		4c8b44da58		MOVQ 0x58(DX)(BX*8), R8			
  0x4228f6		4c8b4cda68		MOVQ 0x68(DX)(BX*8), R9			
  0x4228fb		4c8d5101		LEAQ 0x1(CX), R10			
  0x4228ff		4d39ca			CMPQ R9, R10				
  0x422902		772b			JA 0x42292f				
  0x422904		488d7101		LEAQ 0x1(CX), SI			
  0x422908		488974da60		MOVQ SI, 0x60(DX)(BX*8)			
  0x42290d		498d3cc8		LEAQ 0(R8)(CX*8), DI			
  0x422911		833d08a50b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422918		750e			JNE 0x422928				
  0x42291a		498904c8		MOVQ AX, 0(R8)(CX*8)			
}
  0x42291e		488b6c2470		MOVQ 0x70(SP), BP	
  0x422923		4883c478		ADDQ $0x78, SP		
  0x422927		c3			RET			
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x422928		e8536d0200		CALL runtime.gcWriteBarrier(SB)		
  0x42292d		ebef			JMP 0x42291e				
  0x42292f		488d058a4b0300		LEAQ 0x34b8a(IP), AX			
  0x422936		48890424		MOVQ AX, 0(SP)				
  0x42293a		4c89442408		MOVQ R8, 0x8(SP)			
  0x42293f		48894c2410		MOVQ CX, 0x10(SP)			
  0x422944		4c894c2418		MOVQ R9, 0x18(SP)			
  0x422949		4c89542420		MOVQ R10, 0x20(SP)			
  0x42294e		e82d340100		CALL runtime.growslice(SB)		
  0x422953		488b442428		MOVQ 0x28(SP), AX			
  0x422958		488b4c2430		MOVQ 0x30(SP), CX			
  0x42295d		488b542438		MOVQ 0x38(SP), DX			
  0x422962		488b5c2440		MOVQ 0x40(SP), BX			
  0x422967		488b742450		MOVQ 0x50(SP), SI			
  0x42296c		488954de68		MOVQ DX, 0x68(SI)(BX*8)			
  0x422971		833da8a40b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422978		7518			JNE 0x422992				
  0x42297a		488944de58		MOVQ AX, 0x58(SI)(BX*8)			
  0x42297f		4889f2			MOVQ SI, DX				
  0x422982		4989c0			MOVQ AX, R8				
  0x422985		488b842480000000	MOVQ 0x80(SP), AX			
  0x42298d		e972ffffff		JMP 0x422904				
  0x422992		488b7c2448		MOVQ 0x48(SP), DI			
  0x422997		e8e46c0200		CALL runtime.gcWriteBarrier(SB)		
  0x42299c		ebe1			JMP 0x42297f				
	d.link = nil
  0x42299e		488d7828		LEAQ 0x28(AX), DI	
func freedefer(d *_defer) {
  0x4229a2		4889c1			MOVQ AX, CX		
	d.link = nil
  0x4229a5		31c0			XORL AX, AX			
  0x4229a7		e8d46c0200		CALL runtime.gcWriteBarrier(SB)	
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x4229ac		4889c8			MOVQ CX, AX		
	d.link = nil
  0x4229af		e938ffffff		JMP 0x4228ec		
		systemstack(func() {
  0x4229b4		0f57c0			XORPS X0, X0				
  0x4229b7		0f11442458		MOVUPS X0, 0x58(SP)			
  0x4229bc		48c744246800000000	MOVQ $0x0, 0x68(SP)			
  0x4229c5		488d05d4370200		LEAQ runtime.freedefer.func1(SB), AX	
  0x4229cc		4889442458		MOVQ AX, 0x58(SP)			
  0x4229d1		4889542460		MOVQ DX, 0x60(SP)			
  0x4229d6		48894c2468		MOVQ CX, 0x68(SP)			
  0x4229db		488d442458		LEAQ 0x58(SP), AX			
  0x4229e0		48890424		MOVQ AX, 0(SP)				
  0x4229e4		e8474d0200		CALL runtime.systemstack(SB)		
	d.siz = 0
  0x4229e9		488b842480000000	MOVQ 0x80(SP), AX	
	pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x4229f1		488b542450		MOVQ 0x50(SP), DX	
  0x4229f6		488b5c2440		MOVQ 0x40(SP), BX	
  0x4229fb		488b742448		MOVQ 0x48(SP), SI	
		systemstack(func() {
  0x422a00		e9c1feffff		JMP 0x4228c6		
		return
  0x422a05		488b6c2470		MOVQ 0x70(SP), BP	
  0x422a0a		4883c478		ADDQ $0x78, SP		
  0x422a0e		c3			RET			
	return (siz - minDeferArgs + 15) / 16
  0x422a0f		4883c10f		ADDQ $0xf, CX		
  0x422a13		48c1e904		SHRQ $0x4, CX		
	sc := deferclass(uintptr(d.siz))
  0x422a17		e95ffeffff		JMP 0x42287b		
		freedeferfn()
  0x422a1c		e85f000000		CALL runtime.freedeferfn(SB)	
	sc := deferclass(uintptr(d.siz))
  0x422a21		488b842480000000	MOVQ 0x80(SP), AX	
		freedeferfn()
  0x422a29		e93efeffff		JMP 0x42286c		
		freedeferpanic()
  0x422a2e		e80d000000		CALL runtime.freedeferpanic(SB)	
	if d.fn != nil {
  0x422a33		488b842480000000	MOVQ 0x80(SP), AX	
		freedeferpanic()
  0x422a3b		e921feffff		JMP 0x422861		

TEXT runtime.freedeferpanic(SB) /usr/local/go/src/runtime/panic.go
func freedeferpanic() {
  0x422a40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422a49		483b6110		CMPQ 0x10(CX), SP	
  0x422a4d		7629			JBE 0x422a78		
  0x422a4f		4883ec18		SUBQ $0x18, SP		
  0x422a53		48896c2410		MOVQ BP, 0x10(SP)	
  0x422a58		488d6c2410		LEAQ 0x10(SP), BP	
	throw("freedefer with d._panic != nil")
  0x422a5d		488d054cf10400		LEAQ 0x4f14c(IP), AX	
  0x422a64		48890424		MOVQ AX, 0(SP)		
  0x422a68		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x422a71		e80a0a0000		CALL runtime.throw(SB)	
  0x422a76		0f0b			UD2			
func freedeferpanic() {
  0x422a78		e8034e0200		CALL runtime.morestack_noctxt(SB)	
  0x422a7d		ebc1			JMP runtime.freedeferpanic(SB)		

TEXT runtime.freedeferfn(SB) /usr/local/go/src/runtime/panic.go
func freedeferfn() {
  0x422a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422a89		483b6110		CMPQ 0x10(CX), SP	
  0x422a8d		7629			JBE 0x422ab8		
  0x422a8f		4883ec18		SUBQ $0x18, SP		
  0x422a93		48896c2410		MOVQ BP, 0x10(SP)	
  0x422a98		488d6c2410		LEAQ 0x10(SP), BP	
	throw("freedefer with d.fn != nil")
  0x422a9d		488d05a2e70400		LEAQ 0x4e7a2(IP), AX	
  0x422aa4		48890424		MOVQ AX, 0(SP)		
  0x422aa8		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x422ab1		e8ca090000		CALL runtime.throw(SB)	
  0x422ab6		0f0b			UD2			
func freedeferfn() {
  0x422ab8		e8c34d0200		CALL runtime.morestack_noctxt(SB)	
  0x422abd		ebc1			JMP runtime.freedeferfn(SB)		

TEXT runtime.deferreturn(SB) /usr/local/go/src/runtime/panic.go
func deferreturn(arg0 uintptr) {
  0x422ac0		4883ec40		SUBQ $0x40, SP		
  0x422ac4		48896c2438		MOVQ BP, 0x38(SP)	
  0x422ac9		488d6c2438		LEAQ 0x38(SP), BP	
	gp := getg()
  0x422ace		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	d := gp._defer
  0x422ad7		488b5128		MOVQ 0x28(CX), DX	
	if d == nil {
  0x422adb		4885d2			TESTQ DX, DX		
  0x422ade		0f84ee000000		JE 0x422bd2		
	if d.sp != sp {
  0x422ae4		488d5c2448		LEAQ 0x48(SP), BX	
  0x422ae9		48395a08		CMPQ BX, 0x8(DX)	
  0x422aed		0f85d5000000		JNE 0x422bc8		
	switch d.siz {
  0x422af3		8b1a			MOVL 0(DX), BX		
	case 0:
  0x422af5		85db			TESTL BX, BX		
  0x422af7		757a			JNE 0x422b73		
	fn := d.fn
  0x422af9		488b5a18		MOVQ 0x18(DX), BX	
	d.fn = nil
  0x422afd		833d1ca30b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422b04		7560			JNE 0x422b66				
  0x422b06		48c7421800000000	MOVQ $0x0, 0x18(DX)			
	fn := d.fn
  0x422b0e		48895c2420		MOVQ BX, 0x20(SP)	
	gp._defer = d.link
  0x422b13		8401			TESTB AL, 0(CX)				
  0x422b15		488b4228		MOVQ 0x28(DX), AX			
  0x422b19		833d00a30b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422b20		7539			JNE 0x422b5b				
  0x422b22		48894128		MOVQ AX, 0x28(CX)			
	freedefer(d)
  0x422b26		48891424		MOVQ DX, 0(SP)			
  0x422b2a		e811fdffff		CALL runtime.freedefer(SB)	
	jmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))
  0x422b2f		488d442448		LEAQ 0x48(SP), AX		
  0x422b34		4889442430		MOVQ AX, 0x30(SP)		
  0x422b39		488b442420		MOVQ 0x20(SP), AX		
  0x422b3e		48890424		MOVQ AX, 0(SP)			
  0x422b42		488b442430		MOVQ 0x30(SP), AX		
  0x422b47		4889442408		MOVQ AX, 0x8(SP)		
  0x422b4c		e84f630200		CALL runtime.jmpdefer(SB)	
}
  0x422b51		488b6c2438		MOVQ 0x38(SP), BP	
  0x422b56		4883c440		ADDQ $0x40, SP		
  0x422b5a		c3			RET			
	d := gp._defer
  0x422b5b		488d7928		LEAQ 0x28(CX), DI	
	gp._defer = d.link
  0x422b5f		e81c6b0200		CALL runtime.gcWriteBarrier(SB)	
  0x422b64		ebc0			JMP 0x422b26			
	fn := d.fn
  0x422b66		488d7a18		LEAQ 0x18(DX), DI	
	d.fn = nil
  0x422b6a		31c0			XORL AX, AX			
  0x422b6c		e80f6b0200		CALL runtime.gcWriteBarrier(SB)	
  0x422b71		eb9b			JMP 0x422b0e			
	case sys.PtrSize:
  0x422b73		83fb08			CMPL $0x8, BX		
  0x422b76		7516			JNE 0x422b8e		
	return unsafe.Pointer(uintptr(p) + x)
  0x422b78		488d5a30		LEAQ 0x30(DX), BX	
		*(*uintptr)(unsafe.Pointer(&arg0)) = *(*uintptr)(deferArgs(d))
  0x422b7c		8403			TESTB AL, 0(BX)		
  0x422b7e		488b5a30		MOVQ 0x30(DX), BX	
  0x422b82		90			NOPL			
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x422b83		90			NOPL			
		*(*uintptr)(unsafe.Pointer(&arg0)) = *(*uintptr)(deferArgs(d))
  0x422b84		48895c2448		MOVQ BX, 0x48(SP)	
	switch d.siz {
  0x422b89		e96bffffff		JMP 0x422af9		
	gp := getg()
  0x422b8e		48894c2418		MOVQ CX, 0x18(SP)	
	d := gp._defer
  0x422b93		4889542428		MOVQ DX, 0x28(SP)	
		memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
  0x422b98		90			NOPL			
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x422b99		90			NOPL			
		memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
  0x422b9a		488d442448		LEAQ 0x48(SP), AX	
  0x422b9f		48890424		MOVQ AX, 0(SP)		
	return unsafe.Pointer(uintptr(p) + x)
  0x422ba3		488d4a30		LEAQ 0x30(DX), CX	
		memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
  0x422ba7		48894c2408		MOVQ CX, 0x8(SP)		
  0x422bac		4863cb			MOVSXD BX, CX			
  0x422baf		48894c2410		MOVQ CX, 0x10(SP)		
  0x422bb4		e8977b0200		CALL runtime.memmove(SB)	
	gp._defer = d.link
  0x422bb9		488b4c2418		MOVQ 0x18(SP), CX	
	fn := d.fn
  0x422bbe		488b542428		MOVQ 0x28(SP), DX	
	switch d.siz {
  0x422bc3		e931ffffff		JMP 0x422af9		
		return
  0x422bc8		488b6c2438		MOVQ 0x38(SP), BP	
  0x422bcd		4883c440		ADDQ $0x40, SP		
  0x422bd1		c3			RET			
		return
  0x422bd2		488b6c2438		MOVQ 0x38(SP), BP	
  0x422bd7		4883c440		ADDQ $0x40, SP		
  0x422bdb		c3			RET			

TEXT runtime.preprintpanics(SB) /usr/local/go/src/runtime/panic.go
func preprintpanics(p *_panic) {
  0x422be0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422be9		483b6110		CMPQ 0x10(CX), SP	
  0x422bed		0f86a6010000		JBE 0x422d99		
  0x422bf3		4883ec50		SUBQ $0x50, SP		
  0x422bf7		48896c2448		MOVQ BP, 0x48(SP)	
  0x422bfc		488d6c2448		LEAQ 0x48(SP), BP	
	defer func() {
  0x422c01		c7042400000000		MOVL $0x0, 0(SP)		
  0x422c08		488d05390d0500		LEAQ 0x50d39(IP), AX		
  0x422c0f		4889442408		MOVQ AX, 0x8(SP)		
  0x422c14		e817f6ffff		CALL runtime.deferproc(SB)	
  0x422c19		85c0			TESTL AX, AX			
  0x422c1b		0f8568010000		JNE 0x422d89			
	for p != nil {
  0x422c21		488b442458		MOVQ 0x58(SP), AX	
  0x422c26		eb04			JMP 0x422c2c		
		p = p.link
  0x422c28		488b4018		MOVQ 0x18(AX), AX	
	for p != nil {
  0x422c2c		4885c0			TESTQ AX, AX		
  0x422c2f		0f8444010000		JE 0x422d79		
		switch v := p.arg.(type) {
  0x422c35		488b4810		MOVQ 0x10(AX), CX	
  0x422c39		488b5008		MOVQ 0x8(AX), DX	
  0x422c3d		4885d2			TESTQ DX, DX		
  0x422c40		74e6			JE 0x422c28		
	for p != nil {
  0x422c42		4889442458		MOVQ AX, 0x58(SP)	
		switch v := p.arg.(type) {
  0x422c47		4889542430		MOVQ DX, 0x30(SP)		
  0x422c4c		48894c2440		MOVQ CX, 0x40(SP)		
  0x422c51		488d05e8d10300		LEAQ 0x3d1e8(IP), AX		
  0x422c58		48890424		MOVQ AX, 0(SP)			
  0x422c5c		4889542408		MOVQ DX, 0x8(SP)		
  0x422c61		48894c2410		MOVQ CX, 0x10(SP)		
  0x422c66		e8f556feff		CALL runtime.assertE2I2(SB)	
  0x422c6b		488b442420		MOVQ 0x20(SP), AX		
  0x422c70		488b4c2418		MOVQ 0x18(SP), CX		
  0x422c75		488b542458		MOVQ 0x58(SP), DX		
  0x422c7a		488d5a10		LEAQ 0x10(DX), BX		
  0x422c7e		48895c2438		MOVQ BX, 0x38(SP)		
  0x422c83		807c242800		CMPB $0x0, 0x28(SP)		
  0x422c88		7458			JE 0x422ce2			
			p.arg = v.Error()
  0x422c8a		488b4918		MOVQ 0x18(CX), CX			
  0x422c8e		48890424		MOVQ AX, 0(SP)				
  0x422c92		ffd1			CALL CX					
  0x422c94		488b442410		MOVQ 0x10(SP), AX			
  0x422c99		488b4c2408		MOVQ 0x8(SP), CX			
  0x422c9e		48890c24		MOVQ CX, 0(SP)				
  0x422ca2		4889442408		MOVQ AX, 0x8(SP)			
  0x422ca7		e81456feff		CALL runtime.convTstring(SB)		
  0x422cac		488b442410		MOVQ 0x10(SP), AX			
  0x422cb1		488d0d08850300		LEAQ 0x38508(IP), CX			
  0x422cb8		488b542458		MOVQ 0x58(SP), DX			
  0x422cbd		48894a08		MOVQ CX, 0x8(DX)			
  0x422cc1		833d58a10b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422cc8		750c			JNE 0x422cd6				
  0x422cca		48894210		MOVQ AX, 0x10(DX)			
		p = p.link
  0x422cce		4889d0			MOVQ DX, AX		
		switch v := p.arg.(type) {
  0x422cd1		e952ffffff		JMP 0x422c28		
			p.arg = v.Error()
  0x422cd6		488b7c2438		MOVQ 0x38(SP), DI		
  0x422cdb		e8a0690200		CALL runtime.gcWriteBarrier(SB)	
  0x422ce0		ebec			JMP 0x422cce			
		switch v := p.arg.(type) {
  0x422ce2		488d05d7d10300		LEAQ 0x3d1d7(IP), AX		
  0x422ce9		48890424		MOVQ AX, 0(SP)			
  0x422ced		488b4c2430		MOVQ 0x30(SP), CX		
  0x422cf2		48894c2408		MOVQ CX, 0x8(SP)		
  0x422cf7		488b4c2440		MOVQ 0x40(SP), CX		
  0x422cfc		48894c2410		MOVQ CX, 0x10(SP)		
  0x422d01		e85a56feff		CALL runtime.assertE2I2(SB)	
  0x422d06		488b442420		MOVQ 0x20(SP), AX		
  0x422d0b		488b4c2418		MOVQ 0x18(SP), CX		
  0x422d10		807c242800		CMPB $0x0, 0x28(SP)		
  0x422d15		750a			JNE 0x422d21			
		p = p.link
  0x422d17		488b442458		MOVQ 0x58(SP), AX	
		switch v := p.arg.(type) {
  0x422d1c		e907ffffff		JMP 0x422c28		
			p.arg = v.String()
  0x422d21		488b4918		MOVQ 0x18(CX), CX			
  0x422d25		48890424		MOVQ AX, 0(SP)				
  0x422d29		ffd1			CALL CX					
  0x422d2b		488b442410		MOVQ 0x10(SP), AX			
  0x422d30		488b4c2408		MOVQ 0x8(SP), CX			
  0x422d35		48890c24		MOVQ CX, 0(SP)				
  0x422d39		4889442408		MOVQ AX, 0x8(SP)			
  0x422d3e		e87d55feff		CALL runtime.convTstring(SB)		
  0x422d43		488b442410		MOVQ 0x10(SP), AX			
  0x422d48		488d0d71840300		LEAQ 0x38471(IP), CX			
  0x422d4f		488b542458		MOVQ 0x58(SP), DX			
  0x422d54		48894a08		MOVQ CX, 0x8(DX)			
  0x422d58		833dc1a00b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422d5f		750c			JNE 0x422d6d				
  0x422d61		48894210		MOVQ AX, 0x10(DX)			
		p = p.link
  0x422d65		4889d0			MOVQ DX, AX		
		switch v := p.arg.(type) {
  0x422d68		e9bbfeffff		JMP 0x422c28		
			p.arg = v.String()
  0x422d6d		488b7c2438		MOVQ 0x38(SP), DI		
  0x422d72		e809690200		CALL runtime.gcWriteBarrier(SB)	
  0x422d77		ebec			JMP 0x422d65			
}
  0x422d79		90			NOPL				
  0x422d7a		e841fdffff		CALL runtime.deferreturn(SB)	
  0x422d7f		488b6c2448		MOVQ 0x48(SP), BP		
  0x422d84		4883c450		ADDQ $0x50, SP			
  0x422d88		c3			RET				
	defer func() {
  0x422d89		90			NOPL				
  0x422d8a		e831fdffff		CALL runtime.deferreturn(SB)	
  0x422d8f		488b6c2448		MOVQ 0x48(SP), BP		
  0x422d94		4883c450		ADDQ $0x50, SP			
  0x422d98		c3			RET				
func preprintpanics(p *_panic) {
  0x422d99		e8e24a0200		CALL runtime.morestack_noctxt(SB)	
  0x422d9e		e93dfeffff		JMP runtime.preprintpanics(SB)		

TEXT runtime.printpanics(SB) /usr/local/go/src/runtime/panic.go
func printpanics(p *_panic) {
  0x422db0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422db9		483b6110		CMPQ 0x10(CX), SP	
  0x422dbd		0f86d8000000		JBE 0x422e9b		
  0x422dc3		4883ec18		SUBQ $0x18, SP		
  0x422dc7		48896c2410		MOVQ BP, 0x10(SP)	
  0x422dcc		488d6c2410		LEAQ 0x10(SP), BP	
	if p.link != nil {
  0x422dd1		488b442420		MOVQ 0x20(SP), AX	
  0x422dd6		488b4818		MOVQ 0x18(AX), CX	
  0x422dda		4885c9			TESTQ CX, CX		
  0x422ddd		0f8587000000		JNE 0x422e6a		
	print("panic: ")
  0x422de3		e8d8100000		CALL runtime.printlock(SB)	
  0x422de8		488d0541c50400		LEAQ 0x4c541(IP), AX		
  0x422def		48890424		MOVQ AX, 0(SP)			
  0x422df3		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x422dfc		e8ef190000		CALL runtime.printstring(SB)	
  0x422e01		e83a110000		CALL runtime.printunlock(SB)	
	printany(p.arg)
  0x422e06		488b442420		MOVQ 0x20(SP), AX		
  0x422e0b		488b4808		MOVQ 0x8(AX), CX		
  0x422e0f		488b5010		MOVQ 0x10(AX), DX		
  0x422e13		48890c24		MOVQ CX, 0(SP)			
  0x422e17		4889542408		MOVQ DX, 0x8(SP)		
  0x422e1c		e88f38feff		CALL runtime.printany(SB)	
	if p.recovered {
  0x422e21		488b442420		MOVQ 0x20(SP), AX	
  0x422e26		80782000		CMPB $0x0, 0x20(AX)	
  0x422e2a		7519			JNE 0x422e45		
	print("\n")
  0x422e2c		e88f100000		CALL runtime.printlock(SB)	
  0x422e31		e81a130000		CALL runtime.printnl(SB)	
  0x422e36		e805110000		CALL runtime.printunlock(SB)	
}
  0x422e3b		488b6c2410		MOVQ 0x10(SP), BP	
  0x422e40		4883c418		ADDQ $0x18, SP		
  0x422e44		c3			RET			
		print(" [recovered]")
  0x422e45		e876100000		CALL runtime.printlock(SB)	
  0x422e4a		488d0530cb0400		LEAQ 0x4cb30(IP), AX		
  0x422e51		48890424		MOVQ AX, 0(SP)			
  0x422e55		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x422e5e		e88d190000		CALL runtime.printstring(SB)	
  0x422e63		e8d8100000		CALL runtime.printunlock(SB)	
  0x422e68		ebc2			JMP 0x422e2c			
		printpanics(p.link)
  0x422e6a		48890c24		MOVQ CX, 0(SP)			
  0x422e6e		e83dffffff		CALL runtime.printpanics(SB)	
		print("\t")
  0x422e73		e848100000		CALL runtime.printlock(SB)	
  0x422e78		488d050fc20400		LEAQ 0x4c20f(IP), AX		
  0x422e7f		48890424		MOVQ AX, 0(SP)			
  0x422e83		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x422e8c		e85f190000		CALL runtime.printstring(SB)	
  0x422e91		e8aa100000		CALL runtime.printunlock(SB)	
  0x422e96		e948ffffff		JMP 0x422de3			
func printpanics(p *_panic) {
  0x422e9b		e8e0490200		CALL runtime.morestack_noctxt(SB)	
  0x422ea0		e90bffffff		JMP runtime.printpanics(SB)		

TEXT runtime.gopanic(SB) /usr/local/go/src/runtime/panic.go
func gopanic(e interface{}) {
  0x422eb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x422eb9		488d4424f8		LEAQ -0x8(SP), AX	
  0x422ebe		483b4110		CMPQ 0x10(CX), AX	
  0x422ec2		0f8645050000		JBE 0x42340d		
  0x422ec8		4881ec88000000		SUBQ $0x88, SP		
  0x422ecf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x422ed7		488dac2480000000	LEAQ 0x80(SP), BP	
	gp := getg()
  0x422edf		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.m.curg != gp {
  0x422ee8		488b5130		MOVQ 0x30(CX), DX	
  0x422eec		48398ac0000000		CMPQ CX, 0xc0(DX)	
  0x422ef3		0f85a9040000		JNE 0x4233a2		
	if gp.m.mallocing != 0 {
  0x422ef9		83baf000000000		CMPL $0x0, 0xf0(DX)	
  0x422f00		0f8531040000		JNE 0x423337		
	gp := getg()
  0x422f06		48894c2438		MOVQ CX, 0x38(SP)	
	if gp.m.preemptoff != "" {
  0x422f0b		4883ba0001000000	CMPQ $0x0, 0x100(DX)	
  0x422f13		0f853e030000		JNE 0x423257		
	if gp.m.locks != 0 {
  0x422f19		83ba0801000000		CMPL $0x0, 0x108(DX)	
  0x422f20		0f85c6020000		JNE 0x4231ec		
	var p _panic
  0x422f26		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x422f2f		0f57c0			XORPS X0, X0		
  0x422f32		0f11442460		MOVUPS X0, 0x60(SP)	
  0x422f37		0f11442470		MOVUPS X0, 0x70(SP)	
	p.arg = e
  0x422f3c		488b942490000000	MOVQ 0x90(SP), DX	
  0x422f44		4889542460		MOVQ DX, 0x60(SP)	
  0x422f49		488b942498000000	MOVQ 0x98(SP), DX	
  0x422f51		4889542468		MOVQ DX, 0x68(SP)	
	p.link = gp._panic
  0x422f56		488b5120		MOVQ 0x20(CX), DX	
  0x422f5a		4889542470		MOVQ DX, 0x70(SP)	
	gp._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x422f5f		90			NOPL			
  0x422f60		488d542458		LEAQ 0x58(SP), DX	
  0x422f65		48895120		MOVQ DX, 0x20(CX)	
	atomic.Xadd(&runningPanicDefers, 1)
  0x422f69		bb01000000		MOVL $0x1, BX				
  0x422f6e		488d35879d0b00		LEAQ runtime.runningPanicDefers(SB), SI	
  0x422f75		f00fc11e		LOCK XADDL BX, 0(SI)			
	for {
  0x422f79		eb11			JMP 0x422f8c		
		d := gp._defer
  0x422f7b		488b4c2438		MOVQ 0x38(SP), CX	
	var p _panic
  0x422f80		488d542458		LEAQ 0x58(SP), DX			
  0x422f85		488d35709d0b00		LEAQ runtime.runningPanicDefers(SB), SI	
		d := gp._defer
  0x422f8c		488b5928		MOVQ 0x28(CX), BX	
		if d == nil {
  0x422f90		4885db			TESTQ BX, BX		
  0x422f93		0f84bd010000		JE 0x423156		
		d := gp._defer
  0x422f99		488d7928		LEAQ 0x28(CX), DI	
		if d.started {
  0x422f9d		807b0400		CMPB $0x0, 0x4(BX)	
  0x422fa1		7463			JE 0x423006		
			if d._panic != nil {
  0x422fa3		4c8b4320		MOVQ 0x20(BX), R8	
  0x422fa7		4d85c0			TESTQ R8, R8		
  0x422faa		7405			JE 0x422fb1		
				d._panic.aborted = true
  0x422fac		41c6402101		MOVB $0x1, 0x21(R8)	
			d._panic = nil
  0x422fb1		48c7432000000000	MOVQ $0x0, 0x20(BX)	
			d.fn = nil
  0x422fb9		833d609e0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422fc0		752b			JNE 0x422fed				
  0x422fc2		48c7431800000000	MOVQ $0x0, 0x18(BX)			
			gp._defer = d.link
  0x422fca		488b4328		MOVQ 0x28(BX), AX			
  0x422fce		833d4b9e0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x422fd5		750f			JNE 0x422fe6				
  0x422fd7		48894128		MOVQ AX, 0x28(CX)			
			freedefer(d)
  0x422fdb		48891c24		MOVQ BX, 0(SP)			
  0x422fdf		e85cf8ffff		CALL runtime.freedefer(SB)	
			continue
  0x422fe4		eb95			JMP 0x422f7b		
			gp._defer = d.link
  0x422fe6		e895660200		CALL runtime.gcWriteBarrier(SB)	
  0x422feb		ebee			JMP 0x422fdb			
			d.fn = nil
  0x422fed		4c8d4318		LEAQ 0x18(BX), R8	
		d := gp._defer
  0x422ff1		4889f8			MOVQ DI, AX		
			d.fn = nil
  0x422ff4		4c89c7			MOVQ R8, DI		
		d := gp._defer
  0x422ff7		4989c1			MOVQ AX, R9		
			d.fn = nil
  0x422ffa		31c0			XORL AX, AX			
  0x422ffc		e87f660200		CALL runtime.gcWriteBarrier(SB)	
			gp._defer = d.link
  0x423001		4c89cf			MOVQ R9, DI		
			d.fn = nil
  0x423004		ebc4			JMP 0x422fca		
		d := gp._defer
  0x423006		48897c2450		MOVQ DI, 0x50(SP)	
  0x42300b		48895c2448		MOVQ BX, 0x48(SP)	
		d.started = true
  0x423010		c6430401		MOVB $0x1, 0x4(BX)	
		d._panic = (*_panic)(noescape(unsafe.Pointer(&p)))
  0x423014		90			NOPL			
  0x423015		48895320		MOVQ DX, 0x20(BX)	
		p.argp = unsafe.Pointer(getargp(0))
  0x423019		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x423021		e8fa030000		CALL runtime.getargp(SB)	
  0x423026		488b442408		MOVQ 0x8(SP), AX		
  0x42302b		4889442458		MOVQ AX, 0x58(SP)		
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x423030		90			NOPL			
	if d.siz == 0 {
  0x423031		488b442448		MOVQ 0x48(SP), AX	
  0x423036		8b08			MOVL 0(AX), CX		
  0x423038		85c9			TESTL CX, CX		
  0x42303a		0f850c010000		JNE 0x42314c		
  0x423040		31d2			XORL DX, DX		
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x423042		488b5818		MOVQ 0x18(AX), BX		
  0x423046		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x42304e		48895c2408		MOVQ BX, 0x8(SP)		
  0x423053		4889542410		MOVQ DX, 0x10(SP)		
  0x423058		894c2418		MOVL CX, 0x18(SP)		
  0x42305c		894c241c		MOVL CX, 0x1c(SP)		
  0x423060		e82b480200		CALL runtime.reflectcall(SB)	
		p.argp = nil
  0x423065		48c744245800000000	MOVQ $0x0, 0x58(SP)	
		if gp._defer != d {
  0x42306e		488b442448		MOVQ 0x48(SP), AX	
  0x423073		488b4c2438		MOVQ 0x38(SP), CX	
  0x423078		48394128		CMPQ AX, 0x28(CX)	
  0x42307c		0f854f010000		JNE 0x4231d1		
		d._panic = nil
  0x423082		48c7402000000000	MOVQ $0x0, 0x20(AX)	
		d.fn = nil
  0x42308a		833d8f9d0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x423091		0f859f000000		JNE 0x423136				
  0x423097		48c7401800000000	MOVQ $0x0, 0x18(AX)			
		gp._defer = d.link
  0x42309f		488b5028		MOVQ 0x28(AX), DX			
  0x4230a3		833d769d0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4230aa		7572			JNE 0x42311e				
  0x4230ac		48895128		MOVQ DX, 0x28(CX)			
		pc := d.pc
  0x4230b0		488b4810		MOVQ 0x10(AX), CX	
  0x4230b4		48894c2420		MOVQ CX, 0x20(SP)	
		sp := unsafe.Pointer(d.sp) // must be pointer so it gets adjusted during stack copy
  0x4230b9		488b5008		MOVQ 0x8(AX), DX	
  0x4230bd		4889542430		MOVQ DX, 0x30(SP)	
		freedefer(d)
  0x4230c2		48890424		MOVQ AX, 0(SP)			
  0x4230c6		e875f7ffff		CALL runtime.freedefer(SB)	
		if p.recovered {
  0x4230cb		807c247800		CMPB $0x0, 0x78(SP)	
  0x4230d0		0f84a5feffff		JE 0x422f7b		
			atomic.Xadd(&runningPanicDefers, -1)
  0x4230d6		b8ffffffff		MOVL $-0x1, AX				
  0x4230db		488d0d1a9c0b00		LEAQ runtime.runningPanicDefers(SB), CX	
  0x4230e2		f00fc101		LOCK XADDL AX, 0(CX)			
			gp._panic = p.link
  0x4230e6		488b442470		MOVQ 0x70(SP), AX	
  0x4230eb		488b4c2438		MOVQ 0x38(SP), CX	
  0x4230f0		48894120		MOVQ AX, 0x20(CX)	
			for gp._panic != nil && gp._panic.aborted {
  0x4230f4		eb08			JMP 0x4230fe		
				gp._panic = gp._panic.link
  0x4230f6		488b4018		MOVQ 0x18(AX), AX	
  0x4230fa		48894120		MOVQ AX, 0x20(CX)	
			for gp._panic != nil && gp._panic.aborted {
  0x4230fe		488b4120		MOVQ 0x20(CX), AX	
  0x423102		4885c0			TESTQ AX, AX		
  0x423105		7409			JE 0x423110		
  0x423107		80782100		CMPB $0x0, 0x21(AX)	
  0x42310b		75e9			JNE 0x4230f6		
  0x42310d		4885c0			TESTQ AX, AX		
			if gp._panic == nil { // must be done with signal
  0x423110		757c			JNE 0x42318e		
				gp.sig = 0
  0x423112		c781e000000000000000	MOVL $0x0, 0xe0(CX)	
  0x42311c		eb70			JMP 0x42318e		
		gp._defer = d.link
  0x42311e		488b7c2450		MOVQ 0x50(SP), DI	
		d := gp._defer
  0x423123		4889c3			MOVQ AX, BX		
		gp._defer = d.link
  0x423126		4889d0			MOVQ DX, AX			
  0x423129		e852650200		CALL runtime.gcWriteBarrier(SB)	
		pc := d.pc
  0x42312e		4889d8			MOVQ BX, AX		
		gp._defer = d.link
  0x423131		e97affffff		JMP 0x4230b0		
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x423136		488d7818		LEAQ 0x18(AX), DI	
		d := gp._defer
  0x42313a		4889c2			MOVQ AX, DX		
		d.fn = nil
  0x42313d		31c0			XORL AX, AX			
  0x42313f		e83c650200		CALL runtime.gcWriteBarrier(SB)	
		gp._defer = d.link
  0x423144		4889d0			MOVQ DX, AX		
		d.fn = nil
  0x423147		e953ffffff		JMP 0x42309f		
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x42314c		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x42314d		488d5030		LEAQ 0x30(AX), DX	
		reflectcall(nil, unsafe.Pointer(d.fn), deferArgs(d), uint32(d.siz), uint32(d.siz))
  0x423151		e9ecfeffff		JMP 0x423042		
	preprintpanics(gp._panic)
  0x423156		488b4120		MOVQ 0x20(CX), AX		
  0x42315a		48890424		MOVQ AX, 0(SP)			
  0x42315e		e87dfaffff		CALL runtime.preprintpanics(SB)	
	fatalpanic(gp._panic) // should not return
  0x423163		488b442438		MOVQ 0x38(SP), AX		
  0x423168		488b4020		MOVQ 0x20(AX), AX		
  0x42316c		48890424		MOVQ AX, 0(SP)			
  0x423170		e86b050000		CALL runtime.fatalpanic(SB)	
	*(*int)(nil) = 0      // not reached
  0x423175		31c0			XORL AX, AX		
  0x423177		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x42317e		488bac2480000000	MOVQ 0x80(SP), BP	
  0x423186		4881c488000000		ADDQ $0x88, SP		
  0x42318d		c3			RET			
			gp.sigcode0 = uintptr(sp)
  0x42318e		488b442430		MOVQ 0x30(SP), AX	
  0x423193		48898100010000		MOVQ AX, 0x100(CX)	
			gp.sigcode1 = pc
  0x42319a		488b442420		MOVQ 0x20(SP), AX	
  0x42319f		48898108010000		MOVQ AX, 0x108(CX)	
			mcall(recovery)
  0x4231a6		488d05ab070500		LEAQ 0x507ab(IP), AX	
  0x4231ad		48890424		MOVQ AX, 0(SP)		
  0x4231b1		e8fa440200		CALL runtime.mcall(SB)	
			throw("recovery failed") // mcall should not return
  0x4231b6		488d0500cd0400		LEAQ 0x4cd00(IP), AX	
  0x4231bd		48890424		MOVQ AX, 0(SP)		
  0x4231c1		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x4231ca		e8b1020000		CALL runtime.throw(SB)	
  0x4231cf		0f0b			UD2			
			throw("bad defer entry in panic")
  0x4231d1		488d0542dc0400		LEAQ 0x4dc42(IP), AX	
  0x4231d8		48890424		MOVQ AX, 0(SP)		
  0x4231dc		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x4231e5		e896020000		CALL runtime.throw(SB)	
  0x4231ea		0f0b			UD2			
		print("panic: ")
  0x4231ec		e8cf0c0000		CALL runtime.printlock(SB)	
  0x4231f1		488d0538c10400		LEAQ 0x4c138(IP), AX		
  0x4231f8		48890424		MOVQ AX, 0(SP)			
  0x4231fc		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x423205		e8e6150000		CALL runtime.printstring(SB)	
  0x42320a		e8310d0000		CALL runtime.printunlock(SB)	
		printany(e)
  0x42320f		488b842490000000	MOVQ 0x90(SP), AX		
  0x423217		48890424		MOVQ AX, 0(SP)			
  0x42321b		488b842498000000	MOVQ 0x98(SP), AX		
  0x423223		4889442408		MOVQ AX, 0x8(SP)		
  0x423228		e88334feff		CALL runtime.printany(SB)	
		print("\n")
  0x42322d		e88e0c0000		CALL runtime.printlock(SB)	
  0x423232		e8190f0000		CALL runtime.printnl(SB)	
  0x423237		e8040d0000		CALL runtime.printunlock(SB)	
		throw("panic holding locks")
  0x42323c		488d0544d20400		LEAQ 0x4d244(IP), AX	
  0x423243		48890424		MOVQ AX, 0(SP)		
  0x423247		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x423250		e82b020000		CALL runtime.throw(SB)	
  0x423255		0f0b			UD2			
		print("panic: ")
  0x423257		e8640c0000		CALL runtime.printlock(SB)	
  0x42325c		488d05cdc00400		LEAQ 0x4c0cd(IP), AX		
  0x423263		48890424		MOVQ AX, 0(SP)			
  0x423267		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x423270		e87b150000		CALL runtime.printstring(SB)	
  0x423275		e8c60c0000		CALL runtime.printunlock(SB)	
		printany(e)
  0x42327a		488b842490000000	MOVQ 0x90(SP), AX		
  0x423282		48890424		MOVQ AX, 0(SP)			
  0x423286		488b842498000000	MOVQ 0x98(SP), AX		
  0x42328e		4889442408		MOVQ AX, 0x8(SP)		
  0x423293		e81834feff		CALL runtime.printany(SB)	
		print("\n")
  0x423298		e8230c0000		CALL runtime.printlock(SB)	
  0x42329d		e8ae0e0000		CALL runtime.printnl(SB)	
  0x4232a2		e8990c0000		CALL runtime.printunlock(SB)	
		print("preempt off reason: ")
  0x4232a7		e8140c0000		CALL runtime.printlock(SB)	
  0x4232ac		488d055ed40400		LEAQ 0x4d45e(IP), AX		
  0x4232b3		48890424		MOVQ AX, 0(SP)			
  0x4232b7		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x4232c0		e82b150000		CALL runtime.printstring(SB)	
  0x4232c5		e8760c0000		CALL runtime.printunlock(SB)	
		print(gp.m.preemptoff)
  0x4232ca		488b442438		MOVQ 0x38(SP), AX		
  0x4232cf		488b4030		MOVQ 0x30(AX), AX		
  0x4232d3		488b8800010000		MOVQ 0x100(AX), CX		
  0x4232da		48894c2428		MOVQ CX, 0x28(SP)		
  0x4232df		488b80f8000000		MOVQ 0xf8(AX), AX		
  0x4232e6		4889442440		MOVQ AX, 0x40(SP)		
  0x4232eb		e8d00b0000		CALL runtime.printlock(SB)	
  0x4232f0		488b442440		MOVQ 0x40(SP), AX		
  0x4232f5		48890424		MOVQ AX, 0(SP)			
  0x4232f9		488b442428		MOVQ 0x28(SP), AX		
  0x4232fe		4889442408		MOVQ AX, 0x8(SP)		
  0x423303		e8e8140000		CALL runtime.printstring(SB)	
  0x423308		e8330c0000		CALL runtime.printunlock(SB)	
		print("\n")
  0x42330d		e8ae0b0000		CALL runtime.printlock(SB)	
  0x423312		e8390e0000		CALL runtime.printnl(SB)	
  0x423317		e8240c0000		CALL runtime.printunlock(SB)	
		throw("panic during preemptoff")
  0x42331c		488d059dd90400		LEAQ 0x4d99d(IP), AX	
  0x423323		48890424		MOVQ AX, 0(SP)		
  0x423327		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x423330		e84b010000		CALL runtime.throw(SB)	
  0x423335		0f0b			UD2			
		print("panic: ")
  0x423337		e8840b0000		CALL runtime.printlock(SB)	
  0x42333c		488d05edbf0400		LEAQ 0x4bfed(IP), AX		
  0x423343		48890424		MOVQ AX, 0(SP)			
  0x423347		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x423350		e89b140000		CALL runtime.printstring(SB)	
  0x423355		e8e60b0000		CALL runtime.printunlock(SB)	
		printany(e)
  0x42335a		488b842490000000	MOVQ 0x90(SP), AX		
  0x423362		48890424		MOVQ AX, 0(SP)			
  0x423366		488b842498000000	MOVQ 0x98(SP), AX		
  0x42336e		4889442408		MOVQ AX, 0x8(SP)		
  0x423373		e83833feff		CALL runtime.printany(SB)	
		print("\n")
  0x423378		e8430b0000		CALL runtime.printlock(SB)	
  0x42337d		e8ce0d0000		CALL runtime.printnl(SB)	
  0x423382		e8b90b0000		CALL runtime.printunlock(SB)	
		throw("panic during malloc")
  0x423387		488d05d3d00400		LEAQ 0x4d0d3(IP), AX	
  0x42338e		48890424		MOVQ AX, 0(SP)		
  0x423392		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x42339b		e8e0000000		CALL runtime.throw(SB)	
  0x4233a0		0f0b			UD2			
		print("panic: ")
  0x4233a2		e8190b0000		CALL runtime.printlock(SB)	
  0x4233a7		488d0582bf0400		LEAQ 0x4bf82(IP), AX		
  0x4233ae		48890424		MOVQ AX, 0(SP)			
  0x4233b2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4233bb		e830140000		CALL runtime.printstring(SB)	
  0x4233c0		e87b0b0000		CALL runtime.printunlock(SB)	
		printany(e)
  0x4233c5		488b842490000000	MOVQ 0x90(SP), AX		
  0x4233cd		48890424		MOVQ AX, 0(SP)			
  0x4233d1		488b842498000000	MOVQ 0x98(SP), AX		
  0x4233d9		4889442408		MOVQ AX, 0x8(SP)		
  0x4233de		e8cd32feff		CALL runtime.printany(SB)	
		print("\n")
  0x4233e3		e8d80a0000		CALL runtime.printlock(SB)	
  0x4233e8		e8630d0000		CALL runtime.printnl(SB)	
  0x4233ed		e84e0b0000		CALL runtime.printunlock(SB)	
		throw("panic on system stack")
  0x4233f2		488d055fd40400		LEAQ 0x4d45f(IP), AX	
  0x4233f9		48890424		MOVQ AX, 0(SP)		
  0x4233fd		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x423406		e875000000		CALL runtime.throw(SB)	
  0x42340b		0f0b			UD2			
func gopanic(e interface{}) {
  0x42340d		e86e440200		CALL runtime.morestack_noctxt(SB)	
  0x423412		e999faffff		JMP runtime.gopanic(SB)			

TEXT runtime.getargp(SB) /usr/local/go/src/runtime/panic.go
	return uintptr(noescape(unsafe.Pointer(&x)))
  0x423420		488d442408		LEAQ 0x8(SP), AX	
  0x423425		90			NOPL			
  0x423426		4889442410		MOVQ AX, 0x10(SP)	
  0x42342b		c3			RET			

TEXT runtime.gorecover(SB) /usr/local/go/src/runtime/panic.go
	gp := getg()
  0x423430		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	p := gp._panic
  0x423439		488b4020		MOVQ 0x20(AX), AX	
	if p != nil && !p.recovered && argp == uintptr(p.argp) {
  0x42343d		4885c0			TESTQ AX, AX		
  0x423440		7406			JE 0x423448		
  0x423442		80782000		CMPB $0x0, 0x20(AX)	
  0x423446		7409			JE 0x423451		
	return nil
  0x423448		0f57c0			XORPS X0, X0		
  0x42344b		0f11442410		MOVUPS X0, 0x10(SP)	
  0x423450		c3			RET			
	if p != nil && !p.recovered && argp == uintptr(p.argp) {
  0x423451		488b08			MOVQ 0(AX), CX		
  0x423454		488b542408		MOVQ 0x8(SP), DX	
  0x423459		4839ca			CMPQ CX, DX		
  0x42345c		75ea			JNE 0x423448		
		p.recovered = true
  0x42345e		c6402001		MOVB $0x1, 0x20(AX)	
		return p.arg
  0x423462		488b4810		MOVQ 0x10(AX), CX	
  0x423466		488b4008		MOVQ 0x8(AX), AX	
  0x42346a		4889442410		MOVQ AX, 0x10(SP)	
  0x42346f		48894c2418		MOVQ CX, 0x18(SP)	
  0x423474		c3			RET			

TEXT runtime.throw(SB) /usr/local/go/src/runtime/panic.go
func throw(s string) {
  0x423480		4883ec28		SUBQ $0x28, SP		
  0x423484		48896c2420		MOVQ BP, 0x20(SP)	
  0x423489		488d6c2420		LEAQ 0x20(SP), BP	
	systemstack(func() {
  0x42348e		0f57c0			XORPS X0, X0				
  0x423491		0f11442408		MOVUPS X0, 0x8(SP)			
  0x423496		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x42349f		488d05ea2e0200		LEAQ runtime.throw.func1(SB), AX	
  0x4234a6		4889442408		MOVQ AX, 0x8(SP)			
  0x4234ab		488b442430		MOVQ 0x30(SP), AX			
  0x4234b0		4889442410		MOVQ AX, 0x10(SP)			
  0x4234b5		488b442438		MOVQ 0x38(SP), AX			
  0x4234ba		4889442418		MOVQ AX, 0x18(SP)			
  0x4234bf		488d442408		LEAQ 0x8(SP), AX			
  0x4234c4		48890424		MOVQ AX, 0(SP)				
  0x4234c8		e863420200		CALL runtime.systemstack(SB)		
	gp := getg()
  0x4234cd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp.m.throwing == 0 {
  0x4234d6		488b4030		MOVQ 0x30(AX), AX	
  0x4234da		83b8f400000000		CMPL $0x0, 0xf4(AX)	
  0x4234e1		750a			JNE 0x4234ed		
		gp.m.throwing = 1
  0x4234e3		c780f400000001000000	MOVL $0x1, 0xf4(AX)	
	fatalthrow()
  0x4234ed		e87e010000		CALL runtime.fatalthrow(SB)	
	*(*int)(nil) = 0 // not reached
  0x4234f2		31c0			XORL AX, AX		
  0x4234f4		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x4234fb		488b6c2420		MOVQ 0x20(SP), BP	
  0x423500		4883c428		ADDQ $0x28, SP		
  0x423504		c3			RET			

TEXT runtime.recovery(SB) /usr/local/go/src/runtime/panic.go
func recovery(gp *g) {
  0x423510		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423519		483b6110		CMPQ 0x10(CX), SP	
  0x42351d		0f8637010000		JBE 0x42365a		
  0x423523		4883ec30		SUBQ $0x30, SP		
  0x423527		48896c2428		MOVQ BP, 0x28(SP)	
  0x42352c		488d6c2428		LEAQ 0x28(SP), BP	
	sp := gp.sigcode0
  0x423531		488b442438		MOVQ 0x38(SP), AX	
  0x423536		488b8800010000		MOVQ 0x100(AX), CX	
	pc := gp.sigcode1
  0x42353d		488b9008010000		MOVQ 0x108(AX), DX	
	if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
  0x423544		4885c9			TESTQ CX, CX		
  0x423547		7412			JE 0x42355b		
  0x423549		488b18			MOVQ 0(AX), BX		
  0x42354c		4839d9			CMPQ BX, CX		
  0x42354f		7339			JAE 0x42358a		
  0x423551		be01000000		MOVL $0x1, SI		
  0x423556		4084f6			TESTL SI, SI		
  0x423559		7539			JNE 0x423594		
	gp.sched.sp = sp
  0x42355b		48894838		MOVQ CX, 0x38(AX)	
	gp.sched.pc = pc
  0x42355f		48895040		MOVQ DX, 0x40(AX)	
	gp.sched.lr = 0
  0x423563		48c7406000000000	MOVQ $0x0, 0x60(AX)	
	gp.sched.ret = 1
  0x42356b		48c7405801000000	MOVQ $0x1, 0x58(AX)	
	gogo(&gp.sched)
  0x423573		4883c038		ADDQ $0x38, AX		
  0x423577		48890424		MOVQ AX, 0(SP)		
  0x42357b		e8d0400200		CALL runtime.gogo(SB)	
}
  0x423580		488b6c2428		MOVQ 0x28(SP), BP	
  0x423585		4883c430		ADDQ $0x30, SP		
  0x423589		c3			RET			
	if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
  0x42358a		48394808		CMPQ CX, 0x8(AX)	
  0x42358e		400f92c6		SETB SI			
  0x423592		ebc2			JMP 0x423556		
	sp := gp.sigcode0
  0x423594		48894c2410		MOVQ CX, 0x10(SP)	
	if sp != 0 && (sp < gp.stack.lo || gp.stack.hi < sp) {
  0x423599		48895c2418		MOVQ BX, 0x18(SP)	
		print("recover: ", hex(sp), " not in [", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n")
  0x42359e		488b4008		MOVQ 0x8(AX), AX		
  0x4235a2		4889442420		MOVQ AX, 0x20(SP)		
  0x4235a7		e814090000		CALL runtime.printlock(SB)	
  0x4235ac		488d0506c00400		LEAQ 0x4c006(IP), AX		
  0x4235b3		48890424		MOVQ AX, 0(SP)			
  0x4235b7		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4235c0		e82b120000		CALL runtime.printstring(SB)	
  0x4235c5		488b442410		MOVQ 0x10(SP), AX		
  0x4235ca		48890424		MOVQ AX, 0(SP)			
  0x4235ce		e8dd100000		CALL runtime.printhex(SB)	
  0x4235d3		488d0507bf0400		LEAQ 0x4bf07(IP), AX		
  0x4235da		48890424		MOVQ AX, 0(SP)			
  0x4235de		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4235e7		e804120000		CALL runtime.printstring(SB)	
  0x4235ec		488b442418		MOVQ 0x18(SP), AX		
  0x4235f1		48890424		MOVQ AX, 0(SP)			
  0x4235f5		e8b6100000		CALL runtime.printhex(SB)	
  0x4235fa		488d059bba0400		LEAQ 0x4ba9b(IP), AX		
  0x423601		48890424		MOVQ AX, 0(SP)			
  0x423605		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42360e		e8dd110000		CALL runtime.printstring(SB)	
  0x423613		488b442420		MOVQ 0x20(SP), AX		
  0x423618		48890424		MOVQ AX, 0(SP)			
  0x42361c		e88f100000		CALL runtime.printhex(SB)	
  0x423621		488d0580ba0400		LEAQ 0x4ba80(IP), AX		
  0x423628		48890424		MOVQ AX, 0(SP)			
  0x42362c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x423635		e8b6110000		CALL runtime.printstring(SB)	
  0x42363a		e801090000		CALL runtime.printunlock(SB)	
		throw("bad recovery")
  0x42363f		488d0567c40400		LEAQ 0x4c467(IP), AX	
  0x423646		48890424		MOVQ AX, 0(SP)		
  0x42364a		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x423653		e828feffff		CALL runtime.throw(SB)	
  0x423658		0f0b			UD2			
func recovery(gp *g) {
  0x42365a		e821420200		CALL runtime.morestack_noctxt(SB)	
  0x42365f		e9acfeffff		JMP runtime.recovery(SB)		

TEXT runtime.fatalthrow(SB) /usr/local/go/src/runtime/panic.go
func fatalthrow() {
  0x423670		4883ec30		SUBQ $0x30, SP		
  0x423674		48896c2428		MOVQ BP, 0x28(SP)	
  0x423679		488d6c2428		LEAQ 0x28(SP), BP	
	gp := getg()
  0x42367e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	systemstack(func() {
  0x423687		0f57c0			XORPS X0, X0				
  0x42368a		0f11442408		MOVUPS X0, 0x8(SP)			
  0x42368f		0f11442418		MOVUPS X0, 0x18(SP)			
  0x423694		488d0d752d0200		LEAQ runtime.fatalthrow.func1(SB), CX	
  0x42369b		48894c2408		MOVQ CX, 0x8(SP)			
  0x4236a0		4889442410		MOVQ AX, 0x10(SP)			
  0x4236a5		488b442430		MOVQ 0x30(SP), AX			
  0x4236aa		4889442418		MOVQ AX, 0x18(SP)			
  0x4236af		488d442438		LEAQ 0x38(SP), AX			
  0x4236b4		4889442420		MOVQ AX, 0x20(SP)			
  0x4236b9		488d442408		LEAQ 0x8(SP), AX			
  0x4236be		48890424		MOVQ AX, 0(SP)				
  0x4236c2		e869400200		CALL runtime.systemstack(SB)		
	*(*int)(nil) = 0 // not reached
  0x4236c7		31c0			XORL AX, AX		
  0x4236c9		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x4236d0		488b6c2428		MOVQ 0x28(SP), BP	
  0x4236d5		4883c430		ADDQ $0x30, SP		
  0x4236d9		c3			RET			

TEXT runtime.fatalpanic(SB) /usr/local/go/src/runtime/panic.go
func fatalpanic(msgs *_panic) {
  0x4236e0		4883ec48		SUBQ $0x48, SP		
  0x4236e4		48896c2440		MOVQ BP, 0x40(SP)	
  0x4236e9		488d6c2440		LEAQ 0x40(SP), BP	
	gp := getg()
  0x4236ee		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	var docrash bool
  0x4236f7		c644240f00		MOVB $0x0, 0xf(SP)	
	systemstack(func() {
  0x4236fc		0f57c0			XORPS X0, X0				
  0x4236ff		0f11442410		MOVUPS X0, 0x10(SP)			
  0x423704		0f11442420		MOVUPS X0, 0x20(SP)			
  0x423709		0f11442430		MOVUPS X0, 0x30(SP)			
  0x42370e		488d0d8b2d0200		LEAQ runtime.fatalpanic.func1(SB), CX	
  0x423715		48894c2410		MOVQ CX, 0x10(SP)			
  0x42371a		488b4c2450		MOVQ 0x50(SP), CX			
  0x42371f		48894c2418		MOVQ CX, 0x18(SP)			
  0x423724		4889442420		MOVQ AX, 0x20(SP)			
  0x423729		488b442448		MOVQ 0x48(SP), AX			
  0x42372e		4889442428		MOVQ AX, 0x28(SP)			
  0x423733		488d442450		LEAQ 0x50(SP), AX			
  0x423738		4889442430		MOVQ AX, 0x30(SP)			
  0x42373d		488d44240f		LEAQ 0xf(SP), AX			
  0x423742		4889442438		MOVQ AX, 0x38(SP)			
  0x423747		488d442410		LEAQ 0x10(SP), AX			
  0x42374c		48890424		MOVQ AX, 0(SP)				
  0x423750		e8db3f0200		CALL runtime.systemstack(SB)		
	if docrash {
  0x423755		807c240f00		CMPB $0x0, 0xf(SP)	
  0x42375a		7523			JNE 0x42377f		
	systemstack(func() {
  0x42375c		488d057d000500		LEAQ 0x5007d(IP), AX		
  0x423763		48890424		MOVQ AX, 0(SP)			
  0x423767		e8c43f0200		CALL runtime.systemstack(SB)	
	*(*int)(nil) = 0 // not reached
  0x42376c		31c0			XORL AX, AX		
  0x42376e		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x423775		488b6c2440		MOVQ 0x40(SP), BP	
  0x42377a		4883c448		ADDQ $0x48, SP		
  0x42377e		c3			RET			
		crash()
  0x42377f		e83c1b0100		CALL runtime.crash(SB)	
  0x423784		ebd6			JMP 0x42375c		

TEXT runtime.startpanic_m(SB) /usr/local/go/src/runtime/panic.go
func startpanic_m() bool {
  0x423790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423799		483b6110		CMPQ 0x10(CX), SP	
  0x42379d		0f8681010000		JBE 0x423924		
  0x4237a3		4883ec20		SUBQ $0x20, SP		
  0x4237a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4237ac		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x4237b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if mheap_.cachealloc.size == 0 { // very early
  0x4237ba		48833dc6530a0000	CMPQ $0x0, runtime.mheap_+9544(SB)	
  0x4237c2		0f842a010000		JE 0x4238f2				
	_g_.m.mallocing++
  0x4237c8		488b4830		MOVQ 0x30(AX), CX	
  0x4237cc		ff81f0000000		INCL 0xf0(CX)		
	if _g_.m.locks < 0 {
  0x4237d2		488b4830		MOVQ 0x30(AX), CX	
  0x4237d6		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x4237dd		7d0a			JGE 0x4237e9		
		_g_.m.locks = 1
  0x4237df		c7810801000001000000	MOVL $0x1, 0x108(CX)	
	switch _g_.m.dying {
  0x4237e9		488b4030		MOVQ 0x30(AX), AX	
  0x4237ed		8b880c010000		MOVL 0x10c(AX), CX	
	case 0:
  0x4237f3		85c9			TESTL CX, CX		
  0x4237f5		0f849c000000		JE 0x423897		
	case 1:
  0x4237fb		83f901			CMPL $0x1, CX		
  0x4237fe		745b			JE 0x42385b		
	case 2:
  0x423800		83f902			CMPL $0x2, CX		
  0x423803		741b			JE 0x423820		
		exit(5)
  0x423805		c7042405000000		MOVL $0x5, 0(SP)	
  0x42380c		e80f760200		CALL runtime.exit(SB)	
		return false // Need to return something.
  0x423811		c644242800		MOVB $0x0, 0x28(SP)	
  0x423816		488b6c2418		MOVQ 0x18(SP), BP	
  0x42381b		4883c420		ADDQ $0x20, SP		
  0x42381f		c3			RET			
		_g_.m.dying = 3
  0x423820		c7800c01000003000000	MOVL $0x3, 0x10c(AX)	
		print("stack trace unavailable\n")
  0x42382a		e891060000		CALL runtime.printlock(SB)	
  0x42382f		488d051cd70400		LEAQ 0x4d71c(IP), AX		
  0x423836		48890424		MOVQ AX, 0(SP)			
  0x42383a		48c744240818000000	MOVQ $0x18, 0x8(SP)		
  0x423843		e8a80f0000		CALL runtime.printstring(SB)	
  0x423848		e8f3060000		CALL runtime.printunlock(SB)	
		exit(4)
  0x42384d		c7042404000000		MOVL $0x4, 0(SP)	
  0x423854		e8c7750200		CALL runtime.exit(SB)	
	default:
  0x423859		ebaa			JMP 0x423805		
		_g_.m.dying = 2
  0x42385b		c7800c01000002000000	MOVL $0x2, 0x10c(AX)	
		print("panic during panic\n")
  0x423865		e856060000		CALL runtime.printlock(SB)	
  0x42386a		488d0503cc0400		LEAQ 0x4cc03(IP), AX		
  0x423871		48890424		MOVQ AX, 0(SP)			
  0x423875		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x42387e		e86d0f0000		CALL runtime.printstring(SB)	
  0x423883		e8b8060000		CALL runtime.printunlock(SB)	
		return false
  0x423888		c644242800		MOVB $0x0, 0x28(SP)	
  0x42388d		488b6c2418		MOVQ 0x18(SP), BP	
  0x423892		4883c420		ADDQ $0x20, SP		
  0x423896		c3			RET			
		_g_.m.dying = 1
  0x423897		c7800c01000001000000	MOVL $0x1, 0x10c(AX)	
		atomic.Xadd(&panicking, 1)
  0x4238a1		b801000000		MOVL $0x1, AX			
  0x4238a6		488d0d47940b00		LEAQ runtime.panicking(SB), CX	
  0x4238ad		f00fc101		LOCK XADDL AX, 0(CX)		
		lock(&paniclk)
  0x4238b1		488d05e8940b00		LEAQ runtime.paniclk(SB), AX	
  0x4238b8		48890424		MOVQ AX, 0(SP)			
  0x4238bc		e81f4efeff		CALL runtime.lock(SB)		
		if debug.schedtrace > 0 || debug.scheddetail > 0 {
  0x4238c1		833d50960b0000		CMPL $0x0, runtime.debug+56(SB)	
  0x4238c8		7e1d			JLE 0x4238e7			
			schedtrace(true)
  0x4238ca		c6042401		MOVB $0x1, 0(SP)		
  0x4238ce		e8bdbc0000		CALL runtime.schedtrace(SB)	
		freezetheworld()
  0x4238d3		e8d82d0000		CALL runtime.freezetheworld(SB)	
		return true
  0x4238d8		c644242801		MOVB $0x1, 0x28(SP)	
  0x4238dd		488b6c2418		MOVQ 0x18(SP), BP	
  0x4238e2		4883c420		ADDQ $0x20, SP		
  0x4238e6		c3			RET			
		if debug.schedtrace > 0 || debug.scheddetail > 0 {
  0x4238e7		833d26960b0000		CMPL $0x0, runtime.debug+52(SB)	
  0x4238ee		7fda			JG 0x4238ca			
  0x4238f0		ebe1			JMP 0x4238d3			
	_g_ := getg()
  0x4238f2		4889442410		MOVQ AX, 0x10(SP)	
		print("runtime: panic before malloc heap initialized\n")
  0x4238f7		e8c4050000		CALL runtime.printlock(SB)	
  0x4238fc		488d05c5f60400		LEAQ 0x4f6c5(IP), AX		
  0x423903		48890424		MOVQ AX, 0(SP)			
  0x423907		48c74424082e000000	MOVQ $0x2e, 0x8(SP)		
  0x423910		e8db0e0000		CALL runtime.printstring(SB)	
  0x423915		e826060000		CALL runtime.printunlock(SB)	
	_g_.m.mallocing++
  0x42391a		488b442410		MOVQ 0x10(SP), AX	
		print("runtime: panic before malloc heap initialized\n")
  0x42391f		e9a4feffff		JMP 0x4237c8		
func startpanic_m() bool {
  0x423924		e8573f0200		CALL runtime.morestack_noctxt(SB)	
  0x423929		e962feffff		JMP runtime.startpanic_m(SB)		

TEXT runtime.dopanic_m(SB) /usr/local/go/src/runtime/panic.go
func dopanic_m(gp *g, pc, sp uintptr) bool {
  0x423930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423939		483b6110		CMPQ 0x10(CX), SP	
  0x42393d		0f8661030000		JBE 0x423ca4		
  0x423943		4883ec60		SUBQ $0x60, SP		
  0x423947		48896c2458		MOVQ BP, 0x58(SP)	
  0x42394c		488d6c2458		LEAQ 0x58(SP), BP	
	if gp.sig != 0 {
  0x423951		488b442468		MOVQ 0x68(SP), AX	
  0x423956		8b88e0000000		MOVL 0xe0(AX), CX	
  0x42395c		85c9			TESTL CX, CX		
  0x42395e		0f841d010000		JE 0x423a81		
		signame := signame(gp.sig)
  0x423964		90			NOPL			
	if sig >= uint32(len(sigtable)) {
  0x423965		83f941			CMPL $0x41, CX		
  0x423968		0f820f030000		JB 0x423c7d		
  0x42396e		31d2			XORL DX, DX		
  0x423970		31db			XORL BX, BX		
		if signame != "" {
  0x423972		4885db			TESTQ BX, BX		
  0x423975		0f84c9020000		JE 0x423c44		
		signame := signame(gp.sig)
  0x42397b		4889542450		MOVQ DX, 0x50(SP)	
  0x423980		48895c2430		MOVQ BX, 0x30(SP)	
			print("[signal ", signame)
  0x423985		e836050000		CALL runtime.printlock(SB)	
  0x42398a		488d05b7ba0400		LEAQ 0x4bab7(IP), AX		
  0x423991		48890424		MOVQ AX, 0(SP)			
  0x423995		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x42399e		e84d0e0000		CALL runtime.printstring(SB)	
  0x4239a3		488b442450		MOVQ 0x50(SP), AX		
  0x4239a8		48890424		MOVQ AX, 0(SP)			
  0x4239ac		488b442430		MOVQ 0x30(SP), AX		
  0x4239b1		4889442408		MOVQ AX, 0x8(SP)		
  0x4239b6		e8350e0000		CALL runtime.printstring(SB)	
  0x4239bb		e880050000		CALL runtime.printunlock(SB)	
		print(" code=", hex(gp.sigcode0), " addr=", hex(gp.sigcode1), " pc=", hex(gp.sigpc), "]\n")
  0x4239c0		488b442468		MOVQ 0x68(SP), AX		
  0x4239c5		488b8800010000		MOVQ 0x100(AX), CX		
  0x4239cc		48894c2448		MOVQ CX, 0x48(SP)		
  0x4239d1		488b9008010000		MOVQ 0x108(AX), DX		
  0x4239d8		4889542440		MOVQ DX, 0x40(SP)		
  0x4239dd		488b9810010000		MOVQ 0x110(AX), BX		
  0x4239e4		48895c2438		MOVQ BX, 0x38(SP)		
  0x4239e9		e8d2040000		CALL runtime.printlock(SB)	
  0x4239ee		488d0537b80400		LEAQ 0x4b837(IP), AX		
  0x4239f5		48890424		MOVQ AX, 0(SP)			
  0x4239f9		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x423a02		e8e90d0000		CALL runtime.printstring(SB)	
  0x423a07		488b442448		MOVQ 0x48(SP), AX		
  0x423a0c		48890424		MOVQ AX, 0(SP)			
  0x423a10		e89b0c0000		CALL runtime.printhex(SB)	
  0x423a15		488d0504b80400		LEAQ 0x4b804(IP), AX		
  0x423a1c		48890424		MOVQ AX, 0(SP)			
  0x423a20		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x423a29		e8c20d0000		CALL runtime.printstring(SB)	
  0x423a2e		488b442440		MOVQ 0x40(SP), AX		
  0x423a33		48890424		MOVQ AX, 0(SP)			
  0x423a37		e8740c0000		CALL runtime.printhex(SB)	
  0x423a3c		488d05cab60400		LEAQ 0x4b6ca(IP), AX		
  0x423a43		48890424		MOVQ AX, 0(SP)			
  0x423a47		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x423a50		e89b0d0000		CALL runtime.printstring(SB)	
  0x423a55		488b442438		MOVQ 0x38(SP), AX		
  0x423a5a		48890424		MOVQ AX, 0(SP)			
  0x423a5e		e84d0c0000		CALL runtime.printhex(SB)	
  0x423a63		488d053eb60400		LEAQ 0x4b63e(IP), AX		
  0x423a6a		48890424		MOVQ AX, 0(SP)			
  0x423a6e		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x423a77		e8740d0000		CALL runtime.printstring(SB)	
  0x423a7c		e8bf040000		CALL runtime.printunlock(SB)	
	level, all, docrash := gotraceback()
  0x423a81		90			NOPL			
	_g_ := getg()
  0x423a82		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x423a8b		8b0d7bb50900		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x423a91		488b4030		MOVQ 0x30(AX), AX	
  0x423a95		83b8f400000000		CMPL $0x0, 0xf4(AX)	
  0x423a9c		0f8e96010000		JLE 0x423c38		
  0x423aa2		ba01000000		MOVL $0x1, DX		
	t := atomic.Load(&traceback_cache)
  0x423aa7		894c2428		MOVL CX, 0x28(SP)	
	if _g_.m.traceback != 0 {
  0x423aab		0fb68029010000		MOVZX 0x129(AX), AX	
		level = int32(t >> tracebackShift)
  0x423ab2		c1e902			SHRL $0x2, CX		
	if _g_.m.traceback != 0 {
  0x423ab5		84c0			TESTL AL, AL		
	level, all, docrash := gotraceback()
  0x423ab7		0f45c8			CMOVNE AX, CX		
	_g_ := getg()
  0x423aba		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if level > 0 {
  0x423ac3		85c9			TESTL CX, CX		
	if _g_.m.traceback != 0 {
  0x423ac5		0f8e85000000		JLE 0x423b50		
		if gp != gp.m.curg {
  0x423acb		488b742468		MOVQ 0x68(SP), SI	
  0x423ad0		488b7e30		MOVQ 0x30(SI), DI	
  0x423ad4		4839b7c0000000		CMPQ SI, 0xc0(DI)	
  0x423adb		410f95c0		SETNE R8		
		if !didothers && all {
  0x423adf		4109d0			ORL DX, R8		
  0x423ae2		4488442427		MOVB R8, 0x27(SP)	
		if gp != gp.m.g0 {
  0x423ae7		483937			CMPQ SI, 0(DI)		
  0x423aea		0f85fb000000		JNE 0x423beb		
		} else if level >= 2 || _g_.m.throwing > 0 {
  0x423af0		83f902			CMPL $0x2, CX		
  0x423af3		0f8cdc000000		JL 0x423bd5		
			print("\nruntime stack:\n")
  0x423af9		e8c2030000		CALL runtime.printlock(SB)	
  0x423afe		488d0592c40400		LEAQ 0x4c492(IP), AX		
  0x423b05		48890424		MOVQ AX, 0(SP)			
  0x423b09		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x423b12		e8d90c0000		CALL runtime.printstring(SB)	
  0x423b17		e824040000		CALL runtime.printunlock(SB)	
			traceback(pc, sp, 0, gp)
  0x423b1c		488b442470		MOVQ 0x70(SP), AX		
  0x423b21		48890424		MOVQ AX, 0(SP)			
  0x423b25		488b442478		MOVQ 0x78(SP), AX		
  0x423b2a		4889442408		MOVQ AX, 0x8(SP)		
  0x423b2f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x423b38		488b442468		MOVQ 0x68(SP), AX		
  0x423b3d		4889442418		MOVQ AX, 0x18(SP)		
  0x423b42		e869c00100		CALL runtime.traceback(SB)	
		if !didothers && all {
  0x423b47		803d58910b0000		CMPB $0x0, runtime.didothers(SB)	
  0x423b4e		7462			JE 0x423bb2				
	unlock(&paniclk)
  0x423b50		488d0549920b00		LEAQ runtime.paniclk(SB), AX	
  0x423b57		48890424		MOVQ AX, 0(SP)			
  0x423b5b		e8304dfeff		CALL runtime.unlock(SB)		
	if atomic.Xadd(&panicking, -1) != 0 {
  0x423b60		b8ffffffff		MOVL $-0x1, AX			
  0x423b65		488d0d88910b00		LEAQ runtime.panicking(SB), CX	
  0x423b6c		f00fc101		LOCK XADDL AX, 0(CX)		
  0x423b70		ffc8			DECL AX				
  0x423b72		85c0			TESTL AX, AX			
  0x423b74		751a			JNE 0x423b90			
	crash = t&tracebackCrash != 0
  0x423b76		8b442428		MOVL 0x28(SP), AX	
  0x423b7a		0fbae000		BTL $0x0, AX		
	return docrash
  0x423b7e		0f92842480000000	SETB 0x80(SP)		
  0x423b86		488b6c2458		MOVQ 0x58(SP), BP	
  0x423b8b		4883c460		ADDQ $0x60, SP		
  0x423b8f		c3			RET			
		lock(&deadlock)
  0x423b90		488d05b9910b00		LEAQ runtime.deadlock(SB), AX	
  0x423b97		48890424		MOVQ AX, 0(SP)			
  0x423b9b		e8404bfeff		CALL runtime.lock(SB)		
		lock(&deadlock)
  0x423ba0		488d05a9910b00		LEAQ runtime.deadlock(SB), AX	
  0x423ba7		48890424		MOVQ AX, 0(SP)			
  0x423bab		e8304bfeff		CALL runtime.lock(SB)		
  0x423bb0		ebc4			JMP 0x423b76			
		if !didothers && all {
  0x423bb2		0fb6442427		MOVZX 0x27(SP), AX	
  0x423bb7		84c0			TESTL AL, AL		
  0x423bb9		7495			JE 0x423b50		
			didothers = true
  0x423bbb		c605e4900b0001		MOVB $0x1, runtime.didothers(SB)	
			tracebackothers(gp)
  0x423bc2		488b442468		MOVQ 0x68(SP), AX			
  0x423bc7		48890424		MOVQ AX, 0(SP)				
  0x423bcb		e8a0d00100		CALL runtime.tracebackothers(SB)	
  0x423bd0		e97bffffff		JMP 0x423b50				
		} else if level >= 2 || _g_.m.throwing > 0 {
  0x423bd5		488b4030		MOVQ 0x30(AX), AX	
  0x423bd9		83b8f400000000		CMPL $0x0, 0xf4(AX)	
  0x423be0		0f8f13ffffff		JG 0x423af9		
  0x423be6		e95cffffff		JMP 0x423b47		
			print("\n")
  0x423beb		e8d0020000		CALL runtime.printlock(SB)	
  0x423bf0		e85b050000		CALL runtime.printnl(SB)	
  0x423bf5		e846030000		CALL runtime.printunlock(SB)	
			goroutineheader(gp)
  0x423bfa		488b442468		MOVQ 0x68(SP), AX			
  0x423bff		48890424		MOVQ AX, 0(SP)				
  0x423c03		e888cd0100		CALL runtime.goroutineheader(SB)	
			traceback(pc, sp, 0, gp)
  0x423c08		488b442470		MOVQ 0x70(SP), AX		
  0x423c0d		48890424		MOVQ AX, 0(SP)			
  0x423c11		488b442478		MOVQ 0x78(SP), AX		
  0x423c16		4889442408		MOVQ AX, 0x8(SP)		
  0x423c1b		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x423c24		488b442468		MOVQ 0x68(SP), AX		
  0x423c29		4889442418		MOVQ AX, 0x18(SP)		
  0x423c2e		e87dbf0100		CALL runtime.traceback(SB)	
  0x423c33		e90fffffff		JMP 0x423b47			
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x423c38		0fbae101		BTL $0x1, CX		
  0x423c3c		0f92c2			SETB DL			
  0x423c3f		e963feffff		JMP 0x423aa7		
	if gp.sig != 0 {
  0x423c44		894c242c		MOVL CX, 0x2c(SP)	
			print("[signal ", hex(gp.sig))
  0x423c48		e873020000		CALL runtime.printlock(SB)	
  0x423c4d		488d05f4b70400		LEAQ 0x4b7f4(IP), AX		
  0x423c54		48890424		MOVQ AX, 0(SP)			
  0x423c58		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x423c61		e88a0b0000		CALL runtime.printstring(SB)	
  0x423c66		8b44242c		MOVL 0x2c(SP), AX		
  0x423c6a		48890424		MOVQ AX, 0(SP)			
  0x423c6e		e83d0a0000		CALL runtime.printhex(SB)	
  0x423c73		e8c8020000		CALL runtime.printunlock(SB)	
  0x423c78		e943fdffff		JMP 0x4239c0			
	return sigtable[sig].name
  0x423c7d		4883f941		CMPQ $0x41, CX			
  0x423c81		731a			JAE 0x423c9d			
  0x423c83		488d3449		LEAQ 0(CX)(CX*2), SI		
  0x423c87		488d3df2c50900		LEAQ runtime.sigtable(SB), DI	
  0x423c8e		488b54f708		MOVQ 0x8(DI)(SI*8), DX		
  0x423c93		488b5cf710		MOVQ 0x10(DI)(SI*8), BX		
		signame := signame(gp.sig)
  0x423c98		e9d5fcffff		JMP 0x423972		
	return sigtable[sig].name
  0x423c9d		e87ee2ffff		CALL runtime.panicindex(SB)	
  0x423ca2		0f0b			UD2				
func dopanic_m(gp *g, pc, sp uintptr) bool {
  0x423ca4		e8d73b0200		CALL runtime.morestack_noctxt(SB)	
  0x423ca9		e982fcffff		JMP runtime.dopanic_m(SB)		

TEXT runtime.shouldPushSigpanic(SB) /usr/local/go/src/runtime/panic.go
func shouldPushSigpanic(gp *g, pc, lr uintptr) bool {
  0x423cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423cb9		483b6110		CMPQ 0x10(CX), SP	
  0x423cbd		0f869b000000		JBE 0x423d5e		
  0x423cc3		4883ec20		SUBQ $0x20, SP		
  0x423cc7		48896c2418		MOVQ BP, 0x18(SP)	
  0x423ccc		488d6c2418		LEAQ 0x18(SP), BP	
	if pc == 0 {
  0x423cd1		488b442430		MOVQ 0x30(SP), AX	
  0x423cd6		4885c0			TESTQ AX, AX		
  0x423cd9		7474			JE 0x423d4f		
	if gp.m.incgo || findfunc(pc).valid() {
  0x423cdb		488b4c2428		MOVQ 0x28(SP), CX	
  0x423ce0		488b4930		MOVQ 0x30(CX), CX	
  0x423ce4		80b91901000000		CMPB $0x0, 0x119(CX)	
  0x423ceb		744d			JE 0x423d3a		
  0x423ced		b801000000		MOVL $0x1, AX		
  0x423cf2		84c0			TESTL AL, AL		
  0x423cf4		7535			JNE 0x423d2b		
	if findfunc(lr).valid() {
  0x423cf6		488b442438		MOVQ 0x38(SP), AX		
  0x423cfb		48890424		MOVQ AX, 0(SP)			
  0x423cff		e8fc6d0100		CALL runtime.findfunc(SB)	
  0x423d04		90			NOPL				
  0x423d05		48837c240800		CMPQ $0x0, 0x8(SP)		
  0x423d0b		740f			JE 0x423d1c			
		return false
  0x423d0d		c644244000		MOVB $0x0, 0x40(SP)	
  0x423d12		488b6c2418		MOVQ 0x18(SP), BP	
  0x423d17		4883c420		ADDQ $0x20, SP		
  0x423d1b		c3			RET			
	return true
  0x423d1c		c644244001		MOVB $0x1, 0x40(SP)	
  0x423d21		488b6c2418		MOVQ 0x18(SP), BP	
  0x423d26		4883c420		ADDQ $0x20, SP		
  0x423d2a		c3			RET			
		return true
  0x423d2b		c644244001		MOVB $0x1, 0x40(SP)	
  0x423d30		488b6c2418		MOVQ 0x18(SP), BP	
  0x423d35		4883c420		ADDQ $0x20, SP		
  0x423d39		c3			RET			
	if gp.m.incgo || findfunc(pc).valid() {
  0x423d3a		48890424		MOVQ AX, 0(SP)			
  0x423d3e		e8bd6d0100		CALL runtime.findfunc(SB)	
  0x423d43		48837c240800		CMPQ $0x0, 0x8(SP)		
	return f._func != nil
  0x423d49		0f95c0			SETNE AL		
	if gp.m.incgo || findfunc(pc).valid() {
  0x423d4c		90			NOPL			
  0x423d4d		eba3			JMP 0x423cf2		
		return false
  0x423d4f		c644244000		MOVB $0x0, 0x40(SP)	
  0x423d54		488b6c2418		MOVQ 0x18(SP), BP	
  0x423d59		4883c420		ADDQ $0x20, SP		
  0x423d5d		c3			RET			
func shouldPushSigpanic(gp *g, pc, lr uintptr) bool {
  0x423d5e		e81d3b0200		CALL runtime.morestack_noctxt(SB)	
  0x423d63		e948ffffff		JMP runtime.shouldPushSigpanic(SB)	

TEXT runtime.recordForPanic(SB) /usr/local/go/src/runtime/print.go
func recordForPanic(b []byte) {
  0x423d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423d79		483b6110		CMPQ 0x10(CX), SP	
  0x423d7d		0f862c010000		JBE 0x423eaf		
  0x423d83		4883ec30		SUBQ $0x30, SP		
  0x423d87		48896c2428		MOVQ BP, 0x28(SP)	
  0x423d8c		488d6c2428		LEAQ 0x28(SP), BP	
	printlock()
  0x423d91		e82a010000		CALL runtime.printlock(SB)	
	if atomic.Load(&panicking) == 0 {
  0x423d96		8b05588f0b00		MOVL runtime.panicking(SB), AX	
  0x423d9c		85c0			TESTL AX, AX			
  0x423d9e		0f85f5000000		JNE 0x423e99			
		for i := 0; i < len(b); {
  0x423da4		488b442440		MOVQ 0x40(SP), AX	
  0x423da9		488b4c2448		MOVQ 0x48(SP), CX	
  0x423dae		488b542438		MOVQ 0x38(SP), DX	
  0x423db3		31db			XORL BX, BX		
  0x423db5		eb33			JMP 0x423dea		
			printBacklogIndex += n
  0x423db7		488b35f28f0b00		MOVQ runtime.printBacklogIndex(SB), SI	
  0x423dbe		4c01c6			ADDQ R8, SI				
			printBacklogIndex %= len(printBacklog)
  0x423dc1		4989f2			MOVQ SI, R10				
  0x423dc4		48c1fe3f		SARQ $0x3f, SI				
  0x423dc8		48c1ee37		SHRQ $0x37, SI				
  0x423dcc		4c01d6			ADDQ R10, SI				
  0x423dcf		48c1fe09		SARQ $0x9, SI				
  0x423dd3		48c1e609		SHLQ $0x9, SI				
  0x423dd7		4929f2			SUBQ SI, R10				
  0x423dda		4c8915cf8f0b00		MOVQ R10, runtime.printBacklogIndex(SB)	
			i += n
  0x423de1		4c01c3			ADDQ R8, BX		
		for i := 0; i < len(b); {
  0x423de4		4889f8			MOVQ DI, AX		
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423de7		4c89c9			MOVQ R9, CX		
		for i := 0; i < len(b); {
  0x423dea		4839c3			CMPQ AX, BX		
  0x423ded		0f8da6000000		JGE 0x423e99		
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423df3		488b35b68f0b00		MOVQ runtime.printBacklogIndex(SB), SI	
  0x423dfa		4881fe00020000		CMPQ $0x200, SI				
  0x423e01		0f87a1000000		JA 0x423ea8				
  0x423e07		488dbe00feffff		LEAQ 0xfffffe00(SI), DI			
  0x423e0e		4989f8			MOVQ DI, R8				
  0x423e11		48c1ff3f		SARQ $0x3f, DI				
  0x423e15		4821fe			ANDQ DI, SI				
		for i := 0; i < len(b); {
  0x423e18		4839c3			CMPQ AX, BX		
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423e1b		0f8787000000		JA 0x423ea8				
  0x423e21		49f7d8			NEGQ R8					
  0x423e24		4889c7			MOVQ AX, DI				
  0x423e27		4829d8			SUBQ BX, AX				
  0x423e2a		4939c0			CMPQ AX, R8				
  0x423e2d		4c0f4fc0		CMOVG AX, R8				
  0x423e31		488d0508960b00		LEAQ runtime.printBacklog(SB), AX	
  0x423e38		4801c6			ADDQ AX, SI				
  0x423e3b		4989c9			MOVQ CX, R9				
  0x423e3e		4829d9			SUBQ BX, CX				
  0x423e41		48f7d9			NEGQ CX					
  0x423e44		48c1f93f		SARQ $0x3f, CX				
  0x423e48		4821d9			ANDQ BX, CX				
  0x423e4b		4801d1			ADDQ DX, CX				
  0x423e4e		4839ce			CMPQ CX, SI				
  0x423e51		0f8460ffffff		JE 0x423db7				
		for i := 0; i < len(b); {
  0x423e57		48895c2420		MOVQ BX, 0x20(SP)	
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423e5c		4c89442418		MOVQ R8, 0x18(SP)			
  0x423e61		48893424		MOVQ SI, 0(SP)				
  0x423e65		48894c2408		MOVQ CX, 0x8(SP)			
  0x423e6a		4c89442410		MOVQ R8, 0x10(SP)			
  0x423e6f		e8dc680200		CALL runtime.memmove(SB)		
  0x423e74		488d05c5950b00		LEAQ runtime.printBacklog(SB), AX	
  0x423e7b		488b542438		MOVQ 0x38(SP), DX			
			i += n
  0x423e80		488b5c2420		MOVQ 0x20(SP), BX	
		for i := 0; i < len(b); {
  0x423e85		488b7c2440		MOVQ 0x40(SP), DI	
			printBacklogIndex += n
  0x423e8a		4c8b442418		MOVQ 0x18(SP), R8	
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423e8f		4c8b4c2448		MOVQ 0x48(SP), R9	
  0x423e94		e91effffff		JMP 0x423db7		
	printunlock()
  0x423e99		e8a2000000		CALL runtime.printunlock(SB)	
}
  0x423e9e		488b6c2428		MOVQ 0x28(SP), BP	
  0x423ea3		4883c430		ADDQ $0x30, SP		
  0x423ea7		c3			RET			
			n := copy(printBacklog[printBacklogIndex:], b[i:])
  0x423ea8		e8a3e1ffff		CALL runtime.panicslice(SB)	
  0x423ead		0f0b			UD2				
func recordForPanic(b []byte) {
  0x423eaf		e8cc390200		CALL runtime.morestack_noctxt(SB)	
  0x423eb4		e9b7feffff		JMP runtime.recordForPanic(SB)		

TEXT runtime.printlock(SB) /usr/local/go/src/runtime/print.go
func printlock() {
  0x423ec0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423ec9		483b6110		CMPQ 0x10(CX), SP	
  0x423ecd		7661			JBE 0x423f30		
  0x423ecf		4883ec18		SUBQ $0x18, SP		
  0x423ed3		48896c2410		MOVQ BP, 0x10(SP)	
  0x423ed8		488d6c2410		LEAQ 0x10(SP), BP	
	mp := getg().m
  0x423edd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x423ee6		488b4030		MOVQ 0x30(AX), AX	
	mp.locks++ // do not reschedule between printlock++ and lock(&debuglock).
  0x423eea		ff8008010000		INCL 0x108(AX)		
	mp.printlock++
  0x423ef0		0fb68818010000		MOVZX 0x118(AX), CX	
  0x423ef7		8d5101			LEAL 0x1(CX), DX	
  0x423efa		889018010000		MOVB DL, 0x118(AX)	
	if mp.printlock == 1 {
  0x423f00		84c9			TESTL CL, CL		
  0x423f02		7410			JE 0x423f14		
	mp.locks-- // now we know debuglock is held and holding up mp.locks for us.
  0x423f04		ff8808010000		DECL 0x108(AX)		
}
  0x423f0a		488b6c2410		MOVQ 0x10(SP), BP	
  0x423f0f		4883c418		ADDQ $0x18, SP		
  0x423f13		c3			RET			
	mp := getg().m
  0x423f14		4889442408		MOVQ AX, 0x8(SP)	
		lock(&debuglock)
  0x423f19		488d05388e0b00		LEAQ runtime.debuglock(SB), AX	
  0x423f20		48890424		MOVQ AX, 0(SP)			
  0x423f24		e8b747feff		CALL runtime.lock(SB)		
	mp.locks-- // now we know debuglock is held and holding up mp.locks for us.
  0x423f29		488b442408		MOVQ 0x8(SP), AX	
		lock(&debuglock)
  0x423f2e		ebd4			JMP 0x423f04		
func printlock() {
  0x423f30		e84b390200		CALL runtime.morestack_noctxt(SB)	
  0x423f35		eb89			JMP runtime.printlock(SB)		

TEXT runtime.printunlock(SB) /usr/local/go/src/runtime/print.go
func printunlock() {
  0x423f40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423f49		483b6110		CMPQ 0x10(CX), SP	
  0x423f4d		764c			JBE 0x423f9b		
  0x423f4f		4883ec10		SUBQ $0x10, SP		
  0x423f53		48896c2408		MOVQ BP, 0x8(SP)	
  0x423f58		488d6c2408		LEAQ 0x8(SP), BP	
	mp := getg().m
  0x423f5d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x423f66		488b4030		MOVQ 0x30(AX), AX	
	mp.printlock--
  0x423f6a		0fb68818010000		MOVZX 0x118(AX), CX	
  0x423f71		8d51ff			LEAL -0x1(CX), DX	
  0x423f74		889018010000		MOVB DL, 0x118(AX)	
	if mp.printlock == 0 {
  0x423f7a		80f901			CMPL $0x1, CL		
  0x423f7d		740a			JE 0x423f89		
  0x423f7f		488b6c2408		MOVQ 0x8(SP), BP	
  0x423f84		4883c410		ADDQ $0x10, SP		
  0x423f88		c3			RET			
		unlock(&debuglock)
  0x423f89		488d05c88d0b00		LEAQ runtime.debuglock(SB), AX	
  0x423f90		48890424		MOVQ AX, 0(SP)			
  0x423f94		e8f748feff		CALL runtime.unlock(SB)		
  0x423f99		ebe4			JMP 0x423f7f			
func printunlock() {
  0x423f9b		e8e0380200		CALL runtime.morestack_noctxt(SB)	
  0x423fa0		eb9e			JMP runtime.printunlock(SB)		

TEXT runtime.gwrite(SB) /usr/local/go/src/runtime/print.go
func gwrite(b []byte) {
  0x423fb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x423fb9		483b6110		CMPQ 0x10(CX), SP	
  0x423fbd		0f8628010000		JBE 0x4240eb		
  0x423fc3		4883ec38		SUBQ $0x38, SP		
  0x423fc7		48896c2430		MOVQ BP, 0x30(SP)	
  0x423fcc		488d6c2430		LEAQ 0x30(SP), BP	
	if len(b) == 0 {
  0x423fd1		488b442448		MOVQ 0x48(SP), AX	
  0x423fd6		4885c0			TESTQ AX, AX		
  0x423fd9		0f84fb000000		JE 0x4240da		
	recordForPanic(b)
  0x423fdf		488b4c2440		MOVQ 0x40(SP), CX		
  0x423fe4		48890c24		MOVQ CX, 0(SP)			
  0x423fe8		4889442408		MOVQ AX, 0x8(SP)		
  0x423fed		488b542450		MOVQ 0x50(SP), DX		
  0x423ff2		4889542410		MOVQ DX, 0x10(SP)		
  0x423ff7		e874fdffff		CALL runtime.recordForPanic(SB)	
	gp := getg()
  0x423ffc		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp == nil || gp.writebuf == nil || gp.m.dying > 0 {
  0x424005		4885c0			TESTQ AX, AX		
  0x424008		7427			JE 0x424031		
  0x42400a		488b88f8000000		MOVQ 0xf8(AX), CX	
  0x424011		488b90f0000000		MOVQ 0xf0(AX), DX	
  0x424018		488b98e8000000		MOVQ 0xe8(AX), BX	
  0x42401f		4885db			TESTQ BX, BX		
  0x424022		740d			JE 0x424031		
  0x424024		488b7030		MOVQ 0x30(AX), SI	
  0x424028		83be0c01000000		CMPL $0x0, 0x10c(SI)	
  0x42402f		7e2b			JLE 0x42405c		
		writeErr(b)
  0x424031		90			NOPL			
	write(2, unsafe.Pointer(&b[0]), int32(len(b)))
  0x424032		48c7042402000000	MOVQ $0x2, 0(SP)	
  0x42403a		488b442440		MOVQ 0x40(SP), AX	
  0x42403f		4889442408		MOVQ AX, 0x8(SP)	
  0x424044		488b442448		MOVQ 0x48(SP), AX	
  0x424049		89442410		MOVL AX, 0x10(SP)	
  0x42404d		e84e6e0200		CALL runtime.write(SB)	
		return
  0x424052		488b6c2430		MOVQ 0x30(SP), BP	
  0x424057		4883c438		ADDQ $0x38, SP		
  0x42405b		c3			RET			
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x42405c		4829d1			SUBQ DX, CX		
  0x42405f		488b742448		MOVQ 0x48(SP), SI	
  0x424064		4839f1			CMPQ SI, CX		
  0x424067		4889cf			MOVQ CX, DI		
  0x42406a		480f4fce		CMOVG SI, CX		
  0x42406e		48f7df			NEGQ DI			
  0x424071		48c1ff3f		SARQ $0x3f, DI		
  0x424075		4821fa			ANDQ DI, DX		
  0x424078		4801da			ADDQ BX, DX		
  0x42407b		488b5c2440		MOVQ 0x40(SP), BX	
  0x424080		4839da			CMPQ BX, DX		
  0x424083		752c			JNE 0x4240b1		
	gp.writebuf = gp.writebuf[:len(gp.writebuf)+n]
  0x424085		488b90f0000000		MOVQ 0xf0(AX), DX	
  0x42408c		488b98f8000000		MOVQ 0xf8(AX), BX	
  0x424093		4801d1			ADDQ DX, CX		
  0x424096		4885c9			TESTQ CX, CX		
  0x424099		7c49			JL 0x4240e4		
  0x42409b		4839d9			CMPQ BX, CX		
  0x42409e		7744			JA 0x4240e4		
  0x4240a0		488988f0000000		MOVQ CX, 0xf0(AX)	
}
  0x4240a7		488b6c2430		MOVQ 0x30(SP), BP	
  0x4240ac		4883c438		ADDQ $0x38, SP		
  0x4240b0		c3			RET			
	gp := getg()
  0x4240b1		4889442428		MOVQ AX, 0x28(SP)	
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x4240b6		48894c2420		MOVQ CX, 0x20(SP)		
  0x4240bb		48891424		MOVQ DX, 0(SP)			
  0x4240bf		48895c2408		MOVQ BX, 0x8(SP)		
  0x4240c4		48894c2410		MOVQ CX, 0x10(SP)		
  0x4240c9		e882660200		CALL runtime.memmove(SB)	
	gp.writebuf = gp.writebuf[:len(gp.writebuf)+n]
  0x4240ce		488b442428		MOVQ 0x28(SP), AX	
  0x4240d3		488b4c2420		MOVQ 0x20(SP), CX	
	n := copy(gp.writebuf[len(gp.writebuf):cap(gp.writebuf)], b)
  0x4240d8		ebab			JMP 0x424085		
		return
  0x4240da		488b6c2430		MOVQ 0x30(SP), BP	
  0x4240df		4883c438		ADDQ $0x38, SP		
  0x4240e3		c3			RET			
	gp.writebuf = gp.writebuf[:len(gp.writebuf)+n]
  0x4240e4		e867dfffff		CALL runtime.panicslice(SB)	
  0x4240e9		0f0b			UD2				
func gwrite(b []byte) {
  0x4240eb		e890370200		CALL runtime.morestack_noctxt(SB)	
  0x4240f0		e9bbfeffff		JMP runtime.gwrite(SB)			

TEXT runtime.printsp(SB) /usr/local/go/src/runtime/print.go
func printsp() {
  0x424100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424109		483b6110		CMPQ 0x10(CX), SP	
  0x42410d		7631			JBE 0x424140		
  0x42410f		4883ec18		SUBQ $0x18, SP		
  0x424113		48896c2410		MOVQ BP, 0x10(SP)	
  0x424118		488d6c2410		LEAQ 0x10(SP), BP	
	printstring(" ")
  0x42411d		488d055caf0400		LEAQ 0x4af5c(IP), AX		
  0x424124		48890424		MOVQ AX, 0(SP)			
  0x424128		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x424131		e8ba060000		CALL runtime.printstring(SB)	
}
  0x424136		488b6c2410		MOVQ 0x10(SP), BP	
  0x42413b		4883c418		ADDQ $0x18, SP		
  0x42413f		c3			RET			
func printsp() {
  0x424140		e83b370200		CALL runtime.morestack_noctxt(SB)	
  0x424145		ebb9			JMP runtime.printsp(SB)			

TEXT runtime.printnl(SB) /usr/local/go/src/runtime/print.go
func printnl() {
  0x424150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424159		483b6110		CMPQ 0x10(CX), SP	
  0x42415d		7631			JBE 0x424190		
  0x42415f		4883ec18		SUBQ $0x18, SP		
  0x424163		48896c2410		MOVQ BP, 0x10(SP)	
  0x424168		488d6c2410		LEAQ 0x10(SP), BP	
	printstring("\n")
  0x42416d		488d0519af0400		LEAQ 0x4af19(IP), AX		
  0x424174		48890424		MOVQ AX, 0(SP)			
  0x424178		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x424181		e86a060000		CALL runtime.printstring(SB)	
}
  0x424186		488b6c2410		MOVQ 0x10(SP), BP	
  0x42418b		4883c418		ADDQ $0x18, SP		
  0x42418f		c3			RET			
func printnl() {
  0x424190		e8eb360200		CALL runtime.morestack_noctxt(SB)	
  0x424195		ebb9			JMP runtime.printnl(SB)			

TEXT runtime.printbool(SB) /usr/local/go/src/runtime/print.go
func printbool(v bool) {
  0x4241a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4241a9		483b6110		CMPQ 0x10(CX), SP	
  0x4241ad		7655			JBE 0x424204		
  0x4241af		4883ec18		SUBQ $0x18, SP		
  0x4241b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4241b8		488d6c2410		LEAQ 0x10(SP), BP	
  0x4241bd		0fb6442420		MOVZX 0x20(SP), AX	
  0x4241c2		84c0			TESTL AL, AL		
	if v {
  0x4241c4		7423			JE 0x4241e9		
		printstring("true")
  0x4241c6		488d05b8af0400		LEAQ 0x4afb8(IP), AX		
  0x4241cd		48890424		MOVQ AX, 0(SP)			
  0x4241d1		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4241da		e811060000		CALL runtime.printstring(SB)	
  0x4241df		488b6c2410		MOVQ 0x10(SP), BP		
  0x4241e4		4883c418		ADDQ $0x18, SP			
  0x4241e8		c3			RET				
		printstring("false")
  0x4241e9		488d0502b00400		LEAQ 0x4b002(IP), AX		
  0x4241f0		48890424		MOVQ AX, 0(SP)			
  0x4241f4		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4241fd		e8ee050000		CALL runtime.printstring(SB)	
  0x424202		ebdb			JMP 0x4241df			
func printbool(v bool) {
  0x424204		e877360200		CALL runtime.morestack_noctxt(SB)	
  0x424209		eb95			JMP runtime.printbool(SB)		

TEXT runtime.printfloat(SB) /usr/local/go/src/runtime/print.go
func printfloat(v float64) {
  0x424210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424219		483b6110		CMPQ 0x10(CX), SP	
  0x42421d		0f8680020000		JBE 0x4244a3		
  0x424223		4883ec38		SUBQ $0x38, SP		
  0x424227		48896c2430		MOVQ BP, 0x30(SP)	
  0x42422c		488d6c2430		LEAQ 0x30(SP), BP	
	case v != v:
  0x424231		f20f10442440		MOVSD_XMM 0x40(SP), X0	
  0x424237		660f2ec0		UCOMISD X0, X0		
  0x42423b		0f853f020000		JNE 0x424480		
  0x424241		0f8a39020000		JP 0x424480		
	case v+v == v && v > 0:
  0x424247		0f10c8			MOVUPS X0, X1		
  0x42424a		f20f58c0		ADDSD X0, X0		
  0x42424e		660f2ec8		UCOMISD X0, X1		
  0x424252		0f8520020000		JNE 0x424478		
  0x424258		0f8a1a020000		JP 0x424478		
  0x42425e		0f57d2			XORPS X2, X2		
  0x424261		660f2eca		UCOMISD X2, X1		
	switch {
  0x424265		0f87ea010000		JA 0x424455		
	case v+v == v && v > 0:
  0x42426b		660f2ec8		UCOMISD X0, X1		
	case v+v == v && v < 0:
  0x42426f		750c			JNE 0x42427d		
  0x424271		7a0a			JP 0x42427d		
  0x424273		660f2ed1		UCOMISD X1, X2		
	switch {
  0x424277		0f87b5010000		JA 0x424432		
	var buf [n + 7]byte
  0x42427d		48c744242200000000	MOVQ $0x0, 0x22(SP)	
  0x424286		48c744242800000000	MOVQ $0x0, 0x28(SP)	
	buf[0] = '+'
  0x42428f		c64424222b		MOVB $0x2b, 0x22(SP)	
	if v == 0 {
  0x424294		660f2ed1		UCOMISD X1, X2		
  0x424298		0f8516010000		JNE 0x4243b4		
  0x42429e		0f8a10010000		JP 0x4243b4		
		if 1/v < 0 {
  0x4242a4		f20f10050c8a0500	MOVSD_XMM $f64.3ff0000000000000(SB), X0	
  0x4242ac		f20f5ec1		DIVSD X1, X0				
  0x4242b0		660f2ed0		UCOMISD X0, X2				
  0x4242b4		7605			JBE 0x4242bb				
			buf[0] = '-'
  0x4242b6		c64424222d		MOVB $0x2d, 0x22(SP)	
	buf[1] = buf[2]
  0x4242bb		31c0			XORL AX, AX		
	if e < 0 {
  0x4242bd		31c9			XORL CX, CX		
	for i := 0; i < n; i++ {
  0x4242bf		eb2d			JMP 0x4242ee		
		s := int(v)
  0x4242c1		f2480f2cd1		CVTTSD2SIQ X1, DX	
		buf[i+2] = byte(s + '0')
  0x4242c6		488d5a30		LEAQ 0x30(DX), BX	
  0x4242ca		488d742422		LEAQ 0x22(SP), SI	
  0x4242cf		885c3102		MOVB BL, 0x2(CX)(SI*1)	
	for i := 0; i < n; i++ {
  0x4242d3		48ffc1			INCQ CX			
		v -= float64(s)
  0x4242d6		0f57c0			XORPS X0, X0		
  0x4242d9		f2480f2ac2		CVTSI2SDQ DX, X0	
  0x4242de		f20f5cc8		SUBSD X0, X1		
		v *= 10
  0x4242e2		f20f1005f6890500	MOVSD_XMM $f64.4024000000000000(SB), X0	
  0x4242ea		f20f59c8		MULSD X0, X1				
	for i := 0; i < n; i++ {
  0x4242ee		4883f907		CMPQ $0x7, CX		
  0x4242f2		7ccd			JL 0x4242c1		
	buf[1] = buf[2]
  0x4242f4		0fb64c2424		MOVZX 0x24(SP), CX	
  0x4242f9		884c2423		MOVB CL, 0x23(SP)	
	buf[2] = '.'
  0x4242fd		c64424242e		MOVB $0x2e, 0x24(SP)	
	buf[n+3] = '+'
  0x424302		66c744242b652b		MOVW $0x2b65, 0x2b(SP)	
	if e < 0 {
  0x424309		4885c0			TESTQ AX, AX		
  0x42430c		7d08			JGE 0x424316		
		buf[n+3] = '-'
  0x42430e		c644242c2d		MOVB $0x2d, 0x2c(SP)	
		e = -e
  0x424313		48f7d8			NEGQ AX			
	buf[n+4] = byte(e/100) + '0'
  0x424316		4889442418		MOVQ AX, 0x18(SP)		
  0x42431b		48b90bd7a3703d0ad7a3	MOVQ $0xa3d70a3d70a3d70b, CX	
  0x424325		48f7e9			IMULQ CX			
  0x424328		488b4c2418		MOVQ 0x18(SP), CX		
  0x42432d		4801ca			ADDQ CX, DX			
  0x424330		48c1fa06		SARQ $0x6, DX			
	buf[n+5] = byte(e/10)%10 + '0'
  0x424334		4889cb			MOVQ CX, BX		
  0x424337		48c1f93f		SARQ $0x3f, CX		
	buf[n+4] = byte(e/100) + '0'
  0x42433b		4829ca			SUBQ CX, DX		
  0x42433e		83c230			ADDL $0x30, DX		
  0x424341		8854242d		MOVB DL, 0x2d(SP)	
	buf[n+5] = byte(e/10)%10 + '0'
  0x424345		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
  0x42434f		48f7eb			IMULQ BX			
  0x424352		4801da			ADDQ BX, DX			
  0x424355		48c1fa03		SARQ $0x3, DX			
	buf[n+6] = byte(e%10) + '0'
  0x424359		4829ca			SUBQ CX, DX		
	buf[n+5] = byte(e/10)%10 + '0'
  0x42435c		0fb6ca			MOVZX DL, CX		
  0x42435f		69c99a010000		IMULL $0x19a, CX, CX	
  0x424365		c1e90c			SHRL $0xc, CX		
  0x424368		8d0c89			LEAL 0(CX)(CX*4), CX	
  0x42436b		d1e1			SHLL $0x1, CX		
  0x42436d		4889d6			MOVQ DX, SI		
  0x424370		29ca			SUBL CX, DX		
  0x424372		8d4a30			LEAL 0x30(DX), CX	
  0x424375		884c242e		MOVB CL, 0x2e(SP)	
	buf[n+6] = byte(e%10) + '0'
  0x424379		488d0cb6		LEAQ 0(SI)(SI*4), CX	
  0x42437d		48d1e1			SHLQ $0x1, CX		
  0x424380		4829cb			SUBQ CX, BX		
  0x424383		8d4b30			LEAL 0x30(BX), CX	
  0x424386		884c242f		MOVB CL, 0x2f(SP)	
	gwrite(buf[:])
  0x42438a		488d4c2422		LEAQ 0x22(SP), CX	
  0x42438f		48890c24		MOVQ CX, 0(SP)		
  0x424393		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x42439c		48c74424100e000000	MOVQ $0xe, 0x10(SP)	
  0x4243a5		e806fcffff		CALL runtime.gwrite(SB)	
}
  0x4243aa		488b6c2430		MOVQ 0x30(SP), BP	
  0x4243af		4883c438		ADDQ $0x38, SP		
  0x4243b3		c3			RET			
		if v < 0 {
  0x4243b4		7611			JBE 0x4243c7		
			buf[0] = '-'
  0x4243b6		c64424222d		MOVB $0x2d, 0x22(SP)	
			v = -v
  0x4243bb		f20f100545890500	MOVSD_XMM $f64.8000000000000000(SB), X0	
  0x4243c3		660fefc8		PXOR X0, X1				
	buf[1] = buf[2]
  0x4243c7		31c0			XORL AX, AX		
		for v >= 10 {
  0x4243c9		eb07			JMP 0x4243d2		
			e++
  0x4243cb		48ffc0			INCQ AX			
			v /= 10
  0x4243ce		f20f5ec8		DIVSD X0, X1		
		for v >= 10 {
  0x4243d2		f20f100506890500	MOVSD_XMM $f64.4024000000000000(SB), X0	
  0x4243da		660f2ec8		UCOMISD X0, X1				
  0x4243de		73eb			JAE 0x4243cb				
  0x4243e0		eb07			JMP 0x4243e9				
			e--
  0x4243e2		48ffc8			DECQ AX			
			v *= 10
  0x4243e5		f20f59c8		MULSD X0, X1		
		for v < 1 {
  0x4243e9		f20f1015c7880500	MOVSD_XMM $f64.3ff0000000000000(SB), X2	
  0x4243f1		660f2ed1		UCOMISD X1, X2				
  0x4243f5		77eb			JA 0x4243e2				
  0x4243f7		31c9			XORL CX, CX				
  0x4243f9		f20f1015d7880500	MOVSD_XMM $f64.4014000000000000(SB), X2	
		for i := 0; i < n; i++ {
  0x424401		eb07			JMP 0x42440a		
  0x424403		48ffc1			INCQ CX			
			h /= 10
  0x424406		f20f5ed0		DIVSD X0, X2		
		for i := 0; i < n; i++ {
  0x42440a		4883f907		CMPQ $0x7, CX		
  0x42440e		7cf3			JL 0x424403		
		v += h
  0x424410		f20f58d1		ADDSD X1, X2		
		if v >= 10 {
  0x424414		660f2ed0		UCOMISD X0, X2		
  0x424418		7213			JB 0x42442d		
			e++
  0x42441a		488d4801		LEAQ 0x1(AX), CX	
			v /= 10
  0x42441e		f20f5ed0		DIVSD X0, X2		
		s := int(v)
  0x424422		0f10ca			MOVUPS X2, X1		
	if e < 0 {
  0x424425		4889c8			MOVQ CX, AX		
	for i := 0; i < n; i++ {
  0x424428		e990feffff		JMP 0x4242bd		
	if e < 0 {
  0x42442d		4889c1			MOVQ AX, CX		
		if v >= 10 {
  0x424430		ebf0			JMP 0x424422		
		printstring("-Inf")
  0x424432		488d05f0ac0400		LEAQ 0x4acf0(IP), AX		
  0x424439		48890424		MOVQ AX, 0(SP)			
  0x42443d		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x424446		e8a5030000		CALL runtime.printstring(SB)	
		return
  0x42444b		488b6c2430		MOVQ 0x30(SP), BP	
  0x424450		4883c438		ADDQ $0x38, SP		
  0x424454		c3			RET			
		printstring("+Inf")
  0x424455		488d05c5ac0400		LEAQ 0x4acc5(IP), AX		
  0x42445c		48890424		MOVQ AX, 0(SP)			
  0x424460		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x424469		e882030000		CALL runtime.printstring(SB)	
		return
  0x42446e		488b6c2430		MOVQ 0x30(SP), BP	
  0x424473		4883c438		ADDQ $0x38, SP		
  0x424477		c3			RET			
  0x424478		0f57d2			XORPS X2, X2		
	case v+v == v && v > 0:
  0x42447b		e9effdffff		JMP 0x42426f		
		printstring("NaN")
  0x424480		488d0547ac0400		LEAQ 0x4ac47(IP), AX		
  0x424487		48890424		MOVQ AX, 0(SP)			
  0x42448b		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x424494		e857030000		CALL runtime.printstring(SB)	
		return
  0x424499		488b6c2430		MOVQ 0x30(SP), BP	
  0x42449e		4883c438		ADDQ $0x38, SP		
  0x4244a2		c3			RET			
func printfloat(v float64) {
  0x4244a3		e8d8330200		CALL runtime.morestack_noctxt(SB)	
  0x4244a8		e963fdffff		JMP runtime.printfloat(SB)		

TEXT runtime.printcomplex(SB) /usr/local/go/src/runtime/print.go
func printcomplex(c complex128) {
  0x4244b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4244b9		483b6110		CMPQ 0x10(CX), SP	
  0x4244bd		7674			JBE 0x424533		
  0x4244bf		4883ec18		SUBQ $0x18, SP		
  0x4244c3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4244c8		488d6c2410		LEAQ 0x10(SP), BP	
	print("(", real(c), imag(c), "i)")
  0x4244cd		e8eef9ffff		CALL runtime.printlock(SB)	
  0x4244d2		488d05a8ab0400		LEAQ 0x4aba8(IP), AX		
  0x4244d9		48890424		MOVQ AX, 0(SP)			
  0x4244dd		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4244e6		e805030000		CALL runtime.printstring(SB)	
  0x4244eb		f20f10442420		MOVSD_XMM 0x20(SP), X0		
  0x4244f1		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x4244f6		e815fdffff		CALL runtime.printfloat(SB)	
  0x4244fb		f20f10442428		MOVSD_XMM 0x28(SP), X0		
  0x424501		f20f110424		MOVSD_XMM X0, 0(SP)		
  0x424506		e805fdffff		CALL runtime.printfloat(SB)	
  0x42450b		488d0598ab0400		LEAQ 0x4ab98(IP), AX		
  0x424512		48890424		MOVQ AX, 0(SP)			
  0x424516		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42451f		e8cc020000		CALL runtime.printstring(SB)	
  0x424524		e817faffff		CALL runtime.printunlock(SB)	
}
  0x424529		488b6c2410		MOVQ 0x10(SP), BP	
  0x42452e		4883c418		ADDQ $0x18, SP		
  0x424532		c3			RET			
func printcomplex(c complex128) {
  0x424533		e848330200		CALL runtime.morestack_noctxt(SB)	
  0x424538		e973ffffff		JMP runtime.printcomplex(SB)		

TEXT runtime.printuint(SB) /usr/local/go/src/runtime/print.go
func printuint(v uint64) {
  0x424540		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424549		488d4424f8		LEAQ -0x8(SP), AX	
  0x42454e		483b4110		CMPQ 0x10(CX), AX	
  0x424552		0f86d7000000		JBE 0x42462f		
  0x424558		4881ec88000000		SUBQ $0x88, SP		
  0x42455f		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x424567		488dac2480000000	LEAQ 0x80(SP), BP	
	var buf [100]byte
  0x42456f		48c744241c00000000	MOVQ $0x0, 0x1c(SP)	
  0x424578		488d7c2420		LEAQ 0x20(SP), DI	
  0x42457d		0f57c0			XORPS X0, X0		
  0x424580		488d7fe0		LEAQ -0x20(DI), DI	
  0x424584		48896c24f0		MOVQ BP, -0x10(SP)	
  0x424589		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42458e		e86e5b0200		CALL 0x44a101		
  0x424593		488b6d00		MOVQ 0(BP), BP		
	for i--; i > 0; i-- {
  0x424597		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x42459f		b863000000		MOVL $0x63, AX		
  0x4245a4		eb07			JMP 0x4245ad		
  0x4245a6		488d43ff		LEAQ -0x1(BX), AX	
		buf[i] = byte(v%10 + '0')
  0x4245aa		4889d1			MOVQ DX, CX		
	for i--; i > 0; i-- {
  0x4245ad		4885c0			TESTQ AX, AX		
  0x4245b0		7e71			JLE 0x424623		
  0x4245b2		4889c2			MOVQ AX, DX		
		buf[i] = byte(v%10 + '0')
  0x4245b5		48b8cdcccccccccccccc	MOVQ $0xcccccccccccccccd, AX	
	for i--; i > 0; i-- {
  0x4245bf		4889d3			MOVQ DX, BX		
		buf[i] = byte(v%10 + '0')
  0x4245c2		48f7e1			MULQ CX			
  0x4245c5		48c1ea03		SHRQ $0x3, DX		
  0x4245c9		488d3492		LEAQ 0(DX)(DX*4), SI	
  0x4245cd		48d1e6			SHLQ $0x1, SI		
  0x4245d0		4889cf			MOVQ CX, DI		
  0x4245d3		4829f1			SUBQ SI, CX		
  0x4245d6		4883c130		ADDQ $0x30, CX		
  0x4245da		884c1c1c		MOVB CL, 0x1c(SP)(BX*1)	
		if v < 10 {
  0x4245de		4883ff0a		CMPQ $0xa, DI		
  0x4245e2		73c2			JAE 0x4245a6		
	gwrite(buf[i:])
  0x4245e4		4883fb64		CMPQ $0x64, BX		
  0x4245e8		773e			JA 0x424628		
  0x4245ea		488d439c		LEAQ -0x64(BX), AX	
  0x4245ee		4889c1			MOVQ AX, CX		
  0x4245f1		48c1f83f		SARQ $0x3f, AX		
  0x4245f5		4821c3			ANDQ AX, BX		
  0x4245f8		488d441c1c		LEAQ 0x1c(SP)(BX*1), AX	
  0x4245fd		48890424		MOVQ AX, 0(SP)		
  0x424601		48f7d9			NEGQ CX			
  0x424604		48894c2408		MOVQ CX, 0x8(SP)	
  0x424609		48894c2410		MOVQ CX, 0x10(SP)	
  0x42460e		e89df9ffff		CALL runtime.gwrite(SB)	
}
  0x424613		488bac2480000000	MOVQ 0x80(SP), BP	
  0x42461b		4881c488000000		ADDQ $0x88, SP		
  0x424622		c3			RET			
	gwrite(buf[i:])
  0x424623		4889c3			MOVQ AX, BX		
	for i--; i > 0; i-- {
  0x424626		ebbc			JMP 0x4245e4		
	gwrite(buf[i:])
  0x424628		e823daffff		CALL runtime.panicslice(SB)	
  0x42462d		0f0b			UD2				
func printuint(v uint64) {
  0x42462f		e84c320200		CALL runtime.morestack_noctxt(SB)	
  0x424634		e907ffffff		JMP runtime.printuint(SB)		

TEXT runtime.printint(SB) /usr/local/go/src/runtime/print.go
func printint(v int64) {
  0x424640		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424649		483b6110		CMPQ 0x10(CX), SP	
  0x42464d		764e			JBE 0x42469d		
  0x42464f		4883ec18		SUBQ $0x18, SP		
  0x424653		48896c2410		MOVQ BP, 0x10(SP)	
  0x424658		488d6c2410		LEAQ 0x10(SP), BP	
	if v < 0 {
  0x42465d		488b442420		MOVQ 0x20(SP), AX	
  0x424662		4885c0			TESTQ AX, AX		
  0x424665		7c13			JL 0x42467a		
	printuint(uint64(v))
  0x424667		48890424		MOVQ AX, 0(SP)			
  0x42466b		e8d0feffff		CALL runtime.printuint(SB)	
}
  0x424670		488b6c2410		MOVQ 0x10(SP), BP	
  0x424675		4883c418		ADDQ $0x18, SP		
  0x424679		c3			RET			
		printstring("-")
  0x42467a		488d0504aa0400		LEAQ 0x4aa04(IP), AX		
  0x424681		48890424		MOVQ AX, 0(SP)			
  0x424685		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42468e		e85d010000		CALL runtime.printstring(SB)	
		v = -v
  0x424693		488b442420		MOVQ 0x20(SP), AX	
  0x424698		48f7d8			NEGQ AX			
  0x42469b		ebca			JMP 0x424667		
func printint(v int64) {
  0x42469d		e8de310200		CALL runtime.morestack_noctxt(SB)	
  0x4246a2		eb9c			JMP runtime.printint(SB)		

TEXT runtime.printhex(SB) /usr/local/go/src/runtime/print.go
func printhex(v uint64) {
  0x4246b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4246b9		488d4424f8		LEAQ -0x8(SP), AX	
  0x4246be		483b4110		CMPQ 0x10(CX), AX	
  0x4246c2		0f86de000000		JBE 0x4247a6		
  0x4246c8		4881ec88000000		SUBQ $0x88, SP		
  0x4246cf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x4246d7		488dac2480000000	LEAQ 0x80(SP), BP	
	var buf [100]byte
  0x4246df		48c744241c00000000	MOVQ $0x0, 0x1c(SP)	
  0x4246e8		488d7c2420		LEAQ 0x20(SP), DI	
  0x4246ed		0f57c0			XORPS X0, X0		
  0x4246f0		488d7fe0		LEAQ -0x20(DI), DI	
  0x4246f4		48896c24f0		MOVQ BP, -0x10(SP)	
  0x4246f9		488d6c24f0		LEAQ -0x10(SP), BP	
  0x4246fe		e8fe590200		CALL 0x44a101		
  0x424703		488b6d00		MOVQ 0(BP), BP		
	for i--; i > 0; i-- {
  0x424707		488b842490000000	MOVQ 0x90(SP), AX	
  0x42470f		b963000000		MOVL $0x63, CX		
  0x424714		eb0a			JMP 0x424720		
  0x424716		48ffc9			DECQ CX			
		v /= 16
  0x424719		48c1ea04		SHRQ $0x4, DX		
		buf[i] = dig[v%16]
  0x42471d		4889d0			MOVQ DX, AX		
	for i--; i > 0; i-- {
  0x424720		4885c9			TESTQ CX, CX		
  0x424723		7e1c			JLE 0x424741		
		buf[i] = dig[v%16]
  0x424725		4889c2			MOVQ AX, DX		
  0x424728		4883e00f		ANDQ $0xf, AX		
  0x42472c		488d1d24b80400		LEAQ 0x4b824(IP), BX	
  0x424733		0fb60403		MOVZX 0(BX)(AX*1), AX	
  0x424737		88440c1c		MOVB AL, 0x1c(SP)(CX*1)	
		if v < 16 {
  0x42473b		4883fa10		CMPQ $0x10, DX		
  0x42473f		73d5			JAE 0x424716		
	i--
  0x424741		488d41ff		LEAQ -0x1(CX), AX	
	buf[i] = 'x'
  0x424745		4883f864		CMPQ $0x64, AX			
  0x424749		7354			JAE 0x42479f			
  0x42474b		c6440c1b78		MOVB $0x78, 0x1b(SP)(CX*1)	
	i--
  0x424750		488d41fe		LEAQ -0x2(CX), AX	
	buf[i] = '0'
  0x424754		4883f864		CMPQ $0x64, AX			
  0x424758		733e			JAE 0x424798			
  0x42475a		c6440c1a30		MOVB $0x30, 0x1a(SP)(CX*1)	
	gwrite(buf[i:])
  0x42475f		4883c19a		ADDQ $-0x66, CX		
  0x424763		4889ca			MOVQ CX, DX		
  0x424766		48c1f93f		SARQ $0x3f, CX		
  0x42476a		4821c8			ANDQ CX, AX		
  0x42476d		488d44041c		LEAQ 0x1c(SP)(AX*1), AX	
  0x424772		48890424		MOVQ AX, 0(SP)		
  0x424776		48f7da			NEGQ DX			
  0x424779		4889542408		MOVQ DX, 0x8(SP)	
  0x42477e		4889542410		MOVQ DX, 0x10(SP)	
  0x424783		e828f8ffff		CALL runtime.gwrite(SB)	
}
  0x424788		488bac2480000000	MOVQ 0x80(SP), BP	
  0x424790		4881c488000000		ADDQ $0x88, SP		
  0x424797		c3			RET			
	buf[i] = '0'
  0x424798		e883d7ffff		CALL runtime.panicindex(SB)	
  0x42479d		0f0b			UD2				
	buf[i] = 'x'
  0x42479f		e87cd7ffff		CALL runtime.panicindex(SB)	
  0x4247a4		0f0b			UD2				
func printhex(v uint64) {
  0x4247a6		e8d5300200		CALL runtime.morestack_noctxt(SB)	
  0x4247ab		e900ffffff		JMP runtime.printhex(SB)		

TEXT runtime.printpointer(SB) /usr/local/go/src/runtime/print.go
func printpointer(p unsafe.Pointer) {
  0x4247b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4247b9		483b6110		CMPQ 0x10(CX), SP	
  0x4247bd		7626			JBE 0x4247e5		
  0x4247bf		4883ec10		SUBQ $0x10, SP		
  0x4247c3		48896c2408		MOVQ BP, 0x8(SP)	
  0x4247c8		488d6c2408		LEAQ 0x8(SP), BP	
	printhex(uint64(uintptr(p)))
  0x4247cd		488b442418		MOVQ 0x18(SP), AX		
  0x4247d2		48890424		MOVQ AX, 0(SP)			
  0x4247d6		e8d5feffff		CALL runtime.printhex(SB)	
}
  0x4247db		488b6c2408		MOVQ 0x8(SP), BP	
  0x4247e0		4883c410		ADDQ $0x10, SP		
  0x4247e4		c3			RET			
func printpointer(p unsafe.Pointer) {
  0x4247e5		e896300200		CALL runtime.morestack_noctxt(SB)	
  0x4247ea		ebc4			JMP runtime.printpointer(SB)		

TEXT runtime.printstring(SB) /usr/local/go/src/runtime/print.go
func printstring(s string) {
  0x4247f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4247f9		483b6110		CMPQ 0x10(CX), SP	
  0x4247fd		7675			JBE 0x424874		
  0x4247ff		4883ec48		SUBQ $0x48, SP		
  0x424803		48896c2440		MOVQ BP, 0x40(SP)	
  0x424808		488d6c2440		LEAQ 0x40(SP), BP	
	gwrite(bytes(s))
  0x42480d		488b442450		MOVQ 0x50(SP), AX	
  0x424812		4889442418		MOVQ AX, 0x18(SP)	
  0x424817		488b442458		MOVQ 0x58(SP), AX	
  0x42481c		4889442420		MOVQ AX, 0x20(SP)	
  0x424821		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x42482a		0f57c0			XORPS X0, X0		
  0x42482d		0f11442430		MOVUPS X0, 0x30(SP)	
  0x424832		90			NOPL			
	sp := stringStructOf(&s)
  0x424833		90			NOPL			
	rp.array = sp.str
  0x424834		488b442418		MOVQ 0x18(SP), AX	
  0x424839		4889442428		MOVQ AX, 0x28(SP)	
	rp.len = sp.len
  0x42483e		488b442420		MOVQ 0x20(SP), AX	
  0x424843		4889442430		MOVQ AX, 0x30(SP)	
	rp.cap = sp.len
  0x424848		488b4c2420		MOVQ 0x20(SP), CX	
  0x42484d		48894c2438		MOVQ CX, 0x38(SP)	
	gwrite(bytes(s))
  0x424852		488b542428		MOVQ 0x28(SP), DX	
  0x424857		48891424		MOVQ DX, 0(SP)		
  0x42485b		4889442408		MOVQ AX, 0x8(SP)	
  0x424860		48894c2410		MOVQ CX, 0x10(SP)	
  0x424865		e846f7ffff		CALL runtime.gwrite(SB)	
}
  0x42486a		488b6c2440		MOVQ 0x40(SP), BP	
  0x42486f		4883c448		ADDQ $0x48, SP		
  0x424873		c3			RET			
func printstring(s string) {
  0x424874		e807300200		CALL runtime.morestack_noctxt(SB)	
  0x424879		e972ffffff		JMP runtime.printstring(SB)		

TEXT runtime.printslice(SB) /usr/local/go/src/runtime/print.go
func printslice(s []byte) {
  0x424880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424889		483b6110		CMPQ 0x10(CX), SP	
  0x42488d		0f86ac000000		JBE 0x42493f		
  0x424893		4883ec28		SUBQ $0x28, SP		
  0x424897		48896c2420		MOVQ BP, 0x20(SP)	
  0x42489c		488d6c2420		LEAQ 0x20(SP), BP	
	print("[", len(s), "/", cap(s), "]")
  0x4248a1		488b442440		MOVQ 0x40(SP), AX		
  0x4248a6		4889442418		MOVQ AX, 0x18(SP)		
  0x4248ab		488b4c2438		MOVQ 0x38(SP), CX		
  0x4248b0		48894c2410		MOVQ CX, 0x10(SP)		
  0x4248b5		e806f6ffff		CALL runtime.printlock(SB)	
  0x4248ba		488d05cba70400		LEAQ 0x4a7cb(IP), AX		
  0x4248c1		48890424		MOVQ AX, 0(SP)			
  0x4248c5		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4248ce		e81dffffff		CALL runtime.printstring(SB)	
  0x4248d3		488b442410		MOVQ 0x10(SP), AX		
  0x4248d8		48890424		MOVQ AX, 0(SP)			
  0x4248dc		e85ffdffff		CALL runtime.printint(SB)	
  0x4248e1		488d059fa70400		LEAQ 0x4a79f(IP), AX		
  0x4248e8		48890424		MOVQ AX, 0(SP)			
  0x4248ec		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4248f5		e8f6feffff		CALL runtime.printstring(SB)	
  0x4248fa		488b442418		MOVQ 0x18(SP), AX		
  0x4248ff		48890424		MOVQ AX, 0(SP)			
  0x424903		e838fdffff		CALL runtime.printint(SB)	
  0x424908		488d0580a70400		LEAQ 0x4a780(IP), AX		
  0x42490f		48890424		MOVQ AX, 0(SP)			
  0x424913		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42491c		e8cffeffff		CALL runtime.printstring(SB)	
  0x424921		e81af6ffff		CALL runtime.printunlock(SB)	
	printpointer(sp.array)
  0x424926		90			NOPL			
  0x424927		488b442430		MOVQ 0x30(SP), AX	
	printhex(uint64(uintptr(p)))
  0x42492c		48890424		MOVQ AX, 0(SP)			
  0x424930		e87bfdffff		CALL runtime.printhex(SB)	
  0x424935		488b6c2420		MOVQ 0x20(SP), BP		
  0x42493a		4883c428		ADDQ $0x28, SP			
  0x42493e		c3			RET				
func printslice(s []byte) {
  0x42493f		e83c2f0200		CALL runtime.morestack_noctxt(SB)	
  0x424944		e937ffffff		JMP runtime.printslice(SB)		

TEXT runtime.printeface(SB) /usr/local/go/src/runtime/print.go
func printeface(e eface) {
  0x424950		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424959		483b6110		CMPQ 0x10(CX), SP	
  0x42495d		0f8689000000		JBE 0x4249ec		
  0x424963		4883ec18		SUBQ $0x18, SP		
  0x424967		48896c2410		MOVQ BP, 0x10(SP)	
  0x42496c		488d6c2410		LEAQ 0x10(SP), BP	
	print("(", e._type, ",", e.data, ")")
  0x424971		e84af5ffff		CALL runtime.printlock(SB)	
  0x424976		488d0504a70400		LEAQ 0x4a704(IP), AX		
  0x42497d		48890424		MOVQ AX, 0(SP)			
  0x424981		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42498a		e861feffff		CALL runtime.printstring(SB)	
  0x42498f		488b442420		MOVQ 0x20(SP), AX		
  0x424994		48890424		MOVQ AX, 0(SP)			
  0x424998		e813feffff		CALL runtime.printpointer(SB)	
  0x42499d		488d05e0a60400		LEAQ 0x4a6e0(IP), AX		
  0x4249a4		48890424		MOVQ AX, 0(SP)			
  0x4249a8		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4249b1		e83afeffff		CALL runtime.printstring(SB)	
  0x4249b6		488b442428		MOVQ 0x28(SP), AX		
  0x4249bb		48890424		MOVQ AX, 0(SP)			
  0x4249bf		e8ecfdffff		CALL runtime.printpointer(SB)	
  0x4249c4		488d05b7a60400		LEAQ 0x4a6b7(IP), AX		
  0x4249cb		48890424		MOVQ AX, 0(SP)			
  0x4249cf		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4249d8		e813feffff		CALL runtime.printstring(SB)	
  0x4249dd		e85ef5ffff		CALL runtime.printunlock(SB)	
}
  0x4249e2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4249e7		4883c418		ADDQ $0x18, SP		
  0x4249eb		c3			RET			
func printeface(e eface) {
  0x4249ec		e88f2e0200		CALL runtime.morestack_noctxt(SB)	
  0x4249f1		e95affffff		JMP runtime.printeface(SB)		

TEXT runtime.hexdumpWords(SB) /usr/local/go/src/runtime/print.go
func hexdumpWords(p, end uintptr, mark func(uintptr) byte) {
  0x424a00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424a09		483b6110		CMPQ 0x10(CX), SP	
  0x424a0d		0f862f020000		JBE 0x424c42		
  0x424a13		4883ec60		SUBQ $0x60, SP		
  0x424a17		48896c2458		MOVQ BP, 0x58(SP)	
  0x424a1c		488d6c2458		LEAQ 0x58(SP), BP	
	printlock()
  0x424a21		e89af4ffff		CALL runtime.printlock(SB)	
	var markbuf [1]byte
  0x424a26		c644242700		MOVB $0x0, 0x27(SP)	
	markbuf[0] = ' '
  0x424a2b		c644242720		MOVB $0x20, 0x27(SP)	
  0x424a30		31c0			XORL AX, AX		
	for i := uintptr(0); p+i < end; i += sys.PtrSize {
  0x424a32		eb09			JMP 0x424a3d		
  0x424a34		488b4c2430		MOVQ 0x30(SP), CX	
  0x424a39		488d4108		LEAQ 0x8(CX), AX	
  0x424a3d		488b4c2468		MOVQ 0x68(SP), CX	
  0x424a42		488d1c08		LEAQ 0(AX)(CX*1), BX	
  0x424a46		488b742470		MOVQ 0x70(SP), SI	
  0x424a4b		4839f3			CMPQ SI, BX		
  0x424a4e		0f83d0010000		JAE 0x424c24		
  0x424a54		4889442430		MOVQ AX, 0x30(SP)	
  0x424a59		48895c2440		MOVQ BX, 0x40(SP)	
		if i%16 == 0 {
  0x424a5e		48a90f000000		TESTQ $0xf, AX		
  0x424a64		7540			JNE 0x424aa6		
			if i != 0 {
  0x424a66		4885c0			TESTQ AX, AX		
  0x424a69		0f859c010000		JNE 0x424c0b		
			p1(p + i)
  0x424a6f		48891c24		MOVQ BX, 0(SP)		
  0x424a73		488b05e6ed0400		MOVQ 0x4ede6(IP), AX	
  0x424a7a		488d15dfed0400		LEAQ 0x4eddf(IP), DX	
  0x424a81		ffd0			CALL AX			
			print(": ")
  0x424a83		e838f4ffff		CALL runtime.printlock(SB)	
  0x424a88		488d0511a60400		LEAQ 0x4a611(IP), AX		
  0x424a8f		48890424		MOVQ AX, 0(SP)			
  0x424a93		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x424a9c		e84ffdffff		CALL runtime.printstring(SB)	
  0x424aa1		e89af4ffff		CALL runtime.printunlock(SB)	
		if mark != nil {
  0x424aa6		488b542478		MOVQ 0x78(SP), DX	
  0x424aab		4885d2			TESTQ DX, DX		
  0x424aae		0f852e010000		JNE 0x424be2		
		gwrite(markbuf[:])
  0x424ab4		488d442427		LEAQ 0x27(SP), AX	
  0x424ab9		48890424		MOVQ AX, 0(SP)		
  0x424abd		48c744240801000000	MOVQ $0x1, 0x8(SP)	
  0x424ac6		48c744241001000000	MOVQ $0x1, 0x10(SP)	
  0x424acf		e8dcf4ffff		CALL runtime.gwrite(SB)	
		val := *(*uintptr)(unsafe.Pointer(p + i))
  0x424ad4		488b442440		MOVQ 0x40(SP), AX	
  0x424ad9		488b00			MOVQ 0(AX), AX		
  0x424adc		4889442428		MOVQ AX, 0x28(SP)	
		p1(val)
  0x424ae1		48890424		MOVQ AX, 0(SP)		
  0x424ae5		488b0d74ed0400		MOVQ 0x4ed74(IP), CX	
  0x424aec		488d156ded0400		LEAQ 0x4ed6d(IP), DX	
  0x424af3		ffd1			CALL CX			
		print(" ")
  0x424af5		e8c6f3ffff		CALL runtime.printlock(SB)	
  0x424afa		e801f6ffff		CALL runtime.printsp(SB)	
  0x424aff		e83cf4ffff		CALL runtime.printunlock(SB)	
		fn := findfunc(val)
  0x424b04		488b442428		MOVQ 0x28(SP), AX		
  0x424b09		48890424		MOVQ AX, 0(SP)			
  0x424b0d		e8ee5f0100		CALL runtime.findfunc(SB)	
  0x424b12		488b442410		MOVQ 0x10(SP), AX		
  0x424b17		488b4c2408		MOVQ 0x8(SP), CX		
		if fn.valid() {
  0x424b1c		90			NOPL			
	return f._func != nil
  0x424b1d		4885c9			TESTQ CX, CX		
		if fn.valid() {
  0x424b20		0f840effffff		JE 0x424a34		
		fn := findfunc(val)
  0x424b26		48894c2450		MOVQ CX, 0x50(SP)	
			print("<", funcname(fn), "+", val-fn.entry, "> ")
  0x424b2b		48890c24		MOVQ CX, 0(SP)			
  0x424b2f		4889442408		MOVQ AX, 0x8(SP)		
  0x424b34		e807670100		CALL runtime.funcname(SB)	
  0x424b39		488b442418		MOVQ 0x18(SP), AX		
  0x424b3e		4889442438		MOVQ AX, 0x38(SP)		
  0x424b43		488b4c2410		MOVQ 0x10(SP), CX		
  0x424b48		48894c2448		MOVQ CX, 0x48(SP)		
  0x424b4d		488b542450		MOVQ 0x50(SP), DX		
  0x424b52		488b12			MOVQ 0(DX), DX			
  0x424b55		4889542440		MOVQ DX, 0x40(SP)		
  0x424b5a		e861f3ffff		CALL runtime.printlock(SB)	
  0x424b5f		488d0523a50400		LEAQ 0x4a523(IP), AX		
  0x424b66		48890424		MOVQ AX, 0(SP)			
  0x424b6a		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x424b73		e878fcffff		CALL runtime.printstring(SB)	
  0x424b78		488b442448		MOVQ 0x48(SP), AX		
  0x424b7d		48890424		MOVQ AX, 0(SP)			
  0x424b81		488b442438		MOVQ 0x38(SP), AX		
  0x424b86		4889442408		MOVQ AX, 0x8(SP)		
  0x424b8b		e860fcffff		CALL runtime.printstring(SB)	
  0x424b90		488d05eca40400		LEAQ 0x4a4ec(IP), AX		
  0x424b97		48890424		MOVQ AX, 0(SP)			
  0x424b9b		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x424ba4		e847fcffff		CALL runtime.printstring(SB)	
  0x424ba9		488b442428		MOVQ 0x28(SP), AX		
  0x424bae		488b4c2440		MOVQ 0x40(SP), CX		
  0x424bb3		4829c8			SUBQ CX, AX			
  0x424bb6		48890424		MOVQ AX, 0(SP)			
  0x424bba		e881f9ffff		CALL runtime.printuint(SB)	
  0x424bbf		488d05dca40400		LEAQ 0x4a4dc(IP), AX		
  0x424bc6		48890424		MOVQ AX, 0(SP)			
  0x424bca		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x424bd3		e818fcffff		CALL runtime.printstring(SB)	
  0x424bd8		e863f3ffff		CALL runtime.printunlock(SB)	
  0x424bdd		e952feffff		JMP 0x424a34			
			markbuf[0] = mark(p + i)
  0x424be2		488b442440		MOVQ 0x40(SP), AX	
  0x424be7		48890424		MOVQ AX, 0(SP)		
  0x424beb		488b0a			MOVQ 0(DX), CX		
  0x424bee		ffd1			CALL CX			
  0x424bf0		0fb6442408		MOVZX 0x8(SP), AX	
  0x424bf5		88442427		MOVB AL, 0x27(SP)	
			if markbuf[0] == 0 {
  0x424bf9		84c0			TESTL AL, AL		
  0x424bfb		0f85b3feffff		JNE 0x424ab4		
				markbuf[0] = ' '
  0x424c01		c644242720		MOVB $0x20, 0x27(SP)	
  0x424c06		e9a9feffff		JMP 0x424ab4		
				println()
  0x424c0b		e8b0f2ffff		CALL runtime.printlock(SB)	
  0x424c10		e83bf5ffff		CALL runtime.printnl(SB)	
  0x424c15		e826f3ffff		CALL runtime.printunlock(SB)	
			p1(p + i)
  0x424c1a		488b5c2440		MOVQ 0x40(SP), BX	
				println()
  0x424c1f		e94bfeffff		JMP 0x424a6f		
	println()
  0x424c24		e897f2ffff		CALL runtime.printlock(SB)	
  0x424c29		e822f5ffff		CALL runtime.printnl(SB)	
  0x424c2e		e80df3ffff		CALL runtime.printunlock(SB)	
	printunlock()
  0x424c33		e808f3ffff		CALL runtime.printunlock(SB)	
}
  0x424c38		488b6c2458		MOVQ 0x58(SP), BP	
  0x424c3d		4883c460		ADDQ $0x60, SP		
  0x424c41		c3			RET			
func hexdumpWords(p, end uintptr, mark func(uintptr) byte) {
  0x424c42		e8392c0200		CALL runtime.morestack_noctxt(SB)	
  0x424c47		e9b4fdffff		JMP runtime.hexdumpWords(SB)		

TEXT runtime.main(SB) /usr/local/go/src/runtime/proc.go
func main() {
  0x424c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424c59		483b6110		CMPQ 0x10(CX), SP	
  0x424c5d		0f8667030000		JBE 0x424fca		
  0x424c63		4883ec40		SUBQ $0x40, SP		
  0x424c67		48896c2438		MOVQ BP, 0x38(SP)	
  0x424c6c		488d6c2438		LEAQ 0x38(SP), BP	
	g := getg()
  0x424c71		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x424c7a		4889442430		MOVQ AX, 0x30(SP)	
	g.m.g0.racectx = 0
  0x424c7f		488b4830		MOVQ 0x30(AX), CX	
  0x424c83		488b09			MOVQ 0(CX), CX		
  0x424c86		48c7813001000000000000	MOVQ $0x0, 0x130(CX)	
		maxstacksize = 1000000000
  0x424c91		48c705aca3090000ca9a3b	MOVQ $0x3b9aca00, runtime.maxstacksize(SB)	
	mainStarted = true
  0x424c9c		c6050e800b0001		MOVB $0x1, runtime.mainStarted(SB)	
		systemstack(func() {
  0x424ca3		488d0dceeb0400		LEAQ 0x4ebce(IP), CX		
  0x424caa		48890c24		MOVQ CX, 0(SP)			
  0x424cae		e87d2a0200		CALL runtime.systemstack(SB)	
	getg().m.lockedInt++
  0x424cb3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x424cbc		488b4030		MOVQ 0x30(AX), AX	
	lockOSThread()
  0x424cc0		90			NOPL			
	getg().m.lockedInt++
  0x424cc1		ff8074020000		INCL 0x274(AX)		
	_g_ := getg()
  0x424cc7		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.lockedg.set(_g_)
  0x424cd0		488b4830		MOVQ 0x30(AX), CX	
	dolockOSThread()
  0x424cd4		90			NOPL			
	_g_.m.lockedg.set(_g_)
  0x424cd5		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x424cd6		4889c2			MOVQ AX, DX		
  0x424cd9		48898168010000		MOVQ AX, 0x168(CX)	
	_g_.lockedm.set(_g_.m)
  0x424ce0		90			NOPL			
  0x424ce1		488b4230		MOVQ 0x30(DX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x424ce5		488982d8000000		MOVQ AX, 0xd8(DX)	
	if g.m != &m0 {
  0x424cec		488b442430		MOVQ 0x30(SP), AX	
  0x424cf1		488b4030		MOVQ 0x30(AX), AX	
  0x424cf5		488d0d64d60900		LEAQ runtime.m0(SB), CX	
  0x424cfc		4839c8			CMPQ CX, AX		
  0x424cff		0f85aa020000		JNE 0x424faf		
	runtime_init() // must be before defer
  0x424d05		e856260200		CALL runtime.init(SB)	
	if nanotime() == 0 {
  0x424d0a		e8a1630200		CALL runtime.nanotime(SB)	
  0x424d0f		48833c2400		CMPQ $0x0, 0(SP)		
  0x424d14		0f847a020000		JE 0x424f94			
	needUnlock := true
  0x424d1a		c644242701		MOVB $0x1, 0x27(SP)	
	defer func() {
  0x424d1f		c7042408000000		MOVL $0x8, 0(SP)		
  0x424d26		488d0553eb0400		LEAQ 0x4eb53(IP), AX		
  0x424d2d		4889442408		MOVQ AX, 0x8(SP)		
  0x424d32		488d442427		LEAQ 0x27(SP), AX		
  0x424d37		4889442410		MOVQ AX, 0x10(SP)		
  0x424d3c		e8efd4ffff		CALL runtime.deferproc(SB)	
  0x424d41		85c0			TESTL AX, AX			
  0x424d43		0f85cf010000		JNE 0x424f18			
	runtimeInitTime = nanotime()
  0x424d49		e862630200		CALL runtime.nanotime(SB)		
  0x424d4e		488b0424		MOVQ 0(SP), AX				
  0x424d52		4889056f800b00		MOVQ AX, runtime.runtimeInitTime(SB)	
	gcenable()
  0x424d59		e832d1feff		CALL runtime.gcenable(SB)	
	main_init_done = make(chan bool)
  0x424d5e		488d051b5b0300		LEAQ 0x35b1b(IP), AX			
  0x424d65		48890424		MOVQ AX, 0(SP)				
  0x424d69		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x424d72		e8b9f5fdff		CALL runtime.makechan(SB)		
  0x424d77		488b442410		MOVQ 0x10(SP), AX			
  0x424d7c		833d9d800b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x424d83		0f857e010000		JNE 0x424f07				
  0x424d89		488905d8cb0900		MOVQ AX, runtime.main_init_done(SB)	
	if iscgo {
  0x424d90		803d177f0b0000		CMPB $0x0, runtime.iscgo(SB)	
  0x424d97		746f			JE 0x424e08			
		if _cgo_thread_start == nil {
  0x424d99		48833d4fcb090000	CMPQ $0x0, _cgo_thread_start(SB)	
  0x424da1		0f84d2010000		JE 0x424f79				
			if _cgo_setenv == nil {
  0x424da7		48833d51cb090000	CMPQ $0x0, runtime._cgo_setenv(SB)	
  0x424daf		0f84a9010000		JE 0x424f5e				
			if _cgo_unsetenv == nil {
  0x424db5		48833d4bcb090000	CMPQ $0x0, runtime._cgo_unsetenv(SB)	
  0x424dbd		0f8480010000		JE 0x424f43				
		if _cgo_notify_runtime_init_done == nil {
  0x424dc3		48833d15cb090000	CMPQ $0x0, _cgo_notify_runtime_init_done(SB)	
  0x424dcb		0f8457010000		JE 0x424f28					
		startTemplateThread()
  0x424dd1		90			NOPL			
	if !atomic.Cas(&newmHandoff.haveTemplateThread, 0, 1) {
  0x424dd2		31c0			XORL AX, AX				
  0x424dd4		488d0da5800b00		LEAQ runtime.newmHandoff+32(SB), CX	
  0x424ddb		ba01000000		MOVL $0x1, DX				
  0x424de0		f00fb111		LOCK CMPXCHGL DX, 0(CX)			
  0x424de4		0f94c1			SETE CL					
  0x424de7		84c9			TESTL CL, CL				
  0x424de9		0f85fa000000		JNE 0x424ee9				
		cgocall(_cgo_notify_runtime_init_done, nil)
  0x424def		488b05eaca0900		MOVQ _cgo_notify_runtime_init_done(SB), AX	
  0x424df6		48890424		MOVQ AX, 0(SP)					
  0x424dfa		48c744240800000000	MOVQ $0x0, 0x8(SP)				
  0x424e03		e8e8e9fdff		CALL runtime.cgocall(SB)			
	fn()
  0x424e08		488b0579ea0400		MOVQ 0x4ea79(IP), AX	
  0x424e0f		488d1572ea0400		LEAQ 0x4ea72(IP), DX	
  0x424e16		ffd0			CALL AX			
	close(main_init_done)
  0x424e18		488b0549cb0900		MOVQ runtime.main_init_done(SB), AX	
  0x424e1f		48890424		MOVQ AX, 0(SP)				
  0x424e23		e8f8fffdff		CALL runtime.closechan(SB)		
	needUnlock = false
  0x424e28		c644242700		MOVB $0x0, 0x27(SP)	
	unlockOSThread()
  0x424e2d		e8ce830000		CALL runtime.unlockOSThread(SB)	
	if isarchive || islibrary {
  0x424e32		803d747e0b0000		CMPB $0x0, runtime.isarchive(SB)	
  0x424e39		0f859a000000		JNE 0x424ed9				
  0x424e3f		803d697e0b0000		CMPB $0x0, runtime.islibrary(SB)	
  0x424e46		0f858d000000		JNE 0x424ed9				
	fn()
  0x424e4c		488b053dea0400		MOVQ 0x4ea3d(IP), AX	
  0x424e53		488d1536ea0400		LEAQ 0x4ea36(IP), DX	
  0x424e5a		ffd0			CALL AX			
	if atomic.Load(&runningPanicDefers) != 0 {
  0x424e5c		8b059a7e0b00		MOVL runtime.runningPanicDefers(SB), AX	
  0x424e62		85c0			TESTL AX, AX				
  0x424e64		7435			JE 0x424e9b				
  0x424e66		31c0			XORL AX, AX				
		for c := 0; c < 1000; c++ {
  0x424e68		eb1f			JMP 0x424e89		
  0x424e6a		4889442428		MOVQ AX, 0x28(SP)	
			Gosched()
  0x424e6f		90			NOPL			
	checkTimeouts()
  0x424e70		90			NOPL			
	mcall(gosched_m)
  0x424e71		488d05e0e90400		LEAQ 0x4e9e0(IP), AX	
  0x424e78		48890424		MOVQ AX, 0(SP)		
  0x424e7c		e82f280200		CALL runtime.mcall(SB)	
		for c := 0; c < 1000; c++ {
  0x424e81		488b442428		MOVQ 0x28(SP), AX	
  0x424e86		48ffc0			INCQ AX			
  0x424e89		483de8030000		CMPQ $0x3e8, AX		
  0x424e8f		7d0a			JGE 0x424e9b		
			if atomic.Load(&runningPanicDefers) == 0 {
  0x424e91		8b0d657e0b00		MOVL runtime.runningPanicDefers(SB), CX	
  0x424e97		85c9			TESTL CX, CX				
  0x424e99		75cf			JNE 0x424e6a				
	if atomic.Load(&panicking) != 0 {
  0x424e9b		8b05537e0b00		MOVL runtime.panicking(SB), AX	
  0x424ea1		85c0			TESTL AX, AX			
  0x424ea3		7516			JNE 0x424ebb			
	exit(0)
  0x424ea5		c7042400000000		MOVL $0x0, 0(SP)	
  0x424eac		e86f5f0200		CALL runtime.exit(SB)	
		*x = 0
  0x424eb1		31c0			XORL AX, AX		
  0x424eb3		c70000000000		MOVL $0x0, 0(AX)	
  0x424eb9		ebf6			JMP 0x424eb1		
		gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)
  0x424ebb		0f57c0			XORPS X0, X0		
  0x424ebe		0f110424		MOVUPS X0, 0(SP)	
  0x424ec2		66c74424100810		MOVW $0x1008, 0x10(SP)	
  0x424ec9		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x424ed2		e879020000		CALL runtime.gopark(SB)	
  0x424ed7		ebcc			JMP 0x424ea5		
		return
  0x424ed9		90			NOPL				
  0x424eda		e8e1dbffff		CALL runtime.deferreturn(SB)	
  0x424edf		488b6c2438		MOVQ 0x38(SP), BP		
  0x424ee4		4883c440		ADDQ $0x40, SP			
  0x424ee8		c3			RET				
	newm(templateThread, nil)
  0x424ee9		488d05c8ea0400		LEAQ 0x4eac8(IP), AX	
  0x424ef0		48890424		MOVQ AX, 0(SP)		
  0x424ef4		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x424efd		e86e3b0000		CALL runtime.newm(SB)	
		startTemplateThread()
  0x424f02		e9e8feffff		JMP 0x424def		
	main_init_done = make(chan bool)
  0x424f07		488d3d5aca0900		LEAQ runtime.main_init_done(SB), DI	
  0x424f0e		e86d470200		CALL runtime.gcWriteBarrier(SB)		
  0x424f13		e978feffff		JMP 0x424d90				
	defer func() {
  0x424f18		90			NOPL				
  0x424f19		e8a2dbffff		CALL runtime.deferreturn(SB)	
  0x424f1e		488b6c2438		MOVQ 0x38(SP), BP		
  0x424f23		4883c440		ADDQ $0x40, SP			
  0x424f27		c3			RET				
			throw("_cgo_notify_runtime_init_done missing")
  0x424f28		488d0545d70400		LEAQ 0x4d745(IP), AX	
  0x424f2f		48890424		MOVQ AX, 0(SP)		
  0x424f33		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x424f3c		e83fe5ffff		CALL runtime.throw(SB)	
  0x424f41		0f0b			UD2			
				throw("_cgo_unsetenv missing")
  0x424f43		488d05a5b80400		LEAQ 0x4b8a5(IP), AX	
  0x424f4a		48890424		MOVQ AX, 0(SP)		
  0x424f4e		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x424f57		e824e5ffff		CALL runtime.throw(SB)	
  0x424f5c		0f0b			UD2			
				throw("_cgo_setenv missing")
  0x424f5e		488d0551b40400		LEAQ 0x4b451(IP), AX	
  0x424f65		48890424		MOVQ AX, 0(SP)		
  0x424f69		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x424f72		e809e5ffff		CALL runtime.throw(SB)	
  0x424f77		0f0b			UD2			
			throw("_cgo_thread_start missing")
  0x424f79		488d051cc00400		LEAQ 0x4c01c(IP), AX	
  0x424f80		48890424		MOVQ AX, 0(SP)		
  0x424f84		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x424f8d		e8eee4ffff		CALL runtime.throw(SB)	
  0x424f92		0f0b			UD2			
		throw("nanotime returning zero")
  0x424f94		488d050ebd0400		LEAQ 0x4bd0e(IP), AX	
  0x424f9b		48890424		MOVQ AX, 0(SP)		
  0x424f9f		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x424fa8		e8d3e4ffff		CALL runtime.throw(SB)	
  0x424fad		0f0b			UD2			
		throw("runtime.main not on m0")
  0x424faf		488d0593ba0400		LEAQ 0x4ba93(IP), AX	
  0x424fb6		48890424		MOVQ AX, 0(SP)		
  0x424fba		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x424fc3		e8b8e4ffff		CALL runtime.throw(SB)	
  0x424fc8		0f0b			UD2			
func main() {
  0x424fca		e8b1280200		CALL runtime.morestack_noctxt(SB)	
  0x424fcf		e97cfcffff		JMP runtime.main(SB)			

TEXT runtime.init.5(SB) /usr/local/go/src/runtime/proc.go
func init() {
  0x424fe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x424fe9		483b6110		CMPQ 0x10(CX), SP	
  0x424fed		7630			JBE 0x42501f		
  0x424fef		4883ec18		SUBQ $0x18, SP		
  0x424ff3		48896c2410		MOVQ BP, 0x10(SP)	
  0x424ff8		488d6c2410		LEAQ 0x10(SP), BP	
	go forcegchelper()
  0x424ffd		c7042400000000		MOVL $0x0, 0(SP)		
  0x425004		488d05dde70400		LEAQ 0x4e7dd(IP), AX		
  0x42500b		4889442408		MOVQ AX, 0x8(SP)		
  0x425010		e83b750000		CALL runtime.newproc(SB)	
}
  0x425015		488b6c2410		MOVQ 0x10(SP), BP	
  0x42501a		4883c418		ADDQ $0x18, SP		
  0x42501e		c3			RET			
func init() {
  0x42501f		e85c280200		CALL runtime.morestack_noctxt(SB)	
  0x425024		ebba			JMP runtime.init.5(SB)			

TEXT runtime.forcegchelper(SB) /usr/local/go/src/runtime/proc.go
func forcegchelper() {
  0x425030		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425039		483b6110		CMPQ 0x10(CX), SP	
  0x42503d		0f8601010000		JBE 0x425144		
  0x425043		4883ec28		SUBQ $0x28, SP		
  0x425047		48896c2420		MOVQ BP, 0x20(SP)	
  0x42504c		488d6c2420		LEAQ 0x20(SP), BP	
	forcegc.g = getg()
  0x425051		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x42505a		833dbf7d0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425061		0f85b1000000		JNE 0x425118				
  0x425067		4889051aca0900		MOVQ AX, runtime.forcegc+8(SB)		
	for {
  0x42506e		eb23			JMP 0x425093		
		gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})
  0x425070		e83b600200		CALL runtime.nanotime(SB)	
  0x425075		488b0424		MOVQ 0(SP), AX			
  0x425079		48c7042402000000	MOVQ $0x2, 0(SP)		
  0x425081		4889442408		MOVQ AX, 0x8(SP)		
  0x425086		c744241000000000	MOVL $0x0, 0x10(SP)		
  0x42508e		e83de2feff		CALL runtime.gcStart(SB)	
		lock(&forcegc.lock)
  0x425093		488d05e6c90900		LEAQ runtime.forcegc(SB), AX	
  0x42509a		48890424		MOVQ AX, 0(SP)			
  0x42509e		e83d36feff		CALL runtime.lock(SB)		
		if forcegc.idle != 0 {
  0x4250a3		833de6c9090000		CMPL $0x0, runtime.forcegc+16(SB)	
  0x4250aa		757d			JNE 0x425129				
		atomic.Store(&forcegc.idle, 1)
  0x4250ac		b801000000		MOVL $0x1, AX			
  0x4250b1		488d0dd8c90900		LEAQ runtime.forcegc+16(SB), CX	
  0x4250b8		8701			XCHGL AX, 0(CX)			
		goparkunlock(&forcegc.lock, waitReasonForceGGIdle, traceEvGoBlock, 1)
  0x4250ba		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x4250bb		488d056ee80400		LEAQ 0x4e86e(IP), AX		
  0x4250c2		48890424		MOVQ AX, 0(SP)			
  0x4250c6		488d0db3c90900		LEAQ runtime.forcegc(SB), CX	
  0x4250cd		48894c2408		MOVQ CX, 0x8(SP)		
  0x4250d2		66c74424101014		MOVW $0x1410, 0x10(SP)		
  0x4250d9		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x4250e2		e869000000		CALL runtime.gopark(SB)		
		if debug.gctrace > 0 {
  0x4250e7		833d127e0b0000		CMPL $0x0, runtime.debug+32(SB)	
  0x4250ee		7e80			JLE 0x425070			
			println("GC forced")
  0x4250f0		e8cbedffff		CALL runtime.printlock(SB)	
  0x4250f5		488d0598a60400		LEAQ 0x4a698(IP), AX		
  0x4250fc		48890424		MOVQ AX, 0(SP)			
  0x425100		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x425109		e8e2f6ffff		CALL runtime.printstring(SB)	
  0x42510e		e82deeffff		CALL runtime.printunlock(SB)	
  0x425113		e958ffffff		JMP 0x425070			
	forcegc.g = getg()
  0x425118		488d3d69c90900		LEAQ runtime.forcegc+8(SB), DI	
  0x42511f		e85c450200		CALL runtime.gcWriteBarrier(SB)	
  0x425124		e96affffff		JMP 0x425093			
			throw("forcegc: phase error")
  0x425129		488d0519b50400		LEAQ 0x4b519(IP), AX	
  0x425130		48890424		MOVQ AX, 0(SP)		
  0x425134		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x42513d		e83ee3ffff		CALL runtime.throw(SB)	
  0x425142		0f0b			UD2			
func forcegchelper() {
  0x425144		e837270200		CALL runtime.morestack_noctxt(SB)	
  0x425149		e9e2feffff		JMP runtime.forcegchelper(SB)		

TEXT runtime.gopark(SB) /usr/local/go/src/runtime/proc.go
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
  0x425150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425159		483b6110		CMPQ 0x10(CX), SP	
  0x42515d		0f8625010000		JBE 0x425288		
  0x425163		4883ec18		SUBQ $0x18, SP		
  0x425167		48896c2410		MOVQ BP, 0x10(SP)	
  0x42516c		488d6c2410		LEAQ 0x10(SP), BP	
	if reason != waitReasonSleep {
  0x425171		0fb64c2430		MOVZX 0x30(SP), CX	
  0x425176		80f912			CMPL $0x12, CL		
  0x425179		7401			JE 0x42517c		
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
  0x42517b		90			NOPL			
	_g_ := getg()
  0x42517c		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++
  0x425185		488b5a30		MOVQ 0x30(DX), BX	
	mp := acquirem()
  0x425189		90			NOPL			
	_g_.m.locks++
  0x42518a		ff8308010000		INCL 0x108(BX)		
	return _g_.m
  0x425190		488b5a30		MOVQ 0x30(DX), BX	
  0x425194		8402			TESTB AL, 0(DX)		
	gp := mp.curg
  0x425196		488b93c0000000		MOVQ 0xc0(BX), DX	
	status := readgstatus(gp)
  0x42519d		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42519e		8bb290000000		MOVL 0x90(DX), SI	
	if status != _Grunning && status != _Gscanrunning {
  0x4251a4		83fe02			CMPL $0x2, SI		
  0x4251a7		740c			JE 0x4251b5		
  0x4251a9		81fe02100000		CMPL $0x1002, SI	
  0x4251af		0f85b8000000		JNE 0x42526d		
	mp.waitlock = lock
  0x4251b5		833d647c0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4251bc		0f8595000000		JNE 0x425257				
  0x4251c2		488b742428		MOVQ 0x28(SP), SI			
  0x4251c7		4889b388020000		MOVQ SI, 0x288(BX)			
	mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))
  0x4251ce		488b442420		MOVQ 0x20(SP), AX			
  0x4251d3		833d467c0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4251da		756d			JNE 0x425249				
  0x4251dc		48898380020000		MOVQ AX, 0x280(BX)			
	gp.waitreason = reason
  0x4251e3		888ab0000000		MOVB CL, 0xb0(DX)	
	mp.waittraceev = traceEv
  0x4251e9		0fb6442431		MOVZX 0x31(SP), AX	
  0x4251ee		888390020000		MOVB AL, 0x290(BX)	
	mp.waittraceskip = traceskip
  0x4251f4		488b442438		MOVQ 0x38(SP), AX	
  0x4251f9		48898398020000		MOVQ AX, 0x298(BX)	
	releasem(mp)
  0x425200		90			NOPL			
	_g_ := getg()
  0x425201		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x42520a		8b8b08010000		MOVL 0x108(BX), CX	
  0x425210		8d51ff			LEAL -0x1(CX), DX	
  0x425213		899308010000		MOVL DX, 0x108(BX)	
	if mp.locks == 0 && _g_.preempt {
  0x425219		83f901			CMPL $0x1, CX		
  0x42521c		7511			JNE 0x42522f		
  0x42521e		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x425225		7408			JE 0x42522f		
		_g_.stackguard0 = stackPreempt
  0x425227		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	mcall(park_m)
  0x42522f		488d05f2e60400		LEAQ 0x4e6f2(IP), AX	
  0x425236		48890424		MOVQ AX, 0(SP)		
  0x42523a		e871240200		CALL runtime.mcall(SB)	
}
  0x42523f		488b6c2410		MOVQ 0x10(SP), BP	
  0x425244		4883c418		ADDQ $0x18, SP		
  0x425248		c3			RET			
	mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))
  0x425249		488dbb80020000		LEAQ 0x280(BX), DI		
  0x425250		e82b440200		CALL runtime.gcWriteBarrier(SB)	
  0x425255		eb8c			JMP 0x4251e3			
	mp.waitlock = lock
  0x425257		488dbb88020000		LEAQ 0x288(BX), DI		
  0x42525e		488b442428		MOVQ 0x28(SP), AX		
  0x425263		e818440200		CALL runtime.gcWriteBarrier(SB)	
  0x425268		e961ffffff		JMP 0x4251ce			
		throw("gopark: bad g status")
  0x42526d		488d0511b40400		LEAQ 0x4b411(IP), AX	
  0x425274		48890424		MOVQ AX, 0(SP)		
  0x425278		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x425281		e8fae1ffff		CALL runtime.throw(SB)	
  0x425286		0f0b			UD2			
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
  0x425288		e8f3250200		CALL runtime.morestack_noctxt(SB)	
  0x42528d		e9befeffff		JMP runtime.gopark(SB)			

TEXT runtime.goready(SB) /usr/local/go/src/runtime/proc.go
func goready(gp *g, traceskip int) {
  0x4252a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4252a9		483b6110		CMPQ 0x10(CX), SP	
  0x4252ad		7657			JBE 0x425306		
  0x4252af		4883ec28		SUBQ $0x28, SP		
  0x4252b3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4252b8		488d6c2420		LEAQ 0x20(SP), BP	
	systemstack(func() {
  0x4252bd		0f57c0			XORPS X0, X0				
  0x4252c0		0f11442408		MOVUPS X0, 0x8(SP)			
  0x4252c5		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x4252ce		488d05fb130200		LEAQ runtime.goready.func1(SB), AX	
  0x4252d5		4889442408		MOVQ AX, 0x8(SP)			
  0x4252da		488b442430		MOVQ 0x30(SP), AX			
  0x4252df		4889442410		MOVQ AX, 0x10(SP)			
  0x4252e4		488b442438		MOVQ 0x38(SP), AX			
  0x4252e9		4889442418		MOVQ AX, 0x18(SP)			
  0x4252ee		488d442408		LEAQ 0x8(SP), AX			
  0x4252f3		48890424		MOVQ AX, 0(SP)				
  0x4252f7		e834240200		CALL runtime.systemstack(SB)		
}
  0x4252fc		488b6c2420		MOVQ 0x20(SP), BP	
  0x425301		4883c428		ADDQ $0x28, SP		
  0x425305		c3			RET			
func goready(gp *g, traceskip int) {
  0x425306		e875250200		CALL runtime.morestack_noctxt(SB)	
  0x42530b		eb93			JMP runtime.goready(SB)			

TEXT runtime.acquireSudog(SB) /usr/local/go/src/runtime/proc.go
func acquireSudog() *sudog {
  0x425310		4883ec68		SUBQ $0x68, SP		
  0x425314		48896c2460		MOVQ BP, 0x60(SP)	
  0x425319		488d6c2460		LEAQ 0x60(SP), BP	
	_g_ := getg()
  0x42531e		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	_g_.m.locks++
  0x425327		488b5130		MOVQ 0x30(CX), DX	
	mp := acquirem()
  0x42532b		90			NOPL			
	_g_.m.locks++
  0x42532c		ff8208010000		INCL 0x108(DX)		
	return _g_.m
  0x425332		488b5130		MOVQ 0x30(CX), DX	
  0x425336		4889542440		MOVQ DX, 0x40(SP)	
	pp := mp.p.ptr()
  0x42533b		488b9ad0000000		MOVQ 0xd0(DX), BX	
	return _g_.m
  0x425342		8401			TESTB AL, 0(CX)		
	pp := mp.p.ptr()
  0x425344		90			NOPL			
	if len(pp.sudogcache) == 0 {
  0x425345		4883bb080e000000	CMPQ $0x0, 0xe08(BX)	
  0x42534d		0f8520030000		JNE 0x425673		
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x425353		48895c2458		MOVQ BX, 0x58(SP)	
		lock(&sched.sudoglock)
  0x425358		488d05f1c90900		LEAQ runtime.sched+176(SB), AX	
  0x42535f		48890424		MOVQ AX, 0(SP)			
  0x425363		e87833feff		CALL runtime.lock(SB)		
	if len(pp.sudogcache) == 0 {
  0x425368		488b442458		MOVQ 0x58(SP), AX	
  0x42536d		488d88000e0000		LEAQ 0xe00(AX), CX	
  0x425374		48894c2450		MOVQ CX, 0x50(SP)	
		for len(pp.sudogcache) < cap(pp.sudogcache)/2 && sched.sudogcache != nil {
  0x425379		488b90100e0000		MOVQ 0xe10(AX), DX		
  0x425380		48d1ea			SHRQ $0x1, DX			
  0x425383		483990080e0000		CMPQ DX, 0xe08(AX)		
  0x42538a		0f8d21010000		JGE 0x4254b1			
  0x425390		488b15c1c90900		MOVQ runtime.sched+184(SB), DX	
  0x425397		4885d2			TESTQ DX, DX			
  0x42539a		0f8411010000		JE 0x4254b1			
			sched.sudogcache = s.next
  0x4253a0		488b5a10		MOVQ 0x10(DX), BX			
  0x4253a4		833d757a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4253ab		0f85db000000		JNE 0x42548c				
  0x4253b1		48891da0c90900		MOVQ BX, runtime.sched+184(SB)		
			s.next = nil
  0x4253b8		48c7421000000000	MOVQ $0x0, 0x10(DX)	
			pp.sudogcache = append(pp.sudogcache, s)
  0x4253c0		488b98080e0000		MOVQ 0xe08(AX), BX			
  0x4253c7		488d7301		LEAQ 0x1(BX), SI			
  0x4253cb		4c8b80000e0000		MOVQ 0xe00(AX), R8			
  0x4253d2		4c8b88100e0000		MOVQ 0xe10(AX), R9			
  0x4253d9		4c39ce			CMPQ R9, SI				
  0x4253dc		7734			JA 0x425412				
  0x4253de		488d7301		LEAQ 0x1(BX), SI			
  0x4253e2		4889b0080e0000		MOVQ SI, 0xe08(AX)			
  0x4253e9		498d3cd8		LEAQ 0(R8)(BX*8), DI			
  0x4253ed		833d2c7a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4253f4		7509			JNE 0x4253ff				
  0x4253f6		498914d8		MOVQ DX, 0(R8)(BX*8)			
  0x4253fa		e97affffff		JMP 0x425379				
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4253ff		4889c3			MOVQ AX, BX		
			pp.sudogcache = append(pp.sudogcache, s)
  0x425402		4889d0			MOVQ DX, AX			
  0x425405		e876420200		CALL runtime.gcWriteBarrier(SB)	
		for len(pp.sudogcache) < cap(pp.sudogcache)/2 && sched.sudogcache != nil {
  0x42540a		4889d8			MOVQ BX, AX		
			pp.sudogcache = append(pp.sudogcache, s)
  0x42540d		e967ffffff		JMP 0x425379		
		for len(pp.sudogcache) < cap(pp.sudogcache)/2 && sched.sudogcache != nil {
  0x425412		4889542448		MOVQ DX, 0x48(SP)	
			pp.sudogcache = append(pp.sudogcache, s)
  0x425417		488d0522360300		LEAQ 0x33622(IP), AX			
  0x42541e		48890424		MOVQ AX, 0(SP)				
  0x425422		4c89442408		MOVQ R8, 0x8(SP)			
  0x425427		48895c2410		MOVQ BX, 0x10(SP)			
  0x42542c		4c894c2418		MOVQ R9, 0x18(SP)			
  0x425431		4889742420		MOVQ SI, 0x20(SP)			
  0x425436		e845090100		CALL runtime.growslice(SB)		
  0x42543b		488b442428		MOVQ 0x28(SP), AX			
  0x425440		488b4c2430		MOVQ 0x30(SP), CX			
  0x425445		488b542438		MOVQ 0x38(SP), DX			
  0x42544a		488b5c2458		MOVQ 0x58(SP), BX			
  0x42544f		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x425456		833dc3790b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42545d		7521			JNE 0x425480				
  0x42545f		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x425466		488b542448		MOVQ 0x48(SP), DX			
  0x42546b		4889cb			MOVQ CX, BX				
  0x42546e		4989c0			MOVQ AX, R8				
  0x425471		488b442458		MOVQ 0x58(SP), AX			
  0x425476		488b4c2450		MOVQ 0x50(SP), CX			
  0x42547b		e95effffff		JMP 0x4253de				
  0x425480		488b7c2450		MOVQ 0x50(SP), DI			
  0x425485		e8f6410200		CALL runtime.gcWriteBarrier(SB)		
  0x42548a		ebda			JMP 0x425466				
			sched.sudogcache = s.next
  0x42548c		488d3dc5c80900		LEAQ runtime.sched+184(SB), DI	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x425493		4889c6			MOVQ AX, SI		
			sched.sudogcache = s.next
  0x425496		4889d8			MOVQ BX, AX			
  0x425499		e8e2410200		CALL runtime.gcWriteBarrier(SB)	
  0x42549e		488d7a10		LEAQ 0x10(DX), DI		
			s.next = nil
  0x4254a2		31c0			XORL AX, AX			
  0x4254a4		e8d7410200		CALL runtime.gcWriteBarrier(SB)	
			pp.sudogcache = append(pp.sudogcache, s)
  0x4254a9		4889f0			MOVQ SI, AX		
			sched.sudogcache = s.next
  0x4254ac		e90fffffff		JMP 0x4253c0		
		unlock(&sched.sudoglock)
  0x4254b1		488d0598c80900		LEAQ runtime.sched+176(SB), AX	
  0x4254b8		48890424		MOVQ AX, 0(SP)			
  0x4254bc		e8cf33feff		CALL runtime.unlock(SB)		
		if len(pp.sudogcache) == 0 {
  0x4254c1		488b442458		MOVQ 0x58(SP), AX	
  0x4254c6		4883b8080e000000	CMPQ $0x0, 0xe08(AX)	
  0x4254ce		0f84b7000000		JE 0x42558b		
	n := len(pp.sudogcache)
  0x4254d4		488b88080e0000		MOVQ 0xe08(AX), CX	
  0x4254db		488b90000e0000		MOVQ 0xe00(AX), DX	
	s := pp.sudogcache[n-1]
  0x4254e2		488d59ff		LEAQ -0x1(CX), BX	
  0x4254e6		4839cb			CMPQ CX, BX		
  0x4254e9		0f83ae010000		JAE 0x42569d		
  0x4254ef		488b74caf8		MOVQ -0x8(DX)(CX*8), SI	
  0x4254f4		488d3cca		LEAQ 0(DX)(CX*8), DI	
  0x4254f8		488d7ff8		LEAQ -0x8(DI), DI	
	pp.sudogcache[n-1] = nil
  0x4254fc		833d1d790b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425503		7577			JNE 0x42557c				
  0x425505		48c744caf800000000	MOVQ $0x0, -0x8(DX)(CX*8)		
	pp.sudogcache = pp.sudogcache[:n-1]
  0x42550e		488b88100e0000		MOVQ 0xe10(AX), CX	
  0x425515		4885db			TESTQ BX, BX		
  0x425518		0f8c78010000		JL 0x425696		
  0x42551e		4839cb			CMPQ CX, BX		
  0x425521		0f876f010000		JA 0x425696		
  0x425527		488998080e0000		MOVQ BX, 0xe08(AX)	
	if s.elem != nil {
  0x42552e		48837e2000		CMPQ $0x0, 0x20(SI)	
  0x425533		0f8542010000		JNE 0x42567b		
	releasem(mp)
  0x425539		90			NOPL			
	_g_ := getg()
  0x42553a		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x425543		488b4c2440		MOVQ 0x40(SP), CX	
  0x425548		8b9108010000		MOVL 0x108(CX), DX	
  0x42554e		8d5aff			LEAL -0x1(DX), BX	
  0x425551		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x425557		83fa01			CMPL $0x1, DX		
  0x42555a		7511			JNE 0x42556d		
  0x42555c		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x425563		7408			JE 0x42556d		
		_g_.stackguard0 = stackPreempt
  0x425565		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return s
  0x42556d		4889742470		MOVQ SI, 0x70(SP)	
  0x425572		488b6c2460		MOVQ 0x60(SP), BP	
  0x425577		4883c468		ADDQ $0x68, SP		
  0x42557b		c3			RET			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42557c		4889c1			MOVQ AX, CX		
	pp.sudogcache[n-1] = nil
  0x42557f		31c0			XORL AX, AX			
  0x425581		e8fa400200		CALL runtime.gcWriteBarrier(SB)	
	pp.sudogcache = pp.sudogcache[:n-1]
  0x425586		4889c8			MOVQ CX, AX		
	pp.sudogcache[n-1] = nil
  0x425589		eb83			JMP 0x42550e		
			pp.sudogcache = append(pp.sudogcache, new(sudog))
  0x42558b		488d05ae5f0400		LEAQ 0x45fae(IP), AX			
  0x425592		48890424		MOVQ AX, 0(SP)				
  0x425596		e8b551feff		CALL runtime.newobject(SB)		
  0x42559b		488b442458		MOVQ 0x58(SP), AX			
  0x4255a0		488b88100e0000		MOVQ 0xe10(AX), CX			
  0x4255a7		488b90080e0000		MOVQ 0xe08(AX), DX			
  0x4255ae		488b98000e0000		MOVQ 0xe00(AX), BX			
  0x4255b5		488d7201		LEAQ 0x1(DX), SI			
  0x4255b9		488b7c2408		MOVQ 0x8(SP), DI			
  0x4255be		4839ce			CMPQ CX, SI				
  0x4255c1		773a			JA 0x4255fd				
  0x4255c3		488d4a01		LEAQ 0x1(DX), CX			
  0x4255c7		488988080e0000		MOVQ CX, 0xe08(AX)			
  0x4255ce		488d0cd3		LEAQ 0(BX)(DX*8), CX			
  0x4255d2		833d47780b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4255d9		7509			JNE 0x4255e4				
  0x4255db		48893cd3		MOVQ DI, 0(BX)(DX*8)			
  0x4255df		e9f0feffff		JMP 0x4254d4				
  0x4255e4		4889fa			MOVQ DI, DX				
  0x4255e7		4889cf			MOVQ CX, DI				
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x4255ea		4889c3			MOVQ AX, BX		
			pp.sudogcache = append(pp.sudogcache, new(sudog))
  0x4255ed		4889d0			MOVQ DX, AX			
  0x4255f0		e88b400200		CALL runtime.gcWriteBarrier(SB)	
	n := len(pp.sudogcache)
  0x4255f5		4889d8			MOVQ BX, AX		
			pp.sudogcache = append(pp.sudogcache, new(sudog))
  0x4255f8		e9d7feffff		JMP 0x4254d4				
  0x4255fd		48897c2448		MOVQ DI, 0x48(SP)			
  0x425602		488d0537340300		LEAQ 0x33437(IP), AX			
  0x425609		48890424		MOVQ AX, 0(SP)				
  0x42560d		48895c2408		MOVQ BX, 0x8(SP)			
  0x425612		4889542410		MOVQ DX, 0x10(SP)			
  0x425617		48894c2418		MOVQ CX, 0x18(SP)			
  0x42561c		4889742420		MOVQ SI, 0x20(SP)			
  0x425621		e85a070100		CALL runtime.growslice(SB)		
  0x425626		488b442428		MOVQ 0x28(SP), AX			
  0x42562b		488b4c2430		MOVQ 0x30(SP), CX			
  0x425630		488b542438		MOVQ 0x38(SP), DX			
  0x425635		488b5c2458		MOVQ 0x58(SP), BX			
  0x42563a		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x425641		833dd8770b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425648		751d			JNE 0x425667				
  0x42564a		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x425651		488b7c2448		MOVQ 0x48(SP), DI			
  0x425656		4889ca			MOVQ CX, DX				
  0x425659		4889c6			MOVQ AX, SI				
  0x42565c		4889d8			MOVQ BX, AX				
  0x42565f		4889f3			MOVQ SI, BX				
  0x425662		e95cffffff		JMP 0x4255c3				
  0x425667		488b7c2450		MOVQ 0x50(SP), DI			
  0x42566c		e80f400200		CALL runtime.gcWriteBarrier(SB)		
  0x425671		ebde			JMP 0x425651				
	n := len(pp.sudogcache)
  0x425673		4889d8			MOVQ BX, AX		
  0x425676		e959feffff		JMP 0x4254d4		
		throw("acquireSudog: found s.elem != nil in cache")
  0x42567b		488d0502d50400		LEAQ 0x4d502(IP), AX	
  0x425682		48890424		MOVQ AX, 0(SP)		
  0x425686		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x42568f		e8ecddffff		CALL runtime.throw(SB)	
  0x425694		0f0b			UD2			
	pp.sudogcache = pp.sudogcache[:n-1]
  0x425696		e8b5c9ffff		CALL runtime.panicslice(SB)	
  0x42569b		0f0b			UD2				
	s := pp.sudogcache[n-1]
  0x42569d		e87ec8ffff		CALL runtime.panicindex(SB)	
  0x4256a2		0f0b			UD2				

TEXT runtime.releaseSudog(SB) /usr/local/go/src/runtime/proc.go
func releaseSudog(s *sudog) {
  0x4256b0		4883ec68		SUBQ $0x68, SP		
  0x4256b4		48896c2460		MOVQ BP, 0x60(SP)	
  0x4256b9		488d6c2460		LEAQ 0x60(SP), BP	
	if s.elem != nil {
  0x4256be		488b442470		MOVQ 0x70(SP), AX	
  0x4256c3		4883782000		CMPQ $0x0, 0x20(AX)	
  0x4256c8		0f8561030000		JNE 0x425a2f		
	if s.isSelect {
  0x4256ce		80780800		CMPB $0x0, 0x8(AX)	
  0x4256d2		0f853c030000		JNE 0x425a14		
	if s.next != nil {
  0x4256d8		4883781000		CMPQ $0x0, 0x10(AX)	
  0x4256dd		0f8516030000		JNE 0x4259f9		
	if s.prev != nil {
  0x4256e3		4883781800		CMPQ $0x0, 0x18(AX)	
  0x4256e8		0f85f0020000		JNE 0x4259de		
	if s.waitlink != nil {
  0x4256ee		4883784800		CMPQ $0x0, 0x48(AX)	
  0x4256f3		0f85ca020000		JNE 0x4259c3		
	if s.c != nil {
  0x4256f9		4883785800		CMPQ $0x0, 0x58(AX)	
  0x4256fe		0f85a4020000		JNE 0x4259a8		
	gp := getg()
  0x425704		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if gp.param != nil {
  0x42570d		4883b98800000000	CMPQ $0x0, 0x88(CX)	
  0x425715		0f8572020000		JNE 0x42598d		
	_g_.m.locks++
  0x42571b		488b5130		MOVQ 0x30(CX), DX	
	mp := acquirem() // avoid rescheduling to another P
  0x42571f		90			NOPL			
	_g_.m.locks++
  0x425720		ff8208010000		INCL 0x108(DX)		
	return _g_.m
  0x425726		488b5130		MOVQ 0x30(CX), DX	
  0x42572a		4889542440		MOVQ DX, 0x40(SP)	
	pp := mp.p.ptr()
  0x42572f		488b9ad0000000		MOVQ 0xd0(DX), BX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x425736		48895c2458		MOVQ BX, 0x58(SP)	
	return _g_.m
  0x42573b		8401			TESTB AL, 0(CX)		
	pp := mp.p.ptr()
  0x42573d		90			NOPL			
	if len(pp.sudogcache) == cap(pp.sudogcache) {
  0x42573e		488b8b100e0000		MOVQ 0xe10(BX), CX	
  0x425745		48398b080e0000		CMPQ CX, 0xe08(BX)	
  0x42574c		0f8512010000		JNE 0x425864		
  0x425752		31c9			XORL CX, CX		
  0x425754		31f6			XORL SI, SI		
		for len(pp.sudogcache) > cap(pp.sudogcache)/2 {
  0x425756		eb03			JMP 0x42575b		
				last.next = p
  0x425758		4c89de			MOVQ R11, SI		
		for len(pp.sudogcache) > cap(pp.sudogcache)/2 {
  0x42575b		4c8b83080e0000		MOVQ 0xe08(BX), R8	
  0x425762		4c8b8b000e0000		MOVQ 0xe00(BX), R9	
  0x425769		4c8b93100e0000		MOVQ 0xe10(BX), R10	
  0x425770		49d1ea			SHRQ $0x1, R10		
  0x425773		4d39d0			CMPQ R10, R8		
  0x425776		0f8e93000000		JLE 0x42580f		
			p := pp.sudogcache[n-1]
  0x42577c		4d8d50ff		LEAQ -0x1(R8), R10		
  0x425780		4d39c2			CMPQ R8, R10			
  0x425783		0f83fd010000		JAE 0x425986			
  0x425789		4f8b5cc1f8		MOVQ -0x8(R9)(R8*8), R11	
  0x42578e		4b8d3cc1		LEAQ 0(R9)(R8*8), DI		
  0x425792		488d7ff8		LEAQ -0x8(DI), DI		
			pp.sudogcache[n-1] = nil
  0x425796		833d83760b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42579d		7561			JNE 0x425800				
  0x42579f		4bc744c1f800000000	MOVQ $0x0, -0x8(R9)(R8*8)		
			pp.sudogcache = pp.sudogcache[:n-1]
  0x4257a8		4c8b83100e0000		MOVQ 0xe10(BX), R8	
  0x4257af		4d85d2			TESTQ R10, R10		
  0x4257b2		0f8cc7010000		JL 0x42597f		
  0x4257b8		4d39c2			CMPQ R8, R10		
  0x4257bb		0f87be010000		JA 0x42597f		
  0x4257c1		4c8993080e0000		MOVQ R10, 0xe08(BX)	
			if first == nil {
  0x4257c8		4885c9			TESTQ CX, CX		
  0x4257cb		742b			JE 0x4257f8		
				last.next = p
  0x4257cd		8406			TESTB AL, 0(SI)				
  0x4257cf		833d4a760b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4257d6		7509			JNE 0x4257e1				
  0x4257d8		4c895e10		MOVQ R11, 0x10(SI)			
  0x4257dc		e977ffffff		JMP 0x425758				
  0x4257e1		488d7e10		LEAQ 0x10(SI), DI			
func releaseSudog(s *sudog) {
  0x4257e5		4889c6			MOVQ AX, SI		
				last.next = p
  0x4257e8		4c89d8			MOVQ R11, AX			
  0x4257eb		e8903e0200		CALL runtime.gcWriteBarrier(SB)	
	pp.sudogcache = append(pp.sudogcache, s)
  0x4257f0		4889f0			MOVQ SI, AX		
				last.next = p
  0x4257f3		e960ffffff		JMP 0x425758		
			if first == nil {
  0x4257f8		4c89d9			MOVQ R11, CX		
				first = p
  0x4257fb		e958ffffff		JMP 0x425758		
func releaseSudog(s *sudog) {
  0x425800		4989c0			MOVQ AX, R8		
			pp.sudogcache[n-1] = nil
  0x425803		31c0			XORL AX, AX			
  0x425805		e8763e0200		CALL runtime.gcWriteBarrier(SB)	
	pp.sudogcache = append(pp.sudogcache, s)
  0x42580a		4c89c0			MOVQ R8, AX		
			pp.sudogcache[n-1] = nil
  0x42580d		eb99			JMP 0x4257a8		
				last.next = p
  0x42580f		4889742448		MOVQ SI, 0x48(SP)	
			if first == nil {
  0x425814		48894c2450		MOVQ CX, 0x50(SP)	
		lock(&sched.sudoglock)
  0x425819		488d0530c50900		LEAQ runtime.sched+176(SB), AX	
  0x425820		48890424		MOVQ AX, 0(SP)			
  0x425824		e8b72efeff		CALL runtime.lock(SB)		
		last.next = sched.sudogcache
  0x425829		488b442448		MOVQ 0x48(SP), AX			
  0x42582e		8400			TESTB AL, 0(AX)				
  0x425830		488b0d21c50900		MOVQ runtime.sched+184(SB), CX		
  0x425837		833de2750b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42583e		0f8519010000		JNE 0x42595d				
  0x425844		48894810		MOVQ CX, 0x10(AX)			
		sched.sudogcache = first
  0x425848		488b442450		MOVQ 0x50(SP), AX		
  0x42584d		48890504c50900		MOVQ AX, runtime.sched+184(SB)	
		unlock(&sched.sudoglock)
  0x425854		488d05f5c40900		LEAQ runtime.sched+176(SB), AX	
  0x42585b		48890424		MOVQ AX, 0(SP)			
  0x42585f		e82c30feff		CALL runtime.unlock(SB)		
	pp.sudogcache = append(pp.sudogcache, s)
  0x425864		488b4c2458		MOVQ 0x58(SP), CX			
  0x425869		488b91080e0000		MOVQ 0xe08(CX), DX			
  0x425870		488d5a01		LEAQ 0x1(DX), BX			
  0x425874		488bb1000e0000		MOVQ 0xe00(CX), SI			
  0x42587b		4c8b81100e0000		MOVQ 0xe10(CX), R8			
  0x425882		4c39c3			CMPQ R8, BX				
  0x425885		776b			JA 0x4258f2				
  0x425887		488d5a01		LEAQ 0x1(DX), BX			
  0x42588b		488999080e0000		MOVQ BX, 0xe08(CX)			
  0x425892		488d3cd6		LEAQ 0(SI)(DX*8), DI			
  0x425896		833d83750b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42589d		7547			JNE 0x4258e6				
  0x42589f		488b442470		MOVQ 0x70(SP), AX			
  0x4258a4		488904d6		MOVQ AX, 0(SI)(DX*8)			
	releasem(mp)
  0x4258a8		90			NOPL			
	_g_ := getg()
  0x4258a9		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x4258b2		488b4c2440		MOVQ 0x40(SP), CX	
  0x4258b7		8b9108010000		MOVL 0x108(CX), DX	
  0x4258bd		8d5aff			LEAL -0x1(DX), BX	
  0x4258c0		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x4258c6		83fa01			CMPL $0x1, DX		
  0x4258c9		7511			JNE 0x4258dc		
  0x4258cb		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x4258d2		7408			JE 0x4258dc		
		_g_.stackguard0 = stackPreempt
  0x4258d4		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x4258dc		488b6c2460		MOVQ 0x60(SP), BP	
  0x4258e1		4883c468		ADDQ $0x68, SP		
  0x4258e5		c3			RET			
	pp.sudogcache = append(pp.sudogcache, s)
  0x4258e6		488b442470		MOVQ 0x70(SP), AX			
  0x4258eb		e8903d0200		CALL runtime.gcWriteBarrier(SB)		
  0x4258f0		ebb6			JMP 0x4258a8				
  0x4258f2		488d0547310300		LEAQ 0x33147(IP), AX			
  0x4258f9		48890424		MOVQ AX, 0(SP)				
  0x4258fd		4889742408		MOVQ SI, 0x8(SP)			
  0x425902		4889542410		MOVQ DX, 0x10(SP)			
  0x425907		4c89442418		MOVQ R8, 0x18(SP)			
  0x42590c		48895c2420		MOVQ BX, 0x20(SP)			
  0x425911		e86a040100		CALL runtime.growslice(SB)		
  0x425916		488b442428		MOVQ 0x28(SP), AX			
  0x42591b		488b4c2430		MOVQ 0x30(SP), CX			
  0x425920		488b542438		MOVQ 0x38(SP), DX			
  0x425925		488b5c2458		MOVQ 0x58(SP), BX			
  0x42592a		488993100e0000		MOVQ DX, 0xe10(BX)			
  0x425931		833de8740b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425938		7515			JNE 0x42594f				
  0x42593a		488983000e0000		MOVQ AX, 0xe00(BX)			
  0x425941		4889ca			MOVQ CX, DX				
  0x425944		4889c6			MOVQ AX, SI				
  0x425947		4889d9			MOVQ BX, CX				
  0x42594a		e938ffffff		JMP 0x425887				
	if len(pp.sudogcache) == cap(pp.sudogcache) {
  0x42594f		488dbb000e0000		LEAQ 0xe00(BX), DI	
	pp.sudogcache = append(pp.sudogcache, s)
  0x425956		e8253d0200		CALL runtime.gcWriteBarrier(SB)	
  0x42595b		ebe4			JMP 0x425941			
		last.next = sched.sudogcache
  0x42595d		488d7810		LEAQ 0x10(AX), DI		
  0x425961		4889c8			MOVQ CX, AX			
  0x425964		e8173d0200		CALL runtime.gcWriteBarrier(SB)	
		sched.sudogcache = first
  0x425969		488d3de8c30900		LEAQ runtime.sched+184(SB), DI	
  0x425970		488b442450		MOVQ 0x50(SP), AX		
  0x425975		e8063d0200		CALL runtime.gcWriteBarrier(SB)	
		last.next = sched.sudogcache
  0x42597a		e9d5feffff		JMP 0x425854		
			pp.sudogcache = pp.sudogcache[:n-1]
  0x42597f		e8ccc6ffff		CALL runtime.panicslice(SB)	
  0x425984		0f0b			UD2				
			p := pp.sudogcache[n-1]
  0x425986		e895c5ffff		CALL runtime.panicindex(SB)	
  0x42598b		0f0b			UD2				
		throw("runtime: releaseSudog with non-nil gp.param")
  0x42598d		488d05edd30400		LEAQ 0x4d3ed(IP), AX	
  0x425994		48890424		MOVQ AX, 0(SP)		
  0x425998		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x4259a1		e8dadaffff		CALL runtime.throw(SB)	
  0x4259a6		0f0b			UD2			
		throw("runtime: sudog with non-nil c")
  0x4259a8		488d0508c00400		LEAQ 0x4c008(IP), AX	
  0x4259af		48890424		MOVQ AX, 0(SP)		
  0x4259b3		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4259bc		e8bfdaffff		CALL runtime.throw(SB)	
  0x4259c1		0f0b			UD2			
		throw("runtime: sudog with non-nil waitlink")
  0x4259c3		488d05f5cb0400		LEAQ 0x4cbf5(IP), AX	
  0x4259ca		48890424		MOVQ AX, 0(SP)		
  0x4259ce		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x4259d7		e8a4daffff		CALL runtime.throw(SB)	
  0x4259dc		0f0b			UD2			
		throw("runtime: sudog with non-nil prev")
  0x4259de		488d050cc60400		LEAQ 0x4c60c(IP), AX	
  0x4259e5		48890424		MOVQ AX, 0(SP)		
  0x4259e9		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x4259f2		e889daffff		CALL runtime.throw(SB)	
  0x4259f7		0f0b			UD2			
		throw("runtime: sudog with non-nil next")
  0x4259f9		488d05d1c50400		LEAQ 0x4c5d1(IP), AX	
  0x425a00		48890424		MOVQ AX, 0(SP)		
  0x425a04		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x425a0d		e86edaffff		CALL runtime.throw(SB)	
  0x425a12		0f0b			UD2			
		throw("runtime: sudog with non-false isSelect")
  0x425a14		488d05a9cd0400		LEAQ 0x4cda9(IP), AX	
  0x425a1b		48890424		MOVQ AX, 0(SP)		
  0x425a1f		48c744240826000000	MOVQ $0x26, 0x8(SP)	
  0x425a28		e853daffff		CALL runtime.throw(SB)	
  0x425a2d		0f0b			UD2			
		throw("runtime: sudog with non-nil elem")
  0x425a2f		488d057bc50400		LEAQ 0x4c57b(IP), AX	
  0x425a36		48890424		MOVQ AX, 0(SP)		
  0x425a3a		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x425a43		e838daffff		CALL runtime.throw(SB)	
  0x425a48		0f0b			UD2			

TEXT runtime.funcPC(SB) /usr/local/go/src/runtime/proc.go
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x425a50		488b442410		MOVQ 0x10(SP), AX	
  0x425a55		488b00			MOVQ 0(AX), AX		
  0x425a58		90			NOPL			
  0x425a59		4889442418		MOVQ AX, 0x18(SP)	
  0x425a5e		c3			RET			

TEXT runtime.badmcall(SB) /usr/local/go/src/runtime/proc.go
func badmcall(fn func(*g)) {
  0x425a60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425a69		483b6110		CMPQ 0x10(CX), SP	
  0x425a6d		7629			JBE 0x425a98		
  0x425a6f		4883ec18		SUBQ $0x18, SP		
  0x425a73		48896c2410		MOVQ BP, 0x10(SP)	
  0x425a78		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: mcall called on m->g0 stack")
  0x425a7d		488d0517cb0400		LEAQ 0x4cb17(IP), AX	
  0x425a84		48890424		MOVQ AX, 0(SP)		
  0x425a88		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x425a91		e8ead9ffff		CALL runtime.throw(SB)	
  0x425a96		0f0b			UD2			
func badmcall(fn func(*g)) {
  0x425a98		e8e31d0200		CALL runtime.morestack_noctxt(SB)	
  0x425a9d		ebc1			JMP runtime.badmcall(SB)		

TEXT runtime.badmcall2(SB) /usr/local/go/src/runtime/proc.go
func badmcall2(fn func(*g)) {
  0x425aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425aa9		483b6110		CMPQ 0x10(CX), SP	
  0x425aad		7629			JBE 0x425ad8		
  0x425aaf		4883ec18		SUBQ $0x18, SP		
  0x425ab3		48896c2410		MOVQ BP, 0x10(SP)	
  0x425ab8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: mcall function returned")
  0x425abd		488d058dc40400		LEAQ 0x4c48d(IP), AX	
  0x425ac4		48890424		MOVQ AX, 0(SP)		
  0x425ac8		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x425ad1		e8aad9ffff		CALL runtime.throw(SB)	
  0x425ad6		0f0b			UD2			
func badmcall2(fn func(*g)) {
  0x425ad8		e8a31d0200		CALL runtime.morestack_noctxt(SB)	
  0x425add		ebc1			JMP runtime.badmcall2(SB)		

TEXT runtime.badreflectcall(SB) /usr/local/go/src/runtime/proc.go
func badreflectcall() {
  0x425ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425ae9		483b6110		CMPQ 0x10(CX), SP	
  0x425aed		762c			JBE 0x425b1b		
  0x425aef		4883ec18		SUBQ $0x18, SP		
  0x425af3		48896c2410		MOVQ BP, 0x10(SP)	
  0x425af8		488d6c2410		LEAQ 0x10(SP), BP	
	panic(plainError("arg size to reflect.call more than 1GB"))
  0x425afd		488d05fc950300		LEAQ 0x395fc(IP), AX			
  0x425b04		48890424		MOVQ AX, 0(SP)				
  0x425b08		488d05a1740500		LEAQ runtime.statictmp_20(SB), AX	
  0x425b0f		4889442408		MOVQ AX, 0x8(SP)			
  0x425b14		e897d3ffff		CALL runtime.gopanic(SB)		
  0x425b19		0f0b			UD2					
func badreflectcall() {
  0x425b1b		e8601d0200		CALL runtime.morestack_noctxt(SB)	
  0x425b20		ebbe			JMP runtime.badreflectcall(SB)		

TEXT runtime.badmorestackg0(SB) /usr/local/go/src/runtime/proc.go
func badmorestackg0() {
  0x425b30		4883ec28		SUBQ $0x28, SP		
  0x425b34		48896c2420		MOVQ BP, 0x20(SP)	
  0x425b39		488d6c2420		LEAQ 0x20(SP), BP	
	sp := stringStructOf(&badmorestackg0Msg)
  0x425b3e		90			NOPL					
  0x425b3f		488b05fa9f0900		MOVQ runtime.badmorestackg0Msg(SB), AX	
	write(2, sp.str, int32(sp.len))
  0x425b46		488b0dfb9f0900		MOVQ runtime.badmorestackg0Msg+8(SB), CX	
  0x425b4d		48c7042402000000	MOVQ $0x2, 0(SP)				
  0x425b55		4889442408		MOVQ AX, 0x8(SP)				
  0x425b5a		894c2410		MOVL CX, 0x10(SP)				
  0x425b5e		e83d530200		CALL runtime.write(SB)				
}
  0x425b63		488b6c2420		MOVQ 0x20(SP), BP	
  0x425b68		4883c428		ADDQ $0x28, SP		
  0x425b6c		c3			RET			

TEXT runtime.badmorestackgsignal(SB) /usr/local/go/src/runtime/proc.go
func badmorestackgsignal() {
  0x425b70		4883ec28		SUBQ $0x28, SP		
  0x425b74		48896c2420		MOVQ BP, 0x20(SP)	
  0x425b79		488d6c2420		LEAQ 0x20(SP), BP	
	sp := stringStructOf(&badmorestackgsignalMsg)
  0x425b7e		90			NOPL						
  0x425b7f		488b05ca9f0900		MOVQ runtime.badmorestackgsignalMsg(SB), AX	
	write(2, sp.str, int32(sp.len))
  0x425b86		488b0dcb9f0900		MOVQ runtime.badmorestackgsignalMsg+8(SB), CX	
  0x425b8d		48c7042402000000	MOVQ $0x2, 0(SP)				
  0x425b95		4889442408		MOVQ AX, 0x8(SP)				
  0x425b9a		894c2410		MOVL CX, 0x10(SP)				
  0x425b9e		e8fd520200		CALL runtime.write(SB)				
}
  0x425ba3		488b6c2420		MOVQ 0x20(SP), BP	
  0x425ba8		4883c428		ADDQ $0x28, SP		
  0x425bac		c3			RET			

TEXT runtime.badctxt(SB) /usr/local/go/src/runtime/proc.go
func badctxt() {
  0x425bb0		4883ec18		SUBQ $0x18, SP		
  0x425bb4		48896c2410		MOVQ BP, 0x10(SP)	
  0x425bb9		488d6c2410		LEAQ 0x10(SP), BP	
	throw("ctxt != 0")
  0x425bbe		488d05b5990400		LEAQ 0x499b5(IP), AX	
  0x425bc5		48890424		MOVQ AX, 0(SP)		
  0x425bc9		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x425bd2		e8a9d8ffff		CALL runtime.throw(SB)	
  0x425bd7		0f0b			UD2			

TEXT runtime.allgadd(SB) /usr/local/go/src/runtime/proc.go
func allgadd(gp *g) {
  0x425be0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425be9		483b6110		CMPQ 0x10(CX), SP	
  0x425bed		0f8623010000		JBE 0x425d16		
  0x425bf3		4883ec48		SUBQ $0x48, SP		
  0x425bf7		48896c2440		MOVQ BP, 0x40(SP)	
  0x425bfc		488d6c2440		LEAQ 0x40(SP), BP	
	if readgstatus(gp) == _Gidle {
  0x425c01		90			NOPL			
  0x425c02		488b442450		MOVQ 0x50(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x425c07		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp) == _Gidle {
  0x425c0d		85c9			TESTL CX, CX		
  0x425c0f		0f84e6000000		JE 0x425cfb		
	lock(&allglock)
  0x425c15		488d0504710b00		LEAQ runtime.allglock(SB), AX	
  0x425c1c		48890424		MOVQ AX, 0(SP)			
  0x425c20		e8bb2afeff		CALL runtime.lock(SB)		
	allgs = append(allgs, gp)
  0x425c25		488b05dcbd0900		MOVQ runtime.allgs+8(SB), AX		
  0x425c2c		488d4801		LEAQ 0x1(AX), CX			
  0x425c30		488b15c9bd0900		MOVQ runtime.allgs(SB), DX		
  0x425c37		488b1dd2bd0900		MOVQ runtime.allgs+16(SB), BX		
  0x425c3e		4839d9			CMPQ BX, CX				
  0x425c41		7755			JA 0x425c98				
  0x425c43		488d4801		LEAQ 0x1(AX), CX			
  0x425c47		48890dbabd0900		MOVQ CX, runtime.allgs+8(SB)		
  0x425c4e		488d3cc2		LEAQ 0(DX)(AX*8), DI			
  0x425c52		833dc7710b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425c59		7531			JNE 0x425c8c				
  0x425c5b		488b4c2450		MOVQ 0x50(SP), CX			
  0x425c60		48890cc2		MOVQ CX, 0(DX)(AX*8)			
	allglen = uintptr(len(allgs))
  0x425c64		488b059dbd0900		MOVQ runtime.allgs+8(SB), AX	
  0x425c6b		488905a6700b00		MOVQ AX, runtime.allglen(SB)	
	unlock(&allglock)
  0x425c72		488d05a7700b00		LEAQ runtime.allglock(SB), AX	
  0x425c79		48890424		MOVQ AX, 0(SP)			
  0x425c7d		e80e2cfeff		CALL runtime.unlock(SB)		
}
  0x425c82		488b6c2440		MOVQ 0x40(SP), BP	
  0x425c87		4883c448		ADDQ $0x48, SP		
  0x425c8b		c3			RET			
	allgs = append(allgs, gp)
  0x425c8c		488b442450		MOVQ 0x50(SP), AX			
  0x425c91		e8ea390200		CALL runtime.gcWriteBarrier(SB)		
  0x425c96		ebcc			JMP 0x425c64				
  0x425c98		488d35211f0300		LEAQ 0x31f21(IP), SI			
  0x425c9f		48893424		MOVQ SI, 0(SP)				
  0x425ca3		4889542408		MOVQ DX, 0x8(SP)			
  0x425ca8		4889442410		MOVQ AX, 0x10(SP)			
  0x425cad		48895c2418		MOVQ BX, 0x18(SP)			
  0x425cb2		48894c2420		MOVQ CX, 0x20(SP)			
  0x425cb7		e8c4000100		CALL runtime.growslice(SB)		
  0x425cbc		488b442428		MOVQ 0x28(SP), AX			
  0x425cc1		488b4c2430		MOVQ 0x30(SP), CX			
  0x425cc6		488b542438		MOVQ 0x38(SP), DX			
  0x425ccb		4889153ebd0900		MOVQ DX, runtime.allgs+16(SB)		
  0x425cd2		833d47710b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x425cd9		7512			JNE 0x425ced				
  0x425cdb		4889051ebd0900		MOVQ AX, runtime.allgs(SB)		
  0x425ce2		4889c2			MOVQ AX, DX				
  0x425ce5		4889c8			MOVQ CX, AX				
  0x425ce8		e956ffffff		JMP 0x425c43				
  0x425ced		488d3d0cbd0900		LEAQ runtime.allgs(SB), DI		
  0x425cf4		e887390200		CALL runtime.gcWriteBarrier(SB)		
  0x425cf9		ebe7			JMP 0x425ce2				
		throw("allgadd: bad status Gidle")
  0x425cfb		488d05b3b20400		LEAQ 0x4b2b3(IP), AX	
  0x425d02		48890424		MOVQ AX, 0(SP)		
  0x425d06		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x425d0f		e86cd7ffff		CALL runtime.throw(SB)	
  0x425d14		0f0b			UD2			
func allgadd(gp *g) {
  0x425d16		e8651b0200		CALL runtime.morestack_noctxt(SB)	
  0x425d1b		e9c0feffff		JMP runtime.allgadd(SB)			

TEXT runtime.cpuinit(SB) /usr/local/go/src/runtime/proc.go
func cpuinit() {
  0x425d20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425d29		483b6110		CMPQ 0x10(CX), SP	
  0x425d2d		0f8662010000		JBE 0x425e95		
  0x425d33		4883ec48		SUBQ $0x48, SP		
  0x425d37		48896c2440		MOVQ BP, 0x40(SP)	
  0x425d3c		488d6c2440		LEAQ 0x40(SP), BP	
		cpu.DebugOptions = true
  0x425d41		c605596f0b0001		MOVB $0x1, internal/cpu.DebugOptions(SB)	
  0x425d48		31c0			XORL AX, AX					
		for argv_index(argv, argc+1+n) != nil {
  0x425d4a		eb02			JMP 0x425d4e		
			n++
  0x425d4c		ffc0			INCL AX			
		for argv_index(argv, argc+1+n) != nil {
  0x425d4e		90			NOPL				
  0x425d4f		8b0d676f0b00		MOVL runtime.argc(SB), CX	
  0x425d55		8d0c08			LEAL 0(AX)(CX*1), CX		
  0x425d58		8d4901			LEAL 0x1(CX), CX		
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x425d5b		90			NOPL			
  0x425d5c		4863c9			MOVSXD CX, CX		
  0x425d5f		48c1e103		SHLQ $0x3, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x425d63		48030db6bb0900		ADDQ runtime.argv(SB), CX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x425d6a		48833900		CMPQ $0x0, 0(CX)	
		for argv_index(argv, argc+1+n) != nil {
  0x425d6e		75dc			JNE 0x425d4c		
  0x425d70		89442420		MOVL AX, 0x20(SP)	
  0x425d74		31c9			XORL CX, CX		
		for i := int32(0); i < n; i++ {
  0x425d76		eb0b			JMP 0x425d83		
  0x425d78		8b542424		MOVL 0x24(SP), DX	
  0x425d7c		8d4a01			LEAL 0x1(DX), CX	
  0x425d7f		8b442420		MOVL 0x20(SP), AX	
  0x425d83		39c1			CMPL AX, CX		
  0x425d85		0f8dfd000000		JGE 0x425e88		
  0x425d8b		894c2424		MOVL CX, 0x24(SP)	
			p := argv_index(argv, argc+1+i)
  0x425d8f		90			NOPL				
  0x425d90		8b05266f0b00		MOVL runtime.argc(SB), AX	
  0x425d96		8d0408			LEAL 0(AX)(CX*1), AX		
  0x425d99		8d4001			LEAL 0x1(AX), AX		
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x425d9c		4863c0			MOVSXD AX, AX		
  0x425d9f		48c1e003		SHLQ $0x3, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x425da3		48030576bb0900		ADDQ runtime.argv(SB), AX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x425daa		488b00			MOVQ 0(AX), AX		
  0x425dad		4889442428		MOVQ AX, 0x28(SP)	
  0x425db2		90			NOPL			
			s := *(*string)(unsafe.Pointer(&stringStruct{unsafe.Pointer(p), findnull(p)}))
  0x425db3		48890424		MOVQ AX, 0(SP)			
  0x425db7		e844420100		CALL runtime.findnull(SB)	
  0x425dbc		488b442408		MOVQ 0x8(SP), AX		
  0x425dc1		0f57c0			XORPS X0, X0			
  0x425dc4		0f11442430		MOVUPS X0, 0x30(SP)		
  0x425dc9		488b4c2428		MOVQ 0x28(SP), CX		
  0x425dce		48894c2430		MOVQ CX, 0x30(SP)		
  0x425dd3		4889442438		MOVQ AX, 0x38(SP)		
  0x425dd8		488b542430		MOVQ 0x30(SP), DX		
			if hasPrefix(s, prefix) {
  0x425ddd		90			NOPL			
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x425dde		4883f808		CMPQ $0x8, AX		
  0x425de2		7d77			JGE 0x425e5b		
  0x425de4		31c0			XORL AX, AX		
			if hasPrefix(s, prefix) {
  0x425de6		84c0			TESTL AL, AL		
  0x425de8		748e			JE 0x425d78		
				env = gostring(p)[len(prefix):]
  0x425dea		48890c24		MOVQ CX, 0(SP)			
  0x425dee		e80d3f0100		CALL runtime.gostring(SB)	
  0x425df3		488b442410		MOVQ 0x10(SP), AX		
  0x425df8		488b4c2408		MOVQ 0x8(SP), CX		
  0x425dfd		4883f808		CMPQ $0x8, AX			
  0x425e01		0f8287000000		JB 0x425e8e			
  0x425e07		4883c0f8		ADDQ $-0x8, AX			
  0x425e0b		4889c2			MOVQ AX, DX			
  0x425e0e		48f7d8			NEGQ AX				
  0x425e11		48c1f83f		SARQ $0x3f, AX			
  0x425e15		4883e008		ANDQ $0x8, AX			
  0x425e19		4801c8			ADDQ CX, AX			
	cpu.Initialize(env)
  0x425e1c		48890424		MOVQ AX, 0(SP)				
  0x425e20		4889542408		MOVQ DX, 0x8(SP)			
  0x425e25		e8d6b1fdff		CALL internal/cpu.Initialize(SB)	
	x86HasPOPCNT = cpu.X86.HasPOPCNT
  0x425e2a		0fb60559720b00		MOVZX internal/cpu.X86+74(SB), AX	
  0x425e31		8805806e0b00		MOVB AL, runtime.x86HasPOPCNT(SB)	
	x86HasSSE41 = cpu.X86.HasSSE41
  0x425e37		0fb60550720b00		MOVZX internal/cpu.X86+78(SB), AX	
  0x425e3e		8805746e0b00		MOVB AL, runtime.x86HasSSE41(SB)	
	arm64HasATOMICS = cpu.ARM64.HasATOMICS
  0x425e44		0fb605dd720b00		MOVZX internal/cpu.ARM64+72(SB), AX	
  0x425e4b		8805536e0b00		MOVB AL, runtime.arm64HasATOMICS(SB)	
}
  0x425e51		488b6c2440		MOVQ 0x40(SP), BP	
  0x425e56		4883c448		ADDQ $0x48, SP		
  0x425e5a		c3			RET			
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x425e5b		48891424		MOVQ DX, 0(SP)			
  0x425e5f		488d05da950400		LEAQ 0x495da(IP), AX		
  0x425e66		4889442408		MOVQ AX, 0x8(SP)		
  0x425e6b		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x425e74		e8a7c3fdff		CALL runtime.memequal(SB)	
  0x425e79		0fb6442418		MOVZX 0x18(SP), AX		
				env = gostring(p)[len(prefix):]
  0x425e7e		488b4c2428		MOVQ 0x28(SP), CX	
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x425e83		e95effffff		JMP 0x425de6		
  0x425e88		31d2			XORL DX, DX		
  0x425e8a		31c0			XORL AX, AX		
		for i := int32(0); i < n; i++ {
  0x425e8c		eb8e			JMP 0x425e1c		
				env = gostring(p)[len(prefix):]
  0x425e8e		e8bdc1ffff		CALL runtime.panicslice(SB)	
  0x425e93		0f0b			UD2				
func cpuinit() {
  0x425e95		e8e6190200		CALL runtime.morestack_noctxt(SB)	
  0x425e9a		e981feffff		JMP runtime.cpuinit(SB)			

TEXT runtime.schedinit(SB) /usr/local/go/src/runtime/proc.go
func schedinit() {
  0x425ea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x425ea9		483b6110		CMPQ 0x10(CX), SP	
  0x425ead		0f863d020000		JBE 0x4260f0		
  0x425eb3		4883ec50		SUBQ $0x50, SP		
  0x425eb7		48896c2448		MOVQ BP, 0x48(SP)	
  0x425ebc		488d6c2448		LEAQ 0x48(SP), BP	
	_g_ := getg()
  0x425ec1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x425eca		4889442438		MOVQ AX, 0x38(SP)	
	sched.maxmcount = 10000
  0x425ecf		c705f7bd090010270000	MOVL $0x2710, runtime.sched+48(SB)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x425ed9		488d0da8da0400		LEAQ 0x4daa8(IP), CX	
  0x425ee0		8401			TESTB AL, 0(CX)		
	tracebackinit()
  0x425ee2		90			NOPL			
	skipPC = funcPC(skipPleaseUseCallersFrames)
  0x425ee3		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x425ee4		488b0d9dda0400		MOVQ 0x4da9d(IP), CX	
  0x425eeb		90			NOPL			
	skipPC = funcPC(skipPleaseUseCallersFrames)
  0x425eec		48890ddd6e0b00		MOVQ CX, runtime.skipPC(SB)	
	moduledataverify()
  0x425ef3		e8d8440100		CALL runtime.moduledataverify(SB)	
	stackinit()
  0x425ef8		e8c3040100		CALL runtime.stackinit(SB)	
	mallocinit()
  0x425efd		e80e2ffeff		CALL runtime.mallocinit(SB)	
	mcommoninit(_g_.m)
  0x425f02		488b442438		MOVQ 0x38(SP), AX		
  0x425f07		488b4830		MOVQ 0x30(AX), CX		
  0x425f0b		48890c24		MOVQ CX, 0(SP)			
  0x425f0f		e8ac020000		CALL runtime.mcommoninit(SB)	
	cpuinit()       // must run before alginit
  0x425f14		e807feffff		CALL runtime.cpuinit(SB)	
	alginit()       // maps must not be used before this call
  0x425f19		e812d3fdff		CALL runtime.alginit(SB)	
	modulesinit()   // provides activeModules
  0x425f1e		e82d420100		CALL runtime.modulesinit(SB)	
	typelinksinit() // uses maps, activeModules
  0x425f23		e8f8c50100		CALL runtime.typelinksinit(SB)	
	itabsinit()     // uses activeModules
  0x425f28		e89321feff		CALL runtime.itabsinit(SB)	
	msigsave(_g_.m)
  0x425f2d		488b442438		MOVQ 0x38(SP), AX	
  0x425f32		488b4830		MOVQ 0x30(AX), CX	
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x425f36		8401			TESTB AL, 0(CX)		
	msigsave(_g_.m)
  0x425f38		90			NOPL			
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x425f39		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x425f3a		c7042402000000		MOVL $0x2, 0(SP)	
  0x425f41		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x425f4a		4881c180000000		ADDQ $0x80, CX		
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x425f51		48894c2410		MOVQ CX, 0x10(SP)		
  0x425f56		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x425f5e		e80d520200		CALL runtime.rtsigprocmask(SB)	
	initSigmask = _g_.m.sigmask
  0x425f63		488b442438		MOVQ 0x38(SP), AX			
  0x425f68		488b4030		MOVQ 0x30(AX), AX			
  0x425f6c		488b8080000000		MOVQ 0x80(AX), AX			
  0x425f73		488905066e0b00		MOVQ AX, runtime.initSigmask(SB)	
	goargs()
  0x425f7a		e821b40000		CALL runtime.goargs(SB)	
	goenvs()
  0x425f7f		90			NOPL			
	goenvs_unix()
  0x425f80		e85bb50000		CALL runtime.goenvs_unix(SB)	
	parsedebugvars()
  0x425f85		e8a6bc0000		CALL runtime.parsedebugvars(SB)	
	gcinit()
  0x425f8a		e861bdfeff		CALL runtime.gcinit(SB)	
	sched.lastpoll = uint64(nanotime())
  0x425f8f		e81c510200		CALL runtime.nanotime(SB)	
  0x425f94		488b0424		MOVQ 0(SP), AX			
  0x425f98		48890509bd0900		MOVQ AX, runtime.sched+8(SB)	
	procs := ncpu
  0x425f9f		8b053f6d0b00		MOVL runtime.ncpu(SB), AX	
  0x425fa5		89442424		MOVL AX, 0x24(SP)		
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x425fa9		488d0dee970400		LEAQ 0x497ee(IP), CX		
  0x425fb0		48890c24		MOVQ CX, 0(SP)			
  0x425fb4		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x425fbd		e8ae00feff		CALL runtime.gogetenv(SB)	
  0x425fc2		90			NOPL				
  0x425fc3		488b442418		MOVQ 0x18(SP), AX		
  0x425fc8		488b4c2410		MOVQ 0x10(SP), CX		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x425fcd		48890c24		MOVQ CX, 0(SP)		
  0x425fd1		4889442408		MOVQ AX, 0x8(SP)	
  0x425fd6		e8f53e0100		CALL runtime.atoi(SB)	
  0x425fdb		488b442410		MOVQ 0x10(SP), AX	
  0x425fe0		4863c8			MOVSXD AX, CX		
  0x425fe3		4839c1			CMPQ AX, CX		
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x425fe6		b900000000		MOVL $0x0, CX		
  0x425feb		0f44c8			CMOVE AX, CX		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x425fee		0f94c0			SETE AL			
  0x425ff1		0fb6542418		MOVZX 0x18(SP), DX	
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x425ff6		21d0			ANDL DX, AX		
  0x425ff8		84c0			TESTL AL, AL		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x425ffa		0f84cc000000		JE 0x4260cc		
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
  0x426000		85c9			TESTL CX, CX		
  0x426002		0f8ec4000000		JLE 0x4260cc		
	if procresize(procs) != nil {
  0x426008		890c24			MOVL CX, 0(SP)			
  0x42600b		e8407a0000		CALL runtime.procresize(SB)	
  0x426010		48837c240800		CMPQ $0x0, 0x8(SP)		
  0x426016		0f85b9000000		JNE 0x4260d5			
	if debug.cgocheck > 1 {
  0x42601c		833dc16e0b0001		CMPL $0x1, runtime.debug+4(SB)	
  0x426023		7e5c			JLE 0x426081			
		writeBarrier.cgo = true
  0x426025		c605f96d0b0001		MOVB $0x1, runtime.writeBarrier+5(SB)	
		writeBarrier.enabled = true
  0x42602c		c605ed6d0b0001		MOVB $0x1, runtime.writeBarrier(SB)	
		for _, p := range allp {
  0x426033		488b0de6b90900		MOVQ runtime.allp(SB), CX	
  0x42603a		48894c2440		MOVQ CX, 0x40(SP)		
  0x42603f		488b15e2b90900		MOVQ runtime.allp+8(SB), DX	
  0x426046		4889542430		MOVQ DX, 0x30(SP)		
  0x42604b		31c0			XORL AX, AX			
  0x42604d		eb2d			JMP 0x42607c			
  0x42604f		4889442428		MOVQ AX, 0x28(SP)		
  0x426054		488b14c1		MOVQ 0(CX)(AX*8), DX		
			p.wbBuf.reset()
  0x426058		8402			TESTB AL, 0(DX)			
  0x42605a		4881c220130000		ADDQ $0x1320, DX		
  0x426061		48891424		MOVQ DX, 0(SP)			
  0x426065		e806abffff		CALL runtime.(*wbBuf).reset(SB)	
		for _, p := range allp {
  0x42606a		488b442428		MOVQ 0x28(SP), AX	
  0x42606f		48ffc0			INCQ AX			
  0x426072		488b4c2440		MOVQ 0x40(SP), CX	
  0x426077		488b542430		MOVQ 0x30(SP), DX	
  0x42607c		4839d0			CMPQ DX, AX		
  0x42607f		7cce			JL 0x42604f		
	if buildVersion == "" {
  0x426081		48833def9a090000	CMPQ $0x0, runtime.buildVersion+8(SB)	
  0x426089		7522			JNE 0x4260ad				
		buildVersion = "unknown"
  0x42608b		48c705e29a090007000000	MOVQ $0x7, runtime.buildVersion+8(SB)	
  0x426096		833d836d0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42609d		7518			JNE 0x4260b7				
  0x42609f		488d0524930400		LEAQ 0x49324(IP), AX			
  0x4260a6		488905c39a0900		MOVQ AX, runtime.buildVersion(SB)	
  0x4260ad		488b6c2448		MOVQ 0x48(SP), BP			
  0x4260b2		4883c450		ADDQ $0x50, SP				
  0x4260b6		c3			RET					
  0x4260b7		488d3db29a0900		LEAQ runtime.buildVersion(SB), DI	
  0x4260be		488d0505930400		LEAQ 0x49305(IP), AX			
  0x4260c5		e8b6350200		CALL runtime.gcWriteBarrier(SB)		
  0x4260ca		ebe1			JMP 0x4260ad				
	if procresize(procs) != nil {
  0x4260cc		8b4c2424		MOVL 0x24(SP), CX	
  0x4260d0		e933ffffff		JMP 0x426008		
		throw("unknown runnable goroutine during bootstrap")
  0x4260d5		488d05d0cc0400		LEAQ 0x4ccd0(IP), AX	
  0x4260dc		48890424		MOVQ AX, 0(SP)		
  0x4260e0		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x4260e9		e892d3ffff		CALL runtime.throw(SB)	
  0x4260ee		0f0b			UD2			
func schedinit() {
  0x4260f0		e88b170200		CALL runtime.morestack_noctxt(SB)	
  0x4260f5		e9a6fdffff		JMP runtime.schedinit(SB)		

TEXT runtime.checkmcount(SB) /usr/local/go/src/runtime/proc.go
func checkmcount() {
  0x426100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426109		483b6110		CMPQ 0x10(CX), SP	
  0x42610d		0f869c000000		JBE 0x4261af		
  0x426113		4883ec20		SUBQ $0x20, SP		
  0x426117		48896c2418		MOVQ BP, 0x18(SP)	
  0x42611c		488d6c2418		LEAQ 0x18(SP), BP	
	if mcount() > sched.maxmcount {
  0x426121		90			NOPL				
  0x426122		8b05a8bb0900		MOVL runtime.sched+48(SB), AX	
	return int32(sched.mnext - sched.nmfreed)
  0x426128		488b0d99bb0900		MOVQ runtime.sched+40(SB), CX	
  0x42612f		482b0da2bb0900		SUBQ runtime.sched+56(SB), CX	
	if mcount() > sched.maxmcount {
  0x426136		39c1			CMPL AX, CX		
  0x426138		7f0a			JG 0x426144		
  0x42613a		488b6c2418		MOVQ 0x18(SP), BP	
  0x42613f		4883c420		ADDQ $0x20, SP		
  0x426143		c3			RET			
  0x426144		89442414		MOVL AX, 0x14(SP)	
		print("runtime: program exceeds ", sched.maxmcount, "-thread limit\n")
  0x426148		e873ddffff		CALL runtime.printlock(SB)	
  0x42614d		488d05a6af0400		LEAQ 0x4afa6(IP), AX		
  0x426154		48890424		MOVQ AX, 0(SP)			
  0x426158		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x426161		e88ae6ffff		CALL runtime.printstring(SB)	
  0x426166		8b442414		MOVL 0x14(SP), AX		
  0x42616a		4863c0			MOVSXD AX, AX			
  0x42616d		48890424		MOVQ AX, 0(SP)			
  0x426171		e8cae4ffff		CALL runtime.printint(SB)	
  0x426176		488d05bf9b0400		LEAQ 0x49bbf(IP), AX		
  0x42617d		48890424		MOVQ AX, 0(SP)			
  0x426181		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x42618a		e861e6ffff		CALL runtime.printstring(SB)	
  0x42618f		e8acddffff		CALL runtime.printunlock(SB)	
		throw("thread exhaustion")
  0x426194		488d05c2a00400		LEAQ 0x4a0c2(IP), AX	
  0x42619b		48890424		MOVQ AX, 0(SP)		
  0x42619f		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x4261a8		e8d3d2ffff		CALL runtime.throw(SB)	
  0x4261ad		0f0b			UD2			
func checkmcount() {
  0x4261af		e8cc160200		CALL runtime.morestack_noctxt(SB)	
  0x4261b4		e947ffffff		JMP runtime.checkmcount(SB)		

TEXT runtime.mcommoninit(SB) /usr/local/go/src/runtime/proc.go
func mcommoninit(mp *m) {
  0x4261c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4261c9		483b6110		CMPQ 0x10(CX), SP	
  0x4261cd		0f8609020000		JBE 0x4263dc		
  0x4261d3		4883ec30		SUBQ $0x30, SP		
  0x4261d7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4261dc		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x4261e1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_ != _g_.m.g0 {
  0x4261ea		488b4830		MOVQ 0x30(AX), CX	
  0x4261ee		483901			CMPQ AX, 0(CX)		
  0x4261f1		0f8593010000		JNE 0x42638a		
	lock(&sched.lock)
  0x4261f7		488d05b2ba0900		LEAQ runtime.sched+16(SB), AX	
  0x4261fe		48890424		MOVQ AX, 0(SP)			
  0x426202		e8d924feff		CALL runtime.lock(SB)		
	if sched.mnext+1 < sched.mnext {
  0x426207		488b05baba0900		MOVQ runtime.sched+40(SB), AX	
  0x42620e		488d4801		LEAQ 0x1(AX), CX		
  0x426212		4839c1			CMPQ AX, CX			
  0x426215		0f8ca6010000		JL 0x4263c1			
	mp.id = sched.mnext
  0x42621b		488b4c2438		MOVQ 0x38(SP), CX	
  0x426220		488981e8000000		MOVQ AX, 0xe8(CX)	
	sched.mnext++
  0x426227		48ff059aba0900		INCQ runtime.sched+40(SB)	
	checkmcount()
  0x42622e		e8cdfeffff		CALL runtime.checkmcount(SB)	
	mp.fastrand[0] = 1597334677 * uint32(mp.id)
  0x426233		488b442438		MOVQ 0x38(SP), AX		
  0x426238		488b88e8000000		MOVQ 0xe8(AX), CX		
  0x42623f		69c99564355f		IMULL $0x5f356495, CX, CX	
  0x426245		898820010000		MOVL CX, 0x120(AX)		
	mp.fastrand[1] = uint32(cputicks())
  0x42624b		e8c02d0200		CALL runtime.cputicks(SB)	
  0x426250		488b0424		MOVQ 0(SP), AX			
  0x426254		488b4c2438		MOVQ 0x38(SP), CX		
  0x426259		898124010000		MOVL AX, 0x124(CX)		
	if mp.fastrand[0]|mp.fastrand[1] == 0 {
  0x42625f		8b9120010000		MOVL 0x120(CX), DX	
  0x426265		09c2			ORL AX, DX		
  0x426267		85d2			TESTL DX, DX		
  0x426269		750a			JNE 0x426275		
		mp.fastrand[1] = 1
  0x42626b		c7812401000001000000	MOVL $0x1, 0x124(CX)	
	mpreinit(mp)
  0x426275		90			NOPL			
	mp.gsignal = malg(32 * 1024) // Linux wants >= 2K
  0x426276		c7042400800000		MOVL $0x8000, 0(SP)			
  0x42627d		e8fe610000		CALL runtime.malg(SB)			
  0x426282		488b442408		MOVQ 0x8(SP), AX			
  0x426287		833d926b0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42628e		0f85e3000000		JNE 0x426377				
  0x426294		488b4c2438		MOVQ 0x38(SP), CX			
  0x426299		48894150		MOVQ AX, 0x50(CX)			
	mp.gsignal.m = mp
  0x42629d		8400			TESTB AL, 0(AX)				
  0x42629f		833d7a6b0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4262a6		0f85ba000000		JNE 0x426366				
  0x4262ac		48894830		MOVQ CX, 0x30(AX)			
	if mp.gsignal != nil {
  0x4262b0		488b5150		MOVQ 0x50(CX), DX	
  0x4262b4		4885d2			TESTQ DX, DX		
  0x4262b7		740e			JE 0x4262c7		
		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard
  0x4262b9		488b1a			MOVQ 0(DX), BX		
  0x4262bc		4881c370030000		ADDQ $0x370, BX		
  0x4262c3		48895a18		MOVQ BX, 0x18(DX)	
	mp.alllink = allm
  0x4262c7		488b054ab60900		MOVQ runtime.allm(SB), AX		
  0x4262ce		833d4b6b0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4262d5		757e			JNE 0x426355				
  0x4262d7		48898150010000		MOVQ AX, 0x150(CX)			
	atomicstorep(unsafe.Pointer(&allm), unsafe.Pointer(mp))
  0x4262de		488d0533b60900		LEAQ runtime.allm(SB), AX	
  0x4262e5		48890424		MOVQ AX, 0(SP)			
  0x4262e9		48894c2408		MOVQ CX, 0x8(SP)		
  0x4262ee		e83dd1fdff		CALL runtime.atomicstorep(SB)	
	unlock(&sched.lock)
  0x4262f3		488d05b6b90900		LEAQ runtime.sched+16(SB), AX	
  0x4262fa		48890424		MOVQ AX, 0(SP)			
  0x4262fe		e88d25feff		CALL runtime.unlock(SB)		
	if iscgo || GOOS == "solaris" || GOOS == "windows" {
  0x426303		803da4690b0000		CMPB $0x0, runtime.iscgo(SB)	
  0x42630a		750a			JNE 0x426316			
  0x42630c		488b6c2428		MOVQ 0x28(SP), BP		
  0x426311		4883c430		ADDQ $0x30, SP			
  0x426315		c3			RET				
		mp.cgoCallers = new(cgoCallers)
  0x426316		488d05c3890300		LEAQ 0x389c3(IP), AX			
  0x42631d		48890424		MOVQ AX, 0(SP)				
  0x426321		e82a44feff		CALL runtime.newobject(SB)		
  0x426326		488b442408		MOVQ 0x8(SP), AX			
  0x42632b		833dee6a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x426332		750e			JNE 0x426342				
  0x426334		488b4c2438		MOVQ 0x38(SP), CX			
  0x426339		48898140010000		MOVQ AX, 0x140(CX)			
  0x426340		ebca			JMP 0x42630c				
  0x426342		488b4c2438		MOVQ 0x38(SP), CX			
  0x426347		488db940010000		LEAQ 0x140(CX), DI			
  0x42634e		e82d330200		CALL runtime.gcWriteBarrier(SB)		
  0x426353		ebb7			JMP 0x42630c				
	mp.alllink = allm
  0x426355		488db950010000		LEAQ 0x150(CX), DI		
  0x42635c		e81f330200		CALL runtime.gcWriteBarrier(SB)	
  0x426361		e978ffffff		JMP 0x4262de			
	mp.gsignal.m = mp
  0x426366		488d7830		LEAQ 0x30(AX), DI		
  0x42636a		4889c8			MOVQ CX, AX			
  0x42636d		e80e330200		CALL runtime.gcWriteBarrier(SB)	
  0x426372		e939ffffff		JMP 0x4262b0			
	mp.gsignal = malg(32 * 1024) // Linux wants >= 2K
  0x426377		488b4c2438		MOVQ 0x38(SP), CX		
  0x42637c		488d7950		LEAQ 0x50(CX), DI		
  0x426380		e8fb320200		CALL runtime.gcWriteBarrier(SB)	
  0x426385		e913ffffff		JMP 0x42629d			
		callers(1, mp.createstack[:])
  0x42638a		488b442438		MOVQ 0x38(SP), AX		
  0x42638f		8400			TESTB AL, 0(AX)			
  0x426391		48c7042401000000	MOVQ $0x1, 0(SP)		
  0x426399		488d8870010000		LEAQ 0x170(AX), CX		
  0x4263a0		48894c2408		MOVQ CX, 0x8(SP)		
  0x4263a5		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x4263ae		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x4263b7		e874a10100		CALL runtime.callers(SB)	
  0x4263bc		e936feffff		JMP 0x4261f7			
		throw("runtime: thread ID overflow")
  0x4263c1		488d051ab10400		LEAQ 0x4b11a(IP), AX	
  0x4263c8		48890424		MOVQ AX, 0(SP)		
  0x4263cc		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4263d5		e8a6d0ffff		CALL runtime.throw(SB)	
  0x4263da		0f0b			UD2			
func mcommoninit(mp *m) {
  0x4263dc		e89f140200		CALL runtime.morestack_noctxt(SB)	
  0x4263e1		e9dafdffff		JMP runtime.mcommoninit(SB)		

TEXT runtime.ready(SB) /usr/local/go/src/runtime/proc.go
func ready(gp *g, traceskip int, next bool) {
  0x4263f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4263f9		483b6110		CMPQ 0x10(CX), SP	
  0x4263fd		0f8697020000		JBE 0x42669a		
  0x426403		4883ec40		SUBQ $0x40, SP		
  0x426407		48896c2438		MOVQ BP, 0x38(SP)	
  0x42640c		488d6c2438		LEAQ 0x38(SP), BP	
	if trace.enabled {
  0x426411		803db8670a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x426418		0f85f8000000		JNE 0x426516			
	status := readgstatus(gp)
  0x42641e		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42641f		488b442448		MOVQ 0x48(SP), AX	
  0x426424		8b8890000000		MOVL 0x90(AX), CX	
	_g_ := getg()
  0x42642a		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x426433		488b5a30		MOVQ 0x30(DX), BX	
  0x426437		ff8308010000		INCL 0x108(BX)		
	if status&^_Gscan != _Gwaiting {
  0x42643d		0fbaf10c		BTRL $0xc, CX		
  0x426441		83f904			CMPL $0x4, CX		
  0x426444		0f85e9000000		JNE 0x426533		
	_g_ := getg()
  0x42644a		4889542430		MOVQ DX, 0x30(SP)	
	casgstatus(gp, _Gwaiting, _Grunnable)
  0x42644f		48890424		MOVQ AX, 0(SP)			
  0x426453		48b90400000001000000	MOVQ $0x100000004, CX		
  0x42645d		48894c2408		MOVQ CX, 0x8(SP)		
  0x426462		e839080000		CALL runtime.casgstatus(SB)	
	runqput(_g_.m.p.ptr(), gp, next)
  0x426467		488b442430		MOVQ 0x30(SP), AX		
  0x42646c		488b4830		MOVQ 0x30(AX), CX		
  0x426470		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x426477		90			NOPL				
  0x426478		48890c24		MOVQ CX, 0(SP)			
  0x42647c		488b4c2448		MOVQ 0x48(SP), CX		
  0x426481		48894c2408		MOVQ CX, 0x8(SP)		
  0x426486		0fb64c2458		MOVZX 0x58(SP), CX		
  0x42648b		884c2410		MOVB CL, 0x10(SP)		
  0x42648f		e8bc9f0000		CALL runtime.runqput(SB)	
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x426494		8b0556b80900		MOVL runtime.sched+80(SB), AX	
  0x42649a		85c0			TESTL AX, AX			
  0x42649c		7474			JE 0x426512			
  0x42649e		8b0d50b80900		MOVL runtime.sched+84(SB), CX	
  0x4264a4		85c9			TESTL CX, CX			
  0x4264a6		0f94c1			SETE CL				
  0x4264a9		84c9			TESTL CL, CL			
  0x4264ab		741a			JE 0x4264c7			
		wakep()
  0x4264ad		90			NOPL			
	if !atomic.Cas(&sched.nmspinning, 0, 1) {
  0x4264ae		31c0			XORL AX, AX			
  0x4264b0		488d0d3db80900		LEAQ runtime.sched+84(SB), CX	
  0x4264b7		ba01000000		MOVL $0x1, DX			
  0x4264bc		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x4264c0		0f94c1			SETE CL				
  0x4264c3		84c9			TESTL CL, CL			
  0x4264c5		7537			JNE 0x4264fe			
	_g_.m.locks--
  0x4264c7		488b442430		MOVQ 0x30(SP), AX	
  0x4264cc		488b4830		MOVQ 0x30(AX), CX	
  0x4264d0		ff8908010000		DECL 0x108(CX)		
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in Case we've cleared it in newstack
  0x4264d6		488b4830		MOVQ 0x30(AX), CX	
  0x4264da		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x4264e1		7511			JNE 0x4264f4		
  0x4264e3		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x4264ea		7408			JE 0x4264f4		
		_g_.stackguard0 = stackPreempt
  0x4264ec		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x4264f4		488b6c2438		MOVQ 0x38(SP), BP	
  0x4264f9		4883c440		ADDQ $0x40, SP		
  0x4264fd		c3			RET			
	startm(nil, true)
  0x4264fe		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x426506		c644240801		MOVB $0x1, 0x8(SP)	
  0x42650b		e8602a0000		CALL runtime.startm(SB)	
		wakep()
  0x426510		ebb5			JMP 0x4264c7		
  0x426512		31c9			XORL CX, CX		
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x426514		eb93			JMP 0x4264a9		
		traceGoUnpark(gp, traceskip)
  0x426516		488b442448		MOVQ 0x48(SP), AX		
  0x42651b		48890424		MOVQ AX, 0(SP)			
  0x42651f		488b4c2450		MOVQ 0x50(SP), CX		
  0x426524		48894c2408		MOVQ CX, 0x8(SP)		
  0x426529		e8926c0100		CALL runtime.traceGoUnpark(SB)	
  0x42652e		e9ebfeffff		JMP 0x42641e			
		dumpgstatus(gp)
  0x426533		90			NOPL			
	_g_ := getg()
  0x426534		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42653d		48894c2428		MOVQ CX, 0x28(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x426542		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x426543		8b9090000000		MOVL 0x90(AX), DX	
  0x426549		89542418		MOVL DX, 0x18(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42654d		488b9898000000		MOVQ 0x98(AX), BX		
  0x426554		48895c2420		MOVQ BX, 0x20(SP)		
  0x426559		e862d9ffff		CALL runtime.printlock(SB)	
  0x42655e		488d05329b0400		LEAQ 0x49b32(IP), AX		
  0x426565		48890424		MOVQ AX, 0(SP)			
  0x426569		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426572		e879e2ffff		CALL runtime.printstring(SB)	
  0x426577		488b442448		MOVQ 0x48(SP), AX		
  0x42657c		48890424		MOVQ AX, 0(SP)			
  0x426580		e82be2ffff		CALL runtime.printpointer(SB)	
  0x426585		488d05508d0400		LEAQ 0x48d50(IP), AX		
  0x42658c		48890424		MOVQ AX, 0(SP)			
  0x426590		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x426599		e852e2ffff		CALL runtime.printstring(SB)	
  0x42659e		488b442420		MOVQ 0x20(SP), AX		
  0x4265a3		48890424		MOVQ AX, 0(SP)			
  0x4265a7		e894e0ffff		CALL runtime.printint(SB)	
  0x4265ac		488d05ca9d0400		LEAQ 0x49dca(IP), AX		
  0x4265b3		48890424		MOVQ AX, 0(SP)			
  0x4265b7		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4265c0		e82be2ffff		CALL runtime.printstring(SB)	
  0x4265c5		8b442418		MOVL 0x18(SP), AX		
  0x4265c9		89c0			MOVL AX, AX			
  0x4265cb		48890424		MOVQ AX, 0(SP)			
  0x4265cf		e86cdfffff		CALL runtime.printuint(SB)	
  0x4265d4		e877dbffff		CALL runtime.printnl(SB)	
  0x4265d9		e862d9ffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4265de		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x4265df		488b442428		MOVQ 0x28(SP), AX	
  0x4265e4		8b8890000000		MOVL 0x90(AX), CX	
  0x4265ea		894c241c		MOVL CX, 0x1c(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4265ee		488b9098000000		MOVQ 0x98(AX), DX		
  0x4265f5		4889542420		MOVQ DX, 0x20(SP)		
  0x4265fa		e8c1d8ffff		CALL runtime.printlock(SB)	
  0x4265ff		488d05819a0400		LEAQ 0x49a81(IP), AX		
  0x426606		48890424		MOVQ AX, 0(SP)			
  0x42660a		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426613		e8d8e1ffff		CALL runtime.printstring(SB)	
  0x426618		488b442428		MOVQ 0x28(SP), AX		
  0x42661d		48890424		MOVQ AX, 0(SP)			
  0x426621		e88ae1ffff		CALL runtime.printpointer(SB)	
  0x426626		488d05af8c0400		LEAQ 0x48caf(IP), AX		
  0x42662d		48890424		MOVQ AX, 0(SP)			
  0x426631		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42663a		e8b1e1ffff		CALL runtime.printstring(SB)	
  0x42663f		488b442420		MOVQ 0x20(SP), AX		
  0x426644		48890424		MOVQ AX, 0(SP)			
  0x426648		e8f3dfffff		CALL runtime.printint(SB)	
  0x42664d		488d05169d0400		LEAQ 0x49d16(IP), AX		
  0x426654		48890424		MOVQ AX, 0(SP)			
  0x426658		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x426661		e88ae1ffff		CALL runtime.printstring(SB)	
  0x426666		8b44241c		MOVL 0x1c(SP), AX		
  0x42666a		89c0			MOVL AX, AX			
  0x42666c		48890424		MOVQ AX, 0(SP)			
  0x426670		e8cbdeffff		CALL runtime.printuint(SB)	
  0x426675		e8d6daffff		CALL runtime.printnl(SB)	
  0x42667a		e8c1d8ffff		CALL runtime.printunlock(SB)	
		throw("bad g->status in ready")
  0x42667f		488d05e7a20400		LEAQ 0x4a2e7(IP), AX	
  0x426686		48890424		MOVQ AX, 0(SP)		
  0x42668a		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x426693		e8e8cdffff		CALL runtime.throw(SB)	
  0x426698		0f0b			UD2			
func ready(gp *g, traceskip int, next bool) {
  0x42669a		e8e1110200		CALL runtime.morestack_noctxt(SB)	
  0x42669f		e94cfdffff		JMP runtime.ready(SB)			

TEXT runtime.freezetheworld(SB) /usr/local/go/src/runtime/proc.go
func freezetheworld() {
  0x4266b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4266b9		483b6110		CMPQ 0x10(CX), SP	
  0x4266bd		0f8689000000		JBE 0x42674c		
  0x4266c3		4883ec18		SUBQ $0x18, SP		
  0x4266c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4266cc		488d6c2410		LEAQ 0x10(SP), BP	
	atomic.Store(&freezing, 1)
  0x4266d1		b801000000		MOVL $0x1, AX			
  0x4266d6		488d0def650b00		LEAQ runtime.freezing(SB), CX	
  0x4266dd		8701			XCHGL AX, 0(CX)			
  0x4266df		31c0			XORL AX, AX			
	for i := 0; i < 5; i++ {
  0x4266e1		eb14			JMP 0x4266f7		
		usleep(1000)
  0x4266e3		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x4266ea		e811480200		CALL runtime.usleep(SB)	
	for i := 0; i < 5; i++ {
  0x4266ef		488b442408		MOVQ 0x8(SP), AX	
  0x4266f4		48ffc0			INCQ AX			
  0x4266f7		4883f805		CMPQ $0x5, AX		
  0x4266fb		7d28			JGE 0x426725		
  0x4266fd		4889442408		MOVQ AX, 0x8(SP)	
		sched.stopwait = freezeStopWait
  0x426702		c70590b60900ffffff7f	MOVL $0x7fffffff, runtime.sched+252(SB)	
		atomic.Store(&sched.gcwaiting, 1)
  0x42670c		b801000000		MOVL $0x1, AX			
  0x426711		488d0d80b60900		LEAQ runtime.sched+248(SB), CX	
  0x426718		8701			XCHGL AX, 0(CX)			
		if !preemptall() {
  0x42671a		e8f18d0000		CALL runtime.preemptall(SB)	
  0x42671f		803c2400		CMPB $0x0, 0(SP)		
  0x426723		75be			JNE 0x4266e3			
	usleep(1000)
  0x426725		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x42672c		e8cf470200		CALL runtime.usleep(SB)	
	preemptall()
  0x426731		e8da8d0000		CALL runtime.preemptall(SB)	
	usleep(1000)
  0x426736		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x42673d		e8be470200		CALL runtime.usleep(SB)	
}
  0x426742		488b6c2410		MOVQ 0x10(SP), BP	
  0x426747		4883c418		ADDQ $0x18, SP		
  0x42674b		c3			RET			
func freezetheworld() {
  0x42674c		e82f110200		CALL runtime.morestack_noctxt(SB)	
  0x426751		e95affffff		JMP runtime.freezetheworld(SB)		

TEXT runtime.casfrom_Gscanstatus(SB) /usr/local/go/src/runtime/proc.go
func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {
  0x426760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426769		483b6110		CMPQ 0x10(CX), SP	
  0x42676d		0f8636040000		JBE 0x426ba9		
  0x426773		4883ec40		SUBQ $0x40, SP		
  0x426777		48896c2438		MOVQ BP, 0x38(SP)	
  0x42677c		488d6c2438		LEAQ 0x38(SP), BP	
	case _Gscanrunnable,
  0x426781		8b442450		MOVL 0x50(SP), AX	
  0x426785		8d88ffefffff		LEAL 0xffffefff(AX), CX	
  0x42678b		83f903			CMPL $0x3, CX		
  0x42678e		0f8727020000		JA 0x4269bb		
		if newval == oldval&^_Gscan {
  0x426794		89c1			MOVL AX, CX		
  0x426796		0fbaf00c		BTRL $0xc, AX		
  0x42679a		8b542454		MOVL 0x54(SP), DX	
  0x42679e		39c2			CMPL AX, DX		
  0x4267a0		7522			JNE 0x4267c4		
			success = atomic.Cas(&gp.atomicstatus, oldval, newval)
  0x4267a2		89c8			MOVL CX, AX			
  0x4267a4		488b5c2448		MOVQ 0x48(SP), BX		
  0x4267a9		f00fb19390000000	LOCK CMPXCHGL DX, 0x90(BX)	
  0x4267b1		400f94c6		SETE SI				
	if !success {
  0x4267b5		4084f6			TESTL SI, SI		
  0x4267b8		7413			JE 0x4267cd		
  0x4267ba		488b6c2438		MOVQ 0x38(SP), BP	
  0x4267bf		4883c440		ADDQ $0x40, SP		
  0x4267c3		c3			RET			
		print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")
  0x4267c4		488b5c2448		MOVQ 0x48(SP), BX	
  0x4267c9		31f6			XORL SI, SI		
		if newval == oldval&^_Gscan {
  0x4267cb		ebe8			JMP 0x4267b5		
		print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")
  0x4267cd		e8eed6ffff		CALL runtime.printlock(SB)	
  0x4267d2		488d05adc00400		LEAQ 0x4c0ad(IP), AX		
  0x4267d9		48890424		MOVQ AX, 0(SP)			
  0x4267dd		48c744240827000000	MOVQ $0x27, 0x8(SP)		
  0x4267e6		e805e0ffff		CALL runtime.printstring(SB)	
  0x4267eb		488b442448		MOVQ 0x48(SP), AX		
  0x4267f0		48890424		MOVQ AX, 0(SP)			
  0x4267f4		e8b7dfffff		CALL runtime.printpointer(SB)	
  0x4267f9		488d053b8d0400		LEAQ 0x48d3b(IP), AX		
  0x426800		48890424		MOVQ AX, 0(SP)			
  0x426804		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42680d		e8dedfffff		CALL runtime.printstring(SB)	
  0x426812		8b442450		MOVL 0x50(SP), AX		
  0x426816		48890424		MOVQ AX, 0(SP)			
  0x42681a		e891deffff		CALL runtime.printhex(SB)	
  0x42681f		488d050c8d0400		LEAQ 0x48d0c(IP), AX		
  0x426826		48890424		MOVQ AX, 0(SP)			
  0x42682a		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x426833		e8b8dfffff		CALL runtime.printstring(SB)	
  0x426838		8b442454		MOVL 0x54(SP), AX		
  0x42683c		48890424		MOVQ AX, 0(SP)			
  0x426840		e86bdeffff		CALL runtime.printhex(SB)	
  0x426845		e806d9ffff		CALL runtime.printnl(SB)	
  0x42684a		e8f1d6ffff		CALL runtime.printunlock(SB)	
		dumpgstatus(gp)
  0x42684f		90			NOPL			
	_g_ := getg()
  0x426850		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x426859		4889442428		MOVQ AX, 0x28(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42685e		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42685f		488b4c2448		MOVQ 0x48(SP), CX	
  0x426864		8b9190000000		MOVL 0x90(CX), DX	
  0x42686a		8954241c		MOVL DX, 0x1c(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42686e		488b9998000000		MOVQ 0x98(CX), BX		
  0x426875		48895c2420		MOVQ BX, 0x20(SP)		
  0x42687a		e841d6ffff		CALL runtime.printlock(SB)	
  0x42687f		488d0511980400		LEAQ 0x49811(IP), AX		
  0x426886		48890424		MOVQ AX, 0(SP)			
  0x42688a		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426893		e858dfffff		CALL runtime.printstring(SB)	
  0x426898		488b442448		MOVQ 0x48(SP), AX		
  0x42689d		48890424		MOVQ AX, 0(SP)			
  0x4268a1		e80adfffff		CALL runtime.printpointer(SB)	
  0x4268a6		488d052f8a0400		LEAQ 0x48a2f(IP), AX		
  0x4268ad		48890424		MOVQ AX, 0(SP)			
  0x4268b1		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4268ba		e831dfffff		CALL runtime.printstring(SB)	
  0x4268bf		488b442420		MOVQ 0x20(SP), AX		
  0x4268c4		48890424		MOVQ AX, 0(SP)			
  0x4268c8		e873ddffff		CALL runtime.printint(SB)	
  0x4268cd		488d05a99a0400		LEAQ 0x49aa9(IP), AX		
  0x4268d4		48890424		MOVQ AX, 0(SP)			
  0x4268d8		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4268e1		e80adfffff		CALL runtime.printstring(SB)	
  0x4268e6		8b44241c		MOVL 0x1c(SP), AX		
  0x4268ea		89c0			MOVL AX, AX			
  0x4268ec		48890424		MOVQ AX, 0(SP)			
  0x4268f0		e84bdcffff		CALL runtime.printuint(SB)	
  0x4268f5		e856d8ffff		CALL runtime.printnl(SB)	
  0x4268fa		e841d6ffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x4268ff		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x426900		488b442428		MOVQ 0x28(SP), AX	
  0x426905		8b8890000000		MOVL 0x90(AX), CX	
  0x42690b		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x42690f		488b9098000000		MOVQ 0x98(AX), DX		
  0x426916		4889542420		MOVQ DX, 0x20(SP)		
  0x42691b		e8a0d5ffff		CALL runtime.printlock(SB)	
  0x426920		488d0560970400		LEAQ 0x49760(IP), AX		
  0x426927		48890424		MOVQ AX, 0(SP)			
  0x42692b		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426934		e8b7deffff		CALL runtime.printstring(SB)	
  0x426939		488b442428		MOVQ 0x28(SP), AX		
  0x42693e		48890424		MOVQ AX, 0(SP)			
  0x426942		e869deffff		CALL runtime.printpointer(SB)	
  0x426947		488d058e890400		LEAQ 0x4898e(IP), AX		
  0x42694e		48890424		MOVQ AX, 0(SP)			
  0x426952		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42695b		e890deffff		CALL runtime.printstring(SB)	
  0x426960		488b442420		MOVQ 0x20(SP), AX		
  0x426965		48890424		MOVQ AX, 0(SP)			
  0x426969		e8d2dcffff		CALL runtime.printint(SB)	
  0x42696e		488d05f5990400		LEAQ 0x499f5(IP), AX		
  0x426975		48890424		MOVQ AX, 0(SP)			
  0x426979		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x426982		e869deffff		CALL runtime.printstring(SB)	
  0x426987		8b442414		MOVL 0x14(SP), AX		
  0x42698b		89c0			MOVL AX, AX			
  0x42698d		48890424		MOVQ AX, 0(SP)			
  0x426991		e8aadbffff		CALL runtime.printuint(SB)	
  0x426996		e8b5d7ffff		CALL runtime.printnl(SB)	
  0x42699b		e8a0d5ffff		CALL runtime.printunlock(SB)	
		throw("casfrom_Gscanstatus: gp->status is not in scan state")
  0x4269a0		488d05c5c80400		LEAQ 0x4c8c5(IP), AX	
  0x4269a7		48890424		MOVQ AX, 0(SP)		
  0x4269ab		48c744240834000000	MOVQ $0x34, 0x8(SP)	
  0x4269b4		e8c7caffff		CALL runtime.throw(SB)	
  0x4269b9		0f0b			UD2			
		print("runtime: casfrom_Gscanstatus bad oldval gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")
  0x4269bb		e800d5ffff		CALL runtime.printlock(SB)	
  0x4269c0		488d0564c30400		LEAQ 0x4c364(IP), AX		
  0x4269c7		48890424		MOVQ AX, 0(SP)			
  0x4269cb		48c74424082b000000	MOVQ $0x2b, 0x8(SP)		
  0x4269d4		e817deffff		CALL runtime.printstring(SB)	
  0x4269d9		488b442448		MOVQ 0x48(SP), AX		
  0x4269de		48890424		MOVQ AX, 0(SP)			
  0x4269e2		e8c9ddffff		CALL runtime.printpointer(SB)	
  0x4269e7		488d054d8b0400		LEAQ 0x48b4d(IP), AX		
  0x4269ee		48890424		MOVQ AX, 0(SP)			
  0x4269f2		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4269fb		e8f0ddffff		CALL runtime.printstring(SB)	
  0x426a00		8b442450		MOVL 0x50(SP), AX		
  0x426a04		48890424		MOVQ AX, 0(SP)			
  0x426a08		e8a3dcffff		CALL runtime.printhex(SB)	
  0x426a0d		488d051e8b0400		LEAQ 0x48b1e(IP), AX		
  0x426a14		48890424		MOVQ AX, 0(SP)			
  0x426a18		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x426a21		e8caddffff		CALL runtime.printstring(SB)	
  0x426a26		8b442454		MOVL 0x54(SP), AX		
  0x426a2a		48890424		MOVQ AX, 0(SP)			
  0x426a2e		e87ddcffff		CALL runtime.printhex(SB)	
  0x426a33		e818d7ffff		CALL runtime.printnl(SB)	
  0x426a38		e803d5ffff		CALL runtime.printunlock(SB)	
		dumpgstatus(gp)
  0x426a3d		90			NOPL			
	_g_ := getg()
  0x426a3e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x426a47		4889442430		MOVQ AX, 0x30(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x426a4c		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x426a4d		488b4c2448		MOVQ 0x48(SP), CX	
  0x426a52		8b9190000000		MOVL 0x90(CX), DX	
  0x426a58		89542418		MOVL DX, 0x18(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x426a5c		488b9998000000		MOVQ 0x98(CX), BX		
  0x426a63		48895c2420		MOVQ BX, 0x20(SP)		
  0x426a68		e853d4ffff		CALL runtime.printlock(SB)	
  0x426a6d		488d0523960400		LEAQ 0x49623(IP), AX		
  0x426a74		48890424		MOVQ AX, 0(SP)			
  0x426a78		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426a81		e86addffff		CALL runtime.printstring(SB)	
  0x426a86		488b442448		MOVQ 0x48(SP), AX		
  0x426a8b		48890424		MOVQ AX, 0(SP)			
  0x426a8f		e81cddffff		CALL runtime.printpointer(SB)	
  0x426a94		488d0541880400		LEAQ 0x48841(IP), AX		
  0x426a9b		48890424		MOVQ AX, 0(SP)			
  0x426a9f		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x426aa8		e843ddffff		CALL runtime.printstring(SB)	
  0x426aad		488b442420		MOVQ 0x20(SP), AX		
  0x426ab2		48890424		MOVQ AX, 0(SP)			
  0x426ab6		e885dbffff		CALL runtime.printint(SB)	
  0x426abb		488d05bb980400		LEAQ 0x498bb(IP), AX		
  0x426ac2		48890424		MOVQ AX, 0(SP)			
  0x426ac6		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x426acf		e81cddffff		CALL runtime.printstring(SB)	
  0x426ad4		8b442418		MOVL 0x18(SP), AX		
  0x426ad8		89c0			MOVL AX, AX			
  0x426ada		48890424		MOVQ AX, 0(SP)			
  0x426ade		e85ddaffff		CALL runtime.printuint(SB)	
  0x426ae3		e868d6ffff		CALL runtime.printnl(SB)	
  0x426ae8		e853d4ffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x426aed		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x426aee		488b442430		MOVQ 0x30(SP), AX	
  0x426af3		8b8890000000		MOVL 0x90(AX), CX	
  0x426af9		894c2410		MOVL CX, 0x10(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x426afd		488b9098000000		MOVQ 0x98(AX), DX		
  0x426b04		4889542420		MOVQ DX, 0x20(SP)		
  0x426b09		e8b2d3ffff		CALL runtime.printlock(SB)	
  0x426b0e		488d0572950400		LEAQ 0x49572(IP), AX		
  0x426b15		48890424		MOVQ AX, 0(SP)			
  0x426b19		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x426b22		e8c9dcffff		CALL runtime.printstring(SB)	
  0x426b27		488b442430		MOVQ 0x30(SP), AX		
  0x426b2c		48890424		MOVQ AX, 0(SP)			
  0x426b30		e87bdcffff		CALL runtime.printpointer(SB)	
  0x426b35		488d05a0870400		LEAQ 0x487a0(IP), AX		
  0x426b3c		48890424		MOVQ AX, 0(SP)			
  0x426b40		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x426b49		e8a2dcffff		CALL runtime.printstring(SB)	
  0x426b4e		488b442420		MOVQ 0x20(SP), AX		
  0x426b53		48890424		MOVQ AX, 0(SP)			
  0x426b57		e8e4daffff		CALL runtime.printint(SB)	
  0x426b5c		488d0507980400		LEAQ 0x49807(IP), AX		
  0x426b63		48890424		MOVQ AX, 0(SP)			
  0x426b67		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x426b70		e87bdcffff		CALL runtime.printstring(SB)	
  0x426b75		8b442410		MOVL 0x10(SP), AX		
  0x426b79		89c0			MOVL AX, AX			
  0x426b7b		48890424		MOVQ AX, 0(SP)			
  0x426b7f		e8bcd9ffff		CALL runtime.printuint(SB)	
  0x426b84		e8c7d5ffff		CALL runtime.printnl(SB)	
  0x426b89		e8b2d3ffff		CALL runtime.printunlock(SB)	
		throw("casfrom_Gscanstatus:top gp->status is not in scan state")
  0x426b8e		488d0516c80400		LEAQ 0x4c816(IP), AX	
  0x426b95		48890424		MOVQ AX, 0(SP)		
  0x426b99		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x426ba2		e8d9c8ffff		CALL runtime.throw(SB)	
  0x426ba7		0f0b			UD2			
func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {
  0x426ba9		e8d20c0200		CALL runtime.morestack_noctxt(SB)	
  0x426bae		e9adfbffff		JMP runtime.casfrom_Gscanstatus(SB)	

TEXT runtime.castogscanstatus(SB) /usr/local/go/src/runtime/proc.go
func castogscanstatus(gp *g, oldval, newval uint32) bool {
  0x426bc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426bc9		483b6110		CMPQ 0x10(CX), SP	
  0x426bcd		0f86be000000		JBE 0x426c91		
  0x426bd3		4883ec18		SUBQ $0x18, SP		
  0x426bd7		48896c2410		MOVQ BP, 0x10(SP)	
  0x426bdc		488d6c2410		LEAQ 0x10(SP), BP	
	case _Grunnable,
  0x426be1		8b442428		MOVL 0x28(SP), AX	
  0x426be5		8d48ff			LEAL -0x1(AX), CX	
  0x426be8		83f903			CMPL $0x3, CX		
  0x426beb		772e			JA 0x426c1b		
		if newval == oldval|_Gscan {
  0x426bed		89c1			MOVL AX, CX		
  0x426bef		0fbae80c		BTSL $0xc, AX		
  0x426bf3		8b54242c		MOVL 0x2c(SP), DX	
  0x426bf7		39c2			CMPL AX, DX		
  0x426bf9		7520			JNE 0x426c1b		
			return atomic.Cas(&gp.atomicstatus, oldval, newval)
  0x426bfb		89c8			MOVL CX, AX			
  0x426bfd		488b5c2420		MOVQ 0x20(SP), BX		
  0x426c02		f00fb19390000000	LOCK CMPXCHGL DX, 0x90(BX)	
  0x426c0a		0f94c1			SETE CL				
  0x426c0d		884c2430		MOVB CL, 0x30(SP)		
  0x426c11		488b6c2410		MOVQ 0x10(SP), BP		
  0x426c16		4883c418		ADDQ $0x18, SP			
  0x426c1a		c3			RET				
	print("runtime: castogscanstatus oldval=", hex(oldval), " newval=", hex(newval), "\n")
  0x426c1b		e8a0d2ffff		CALL runtime.printlock(SB)	
  0x426c20		488d0574b50400		LEAQ 0x4b574(IP), AX		
  0x426c27		48890424		MOVQ AX, 0(SP)			
  0x426c2b		48c744240821000000	MOVQ $0x21, 0x8(SP)		
  0x426c34		e8b7dbffff		CALL runtime.printstring(SB)	
  0x426c39		8b442428		MOVL 0x28(SP), AX		
  0x426c3d		48890424		MOVQ AX, 0(SP)			
  0x426c41		e86adaffff		CALL runtime.printhex(SB)	
  0x426c46		488d05bb870400		LEAQ 0x487bb(IP), AX		
  0x426c4d		48890424		MOVQ AX, 0(SP)			
  0x426c51		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x426c5a		e891dbffff		CALL runtime.printstring(SB)	
  0x426c5f		8b44242c		MOVL 0x2c(SP), AX		
  0x426c63		48890424		MOVQ AX, 0(SP)			
  0x426c67		e844daffff		CALL runtime.printhex(SB)	
  0x426c6c		e8dfd4ffff		CALL runtime.printnl(SB)	
  0x426c71		e8cad2ffff		CALL runtime.printunlock(SB)	
	throw("castogscanstatus")
  0x426c76		488d055a930400		LEAQ 0x4935a(IP), AX	
  0x426c7d		48890424		MOVQ AX, 0(SP)		
  0x426c81		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x426c8a		e8f1c7ffff		CALL runtime.throw(SB)	
  0x426c8f		0f0b			UD2			
func castogscanstatus(gp *g, oldval, newval uint32) bool {
  0x426c91		e8ea0b0200		CALL runtime.morestack_noctxt(SB)	
  0x426c96		e925ffffff		JMP runtime.castogscanstatus(SB)	

TEXT runtime.casgstatus(SB) /usr/local/go/src/runtime/proc.go
func casgstatus(gp *g, oldval, newval uint32) {
  0x426ca0		4883ec58		SUBQ $0x58, SP		
  0x426ca4		48896c2450		MOVQ BP, 0x50(SP)	
  0x426ca9		488d6c2450		LEAQ 0x50(SP), BP	
	if (oldval&_Gscan != 0) || (newval&_Gscan != 0) || oldval == newval {
  0x426cae		8b442468		MOVL 0x68(SP), AX	
  0x426cb2		0fbae00c		BTL $0xc, AX		
  0x426cb6		0f83a0010000		JAE 0x426e5c		
		systemstack(func() {
  0x426cbc		0f57c0			XORPS X0, X0				
  0x426cbf		0f11442428		MOVUPS X0, 0x28(SP)			
  0x426cc4		488d0d55fa0100		LEAQ runtime.casgstatus.func1(SB), CX	
  0x426ccb		48894c2428		MOVQ CX, 0x28(SP)			
  0x426cd0		89442430		MOVL AX, 0x30(SP)			
  0x426cd4		8b4c246c		MOVL 0x6c(SP), CX			
  0x426cd8		894c2434		MOVL CX, 0x34(SP)			
  0x426cdc		488d542428		LEAQ 0x28(SP), DX			
  0x426ce1		48891424		MOVQ DX, 0(SP)				
  0x426ce5		e8460a0200		CALL runtime.systemstack(SB)		
	if oldval == _Grunning && gp.gcscanvalid {
  0x426cea		8b442468		MOVL 0x68(SP), AX	
  0x426cee		83f802			CMPL $0x2, AX		
  0x426cf1		0f855b010000		JNE 0x426e52		
  0x426cf7		488b4c2460		MOVQ 0x60(SP), CX	
  0x426cfc		80b9b500000000		CMPB $0x0, 0xb5(CX)	
  0x426d03		0f85ff000000		JNE 0x426e08		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426d09		8b54246c		MOVL 0x6c(SP), DX	
  0x426d0d		31db			XORL BX, BX		
  0x426d0f		31f6			XORL SI, SI		
  0x426d11		eb58			JMP 0x426d6b		
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x426d13		48895c2410		MOVQ BX, 0x10(SP)	
				procyield(1)
  0x426d18		c7042401000000		MOVL $0x1, 0(SP)		
  0x426d1f		e85c210200		CALL runtime.procyield(SB)	
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x426d24		488b442410		MOVQ 0x10(SP), AX	
  0x426d29		488d5801		LEAQ 0x1(AX), BX	
  0x426d2d		8b442468		MOVL 0x68(SP), AX	
  0x426d31		488b4c2460		MOVQ 0x60(SP), CX	
		if nanotime() < nextYield {
  0x426d36		488b442418		MOVQ 0x18(SP), AX	
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x426d3b		8b4c2468		MOVL 0x68(SP), CX	
  0x426d3f		488b542460		MOVQ 0x60(SP), DX	
  0x426d44		4883fb0a		CMPQ $0xa, BX		
  0x426d48		7d08			JGE 0x426d52		
  0x426d4a		398a90000000		CMPL CX, 0x90(DX)	
  0x426d50		75c1			JNE 0x426d13		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426d52		488b7c2420		MOVQ 0x20(SP), DI	
  0x426d57		488d5f01		LEAQ 0x1(DI), BX	
  0x426d5b		8b7c246c		MOVL 0x6c(SP), DI	
  0x426d5f		4889d1			MOVQ DX, CX		
  0x426d62		89fa			MOVL DI, DX		
		if nanotime() < nextYield {
  0x426d64		4889c6			MOVQ AX, SI		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426d67		8b442468		MOVL 0x68(SP), AX		
  0x426d6b		f00fb19190000000	LOCK CMPXCHGL DX, 0x90(CX)	
  0x426d73		400f94c7		SETE DI				
  0x426d77		4084ff			TESTL DI, DI			
  0x426d7a		7576			JNE 0x426df2			
		if oldval == _Gwaiting && gp.atomicstatus == _Grunnable {
  0x426d7c		8b442468		MOVL 0x68(SP), AX	
  0x426d80		83f804			CMPL $0x4, AX		
  0x426d83		750d			JNE 0x426d92		
  0x426d85		83b99000000001		CMPL $0x1, 0x90(CX)	
  0x426d8c		0f84e5000000		JE 0x426e77		
		if i == 0 {
  0x426d92		48895c2420		MOVQ BX, 0x20(SP)	
  0x426d97		4885db			TESTQ BX, BX		
  0x426d9a		7444			JE 0x426de0		
		if nanotime() < nextYield {
  0x426d9c		4889742418		MOVQ SI, 0x18(SP)		
  0x426da1		e80a430200		CALL runtime.nanotime(SB)	
  0x426da6		488b442418		MOVQ 0x18(SP), AX		
  0x426dab		48390424		CMPQ AX, 0(SP)			
  0x426daf		7d0d			JGE 0x426dbe			
			for x := 0; x < 10 && gp.atomicstatus != oldval; x++ {
  0x426db1		8b4c2468		MOVL 0x68(SP), CX	
  0x426db5		488b542460		MOVQ 0x60(SP), DX	
  0x426dba		31db			XORL BX, BX		
  0x426dbc		eb86			JMP 0x426d44		
			osyield()
  0x426dbe		e82d480200		CALL runtime.osyield(SB)	
			nextYield = nanotime() + yieldDelay/2
  0x426dc3		e8e8420200		CALL runtime.nanotime(SB)	
  0x426dc8		488b0424		MOVQ 0(SP), AX			
  0x426dcc		4805c4090000		ADDQ $0x9c4, AX			
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426dd2		8b4c2468		MOVL 0x68(SP), CX	
  0x426dd6		488b542460		MOVQ 0x60(SP), DX	
			nextYield = nanotime() + yieldDelay/2
  0x426ddb		e972ffffff		JMP 0x426d52		
			nextYield = nanotime() + yieldDelay
  0x426de0		e8cb420200		CALL runtime.nanotime(SB)	
  0x426de5		488b0424		MOVQ 0(SP), AX			
  0x426de9		488db088130000		LEAQ 0x1388(AX), SI		
  0x426df0		ebaa			JMP 0x426d9c			
	if newval == _Grunning {
  0x426df2		83fa02			CMPL $0x2, DX		
  0x426df5		7507			JNE 0x426dfe		
		gp.gcscanvalid = false
  0x426df7		c681b500000000		MOVB $0x0, 0xb5(CX)	
  0x426dfe		488b6c2450		MOVQ 0x50(SP), BP	
  0x426e03		4883c458		ADDQ $0x58, SP		
  0x426e07		c3			RET			
		systemstack(func() {
  0x426e08		48c744243800000000	MOVQ $0x0, 0x38(SP)			
  0x426e11		0f57c0			XORPS X0, X0				
  0x426e14		0f11442440		MOVUPS X0, 0x40(SP)			
  0x426e19		488d15c0f90100		LEAQ runtime.casgstatus.func2(SB), DX	
  0x426e20		4889542438		MOVQ DX, 0x38(SP)			
  0x426e25		89442440		MOVL AX, 0x40(SP)			
  0x426e29		8b54246c		MOVL 0x6c(SP), DX			
  0x426e2d		89542444		MOVL DX, 0x44(SP)			
  0x426e31		48894c2448		MOVQ CX, 0x48(SP)			
  0x426e36		488d5c2438		LEAQ 0x38(SP), BX			
  0x426e3b		48891c24		MOVQ BX, 0(SP)				
  0x426e3f		e8ec080200		CALL runtime.systemstack(SB)		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426e44		8b442468		MOVL 0x68(SP), AX	
  0x426e48		488b4c2460		MOVQ 0x60(SP), CX	
		systemstack(func() {
  0x426e4d		e9b7feffff		JMP 0x426d09		
	for i := 0; !atomic.Cas(&gp.atomicstatus, oldval, newval); i++ {
  0x426e52		488b4c2460		MOVQ 0x60(SP), CX	
	if oldval == _Grunning && gp.gcscanvalid {
  0x426e57		e9adfeffff		JMP 0x426d09		
	if (oldval&_Gscan != 0) || (newval&_Gscan != 0) || oldval == newval {
  0x426e5c		8b4c246c		MOVL 0x6c(SP), CX	
  0x426e60		0fbae10c		BTL $0xc, CX		
  0x426e64		0f8252feffff		JB 0x426cbc		
  0x426e6a		39c1			CMPL AX, CX		
  0x426e6c		0f844afeffff		JE 0x426cbc		
  0x426e72		e973feffff		JMP 0x426cea		
			throw("casgstatus: waiting for Gwaiting but is Grunnable")
  0x426e77		488d0561c20400		LEAQ 0x4c261(IP), AX	
  0x426e7e		48890424		MOVQ AX, 0(SP)		
  0x426e82		48c744240831000000	MOVQ $0x31, 0x8(SP)	
  0x426e8b		e8f0c5ffff		CALL runtime.throw(SB)	
  0x426e90		0f0b			UD2			

TEXT runtime.scang(SB) /usr/local/go/src/runtime/proc.go
func scang(gp *g, gcw *gcWork) {
  0x426ea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x426ea9		483b6110		CMPQ 0x10(CX), SP	
  0x426ead		0f866b030000		JBE 0x42721e		
  0x426eb3		4883ec48		SUBQ $0x48, SP		
  0x426eb7		48896c2440		MOVQ BP, 0x40(SP)	
  0x426ebc		488d6c2440		LEAQ 0x40(SP), BP	
	gp.gcscandone = false
  0x426ec1		488b442450		MOVQ 0x50(SP), AX	
  0x426ec6		c680b400000000		MOVB $0x0, 0xb4(AX)	
  0x426ecd		31c9			XORL CX, CX		
  0x426ecf		31d2			XORL DX, DX		
	for i := 0; !gp.gcscandone; i++ {
  0x426ed1		eb14			JMP 0x426ee7		
  0x426ed3		488b5c2428		MOVQ 0x28(SP), BX	
  0x426ed8		488d4b01		LEAQ 0x1(BX), CX	
  0x426edc		488b5c2450		MOVQ 0x50(SP), BX	
		if nanotime() < nextYield {
  0x426ee1		4889c2			MOVQ AX, DX		
	for i := 0; !gp.gcscandone; i++ {
  0x426ee4		4889d8			MOVQ BX, AX		
  0x426ee7		80b8b400000000		CMPB $0x0, 0xb4(AX)	
  0x426eee		0f8567010000		JNE 0x42705b		
		if i == 0 {
  0x426ef4		48894c2428		MOVQ CX, 0x28(SP)	
		switch s := readgstatus(gp); s {
  0x426ef9		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x426efa		8b9890000000		MOVL 0x90(AX), BX	
		switch s := readgstatus(gp); s {
  0x426f00		83fb04			CMPL $0x4, BX		
  0x426f03		0f8789010000		JA 0x427092		
		if nanotime() < nextYield {
  0x426f09		4889542420		MOVQ DX, 0x20(SP)	
		case _Grunnable, _Gsyscall, _Gwaiting:
  0x426f0e		83fb01			CMPL $0x1, BX		
  0x426f11		0f84fd000000		JE 0x427014		
		case _Grunning:
  0x426f17		83fb02			CMPL $0x2, BX		
  0x426f1a		0f85e8000000		JNE 0x427008		
			if gp.preemptscan && gp.preempt && gp.stackguard0 == stackPreempt {
  0x426f20		80b8b300000000		CMPB $0x0, 0xb3(AX)	
  0x426f27		746e			JE 0x426f97		
  0x426f29		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x426f30		7465			JE 0x426f97		
  0x426f32		48817810defaffff	CMPQ $-0x522, 0x10(AX)	
  0x426f3a		755b			JNE 0x426f97		
		if i == 0 {
  0x426f3c		4885c9			TESTQ CX, CX		
  0x426f3f		7444			JE 0x426f85		
		if nanotime() < nextYield {
  0x426f41		4889542430		MOVQ DX, 0x30(SP)		
  0x426f46		e865410200		CALL runtime.nanotime(SB)	
  0x426f4b		488b442430		MOVQ 0x30(SP), AX		
  0x426f50		48390424		CMPQ AX, 0(SP)			
  0x426f54		7d16			JGE 0x426f6c			
			procyield(10)
  0x426f56		c704240a000000		MOVL $0xa, 0(SP)		
  0x426f5d		e81e1f0200		CALL runtime.procyield(SB)	
		if nanotime() < nextYield {
  0x426f62		488b442430		MOVQ 0x30(SP), AX	
			procyield(10)
  0x426f67		e967ffffff		JMP 0x426ed3		
			osyield()
  0x426f6c		e87f460200		CALL runtime.osyield(SB)	
			nextYield = nanotime() + yieldDelay/2
  0x426f71		e83a410200		CALL runtime.nanotime(SB)	
  0x426f76		488b0424		MOVQ 0(SP), AX			
  0x426f7a		480588130000		ADDQ $0x1388, AX		
  0x426f80		e94effffff		JMP 0x426ed3			
			nextYield = nanotime() + yieldDelay
  0x426f85		e826410200		CALL runtime.nanotime(SB)	
  0x426f8a		488b0424		MOVQ 0(SP), AX			
  0x426f8e		488d9010270000		LEAQ 0x2710(AX), DX		
  0x426f95		ebaa			JMP 0x426f41			
			if castogscanstatus(gp, _Grunning, _Gscanrunning) {
  0x426f97		48890424		MOVQ AX, 0(SP)				
  0x426f9b		48b90200000002100000	MOVQ $0x100200000002, CX		
  0x426fa5		48894c2408		MOVQ CX, 0x8(SP)			
  0x426faa		e811fcffff		CALL runtime.castogscanstatus(SB)	
  0x426faf		807c241000		CMPB $0x0, 0x10(SP)			
  0x426fb4		7426			JE 0x426fdc				
				if !gp.gcscandone {
  0x426fb6		488b442450		MOVQ 0x50(SP), AX	
  0x426fbb		80b8b400000000		CMPB $0x0, 0xb4(AX)	
  0x426fc2		742c			JE 0x426ff0		
				casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)
  0x426fc4		48890424		MOVQ AX, 0(SP)				
  0x426fc8		48b90210000002000000	MOVQ $0x200001002, CX			
  0x426fd2		48894c2408		MOVQ CX, 0x8(SP)			
  0x426fd7		e884f7ffff		CALL runtime.casfrom_Gscanstatus(SB)	
	for i := 0; !gp.gcscandone; i++ {
  0x426fdc		488b442450		MOVQ 0x50(SP), AX	
		if i == 0 {
  0x426fe1		488b4c2428		MOVQ 0x28(SP), CX	
		if nanotime() < nextYield {
  0x426fe6		488b542420		MOVQ 0x20(SP), DX	
		switch s := readgstatus(gp); s {
  0x426feb		e94cffffff		JMP 0x426f3c		
					gp.preemptscan = true
  0x426ff0		c680b300000001		MOVB $0x1, 0xb3(AX)	
					gp.preempt = true
  0x426ff7		c680b100000001		MOVB $0x1, 0xb1(AX)	
					gp.stackguard0 = stackPreempt
  0x426ffe		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x427006		ebbc			JMP 0x426fc4		
		case _Grunnable, _Gsyscall, _Gwaiting:
  0x427008		8d73fd			LEAL -0x3(BX), SI	
  0x42700b		83fe01			CMPL $0x1, SI		
  0x42700e		0f87a3000000		JA 0x4270b7		
			if castogscanstatus(gp, s, s|_Gscan) {
  0x427014		48890424		MOVQ AX, 0(SP)				
  0x427018		895c2408		MOVL BX, 0x8(SP)			
  0x42701c		0fbaeb0c		BTSL $0xc, BX				
  0x427020		895c240c		MOVL BX, 0xc(SP)			
  0x427024		e897fbffff		CALL runtime.castogscanstatus(SB)	
  0x427029		807c241000		CMPB $0x0, 0x10(SP)			
  0x42702e		7514			JNE 0x427044				
	for i := 0; !gp.gcscandone; i++ {
  0x427030		488b442450		MOVQ 0x50(SP), AX	
		if i == 0 {
  0x427035		488b4c2428		MOVQ 0x28(SP), CX	
		if nanotime() < nextYield {
  0x42703a		488b542420		MOVQ 0x20(SP), DX	
		switch s := readgstatus(gp); s {
  0x42703f		e9f8feffff		JMP 0x426f3c		
				if !gp.gcscandone {
  0x427044		488b442450		MOVQ 0x50(SP), AX	
  0x427049		80b8b400000000		CMPB $0x0, 0xb4(AX)	
  0x427050		741f			JE 0x427071		
				restartg(gp)
  0x427052		48890424		MOVQ AX, 0(SP)			
  0x427056		e8d5010000		CALL runtime.restartg(SB)	
	gp.preemptscan = false // cancel scan request if no longer needed
  0x42705b		488b442450		MOVQ 0x50(SP), AX	
  0x427060		c680b300000000		MOVB $0x0, 0xb3(AX)	
}
  0x427067		488b6c2440		MOVQ 0x40(SP), BP	
  0x42706c		4883c448		ADDQ $0x48, SP		
  0x427070		c3			RET			
					scanstack(gp, gcw)
  0x427071		48890424		MOVQ AX, 0(SP)			
  0x427075		488b4c2458		MOVQ 0x58(SP), CX		
  0x42707a		48894c2408		MOVQ CX, 0x8(SP)		
  0x42707f		e85c07ffff		CALL runtime.scanstack(SB)	
					gp.gcscandone = true
  0x427084		488b442450		MOVQ 0x50(SP), AX	
  0x427089		c680b400000001		MOVB $0x1, 0xb4(AX)	
  0x427090		ebc0			JMP 0x427052		
		case _Gdead:
  0x427092		83fb06			CMPL $0x6, BX		
  0x427095		7417			JE 0x4270ae		
		case _Gcopystack:
  0x427097		83fb08			CMPL $0x8, BX		
  0x42709a		0f849cfeffff		JE 0x426f3c		
		case _Gscanwaiting:
  0x4270a0		81fb04100000		CMPL $0x1004, BX	
  0x4270a6		0f8490feffff		JE 0x426f3c		
  0x4270ac		eb09			JMP 0x4270b7		
			gp.gcscandone = true
  0x4270ae		c680b400000001		MOVB $0x1, 0xb4(AX)	
			break loop
  0x4270b5		eba4			JMP 0x42705b		
			dumpgstatus(gp)
  0x4270b7		90			NOPL			
	_g_ := getg()
  0x4270b8		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4270c1		48894c2438		MOVQ CX, 0x38(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4270c6		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x4270c7		8b9090000000		MOVL 0x90(AX), DX	
  0x4270cd		8954241c		MOVL DX, 0x1c(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4270d1		488b9898000000		MOVQ 0x98(AX), BX		
  0x4270d8		48895c2430		MOVQ BX, 0x30(SP)		
  0x4270dd		e8decdffff		CALL runtime.printlock(SB)	
  0x4270e2		488d05ae8f0400		LEAQ 0x48fae(IP), AX		
  0x4270e9		48890424		MOVQ AX, 0(SP)			
  0x4270ed		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4270f6		e8f5d6ffff		CALL runtime.printstring(SB)	
  0x4270fb		488b442450		MOVQ 0x50(SP), AX		
  0x427100		48890424		MOVQ AX, 0(SP)			
  0x427104		e8a7d6ffff		CALL runtime.printpointer(SB)	
  0x427109		488d05cc810400		LEAQ 0x481cc(IP), AX		
  0x427110		48890424		MOVQ AX, 0(SP)			
  0x427114		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42711d		e8ced6ffff		CALL runtime.printstring(SB)	
  0x427122		488b442430		MOVQ 0x30(SP), AX		
  0x427127		48890424		MOVQ AX, 0(SP)			
  0x42712b		e810d5ffff		CALL runtime.printint(SB)	
  0x427130		488d0546920400		LEAQ 0x49246(IP), AX		
  0x427137		48890424		MOVQ AX, 0(SP)			
  0x42713b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x427144		e8a7d6ffff		CALL runtime.printstring(SB)	
  0x427149		8b44241c		MOVL 0x1c(SP), AX		
  0x42714d		89c0			MOVL AX, AX			
  0x42714f		48890424		MOVQ AX, 0(SP)			
  0x427153		e8e8d3ffff		CALL runtime.printuint(SB)	
  0x427158		e8f3cfffff		CALL runtime.printnl(SB)	
  0x42715d		e8decdffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x427162		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x427163		488b442438		MOVQ 0x38(SP), AX	
  0x427168		8b8890000000		MOVL 0x90(AX), CX	
  0x42716e		894c2418		MOVL CX, 0x18(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x427172		488b9098000000		MOVQ 0x98(AX), DX		
  0x427179		4889542430		MOVQ DX, 0x30(SP)		
  0x42717e		e83dcdffff		CALL runtime.printlock(SB)	
  0x427183		488d05fd8e0400		LEAQ 0x48efd(IP), AX		
  0x42718a		48890424		MOVQ AX, 0(SP)			
  0x42718e		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x427197		e854d6ffff		CALL runtime.printstring(SB)	
  0x42719c		488b442438		MOVQ 0x38(SP), AX		
  0x4271a1		48890424		MOVQ AX, 0(SP)			
  0x4271a5		e806d6ffff		CALL runtime.printpointer(SB)	
  0x4271aa		488d052b810400		LEAQ 0x4812b(IP), AX		
  0x4271b1		48890424		MOVQ AX, 0(SP)			
  0x4271b5		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4271be		e82dd6ffff		CALL runtime.printstring(SB)	
  0x4271c3		488b442430		MOVQ 0x30(SP), AX		
  0x4271c8		48890424		MOVQ AX, 0(SP)			
  0x4271cc		e86fd4ffff		CALL runtime.printint(SB)	
  0x4271d1		488d0592910400		LEAQ 0x49192(IP), AX		
  0x4271d8		48890424		MOVQ AX, 0(SP)			
  0x4271dc		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4271e5		e806d6ffff		CALL runtime.printstring(SB)	
  0x4271ea		8b442418		MOVL 0x18(SP), AX		
  0x4271ee		89c0			MOVL AX, AX			
  0x4271f0		48890424		MOVQ AX, 0(SP)			
  0x4271f4		e847d3ffff		CALL runtime.printuint(SB)	
  0x4271f9		e852cfffff		CALL runtime.printnl(SB)	
  0x4271fe		e83dcdffff		CALL runtime.printunlock(SB)	
			throw("stopg: invalid status")
  0x427203		488d05f6960400		LEAQ 0x496f6(IP), AX	
  0x42720a		48890424		MOVQ AX, 0(SP)		
  0x42720e		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x427217		e864c2ffff		CALL runtime.throw(SB)	
  0x42721c		0f0b			UD2			
func scang(gp *g, gcw *gcWork) {
  0x42721e		e85d060200		CALL runtime.morestack_noctxt(SB)	
  0x427223		e978fcffff		JMP runtime.scang(SB)			

TEXT runtime.restartg(SB) /usr/local/go/src/runtime/proc.go
func restartg(gp *g) {
  0x427230		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427239		483b6110		CMPQ 0x10(CX), SP	
  0x42723d		0f86ba010000		JBE 0x4273fd		
  0x427243		4883ec30		SUBQ $0x30, SP		
  0x427247		48896c2428		MOVQ BP, 0x28(SP)	
  0x42724c		488d6c2428		LEAQ 0x28(SP), BP	
	s := readgstatus(gp)
  0x427251		90			NOPL			
  0x427252		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x427257		8b8890000000		MOVL 0x90(AX), CX	
	case _Gdead:
  0x42725d		83f906			CMPL $0x6, CX		
  0x427260		750a			JNE 0x42726c		
  0x427262		488b6c2428		MOVQ 0x28(SP), BP	
  0x427267		4883c430		ADDQ $0x30, SP		
  0x42726b		c3			RET			
	case _Gscanrunnable,
  0x42726c		81f901100000		CMPL $0x1001, CX	
  0x427272		7517			JNE 0x42728b		
		casfrom_Gscanstatus(gp, s, s&^_Gscan)
  0x427274		48890424		MOVQ AX, 0(SP)				
  0x427278		894c2408		MOVL CX, 0x8(SP)			
  0x42727c		0fbaf10c		BTRL $0xc, CX				
  0x427280		894c240c		MOVL CX, 0xc(SP)			
  0x427284		e8d7f4ffff		CALL runtime.casfrom_Gscanstatus(SB)	
	switch s {
  0x427289		ebd7			JMP 0x427262		
	case _Gscanrunnable,
  0x42728b		8d91fdefffff		LEAL 0xffffeffd(CX), DX	
  0x427291		83fa01			CMPL $0x1, DX		
  0x427294		76de			JBE 0x427274		
		dumpgstatus(gp)
  0x427296		90			NOPL			
	_g_ := getg()
  0x427297		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4272a0		48894c2420		MOVQ CX, 0x20(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4272a5		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x4272a6		8b9090000000		MOVL 0x90(AX), DX	
  0x4272ac		89542410		MOVL DX, 0x10(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4272b0		488b9898000000		MOVQ 0x98(AX), BX		
  0x4272b7		48895c2418		MOVQ BX, 0x18(SP)		
  0x4272bc		e8ffcbffff		CALL runtime.printlock(SB)	
  0x4272c1		488d05cf8d0400		LEAQ 0x48dcf(IP), AX		
  0x4272c8		48890424		MOVQ AX, 0(SP)			
  0x4272cc		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4272d5		e816d5ffff		CALL runtime.printstring(SB)	
  0x4272da		488b442438		MOVQ 0x38(SP), AX		
  0x4272df		48890424		MOVQ AX, 0(SP)			
  0x4272e3		e8c8d4ffff		CALL runtime.printpointer(SB)	
  0x4272e8		488d05ed7f0400		LEAQ 0x47fed(IP), AX		
  0x4272ef		48890424		MOVQ AX, 0(SP)			
  0x4272f3		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4272fc		e8efd4ffff		CALL runtime.printstring(SB)	
  0x427301		488b442418		MOVQ 0x18(SP), AX		
  0x427306		48890424		MOVQ AX, 0(SP)			
  0x42730a		e831d3ffff		CALL runtime.printint(SB)	
  0x42730f		488d0567900400		LEAQ 0x49067(IP), AX		
  0x427316		48890424		MOVQ AX, 0(SP)			
  0x42731a		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x427323		e8c8d4ffff		CALL runtime.printstring(SB)	
  0x427328		8b442410		MOVL 0x10(SP), AX		
  0x42732c		89c0			MOVL AX, AX			
  0x42732e		48890424		MOVQ AX, 0(SP)			
  0x427332		e809d2ffff		CALL runtime.printuint(SB)	
  0x427337		e814ceffff		CALL runtime.printnl(SB)	
  0x42733c		e8ffcbffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x427341		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x427342		488b442420		MOVQ 0x20(SP), AX	
  0x427347		8b8890000000		MOVL 0x90(AX), CX	
  0x42734d		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x427351		488b9098000000		MOVQ 0x98(AX), DX		
  0x427358		4889542418		MOVQ DX, 0x18(SP)		
  0x42735d		e85ecbffff		CALL runtime.printlock(SB)	
  0x427362		488d051e8d0400		LEAQ 0x48d1e(IP), AX		
  0x427369		48890424		MOVQ AX, 0(SP)			
  0x42736d		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x427376		e875d4ffff		CALL runtime.printstring(SB)	
  0x42737b		488b442420		MOVQ 0x20(SP), AX		
  0x427380		48890424		MOVQ AX, 0(SP)			
  0x427384		e827d4ffff		CALL runtime.printpointer(SB)	
  0x427389		488d054c7f0400		LEAQ 0x47f4c(IP), AX		
  0x427390		48890424		MOVQ AX, 0(SP)			
  0x427394		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42739d		e84ed4ffff		CALL runtime.printstring(SB)	
  0x4273a2		488b442418		MOVQ 0x18(SP), AX		
  0x4273a7		48890424		MOVQ AX, 0(SP)			
  0x4273ab		e890d2ffff		CALL runtime.printint(SB)	
  0x4273b0		488d05b38f0400		LEAQ 0x48fb3(IP), AX		
  0x4273b7		48890424		MOVQ AX, 0(SP)			
  0x4273bb		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4273c4		e827d4ffff		CALL runtime.printstring(SB)	
  0x4273c9		8b442414		MOVL 0x14(SP), AX		
  0x4273cd		89c0			MOVL AX, AX			
  0x4273cf		48890424		MOVQ AX, 0(SP)			
  0x4273d3		e868d1ffff		CALL runtime.printuint(SB)	
  0x4273d8		e873cdffff		CALL runtime.printnl(SB)	
  0x4273dd		e85ecbffff		CALL runtime.printunlock(SB)	
		throw("restartg: unexpected status")
  0x4273e2		488d058da00400		LEAQ 0x4a08d(IP), AX	
  0x4273e9		48890424		MOVQ AX, 0(SP)		
  0x4273ed		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4273f6		e885c0ffff		CALL runtime.throw(SB)	
  0x4273fb		0f0b			UD2			
func restartg(gp *g) {
  0x4273fd		e87e040200		CALL runtime.morestack_noctxt(SB)	
  0x427402		e929feffff		JMP runtime.restartg(SB)		

TEXT runtime.stopTheWorldWithSema(SB) /usr/local/go/src/runtime/proc.go
func stopTheWorldWithSema() {
  0x427410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427419		483b6110		CMPQ 0x10(CX), SP	
  0x42741d		0f8698020000		JBE 0x4276bb		
  0x427423		4883ec60		SUBQ $0x60, SP		
  0x427427		48896c2458		MOVQ BP, 0x58(SP)	
  0x42742c		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x427431		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks > 0 {
  0x42743a		488b4830		MOVQ 0x30(AX), CX	
  0x42743e		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x427445		0f8f55020000		JG 0x4276a0		
	_g_ := getg()
  0x42744b		4889442448		MOVQ AX, 0x48(SP)	
	lock(&sched.lock)
  0x427450		488d0559a80900		LEAQ runtime.sched+16(SB), AX	
  0x427457		48890424		MOVQ AX, 0(SP)			
  0x42745b		e88012feff		CALL runtime.lock(SB)		
	sched.stopwait = gomaxprocs
  0x427460		8b057a580b00		MOVL runtime.gomaxprocs(SB), AX	
  0x427466		890530a90900		MOVL AX, runtime.sched+252(SB)	
	atomic.Store(&sched.gcwaiting, 1)
  0x42746c		b801000000		MOVL $0x1, AX			
  0x427471		488d0d20a90900		LEAQ runtime.sched+248(SB), CX	
  0x427478		8701			XCHGL AX, 0(CX)			
	preemptall()
  0x42747a		e891800000		CALL runtime.preemptall(SB)	
	_g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.
  0x42747f		488b442448		MOVQ 0x48(SP), AX	
  0x427484		488b4030		MOVQ 0x30(AX), AX	
  0x427488		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x42748f		90			NOPL			
  0x427490		c7400c03000000		MOVL $0x3, 0xc(AX)	
	sched.stopwait--
  0x427497		ff0dffa80900		DECL runtime.sched+252(SB)	
	for _, p := range allp {
  0x42749d		488b0584a50900		MOVQ runtime.allp+8(SB), AX	
  0x4274a4		4889442430		MOVQ AX, 0x30(SP)		
  0x4274a9		488b0d70a50900		MOVQ runtime.allp(SB), CX	
  0x4274b0		48894c2450		MOVQ CX, 0x50(SP)		
  0x4274b5		31d2			XORL DX, DX			
  0x4274b7		eb06			JMP 0x4274bf			
  0x4274b9		48ffc2			INCQ DX				
  0x4274bc		4889f8			MOVQ DI, AX			
  0x4274bf		4839c2			CMPQ AX, DX			
  0x4274c2		0f8d91000000		JGE 0x427559			
  0x4274c8		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		s := p.status
  0x4274cc		8b730c			MOVL 0xc(BX), SI	
		if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
  0x4274cf		83fe02			CMPL $0x2, SI		
  0x4274d2		756b			JNE 0x42753f		
	for _, p := range allp {
  0x4274d4		4889c7			MOVQ AX, DI		
		if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
  0x4274d7		89f0			MOVL SI, AX			
  0x4274d9		41b803000000		MOVL $0x3, R8			
  0x4274df		f0440fb1430c		LOCK CMPXCHGL R8, 0xc(BX)	
  0x4274e5		400f94c6		SETE SI				
  0x4274e9		4084f6			TESTL SI, SI			
  0x4274ec		74cb			JE 0x4274b9			
			if trace.enabled {
  0x4274ee		803ddb560a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x4274f5		750b			JNE 0x427502			
			p.syscalltick++
  0x4274f7		ff431c			INCL 0x1c(BX)		
			sched.stopwait--
  0x4274fa		ff0d9ca80900		DECL runtime.sched+252(SB)	
  0x427500		ebb7			JMP 0x4274b9			
	for _, p := range allp {
  0x427502		4889542428		MOVQ DX, 0x28(SP)	
  0x427507		48895c2438		MOVQ BX, 0x38(SP)	
				traceGoSysBlock(p)
  0x42750c		48891c24		MOVQ BX, 0(SP)				
  0x427510		e8eb5e0100		CALL runtime.traceGoSysBlock(SB)	
				traceProcStop(p)
  0x427515		488b442438		MOVQ 0x38(SP), AX		
  0x42751a		48890424		MOVQ AX, 0(SP)			
  0x42751e		e89d560100		CALL runtime.traceProcStop(SB)	
	for _, p := range allp {
  0x427523		488b4c2450		MOVQ 0x50(SP), CX	
  0x427528		488b542428		MOVQ 0x28(SP), DX	
			p.syscalltick++
  0x42752d		488b5c2438		MOVQ 0x38(SP), BX	
	for _, p := range allp {
  0x427532		488b7c2430		MOVQ 0x30(SP), DI	
  0x427537		41b803000000		MOVL $0x3, R8		
				traceProcStop(p)
  0x42753d		ebb8			JMP 0x4274f7		
	for _, p := range allp {
  0x42753f		4889c7			MOVQ AX, DI		
  0x427542		41b803000000		MOVL $0x3, R8		
  0x427548		31f6			XORL SI, SI		
		if s == _Psyscall && atomic.Cas(&p.status, s, _Pgcstop) {
  0x42754a		eb9d			JMP 0x4274e9		
		p.status = _Pgcstop
  0x42754c		c7400c03000000		MOVL $0x3, 0xc(AX)	
		sched.stopwait--
  0x427553		ff0d43a80900		DECL runtime.sched+252(SB)	
		p := pidleget()
  0x427559		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x42755a		488b0587a70900		MOVQ runtime.sched+72(SB), AX	
  0x427561		90			NOPL				
	if _p_ != nil {
  0x427562		4885c0			TESTQ AX, AX		
  0x427565		741e			JE 0x427585		
		sched.pidle = _p_.link
  0x427567		488b4810		MOVQ 0x10(AX), CX		
  0x42756b		48890d76a70900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x427572		b9ffffffff		MOVL $-0x1, CX			
  0x427577		488d1572a70900		LEAQ runtime.sched+80(SB), DX	
  0x42757e		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x427582		4885c0			TESTQ AX, AX		
		if p == nil {
  0x427585		75c5			JNE 0x42754c		
	wait := sched.stopwait > 0
  0x427587		8b050fa80900		MOVL runtime.sched+252(SB), AX	
  0x42758d		8944241c		MOVL AX, 0x1c(SP)		
  0x427591		83f800			CMPL $0x0, AX			
	unlock(&sched.lock)
  0x427594		488d0d15a70900		LEAQ runtime.sched+16(SB), CX	
  0x42759b		48890c24		MOVQ CX, 0(SP)			
  0x42759f		e8ec12feff		CALL runtime.unlock(SB)		
	wait := sched.stopwait > 0
  0x4275a4		8b44241c		MOVL 0x1c(SP), AX	
  0x4275a8		83f800			CMPL $0x0, AX		
	if wait {
  0x4275ab		0f8fae000000		JG 0x42765f		
	if sched.stopwait != 0 {
  0x4275b1		833de4a7090000		CMPL $0x0, runtime.sched+252(SB)	
  0x4275b8		0f858e000000		JNE 0x42764c				
		for _, p := range allp {
  0x4275be		488b0563a40900		MOVQ runtime.allp+8(SB), AX	
  0x4275c5		488b0d54a40900		MOVQ runtime.allp(SB), CX	
  0x4275cc		31d2			XORL DX, DX			
  0x4275ce		31db			XORL BX, BX			
  0x4275d0		31f6			XORL SI, SI			
  0x4275d2		eb20			JMP 0x4275f4			
  0x4275d4		488b3cd1		MOVQ 0(CX)(DX*8), DI		
			if p.status != _Pgcstop {
  0x4275d8		837f0c03		CMPL $0x3, 0xc(DI)	
	if bad != "" {
  0x4275dc		488d3d6fba0400		LEAQ 0x4ba6f(IP), DI	
  0x4275e3		480f45df		CMOVNE DI, BX		
  0x4275e7		41b82e000000		MOVL $0x2e, R8		
  0x4275ed		490f45f0		CMOVNE R8, SI		
		for _, p := range allp {
  0x4275f1		48ffc2			INCQ DX			
  0x4275f4		4839c2			CMPQ AX, DX		
  0x4275f7		7cdb			JL 0x4275d4		
	if atomic.Load(&freezing) != 0 {
  0x4275f9		8b05cd560b00		MOVL runtime.freezing(SB), AX	
  0x4275ff		85c0			TESTL AX, AX			
  0x427601		7513			JNE 0x427616			
	if bad != "" {
  0x427603		4885f6			TESTQ SI, SI		
  0x427606		0f8584000000		JNE 0x427690		
  0x42760c		488b6c2458		MOVQ 0x58(SP), BP	
  0x427611		4883c460		ADDQ $0x60, SP		
  0x427615		c3			RET			
  0x427616		48895c2440		MOVQ BX, 0x40(SP)	
  0x42761b		4889742420		MOVQ SI, 0x20(SP)	
		lock(&deadlock)
  0x427620		488d0529570b00		LEAQ runtime.deadlock(SB), AX	
  0x427627		48890424		MOVQ AX, 0(SP)			
  0x42762b		e8b010feff		CALL runtime.lock(SB)		
		lock(&deadlock)
  0x427630		488d0519570b00		LEAQ runtime.deadlock(SB), AX	
  0x427637		48890424		MOVQ AX, 0(SP)			
  0x42763b		e8a010feff		CALL runtime.lock(SB)		
		throw(bad)
  0x427640		488b5c2440		MOVQ 0x40(SP), BX	
	if bad != "" {
  0x427645		488b742420		MOVQ 0x20(SP), SI	
		lock(&deadlock)
  0x42764a		ebb7			JMP 0x427603		
  0x42764c		488d1ddeb40400		LEAQ 0x4b4de(IP), BX	
  0x427653		be29000000		MOVL $0x29, SI		
	if atomic.Load(&freezing) != 0 {
  0x427658		eb9f			JMP 0x4275f9		
			preemptall()
  0x42765a		e8b17e0000		CALL runtime.preemptall(SB)	
			if notetsleep(&sched.stopnote, 100*1000) {
  0x42765f		488d053aa70900		LEAQ runtime.sched+256(SB), AX	
  0x427666		48890424		MOVQ AX, 0(SP)			
  0x42766a		48c7442408a0860100	MOVQ $0x186a0, 0x8(SP)		
  0x427673		e86816feff		CALL runtime.notetsleep(SB)	
  0x427678		807c241000		CMPB $0x0, 0x10(SP)		
  0x42767d		74db			JE 0x42765a			
				noteclear(&sched.stopnote)
  0x42767f		90			NOPL			
	n.key = 0
  0x427680		48c70515a7090000000000	MOVQ $0x0, runtime.sched+256(SB)	
	if sched.stopwait != 0 {
  0x42768b		e921ffffff		JMP 0x4275b1		
		throw(bad)
  0x427690		48891c24		MOVQ BX, 0(SP)		
  0x427694		4889742408		MOVQ SI, 0x8(SP)	
  0x427699		e8e2bdffff		CALL runtime.throw(SB)	
  0x42769e		0f0b			UD2			
		throw("stopTheWorld: holding locks")
  0x4276a0		488d05dd9e0400		LEAQ 0x49edd(IP), AX	
  0x4276a7		48890424		MOVQ AX, 0(SP)		
  0x4276ab		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x4276b4		e8c7bdffff		CALL runtime.throw(SB)	
  0x4276b9		0f0b			UD2			
func stopTheWorldWithSema() {
  0x4276bb		e8c0010200		CALL runtime.morestack_noctxt(SB)	
  0x4276c0		e94bfdffff		JMP runtime.stopTheWorldWithSema(SB)	

TEXT runtime.startTheWorldWithSema(SB) /usr/local/go/src/runtime/proc.go
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x4276d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4276d9		483b6110		CMPQ 0x10(CX), SP	
  0x4276dd		0f8650020000		JBE 0x427933		
  0x4276e3		4883ec58		SUBQ $0x58, SP		
  0x4276e7		48896c2450		MOVQ BP, 0x50(SP)	
  0x4276ec		488d6c2450		LEAQ 0x50(SP), BP	
	_g_ := getg()
  0x4276f1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4276fa		4889442440		MOVQ AX, 0x40(SP)	
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x4276ff		488b4830		MOVQ 0x30(AX), CX	
  0x427703		ff8108010000		INCL 0x108(CX)		
	if netpollinited() {
  0x427709		90			NOPL			
	return atomic.Load(&netpollInited) != 0
  0x42770a		8b0dd8550b00		MOVL runtime.netpollInited(SB), CX	
  0x427710		85c9			TESTL CX, CX				
	if netpollinited() {
  0x427712		0f85da010000		JNE 0x4278f2		
	lock(&sched.lock)
  0x427718		488d0591a50900		LEAQ runtime.sched+16(SB), AX	
  0x42771f		48890424		MOVQ AX, 0(SP)			
  0x427723		e8b80ffeff		CALL runtime.lock(SB)		
	procs := gomaxprocs
  0x427728		8b05b2550b00		MOVL runtime.gomaxprocs(SB), AX	
	if newprocs != 0 {
  0x42772e		8b0dbc550b00		MOVL runtime.newprocs(SB), CX	
  0x427734		85c9			TESTL CX, CX			
  0x427736		0f84af010000		JE 0x4278eb			
		newprocs = 0
  0x42773c		c705aa550b0000000000	MOVL $0x0, runtime.newprocs(SB)	
	p1 := procresize(procs)
  0x427746		890c24			MOVL CX, 0(SP)			
  0x427749		e802630000		CALL runtime.procresize(SB)	
  0x42774e		488b442408		MOVQ 0x8(SP), AX		
  0x427753		4889442438		MOVQ AX, 0x38(SP)		
	sched.gcwaiting = 0
  0x427758		c70536a6090000000000	MOVL $0x0, runtime.sched+248(SB)	
	if sched.sysmonwait != 0 {
  0x427762		833d3fa6090000		CMPL $0x0, runtime.sched+264(SB)	
  0x427769		0f855d010000		JNE 0x4278cc				
	unlock(&sched.lock)
  0x42776f		488d053aa50900		LEAQ runtime.sched+16(SB), AX	
  0x427776		48890424		MOVQ AX, 0(SP)			
  0x42777a		e81111feff		CALL runtime.unlock(SB)		
	for p1 != nil {
  0x42777f		488b442438		MOVQ 0x38(SP), AX	
  0x427784		eb08			JMP 0x42778e		
  0x427786		488b4c2448		MOVQ 0x48(SP), CX	
  0x42778b		4889c8			MOVQ CX, AX		
  0x42778e		4885c0			TESTQ AX, AX		
  0x427791		7458			JE 0x4277eb		
		p1 = p1.link.ptr()
  0x427793		488b4810		MOVQ 0x10(AX), CX	
  0x427797		90			NOPL			
		if p.m != 0 {
  0x427798		488b5040		MOVQ 0x40(AX), DX	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42779c		48894c2448		MOVQ CX, 0x48(SP)	
		if p.m != 0 {
  0x4277a1		4885d2			TESTQ DX, DX		
  0x4277a4		7431			JE 0x4277d7		
			mp := p.m.ptr()
  0x4277a6		90			NOPL			
			p.m = 0
  0x4277a7		48c7404000000000	MOVQ $0x0, 0x40(AX)	
			if mp.nextp != 0 {
  0x4277af		4883bad800000000	CMPQ $0x0, 0xd8(DX)	
  0x4277b7		0f855b010000		JNE 0x427918		
			mp.nextp.set(p)
  0x4277bd		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4277be		488982d8000000		MOVQ AX, 0xd8(DX)	
			notewakeup(&mp.park)
  0x4277c5		488d8248010000		LEAQ 0x148(DX), AX		
  0x4277cc		48890424		MOVQ AX, 0(SP)			
  0x4277d0		e88b11feff		CALL runtime.notewakeup(SB)	
  0x4277d5		ebaf			JMP 0x427786			
			newm(nil, p)
  0x4277d7		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x4277df		4889442408		MOVQ AX, 0x8(SP)	
  0x4277e4		e887120000		CALL runtime.newm(SB)	
  0x4277e9		eb9b			JMP 0x427786		
	startTime := nanotime()
  0x4277eb		e8c0380200		CALL runtime.nanotime(SB)	
  0x4277f0		488b0424		MOVQ 0(SP), AX			
  0x4277f4		4889442428		MOVQ AX, 0x28(SP)		
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x4277f9		0fb64c2460		MOVZX 0x60(SP), CX	
  0x4277fe		84c9			TESTL CL, CL		
	if emitTraceEvent {
  0x427800		0f8598000000		JNE 0x42789e		
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x427806		8b0de4a40900		MOVL runtime.sched+80(SB), CX	
  0x42780c		85c9			TESTL CX, CX			
  0x42780e		0f8486000000		JE 0x42789a			
  0x427814		8b0ddaa40900		MOVL runtime.sched+84(SB), CX	
  0x42781a		85c9			TESTL CX, CX			
  0x42781c		0f94c1			SETE CL				
  0x42781f		84c9			TESTL CL, CL			
  0x427821		7472			JE 0x427895			
		wakep()
  0x427823		90			NOPL			
	startTime := nanotime()
  0x427824		4889c1			MOVQ AX, CX		
	if !atomic.Cas(&sched.nmspinning, 0, 1) {
  0x427827		31c0			XORL AX, AX			
  0x427829		488d15c4a40900		LEAQ runtime.sched+84(SB), DX	
  0x427830		bb01000000		MOVL $0x1, BX			
  0x427835		f00fb11a		LOCK CMPXCHGL BX, 0(DX)		
  0x427839		0f94c2			SETE DL				
  0x42783c		84d2			TESTL DL, DL			
  0x42783e		753c			JNE 0x42787c			
	_g_.m.locks--
  0x427840		488b442440		MOVQ 0x40(SP), AX	
  0x427845		488b5030		MOVQ 0x30(AX), DX	
  0x427849		ff8a08010000		DECL 0x108(DX)		
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x42784f		488b5030		MOVQ 0x30(AX), DX	
  0x427853		83ba0801000000		CMPL $0x0, 0x108(DX)	
  0x42785a		7511			JNE 0x42786d		
  0x42785c		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x427863		7408			JE 0x42786d		
		_g_.stackguard0 = stackPreempt
  0x427865		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return startTime
  0x42786d		48894c2468		MOVQ CX, 0x68(SP)	
  0x427872		488b6c2450		MOVQ 0x50(SP), BP	
  0x427877		4883c458		ADDQ $0x58, SP		
  0x42787b		c3			RET			
	startm(nil, true)
  0x42787c		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x427884		c644240801		MOVB $0x1, 0x8(SP)	
  0x427889		e8e2160000		CALL runtime.startm(SB)	
	return startTime
  0x42788e		488b4c2428		MOVQ 0x28(SP), CX	
		wakep()
  0x427893		ebab			JMP 0x427840		
	return startTime
  0x427895		4889c1			MOVQ AX, CX		
	_g_.m.locks--
  0x427898		eba6			JMP 0x427840		
  0x42789a		31c9			XORL CX, CX		
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x42789c		eb81			JMP 0x42781f		
		traceGCSTWDone()
  0x42789e		90			NOPL			
	traceEvent(traceEvGCSTWDone, -1)
  0x42789f		c604240a		MOVB $0xa, 0(SP)		
  0x4278a3		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x4278ac		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4278b5		0f57c0			XORPS X0, X0			
  0x4278b8		0f11442418		MOVUPS X0, 0x18(SP)		
  0x4278bd		e8de450100		CALL runtime.traceEvent(SB)	
	return startTime
  0x4278c2		488b442428		MOVQ 0x28(SP), AX	
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 {
  0x4278c7		e93affffff		JMP 0x427806		
		sched.sysmonwait = 0
  0x4278cc		c705d2a4090000000000	MOVL $0x0, runtime.sched+264(SB)	
		notewakeup(&sched.sysmonnote)
  0x4278d6		488d05d3a40900		LEAQ runtime.sched+272(SB), AX	
  0x4278dd		48890424		MOVQ AX, 0(SP)			
  0x4278e1		e87a10feff		CALL runtime.notewakeup(SB)	
  0x4278e6		e984feffff		JMP 0x42776f			
	p1 := procresize(procs)
  0x4278eb		89c1			MOVL AX, CX		
	if newprocs != 0 {
  0x4278ed		e954feffff		JMP 0x427746		
		list := netpoll(false) // non-blocking
  0x4278f2		c6042400		MOVB $0x0, 0(SP)		
  0x4278f6		e8d597ffff		CALL runtime.netpoll(SB)	
  0x4278fb		488b442408		MOVQ 0x8(SP), AX		
  0x427900		4889442430		MOVQ AX, 0x30(SP)		
		injectglist(&list)
  0x427905		488d442430		LEAQ 0x30(SP), AX		
  0x42790a		48890424		MOVQ AX, 0(SP)			
  0x42790e		e85d2f0000		CALL runtime.injectglist(SB)	
  0x427913		e900feffff		JMP 0x427718			
				throw("startTheWorld: inconsistent mp->nextp")
  0x427918		488d050eae0400		LEAQ 0x4ae0e(IP), AX	
  0x42791f		48890424		MOVQ AX, 0(SP)		
  0x427923		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x42792c		e84fbbffff		CALL runtime.throw(SB)	
  0x427931		0f0b			UD2			
func startTheWorldWithSema(emitTraceEvent bool) int64 {
  0x427933		e848ff0100		CALL runtime.morestack_noctxt(SB)	
  0x427938		e993fdffff		JMP runtime.startTheWorldWithSema(SB)	

TEXT runtime.mstart(SB) /usr/local/go/src/runtime/proc.go
func mstart() {
  0x427940		4883ec20		SUBQ $0x20, SP		
  0x427944		48896c2418		MOVQ BP, 0x18(SP)	
  0x427949		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x42794e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	osStack := _g_.stack.lo == 0
  0x427957		488b08			MOVQ 0(AX), CX		
  0x42795a		48894c2410		MOVQ CX, 0x10(SP)	
  0x42795f		4883f900		CMPQ $0x0, CX		
	if osStack {
  0x427963		7533			JNE 0x427998		
		size := _g_.stack.hi
  0x427965		488b5008		MOVQ 0x8(AX), DX	
  0x427969		4889542408		MOVQ DX, 0x8(SP)	
		if size == 0 {
  0x42796e		4885d2			TESTQ DX, DX		
  0x427971		7509			JNE 0x42797c		
			size = 8192 * sys.StackGuardMultiplier
  0x427973		48c744240800200000	MOVQ $0x2000, 0x8(SP)	
		_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))
  0x42797c		488d542408		LEAQ 0x8(SP), DX	
  0x427981		90			NOPL			
  0x427982		48895008		MOVQ DX, 0x8(AX)	
		_g_.stack.lo = _g_.stack.hi - size + 1024
  0x427986		488b5c2408		MOVQ 0x8(SP), BX	
  0x42798b		4829da			SUBQ BX, DX		
  0x42798e		4881c200040000		ADDQ $0x400, DX		
  0x427995		488910			MOVQ DX, 0(AX)		
	_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x427998		488b08			MOVQ 0(AX), CX		
  0x42799b		4881c170030000		ADDQ $0x370, CX		
  0x4279a2		48894810		MOVQ CX, 0x10(AX)	
	_g_.stackguard1 = _g_.stackguard0
  0x4279a6		48894818		MOVQ CX, 0x18(AX)	
	mstart1()
  0x4279aa		e821000000		CALL runtime.mstart1(SB)	
	osStack := _g_.stack.lo == 0
  0x4279af		488b442410		MOVQ 0x10(SP), AX	
  0x4279b4		4883f800		CMPQ $0x0, AX		
  0x4279b8		0f94c0			SETE AL			
	mexit(osStack)
  0x4279bb		880424			MOVB AL, 0(SP)		
  0x4279be		e87d010000		CALL runtime.mexit(SB)	
}
  0x4279c3		488b6c2418		MOVQ 0x18(SP), BP	
  0x4279c8		4883c420		ADDQ $0x20, SP		
  0x4279cc		c3			RET			

TEXT runtime.mstart1(SB) /usr/local/go/src/runtime/proc.go
func mstart1() {
  0x4279d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4279d9		483b6110		CMPQ 0x10(CX), SP	
  0x4279dd		0f86ed000000		JBE 0x427ad0		
  0x4279e3		4883ec20		SUBQ $0x20, SP		
  0x4279e7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4279ec		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x4279f1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_ != _g_.m.g0 {
  0x4279fa		488b4830		MOVQ 0x30(AX), CX	
  0x4279fe		483901			CMPQ AX, 0(CX)		
  0x427a01		0f85ae000000		JNE 0x427ab5		
	_g_ := getg()
  0x427a07		4889442410		MOVQ AX, 0x10(SP)	
	save(getcallerpc(), getcallersp())
  0x427a0c		488b442420		MOVQ 0x20(SP), AX	
  0x427a11		48890424		MOVQ AX, 0(SP)		
  0x427a15		488d442428		LEAQ 0x28(SP), AX	
  0x427a1a		4889442408		MOVQ AX, 0x8(SP)	
  0x427a1f		e80c3d0000		CALL runtime.save(SB)	
	asminit()
  0x427a24		e817fc0100		CALL runtime.asminit(SB)	
	minit()
  0x427a29		e832a2ffff		CALL runtime.minit(SB)	
	if _g_.m == &m0 {
  0x427a2e		488d052ba90900		LEAQ runtime.m0(SB), AX	
  0x427a35		488b4c2410		MOVQ 0x10(SP), CX	
  0x427a3a		48394130		CMPQ AX, 0x30(CX)	
  0x427a3e		7462			JE 0x427aa2		
	if fn := _g_.m.mstartfn; fn != nil {
  0x427a40		488b5930		MOVQ 0x30(CX), BX	
  0x427a44		488b93b8000000		MOVQ 0xb8(BX), DX	
  0x427a4b		4885d2			TESTQ DX, DX		
  0x427a4e		753f			JNE 0x427a8f		
	if _g_.m != &m0 {
  0x427a50		488b5130		MOVQ 0x30(CX), DX	
  0x427a54		4839d0			CMPQ DX, AX		
  0x427a57		750f			JNE 0x427a68		
	schedule()
  0x427a59		e8a22f0000		CALL runtime.schedule(SB)	
}
  0x427a5e		488b6c2418		MOVQ 0x18(SP), BP	
  0x427a63		4883c420		ADDQ $0x20, SP		
  0x427a67		c3			RET			
		acquirep(_g_.m.nextp.ptr())
  0x427a68		488b82d8000000		MOVQ 0xd8(DX), AX		
  0x427a6f		90			NOPL				
  0x427a70		48890424		MOVQ AX, 0(SP)			
  0x427a74		e8576a0000		CALL runtime.acquirep(SB)	
		_g_.m.nextp = 0
  0x427a79		488b442410		MOVQ 0x10(SP), AX	
  0x427a7e		488b4030		MOVQ 0x30(AX), AX	
  0x427a82		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
  0x427a8d		ebca			JMP 0x427a59		
		fn()
  0x427a8f		488b02			MOVQ 0(DX), AX		
  0x427a92		ffd0			CALL AX			
  0x427a94		488d05c5a80900		LEAQ runtime.m0(SB), AX	
	if _g_.m != &m0 {
  0x427a9b		488b4c2410		MOVQ 0x10(SP), CX	
		fn()
  0x427aa0		ebae			JMP 0x427a50		
		mstartm0()
  0x427aa2		e839000000		CALL runtime.mstartm0(SB)	
  0x427aa7		488d05b2a80900		LEAQ runtime.m0(SB), AX		
	if fn := _g_.m.mstartfn; fn != nil {
  0x427aae		488b4c2410		MOVQ 0x10(SP), CX	
		mstartm0()
  0x427ab3		eb8b			JMP 0x427a40		
		throw("bad runtimemstart")
  0x427ab5		488d050d890400		LEAQ 0x4890d(IP), AX	
  0x427abc		48890424		MOVQ AX, 0(SP)		
  0x427ac0		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x427ac9		e8b2b9ffff		CALL runtime.throw(SB)	
  0x427ace		0f0b			UD2			
func mstart1() {
  0x427ad0		e8abfd0100		CALL runtime.morestack_noctxt(SB)	
  0x427ad5		e9f6feffff		JMP runtime.mstart1(SB)			

TEXT runtime.mstartm0(SB) /usr/local/go/src/runtime/proc.go
func mstartm0() {
  0x427ae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427ae9		483b6110		CMPQ 0x10(CX), SP	
  0x427aed		7641			JBE 0x427b30		
  0x427aef		4883ec10		SUBQ $0x10, SP		
  0x427af3		48896c2408		MOVQ BP, 0x8(SP)	
  0x427af8		488d6c2408		LEAQ 0x8(SP), BP	
	if (iscgo || GOOS == "windows") && !cgoHasExtraM {
  0x427afd		803daa510b0000		CMPB $0x0, runtime.iscgo(SB)		
  0x427b04		7409			JE 0x427b0f				
  0x427b06		803d98510b0000		CMPB $0x0, runtime.cgoHasExtraM(SB)	
  0x427b0d		7413			JE 0x427b22				
	initsig(false)
  0x427b0f		c6042400		MOVB $0x0, 0(SP)		
  0x427b13		e8a8c90000		CALL runtime.initsig(SB)	
}
  0x427b18		488b6c2408		MOVQ 0x8(SP), BP	
  0x427b1d		4883c410		ADDQ $0x10, SP		
  0x427b21		c3			RET			
		cgoHasExtraM = true
  0x427b22		c6057c510b0001		MOVB $0x1, runtime.cgoHasExtraM(SB)	
		newextram()
  0x427b29		e8120b0000		CALL runtime.newextram(SB)	
  0x427b2e		ebdf			JMP 0x427b0f			
func mstartm0() {
  0x427b30		e84bfd0100		CALL runtime.morestack_noctxt(SB)	
  0x427b35		eba9			JMP runtime.mstartm0(SB)		

TEXT runtime.mexit(SB) /usr/local/go/src/runtime/proc.go
func mexit(osStack bool) {
  0x427b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427b49		483b6110		CMPQ 0x10(CX), SP	
  0x427b4d		0f8646020000		JBE 0x427d99		
  0x427b53		4883ec30		SUBQ $0x30, SP		
  0x427b57		48896c2428		MOVQ BP, 0x28(SP)	
  0x427b5c		488d6c2428		LEAQ 0x28(SP), BP	
	g := getg()
  0x427b61		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	m := g.m
  0x427b6a		488b4030		MOVQ 0x30(AX), AX	
  0x427b6e		4889442420		MOVQ AX, 0x20(SP)	
	if m == &m0 {
  0x427b73		488d0de6a70900		LEAQ runtime.m0(SB), CX	
  0x427b7a		4839c1			CMPQ AX, CX		
  0x427b7d		0f84af010000		JE 0x427d32		
	sigblock()
  0x427b83		90			NOPL			
	sigprocmask(_SIG_SETMASK, &sigset_all, nil)
  0x427b84		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x427b85		c7042402000000		MOVL $0x2, 0(SP)		
  0x427b8c		488d05bd740900		LEAQ runtime.sigset_all(SB), AX	
  0x427b93		4889442408		MOVQ AX, 0x8(SP)		
  0x427b98		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x427ba1		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x427ba9		e8c2350200		CALL runtime.rtsigprocmask(SB)	
	unminit()
  0x427bae		90			NOPL			
	unminitSignals()
  0x427baf		e84cde0000		CALL runtime.unminitSignals(SB)	
	if m.gsignal != nil {
  0x427bb4		488b442420		MOVQ 0x20(SP), AX	
  0x427bb9		488b4850		MOVQ 0x50(AX), CX	
  0x427bbd		4885c9			TESTQ CX, CX		
  0x427bc0		0f8537010000		JNE 0x427cfd		
	lock(&sched.lock)
  0x427bc6		488d05e3a00900		LEAQ runtime.sched+16(SB), AX	
  0x427bcd		48890424		MOVQ AX, 0(SP)			
  0x427bd1		e80a0bfeff		CALL runtime.lock(SB)		
	for pprev := &allm; *pprev != nil; pprev = &(*pprev).alllink {
  0x427bd6		488b442420		MOVQ 0x20(SP), AX		
  0x427bdb		488d0d369d0900		LEAQ runtime.allm(SB), CX	
  0x427be2		eb07			JMP 0x427beb			
  0x427be4		488d8a50010000		LEAQ 0x150(DX), CX		
  0x427beb		488b11			MOVQ 0(CX), DX			
  0x427bee		4885d2			TESTQ DX, DX			
  0x427bf1		0f8420010000		JE 0x427d17			
		if *pprev == m {
  0x427bf7		4839c2			CMPQ AX, DX		
  0x427bfa		75e8			JNE 0x427be4		
			*pprev = m.alllink
  0x427bfc		488b9050010000		MOVQ 0x150(AX), DX			
  0x427c03		833d16520b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x427c0a		0f85d7000000		JNE 0x427ce7				
  0x427c10		488911			MOVQ DX, 0(CX)				
func mexit(osStack bool) {
  0x427c13		0fb64c2438		MOVZX 0x38(SP), CX	
  0x427c18		84c9			TESTL CL, CL		
	if !osStack {
  0x427c1a		7477			JE 0x427c93		
	unlock(&sched.lock)
  0x427c1c		488d058da00900		LEAQ runtime.sched+16(SB), AX	
  0x427c23		48890424		MOVQ AX, 0(SP)			
  0x427c27		e8640cfeff		CALL runtime.unlock(SB)		
	handoffp(releasep())
  0x427c2c		e85f6a0000		CALL runtime.releasep(SB)	
  0x427c31		e85a150000		CALL runtime.handoffp(SB)	
	lock(&sched.lock)
  0x427c36		488d0573a00900		LEAQ runtime.sched+16(SB), AX	
  0x427c3d		48890424		MOVQ AX, 0(SP)			
  0x427c41		e89a0afeff		CALL runtime.lock(SB)		
	sched.nmfreed++
  0x427c46		48ff058ba00900		INCQ runtime.sched+56(SB)	
	checkdead()
  0x427c4d		e8de6c0000		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x427c52		488d0557a00900		LEAQ runtime.sched+16(SB), AX	
  0x427c59		48890424		MOVQ AX, 0(SP)			
  0x427c5d		e82e0cfeff		CALL runtime.unlock(SB)		
func mexit(osStack bool) {
  0x427c62		0fb6442438		MOVZX 0x38(SP), AX	
  0x427c67		84c0			TESTL AL, AL		
	if osStack {
  0x427c69		740a			JE 0x427c75		
		return
  0x427c6b		488b6c2428		MOVQ 0x28(SP), BP	
  0x427c70		4883c430		ADDQ $0x30, SP		
  0x427c74		c3			RET			
	exitThread(&m.freeWait)
  0x427c75		488b442420		MOVQ 0x20(SP), AX		
  0x427c7a		48051c010000		ADDQ $0x11c, AX			
  0x427c80		48890424		MOVQ AX, 0(SP)			
  0x427c84		e8a7310200		CALL runtime.exitThread(SB)	
}
  0x427c89		488b6c2428		MOVQ 0x28(SP), BP	
  0x427c8e		4883c430		ADDQ $0x30, SP		
  0x427c92		c3			RET			
		atomic.Store(&m.freeWait, 1)
  0x427c93		ba01000000		MOVL $0x1, DX		
  0x427c98		87901c010000		XCHGL DX, 0x11c(AX)	
		m.freelink = sched.freem
  0x427c9e		488b15eba00900		MOVQ runtime.sched+240(SB), DX		
  0x427ca5		833d74510b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x427cac		7513			JNE 0x427cc1				
  0x427cae		488990b0020000		MOVQ DX, 0x2b0(AX)			
		sched.freem = m
  0x427cb5		488905d4a00900		MOVQ AX, runtime.sched+240(SB)	
		m.freelink = sched.freem
  0x427cbc		e95bffffff		JMP 0x427c1c		
  0x427cc1		488db8b0020000		LEAQ 0x2b0(AX), DI	
	m := g.m
  0x427cc8		4889c3			MOVQ AX, BX		
		m.freelink = sched.freem
  0x427ccb		4889d0			MOVQ DX, AX			
  0x427cce		e8ad190200		CALL runtime.gcWriteBarrier(SB)	
		sched.freem = m
  0x427cd3		488d3db6a00900		LEAQ runtime.sched+240(SB), DI	
  0x427cda		4889d8			MOVQ BX, AX			
  0x427cdd		e89e190200		CALL runtime.gcWriteBarrier(SB)	
		m.freelink = sched.freem
  0x427ce2		e935ffffff		JMP 0x427c1c		
			*pprev = m.alllink
  0x427ce7		4889cf			MOVQ CX, DI		
	m := g.m
  0x427cea		4889c3			MOVQ AX, BX		
			*pprev = m.alllink
  0x427ced		4889d0			MOVQ DX, AX			
  0x427cf0		e88b190200		CALL runtime.gcWriteBarrier(SB)	
		atomic.Store(&m.freeWait, 1)
  0x427cf5		4889d8			MOVQ BX, AX		
			*pprev = m.alllink
  0x427cf8		e916ffffff		JMP 0x427c13		
		stackfree(m.gsignal.stack)
  0x427cfd		488b4108		MOVQ 0x8(CX), AX		
  0x427d01		488b09			MOVQ 0(CX), CX			
  0x427d04		48890c24		MOVQ CX, 0(SP)			
  0x427d08		4889442408		MOVQ AX, 0x8(SP)		
  0x427d0d		e8aef00000		CALL runtime.stackfree(SB)	
  0x427d12		e9affeffff		JMP 0x427bc6			
	throw("m not found in allm")
  0x427d17		488d05d1860400		LEAQ 0x486d1(IP), AX	
  0x427d1e		48890424		MOVQ AX, 0(SP)		
  0x427d22		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x427d2b		e850b7ffff		CALL runtime.throw(SB)	
  0x427d30		0f0b			UD2			
		handoffp(releasep())
  0x427d32		e859690000		CALL runtime.releasep(SB)	
  0x427d37		e854140000		CALL runtime.handoffp(SB)	
		lock(&sched.lock)
  0x427d3c		488d056d9f0900		LEAQ runtime.sched+16(SB), AX	
  0x427d43		48890424		MOVQ AX, 0(SP)			
  0x427d47		e89409feff		CALL runtime.lock(SB)		
		sched.nmfreed++
  0x427d4c		48ff05859f0900		INCQ runtime.sched+56(SB)	
		checkdead()
  0x427d53		e8d86b0000		CALL runtime.checkdead(SB)	
		unlock(&sched.lock)
  0x427d58		488d05519f0900		LEAQ runtime.sched+16(SB), AX	
  0x427d5f		48890424		MOVQ AX, 0(SP)			
  0x427d63		e8280bfeff		CALL runtime.unlock(SB)		
		notesleep(&m.park)
  0x427d68		488b442420		MOVQ 0x20(SP), AX		
  0x427d6d		8400			TESTB AL, 0(AX)			
  0x427d6f		480548010000		ADDQ $0x148, AX			
  0x427d75		48890424		MOVQ AX, 0(SP)			
  0x427d79		e8b20cfeff		CALL runtime.notesleep(SB)	
		throw("locked m0 woke up")
  0x427d7e		488d050c840400		LEAQ 0x4840c(IP), AX	
  0x427d85		48890424		MOVQ AX, 0(SP)		
  0x427d89		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x427d92		e8e9b6ffff		CALL runtime.throw(SB)	
  0x427d97		0f0b			UD2			
func mexit(osStack bool) {
  0x427d99		e8e2fa0100		CALL runtime.morestack_noctxt(SB)	
  0x427d9e		e99dfdffff		JMP runtime.mexit(SB)			

TEXT runtime.forEachP(SB) /usr/local/go/src/runtime/proc.go
func forEachP(fn func(*p)) {
  0x427db0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427db9		483b6118		CMPQ 0x18(CX), SP	
  0x427dbd		0f866b030000		JBE 0x42812e		
  0x427dc3		4883ec60		SUBQ $0x60, SP		
  0x427dc7		48896c2458		MOVQ BP, 0x58(SP)	
  0x427dcc		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x427dd1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x427dda		488b4830		MOVQ 0x30(AX), CX	
	mp := acquirem()
  0x427dde		90			NOPL			
	_g_.m.locks++
  0x427ddf		ff8108010000		INCL 0x108(CX)		
	_p_ := getg().m.p.ptr()
  0x427de5		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x427dee		488b4930		MOVQ 0x30(CX), CX	
  0x427df2		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x427df9		90			NOPL			
	return _g_.m
  0x427dfa		488b4030		MOVQ 0x30(AX), AX	
  0x427dfe		4889442438		MOVQ AX, 0x38(SP)	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x427e03		48894c2450		MOVQ CX, 0x50(SP)	
	lock(&sched.lock)
  0x427e08		488d15a19e0900		LEAQ runtime.sched+16(SB), DX	
  0x427e0f		48891424		MOVQ DX, 0(SP)			
  0x427e13		e8c808feff		CALL runtime.lock(SB)		
	if sched.safePointWait != 0 {
  0x427e18		833da19f090000		CMPL $0x0, runtime.sched+288(SB)	
  0x427e1f		0f85ee020000		JNE 0x428113				
	sched.safePointWait = gomaxprocs - 1
  0x427e25		8b0db54e0b00		MOVL runtime.gomaxprocs(SB), CX	
  0x427e2b		ffc9			DECL CX				
  0x427e2d		890d8d9f0900		MOVL CX, runtime.sched+288(SB)	
	sched.safePointFn = fn
  0x427e33		833de64f0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x427e3a		0f8587020000		JNE 0x4280c7				
  0x427e40		488b442468		MOVQ 0x68(SP), AX			
  0x427e45		4889056c9f0900		MOVQ AX, runtime.sched+280(SB)		
	for _, p := range allp {
  0x427e4c		488b0dcd9b0900		MOVQ runtime.allp(SB), CX	
  0x427e53		488b15ce9b0900		MOVQ runtime.allp+8(SB), DX	
  0x427e5a		488b5c2450		MOVQ 0x50(SP), BX		
  0x427e5f		31f6			XORL SI, SI			
  0x427e61		eb03			JMP 0x427e66			
  0x427e63		48ffc6			INCQ SI				
  0x427e66		4839d6			CMPQ DX, SI			
  0x427e69		7d1a			JGE 0x427e85			
  0x427e6b		488b3cf1		MOVQ 0(CX)(SI*8), DI		
		if p != _p_ {
  0x427e6f		4839df			CMPQ BX, DI		
  0x427e72		74ef			JE 0x427e63		
			atomic.Store(&p.runSafePointFn, 1)
  0x427e74		8407			TESTB AL, 0(DI)		
  0x427e76		41b801000000		MOVL $0x1, R8		
  0x427e7c		44878738230000		XCHGL R8, 0x2338(DI)	
  0x427e83		ebde			JMP 0x427e63		
	preemptall()
  0x427e85		e886760000		CALL runtime.preemptall(SB)	
	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {
  0x427e8a		488b05579e0900		MOVQ runtime.sched+72(SB), AX	
  0x427e91		90			NOPL				
  0x427e92		eb05			JMP 0x427e99			
  0x427e94		488b4110		MOVQ 0x10(CX), AX		
  0x427e98		90			NOPL				
  0x427e99		4885c0			TESTQ AX, AX			
  0x427e9c		743d			JE 0x427edb			
  0x427e9e		4889c1			MOVQ AX, CX			
		if atomic.Cas(&p.runSafePointFn, 1, 0) {
  0x427ea1		b801000000		MOVL $0x1, AX			
  0x427ea6		31db			XORL BX, BX			
  0x427ea8		f00fb19938230000	LOCK CMPXCHGL BX, 0x2338(CX)	
  0x427eb0		400f94c6		SETE SI				
  0x427eb4		4084f6			TESTL SI, SI			
  0x427eb7		74db			JE 0x427e94			
	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {
  0x427eb9		48894c2448		MOVQ CX, 0x48(SP)	
			fn(p)
  0x427ebe		48890c24		MOVQ CX, 0(SP)		
  0x427ec2		488b542468		MOVQ 0x68(SP), DX	
  0x427ec7		488b02			MOVQ 0(DX), AX		
  0x427eca		ffd0			CALL AX			
			sched.safePointWait--
  0x427ecc		ff0dee9e0900		DECL runtime.sched+288(SB)	
	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {
  0x427ed2		488b4c2448		MOVQ 0x48(SP), CX	
  0x427ed7		31db			XORL BX, BX		
			sched.safePointWait--
  0x427ed9		ebb9			JMP 0x427e94		
	wait := sched.safePointWait > 0
  0x427edb		8b05df9e0900		MOVL runtime.sched+288(SB), AX	
  0x427ee1		8944241c		MOVL AX, 0x1c(SP)		
  0x427ee5		83f800			CMPL $0x0, AX			
	unlock(&sched.lock)
  0x427ee8		488d0dc19d0900		LEAQ runtime.sched+16(SB), CX	
  0x427eef		48890c24		MOVQ CX, 0(SP)			
  0x427ef3		e89809feff		CALL runtime.unlock(SB)		
	fn(_p_)
  0x427ef8		488b442450		MOVQ 0x50(SP), AX	
  0x427efd		48890424		MOVQ AX, 0(SP)		
  0x427f01		488b542468		MOVQ 0x68(SP), DX	
  0x427f06		488b02			MOVQ 0(DX), AX		
  0x427f09		ffd0			CALL AX			
	for _, p := range allp {
  0x427f0b		488b05169b0900		MOVQ runtime.allp+8(SB), AX	
  0x427f12		4889442428		MOVQ AX, 0x28(SP)		
  0x427f17		488b0d029b0900		MOVQ runtime.allp(SB), CX	
  0x427f1e		48894c2440		MOVQ CX, 0x40(SP)		
  0x427f23		31d2			XORL DX, DX			
  0x427f25		eb06			JMP 0x427f2d			
  0x427f27		48ffc2			INCQ DX				
  0x427f2a		4889f8			MOVQ DI, AX			
  0x427f2d		4839c2			CMPQ AX, DX			
  0x427f30		0f8d91000000		JGE 0x427fc7			
  0x427f36		488b1cd1		MOVQ 0(CX)(DX*8), BX		
		s := p.status
  0x427f3a		8b730c			MOVL 0xc(BX), SI	
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x427f3d		83fe02			CMPL $0x2, SI		
  0x427f40		757b			JNE 0x427fbd		
  0x427f42		83bb3823000001		CMPL $0x1, 0x2338(BX)	
  0x427f49		7568			JNE 0x427fb3		
	for _, p := range allp {
  0x427f4b		4889c7			MOVQ AX, DI		
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x427f4e		89f0			MOVL SI, AX			
  0x427f50		4531c0			XORL R8, R8			
  0x427f53		f0440fb1430c		LOCK CMPXCHGL R8, 0xc(BX)	
  0x427f59		400f94c6		SETE SI				
  0x427f5d		4084f6			TESTL SI, SI			
  0x427f60		74c5			JE 0x427f27			
	for _, p := range allp {
  0x427f62		4889542420		MOVQ DX, 0x20(SP)	
			if trace.enabled {
  0x427f67		803d624c0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x427f6e		7520			JNE 0x427f90			
			p.syscalltick++
  0x427f70		ff431c			INCL 0x1c(BX)		
			handoffp(p)
  0x427f73		48891c24		MOVQ BX, 0(SP)			
  0x427f77		e814120000		CALL runtime.handoffp(SB)	
	for _, p := range allp {
  0x427f7c		488b4c2440		MOVQ 0x40(SP), CX	
  0x427f81		488b542420		MOVQ 0x20(SP), DX	
  0x427f86		488b7c2428		MOVQ 0x28(SP), DI	
  0x427f8b		4531c0			XORL R8, R8		
			handoffp(p)
  0x427f8e		eb97			JMP 0x427f27		
	for _, p := range allp {
  0x427f90		48895c2430		MOVQ BX, 0x30(SP)	
				traceGoSysBlock(p)
  0x427f95		48891c24		MOVQ BX, 0(SP)				
  0x427f99		e862540100		CALL runtime.traceGoSysBlock(SB)	
				traceProcStop(p)
  0x427f9e		488b442430		MOVQ 0x30(SP), AX		
  0x427fa3		48890424		MOVQ AX, 0(SP)			
  0x427fa7		e8144c0100		CALL runtime.traceProcStop(SB)	
			p.syscalltick++
  0x427fac		488b5c2430		MOVQ 0x30(SP), BX	
				traceProcStop(p)
  0x427fb1		ebbd			JMP 0x427f70		
	for _, p := range allp {
  0x427fb3		4889c7			MOVQ AX, DI		
  0x427fb6		4531c0			XORL R8, R8		
  0x427fb9		31f6			XORL SI, SI		
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x427fbb		eba0			JMP 0x427f5d		
	for _, p := range allp {
  0x427fbd		4889c7			MOVQ AX, DI		
  0x427fc0		4531c0			XORL R8, R8		
  0x427fc3		31f6			XORL SI, SI		
		if s == _Psyscall && p.runSafePointFn == 1 && atomic.Cas(&p.status, s, _Pidle) {
  0x427fc5		eb96			JMP 0x427f5d		
	wait := sched.safePointWait > 0
  0x427fc7		8b44241c		MOVL 0x1c(SP), AX	
  0x427fcb		83f800			CMPL $0x0, AX		
	if wait {
  0x427fce		0f8fc2000000		JG 0x428096		
	if sched.safePointWait != 0 {
  0x427fd4		833de59d090000		CMPL $0x0, runtime.sched+288(SB)	
  0x427fdb		0f8517010000		JNE 0x4280f8				
	for _, p := range allp {
  0x427fe1		488b05389a0900		MOVQ runtime.allp(SB), AX	
  0x427fe8		488b0d399a0900		MOVQ runtime.allp+8(SB), CX	
  0x427fef		31d2			XORL DX, DX			
  0x427ff1		eb03			JMP 0x427ff6			
  0x427ff3		48ffc2			INCQ DX				
  0x427ff6		4839ca			CMPQ CX, DX			
  0x427ff9		7d14			JGE 0x42800f			
  0x427ffb		488b1cd0		MOVQ 0(AX)(DX*8), BX		
		if p.runSafePointFn != 0 {
  0x427fff		8403			TESTB AL, 0(BX)		
  0x428001		83bb3823000000		CMPL $0x0, 0x2338(BX)	
  0x428008		74e9			JE 0x427ff3		
  0x42800a		e9ce000000		JMP 0x4280dd		
	lock(&sched.lock)
  0x42800f		488d059a9c0900		LEAQ runtime.sched+16(SB), AX	
  0x428016		48890424		MOVQ AX, 0(SP)			
  0x42801a		e8c106feff		CALL runtime.lock(SB)		
	sched.safePointFn = nil
  0x42801f		833dfa4d0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x428026		7559			JNE 0x428081				
  0x428028		48c705859d090000000000	MOVQ $0x0, runtime.sched+280(SB)	
	unlock(&sched.lock)
  0x428033		488d05769c0900		LEAQ runtime.sched+16(SB), AX	
  0x42803a		48890424		MOVQ AX, 0(SP)			
  0x42803e		e84d08feff		CALL runtime.unlock(SB)		
	releasem(mp)
  0x428043		90			NOPL			
	_g_ := getg()
  0x428044		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x42804d		488b4c2438		MOVQ 0x38(SP), CX	
  0x428052		8b9108010000		MOVL 0x108(CX), DX	
  0x428058		8d5aff			LEAL -0x1(DX), BX	
  0x42805b		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x428061		83fa01			CMPL $0x1, DX		
  0x428064		7511			JNE 0x428077		
  0x428066		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x42806d		7408			JE 0x428077		
		_g_.stackguard0 = stackPreempt
  0x42806f		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x428077		488b6c2458		MOVQ 0x58(SP), BP	
  0x42807c		4883c460		ADDQ $0x60, SP		
  0x428080		c3			RET			
	sched.safePointFn = nil
  0x428081		488d3d309d0900		LEAQ runtime.sched+280(SB), DI	
  0x428088		31c0			XORL AX, AX			
  0x42808a		e8f1150200		CALL runtime.gcWriteBarrier(SB)	
  0x42808f		eba2			JMP 0x428033			
			preemptall()
  0x428091		e87a740000		CALL runtime.preemptall(SB)	
			if notetsleep(&sched.safePointNote, 100*1000) {
  0x428096		488d052b9d0900		LEAQ runtime.sched+296(SB), AX	
  0x42809d		48890424		MOVQ AX, 0(SP)			
  0x4280a1		48c7442408a0860100	MOVQ $0x186a0, 0x8(SP)		
  0x4280aa		e8310cfeff		CALL runtime.notetsleep(SB)	
  0x4280af		807c241000		CMPB $0x0, 0x10(SP)		
  0x4280b4		74db			JE 0x428091			
				noteclear(&sched.safePointNote)
  0x4280b6		90			NOPL			
	n.key = 0
  0x4280b7		48c705069d090000000000	MOVQ $0x0, runtime.sched+296(SB)	
	if sched.safePointWait != 0 {
  0x4280c2		e90dffffff		JMP 0x427fd4		
	sched.safePointFn = fn
  0x4280c7		488d3dea9c0900		LEAQ runtime.sched+280(SB), DI	
  0x4280ce		488b442468		MOVQ 0x68(SP), AX		
  0x4280d3		e8a8150200		CALL runtime.gcWriteBarrier(SB)	
  0x4280d8		e96ffdffff		JMP 0x427e4c			
			throw("forEachP: P did not run fn")
  0x4280dd		488d052e910400		LEAQ 0x4912e(IP), AX	
  0x4280e4		48890424		MOVQ AX, 0(SP)		
  0x4280e8		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x4280f1		e88ab3ffff		CALL runtime.throw(SB)	
  0x4280f6		0f0b			UD2			
		throw("forEachP: not done")
  0x4280f8		488d05eb810400		LEAQ 0x481eb(IP), AX	
  0x4280ff		48890424		MOVQ AX, 0(SP)		
  0x428103		48c744240812000000	MOVQ $0x12, 0x8(SP)	
  0x42810c		e86fb3ffff		CALL runtime.throw(SB)	
  0x428111		0f0b			UD2			
		throw("forEachP: sched.safePointWait != 0")
  0x428113		488d050ea20400		LEAQ 0x4a20e(IP), AX	
  0x42811a		48890424		MOVQ AX, 0(SP)		
  0x42811e		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x428127		e854b3ffff		CALL runtime.throw(SB)	
  0x42812c		0f0b			UD2			
func forEachP(fn func(*p)) {
  0x42812e		e89d150100		CALL runtime.morestackc(SB)	
  0x428133		e978fcffff		JMP runtime.forEachP(SB)	

TEXT runtime.runSafePointFn(SB) /usr/local/go/src/runtime/proc.go
func runSafePointFn() {
  0x428140		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428149		483b6110		CMPQ 0x10(CX), SP	
  0x42814d		0f86a5000000		JBE 0x4281f8		
  0x428153		4883ec10		SUBQ $0x10, SP		
  0x428157		48896c2408		MOVQ BP, 0x8(SP)	
  0x42815c		488d6c2408		LEAQ 0x8(SP), BP	
	p := getg().m.p.ptr()
  0x428161		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42816a		488b4930		MOVQ 0x30(CX), CX	
  0x42816e		488b89d0000000		MOVQ 0xd0(CX), CX	
	if !atomic.Cas(&p.runSafePointFn, 1, 0) {
  0x428175		8401			TESTB AL, 0(CX)		
	p := getg().m.p.ptr()
  0x428177		90			NOPL			
	if !atomic.Cas(&p.runSafePointFn, 1, 0) {
  0x428178		b801000000		MOVL $0x1, AX			
  0x42817d		31db			XORL BX, BX			
  0x42817f		f00fb19938230000	LOCK CMPXCHGL BX, 0x2338(CX)	
  0x428187		0f94c3			SETE BL				
  0x42818a		84db			TESTL BL, BL			
  0x42818c		7460			JE 0x4281ee			
	sched.safePointFn(p)
  0x42818e		488b15239c0900		MOVQ runtime.sched+280(SB), DX	
  0x428195		48890c24		MOVQ CX, 0(SP)			
  0x428199		488b02			MOVQ 0(DX), AX			
  0x42819c		ffd0			CALL AX				
	lock(&sched.lock)
  0x42819e		488d050b9b0900		LEAQ runtime.sched+16(SB), AX	
  0x4281a5		48890424		MOVQ AX, 0(SP)			
  0x4281a9		e83205feff		CALL runtime.lock(SB)		
	sched.safePointWait--
  0x4281ae		8b050c9c0900		MOVL runtime.sched+288(SB), AX	
  0x4281b4		8d48ff			LEAL -0x1(AX), CX		
  0x4281b7		890d039c0900		MOVL CX, runtime.sched+288(SB)	
	if sched.safePointWait == 0 {
  0x4281bd		83f801			CMPL $0x1, AX		
  0x4281c0		741a			JE 0x4281dc		
	unlock(&sched.lock)
  0x4281c2		488d05e79a0900		LEAQ runtime.sched+16(SB), AX	
  0x4281c9		48890424		MOVQ AX, 0(SP)			
  0x4281cd		e8be06feff		CALL runtime.unlock(SB)		
}
  0x4281d2		488b6c2408		MOVQ 0x8(SP), BP	
  0x4281d7		4883c410		ADDQ $0x10, SP		
  0x4281db		c3			RET			
		notewakeup(&sched.safePointNote)
  0x4281dc		488d05e59b0900		LEAQ runtime.sched+296(SB), AX	
  0x4281e3		48890424		MOVQ AX, 0(SP)			
  0x4281e7		e87407feff		CALL runtime.notewakeup(SB)	
  0x4281ec		ebd4			JMP 0x4281c2			
		return
  0x4281ee		488b6c2408		MOVQ 0x8(SP), BP	
  0x4281f3		4883c410		ADDQ $0x10, SP		
  0x4281f7		c3			RET			
func runSafePointFn() {
  0x4281f8		e883f60100		CALL runtime.morestack_noctxt(SB)	
  0x4281fd		e93effffff		JMP runtime.runSafePointFn(SB)		

TEXT runtime.allocm(SB) /usr/local/go/src/runtime/proc.go
func allocm(_p_ *p, fn func()) *m {
  0x428210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428219		483b6110		CMPQ 0x10(CX), SP	
  0x42821d		0f8683020000		JBE 0x4284a6		
  0x428223		4883ec38		SUBQ $0x38, SP		
  0x428227		48896c2430		MOVQ BP, 0x30(SP)	
  0x42822c		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x428231		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42823a		4889442428		MOVQ AX, 0x28(SP)	
	_g_.m.locks++ // disable GC because it can be called from sysmon
  0x42823f		488b4830		MOVQ 0x30(AX), CX	
  0x428243		ff8108010000		INCL 0x108(CX)		
	if _g_.m.p == 0 {
  0x428249		488b4830		MOVQ 0x30(AX), CX	
  0x42824d		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x428255		0f8433020000		JE 0x42848e		
	if sched.freem != nil {
  0x42825b		48833d2d9b090000	CMPQ $0x0, runtime.sched+240(SB)	
  0x428263		0f84b8000000		JE 0x428321				
		lock(&sched.lock)
  0x428269		488d05409a0900		LEAQ runtime.sched+16(SB), AX	
  0x428270		48890424		MOVQ AX, 0(SP)			
  0x428274		e86704feff		CALL runtime.lock(SB)		
		for freem := sched.freem; freem != nil; {
  0x428279		488b05109b0900		MOVQ runtime.sched+240(SB), AX	
  0x428280		31c9			XORL CX, CX			
  0x428282		eb06			JMP 0x42828a			
				freem.freelink = newList
  0x428284		4889c1			MOVQ AX, CX		
		for freem := sched.freem; freem != nil; {
  0x428287		4889d0			MOVQ DX, AX		
  0x42828a		4885c0			TESTQ AX, AX		
  0x42828d		746e			JE 0x4282fd		
			if freem.freeWait != 0 {
  0x42828f		83b81c01000000		CMPL $0x0, 0x11c(AX)	
  0x428296		7430			JE 0x4282c8		
				next := freem.freelink
  0x428298		488b90b0020000		MOVQ 0x2b0(AX), DX	
				freem.freelink = newList
  0x42829f		833d7a4b0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4282a6		7509			JNE 0x4282b1				
  0x4282a8		488988b0020000		MOVQ CX, 0x2b0(AX)			
  0x4282af		ebd3			JMP 0x428284				
				next := freem.freelink
  0x4282b1		488db8b0020000		LEAQ 0x2b0(AX), DI	
		for freem := sched.freem; freem != nil; {
  0x4282b8		4889c3			MOVQ AX, BX		
				freem.freelink = newList
  0x4282bb		4889c8			MOVQ CX, AX			
  0x4282be		e8bd130200		CALL runtime.gcWriteBarrier(SB)	
  0x4282c3		4889d8			MOVQ BX, AX			
  0x4282c6		ebbc			JMP 0x428284			
		for freem := sched.freem; freem != nil; {
  0x4282c8		4889442420		MOVQ AX, 0x20(SP)	
				freem.freelink = newList
  0x4282cd		48894c2410		MOVQ CX, 0x10(SP)	
			stackfree(freem.g0.stack)
  0x4282d2		488b08			MOVQ 0(AX), CX			
  0x4282d5		488b5108		MOVQ 0x8(CX), DX		
  0x4282d9		488b09			MOVQ 0(CX), CX			
  0x4282dc		48890c24		MOVQ CX, 0(SP)			
  0x4282e0		4889542408		MOVQ DX, 0x8(SP)		
  0x4282e5		e8d6ea0000		CALL runtime.stackfree(SB)	
			freem = freem.freelink
  0x4282ea		488b442420		MOVQ 0x20(SP), AX	
  0x4282ef		488b90b0020000		MOVQ 0x2b0(AX), DX	
				freem.freelink = newList
  0x4282f6		488b442410		MOVQ 0x10(SP), AX	
			freem = freem.freelink
  0x4282fb		eb87			JMP 0x428284		
		sched.freem = newList
  0x4282fd		833d1c4b0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x428304		0f8570010000		JNE 0x42847a				
  0x42830a		48890d7f9a0900		MOVQ CX, runtime.sched+240(SB)		
		unlock(&sched.lock)
  0x428311		488d0598990900		LEAQ runtime.sched+16(SB), AX	
  0x428318		48890424		MOVQ AX, 0(SP)			
  0x42831c		e86f05feff		CALL runtime.unlock(SB)		
	mp := new(m)
  0x428321		488d0558670400		LEAQ 0x46758(IP), AX		
  0x428328		48890424		MOVQ AX, 0(SP)			
  0x42832c		e81f24feff		CALL runtime.newobject(SB)	
  0x428331		488b442408		MOVQ 0x8(SP), AX		
	mp.mstartfn = fn
  0x428336		833de34a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42833d		0f851b010000		JNE 0x42845e				
  0x428343		488b4c2448		MOVQ 0x48(SP), CX			
  0x428348		488988b8000000		MOVQ CX, 0xb8(AX)			
	mp := new(m)
  0x42834f		4889442418		MOVQ AX, 0x18(SP)	
	mcommoninit(mp)
  0x428354		48890424		MOVQ AX, 0(SP)			
  0x428358		e863deffff		CALL runtime.mcommoninit(SB)	
	if iscgo || GOOS == "solaris" || GOOS == "windows" || GOOS == "plan9" || GOOS == "darwin" {
  0x42835d		803d4a490b0000		CMPB $0x0, runtime.iscgo(SB)	
  0x428364		0f84bb000000		JE 0x428425			
		mp.g0 = malg(-1)
  0x42836a		c70424ffffffff		MOVL $-0x1, 0(SP)			
  0x428371		e80a410000		CALL runtime.malg(SB)			
  0x428376		488b442408		MOVQ 0x8(SP), AX			
  0x42837b		833d9e4a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x428382		0f858b000000		JNE 0x428413				
  0x428388		488b4c2418		MOVQ 0x18(SP), CX			
  0x42838d		488901			MOVQ AX, 0(CX)				
	mp.g0.m = mp
  0x428390		488b11			MOVQ 0(CX), DX				
  0x428393		8402			TESTB AL, 0(DX)				
  0x428395		833d844a0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42839c		7567			JNE 0x428405				
  0x42839e		48894a30		MOVQ CX, 0x30(DX)			
	if _p_ == _g_.m.p.ptr() {
  0x4283a2		488b442428		MOVQ 0x28(SP), AX	
  0x4283a7		488b5030		MOVQ 0x30(AX), DX	
  0x4283ab		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x4283b2		90			NOPL			
  0x4283b3		488b5c2440		MOVQ 0x40(SP), BX	
  0x4283b8		4839d3			CMPQ DX, BX		
  0x4283bb		7437			JE 0x4283f4		
	_g_.m.locks--
  0x4283bd		488b5030		MOVQ 0x30(AX), DX	
  0x4283c1		ff8a08010000		DECL 0x108(DX)		
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x4283c7		488b5030		MOVQ 0x30(AX), DX	
  0x4283cb		83ba0801000000		CMPL $0x0, 0x108(DX)	
  0x4283d2		7511			JNE 0x4283e5		
  0x4283d4		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x4283db		7408			JE 0x4283e5		
		_g_.stackguard0 = stackPreempt
  0x4283dd		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	return mp
  0x4283e5		48894c2450		MOVQ CX, 0x50(SP)	
  0x4283ea		488b6c2430		MOVQ 0x30(SP), BP	
  0x4283ef		4883c438		ADDQ $0x38, SP		
  0x4283f3		c3			RET			
		releasep()
  0x4283f4		e897620000		CALL runtime.releasep(SB)	
	_g_.m.locks--
  0x4283f9		488b442428		MOVQ 0x28(SP), AX	
	return mp
  0x4283fe		488b4c2418		MOVQ 0x18(SP), CX	
		releasep()
  0x428403		ebb8			JMP 0x4283bd		
	mp.g0.m = mp
  0x428405		488d7a30		LEAQ 0x30(DX), DI		
  0x428409		4889c8			MOVQ CX, AX			
  0x42840c		e86f120200		CALL runtime.gcWriteBarrier(SB)	
  0x428411		eb8f			JMP 0x4283a2			
		mp.g0 = malg(-1)
  0x428413		488b7c2418		MOVQ 0x18(SP), DI		
  0x428418		e863120200		CALL runtime.gcWriteBarrier(SB)	
	mp.g0.m = mp
  0x42841d		4889f9			MOVQ DI, CX		
		mp.g0 = malg(-1)
  0x428420		e96bffffff		JMP 0x428390		
		mp.g0 = malg(8192 * sys.StackGuardMultiplier)
  0x428425		c7042400200000		MOVL $0x2000, 0(SP)			
  0x42842c		e84f400000		CALL runtime.malg(SB)			
  0x428431		488b442408		MOVQ 0x8(SP), AX			
  0x428436		833de3490b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42843d		750d			JNE 0x42844c				
  0x42843f		488b4c2418		MOVQ 0x18(SP), CX			
  0x428444		488901			MOVQ AX, 0(CX)				
  0x428447		e944ffffff		JMP 0x428390				
  0x42844c		488b7c2418		MOVQ 0x18(SP), DI			
  0x428451		e82a120200		CALL runtime.gcWriteBarrier(SB)		
	mp.g0.m = mp
  0x428456		4889f9			MOVQ DI, CX		
		mp.g0 = malg(8192 * sys.StackGuardMultiplier)
  0x428459		e932ffffff		JMP 0x428390		
	mp.mstartfn = fn
  0x42845e		488db8b8000000		LEAQ 0xb8(AX), DI	
	mp := new(m)
  0x428465		4889c1			MOVQ AX, CX		
	mp.mstartfn = fn
  0x428468		488b442448		MOVQ 0x48(SP), AX		
  0x42846d		e80e120200		CALL runtime.gcWriteBarrier(SB)	
	mcommoninit(mp)
  0x428472		4889c8			MOVQ CX, AX		
	mp.mstartfn = fn
  0x428475		e9d5feffff		JMP 0x42834f		
		sched.freem = newList
  0x42847a		488d3d0f990900		LEAQ runtime.sched+240(SB), DI	
  0x428481		4889c8			MOVQ CX, AX			
  0x428484		e8f7110200		CALL runtime.gcWriteBarrier(SB)	
  0x428489		e983feffff		JMP 0x428311			
		acquirep(_p_) // temporarily borrow p for mallocs in this function
  0x42848e		488b442440		MOVQ 0x40(SP), AX		
  0x428493		48890424		MOVQ AX, 0(SP)			
  0x428497		e834600000		CALL runtime.acquirep(SB)	
	if _p_ == _g_.m.p.ptr() {
  0x42849c		488b442428		MOVQ 0x28(SP), AX	
		acquirep(_p_) // temporarily borrow p for mallocs in this function
  0x4284a1		e9b5fdffff		JMP 0x42825b		
func allocm(_p_ *p, fn func()) *m {
  0x4284a6		e8d5f30100		CALL runtime.morestack_noctxt(SB)	
  0x4284ab		e960fdffff		JMP runtime.allocm(SB)			

TEXT runtime.needm(SB) /usr/local/go/src/runtime/proc.go
func needm(x byte) {
  0x4284b0		4883ec38		SUBQ $0x38, SP		
  0x4284b4		48896c2430		MOVQ BP, 0x30(SP)	
  0x4284b9		488d6c2430		LEAQ 0x30(SP), BP	
	if (iscgo || GOOS == "windows") && !cgoHasExtraM {
  0x4284be		803de9470b0000		CMPB $0x0, runtime.iscgo(SB)		
  0x4284c5		740d			JE 0x4284d4				
  0x4284c7		803dd7470b0000		CMPB $0x0, runtime.cgoHasExtraM(SB)	
  0x4284ce		0f8424010000		JE 0x4285f8				
	mp := lockextra(false)
  0x4284d4		c6042400		MOVB $0x0, 0(SP)		
  0x4284d8		e8d3040000		CALL runtime.lockextra(SB)	
  0x4284dd		488b442408		MOVQ 0x8(SP), AX		
  0x4284e2		4889442420		MOVQ AX, 0x20(SP)		
	mp.needextram = mp.schedlink == 0
  0x4284e7		4883b85801000000	CMPQ $0x0, 0x158(AX)	
  0x4284ef		0f948028010000		SETE 0x128(AX)		
	extraMCount--
  0x4284f6		ff0dc8470b00		DECL runtime.extraMCount(SB)	
	unlockextra(mp.schedlink.ptr())
  0x4284fc		90			NOPL			
  0x4284fd		488b8858010000		MOVQ 0x158(AX), CX	
  0x428504		90			NOPL			
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x428505		48894c2428		MOVQ CX, 0x28(SP)		
  0x42850a		488d154f480b00		LEAQ runtime.extram(SB), DX	
  0x428511		48870a			XCHGQ CX, 0(DX)			
	msigsave(mp)
  0x428514		90			NOPL			
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x428515		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x428516		c7042402000000		MOVL $0x2, 0(SP)	
  0x42851d		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	sigprocmask(_SIG_SETMASK, nil, &mp.sigmask)
  0x428526		488d8880000000		LEAQ 0x80(AX), CX	
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x42852d		48894c2410		MOVQ CX, 0x10(SP)		
  0x428532		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x42853a		e8312c0200		CALL runtime.rtsigprocmask(SB)	
	sigblock()
  0x42853f		90			NOPL			
	sigprocmask(_SIG_SETMASK, &sigset_all, nil)
  0x428540		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x428541		c7042402000000		MOVL $0x2, 0(SP)		
  0x428548		488d05016b0900		LEAQ runtime.sigset_all(SB), AX	
  0x42854f		4889442408		MOVQ AX, 0x8(SP)		
  0x428554		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42855d		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x428565		e8062c0200		CALL runtime.rtsigprocmask(SB)	
	setg(mp.g0)
  0x42856a		488b442420		MOVQ 0x20(SP), AX	
  0x42856f		488b08			MOVQ 0(AX), CX		
  0x428572		48890c24		MOVQ CX, 0(SP)		
  0x428576		e8450a0200		CALL runtime.setg(SB)	
	_g_ := getg()
  0x42857b		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&x))) + 1024
  0x428584		488d4c2440		LEAQ 0x40(SP), CX	
  0x428589		90			NOPL			
  0x42858a		4881c100040000		ADDQ $0x400, CX		
  0x428591		48894808		MOVQ CX, 0x8(AX)	
	_g_.stack.lo = uintptr(noescape(unsafe.Pointer(&x))) - 32*1024
  0x428595		488d4c2440		LEAQ 0x40(SP), CX	
  0x42859a		90			NOPL			
  0x42859b		488d910080ffff		LEAQ 0xffff8000(CX), DX	
  0x4285a2		488910			MOVQ DX, 0(AX)		
	_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x4285a5		4881c17083ffff		ADDQ $-0x7c90, CX	
  0x4285ac		48894810		MOVQ CX, 0x10(AX)	
	asminit()
  0x4285b0		e88bf00100		CALL runtime.asminit(SB)	
	minit()
  0x4285b5		e8a696ffff		CALL runtime.minit(SB)	
	casgstatus(mp.curg, _Gdead, _Gsyscall)
  0x4285ba		488b442420		MOVQ 0x20(SP), AX		
  0x4285bf		488b80c0000000		MOVQ 0xc0(AX), AX		
  0x4285c6		48890424		MOVQ AX, 0(SP)			
  0x4285ca		48b80600000003000000	MOVQ $0x300000006, AX		
  0x4285d4		4889442408		MOVQ AX, 0x8(SP)		
  0x4285d9		e8c2e6ffff		CALL runtime.casgstatus(SB)	
	atomic.Xadd(&sched.ngsys, -1)
  0x4285de		b8ffffffff		MOVL $-0x1, AX			
  0x4285e3		488d0df6960900		LEAQ runtime.sched+64(SB), CX	
  0x4285ea		f00fc101		LOCK XADDL AX, 0(CX)		
}
  0x4285ee		488b6c2430		MOVQ 0x30(SP), BP	
  0x4285f3		4883c438		ADDQ $0x38, SP		
  0x4285f7		c3			RET			
		write(2, unsafe.Pointer(&earlycgocallback[0]), int32(len(earlycgocallback)))
  0x4285f8		488b05b9760900		MOVQ runtime.earlycgocallback+8(SB), AX	
  0x4285ff		488b0daa760900		MOVQ runtime.earlycgocallback(SB), CX	
  0x428606		4885c0			TESTQ AX, AX				
  0x428609		7627			JBE 0x428632				
  0x42860b		48c7042402000000	MOVQ $0x2, 0(SP)			
  0x428613		48894c2408		MOVQ CX, 0x8(SP)			
  0x428618		89442410		MOVL AX, 0x10(SP)			
  0x42861c		e87f280200		CALL runtime.write(SB)			
		exit(1)
  0x428621		c7042401000000		MOVL $0x1, 0(SP)	
  0x428628		e8f3270200		CALL runtime.exit(SB)	
  0x42862d		e9a2feffff		JMP 0x4284d4		
		write(2, unsafe.Pointer(&earlycgocallback[0]), int32(len(earlycgocallback)))
  0x428632		e8e998ffff		CALL runtime.panicindex(SB)	
  0x428637		0f0b			UD2				

TEXT runtime.newextram(SB) /usr/local/go/src/runtime/proc.go
func newextram() {
  0x428640		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428649		483b6110		CMPQ 0x10(CX), SP	
  0x42864d		7674			JBE 0x4286c3		
  0x42864f		4883ec28		SUBQ $0x28, SP		
  0x428653		48896c2420		MOVQ BP, 0x20(SP)	
  0x428658		488d6c2420		LEAQ 0x20(SP), BP	
	c := atomic.Xchg(&extraMWaiters, 0)
  0x42865d		31c0			XORL AX, AX				
  0x42865f		488d0d62460b00		LEAQ runtime.extraMWaiters(SB), CX	
  0x428666		8701			XCHGL AX, 0(CX)				
	if c > 0 {
  0x428668		85c0			TESTL AX, AX		
  0x42866a		762a			JBE 0x428696		
	c := atomic.Xchg(&extraMWaiters, 0)
  0x42866c		89442414		MOVL AX, 0x14(SP)	
  0x428670		31c9			XORL CX, CX		
		for i := uint32(0); i < c; i++ {
  0x428672		eb14			JMP 0x428688		
  0x428674		894c2410		MOVL CX, 0x10(SP)	
			oneNewExtraM()
  0x428678		e853000000		CALL runtime.oneNewExtraM(SB)	
		for i := uint32(0); i < c; i++ {
  0x42867d		8b442410		MOVL 0x10(SP), AX	
  0x428681		8d4801			LEAL 0x1(AX), CX	
  0x428684		8b442414		MOVL 0x14(SP), AX	
  0x428688		39c1			CMPL AX, CX		
  0x42868a		72e8			JB 0x428674		
  0x42868c		488b6c2420		MOVQ 0x20(SP), BP	
  0x428691		4883c428		ADDQ $0x28, SP		
  0x428695		c3			RET			
		mp := lockextra(true)
  0x428696		c6042401		MOVB $0x1, 0(SP)		
  0x42869a		e811030000		CALL runtime.lockextra(SB)	
  0x42869f		488b442408		MOVQ 0x8(SP), AX		
		unlockextra(mp)
  0x4286a4		90			NOPL			
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x4286a5		4889442418		MOVQ AX, 0x18(SP)		
  0x4286aa		4889c1			MOVQ AX, CX			
  0x4286ad		488d15ac460b00		LEAQ runtime.extram(SB), DX	
  0x4286b4		488702			XCHGQ AX, 0(DX)			
		if mp == nil {
  0x4286b7		4885c9			TESTQ CX, CX		
  0x4286ba		75d0			JNE 0x42868c		
			oneNewExtraM()
  0x4286bc		e80f000000		CALL runtime.oneNewExtraM(SB)	
  0x4286c1		ebc9			JMP 0x42868c			
func newextram() {
  0x4286c3		e8b8f10100		CALL runtime.morestack_noctxt(SB)	
  0x4286c8		e973ffffff		JMP runtime.newextram(SB)		

TEXT runtime.oneNewExtraM(SB) /usr/local/go/src/runtime/proc.go
func oneNewExtraM() {
  0x4286d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4286d9		483b6110		CMPQ 0x10(CX), SP	
  0x4286dd		0f8690010000		JBE 0x428873		
  0x4286e3		4883ec38		SUBQ $0x38, SP		
  0x4286e7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4286ec		488d6c2430		LEAQ 0x30(SP), BP	
	mp := allocm(nil, nil)
  0x4286f1		0f57c0			XORPS X0, X0		
  0x4286f4		0f110424		MOVUPS X0, 0(SP)	
  0x4286f8		e813fbffff		CALL runtime.allocm(SB)	
  0x4286fd		488b442410		MOVQ 0x10(SP), AX	
  0x428702		4889442418		MOVQ AX, 0x18(SP)	
	gp := malg(4096)
  0x428707		c7042400100000		MOVL $0x1000, 0(SP)	
  0x42870e		e86d3d0000		CALL runtime.malg(SB)	
  0x428713		488b442408		MOVQ 0x8(SP), AX	
  0x428718		4889442420		MOVQ AX, 0x20(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42871d		488d0d2cb10400		LEAQ 0x4b12c(IP), CX	
  0x428724		8401			TESTB AL, 0(CX)		
	gp.sched.pc = funcPC(goexit) + sys.PCQuantum
  0x428726		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x428727		488b0d22b10400		MOVQ 0x4b122(IP), CX	
	gp.sched.pc = funcPC(goexit) + sys.PCQuantum
  0x42872e		48ffc1			INCQ CX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x428731		90			NOPL			
	gp.sched.pc = funcPC(goexit) + sys.PCQuantum
  0x428732		48894840		MOVQ CX, 0x40(AX)	
	gp.sched.sp = gp.stack.hi
  0x428736		488b4808		MOVQ 0x8(AX), CX	
	gp.sched.sp -= 4 * sys.RegSize // extra space in case of reads slightly beyond frame
  0x42873a		4883c1e0		ADDQ $-0x20, CX		
  0x42873e		48894838		MOVQ CX, 0x38(AX)	
	gp.sched.lr = 0
  0x428742		48c7406000000000	MOVQ $0x0, 0x60(AX)	
	gp.sched.g = guintptr(unsafe.Pointer(gp))
  0x42874a		4889c2			MOVQ AX, DX		
  0x42874d		48894248		MOVQ AX, 0x48(DX)	
	gp.syscallpc = gp.sched.pc
  0x428751		488b4240		MOVQ 0x40(DX), AX	
  0x428755		48894278		MOVQ AX, 0x78(DX)	
	gp.syscallsp = gp.sched.sp
  0x428759		48894a70		MOVQ CX, 0x70(DX)	
	gp.stktopsp = gp.sched.sp
  0x42875d		488b4238		MOVQ 0x38(DX), AX	
  0x428761		48898280000000		MOVQ AX, 0x80(DX)	
	gp.gcscandone = true
  0x428768		66c782b40000000101	MOVW $0x101, 0xb4(DX)	
	casgstatus(gp, _Gidle, _Gdead)
  0x428771		48891424		MOVQ DX, 0(SP)			
  0x428775		48b80000000006000000	MOVQ $0x600000000, AX		
  0x42877f		4889442408		MOVQ AX, 0x8(SP)		
  0x428784		e817e5ffff		CALL runtime.casgstatus(SB)	
	gp.m = mp
  0x428789		833d90460b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x428790		0f85bd000000		JNE 0x428853				
  0x428796		488b4c2418		MOVQ 0x18(SP), CX			
  0x42879b		488b442420		MOVQ 0x20(SP), AX			
  0x4287a0		48894830		MOVQ CX, 0x30(AX)			
	mp.curg = gp
  0x4287a4		8401			TESTB AL, 0(CX)				
  0x4287a6		833d73460b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4287ad		0f858f000000		JNE 0x428842				
  0x4287b3		488981c0000000		MOVQ AX, 0xc0(CX)			
	mp.lockedInt++
  0x4287ba		ff8174020000		INCL 0x274(CX)		
	mp.lockedg.set(gp)
  0x4287c0		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4287c1		4889c2			MOVQ AX, DX		
  0x4287c4		48898168010000		MOVQ AX, 0x168(CX)	
	gp.lockedm.set(mp)
  0x4287cb		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x4287cc		48898ad8000000		MOVQ CX, 0xd8(DX)	
	gp.goid = int64(atomic.Xadd64(&sched.goidgen, 1))
  0x4287d3		b901000000		MOVL $0x1, CX			
  0x4287d8		488d1dc1940900		LEAQ runtime.sched(SB), BX	
  0x4287df		f0480fc10b		LOCK XADDQ CX, 0(BX)		
  0x4287e4		48ffc1			INCQ CX				
  0x4287e7		48898a98000000		MOVQ CX, 0x98(DX)		
	allgadd(gp)
  0x4287ee		48891424		MOVQ DX, 0(SP)			
  0x4287f2		e8e9d3ffff		CALL runtime.allgadd(SB)	
	atomic.Xadd(&sched.ngsys, +1)
  0x4287f7		b801000000		MOVL $0x1, AX			
  0x4287fc		488d0ddd940900		LEAQ runtime.sched+64(SB), CX	
  0x428803		f00fc101		LOCK XADDL AX, 0(CX)		
	mnext := lockextra(true)
  0x428807		c6042401		MOVB $0x1, 0(SP)		
  0x42880b		e8a0010000		CALL runtime.lockextra(SB)	
  0x428810		488b442408		MOVQ 0x8(SP), AX		
	mp.schedlink.set(mnext)
  0x428815		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428816		488b4c2418		MOVQ 0x18(SP), CX	
  0x42881b		48898158010000		MOVQ AX, 0x158(CX)	
	extraMCount++
  0x428822		ff059c440b00		INCL runtime.extraMCount(SB)	
	unlockextra(mp)
  0x428828		90			NOPL			
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x428829		48894c2428		MOVQ CX, 0x28(SP)		
  0x42882e		488d052b450b00		LEAQ runtime.extram(SB), AX	
  0x428835		488708			XCHGQ CX, 0(AX)			
  0x428838		488b6c2430		MOVQ 0x30(SP), BP		
  0x42883d		4883c438		ADDQ $0x38, SP			
  0x428841		c3			RET				
	mp.curg = gp
  0x428842		488db9c0000000		LEAQ 0xc0(CX), DI		
  0x428849		e8320e0200		CALL runtime.gcWriteBarrier(SB)	
  0x42884e		e967ffffff		JMP 0x4287ba			
	gp.m = mp
  0x428853		488b542420		MOVQ 0x20(SP), DX		
  0x428858		488d7a30		LEAQ 0x30(DX), DI		
  0x42885c		488b442418		MOVQ 0x18(SP), AX		
  0x428861		e81a0e0200		CALL runtime.gcWriteBarrier(SB)	
	mp.curg = gp
  0x428866		4889d0			MOVQ DX, AX		
  0x428869		488b4c2418		MOVQ 0x18(SP), CX	
	gp.m = mp
  0x42886e		e931ffffff		JMP 0x4287a4		
func oneNewExtraM() {
  0x428873		e808f00100		CALL runtime.morestack_noctxt(SB)	
  0x428878		e953feffff		JMP runtime.oneNewExtraM(SB)		

TEXT runtime.dropm(SB) /usr/local/go/src/runtime/proc.go
func dropm() {
  0x428880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428889		483b6110		CMPQ 0x10(CX), SP	
  0x42888d		0f8611010000		JBE 0x4289a4		
  0x428893		4883ec48		SUBQ $0x48, SP		
  0x428897		48896c2440		MOVQ BP, 0x40(SP)	
  0x42889c		488d6c2440		LEAQ 0x40(SP), BP	
	mp := getg().m
  0x4288a1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4288aa		488b4030		MOVQ 0x30(AX), AX	
  0x4288ae		4889442430		MOVQ AX, 0x30(SP)	
	casgstatus(mp.curg, _Gsyscall, _Gdead)
  0x4288b3		488b88c0000000		MOVQ 0xc0(AX), CX		
  0x4288ba		48890c24		MOVQ CX, 0(SP)			
  0x4288be		48b90300000006000000	MOVQ $0x600000003, CX		
  0x4288c8		48894c2408		MOVQ CX, 0x8(SP)		
  0x4288cd		e8cee3ffff		CALL runtime.casgstatus(SB)	
	atomic.Xadd(&sched.ngsys, +1)
  0x4288d2		b801000000		MOVL $0x1, AX			
  0x4288d7		488d0d02940900		LEAQ runtime.sched+64(SB), CX	
  0x4288de		f00fc101		LOCK XADDL AX, 0(CX)		
	sigmask := mp.sigmask
  0x4288e2		488b442430		MOVQ 0x30(SP), AX	
  0x4288e7		488b8880000000		MOVQ 0x80(AX), CX	
  0x4288ee		48894c2428		MOVQ CX, 0x28(SP)	
	sigblock()
  0x4288f3		90			NOPL			
	sigprocmask(_SIG_SETMASK, &sigset_all, nil)
  0x4288f4		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x4288f5		c7042402000000		MOVL $0x2, 0(SP)		
  0x4288fc		488d0d4d670900		LEAQ runtime.sigset_all(SB), CX	
  0x428903		48894c2408		MOVQ CX, 0x8(SP)		
  0x428908		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x428911		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x428919		e852280200		CALL runtime.rtsigprocmask(SB)	
	unminit()
  0x42891e		90			NOPL			
	unminitSignals()
  0x42891f		e8dcd00000		CALL runtime.unminitSignals(SB)	
	mnext := lockextra(true)
  0x428924		c6042401		MOVB $0x1, 0(SP)		
  0x428928		e883000000		CALL runtime.lockextra(SB)	
  0x42892d		488b442408		MOVQ 0x8(SP), AX		
	extraMCount++
  0x428932		ff058c430b00		INCL runtime.extraMCount(SB)	
	mp.schedlink.set(mnext)
  0x428938		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428939		488b4c2430		MOVQ 0x30(SP), CX	
  0x42893e		48898158010000		MOVQ AX, 0x158(CX)	
	setg(nil)
  0x428945		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x42894d		e86e060200		CALL runtime.setg(SB)	
	unlockextra(mp)
  0x428952		90			NOPL			
	atomic.Storeuintptr(&extram, uintptr(unsafe.Pointer(mp)))
  0x428953		488b442430		MOVQ 0x30(SP), AX		
  0x428958		4889442438		MOVQ AX, 0x38(SP)		
  0x42895d		488d0dfc430b00		LEAQ runtime.extram(SB), CX	
  0x428964		488701			XCHGQ AX, 0(CX)			
	msigrestore(sigmask)
  0x428967		488b442428		MOVQ 0x28(SP), AX	
  0x42896c		4889442420		MOVQ AX, 0x20(SP)	
  0x428971		90			NOPL			
	sigprocmask(_SIG_SETMASK, &sigmask, nil)
  0x428972		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x428973		c7042402000000		MOVL $0x2, 0(SP)		
  0x42897a		488d442420		LEAQ 0x20(SP), AX		
  0x42897f		4889442408		MOVQ AX, 0x8(SP)		
  0x428984		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42898d		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x428995		e8d6270200		CALL runtime.rtsigprocmask(SB)	
  0x42899a		488b6c2440		MOVQ 0x40(SP), BP		
  0x42899f		4883c448		ADDQ $0x48, SP			
  0x4289a3		c3			RET				
func dropm() {
  0x4289a4		e8d7ee0100		CALL runtime.morestack_noctxt(SB)	
  0x4289a9		e9d2feffff		JMP runtime.dropm(SB)			

TEXT runtime.lockextra(SB) /usr/local/go/src/runtime/proc.go
func lockextra(nilokay bool) *m {
  0x4289b0		4883ec18		SUBQ $0x18, SP		
  0x4289b4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4289b9		488d6c2410		LEAQ 0x10(SP), BP	
	for {
  0x4289be		0fb64c2420		MOVZX 0x20(SP), CX	
  0x4289c3		31c0			XORL AX, AX		
  0x4289c5		eb07			JMP 0x4289ce		
		old := atomic.Loaduintptr(&extram)
  0x4289c7		0fb65c2420		MOVZX 0x20(SP), BX	
func lockextra(nilokay bool) *m {
  0x4289cc		89d9			MOVL BX, CX		
			if !incr {
  0x4289ce		8844240f		MOVB AL, 0xf(SP)	
		old := atomic.Loaduintptr(&extram)
  0x4289d2		488b1d87430b00		MOVQ runtime.extram(SB), BX	
		if old == locked {
  0x4289d9		4883fb01		CMPQ $0x1, BX		
  0x4289dd		7475			JE 0x428a54		
		if old == 0 && !nilokay {
  0x4289df		4885db			TESTQ BX, BX		
  0x4289e2		7504			JNE 0x4289e8		
func lockextra(nilokay bool) *m {
  0x4289e4		84c9			TESTL CL, CL		
		if old == 0 && !nilokay {
  0x4289e6		7443			JE 0x428a2b		
		if atomic.Casuintptr(&extram, old, locked) {
  0x4289e8		4889d8			MOVQ BX, AX			
  0x4289eb		488d356e430b00		LEAQ runtime.extram(SB), SI	
  0x4289f2		bf01000000		MOVL $0x1, DI			
  0x4289f7		f0480fb13e		LOCK CMPXCHGQ DI, 0(SI)		
  0x4289fc		410f94c0		SETE R8				
  0x428a00		4584c0			TESTL R8, R8			
  0x428a03		7517			JNE 0x428a1c			
		yield()
  0x428a05		488b0514af0400		MOVQ 0x4af14(IP), AX	
  0x428a0c		488d150daf0400		LEAQ 0x4af0d(IP), DX	
  0x428a13		ffd0			CALL AX			
			if !incr {
  0x428a15		0fb644240f		MOVZX 0xf(SP), AX	
		continue
  0x428a1a		ebab			JMP 0x4289c7		
			return (*m)(unsafe.Pointer(old))
  0x428a1c		48895c2428		MOVQ BX, 0x28(SP)	
  0x428a21		488b6c2410		MOVQ 0x10(SP), BP	
  0x428a26		4883c418		ADDQ $0x18, SP		
  0x428a2a		c3			RET			
			if !incr {
  0x428a2b		84c0			TESTL AL, AL		
  0x428a2d		7413			JE 0x428a42		
			usleep(1)
  0x428a2f		c7042401000000		MOVL $0x1, 0(SP)	
  0x428a36		e8c5240200		CALL runtime.usleep(SB)	
  0x428a3b		b801000000		MOVL $0x1, AX		
			continue
  0x428a40		eb85			JMP 0x4289c7		
				atomic.Xadd(&extraMWaiters, 1)
  0x428a42		b801000000		MOVL $0x1, AX				
  0x428a47		488d157a420b00		LEAQ runtime.extraMWaiters(SB), DX	
  0x428a4e		f00fc102		LOCK XADDL AX, 0(DX)			
				incr = true
  0x428a52		ebdb			JMP 0x428a2f		
			yield()
  0x428a54		488b05c5ae0400		MOVQ 0x4aec5(IP), AX	
  0x428a5b		488d15beae0400		LEAQ 0x4aebe(IP), DX	
  0x428a62		ffd0			CALL AX			
			if !incr {
  0x428a64		0fb644240f		MOVZX 0xf(SP), AX	
			continue
  0x428a69		e959ffffff		JMP 0x4289c7		

TEXT runtime.newm(SB) /usr/local/go/src/runtime/proc.go
func newm(fn func(), _p_ *p) {
  0x428a70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428a79		483b6110		CMPQ 0x10(CX), SP	
  0x428a7d		0f8622010000		JBE 0x428ba5		
  0x428a83		4883ec28		SUBQ $0x28, SP		
  0x428a87		48896c2420		MOVQ BP, 0x20(SP)	
  0x428a8c		488d6c2420		LEAQ 0x20(SP), BP	
	mp := allocm(_p_, fn)
  0x428a91		488b442438		MOVQ 0x38(SP), AX	
  0x428a96		48890424		MOVQ AX, 0(SP)		
  0x428a9a		488b4c2430		MOVQ 0x30(SP), CX	
  0x428a9f		48894c2408		MOVQ CX, 0x8(SP)	
  0x428aa4		e867f7ffff		CALL runtime.allocm(SB)	
  0x428aa9		488b442410		MOVQ 0x10(SP), AX	
	mp.nextp.set(_p_)
  0x428aae		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x428aaf		488b4c2438		MOVQ 0x38(SP), CX	
  0x428ab4		488988d8000000		MOVQ CX, 0xd8(AX)	
	mp.sigmask = initSigmask
  0x428abb		488b0dbe420b00		MOVQ runtime.initSigmask(SB), CX	
  0x428ac2		48898880000000		MOVQ CX, 0x80(AX)			
	if gp := getg(); gp != nil && gp.m != nil && (gp.m.lockedExt != 0 || gp.m.incgo) && GOOS != "plan9" {
  0x428ac9		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428ad2		4885c9			TESTQ CX, CX		
  0x428ad5		741f			JE 0x428af6		
  0x428ad7		488b4930		MOVQ 0x30(CX), CX	
  0x428adb		4885c9			TESTQ CX, CX		
  0x428ade		7416			JE 0x428af6		
  0x428ae0		83b97002000000		CMPL $0x0, 0x270(CX)	
  0x428ae7		0f8491000000		JE 0x428b7e		
  0x428aed		b901000000		MOVL $0x1, CX		
  0x428af2		84c9			TESTL CL, CL		
  0x428af4		7513			JNE 0x428b09		
	newm1(mp)
  0x428af6		48890424		MOVQ AX, 0(SP)		
  0x428afa		e8b1000000		CALL runtime.newm1(SB)	
}
  0x428aff		488b6c2420		MOVQ 0x20(SP), BP	
  0x428b04		4883c428		ADDQ $0x28, SP		
  0x428b08		c3			RET			
	mp := allocm(_p_, fn)
  0x428b09		4889442418		MOVQ AX, 0x18(SP)	
		lock(&newmHandoff.lock)
  0x428b0e		488d054b430b00		LEAQ runtime.newmHandoff(SB), AX	
  0x428b15		48890424		MOVQ AX, 0(SP)				
  0x428b19		e8c2fbfdff		CALL runtime.lock(SB)			
		if newmHandoff.haveTemplateThread == 0 {
  0x428b1e		833d5b430b0000		CMPL $0x0, runtime.newmHandoff+32(SB)	
  0x428b25		7463			JE 0x428b8a				
		mp.schedlink = newmHandoff.newm
  0x428b27		488b053a430b00		MOVQ runtime.newmHandoff+8(SB), AX	
  0x428b2e		488b4c2418		MOVQ 0x18(SP), CX			
  0x428b33		48898158010000		MOVQ AX, 0x158(CX)			
		newmHandoff.newm.set(mp)
  0x428b3a		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428b3b		48890d26430b00		MOVQ CX, runtime.newmHandoff+8(SB)	
		if newmHandoff.waiting {
  0x428b42		803d27430b0000		CMPB $0x0, runtime.newmHandoff+16(SB)	
  0x428b49		751a			JNE 0x428b65				
		unlock(&newmHandoff.lock)
  0x428b4b		488d050e430b00		LEAQ runtime.newmHandoff(SB), AX	
  0x428b52		48890424		MOVQ AX, 0(SP)				
  0x428b56		e835fdfdff		CALL runtime.unlock(SB)			
		return
  0x428b5b		488b6c2420		MOVQ 0x20(SP), BP	
  0x428b60		4883c428		ADDQ $0x28, SP		
  0x428b64		c3			RET			
			newmHandoff.waiting = false
  0x428b65		c60504430b0000		MOVB $0x0, runtime.newmHandoff+16(SB)	
			notewakeup(&newmHandoff.wake)
  0x428b6c		488d0505430b00		LEAQ runtime.newmHandoff+24(SB), AX	
  0x428b73		48890424		MOVQ AX, 0(SP)				
  0x428b77		e8e4fdfdff		CALL runtime.notewakeup(SB)		
  0x428b7c		ebcd			JMP 0x428b4b				
	if gp := getg(); gp != nil && gp.m != nil && (gp.m.lockedExt != 0 || gp.m.incgo) && GOOS != "plan9" {
  0x428b7e		0fb68919010000		MOVZX 0x119(CX), CX	
  0x428b85		e968ffffff		JMP 0x428af2		
			throw("on a locked thread with no template thread")
  0x428b8a		488d059ba00400		LEAQ 0x4a09b(IP), AX	
  0x428b91		48890424		MOVQ AX, 0(SP)		
  0x428b95		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x428b9e		e8dda8ffff		CALL runtime.throw(SB)	
  0x428ba3		0f0b			UD2			
func newm(fn func(), _p_ *p) {
  0x428ba5		e8d6ec0100		CALL runtime.morestack_noctxt(SB)	
  0x428baa		e9c1feffff		JMP runtime.newm(SB)			

TEXT runtime.newm1(SB) /usr/local/go/src/runtime/proc.go
func newm1(mp *m) {
  0x428bb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428bb9		483b6110		CMPQ 0x10(CX), SP	
  0x428bbd		0f8601010000		JBE 0x428cc4		
  0x428bc3		4883ec38		SUBQ $0x38, SP		
  0x428bc7		48896c2430		MOVQ BP, 0x30(SP)	
  0x428bcc		488d6c2430		LEAQ 0x30(SP), BP	
	if iscgo {
  0x428bd1		803dd6400b0000		CMPB $0x0, runtime.iscgo(SB)	
  0x428bd8		0f8493000000		JE 0x428c71			
		var ts cgothreadstart
  0x428bde		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x428be7		0f57c0			XORPS X0, X0		
  0x428bea		0f11442420		MOVUPS X0, 0x20(SP)	
		if _cgo_thread_start == nil {
  0x428bef		48833df98c090000	CMPQ $0x0, _cgo_thread_start(SB)	
  0x428bf7		0f84ac000000		JE 0x428ca9				
		ts.g.set(mp.g0)
  0x428bfd		90			NOPL			
  0x428bfe		488b442440		MOVQ 0x40(SP), AX	
  0x428c03		488b08			MOVQ 0(AX), CX		
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x428c06		48894c2418		MOVQ CX, 0x18(SP)	
		ts.tls = (*uint64)(unsafe.Pointer(&mp.tls[0]))
  0x428c0b		480588000000		ADDQ $0x88, AX		
  0x428c11		4889442420		MOVQ AX, 0x20(SP)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x428c16		488d05ebac0400		LEAQ 0x4aceb(IP), AX	
  0x428c1d		8400			TESTB AL, 0(AX)		
  0x428c1f		488b05e2ac0400		MOVQ 0x4ace2(IP), AX	
		ts.fn = unsafe.Pointer(funcPC(mstart))
  0x428c26		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x428c27		90			NOPL			
		ts.fn = unsafe.Pointer(funcPC(mstart))
  0x428c28		4889442428		MOVQ AX, 0x28(SP)	
		execLock.rlock() // Prevent process clone.
  0x428c2d		488d056c420b00		LEAQ runtime.execLock(SB), AX		
  0x428c34		48890424		MOVQ AX, 0(SP)				
  0x428c38		e8d3960000		CALL runtime.(*rwmutex).rlock(SB)	
		asmcgocall(_cgo_thread_start, unsafe.Pointer(&ts))
  0x428c3d		488b05ac8c0900		MOVQ _cgo_thread_start(SB), AX	
  0x428c44		48890424		MOVQ AX, 0(SP)			
  0x428c48		488d442418		LEAQ 0x18(SP), AX		
  0x428c4d		4889442408		MOVQ AX, 0x8(SP)		
  0x428c52		e8a9020200		CALL runtime.asmcgocall(SB)	
		execLock.runlock()
  0x428c57		488d0542420b00		LEAQ runtime.execLock(SB), AX		
  0x428c5e		48890424		MOVQ AX, 0(SP)				
  0x428c62		e839970000		CALL runtime.(*rwmutex).runlock(SB)	
		return
  0x428c67		488b6c2430		MOVQ 0x30(SP), BP	
  0x428c6c		4883c438		ADDQ $0x38, SP		
  0x428c70		c3			RET			
	execLock.rlock() // Prevent process clone.
  0x428c71		488d0528420b00		LEAQ runtime.execLock(SB), AX		
  0x428c78		48890424		MOVQ AX, 0(SP)				
  0x428c7c		e88f960000		CALL runtime.(*rwmutex).rlock(SB)	
	newosproc(mp)
  0x428c81		488b442440		MOVQ 0x40(SP), AX		
  0x428c86		48890424		MOVQ AX, 0(SP)			
  0x428c8a		e8e188ffff		CALL runtime.newosproc(SB)	
	execLock.runlock()
  0x428c8f		488d050a420b00		LEAQ runtime.execLock(SB), AX		
  0x428c96		48890424		MOVQ AX, 0(SP)				
  0x428c9a		e801970000		CALL runtime.(*rwmutex).runlock(SB)	
}
  0x428c9f		488b6c2430		MOVQ 0x30(SP), BP	
  0x428ca4		4883c438		ADDQ $0x38, SP		
  0x428ca8		c3			RET			
			throw("_cgo_thread_start missing")
  0x428ca9		488d05ec820400		LEAQ 0x482ec(IP), AX	
  0x428cb0		48890424		MOVQ AX, 0(SP)		
  0x428cb4		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x428cbd		e8bea7ffff		CALL runtime.throw(SB)	
  0x428cc2		0f0b			UD2			
func newm1(mp *m) {
  0x428cc4		e8b7eb0100		CALL runtime.morestack_noctxt(SB)	
  0x428cc9		e9e2feffff		JMP runtime.newm1(SB)			

TEXT runtime.templateThread(SB) /usr/local/go/src/runtime/proc.go
func templateThread() {
  0x428cd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428cd9		483b6110		CMPQ 0x10(CX), SP	
  0x428cdd		0f86f2000000		JBE 0x428dd5		
  0x428ce3		4883ec18		SUBQ $0x18, SP		
  0x428ce7		48896c2410		MOVQ BP, 0x10(SP)	
  0x428cec		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x428cf1		488d05b88f0900		LEAQ runtime.sched+16(SB), AX	
  0x428cf8		48890424		MOVQ AX, 0(SP)			
  0x428cfc		e8dff9fdff		CALL runtime.lock(SB)		
	sched.nmsys++
  0x428d01		ff05cd8f0900		INCL runtime.sched+52(SB)	
	checkdead()
  0x428d07		e8245c0000		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x428d0c		488d059d8f0900		LEAQ runtime.sched+16(SB), AX	
  0x428d13		48890424		MOVQ AX, 0(SP)			
  0x428d17		e874fbfdff		CALL runtime.unlock(SB)		
	for {
  0x428d1c		e9a2000000		JMP 0x428dc3		
				next := newm.schedlink.ptr()
  0x428d21		488b8858010000		MOVQ 0x158(AX), CX	
  0x428d28		90			NOPL			
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x428d29		48894c2408		MOVQ CX, 0x8(SP)	
				newm.schedlink = 0
  0x428d2e		48c7805801000000000000	MOVQ $0x0, 0x158(AX)	
				newm1(newm)
  0x428d39		48890424		MOVQ AX, 0(SP)		
  0x428d3d		e86efeffff		CALL runtime.newm1(SB)	
			for newm != nil {
  0x428d42		488b442408		MOVQ 0x8(SP), AX	
  0x428d47		4885c0			TESTQ AX, AX		
  0x428d4a		75d5			JNE 0x428d21		
			lock(&newmHandoff.lock)
  0x428d4c		488d050d410b00		LEAQ runtime.newmHandoff(SB), AX	
  0x428d53		48890424		MOVQ AX, 0(SP)				
  0x428d57		e884f9fdff		CALL runtime.lock(SB)			
		for newmHandoff.newm != 0 {
  0x428d5c		488b0505410b00		MOVQ runtime.newmHandoff+8(SB), AX	
  0x428d63		4885c0			TESTQ AX, AX				
  0x428d66		7428			JE 0x428d90				
			newm := newmHandoff.newm.ptr()
  0x428d68		90			NOPL			
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x428d69		4889442408		MOVQ AX, 0x8(SP)	
			newmHandoff.newm = 0
  0x428d6e		48c705ef400b0000000000	MOVQ $0x0, runtime.newmHandoff+8(SB)	
			unlock(&newmHandoff.lock)
  0x428d79		488d0de0400b00		LEAQ runtime.newmHandoff(SB), CX	
  0x428d80		48890c24		MOVQ CX, 0(SP)				
  0x428d84		e807fbfdff		CALL runtime.unlock(SB)			
			for newm != nil {
  0x428d89		488b442408		MOVQ 0x8(SP), AX	
  0x428d8e		ebb7			JMP 0x428d47		
		newmHandoff.waiting = true
  0x428d90		c605d9400b0001		MOVB $0x1, runtime.newmHandoff+16(SB)	
		noteclear(&newmHandoff.wake)
  0x428d97		90			NOPL			
	n.key = 0
  0x428d98		48c705d5400b0000000000	MOVQ $0x0, runtime.newmHandoff+24(SB)	
		unlock(&newmHandoff.lock)
  0x428da3		488d05b6400b00		LEAQ runtime.newmHandoff(SB), AX	
  0x428daa		48890424		MOVQ AX, 0(SP)				
  0x428dae		e8ddfafdff		CALL runtime.unlock(SB)			
		notesleep(&newmHandoff.wake)
  0x428db3		488d05be400b00		LEAQ runtime.newmHandoff+24(SB), AX	
  0x428dba		48890424		MOVQ AX, 0(SP)				
  0x428dbe		e86dfcfdff		CALL runtime.notesleep(SB)		
		lock(&newmHandoff.lock)
  0x428dc3		488d0596400b00		LEAQ runtime.newmHandoff(SB), AX	
  0x428dca		48890424		MOVQ AX, 0(SP)				
  0x428dce		e80df9fdff		CALL runtime.lock(SB)			
		for newmHandoff.newm != 0 {
  0x428dd3		eb87			JMP 0x428d5c		
func templateThread() {
  0x428dd5		e8a6ea0100		CALL runtime.morestack_noctxt(SB)	
  0x428dda		e9f1feffff		JMP runtime.templateThread(SB)		

TEXT runtime.stopm(SB) /usr/local/go/src/runtime/proc.go
func stopm() {
  0x428de0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428de9		483b6110		CMPQ 0x10(CX), SP	
  0x428ded		0f8647010000		JBE 0x428f3a		
  0x428df3		4883ec20		SUBQ $0x20, SP		
  0x428df7		48896c2418		MOVQ BP, 0x18(SP)	
  0x428dfc		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x428e01		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks != 0 {
  0x428e0a		488b4830		MOVQ 0x30(AX), CX	
  0x428e0e		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x428e15		0f8504010000		JNE 0x428f1f		
	if _g_.m.p != 0 {
  0x428e1b		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x428e23		0f85db000000		JNE 0x428f04		
	if _g_.m.spinning {
  0x428e29		80b91401000000		CMPB $0x0, 0x114(CX)	
  0x428e30		0f85b3000000		JNE 0x428ee9		
	_g_ := getg()
  0x428e36		4889442410		MOVQ AX, 0x10(SP)	
	lock(&sched.lock)
  0x428e3b		488d056e8e0900		LEAQ runtime.sched+16(SB), AX	
  0x428e42		48890424		MOVQ AX, 0(SP)			
  0x428e46		e895f8fdff		CALL runtime.lock(SB)		
	mput(_g_.m)
  0x428e4b		488b442410		MOVQ 0x10(SP), AX	
  0x428e50		488b4830		MOVQ 0x30(AX), CX	
  0x428e54		90			NOPL			
	mp.schedlink = sched.midle
  0x428e55		488b155c8e0900		MOVQ runtime.sched+24(SB), DX	
  0x428e5c		48899158010000		MOVQ DX, 0x158(CX)		
	sched.midle.set(mp)
  0x428e63		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x428e64		48890d4d8e0900		MOVQ CX, runtime.sched+24(SB)	
	sched.nmidle++
  0x428e6b		ff054f8e0900		INCL runtime.sched+32(SB)	
	checkdead()
  0x428e71		e8ba5a0000		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x428e76		488d05338e0900		LEAQ runtime.sched+16(SB), AX	
  0x428e7d		48890424		MOVQ AX, 0(SP)			
  0x428e81		e80afafdff		CALL runtime.unlock(SB)		
	notesleep(&_g_.m.park)
  0x428e86		488b442410		MOVQ 0x10(SP), AX		
  0x428e8b		488b4830		MOVQ 0x30(AX), CX		
  0x428e8f		8401			TESTB AL, 0(CX)			
  0x428e91		4881c148010000		ADDQ $0x148, CX			
  0x428e98		48890c24		MOVQ CX, 0(SP)			
  0x428e9c		e88ffbfdff		CALL runtime.notesleep(SB)	
	noteclear(&_g_.m.park)
  0x428ea1		488b442410		MOVQ 0x10(SP), AX	
  0x428ea6		488b4830		MOVQ 0x30(AX), CX	
  0x428eaa		90			NOPL			
	n.key = 0
  0x428eab		48c7814801000000000000	MOVQ $0x0, 0x148(CX)	
	acquirep(_g_.m.nextp.ptr())
  0x428eb6		488b4830		MOVQ 0x30(AX), CX		
  0x428eba		488b89d8000000		MOVQ 0xd8(CX), CX		
  0x428ec1		90			NOPL				
  0x428ec2		48890c24		MOVQ CX, 0(SP)			
  0x428ec6		e805560000		CALL runtime.acquirep(SB)	
	_g_.m.nextp = 0
  0x428ecb		488b442410		MOVQ 0x10(SP), AX	
  0x428ed0		488b4030		MOVQ 0x30(AX), AX	
  0x428ed4		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
}
  0x428edf		488b6c2418		MOVQ 0x18(SP), BP	
  0x428ee4		4883c420		ADDQ $0x20, SP		
  0x428ee8		c3			RET			
		throw("stopm spinning")
  0x428ee9		488d052c6f0400		LEAQ 0x46f2c(IP), AX	
  0x428ef0		48890424		MOVQ AX, 0(SP)		
  0x428ef4		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x428efd		e87ea5ffff		CALL runtime.throw(SB)	
  0x428f02		0f0b			UD2			
		throw("stopm holding p")
  0x428f04		488d05fd6f0400		LEAQ 0x46ffd(IP), AX	
  0x428f0b		48890424		MOVQ AX, 0(SP)		
  0x428f0f		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x428f18		e863a5ffff		CALL runtime.throw(SB)	
  0x428f1d		0f0b			UD2			
		throw("stopm holding locks")
  0x428f1f		488d05e6750400		LEAQ 0x475e6(IP), AX	
  0x428f26		48890424		MOVQ AX, 0(SP)		
  0x428f2a		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x428f33		e848a5ffff		CALL runtime.throw(SB)	
  0x428f38		0f0b			UD2			
func stopm() {
  0x428f3a		e841e90100		CALL runtime.morestack_noctxt(SB)	
  0x428f3f		e99cfeffff		JMP runtime.stopm(SB)			

TEXT runtime.mspinning(SB) /usr/local/go/src/runtime/proc.go
	getg().m.spinning = true
  0x428f50		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x428f59		488b4030		MOVQ 0x30(AX), AX	
  0x428f5d		c6801401000001		MOVB $0x1, 0x114(AX)	
}
  0x428f64		c3			RET			

TEXT runtime.startm(SB) /usr/local/go/src/runtime/proc.go
func startm(_p_ *p, spinning bool) {
  0x428f70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x428f79		483b6110		CMPQ 0x10(CX), SP	
  0x428f7d		0f86fa010000		JBE 0x42917d		
  0x428f83		4883ec28		SUBQ $0x28, SP		
  0x428f87		48896c2420		MOVQ BP, 0x20(SP)	
  0x428f8c		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&sched.lock)
  0x428f91		488d05188d0900		LEAQ runtime.sched+16(SB), AX	
  0x428f98		48890424		MOVQ AX, 0(SP)			
  0x428f9c		e83ff7fdff		CALL runtime.lock(SB)		
	if _p_ == nil {
  0x428fa1		488b442430		MOVQ 0x30(SP), AX	
  0x428fa6		4885c0			TESTQ AX, AX		
  0x428fa9		0f84f7000000		JE 0x4290a6		
	mp.nextp.set(_p_)
  0x428faf		4889442410		MOVQ AX, 0x10(SP)	
	mp := mget()
  0x428fb4		90			NOPL			
	mp := sched.midle.ptr()
  0x428fb5		488b0dfc8c0900		MOVQ runtime.sched+24(SB), CX	
  0x428fbc		90			NOPL				
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x428fbd		48894c2418		MOVQ CX, 0x18(SP)	
	if mp != nil {
  0x428fc2		4885c9			TESTQ CX, CX		
  0x428fc5		7414			JE 0x428fdb		
		sched.midle = mp.schedlink
  0x428fc7		488b9158010000		MOVQ 0x158(CX), DX		
  0x428fce		488915e38c0900		MOVQ DX, runtime.sched+24(SB)	
		sched.nmidle--
  0x428fd5		ff0de58c0900		DECL runtime.sched+32(SB)	
	unlock(&sched.lock)
  0x428fdb		488d05ce8c0900		LEAQ runtime.sched+16(SB), AX	
  0x428fe2		48890424		MOVQ AX, 0(SP)			
  0x428fe6		e8a5f8fdff		CALL runtime.unlock(SB)		
	if mp != nil {
  0x428feb		488b442418		MOVQ 0x18(SP), AX	
  0x428ff0		4885c0			TESTQ AX, AX		
	if mp == nil {
  0x428ff3		747c			JE 0x429071		
	if mp.spinning {
  0x428ff5		80b81401000000		CMPB $0x0, 0x114(AX)	
  0x428ffc		0f8545010000		JNE 0x429147		
	if mp.nextp != 0 {
  0x429002		4883b8d800000000	CMPQ $0x0, 0xd8(AX)	
  0x42900a		0f851c010000		JNE 0x42912c		
func startm(_p_ *p, spinning bool) {
  0x429010		0fb64c2438		MOVZX 0x38(SP), CX	
  0x429015		84c9			TESTL CL, CL		
	if spinning && !runqempty(_p_) {
  0x429017		7536			JNE 0x42904f		
  0x429019		31d2			XORL DX, DX		
  0x42901b		84d2			TESTL DL, DL		
  0x42901d		0f85ee000000		JNE 0x429111		
	mp.spinning = spinning
  0x429023		888814010000		MOVB CL, 0x114(AX)	
	mp.nextp.set(_p_)
  0x429029		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42902a		488b4c2410		MOVQ 0x10(SP), CX	
  0x42902f		488988d8000000		MOVQ CX, 0xd8(AX)	
	notewakeup(&mp.park)
  0x429036		480548010000		ADDQ $0x148, AX			
  0x42903c		48890424		MOVQ AX, 0(SP)			
  0x429040		e81bf9fdff		CALL runtime.notewakeup(SB)	
}
  0x429045		488b6c2420		MOVQ 0x20(SP), BP	
  0x42904a		4883c428		ADDQ $0x28, SP		
  0x42904e		c3			RET			
	if spinning && !runqempty(_p_) {
  0x42904f		488b442410		MOVQ 0x10(SP), AX		
  0x429054		48890424		MOVQ AX, 0(SP)			
  0x429058		e8b3730000		CALL runtime.runqempty(SB)	
  0x42905d		0fb6542408		MOVZX 0x8(SP), DX		
  0x429062		83f201			XORL $0x1, DX			
	mp.spinning = spinning
  0x429065		488b442418		MOVQ 0x18(SP), AX	
  0x42906a		0fb64c2438		MOVZX 0x38(SP), CX	
	if spinning && !runqempty(_p_) {
  0x42906f		ebaa			JMP 0x42901b		
		newm(fn, _p_)
  0x429071		0fb6442438		MOVZX 0x38(SP), AX	
  0x429076		4885c0			TESTQ AX, AX		
  0x429079		b800000000		MOVL $0x0, AX		
  0x42907e		488d0d7ba80400		LEAQ 0x4a87b(IP), CX	
  0x429085		480f45c1		CMOVNE CX, AX		
  0x429089		48890424		MOVQ AX, 0(SP)		
  0x42908d		488b442410		MOVQ 0x10(SP), AX	
  0x429092		4889442408		MOVQ AX, 0x8(SP)	
  0x429097		e8d4f9ffff		CALL runtime.newm(SB)	
		if spinning {
  0x42909c		488b6c2420		MOVQ 0x20(SP), BP	
  0x4290a1		4883c428		ADDQ $0x28, SP		
  0x4290a5		c3			RET			
		_p_ = pidleget()
  0x4290a6		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x4290a7		488b053a8c0900		MOVQ runtime.sched+72(SB), AX	
  0x4290ae		90			NOPL				
	if _p_ != nil {
  0x4290af		4885c0			TESTQ AX, AX		
  0x4290b2		741e			JE 0x4290d2		
		sched.pidle = _p_.link
  0x4290b4		488b4810		MOVQ 0x10(AX), CX		
  0x4290b8		48890d298c0900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x4290bf		b9ffffffff		MOVL $-0x1, CX			
  0x4290c4		488d15258c0900		LEAQ runtime.sched+80(SB), DX	
  0x4290cb		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x4290cf		4885c0			TESTQ AX, AX		
		if _p_ == nil {
  0x4290d2		0f85d7feffff		JNE 0x428faf		
			unlock(&sched.lock)
  0x4290d8		488d05d18b0900		LEAQ runtime.sched+16(SB), AX	
  0x4290df		48890424		MOVQ AX, 0(SP)			
  0x4290e3		e8a8f7fdff		CALL runtime.unlock(SB)		
func startm(_p_ *p, spinning bool) {
  0x4290e8		0fb6442438		MOVZX 0x38(SP), AX	
  0x4290ed		84c0			TESTL AL, AL		
			if spinning {
  0x4290ef		7416			JE 0x429107		
				if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x4290f1		b8ffffffff		MOVL $-0x1, AX			
  0x4290f6		488d0df78b0900		LEAQ runtime.sched+84(SB), CX	
  0x4290fd		f00fc101		LOCK XADDL AX, 0(CX)		
  0x429101		ffc8			DECL AX				
  0x429103		85c0			TESTL AX, AX			
  0x429105		7c5b			JL 0x429162			
			return
  0x429107		488b6c2420		MOVQ 0x20(SP), BP	
  0x42910c		4883c428		ADDQ $0x28, SP		
  0x429110		c3			RET			
		throw("startm: p has runnable gs")
  0x429111		488d052d800400		LEAQ 0x4802d(IP), AX	
  0x429118		48890424		MOVQ AX, 0(SP)		
  0x42911c		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x429125		e856a3ffff		CALL runtime.throw(SB)	
  0x42912a		0f0b			UD2			
		throw("startm: m has p")
  0x42912c		488d05c66d0400		LEAQ 0x46dc6(IP), AX	
  0x429133		48890424		MOVQ AX, 0(SP)		
  0x429137		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x429140		e83ba3ffff		CALL runtime.throw(SB)	
  0x429145		0f0b			UD2			
		throw("startm: m is spinning")
  0x429147		488d059d770400		LEAQ 0x4779d(IP), AX	
  0x42914e		48890424		MOVQ AX, 0(SP)		
  0x429152		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42915b		e820a3ffff		CALL runtime.throw(SB)	
  0x429160		0f0b			UD2			
					throw("startm: negative nmspinning")
  0x429162		488d0500840400		LEAQ 0x48400(IP), AX	
  0x429169		48890424		MOVQ AX, 0(SP)		
  0x42916d		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x429176		e805a3ffff		CALL runtime.throw(SB)	
  0x42917b		0f0b			UD2			
func startm(_p_ *p, spinning bool) {
  0x42917d		e8fee60100		CALL runtime.morestack_noctxt(SB)	
  0x429182		e9e9fdffff		JMP runtime.startm(SB)			

TEXT runtime.handoffp(SB) /usr/local/go/src/runtime/proc.go
func handoffp(_p_ *p) {
  0x429190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429199		483b6110		CMPQ 0x10(CX), SP	
  0x42919d		0f86f0020000		JBE 0x429493		
  0x4291a3		4883ec18		SUBQ $0x18, SP		
  0x4291a7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4291ac		488d6c2410		LEAQ 0x10(SP), BP	
	if !runqempty(_p_) || sched.runqsize != 0 {
  0x4291b1		488b442420		MOVQ 0x20(SP), AX			
  0x4291b6		48890424		MOVQ AX, 0(SP)				
  0x4291ba		e851720000		CALL runtime.runqempty(SB)		
  0x4291bf		807c240800		CMPB $0x0, 0x8(SP)			
  0x4291c4		7409			JE 0x4291cf				
  0x4291c6		833d3b8b090000		CMPL $0x0, runtime.sched+104(SB)	
  0x4291cd		741d			JE 0x4291ec				
		startm(_p_, false)
  0x4291cf		488b442420		MOVQ 0x20(SP), AX	
  0x4291d4		48890424		MOVQ AX, 0(SP)		
  0x4291d8		c644240800		MOVB $0x0, 0x8(SP)	
  0x4291dd		e88efdffff		CALL runtime.startm(SB)	
		return
  0x4291e2		488b6c2410		MOVQ 0x10(SP), BP	
  0x4291e7		4883c418		ADDQ $0x18, SP		
  0x4291eb		c3			RET			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x4291ec		833ddd3a0b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x4291f3		0f848e020000		JE 0x429487				
  0x4291f9		90			NOPL					
	if p != nil && !p.gcw.empty() {
  0x4291fa		488b4c2420		MOVQ 0x20(SP), CX	
  0x4291ff		4885c9			TESTQ CX, CX		
  0x429202		7433			JE 0x429237		
  0x429204		90			NOPL			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x429205		488b9170120000		MOVQ 0x1270(CX), DX	
  0x42920c		4885d2			TESTQ DX, DX		
  0x42920f		0f8468020000		JE 0x42947d		
  0x429215		48837a1000		CMPQ $0x0, 0x10(DX)	
  0x42921a		0f8556020000		JNE 0x429476		
  0x429220		488b9178120000		MOVQ 0x1278(CX), DX	
  0x429227		48837a1000		CMPQ $0x0, 0x10(DX)	
  0x42922c		0f94c2			SETE DL			
	if p != nil && !p.gcw.empty() {
  0x42922f		84d2			TESTL DL, DL		
  0x429231		0f8435020000		JE 0x42946c		
	if !work.full.empty() {
  0x429237		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x429238		488b15418d0900		MOVQ runtime.work(SB), DX	
  0x42923f		4885d2			TESTQ DX, DX			
	if !work.full.empty() {
  0x429242		0f851a020000		JNE 0x429462		
	if work.markrootNext < work.markrootJobs {
  0x429248		8b15be8d0900		MOVL runtime.work+140(SB), DX	
  0x42924e		3915b48d0900		CMPL DX, runtime.work+136(SB)	
  0x429254		0f8301020000		JAE 0x42945b			
  0x42925a		b801000000		MOVL $0x1, AX			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42925f		84c0			TESTL AL, AL		
  0x429261		0f85dc010000		JNE 0x429443		
	if atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) { // TODO: fast atomic
  0x429267		8b15878a0900		MOVL runtime.sched+84(SB), DX	
  0x42926d		8b1d7d8a0900		MOVL runtime.sched+80(SB), BX	
  0x429273		01da			ADDL BX, DX			
  0x429275		85d2			TESTL DX, DX			
  0x429277		0f85ba010000		JNE 0x429437			
  0x42927d		31c0			XORL AX, AX			
  0x42927f		488d156e8a0900		LEAQ runtime.sched+84(SB), DX	
  0x429286		bb01000000		MOVL $0x1, BX			
  0x42928b		f00fb11a		LOCK CMPXCHGL BX, 0(DX)		
  0x42928f		0f94c2			SETE DL				
  0x429292		84d2			TESTL DL, DL			
  0x429294		0f8585010000		JNE 0x42941f			
	lock(&sched.lock)
  0x42929a		488d050f8a0900		LEAQ runtime.sched+16(SB), AX	
  0x4292a1		48890424		MOVQ AX, 0(SP)			
  0x4292a5		e836f4fdff		CALL runtime.lock(SB)		
	if sched.gcwaiting != 0 {
  0x4292aa		833de78a090000		CMPL $0x0, runtime.sched+248(SB)	
  0x4292b1		744c			JE 0x4292ff				
		_p_.status = _Pgcstop
  0x4292b3		488b442420		MOVQ 0x20(SP), AX	
  0x4292b8		c7400c03000000		MOVL $0x3, 0xc(AX)	
		sched.stopwait--
  0x4292bf		8b05d78a0900		MOVL runtime.sched+252(SB), AX	
  0x4292c5		8d48ff			LEAL -0x1(AX), CX		
  0x4292c8		890dce8a0900		MOVL CX, runtime.sched+252(SB)	
		if sched.stopwait == 0 {
  0x4292ce		83f801			CMPL $0x1, AX		
  0x4292d1		741a			JE 0x4292ed		
		unlock(&sched.lock)
  0x4292d3		488d05d6890900		LEAQ runtime.sched+16(SB), AX	
  0x4292da		48890424		MOVQ AX, 0(SP)			
  0x4292de		e8adf5fdff		CALL runtime.unlock(SB)		
		return
  0x4292e3		488b6c2410		MOVQ 0x10(SP), BP	
  0x4292e8		4883c418		ADDQ $0x18, SP		
  0x4292ec		c3			RET			
			notewakeup(&sched.stopnote)
  0x4292ed		488d05ac8a0900		LEAQ runtime.sched+256(SB), AX	
  0x4292f4		48890424		MOVQ AX, 0(SP)			
  0x4292f8		e863f6fdff		CALL runtime.notewakeup(SB)	
  0x4292fd		ebd4			JMP 0x4292d3			
	if _p_.runSafePointFn != 0 && atomic.Cas(&_p_.runSafePointFn, 1, 0) {
  0x4292ff		488b4c2420		MOVQ 0x20(SP), CX		
  0x429304		8401			TESTB AL, 0(CX)			
  0x429306		83b93823000000		CMPL $0x0, 0x2338(CX)		
  0x42930d		0f8405010000		JE 0x429418			
  0x429313		b801000000		MOVL $0x1, AX			
  0x429318		31db			XORL BX, BX			
  0x42931a		f00fb19938230000	LOCK CMPXCHGL BX, 0x2338(CX)	
  0x429322		0f94c3			SETE BL				
  0x429325		84db			TESTL BL, BL			
  0x429327		0f85ab000000		JNE 0x4293d8			
	if sched.runqsize != 0 {
  0x42932d		833dd489090000		CMPL $0x0, runtime.sched+104(SB)	
  0x429334		7575			JNE 0x4293ab				
	if sched.npidle == uint32(gomaxprocs-1) && atomic.Load64(&sched.lastpoll) != 0 {
  0x429336		8b05a4390b00		MOVL runtime.gomaxprocs(SB), AX	
  0x42933c		ffc8			DECL AX				
  0x42933e		3905ac890900		CMPL AX, runtime.sched+80(SB)	
  0x429344		7561			JNE 0x4293a7			
  0x429346		488b055b890900		MOVQ runtime.sched+8(SB), AX	
  0x42934d		4885c0			TESTQ AX, AX			
  0x429350		0f95c0			SETNE AL			
  0x429353		84c0			TESTL AL, AL			
  0x429355		742d			JE 0x429384			
		unlock(&sched.lock)
  0x429357		488d0552890900		LEAQ runtime.sched+16(SB), AX	
  0x42935e		48890424		MOVQ AX, 0(SP)			
  0x429362		e829f5fdff		CALL runtime.unlock(SB)		
		startm(_p_, false)
  0x429367		488b442420		MOVQ 0x20(SP), AX	
  0x42936c		48890424		MOVQ AX, 0(SP)		
  0x429370		c644240800		MOVB $0x0, 0x8(SP)	
  0x429375		e8f6fbffff		CALL runtime.startm(SB)	
		return
  0x42937a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42937f		4883c418		ADDQ $0x18, SP		
  0x429383		c3			RET			
	pidleput(_p_)
  0x429384		48890c24		MOVQ CX, 0(SP)			
  0x429388		e8f36f0000		CALL runtime.pidleput(SB)	
	unlock(&sched.lock)
  0x42938d		488d051c890900		LEAQ runtime.sched+16(SB), AX	
  0x429394		48890424		MOVQ AX, 0(SP)			
  0x429398		e8f3f4fdff		CALL runtime.unlock(SB)		
}
  0x42939d		488b6c2410		MOVQ 0x10(SP), BP	
  0x4293a2		4883c418		ADDQ $0x18, SP		
  0x4293a6		c3			RET			
  0x4293a7		31c0			XORL AX, AX		
	if sched.npidle == uint32(gomaxprocs-1) && atomic.Load64(&sched.lastpoll) != 0 {
  0x4293a9		eba8			JMP 0x429353		
		unlock(&sched.lock)
  0x4293ab		488d05fe880900		LEAQ runtime.sched+16(SB), AX	
  0x4293b2		48890424		MOVQ AX, 0(SP)			
  0x4293b6		e8d5f4fdff		CALL runtime.unlock(SB)		
		startm(_p_, false)
  0x4293bb		488b442420		MOVQ 0x20(SP), AX	
  0x4293c0		48890424		MOVQ AX, 0(SP)		
  0x4293c4		c644240800		MOVB $0x0, 0x8(SP)	
  0x4293c9		e8a2fbffff		CALL runtime.startm(SB)	
		return
  0x4293ce		488b6c2410		MOVQ 0x10(SP), BP	
  0x4293d3		4883c418		ADDQ $0x18, SP		
  0x4293d7		c3			RET			
		sched.safePointFn(_p_)
  0x4293d8		488b15d9890900		MOVQ runtime.sched+280(SB), DX	
  0x4293df		48890c24		MOVQ CX, 0(SP)			
  0x4293e3		488b02			MOVQ 0(DX), AX			
  0x4293e6		ffd0			CALL AX				
		sched.safePointWait--
  0x4293e8		8b05d2890900		MOVL runtime.sched+288(SB), AX	
  0x4293ee		8d48ff			LEAL -0x1(AX), CX		
  0x4293f1		890dc9890900		MOVL CX, runtime.sched+288(SB)	
		if sched.safePointWait == 0 {
  0x4293f7		83f801			CMPL $0x1, AX		
  0x4293fa		740a			JE 0x429406		
	pidleput(_p_)
  0x4293fc		488b4c2420		MOVQ 0x20(SP), CX	
	if sched.runqsize != 0 {
  0x429401		e927ffffff		JMP 0x42932d		
			notewakeup(&sched.safePointNote)
  0x429406		488d05bb890900		LEAQ runtime.sched+296(SB), AX	
  0x42940d		48890424		MOVQ AX, 0(SP)			
  0x429411		e84af5fdff		CALL runtime.notewakeup(SB)	
  0x429416		ebe4			JMP 0x4293fc			
  0x429418		31db			XORL BX, BX			
	if _p_.runSafePointFn != 0 && atomic.Cas(&_p_.runSafePointFn, 1, 0) {
  0x42941a		e906ffffff		JMP 0x429325		
		startm(_p_, true)
  0x42941f		48890c24		MOVQ CX, 0(SP)		
  0x429423		c644240801		MOVB $0x1, 0x8(SP)	
  0x429428		e843fbffff		CALL runtime.startm(SB)	
		return
  0x42942d		488b6c2410		MOVQ 0x10(SP), BP	
  0x429432		4883c418		ADDQ $0x18, SP		
  0x429436		c3			RET			
  0x429437		bb01000000		MOVL $0x1, BX		
  0x42943c		31d2			XORL DX, DX		
	if atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) == 0 && atomic.Cas(&sched.nmspinning, 0, 1) { // TODO: fast atomic
  0x42943e		e94ffeffff		JMP 0x429292		
		startm(_p_, false)
  0x429443		48890c24		MOVQ CX, 0(SP)		
  0x429447		c644240800		MOVB $0x0, 0x8(SP)	
  0x42944c		e81ffbffff		CALL runtime.startm(SB)	
		return
  0x429451		488b6c2410		MOVQ 0x10(SP), BP	
  0x429456		4883c418		ADDQ $0x18, SP		
  0x42945a		c3			RET			
  0x42945b		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42945d		e9fdfdffff		JMP 0x42925f		
  0x429462		b801000000		MOVL $0x1, AX		
  0x429467		e9f3fdffff		JMP 0x42925f		
  0x42946c		b801000000		MOVL $0x1, AX		
  0x429471		e9e9fdffff		JMP 0x42925f		
  0x429476		31d2			XORL DX, DX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x429478		e9b2fdffff		JMP 0x42922f		
  0x42947d		ba01000000		MOVL $0x1, DX		
  0x429482		e9a8fdffff		JMP 0x42922f		
		startm(_p_, false)
  0x429487		488b4c2420		MOVQ 0x20(SP), CX	
  0x42948c		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
  0x42948e		e9ccfdffff		JMP 0x42925f		
func handoffp(_p_ *p) {
  0x429493		e8e8e30100		CALL runtime.morestack_noctxt(SB)	
  0x429498		e9f3fcffff		JMP runtime.handoffp(SB)		

TEXT runtime.stoplockedm(SB) /usr/local/go/src/runtime/proc.go
func stoplockedm() {
  0x4294a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4294a9		483b6110		CMPQ 0x10(CX), SP	
  0x4294ad		0f8696020000		JBE 0x429749		
  0x4294b3		4883ec38		SUBQ $0x38, SP		
  0x4294b7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4294bc		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x4294c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedg == 0 || _g_.m.lockedg.ptr().lockedm.ptr() != _g_.m {
  0x4294ca		488b4830		MOVQ 0x30(AX), CX	
  0x4294ce		488b9168010000		MOVQ 0x168(CX), DX	
  0x4294d5		4885d2			TESTQ DX, DX		
  0x4294d8		0f8450020000		JE 0x42972e		
  0x4294de		90			NOPL			
  0x4294df		488b92d8000000		MOVQ 0xd8(DX), DX	
  0x4294e6		90			NOPL			
  0x4294e7		4839ca			CMPQ CX, DX		
  0x4294ea		0f853e020000		JNE 0x42972e		
	_g_ := getg()
  0x4294f0		4889442420		MOVQ AX, 0x20(SP)	
	if _g_.m.p != 0 {
  0x4294f5		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x4294fd		0f858d000000		JNE 0x429590		
	incidlelocked(1)
  0x429503		c7042401000000		MOVL $0x1, 0(SP)		
  0x42950a		e8b1530000		CALL runtime.incidlelocked(SB)	
	notesleep(&_g_.m.park)
  0x42950f		488b442420		MOVQ 0x20(SP), AX		
  0x429514		488b4830		MOVQ 0x30(AX), CX		
  0x429518		8401			TESTB AL, 0(CX)			
  0x42951a		8400			TESTB AL, 0(AX)			
  0x42951c		4881c148010000		ADDQ $0x148, CX			
  0x429523		48890c24		MOVQ CX, 0(SP)			
  0x429527		e804f5fdff		CALL runtime.notesleep(SB)	
	noteclear(&_g_.m.park)
  0x42952c		488b442420		MOVQ 0x20(SP), AX	
  0x429531		488b4830		MOVQ 0x30(AX), CX	
  0x429535		90			NOPL			
	n.key = 0
  0x429536		48c7814801000000000000	MOVQ $0x0, 0x148(CX)	
	status := readgstatus(_g_.m.lockedg.ptr())
  0x429541		488b4830		MOVQ 0x30(AX), CX	
  0x429545		488b8968010000		MOVQ 0x168(CX), CX	
  0x42954c		90			NOPL			
  0x42954d		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42954e		8b8990000000		MOVL 0x90(CX), CX	
	if status&^_Gscan != _Grunnable {
  0x429554		0fbaf10c		BTRL $0xc, CX		
  0x429558		83f901			CMPL $0x1, CX		
  0x42955b		7542			JNE 0x42959f		
	acquirep(_g_.m.nextp.ptr())
  0x42955d		488b4830		MOVQ 0x30(AX), CX		
  0x429561		488b89d8000000		MOVQ 0xd8(CX), CX		
  0x429568		90			NOPL				
  0x429569		48890c24		MOVQ CX, 0(SP)			
  0x42956d		e85e4f0000		CALL runtime.acquirep(SB)	
	_g_.m.nextp = 0
  0x429572		488b442420		MOVQ 0x20(SP), AX	
  0x429577		488b4030		MOVQ 0x30(AX), AX	
  0x42957b		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
}
  0x429586		488b6c2430		MOVQ 0x30(SP), BP	
  0x42958b		4883c438		ADDQ $0x38, SP		
  0x42958f		c3			RET			
		_p_ := releasep()
  0x429590		e8fb500000		CALL runtime.releasep(SB)	
		handoffp(_p_)
  0x429595		e8f6fbffff		CALL runtime.handoffp(SB)	
  0x42959a		e964ffffff		JMP 0x429503			
		print("runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n")
  0x42959f		e81ca9ffff		CALL runtime.printlock(SB)	
  0x4295a4		488d054f9f0400		LEAQ 0x49f4f(IP), AX		
  0x4295ab		48890424		MOVQ AX, 0(SP)			
  0x4295af		48c744240839000000	MOVQ $0x39, 0x8(SP)		
  0x4295b8		e833b2ffff		CALL runtime.printstring(SB)	
  0x4295bd		e87ea9ffff		CALL runtime.printunlock(SB)	
		dumpgstatus(_g_)
  0x4295c2		90			NOPL			
	_g_ := getg()
  0x4295c3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4295cc		4889442428		MOVQ AX, 0x28(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4295d1		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x4295d2		488b4c2420		MOVQ 0x20(SP), CX	
  0x4295d7		8b9190000000		MOVL 0x90(CX), DX	
  0x4295dd		89542410		MOVL DX, 0x10(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x4295e1		488b9998000000		MOVQ 0x98(CX), BX		
  0x4295e8		48895c2418		MOVQ BX, 0x18(SP)		
  0x4295ed		e8cea8ffff		CALL runtime.printlock(SB)	
  0x4295f2		488d059e6a0400		LEAQ 0x46a9e(IP), AX		
  0x4295f9		48890424		MOVQ AX, 0(SP)			
  0x4295fd		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x429606		e8e5b1ffff		CALL runtime.printstring(SB)	
  0x42960b		488b442420		MOVQ 0x20(SP), AX		
  0x429610		48890424		MOVQ AX, 0(SP)			
  0x429614		e897b1ffff		CALL runtime.printpointer(SB)	
  0x429619		488d05bc5c0400		LEAQ 0x45cbc(IP), AX		
  0x429620		48890424		MOVQ AX, 0(SP)			
  0x429624		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42962d		e8beb1ffff		CALL runtime.printstring(SB)	
  0x429632		488b442418		MOVQ 0x18(SP), AX		
  0x429637		48890424		MOVQ AX, 0(SP)			
  0x42963b		e800b0ffff		CALL runtime.printint(SB)	
  0x429640		488d05366d0400		LEAQ 0x46d36(IP), AX		
  0x429647		48890424		MOVQ AX, 0(SP)			
  0x42964b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x429654		e897b1ffff		CALL runtime.printstring(SB)	
  0x429659		8b442410		MOVL 0x10(SP), AX		
  0x42965d		89c0			MOVL AX, AX			
  0x42965f		48890424		MOVQ AX, 0(SP)			
  0x429663		e8d8aeffff		CALL runtime.printuint(SB)	
  0x429668		e8e3aaffff		CALL runtime.printnl(SB)	
  0x42966d		e8cea8ffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x429672		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x429673		488b442428		MOVQ 0x28(SP), AX	
  0x429678		8b8890000000		MOVL 0x90(AX), CX	
  0x42967e		894c2414		MOVL CX, 0x14(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x429682		488b9098000000		MOVQ 0x98(AX), DX		
  0x429689		4889542418		MOVQ DX, 0x18(SP)		
  0x42968e		e82da8ffff		CALL runtime.printlock(SB)	
  0x429693		488d05ed690400		LEAQ 0x469ed(IP), AX		
  0x42969a		48890424		MOVQ AX, 0(SP)			
  0x42969e		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x4296a7		e844b1ffff		CALL runtime.printstring(SB)	
  0x4296ac		488b442428		MOVQ 0x28(SP), AX		
  0x4296b1		48890424		MOVQ AX, 0(SP)			
  0x4296b5		e8f6b0ffff		CALL runtime.printpointer(SB)	
  0x4296ba		488d051b5c0400		LEAQ 0x45c1b(IP), AX		
  0x4296c1		48890424		MOVQ AX, 0(SP)			
  0x4296c5		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4296ce		e81db1ffff		CALL runtime.printstring(SB)	
  0x4296d3		488b442418		MOVQ 0x18(SP), AX		
  0x4296d8		48890424		MOVQ AX, 0(SP)			
  0x4296dc		e85fafffff		CALL runtime.printint(SB)	
  0x4296e1		488d05826c0400		LEAQ 0x46c82(IP), AX		
  0x4296e8		48890424		MOVQ AX, 0(SP)			
  0x4296ec		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4296f5		e8f6b0ffff		CALL runtime.printstring(SB)	
  0x4296fa		8b442414		MOVL 0x14(SP), AX		
  0x4296fe		89c0			MOVL AX, AX			
  0x429700		48890424		MOVQ AX, 0(SP)			
  0x429704		e837aeffff		CALL runtime.printuint(SB)	
  0x429709		e842aaffff		CALL runtime.printnl(SB)	
  0x42970e		e82da8ffff		CALL runtime.printunlock(SB)	
		throw("stoplockedm: not runnable")
  0x429713		488d05447a0400		LEAQ 0x47a44(IP), AX	
  0x42971a		48890424		MOVQ AX, 0(SP)		
  0x42971e		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x429727		e8549dffff		CALL runtime.throw(SB)	
  0x42972c		0f0b			UD2			
		throw("stoplockedm: inconsistent locking")
  0x42972e		488d056e8b0400		LEAQ 0x48b6e(IP), AX	
  0x429735		48890424		MOVQ AX, 0(SP)		
  0x429739		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x429742		e8399dffff		CALL runtime.throw(SB)	
  0x429747		0f0b			UD2			
func stoplockedm() {
  0x429749		e832e10100		CALL runtime.morestack_noctxt(SB)	
  0x42974e		e94dfdffff		JMP runtime.stoplockedm(SB)		

TEXT runtime.startlockedm(SB) /usr/local/go/src/runtime/proc.go
func startlockedm(gp *g) {
  0x429760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429769		483b6110		CMPQ 0x10(CX), SP	
  0x42976d		0f86b0000000		JBE 0x429823		
  0x429773		4883ec20		SUBQ $0x20, SP		
  0x429777		48896c2418		MOVQ BP, 0x18(SP)	
  0x42977c		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x429781		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp := gp.lockedm.ptr()
  0x42978a		488b4c2428		MOVQ 0x28(SP), CX	
  0x42978f		488b89d8000000		MOVQ 0xd8(CX), CX	
  0x429796		90			NOPL			
	if mp == _g_.m {
  0x429797		48394830		CMPQ CX, 0x30(AX)	
  0x42979b		746b			JE 0x429808		
	if mp.nextp != 0 {
  0x42979d		4883b9d800000000	CMPQ $0x0, 0xd8(CX)	
  0x4297a5		7546			JNE 0x4297ed		
func (mp muintptr) ptr() *m { return (*m)(unsafe.Pointer(mp)) }
  0x4297a7		48894c2410		MOVQ CX, 0x10(SP)	
	incidlelocked(-1)
  0x4297ac		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x4297b3		e808510000		CALL runtime.incidlelocked(SB)	
	_p_ := releasep()
  0x4297b8		e8d34e0000		CALL runtime.releasep(SB)	
  0x4297bd		488b0424		MOVQ 0(SP), AX			
	mp.nextp.set(_p_)
  0x4297c1		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4297c2		488b4c2410		MOVQ 0x10(SP), CX	
  0x4297c7		488981d8000000		MOVQ AX, 0xd8(CX)	
	notewakeup(&mp.park)
  0x4297ce		488d8148010000		LEAQ 0x148(CX), AX		
  0x4297d5		48890424		MOVQ AX, 0(SP)			
  0x4297d9		e882f1fdff		CALL runtime.notewakeup(SB)	
	stopm()
  0x4297de		e8fdf5ffff		CALL runtime.stopm(SB)	
}
  0x4297e3		488b6c2418		MOVQ 0x18(SP), BP	
  0x4297e8		4883c420		ADDQ $0x20, SP		
  0x4297ec		c3			RET			
		throw("startlockedm: m has p")
  0x4297ed		488d05e2700400		LEAQ 0x470e2(IP), AX	
  0x4297f4		48890424		MOVQ AX, 0(SP)		
  0x4297f8		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x429801		e87a9cffff		CALL runtime.throw(SB)	
  0x429806		0f0b			UD2			
		throw("startlockedm: locked to me")
  0x429808		488d05d37a0400		LEAQ 0x47ad3(IP), AX	
  0x42980f		48890424		MOVQ AX, 0(SP)		
  0x429813		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x42981c		e85f9cffff		CALL runtime.throw(SB)	
  0x429821		0f0b			UD2			
func startlockedm(gp *g) {
  0x429823		e858e00100		CALL runtime.morestack_noctxt(SB)	
  0x429828		e933ffffff		JMP runtime.startlockedm(SB)		

TEXT runtime.gcstopm(SB) /usr/local/go/src/runtime/proc.go
func gcstopm() {
  0x429830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429839		483b6110		CMPQ 0x10(CX), SP	
  0x42983d		0f86f3000000		JBE 0x429936		
  0x429843		4883ec20		SUBQ $0x20, SP		
  0x429847		48896c2418		MOVQ BP, 0x18(SP)	
  0x42984c		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x429851		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if sched.gcwaiting == 0 {
  0x42985a		833d3785090000		CMPL $0x0, runtime.sched+248(SB)	
  0x429861		0f84b4000000		JE 0x42991b				
	if _g_.m.spinning {
  0x429867		488b4030		MOVQ 0x30(AX), AX	
  0x42986b		80b81401000000		CMPB $0x0, 0x114(AX)	
  0x429872		741d			JE 0x429891		
		_g_.m.spinning = false
  0x429874		c6801401000000		MOVB $0x0, 0x114(AX)	
		if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x42987b		b8ffffffff		MOVL $-0x1, AX			
  0x429880		488d0d6d840900		LEAQ runtime.sched+84(SB), CX	
  0x429887		f00fc101		LOCK XADDL AX, 0(CX)		
  0x42988b		ffc8			DECL AX				
  0x42988d		85c0			TESTL AX, AX			
  0x42988f		7c6f			JL 0x429900			
	_p_ := releasep()
  0x429891		e8fa4d0000		CALL runtime.releasep(SB)	
  0x429896		488b0424		MOVQ 0(SP), AX			
  0x42989a		4889442410		MOVQ AX, 0x10(SP)		
	lock(&sched.lock)
  0x42989f		488d0d0a840900		LEAQ runtime.sched+16(SB), CX	
  0x4298a6		48890c24		MOVQ CX, 0(SP)			
  0x4298aa		e831eefdff		CALL runtime.lock(SB)		
	_p_.status = _Pgcstop
  0x4298af		488b442410		MOVQ 0x10(SP), AX	
  0x4298b4		c7400c03000000		MOVL $0x3, 0xc(AX)	
	sched.stopwait--
  0x4298bb		8b05db840900		MOVL runtime.sched+252(SB), AX	
  0x4298c1		8d48ff			LEAL -0x1(AX), CX		
  0x4298c4		890dd2840900		MOVL CX, runtime.sched+252(SB)	
	if sched.stopwait == 0 {
  0x4298ca		83f801			CMPL $0x1, AX		
  0x4298cd		741f			JE 0x4298ee		
	unlock(&sched.lock)
  0x4298cf		488d05da830900		LEAQ runtime.sched+16(SB), AX	
  0x4298d6		48890424		MOVQ AX, 0(SP)			
  0x4298da		e8b1effdff		CALL runtime.unlock(SB)		
	stopm()
  0x4298df		e8fcf4ffff		CALL runtime.stopm(SB)	
}
  0x4298e4		488b6c2418		MOVQ 0x18(SP), BP	
  0x4298e9		4883c420		ADDQ $0x20, SP		
  0x4298ed		c3			RET			
		notewakeup(&sched.stopnote)
  0x4298ee		488d05ab840900		LEAQ runtime.sched+256(SB), AX	
  0x4298f5		48890424		MOVQ AX, 0(SP)			
  0x4298f9		e862f0fdff		CALL runtime.notewakeup(SB)	
  0x4298fe		ebcf			JMP 0x4298cf			
			throw("gcstopm: negative nmspinning")
  0x429900		488d05af7d0400		LEAQ 0x47daf(IP), AX	
  0x429907		48890424		MOVQ AX, 0(SP)		
  0x42990b		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x429914		e8679bffff		CALL runtime.throw(SB)	
  0x429919		0f0b			UD2			
		throw("gcstopm: not waiting for gc")
  0x42991b		488d05467a0400		LEAQ 0x47a46(IP), AX	
  0x429922		48890424		MOVQ AX, 0(SP)		
  0x429926		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x42992f		e84c9bffff		CALL runtime.throw(SB)	
  0x429934		0f0b			UD2			
func gcstopm() {
  0x429936		e845df0100		CALL runtime.morestack_noctxt(SB)	
  0x42993b		e9f0feffff		JMP runtime.gcstopm(SB)			

TEXT runtime.execute(SB) /usr/local/go/src/runtime/proc.go
func execute(gp *g, inheritTime bool) {
  0x429940		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429949		483b6110		CMPQ 0x10(CX), SP	
  0x42994d		0f8649010000		JBE 0x429a9c		
  0x429953		4883ec20		SUBQ $0x20, SP		
  0x429957		48896c2418		MOVQ BP, 0x18(SP)	
  0x42995c		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x429961		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42996a		4889442410		MOVQ AX, 0x10(SP)	
	casgstatus(gp, _Grunnable, _Grunning)
  0x42996f		488b4c2428		MOVQ 0x28(SP), CX		
  0x429974		48890c24		MOVQ CX, 0(SP)			
  0x429978		48ba0100000002000000	MOVQ $0x200000001, DX		
  0x429982		4889542408		MOVQ DX, 0x8(SP)		
  0x429987		e814d3ffff		CALL runtime.casgstatus(SB)	
	gp.waitsince = 0
  0x42998c		488b442428		MOVQ 0x28(SP), AX	
  0x429991		48c780a800000000000000	MOVQ $0x0, 0xa8(AX)	
	gp.preempt = false
  0x42999c		c680b100000000		MOVB $0x0, 0xb1(AX)	
	gp.stackguard0 = gp.stack.lo + _StackGuard
  0x4299a3		488b08			MOVQ 0(AX), CX		
  0x4299a6		4881c170030000		ADDQ $0x370, CX		
  0x4299ad		48894810		MOVQ CX, 0x10(AX)	
func execute(gp *g, inheritTime bool) {
  0x4299b1		0fb64c2430		MOVZX 0x30(SP), CX	
  0x4299b6		84c9			TESTL CL, CL		
	if !inheritTime {
  0x4299b8		0f84c5000000		JE 0x429a83		
	_g_.m.curg = gp
  0x4299be		488b4c2410		MOVQ 0x10(SP), CX			
  0x4299c3		488b5130		MOVQ 0x30(CX), DX			
  0x4299c7		8402			TESTB AL, 0(DX)				
  0x4299c9		833d50340b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4299d0		0f859c000000		JNE 0x429a72				
  0x4299d6		488982c0000000		MOVQ AX, 0xc0(DX)			
	gp.m = _g_.m
  0x4299dd		488b5130		MOVQ 0x30(CX), DX			
  0x4299e1		833d38340b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4299e8		7571			JNE 0x429a5b				
  0x4299ea		48895030		MOVQ DX, 0x30(AX)			
	if _g_.m.profilehz != hz {
  0x4299ee		488b4930		MOVQ 0x30(CX), CX	
	hz := sched.profilehz
  0x4299f2		8b15d8830900		MOVL runtime.sched+304(SB), DX	
	if _g_.m.profilehz != hz {
  0x4299f8		399110010000		CMPL DX, 0x110(CX)	
  0x4299fe		754c			JNE 0x429a4c		
	if trace.enabled {
  0x429a00		803dc9310a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x429a07		7415			JE 0x429a1e			
		if gp.syscallsp != 0 && gp.sysblocktraced {
  0x429a09		4883787000		CMPQ $0x0, 0x70(AX)	
  0x429a0e		7409			JE 0x429a19		
  0x429a10		80b8b800000000		CMPB $0x0, 0xb8(AX)	
  0x429a17		7521			JNE 0x429a3a		
		traceGoStart()
  0x429a19		e872350100		CALL runtime.traceGoStart(SB)	
	gogo(&gp.sched)
  0x429a1e		488b442428		MOVQ 0x28(SP), AX	
  0x429a23		4883c038		ADDQ $0x38, AX		
  0x429a27		48890424		MOVQ AX, 0(SP)		
  0x429a2b		e820dc0100		CALL runtime.gogo(SB)	
}
  0x429a30		488b6c2418		MOVQ 0x18(SP), BP	
  0x429a35		4883c420		ADDQ $0x20, SP		
  0x429a39		c3			RET			
			traceGoSysExit(gp.sysexitticks)
  0x429a3a		488b88c0000000		MOVQ 0xc0(AX), CX		
  0x429a41		48890c24		MOVQ CX, 0(SP)			
  0x429a45		e8d6380100		CALL runtime.traceGoSysExit(SB)	
  0x429a4a		ebcd			JMP 0x429a19			
		setThreadCPUProfiler(hz)
  0x429a4c		891424			MOVL DX, 0(SP)				
  0x429a4f		e86cac0000		CALL runtime.setThreadCPUProfiler(SB)	
		if gp.syscallsp != 0 && gp.sysblocktraced {
  0x429a54		488b442428		MOVQ 0x28(SP), AX	
		setThreadCPUProfiler(hz)
  0x429a59		eba5			JMP 0x429a00		
	gp.m = _g_.m
  0x429a5b		488d7830		LEAQ 0x30(AX), DI	
func execute(gp *g, inheritTime bool) {
  0x429a5f		4889c3			MOVQ AX, BX		
	gp.m = _g_.m
  0x429a62		4889d0			MOVQ DX, AX			
  0x429a65		e816fc0100		CALL runtime.gcWriteBarrier(SB)	
		if gp.syscallsp != 0 && gp.sysblocktraced {
  0x429a6a		4889d8			MOVQ BX, AX		
	gp.m = _g_.m
  0x429a6d		e97cffffff		JMP 0x4299ee		
	_g_.m.curg = gp
  0x429a72		488dbac0000000		LEAQ 0xc0(DX), DI		
  0x429a79		e802fc0100		CALL runtime.gcWriteBarrier(SB)	
  0x429a7e		e95affffff		JMP 0x4299dd			
		_g_.m.p.ptr().schedtick++
  0x429a83		488b4c2410		MOVQ 0x10(SP), CX	
  0x429a88		488b5130		MOVQ 0x30(CX), DX	
  0x429a8c		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x429a93		90			NOPL			
  0x429a94		ff4218			INCL 0x18(DX)		
  0x429a97		e922ffffff		JMP 0x4299be		
func execute(gp *g, inheritTime bool) {
  0x429a9c		e8dfdd0100		CALL runtime.morestack_noctxt(SB)	
  0x429aa1		e99afeffff		JMP runtime.execute(SB)			

TEXT runtime.findrunnable(SB) /usr/local/go/src/runtime/proc.go
func findrunnable() (gp *g, inheritTime bool) {
  0x429ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x429ab9		488d4424e8		LEAQ -0x18(SP), AX	
  0x429abe		483b4110		CMPQ 0x10(CX), AX	
  0x429ac2		0f86cd0b0000		JBE 0x42a695		
  0x429ac8		4881ec98000000		SUBQ $0x98, SP		
  0x429acf		4889ac2490000000	MOVQ BP, 0x90(SP)	
  0x429ad7		488dac2490000000	LEAQ 0x90(SP), BP	
	_g_ := getg()
  0x429adf		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x429ae8		4889842480000000	MOVQ AX, 0x80(SP)	
top:
  0x429af0		e99f060000		JMP 0x42a194		
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x429af5		31d2			XORL DX, DX		
  0x429af7		f7f1			DIVL CX			
  0x429af9		89542450		MOVL DX, 0x50(SP)	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429afd		488b542440		MOVQ 0x40(SP), DX	
  0x429b02		488b9c2488000000	MOVQ 0x88(SP), BX	
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x429b0a		4889d9			MOVQ BX, CX		
			stealRunNextG := i > 2 // first look for ready queues with more than 1 g
  0x429b0d		4989d1			MOVQ DX, R9		
	_p_ := _g_.m.p.ptr()
  0x429b10		4c8b942480000000	MOVQ 0x80(SP), R10	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429b18		90			NOPL			
	return enum.i == enum.count
  0x429b19		8b54244c		MOVL 0x4c(SP), DX	
  0x429b1d		39542448		CMPL DX, 0x48(SP)	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429b21		0f848d000000		JE 0x429bb4		
			if sched.gcwaiting != 0 {
  0x429b27		833d6a82090000		CMPL $0x0, runtime.sched+248(SB)	
  0x429b2e		757c			JNE 0x429bac				
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x429b30		488b05e97e0900		MOVQ runtime.allp(SB), AX	
  0x429b37		90			NOPL				
	return enum.pos
  0x429b38		8b542450		MOVL 0x50(SP), DX	
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x429b3c		483915e57e0900		CMPQ DX, runtime.allp+8(SB)	
  0x429b43		0f86300b0000		JBE 0x42a679			
  0x429b49		488b04d0		MOVQ 0(AX)(DX*8), AX		
  0x429b4d		48890c24		MOVQ CX, 0(SP)			
  0x429b51		4889442408		MOVQ AX, 0x8(SP)		
			stealRunNextG := i > 2 // first look for ready queues with more than 1 g
  0x429b56		4983f902		CMPQ $0x2, R9		
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x429b5a		0f9f442410		SETG 0x10(SP)			
  0x429b5f		e81c6e0000		CALL runtime.runqsteal(SB)	
  0x429b64		488b442418		MOVQ 0x18(SP), AX		
  0x429b69		4885c0			TESTQ AX, AX			
  0x429b6c		751e			JNE 0x429b8c			
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429b6e		90			NOPL			
	enum.i++
  0x429b6f		ff442448		INCL 0x48(SP)		
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x429b73		8b442450		MOVL 0x50(SP), AX	
  0x429b77		03442454		ADDL 0x54(SP), AX	
  0x429b7b		8b4c244c		MOVL 0x4c(SP), CX	
  0x429b7f		85c9			TESTL CX, CX		
  0x429b81		0f856effffff		JNE 0x429af5		
  0x429b87		e9e60a0000		JMP 0x42a672		
				return gp, false
  0x429b8c		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x429b94		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x429b9c		488bac2490000000	MOVQ 0x90(SP), BP	
  0x429ba4		4881c498000000		ADDQ $0x98, SP		
  0x429bab		c3			RET			
	_p_ := _g_.m.p.ptr()
  0x429bac		4c89d0			MOVQ R10, AX		
				goto top
  0x429baf		e9e0050000		JMP 0x42a194		
	for i := 0; i < 4; i++ {
  0x429bb4		498d4101		LEAQ 0x1(R9), AX	
	_p_ := _g_.m.p.ptr()
  0x429bb8		4c89d2			MOVQ R10, DX		
	for i := 0; i < 4; i++ {
  0x429bbb		4883f804		CMPQ $0x4, AX		
  0x429bbf		0f8d48020000		JGE 0x429e0d		
	mp := getg().m
  0x429bc5		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x429bce		488b5b30		MOVQ 0x30(BX), BX	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429bd2		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x429bd3		8bb320010000		MOVL 0x120(BX), SI	
  0x429bd9		8bbb24010000		MOVL 0x124(BX), DI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x429bdf		89bb20010000		MOVL DI, 0x120(BX)	
	s1 ^= s1 << 17
  0x429be5		4189f0			MOVL SI, R8		
  0x429be8		c1e611			SHLL $0x11, SI		
  0x429beb		4431c6			XORL R8, SI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x429bee		4189f8			MOVL DI, R8		
  0x429bf1		31f7			XORL SI, DI		
  0x429bf3		c1ee07			SHRL $0x7, SI		
  0x429bf6		31fe			XORL DI, SI		
  0x429bf8		4489c7			MOVL R8, DI		
  0x429bfb		41c1e810		SHRL $0x10, R8		
  0x429bff		4131f0			XORL SI, R8		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x429c02		44898324010000		MOVL R8, 0x124(BX)	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429c09		90			NOPL			
	return s0 + s1
  0x429c0a		418d1c38		LEAL 0(R8)(DI*1), BX	
		count: ord.count,
  0x429c0e		8b352c7f0900		MOVL runtime.stealOrder(SB), SI	
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x429c14		488b3d2d7f0900		MOVQ runtime.stealOrder+8(SB), DI	
  0x429c1b		4c8b052e7f0900		MOVQ runtime.stealOrder+16(SB), R8	
		pos:   i % ord.count,
  0x429c22		85f6			TESTL SI, SI		
  0x429c24		0f84640a0000		JE 0x42a68e		
	for i := 0; i < 4; i++ {
  0x429c2a		4989c1			MOVQ AX, R9		
		pos:   i % ord.count,
  0x429c2d		89d8			MOVL BX, AX		
	_g_ := getg()
  0x429c2f		4989d2			MOVQ DX, R10		
		pos:   i % ord.count,
  0x429c32		31d2			XORL DX, DX		
  0x429c34		f7f6			DIVL SI			
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x429c36		4585c0			TESTL R8, R8		
  0x429c39		0f84480a0000		JE 0x42a687		
  0x429c3f		89d8			MOVL BX, AX		
		pos:   i % ord.count,
  0x429c41		89d3			MOVL DX, BX		
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x429c43		31d2			XORL DX, DX		
  0x429c45		41f7f0			DIVL R8			
  0x429c48		89d2			MOVL DX, DX		
  0x429c4a		4c39c2			CMPQ R8, DX		
  0x429c4d		0f832d0a0000		JAE 0x42a680		
	for i := 0; i < 4; i++ {
  0x429c53		4c894c2440		MOVQ R9, 0x40(SP)	
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x429c58		8b1497			MOVL 0(DI)(DX*4), DX	
		for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
  0x429c5b		c744244800000000	MOVL $0x0, 0x48(SP)	
  0x429c63		8974244c		MOVL SI, 0x4c(SP)	
  0x429c67		895c2450		MOVL BX, 0x50(SP)	
  0x429c6b		89542454		MOVL DX, 0x54(SP)	
  0x429c6f		e9a4feffff		JMP 0x429b18		
	for _, _p_ := range allpSnapshot {
  0x429c74		488b5c2440		MOVQ 0x40(SP), BX	
  0x429c79		488d4b01		LEAQ 0x1(BX), CX	
		if _g_.m.p != 0 {
  0x429c7d		488b842480000000	MOVQ 0x80(SP), AX	
	wasSpinning := _g_.m.spinning
  0x429c85		0fb6542427		MOVZX 0x27(SP), DX	
	for _, _p_ := range allpSnapshot {
  0x429c8a		488b5c2438		MOVQ 0x38(SP), BX	
  0x429c8f		4839d9			CMPQ BX, CX		
  0x429c92		0f8d80000000		JGE 0x429d18		
  0x429c98		48894c2440		MOVQ CX, 0x40(SP)	
  0x429c9d		488b442470		MOVQ 0x70(SP), AX	
  0x429ca2		488b14c8		MOVQ 0(AX)(CX*8), DX	
		if !runqempty(_p_) {
  0x429ca6		48891424		MOVQ DX, 0(SP)			
  0x429caa		e861670000		CALL runtime.runqempty(SB)	
  0x429caf		807c240800		CMPB $0x0, 0x8(SP)		
  0x429cb4		75be			JNE 0x429c74			
			lock(&sched.lock)
  0x429cb6		488d05f37f0900		LEAQ runtime.sched+16(SB), AX	
  0x429cbd		48890424		MOVQ AX, 0(SP)			
  0x429cc1		e81aeafdff		CALL runtime.lock(SB)		
			_p_ = pidleget()
  0x429cc6		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x429cc7		488b051a800900		MOVQ runtime.sched+72(SB), AX	
  0x429cce		90			NOPL				
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x429ccf		4889842488000000	MOVQ AX, 0x88(SP)	
	if _p_ != nil {
  0x429cd7		4885c0			TESTQ AX, AX		
  0x429cda		741b			JE 0x429cf7		
		sched.pidle = _p_.link
  0x429cdc		488b4810		MOVQ 0x10(AX), CX		
  0x429ce0		48890d01800900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x429ce7		b9ffffffff		MOVL $-0x1, CX			
  0x429cec		488d15fd7f0900		LEAQ runtime.sched+80(SB), DX	
  0x429cf3		f00fc10a		LOCK XADDL CX, 0(DX)		
			unlock(&sched.lock)
  0x429cf7		488d05b27f0900		LEAQ runtime.sched+16(SB), AX	
  0x429cfe		48890424		MOVQ AX, 0(SP)			
  0x429d02		e889ebfdff		CALL runtime.unlock(SB)		
	if _p_ != nil {
  0x429d07		488b842488000000	MOVQ 0x88(SP), AX	
  0x429d0f		4885c0			TESTQ AX, AX		
			if _p_ != nil {
  0x429d12		0f8543040000		JNE 0x42a15b		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x429d18		833db12f0b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x429d1f		0f842f040000		JE 0x42a154				
  0x429d25		90			NOPL					
	if !work.full.empty() {
  0x429d26		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x429d27		488b0552820900		MOVQ runtime.work(SB), AX	
  0x429d2e		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x429d31		0f8513040000		JNE 0x42a14a		
	if work.markrootNext < work.markrootJobs {
  0x429d37		8b05cf820900		MOVL runtime.work+140(SB), AX	
  0x429d3d		3905c5820900		CMPL AX, runtime.work+136(SB)	
  0x429d43		0f83fa030000		JAE 0x42a143			
  0x429d49		b801000000		MOVL $0x1, AX			
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x429d4e		84c0			TESTL AL, AL		
  0x429d50		0f8411020000		JE 0x429f67		
		lock(&sched.lock)
  0x429d56		488d05537f0900		LEAQ runtime.sched+16(SB), AX	
  0x429d5d		48890424		MOVQ AX, 0(SP)			
  0x429d61		e87ae9fdff		CALL runtime.lock(SB)		
		_p_ = pidleget()
  0x429d66		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x429d67		488b057a7f0900		MOVQ runtime.sched+72(SB), AX	
  0x429d6e		90			NOPL				
	if _p_ != nil {
  0x429d6f		4885c0			TESTQ AX, AX		
  0x429d72		0f84bf030000		JE 0x42a137		
		sched.pidle = _p_.link
  0x429d78		488b4810		MOVQ 0x10(AX), CX		
  0x429d7c		48890d657f0900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x429d83		b9ffffffff		MOVL $-0x1, CX			
  0x429d88		488d15617f0900		LEAQ runtime.sched+80(SB), DX	
  0x429d8f		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x429d93		4885c0			TESTQ AX, AX		
		if _p_ != nil && _p_.gcBgMarkWorker == 0 {
  0x429d96		740e			JE 0x429da6		
  0x429d98		4883b85812000000	CMPQ $0x0, 0x1258(AX)	
  0x429da0		0f8481030000		JE 0x42a127		
		if _p_ != nil {
  0x429da6		4889442478		MOVQ AX, 0x78(SP)	
		unlock(&sched.lock)
  0x429dab		488d0dfe7e0900		LEAQ runtime.sched+16(SB), CX	
  0x429db2		48890c24		MOVQ CX, 0(SP)			
  0x429db6		e8d5eafdff		CALL runtime.unlock(SB)		
		if _p_ != nil {
  0x429dbb		488b442478		MOVQ 0x78(SP), AX	
  0x429dc0		4885c0			TESTQ AX, AX		
  0x429dc3		0f849e010000		JE 0x429f67		
			acquirep(_p_)
  0x429dc9		48890424		MOVQ AX, 0(SP)			
  0x429dcd		e8fe460000		CALL runtime.acquirep(SB)	
	wasSpinning := _g_.m.spinning
  0x429dd2		0fb6442427		MOVZX 0x27(SP), AX	
  0x429dd7		84c0			TESTL AL, AL		
			if wasSpinning {
  0x429dd9		0f847b010000		JE 0x429f5a		
				_g_.m.spinning = true
  0x429ddf		488b842480000000	MOVQ 0x80(SP), AX	
  0x429de7		488b4830		MOVQ 0x30(AX), CX	
  0x429deb		c6811401000001		MOVB $0x1, 0x114(CX)	
				atomic.Xadd(&sched.nmspinning, 1)
  0x429df2		b901000000		MOVL $0x1, CX			
  0x429df7		488d15f67e0900		LEAQ runtime.sched+84(SB), DX	
  0x429dfe		f00fc10a		LOCK XADDL CX, 0(DX)		
			goto stop
  0x429e02		488b5c2478		MOVQ 0x78(SP), BX	
	_p_ := _g_.m.p.ptr()
  0x429e07		4889c2			MOVQ AX, DX		
		gp := globrunqget(_p_, 0)
  0x429e0a		4889d9			MOVQ BX, CX		
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x429e0d		833dbc2e0b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x429e14		0f84c7050000		JE 0x42a3e1				
  0x429e1a		8401			TESTB AL, 0(CX)				
  0x429e1c		4883b95812000000	CMPQ $0x0, 0x1258(CX)			
  0x429e24		0f84b0050000		JE 0x42a3da				
  0x429e2a		90			NOPL					
	if p != nil && !p.gcw.empty() {
  0x429e2b		90			NOPL			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x429e2c		488b8170120000		MOVQ 0x1270(CX), AX	
  0x429e33		4885c0			TESTQ AX, AX		
  0x429e36		0f8494050000		JE 0x42a3d0		
  0x429e3c		4883781000		CMPQ $0x0, 0x10(AX)	
  0x429e41		0f8582050000		JNE 0x42a3c9		
  0x429e47		488b8178120000		MOVQ 0x1278(CX), AX	
  0x429e4e		4883781000		CMPQ $0x0, 0x10(AX)	
  0x429e53		0f94c0			SETE AL			
	if p != nil && !p.gcw.empty() {
  0x429e56		84c0			TESTL AL, AL		
  0x429e58		0f8461050000		JE 0x42a3bf		
	if !work.full.empty() {
  0x429e5e		90			NOPL			
	return atomic.Load64((*uint64)(head)) == 0
  0x429e5f		488b051a810900		MOVQ runtime.work(SB), AX	
  0x429e66		4885c0			TESTQ AX, AX			
	if !work.full.empty() {
  0x429e69		0f8546050000		JNE 0x42a3b5		
	if work.markrootNext < work.markrootJobs {
  0x429e6f		8b0597810900		MOVL runtime.work+140(SB), AX	
  0x429e75		39058d810900		CMPL AX, runtime.work+136(SB)	
  0x429e7b		0f832d050000		JAE 0x42a3ae			
  0x429e81		b801000000		MOVL $0x1, AX			
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x429e86		84c0			TESTL AL, AL		
  0x429e88		0f859e040000		JNE 0x42a32c		
		gp := globrunqget(_p_, 0)
  0x429e8e		48894c2458		MOVQ CX, 0x58(SP)	
	if beforeIdle() {
  0x429e93		90			NOPL			
	allpSnapshot := allp
  0x429e94		488b058d7b0900		MOVQ runtime.allp+8(SB), AX	
  0x429e9b		4889442438		MOVQ AX, 0x38(SP)		
  0x429ea0		488b0d797b0900		MOVQ runtime.allp(SB), CX	
  0x429ea7		48894c2470		MOVQ CX, 0x70(SP)		
	lock(&sched.lock)
  0x429eac		488d15fd7d0900		LEAQ runtime.sched+16(SB), DX	
  0x429eb3		48891424		MOVQ DX, 0(SP)			
  0x429eb7		e824e8fdff		CALL runtime.lock(SB)		
	if sched.gcwaiting != 0 || _p_.runSafePointFn != 0 {
  0x429ebc		833dd57e090000		CMPL $0x0, runtime.sched+248(SB)	
  0x429ec3		0f8546040000		JNE 0x42a30f				
  0x429ec9		488b442458		MOVQ 0x58(SP), AX			
  0x429ece		8400			TESTB AL, 0(AX)				
  0x429ed0		83b83823000000		CMPL $0x0, 0x2338(AX)			
  0x429ed7		0f8532040000		JNE 0x42a30f				
	if sched.runqsize != 0 {
  0x429edd		833d247e090000		CMPL $0x0, runtime.sched+104(SB)	
  0x429ee4		0f85d5030000		JNE 0x42a2bf				
	if releasep() != _p_ {
  0x429eea		e8a1470000		CALL runtime.releasep(SB)	
  0x429eef		488b442458		MOVQ 0x58(SP), AX		
  0x429ef4		48390424		CMPQ AX, 0(SP)			
  0x429ef8		0f8559070000		JNE 0x42a657			
	pidleput(_p_)
  0x429efe		48890424		MOVQ AX, 0(SP)			
  0x429f02		e879640000		CALL runtime.pidleput(SB)	
	unlock(&sched.lock)
  0x429f07		488d05a27d0900		LEAQ runtime.sched+16(SB), AX	
  0x429f0e		48890424		MOVQ AX, 0(SP)			
  0x429f12		e879e9fdff		CALL runtime.unlock(SB)		
	if _g_.m.spinning {
  0x429f17		488b842480000000	MOVQ 0x80(SP), AX	
  0x429f1f		488b4830		MOVQ 0x30(AX), CX	
	wasSpinning := _g_.m.spinning
  0x429f23		0fb69114010000		MOVZX 0x114(CX), DX	
  0x429f2a		84d2			TESTL DL, DL		
	if _g_.m.spinning {
  0x429f2c		7421			JE 0x429f4f		
		_g_.m.spinning = false
  0x429f2e		c6811401000000		MOVB $0x0, 0x114(CX)	
		if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
  0x429f35		b9ffffffff		MOVL $-0x1, CX			
  0x429f3a		488d1db37d0900		LEAQ runtime.sched+84(SB), BX	
  0x429f41		f00fc10b		LOCK XADDL CX, 0(BX)		
  0x429f45		ffc9			DECL CX				
  0x429f47		85c9			TESTL CX, CX			
  0x429f49		0f8ced060000		JL 0x42a63c			
	wasSpinning := _g_.m.spinning
  0x429f4f		88542427		MOVB DL, 0x27(SP)	
  0x429f53		31c9			XORL CX, CX		
	for _, _p_ := range allpSnapshot {
  0x429f55		e930fdffff		JMP 0x429c8a		
	_p_ := _g_.m.p.ptr()
  0x429f5a		488b842480000000	MOVQ 0x80(SP), AX	
			if wasSpinning {
  0x429f62		e99bfeffff		JMP 0x429e02		
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Xchg64(&sched.lastpoll, 0) != 0 {
  0x429f67		90			NOPL			
	return atomic.Load(&netpollInited) != 0
  0x429f68		8b057a2d0b00		MOVL runtime.netpollInited(SB), AX	
  0x429f6e		85c0			TESTL AX, AX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Xchg64(&sched.lastpoll, 0) != 0 {
  0x429f70		0f84aa010000		JE 0x42a120				
  0x429f76		8b05702d0b00		MOVL runtime.netpollWaiters(SB), AX	
  0x429f7c		85c0			TESTL AX, AX				
  0x429f7e		0f97c0			SETA AL					
  0x429f81		84c0			TESTL AL, AL				
  0x429f83		0f8490010000		JE 0x42a119				
  0x429f89		31c0			XORL AX, AX				
  0x429f8b		488d0d167d0900		LEAQ runtime.sched+8(SB), CX		
  0x429f92		488701			XCHGQ AX, 0(CX)				
  0x429f95		4885c0			TESTQ AX, AX				
  0x429f98		0f95c0			SETNE AL				
  0x429f9b		84c0			TESTL AL, AL				
  0x429f9d		7456			JE 0x429ff5				
		if _g_.m.p != 0 {
  0x429f9f		488b842480000000	MOVQ 0x80(SP), AX	
  0x429fa7		488b4830		MOVQ 0x30(AX), CX	
  0x429fab		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x429fb3		0f8568060000		JNE 0x42a621		
		if _g_.m.spinning {
  0x429fb9		80b91401000000		CMPB $0x0, 0x114(CX)	
  0x429fc0		0f8540060000		JNE 0x42a606		
		list := netpoll(true) // block until new work is available
  0x429fc6		c6042401		MOVB $0x1, 0(SP)		
  0x429fca		e80171ffff		CALL runtime.netpoll(SB)	
  0x429fcf		488b442408		MOVQ 0x8(SP), AX		
  0x429fd4		4889442428		MOVQ AX, 0x28(SP)		
		atomic.Store64(&sched.lastpoll, uint64(nanotime()))
  0x429fd9		e8d2100200		CALL runtime.nanotime(SB)	
  0x429fde		488b0424		MOVQ 0(SP), AX			
  0x429fe2		488d0dbf7c0900		LEAQ runtime.sched+8(SB), CX	
  0x429fe9		488701			XCHGQ AX, 0(CX)			
		if !list.empty() {
  0x429fec		90			NOPL			
	return l.head == 0
  0x429fed		48837c242800		CMPQ $0x0, 0x28(SP)	
		if !list.empty() {
  0x429ff3		7512			JNE 0x42a007		
	stopm()
  0x429ff5		e8e6edffff		CALL runtime.stopm(SB)	
	_p_ := _g_.m.p.ptr()
  0x429ffa		488b842480000000	MOVQ 0x80(SP), AX	
	goto top
  0x42a002		e98d010000		JMP 0x42a194		
			lock(&sched.lock)
  0x42a007		488d05a27c0900		LEAQ runtime.sched+16(SB), AX	
  0x42a00e		48890424		MOVQ AX, 0(SP)			
  0x42a012		e8c9e6fdff		CALL runtime.lock(SB)		
			_p_ = pidleget()
  0x42a017		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x42a018		488b05c97c0900		MOVQ runtime.sched+72(SB), AX	
  0x42a01f		90			NOPL				
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42a020		4889842488000000	MOVQ AX, 0x88(SP)	
	if _p_ != nil {
  0x42a028		4885c0			TESTQ AX, AX		
  0x42a02b		741b			JE 0x42a048		
		sched.pidle = _p_.link
  0x42a02d		488b4810		MOVQ 0x10(AX), CX		
  0x42a031		48890db07c0900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42a038		b9ffffffff		MOVL $-0x1, CX			
  0x42a03d		488d15ac7c0900		LEAQ runtime.sched+80(SB), DX	
  0x42a044		f00fc10a		LOCK XADDL CX, 0(DX)		
			unlock(&sched.lock)
  0x42a048		488d05617c0900		LEAQ runtime.sched+16(SB), AX	
  0x42a04f		48890424		MOVQ AX, 0(SP)			
  0x42a053		e838e8fdff		CALL runtime.unlock(SB)		
	if _p_ != nil {
  0x42a058		488b842488000000	MOVQ 0x88(SP), AX	
  0x42a060		4885c0			TESTQ AX, AX		
			if _p_ != nil {
  0x42a063		7510			JNE 0x42a075		
			injectglist(&list)
  0x42a065		488d442428		LEAQ 0x28(SP), AX		
  0x42a06a		48890424		MOVQ AX, 0(SP)			
  0x42a06e		e8fd070000		CALL runtime.injectglist(SB)	
  0x42a073		eb80			JMP 0x429ff5			
				acquirep(_p_)
  0x42a075		48890424		MOVQ AX, 0(SP)			
  0x42a079		e852440000		CALL runtime.acquirep(SB)	
				gp := list.pop()
  0x42a07e		90			NOPL			
	gp := l.head.ptr()
  0x42a07f		488b442428		MOVQ 0x28(SP), AX	
  0x42a084		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42a085		4889842488000000	MOVQ AX, 0x88(SP)	
	if gp != nil {
  0x42a08d		4885c0			TESTQ AX, AX		
  0x42a090		740c			JE 0x42a09e		
		l.head = gp.schedlink
  0x42a092		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x42a099		48894c2428		MOVQ CX, 0x28(SP)	
				injectglist(&list)
  0x42a09e		488d442428		LEAQ 0x28(SP), AX		
  0x42a0a3		48890424		MOVQ AX, 0(SP)			
  0x42a0a7		e8c4070000		CALL runtime.injectglist(SB)	
				casgstatus(gp, _Gwaiting, _Grunnable)
  0x42a0ac		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a0b4		48890424		MOVQ AX, 0(SP)			
  0x42a0b8		48b90400000001000000	MOVQ $0x100000004, CX		
  0x42a0c2		48894c2408		MOVQ CX, 0x8(SP)		
  0x42a0c7		e8d4cbffff		CALL runtime.casgstatus(SB)	
				if trace.enabled {
  0x42a0cc		803dfd2a0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42a0d3		7528			JNE 0x42a0fd			
				return gp, false
  0x42a0d5		488b842488000000	MOVQ 0x88(SP), AX	
  0x42a0dd		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a0e5		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x42a0ed		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a0f5		4881c498000000		ADDQ $0x98, SP		
  0x42a0fc		c3			RET			
					traceGoUnpark(gp, 0)
  0x42a0fd		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a105		48890424		MOVQ AX, 0(SP)			
  0x42a109		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42a112		e8a9300100		CALL runtime.traceGoUnpark(SB)	
  0x42a117		ebbc			JMP 0x42a0d5			
  0x42a119		31c0			XORL AX, AX			
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Xchg64(&sched.lastpoll, 0) != 0 {
  0x42a11b		e97bfeffff		JMP 0x429f9b		
  0x42a120		31c0			XORL AX, AX		
  0x42a122		e95afeffff		JMP 0x429f81		
			pidleput(_p_)
  0x42a127		48890424		MOVQ AX, 0(SP)			
  0x42a12b		e850620000		CALL runtime.pidleput(SB)	
  0x42a130		31c0			XORL AX, AX			
			_p_ = nil
  0x42a132		e96ffcffff		JMP 0x429da6		
	if atomic.Load(&sched.npidle) == procs-1 {
  0x42a137		488d15b27b0900		LEAQ runtime.sched+80(SB), DX	
	if _p_ != nil {
  0x42a13e		e953fcffff		JMP 0x429d96		
  0x42a143		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && gcMarkWorkAvailable(nil) {
  0x42a145		e904fcffff		JMP 0x429d4e		
  0x42a14a		b801000000		MOVL $0x1, AX		
  0x42a14f		e9fafbffff		JMP 0x429d4e		
  0x42a154		31c0			XORL AX, AX		
  0x42a156		e9f3fbffff		JMP 0x429d4e		
				acquirep(_p_)
  0x42a15b		48890424		MOVQ AX, 0(SP)			
  0x42a15f		e86c430000		CALL runtime.acquirep(SB)	
	wasSpinning := _g_.m.spinning
  0x42a164		0fb6442427		MOVZX 0x27(SP), AX	
  0x42a169		84c0			TESTL AL, AL		
				if wasSpinning {
  0x42a16b		0f8441010000		JE 0x42a2b2		
					_g_.m.spinning = true
  0x42a171		488b842480000000	MOVQ 0x80(SP), AX	
  0x42a179		488b4830		MOVQ 0x30(AX), CX	
  0x42a17d		c6811401000001		MOVB $0x1, 0x114(CX)	
					atomic.Xadd(&sched.nmspinning, 1)
  0x42a184		b901000000		MOVL $0x1, CX			
  0x42a189		488d15647b0900		LEAQ runtime.sched+84(SB), DX	
  0x42a190		f00fc10a		LOCK XADDL CX, 0(DX)		
	_p_ := _g_.m.p.ptr()
  0x42a194		488b4830		MOVQ 0x30(AX), CX	
  0x42a198		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42a19f		90			NOPL			
	if sched.gcwaiting != 0 {
  0x42a1a0		833df17b090000		CMPL $0x0, runtime.sched+248(SB)	
  0x42a1a7		740f			JE 0x42a1b8				
		gcstopm()
  0x42a1a9		e882f6ffff		CALL runtime.gcstopm(SB)	
	_p_ := _g_.m.p.ptr()
  0x42a1ae		488b842480000000	MOVQ 0x80(SP), AX	
		goto top
  0x42a1b6		ebdc			JMP 0x42a194		
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42a1b8		48898c2488000000	MOVQ CX, 0x88(SP)	
	if _p_.runSafePointFn != 0 {
  0x42a1c0		8401			TESTB AL, 0(CX)		
  0x42a1c2		83b93823000000		CMPL $0x0, 0x2338(CX)	
  0x42a1c9		0f851d040000		JNE 0x42a5ec		
	if fingwait && fingwake {
  0x42a1cf		803dd22a0b0000		CMPB $0x0, runtime.fingwait(SB)	
  0x42a1d6		740d			JE 0x42a1e5			
  0x42a1d8		803dca2a0b0000		CMPB $0x0, runtime.fingwake(SB)	
  0x42a1df		0f85d1030000		JNE 0x42a5b6			
	if *cgo_yield != nil {
  0x42a1e5		488b153c590900		MOVQ runtime.cgo_yield(SB), DX	
  0x42a1ec		488b12			MOVQ 0(DX), DX			
  0x42a1ef		4885d2			TESTQ DX, DX			
  0x42a1f2		0f859f030000		JNE 0x42a597			
	if gp, inheritTime := runqget(_p_); gp != nil {
  0x42a1f8		48890c24		MOVQ CX, 0(SP)			
  0x42a1fc		e87f650000		CALL runtime.runqget(SB)	
  0x42a201		488b442408		MOVQ 0x8(SP), AX		
  0x42a206		0fb64c2410		MOVZX 0x10(SP), CX		
  0x42a20b		4885c0			TESTQ AX, AX			
  0x42a20e		0f8564030000		JNE 0x42a578			
	if sched.runqsize != 0 {
  0x42a214		833ded7a090000		CMPL $0x0, runtime.sched+104(SB)	
  0x42a21b		0f85e6020000		JNE 0x42a507				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
  0x42a221		90			NOPL			
	return atomic.Load(&netpollInited) != 0
  0x42a222		8b0dc02a0b00		MOVL runtime.netpollInited(SB), CX	
  0x42a228		85c9			TESTL CX, CX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
  0x42a22a		0f84d0020000		JE 0x42a500				
  0x42a230		8b0db62a0b00		MOVL runtime.netpollWaiters(SB), CX	
  0x42a236		85c9			TESTL CX, CX				
  0x42a238		0f97c1			SETA CL					
  0x42a23b		84c9			TESTL CL, CL				
  0x42a23d		0f84b6020000		JE 0x42a4f9				
  0x42a243		488b0d5e7a0900		MOVQ runtime.sched+8(SB), CX		
  0x42a24a		4885c9			TESTQ CX, CX				
  0x42a24d		0f95c1			SETNE CL				
  0x42a250		84c9			TESTL CL, CL				
  0x42a252		0f85ee010000		JNE 0x42a446				
	procs := uint32(gomaxprocs)
  0x42a258		8b0d822a0b00		MOVL runtime.gomaxprocs(SB), CX	
	if atomic.Load(&sched.npidle) == procs-1 {
  0x42a25e		8b158c7a0900		MOVL runtime.sched+80(SB), DX	
  0x42a264		8d59ff			LEAL -0x1(CX), BX		
  0x42a267		39d3			CMPL DX, BX			
  0x42a269		0f84bf010000		JE 0x42a42e			
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x42a26f		488b942480000000	MOVQ 0x80(SP), DX	
  0x42a277		488b5a30		MOVQ 0x30(DX), BX	
  0x42a27b		80bb1401000000		CMPB $0x0, 0x114(BX)	
  0x42a282		0f848c010000		JE 0x42a414		
  0x42a288		31c0			XORL AX, AX		
  0x42a28a		84c0			TESTL AL, AL		
  0x42a28c		0f8572010000		JNE 0x42a404		
	if !_g_.m.spinning {
  0x42a292		488b4a30		MOVQ 0x30(DX), CX	
  0x42a296		80b91401000000		CMPB $0x0, 0x114(CX)	
  0x42a29d		0f8445010000		JE 0x42a3e8		
	for i := 0; i < 4; i++ {
  0x42a2a3		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x42a2ab		31c0			XORL AX, AX		
  0x42a2ad		e909f9ffff		JMP 0x429bbb		
	_p_ := _g_.m.p.ptr()
  0x42a2b2		488b842480000000	MOVQ 0x80(SP), AX	
				if wasSpinning {
  0x42a2ba		e9d5feffff		JMP 0x42a194		
		gp := globrunqget(_p_, 0)
  0x42a2bf		48890424		MOVQ AX, 0(SP)			
  0x42a2c3		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x42a2cb		e8605f0000		CALL runtime.globrunqget(SB)	
  0x42a2d0		488b442410		MOVQ 0x10(SP), AX		
  0x42a2d5		4889442460		MOVQ AX, 0x60(SP)		
		unlock(&sched.lock)
  0x42a2da		488d0dcf790900		LEAQ runtime.sched+16(SB), CX	
  0x42a2e1		48890c24		MOVQ CX, 0(SP)			
  0x42a2e5		e8a6e5fdff		CALL runtime.unlock(SB)		
		return gp, false
  0x42a2ea		488b442460		MOVQ 0x60(SP), AX	
  0x42a2ef		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a2f7		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x42a2ff		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a307		4881c498000000		ADDQ $0x98, SP		
  0x42a30e		c3			RET			
		unlock(&sched.lock)
  0x42a30f		488d059a790900		LEAQ runtime.sched+16(SB), AX	
  0x42a316		48890424		MOVQ AX, 0(SP)			
  0x42a31a		e871e5fdff		CALL runtime.unlock(SB)		
	_p_ := _g_.m.p.ptr()
  0x42a31f		488b842480000000	MOVQ 0x80(SP), AX	
		goto top
  0x42a327		e968feffff		JMP 0x42a194		
		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode
  0x42a32c		8401			TESTB AL, 0(CX)		
  0x42a32e		48c7816012000002000000	MOVQ $0x2, 0x1260(CX)	
		gp := _p_.gcBgMarkWorker.ptr()
  0x42a339		488b8158120000		MOVQ 0x1258(CX), AX	
  0x42a340		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42a341		4889842488000000	MOVQ AX, 0x88(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x42a349		48890424		MOVQ AX, 0(SP)			
  0x42a34d		48b90400000001000000	MOVQ $0x100000004, CX		
  0x42a357		48894c2408		MOVQ CX, 0x8(SP)		
  0x42a35c		e83fc9ffff		CALL runtime.casgstatus(SB)	
		if trace.enabled {
  0x42a361		803d68280a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42a368		7528			JNE 0x42a392			
		return gp, false
  0x42a36a		488b842488000000	MOVQ 0x88(SP), AX	
  0x42a372		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a37a		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x42a382		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a38a		4881c498000000		ADDQ $0x98, SP		
  0x42a391		c3			RET			
			traceGoUnpark(gp, 0)
  0x42a392		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a39a		48890424		MOVQ AX, 0(SP)			
  0x42a39e		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42a3a7		e8142e0100		CALL runtime.traceGoUnpark(SB)	
  0x42a3ac		ebbc			JMP 0x42a36a			
  0x42a3ae		31c0			XORL AX, AX			
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x42a3b0		e9d1faffff		JMP 0x429e86		
  0x42a3b5		b801000000		MOVL $0x1, AX		
  0x42a3ba		e9c7faffff		JMP 0x429e86		
  0x42a3bf		b801000000		MOVL $0x1, AX		
  0x42a3c4		e9bdfaffff		JMP 0x429e86		
  0x42a3c9		31c0			XORL AX, AX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x42a3cb		e986faffff		JMP 0x429e56		
  0x42a3d0		b801000000		MOVL $0x1, AX		
  0x42a3d5		e97cfaffff		JMP 0x429e56		
  0x42a3da		31c0			XORL AX, AX		
	if gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
  0x42a3dc		e9a5faffff		JMP 0x429e86		
  0x42a3e1		31c0			XORL AX, AX		
  0x42a3e3		e99efaffff		JMP 0x429e86		
		_g_.m.spinning = true
  0x42a3e8		c6811401000001		MOVB $0x1, 0x114(CX)	
		atomic.Xadd(&sched.nmspinning, 1)
  0x42a3ef		b901000000		MOVL $0x1, CX			
  0x42a3f4		488d1df9780900		LEAQ runtime.sched+84(SB), BX	
  0x42a3fb		f00fc10b		LOCK XADDL CX, 0(BX)		
  0x42a3ff		e99ffeffff		JMP 0x42a2a3			
		goto stop
  0x42a404		488b842488000000	MOVQ 0x88(SP), AX	
		gp := globrunqget(_p_, 0)
  0x42a40c		4889c1			MOVQ AX, CX		
		goto stop
  0x42a40f		e9f9f9ffff		JMP 0x429e0d		
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x42a414		8b1dda780900		MOVL runtime.sched+84(SB), BX	
  0x42a41a		8b35d0780900		MOVL runtime.sched+80(SB), SI	
  0x42a420		d1e3			SHLL $0x1, BX			
  0x42a422		29f1			SUBL SI, CX			
  0x42a424		39cb			CMPL CX, BX			
  0x42a426		0f93c0			SETAE AL			
  0x42a429		e95cfeffff		JMP 0x42a28a			
		goto stop
  0x42a42e		488b842488000000	MOVQ 0x88(SP), AX	
	_p_ := _g_.m.p.ptr()
  0x42a436		488b942480000000	MOVQ 0x80(SP), DX	
		gp := globrunqget(_p_, 0)
  0x42a43e		4889c1			MOVQ AX, CX		
		goto stop
  0x42a441		e9c7f9ffff		JMP 0x429e0d		
		if list := netpoll(false); !list.empty() { // non-blocking
  0x42a446		c6042400		MOVB $0x0, 0(SP)		
  0x42a44a		e8816cffff		CALL runtime.netpoll(SB)	
  0x42a44f		488b442408		MOVQ 0x8(SP), AX		
  0x42a454		4889442430		MOVQ AX, 0x30(SP)		
  0x42a459		90			NOPL				
	return l.head == 0
  0x42a45a		4885c0			TESTQ AX, AX		
		if list := netpoll(false); !list.empty() { // non-blocking
  0x42a45d		0f84f5fdffff		JE 0x42a258		
			gp := list.pop()
  0x42a463		90			NOPL			
	gp := l.head.ptr()
  0x42a464		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42a465		4889842488000000	MOVQ AX, 0x88(SP)	
	if gp != nil {
  0x42a46d		4885c0			TESTQ AX, AX		
  0x42a470		740c			JE 0x42a47e		
		l.head = gp.schedlink
  0x42a472		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x42a479		48894c2430		MOVQ CX, 0x30(SP)	
			injectglist(&list)
  0x42a47e		488d442430		LEAQ 0x30(SP), AX		
  0x42a483		48890424		MOVQ AX, 0(SP)			
  0x42a487		e8e4030000		CALL runtime.injectglist(SB)	
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x42a48c		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a494		48890424		MOVQ AX, 0(SP)			
  0x42a498		48b90400000001000000	MOVQ $0x100000004, CX		
  0x42a4a2		48894c2408		MOVQ CX, 0x8(SP)		
  0x42a4a7		e8f4c7ffff		CALL runtime.casgstatus(SB)	
			if trace.enabled {
  0x42a4ac		803d1d270a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42a4b3		7528			JNE 0x42a4dd			
			return gp, false
  0x42a4b5		488b842488000000	MOVQ 0x88(SP), AX	
  0x42a4bd		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a4c5		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x42a4cd		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a4d5		4881c498000000		ADDQ $0x98, SP		
  0x42a4dc		c3			RET			
				traceGoUnpark(gp, 0)
  0x42a4dd		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a4e5		48890424		MOVQ AX, 0(SP)			
  0x42a4e9		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42a4f2		e8c92c0100		CALL runtime.traceGoUnpark(SB)	
  0x42a4f7		ebbc			JMP 0x42a4b5			
  0x42a4f9		31c9			XORL CX, CX			
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && atomic.Load64(&sched.lastpoll) != 0 {
  0x42a4fb		e950fdffff		JMP 0x42a250		
  0x42a500		31c9			XORL CX, CX		
  0x42a502		e934fdffff		JMP 0x42a23b		
		lock(&sched.lock)
  0x42a507		488d05a2770900		LEAQ runtime.sched+16(SB), AX	
  0x42a50e		48890424		MOVQ AX, 0(SP)			
  0x42a512		e8c9e1fdff		CALL runtime.lock(SB)		
		gp := globrunqget(_p_, 0)
  0x42a517		488b842488000000	MOVQ 0x88(SP), AX		
  0x42a51f		48890424		MOVQ AX, 0(SP)			
  0x42a523		c744240800000000	MOVL $0x0, 0x8(SP)		
  0x42a52b		e8005d0000		CALL runtime.globrunqget(SB)	
  0x42a530		488b442410		MOVQ 0x10(SP), AX		
  0x42a535		4889442468		MOVQ AX, 0x68(SP)		
		unlock(&sched.lock)
  0x42a53a		488d0d6f770900		LEAQ runtime.sched+16(SB), CX	
  0x42a541		48890c24		MOVQ CX, 0(SP)			
  0x42a545		e846e3fdff		CALL runtime.unlock(SB)		
		if gp != nil {
  0x42a54a		488b442468		MOVQ 0x68(SP), AX	
  0x42a54f		4885c0			TESTQ AX, AX		
  0x42a552		0f84c9fcffff		JE 0x42a221		
			return gp, false
  0x42a558		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a560		c68424a800000000	MOVB $0x0, 0xa8(SP)	
  0x42a568		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a570		4881c498000000		ADDQ $0x98, SP		
  0x42a577		c3			RET			
		return gp, inheritTime
  0x42a578		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x42a580		888c24a8000000		MOVB CL, 0xa8(SP)	
  0x42a587		488bac2490000000	MOVQ 0x90(SP), BP	
  0x42a58f		4881c498000000		ADDQ $0x98, SP		
  0x42a596		c3			RET			
		asmcgocall(*cgo_yield, nil)
  0x42a597		48891424		MOVQ DX, 0(SP)			
  0x42a59b		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42a5a4		e857e90100		CALL runtime.asmcgocall(SB)	
	if gp, inheritTime := runqget(_p_); gp != nil {
  0x42a5a9		488b8c2488000000	MOVQ 0x88(SP), CX	
		asmcgocall(*cgo_yield, nil)
  0x42a5b1		e942fcffff		JMP 0x42a1f8		
		if gp := wakefing(); gp != nil {
  0x42a5b6		e84575feff		CALL runtime.wakefing(SB)	
  0x42a5bb		48833c2400		CMPQ $0x0, 0(SP)		
  0x42a5c0		7515			JNE 0x42a5d7			
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x42a5c2		488b842480000000	MOVQ 0x80(SP), AX	
	if gp, inheritTime := runqget(_p_); gp != nil {
  0x42a5ca		488b8c2488000000	MOVQ 0x88(SP), CX	
	if *cgo_yield != nil {
  0x42a5d2		e90efcffff		JMP 0x42a1e5		
			ready(gp, 0, true)
  0x42a5d7		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x42a5e0		c644241001		MOVB $0x1, 0x10(SP)	
  0x42a5e5		e806beffff		CALL runtime.ready(SB)	
  0x42a5ea		ebd6			JMP 0x42a5c2		
		runSafePointFn()
  0x42a5ec		e84fdbffff		CALL runtime.runSafePointFn(SB)	
	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= procs-atomic.Load(&sched.npidle) {
  0x42a5f1		488b842480000000	MOVQ 0x80(SP), AX	
	if gp, inheritTime := runqget(_p_); gp != nil {
  0x42a5f9		488b8c2488000000	MOVQ 0x88(SP), CX	
		runSafePointFn()
  0x42a601		e9c9fbffff		JMP 0x42a1cf		
			throw("findrunnable: netpoll with spinning")
  0x42a606		488d052c7e0400		LEAQ 0x47e2c(IP), AX	
  0x42a60d		48890424		MOVQ AX, 0(SP)		
  0x42a611		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x42a61a		e8618effff		CALL runtime.throw(SB)	
  0x42a61f		0f0b			UD2			
			throw("findrunnable: netpoll with p")
  0x42a621		488d0572700400		LEAQ 0x47072(IP), AX	
  0x42a628		48890424		MOVQ AX, 0(SP)		
  0x42a62c		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42a635		e8468effff		CALL runtime.throw(SB)	
  0x42a63a		0f0b			UD2			
			throw("findrunnable: negative nmspinning")
  0x42a63c		488d05d47a0400		LEAQ 0x47ad4(IP), AX	
  0x42a643		48890424		MOVQ AX, 0(SP)		
  0x42a647		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x42a650		e82b8effff		CALL runtime.throw(SB)	
  0x42a655		0f0b			UD2			
		throw("findrunnable: wrong p")
  0x42a657		488d05e5610400		LEAQ 0x461e5(IP), AX	
  0x42a65e		48890424		MOVQ AX, 0(SP)		
  0x42a662		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42a66b		e8108effff		CALL runtime.throw(SB)	
  0x42a670		0f0b			UD2			
	enum.pos = (enum.pos + enum.inc) % enum.count
  0x42a672		e8097bffff		CALL runtime.panicdivide(SB)	
  0x42a677		0f0b			UD2				
			if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
  0x42a679		e8a278ffff		CALL runtime.panicindex(SB)	
  0x42a67e		0f0b			UD2				
		inc:   ord.coprimes[i%uint32(len(ord.coprimes))],
  0x42a680		e89b78ffff		CALL runtime.panicindex(SB)	
  0x42a685		0f0b			UD2				
  0x42a687		e8f47affff		CALL runtime.panicdivide(SB)	
  0x42a68c		0f0b			UD2				
		pos:   i % ord.count,
  0x42a68e		e8ed7affff		CALL runtime.panicdivide(SB)	
  0x42a693		0f0b			UD2				
func findrunnable() (gp *g, inheritTime bool) {
  0x42a695		e8e6d10100		CALL runtime.morestack_noctxt(SB)	
  0x42a69a		e911f4ffff		JMP runtime.findrunnable(SB)		

TEXT runtime.pollWork(SB) /usr/local/go/src/runtime/proc.go
func pollWork() bool {
  0x42a6a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a6a9		483b6110		CMPQ 0x10(CX), SP	
  0x42a6ad		0f86cb000000		JBE 0x42a77e		
  0x42a6b3		4883ec20		SUBQ $0x20, SP		
  0x42a6b7		48896c2418		MOVQ BP, 0x18(SP)	
  0x42a6bc		488d6c2418		LEAQ 0x18(SP), BP	
	if sched.runqsize != 0 {
  0x42a6c1		833d4076090000		CMPL $0x0, runtime.sched+104(SB)	
  0x42a6c8		0f85a1000000		JNE 0x42a76f				
	p := getg().m.p.ptr()
  0x42a6ce		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42a6d7		488b4030		MOVQ 0x30(AX), AX	
  0x42a6db		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x42a6e2		90			NOPL			
	if !runqempty(p) {
  0x42a6e3		48890424		MOVQ AX, 0(SP)			
  0x42a6e7		e8245d0000		CALL runtime.runqempty(SB)	
  0x42a6ec		807c240800		CMPB $0x0, 0x8(SP)		
  0x42a6f1		746d			JE 0x42a760			
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && sched.lastpoll != 0 {
  0x42a6f3		90			NOPL			
	return atomic.Load(&netpollInited) != 0
  0x42a6f4		8b05ee250b00		MOVL runtime.netpollInited(SB), AX	
  0x42a6fa		85c0			TESTL AX, AX				
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && sched.lastpoll != 0 {
  0x42a6fc		745e			JE 0x42a75c				
  0x42a6fe		8b05e8250b00		MOVL runtime.netpollWaiters(SB), AX	
  0x42a704		85c0			TESTL AX, AX				
  0x42a706		0f97c0			SETA AL					
  0x42a709		84c0			TESTL AL, AL				
  0x42a70b		740a			JE 0x42a717				
  0x42a70d		48833d9375090000	CMPQ $0x0, runtime.sched+8(SB)		
  0x42a715		750f			JNE 0x42a726				
	return false
  0x42a717		c644242800		MOVB $0x0, 0x28(SP)	
  0x42a71c		488b6c2418		MOVQ 0x18(SP), BP	
  0x42a721		4883c420		ADDQ $0x20, SP		
  0x42a725		c3			RET			
		if list := netpoll(false); !list.empty() {
  0x42a726		c6042400		MOVB $0x0, 0(SP)		
  0x42a72a		e8a169ffff		CALL runtime.netpoll(SB)	
  0x42a72f		488b442408		MOVQ 0x8(SP), AX		
  0x42a734		4889442410		MOVQ AX, 0x10(SP)		
  0x42a739		90			NOPL				
	return l.head == 0
  0x42a73a		4885c0			TESTQ AX, AX		
		if list := netpoll(false); !list.empty() {
  0x42a73d		74d8			JE 0x42a717		
			injectglist(&list)
  0x42a73f		488d442410		LEAQ 0x10(SP), AX		
  0x42a744		48890424		MOVQ AX, 0(SP)			
  0x42a748		e823010000		CALL runtime.injectglist(SB)	
			return true
  0x42a74d		c644242801		MOVB $0x1, 0x28(SP)	
  0x42a752		488b6c2418		MOVQ 0x18(SP), BP	
  0x42a757		4883c420		ADDQ $0x20, SP		
  0x42a75b		c3			RET			
  0x42a75c		31c0			XORL AX, AX		
	if netpollinited() && atomic.Load(&netpollWaiters) > 0 && sched.lastpoll != 0 {
  0x42a75e		eba9			JMP 0x42a709		
		return true
  0x42a760		c644242801		MOVB $0x1, 0x28(SP)	
  0x42a765		488b6c2418		MOVQ 0x18(SP), BP	
  0x42a76a		4883c420		ADDQ $0x20, SP		
  0x42a76e		c3			RET			
		return true
  0x42a76f		c644242801		MOVB $0x1, 0x28(SP)	
  0x42a774		488b6c2418		MOVQ 0x18(SP), BP	
  0x42a779		4883c420		ADDQ $0x20, SP		
  0x42a77d		c3			RET			
func pollWork() bool {
  0x42a77e		e8fdd00100		CALL runtime.morestack_noctxt(SB)	
  0x42a783		e918ffffff		JMP runtime.pollWork(SB)		

TEXT runtime.resetspinning(SB) /usr/local/go/src/runtime/proc.go
func resetspinning() {
  0x42a790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a799		483b6110		CMPQ 0x10(CX), SP	
  0x42a79d		0f86bd000000		JBE 0x42a860		
  0x42a7a3		4883ec18		SUBQ $0x18, SP		
  0x42a7a7		48896c2410		MOVQ BP, 0x10(SP)	
  0x42a7ac		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x42a7b1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if !_g_.m.spinning {
  0x42a7ba		488b4930		MOVQ 0x30(CX), CX	
  0x42a7be		80b91401000000		CMPB $0x0, 0x114(CX)	
  0x42a7c5		747e			JE 0x42a845		
	_g_.m.spinning = false
  0x42a7c7		c6811401000000		MOVB $0x0, 0x114(CX)	
	nmspinning := atomic.Xadd(&sched.nmspinning, -1)
  0x42a7ce		b9ffffffff		MOVL $-0x1, CX			
  0x42a7d3		488d151a750900		LEAQ runtime.sched+84(SB), DX	
  0x42a7da		f00fc10a		LOCK XADDL CX, 0(DX)		
  0x42a7de		ffc9			DECL CX				
	if int32(nmspinning) < 0 {
  0x42a7e0		85c9			TESTL CX, CX		
  0x42a7e2		7c46			JL 0x42a82a		
	if nmspinning == 0 && atomic.Load(&sched.npidle) > 0 {
  0x42a7e4		7540			JNE 0x42a826			
  0x42a7e6		8b0d04750900		MOVL runtime.sched+80(SB), CX	
  0x42a7ec		85c9			TESTL CX, CX			
  0x42a7ee		0f97c1			SETA CL				
  0x42a7f1		84c9			TESTL CL, CL			
  0x42a7f3		7413			JE 0x42a808			
		wakep()
  0x42a7f5		90			NOPL			
	if !atomic.Cas(&sched.nmspinning, 0, 1) {
  0x42a7f6		31c0			XORL AX, AX		
  0x42a7f8		b901000000		MOVL $0x1, CX		
  0x42a7fd		f00fb10a		LOCK CMPXCHGL CX, 0(DX)	
  0x42a801		0f94c1			SETE CL			
  0x42a804		84c9			TESTL CL, CL		
  0x42a806		750a			JNE 0x42a812		
  0x42a808		488b6c2410		MOVQ 0x10(SP), BP	
  0x42a80d		4883c418		ADDQ $0x18, SP		
  0x42a811		c3			RET			
	startm(nil, true)
  0x42a812		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x42a81a		c644240801		MOVB $0x1, 0x8(SP)	
  0x42a81f		e84ce7ffff		CALL runtime.startm(SB)	
		wakep()
  0x42a824		ebe2			JMP 0x42a808		
  0x42a826		31c9			XORL CX, CX		
	if nmspinning == 0 && atomic.Load(&sched.npidle) > 0 {
  0x42a828		ebc7			JMP 0x42a7f1		
		throw("findrunnable: negative nmspinning")
  0x42a82a		488d05e6780400		LEAQ 0x478e6(IP), AX	
  0x42a831		48890424		MOVQ AX, 0(SP)		
  0x42a835		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x42a83e		e83d8cffff		CALL runtime.throw(SB)	
  0x42a843		0f0b			UD2			
		throw("resetspinning: not a spinning m")
  0x42a845		488d05c8750400		LEAQ 0x475c8(IP), AX	
  0x42a84c		48890424		MOVQ AX, 0(SP)		
  0x42a850		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x42a859		e8228cffff		CALL runtime.throw(SB)	
  0x42a85e		0f0b			UD2			
func resetspinning() {
  0x42a860		e81bd00100		CALL runtime.morestack_noctxt(SB)	
  0x42a865		e926ffffff		JMP runtime.resetspinning(SB)		

TEXT runtime.injectglist(SB) /usr/local/go/src/runtime/proc.go
func injectglist(glist *gList) {
  0x42a870		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42a879		483b6110		CMPQ 0x10(CX), SP	
  0x42a87d		0f8669010000		JBE 0x42a9ec		
  0x42a883		4883ec30		SUBQ $0x30, SP		
  0x42a887		48896c2428		MOVQ BP, 0x28(SP)	
  0x42a88c		488d6c2428		LEAQ 0x28(SP), BP	
	if glist.empty() {
  0x42a891		90			NOPL			
  0x42a892		488b442438		MOVQ 0x38(SP), AX	
	return l.head == 0
  0x42a897		488b08			MOVQ 0(AX), CX		
  0x42a89a		4885c9			TESTQ CX, CX		
	if glist.empty() {
  0x42a89d		0f843f010000		JE 0x42a9e2		
	if trace.enabled {
  0x42a8a3		803d26230a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42a8aa		7431			JE 0x42a8dd			
		for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {
  0x42a8ac		90			NOPL			
  0x42a8ad		eb29			JMP 0x42a8d8		
  0x42a8af		48894c2418		MOVQ CX, 0x18(SP)	
			traceGoUnpark(gp, 0)
  0x42a8b4		48890c24		MOVQ CX, 0(SP)			
  0x42a8b8		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42a8c1		e8fa280100		CALL runtime.traceGoUnpark(SB)	
		for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {
  0x42a8c6		488b442418		MOVQ 0x18(SP), AX	
  0x42a8cb		488b88a0000000		MOVQ 0xa0(AX), CX	
  0x42a8d2		90			NOPL			
	return l.head == 0
  0x42a8d3		488b442438		MOVQ 0x38(SP), AX	
		for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {
  0x42a8d8		4885c9			TESTQ CX, CX		
  0x42a8db		75d2			JNE 0x42a8af		
	lock(&sched.lock)
  0x42a8dd		488d05cc730900		LEAQ runtime.sched+16(SB), AX	
  0x42a8e4		48890424		MOVQ AX, 0(SP)			
  0x42a8e8		e8f3ddfdff		CALL runtime.lock(SB)		
  0x42a8ed		31c0			XORL AX, AX			
	for n = 0; !glist.empty(); n++ {
  0x42a8ef		eb17			JMP 0x42a908		
	q.tail.set(gp)
  0x42a8f1		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a8f2		48891507740900		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42a8f9		ff0509740900		INCL runtime.sched+104(SB)	
	for n = 0; !glist.empty(); n++ {
  0x42a8ff		488b4c2410		MOVQ 0x10(SP), CX	
  0x42a904		488d4101		LEAQ 0x1(CX), AX	
	for ; n != 0 && sched.npidle != 0; n-- {
  0x42a908		4889442410		MOVQ AX, 0x10(SP)	
	for n = 0; !glist.empty(); n++ {
  0x42a90d		90			NOPL			
	return l.head == 0
  0x42a90e		488b4c2438		MOVQ 0x38(SP), CX	
  0x42a913		488b11			MOVQ 0(CX), DX		
  0x42a916		4885d2			TESTQ DX, DX		
	for n = 0; !glist.empty(); n++ {
  0x42a919		746d			JE 0x42a988		
		gp := glist.pop()
  0x42a91b		90			NOPL			
	gp := l.head.ptr()
  0x42a91c		90			NOPL			
	if gp != nil {
  0x42a91d		4885d2			TESTQ DX, DX		
  0x42a920		740a			JE 0x42a92c		
		l.head = gp.schedlink
  0x42a922		488b9aa0000000		MOVQ 0xa0(DX), BX	
  0x42a929		488919			MOVQ BX, 0(CX)		
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42a92c		4889542420		MOVQ DX, 0x20(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x42a931		48891424		MOVQ DX, 0(SP)			
  0x42a935		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42a93f		4889442408		MOVQ AX, 0x8(SP)		
  0x42a944		e857c3ffff		CALL runtime.casgstatus(SB)	
		globrunqput(gp)
  0x42a949		90			NOPL			
	sched.runq.pushBack(gp)
  0x42a94a		90			NOPL			
	gp.schedlink = 0
  0x42a94b		488b442420		MOVQ 0x20(SP), AX	
  0x42a950		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x42a95b		488b0d9e730900		MOVQ runtime.sched+96(SB), CX	
  0x42a962		4885c9			TESTQ CX, CX			
  0x42a965		7411			JE 0x42a978			
		q.tail.ptr().schedlink.set(gp)
  0x42a967		90			NOPL			
  0x42a968		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a969		4889c2			MOVQ AX, DX		
  0x42a96c		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x42a973		e979ffffff		JMP 0x42a8f1		
		q.head.set(gp)
  0x42a978		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42a979		4889c2			MOVQ AX, DX			
  0x42a97c		48890575730900		MOVQ AX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x42a983		e969ffffff		JMP 0x42a8f1		
	unlock(&sched.lock)
  0x42a988		488d0521730900		LEAQ runtime.sched+16(SB), AX	
  0x42a98f		48890424		MOVQ AX, 0(SP)			
  0x42a993		e8f8defdff		CALL runtime.unlock(SB)		
	for ; n != 0 && sched.npidle != 0; n-- {
  0x42a998		488b442410		MOVQ 0x10(SP), AX	
  0x42a99d		eb1f			JMP 0x42a9be		
  0x42a99f		4889442410		MOVQ AX, 0x10(SP)	
		startm(nil, false)
  0x42a9a4		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x42a9ac		c644240800		MOVB $0x0, 0x8(SP)	
  0x42a9b1		e8bae5ffff		CALL runtime.startm(SB)	
	for ; n != 0 && sched.npidle != 0; n-- {
  0x42a9b6		488b442410		MOVQ 0x10(SP), AX		
  0x42a9bb		48ffc8			DECQ AX				
  0x42a9be		4885c0			TESTQ AX, AX			
  0x42a9c1		7409			JE 0x42a9cc			
  0x42a9c3		833d2673090000		CMPL $0x0, runtime.sched+80(SB)	
  0x42a9ca		75d3			JNE 0x42a99f			
	*glist = gList{}
  0x42a9cc		488b442438		MOVQ 0x38(SP), AX	
  0x42a9d1		48c70000000000		MOVQ $0x0, 0(AX)	
}
  0x42a9d8		488b6c2428		MOVQ 0x28(SP), BP	
  0x42a9dd		4883c430		ADDQ $0x30, SP		
  0x42a9e1		c3			RET			
		return
  0x42a9e2		488b6c2428		MOVQ 0x28(SP), BP	
  0x42a9e7		4883c430		ADDQ $0x30, SP		
  0x42a9eb		c3			RET			
func injectglist(glist *gList) {
  0x42a9ec		e88fce0100		CALL runtime.morestack_noctxt(SB)	
  0x42a9f1		e97afeffff		JMP runtime.injectglist(SB)		

TEXT runtime.schedule(SB) /usr/local/go/src/runtime/proc.go
func schedule() {
  0x42aa00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42aa09		483b6110		CMPQ 0x10(CX), SP	
  0x42aa0d		0f8621040000		JBE 0x42ae34		
  0x42aa13		4883ec48		SUBQ $0x48, SP		
  0x42aa17		48896c2440		MOVQ BP, 0x40(SP)	
  0x42aa1c		488d6c2440		LEAQ 0x40(SP), BP	
	_g_ := getg()
  0x42aa21		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.locks != 0 {
  0x42aa2a		488b4830		MOVQ 0x30(AX), CX	
  0x42aa2e		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x42aa35		0f85de030000		JNE 0x42ae19		
	_g_ := getg()
  0x42aa3b		4889442430		MOVQ AX, 0x30(SP)	
	if _g_.m.lockedg != 0 {
  0x42aa40		4883b96801000000	CMPQ $0x0, 0x168(CX)	
  0x42aa48		0f8567030000		JNE 0x42adb5		
	if _g_.m.incgo {
  0x42aa4e		488b4830		MOVQ 0x30(AX), CX	
  0x42aa52		80b91901000000		CMPB $0x0, 0x119(CX)	
  0x42aa59		7413			JE 0x42aa6e		
  0x42aa5b		e99e030000		JMP 0x42adfe		
		startlockedm(gp)
  0x42aa60		48890424		MOVQ AX, 0(SP)			
  0x42aa64		e8f7ecffff		CALL runtime.startlockedm(SB)	
		goto top
  0x42aa69		488b442430		MOVQ 0x30(SP), AX	
	if sched.gcwaiting != 0 {
  0x42aa6e		833d2373090000		CMPL $0x0, runtime.sched+248(SB)	
  0x42aa75		0f852b030000		JNE 0x42ada6				
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x42aa7b		488b4830		MOVQ 0x30(AX), CX	
  0x42aa7f		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42aa86		8401			TESTB AL, 0(CX)		
  0x42aa88		90			NOPL			
  0x42aa89		83b93823000000		CMPL $0x0, 0x2338(CX)	
  0x42aa90		0f8501030000		JNE 0x42ad97		
	if trace.enabled || trace.shutdown {
  0x42aa96		803d33210a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42aa9d		0f84e0020000		JE 0x42ad83			
		gp = traceReader()
  0x42aaa3		e838120100		CALL runtime.traceReader(SB)	
  0x42aaa8		488b0424		MOVQ 0(SP), AX			
		if gp != nil {
  0x42aaac		4885c0			TESTQ AX, AX		
  0x42aaaf		0f8594020000		JNE 0x42ad49		
	if gp == nil && gcBlackenEnabled != 0 {
  0x42aab5		4885c0			TESTQ AX, AX		
  0x42aab8		0f844e020000		JE 0x42ad0c		
	if gp == nil {
  0x42aabe		4885c0			TESTQ AX, AX		
  0x42aac1		0f84b1010000		JE 0x42ac78		
	if gp == nil {
  0x42aac7		4885c0			TESTQ AX, AX		
  0x42aaca		0f845a010000		JE 0x42ac2a		
  0x42aad0		31c9			XORL CX, CX		
	if gp == nil {
  0x42aad2		4885c0			TESTQ AX, AX		
  0x42aad5		0f843c010000		JE 0x42ac17		
	execute(gp, inheritTime)
  0x42aadb		884c241f		MOVB CL, 0x1f(SP)	
		if schedEnabled(gp) {
  0x42aadf		4889442428		MOVQ AX, 0x28(SP)	
	if _g_.m.spinning {
  0x42aae4		488b542430		MOVQ 0x30(SP), DX	
  0x42aae9		488b5a30		MOVQ 0x30(DX), BX	
  0x42aaed		80bb1401000000		CMPB $0x0, 0x114(BX)	
  0x42aaf4		0f8504010000		JNE 0x42abfe		
	if sched.disable.user && !schedEnabled(gp) {
  0x42aafa		803d0f72090000		CMPB $0x0, runtime.sched+112(SB)	
  0x42ab01		0f85d2000000		JNE 0x42abd9				
  0x42ab07		31db			XORL BX, BX				
  0x42ab09		84db			TESTL BL, BL				
  0x42ab0b		7525			JNE 0x42ab32				
	if gp.lockedm != 0 {
  0x42ab0d		4883b8d800000000	CMPQ $0x0, 0xd8(AX)	
  0x42ab15		0f8545ffffff		JNE 0x42aa60		
	execute(gp, inheritTime)
  0x42ab1b		48890424		MOVQ AX, 0(SP)			
  0x42ab1f		884c2408		MOVB CL, 0x8(SP)		
  0x42ab23		e818eeffff		CALL runtime.execute(SB)	
}
  0x42ab28		488b6c2440		MOVQ 0x40(SP), BP	
  0x42ab2d		4883c448		ADDQ $0x48, SP		
  0x42ab31		c3			RET			
		lock(&sched.lock)
  0x42ab32		488d0577710900		LEAQ runtime.sched+16(SB), AX	
  0x42ab39		48890424		MOVQ AX, 0(SP)			
  0x42ab3d		e89edbfdff		CALL runtime.lock(SB)		
		if schedEnabled(gp) {
  0x42ab42		488b442428		MOVQ 0x28(SP), AX		
  0x42ab47		48890424		MOVQ AX, 0(SP)			
  0x42ab4b		e870560000		CALL runtime.schedEnabled(SB)	
  0x42ab50		807c240800		CMPB $0x0, 0x8(SP)		
  0x42ab55		755e			JNE 0x42abb5			
			sched.disable.runnable.pushBack(gp)
  0x42ab57		90			NOPL			
	gp.schedlink = 0
  0x42ab58		488b442428		MOVQ 0x28(SP), AX	
  0x42ab5d		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x42ab68		488b0db1710900		MOVQ runtime.sched+128(SB), CX	
  0x42ab6f		4885c9			TESTQ CX, CX			
  0x42ab72		7434			JE 0x42aba8			
		q.tail.ptr().schedlink.set(gp)
  0x42ab74		90			NOPL			
  0x42ab75		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ab76		4889c2			MOVQ AX, DX		
  0x42ab79		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x42ab80		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ab81		48891598710900		MOVQ DX, runtime.sched+128(SB)	
			sched.disable.n++
  0x42ab88		ff059a710900		INCL runtime.sched+136(SB)	
			unlock(&sched.lock)
  0x42ab8e		488d051b710900		LEAQ runtime.sched+16(SB), AX	
  0x42ab95		48890424		MOVQ AX, 0(SP)			
  0x42ab99		e8f2dcfdff		CALL runtime.unlock(SB)		
			goto top
  0x42ab9e		488b442430		MOVQ 0x30(SP), AX	
  0x42aba3		e9c6feffff		JMP 0x42aa6e		
		q.head.set(gp)
  0x42aba8		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42aba9		4889c2			MOVQ AX, DX			
  0x42abac		48890565710900		MOVQ AX, runtime.sched+120(SB)	
	q.tail.set(gp)
  0x42abb3		ebcb			JMP 0x42ab80		
			unlock(&sched.lock)
  0x42abb5		488d05f4700900		LEAQ runtime.sched+16(SB), AX	
  0x42abbc		48890424		MOVQ AX, 0(SP)			
  0x42abc0		e8cbdcfdff		CALL runtime.unlock(SB)		
	if gp.lockedm != 0 {
  0x42abc5		488b442428		MOVQ 0x28(SP), AX	
	execute(gp, inheritTime)
  0x42abca		0fb64c241f		MOVZX 0x1f(SP), CX	
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x42abcf		488b542430		MOVQ 0x30(SP), DX	
	if gp.lockedm != 0 {
  0x42abd4		e934ffffff		JMP 0x42ab0d		
	if sched.disable.user && !schedEnabled(gp) {
  0x42abd9		48890424		MOVQ AX, 0(SP)			
  0x42abdd		e8de550000		CALL runtime.schedEnabled(SB)	
  0x42abe2		0fb65c2408		MOVZX 0x8(SP), BX		
  0x42abe7		83f301			XORL $0x1, BX			
	if gp.lockedm != 0 {
  0x42abea		488b442428		MOVQ 0x28(SP), AX	
	execute(gp, inheritTime)
  0x42abef		0fb64c241f		MOVZX 0x1f(SP), CX	
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x42abf4		488b542430		MOVQ 0x30(SP), DX	
	if sched.disable.user && !schedEnabled(gp) {
  0x42abf9		e90bffffff		JMP 0x42ab09		
		resetspinning()
  0x42abfe		e88dfbffff		CALL runtime.resetspinning(SB)	
	if gp.lockedm != 0 {
  0x42ac03		488b442428		MOVQ 0x28(SP), AX	
	execute(gp, inheritTime)
  0x42ac08		0fb64c241f		MOVZX 0x1f(SP), CX	
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x42ac0d		488b542430		MOVQ 0x30(SP), DX	
		resetspinning()
  0x42ac12		e9e3feffff		JMP 0x42aafa		
		gp, inheritTime = findrunnable() // blocks until work is available
  0x42ac17		e894eeffff		CALL runtime.findrunnable(SB)	
  0x42ac1c		488b0424		MOVQ 0(SP), AX			
  0x42ac20		0fb64c2408		MOVZX 0x8(SP), CX		
  0x42ac25		e9b1feffff		JMP 0x42aadb			
		gp, inheritTime = runqget(_g_.m.p.ptr())
  0x42ac2a		488b442430		MOVQ 0x30(SP), AX		
  0x42ac2f		488b4830		MOVQ 0x30(AX), CX		
  0x42ac33		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x42ac3a		90			NOPL				
  0x42ac3b		48890c24		MOVQ CX, 0(SP)			
  0x42ac3f		e83c5b0000		CALL runtime.runqget(SB)	
  0x42ac44		488b442408		MOVQ 0x8(SP), AX		
  0x42ac49		0fb64c2410		MOVZX 0x10(SP), CX		
		if gp != nil && _g_.m.spinning {
  0x42ac4e		4885c0			TESTQ AX, AX		
  0x42ac51		741b			JE 0x42ac6e		
  0x42ac53		488b542430		MOVQ 0x30(SP), DX	
  0x42ac58		488b5a30		MOVQ 0x30(DX), BX	
  0x42ac5c		80bb1401000000		CMPB $0x0, 0x114(BX)	
  0x42ac63		0f8469feffff		JE 0x42aad2		
  0x42ac69		e975010000		JMP 0x42ade3		
	if _g_.m.spinning {
  0x42ac6e		488b542430		MOVQ 0x30(SP), DX	
		if gp != nil && _g_.m.spinning {
  0x42ac73		e95afeffff		JMP 0x42aad2		
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
  0x42ac78		488b4c2430		MOVQ 0x30(SP), CX			
  0x42ac7d		488b5130		MOVQ 0x30(CX), DX			
  0x42ac81		488b92d0000000		MOVQ 0xd0(DX), DX			
  0x42ac88		90			NOPL					
  0x42ac89		8b5218			MOVL 0x18(DX), DX			
  0x42ac8c		bb7e8a4b86		MOVL $-0x79b47582, BX			
  0x42ac91		480fafda		IMULQ DX, BX				
  0x42ac95		48c1eb25		SHRQ $0x25, BX				
  0x42ac99		6bdb3d			IMULL $0x3d, BX, BX			
  0x42ac9c		39da			CMPL BX, DX				
  0x42ac9e		0f8523feffff		JNE 0x42aac7				
  0x42aca4		833d5d70090000		CMPL $0x0, runtime.sched+104(SB)	
  0x42acab		0f8e16feffff		JLE 0x42aac7				
			lock(&sched.lock)
  0x42acb1		488d05f86f0900		LEAQ runtime.sched+16(SB), AX	
  0x42acb8		48890424		MOVQ AX, 0(SP)			
  0x42acbc		e81fdafdff		CALL runtime.lock(SB)		
			gp = globrunqget(_g_.m.p.ptr(), 1)
  0x42acc1		488b442430		MOVQ 0x30(SP), AX		
  0x42acc6		488b4830		MOVQ 0x30(AX), CX		
  0x42acca		488b89d0000000		MOVQ 0xd0(CX), CX		
  0x42acd1		90			NOPL				
  0x42acd2		48890c24		MOVQ CX, 0(SP)			
  0x42acd6		c744240801000000	MOVL $0x1, 0x8(SP)		
  0x42acde		e84d550000		CALL runtime.globrunqget(SB)	
  0x42ace3		488b442410		MOVQ 0x10(SP), AX		
  0x42ace8		4889442420		MOVQ AX, 0x20(SP)		
			unlock(&sched.lock)
  0x42aced		488d0dbc6f0900		LEAQ runtime.sched+16(SB), CX	
  0x42acf4		48890c24		MOVQ CX, 0(SP)			
  0x42acf8		e893dbfdff		CALL runtime.unlock(SB)		
	if _g_.m.spinning {
  0x42acfd		488b4c2430		MOVQ 0x30(SP), CX	
	if gp == nil {
  0x42ad02		488b442420		MOVQ 0x20(SP), AX	
			unlock(&sched.lock)
  0x42ad07		e9bbfdffff		JMP 0x42aac7		
	if gp == nil && gcBlackenEnabled != 0 {
  0x42ad0c		833dbd1f0b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x42ad13		0f84a5fdffff		JE 0x42aabe				
		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
  0x42ad19		488b442430		MOVQ 0x30(SP), AX						
  0x42ad1e		488b4830		MOVQ 0x30(AX), CX						
  0x42ad22		488b89d0000000		MOVQ 0xd0(CX), CX						
  0x42ad29		90			NOPL								
  0x42ad2a		488d154f240b00		LEAQ runtime.gcController(SB), DX				
  0x42ad31		48891424		MOVQ DX, 0(SP)							
  0x42ad35		48894c2408		MOVQ CX, 0x8(SP)						
  0x42ad3a		e8b17dfeff		CALL runtime.(*gcControllerState).findRunnableGCWorker(SB)	
  0x42ad3f		488b442410		MOVQ 0x10(SP), AX						
  0x42ad44		e975fdffff		JMP 0x42aabe							
		gp = traceReader()
  0x42ad49		4889442438		MOVQ AX, 0x38(SP)	
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x42ad4e		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42ad58		4889442408		MOVQ AX, 0x8(SP)		
  0x42ad5d		e83ebfffff		CALL runtime.casgstatus(SB)	
			traceGoUnpark(gp, 0)
  0x42ad62		488b442438		MOVQ 0x38(SP), AX		
  0x42ad67		48890424		MOVQ AX, 0(SP)			
  0x42ad6b		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42ad74		e847240100		CALL runtime.traceGoUnpark(SB)	
	if gp == nil && gcBlackenEnabled != 0 {
  0x42ad79		488b442438		MOVQ 0x38(SP), AX	
			traceGoUnpark(gp, 0)
  0x42ad7e		e932fdffff		JMP 0x42aab5		
	if trace.enabled || trace.shutdown {
  0x42ad83		803d471e0a0000		CMPB $0x0, runtime.trace+17(SB)	
  0x42ad8a		0f8513fdffff		JNE 0x42aaa3			
  0x42ad90		31c0			XORL AX, AX			
	if gp == nil && gcBlackenEnabled != 0 {
  0x42ad92		e91efdffff		JMP 0x42aab5		
		runSafePointFn()
  0x42ad97		e8a4d3ffff		CALL runtime.runSafePointFn(SB)	
		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
  0x42ad9c		488b442430		MOVQ 0x30(SP), AX	
		runSafePointFn()
  0x42ada1		e9f0fcffff		JMP 0x42aa96		
		gcstopm()
  0x42ada6		e885eaffff		CALL runtime.gcstopm(SB)	
		goto top
  0x42adab		488b442430		MOVQ 0x30(SP), AX	
  0x42adb0		e9b9fcffff		JMP 0x42aa6e		
		stoplockedm()
  0x42adb5		e8e6e6ffff		CALL runtime.stoplockedm(SB)	
		execute(_g_.m.lockedg.ptr(), false) // Never returns.
  0x42adba		488b442430		MOVQ 0x30(SP), AX		
  0x42adbf		488b4830		MOVQ 0x30(AX), CX		
  0x42adc3		488b8968010000		MOVQ 0x168(CX), CX		
  0x42adca		90			NOPL				
  0x42adcb		48890c24		MOVQ CX, 0(SP)			
  0x42adcf		c644240800		MOVB $0x0, 0x8(SP)		
  0x42add4		e867ebffff		CALL runtime.execute(SB)	
	if _g_.m.incgo {
  0x42add9		488b442430		MOVQ 0x30(SP), AX	
		execute(_g_.m.lockedg.ptr(), false) // Never returns.
  0x42adde		e96bfcffff		JMP 0x42aa4e		
			throw("schedule: spinning with local work")
  0x42ade3		488d05e8750400		LEAQ 0x475e8(IP), AX	
  0x42adea		48890424		MOVQ AX, 0(SP)		
  0x42adee		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x42adf7		e88486ffff		CALL runtime.throw(SB)	
  0x42adfc		0f0b			UD2			
		throw("schedule: in cgo")
  0x42adfe		488d05b2520400		LEAQ 0x452b2(IP), AX	
  0x42ae05		48890424		MOVQ AX, 0(SP)		
  0x42ae09		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x42ae12		e86986ffff		CALL runtime.throw(SB)	
  0x42ae17		0f0b			UD2			
		throw("schedule: holding locks")
  0x42ae19		488d05585f0400		LEAQ 0x45f58(IP), AX	
  0x42ae20		48890424		MOVQ AX, 0(SP)		
  0x42ae24		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x42ae2d		e84e86ffff		CALL runtime.throw(SB)	
  0x42ae32		0f0b			UD2			
func schedule() {
  0x42ae34		e847ca0100		CALL runtime.morestack_noctxt(SB)	
  0x42ae39		e9c2fbffff		JMP runtime.schedule(SB)		

TEXT runtime.parkunlock_c(SB) /usr/local/go/src/runtime/proc.go
func parkunlock_c(gp *g, lock unsafe.Pointer) bool {
  0x42ae40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ae49		483b6110		CMPQ 0x10(CX), SP	
  0x42ae4d		762b			JBE 0x42ae7a		
  0x42ae4f		4883ec10		SUBQ $0x10, SP		
  0x42ae53		48896c2408		MOVQ BP, 0x8(SP)	
  0x42ae58		488d6c2408		LEAQ 0x8(SP), BP	
	unlock((*mutex)(lock))
  0x42ae5d		488b442420		MOVQ 0x20(SP), AX	
  0x42ae62		48890424		MOVQ AX, 0(SP)		
  0x42ae66		e825dafdff		CALL runtime.unlock(SB)	
	return true
  0x42ae6b		c644242801		MOVB $0x1, 0x28(SP)	
  0x42ae70		488b6c2408		MOVQ 0x8(SP), BP	
  0x42ae75		4883c410		ADDQ $0x10, SP		
  0x42ae79		c3			RET			
func parkunlock_c(gp *g, lock unsafe.Pointer) bool {
  0x42ae7a		e801ca0100		CALL runtime.morestack_noctxt(SB)	
  0x42ae7f		ebbf			JMP runtime.parkunlock_c(SB)		

TEXT runtime.park_m(SB) /usr/local/go/src/runtime/proc.go
func park_m(gp *g) {
  0x42ae90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ae99		483b6110		CMPQ 0x10(CX), SP	
  0x42ae9d		0f86aa010000		JBE 0x42b04d		
  0x42aea3		4883ec28		SUBQ $0x28, SP		
  0x42aea7		48896c2420		MOVQ BP, 0x20(SP)	
  0x42aeac		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x42aeb1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42aeba		4889442418		MOVQ AX, 0x18(SP)	
	if trace.enabled {
  0x42aebf		803d0a1d0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42aec6		0f855d010000		JNE 0x42b029			
	casgstatus(gp, _Grunning, _Gwaiting)
  0x42aecc		488b442430		MOVQ 0x30(SP), AX		
  0x42aed1		48890424		MOVQ AX, 0(SP)			
  0x42aed5		48b90200000004000000	MOVQ $0x400000002, CX		
  0x42aedf		48894c2408		MOVQ CX, 0x8(SP)		
  0x42aee4		e8b7bdffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x42aee9		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x42aef2		488b4830		MOVQ 0x30(AX), CX	
  0x42aef6		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x42aefd		8401			TESTB AL, 0(CX)		
	dropg()
  0x42aeff		90			NOPL			
	setMNoWB(&_g_.m.curg.m, nil)
  0x42af00		90			NOPL			
	(*muintptr)(unsafe.Pointer(mp)).set(new)
  0x42af01		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42af02		31c9			XORL CX, CX		
  0x42af04		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x42af08		488b4830		MOVQ 0x30(AX), CX	
  0x42af0c		8400			TESTB AL, 0(AX)		
  0x42af0e		90			NOPL			
	(*guintptr)(unsafe.Pointer(gp)).set(new)
  0x42af0f		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42af10		31c0			XORL AX, AX		
  0x42af12		488981c0000000		MOVQ AX, 0xc0(CX)	
	if _g_.m.waitunlockf != nil {
  0x42af19		488b442418		MOVQ 0x18(SP), AX	
  0x42af1e		488b4830		MOVQ 0x30(AX), CX	
  0x42af22		4883b98002000000	CMPQ $0x0, 0x280(CX)	
  0x42af2a		750f			JNE 0x42af3b		
	schedule()
  0x42af2c		e8cffaffff		CALL runtime.schedule(SB)	
}
  0x42af31		488b6c2420		MOVQ 0x20(SP), BP	
  0x42af36		4883c428		ADDQ $0x28, SP		
  0x42af3a		c3			RET			
		fn := *(*func(*g, unsafe.Pointer) bool)(unsafe.Pointer(&_g_.m.waitunlockf))
  0x42af3b		488b9180020000		MOVQ 0x280(CX), DX	
		ok := fn(gp, _g_.m.waitlock)
  0x42af42		488b8188020000		MOVQ 0x288(CX), AX	
  0x42af49		488b4c2430		MOVQ 0x30(SP), CX	
  0x42af4e		48890c24		MOVQ CX, 0(SP)		
  0x42af52		4889442408		MOVQ AX, 0x8(SP)	
  0x42af57		488b02			MOVQ 0(DX), AX		
  0x42af5a		ffd0			CALL AX			
		_g_.m.waitunlockf = nil
  0x42af5c		488b442418		MOVQ 0x18(SP), AX	
  0x42af61		488b4830		MOVQ 0x30(AX), CX	
  0x42af65		8401			TESTB AL, 0(CX)		
		ok := fn(gp, _g_.m.waitlock)
  0x42af67		0fb65c2410		MOVZX 0x10(SP), BX	
  0x42af6c		80fb00			CMPL $0x0, BL		
		_g_.m.waitunlockf = nil
  0x42af6f		833daa1e0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42af76		0f8594000000		JNE 0x42b010				
  0x42af7c		48c7818002000000000000	MOVQ $0x0, 0x280(CX)			
		_g_.m.waitlock = nil
  0x42af87		488b4830		MOVQ 0x30(AX), CX			
  0x42af8b		8401			TESTB AL, 0(CX)				
  0x42af8d		833d8c1e0b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42af94		7567			JNE 0x42affd				
  0x42af96		48c7818802000000000000	MOVQ $0x0, 0x288(CX)			
		ok := fn(gp, _g_.m.waitlock)
  0x42afa1		80fb00			CMPL $0x0, BL		
		if !ok {
  0x42afa4		7586			JNE 0x42af2c		
			if trace.enabled {
  0x42afa6		803d231c0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42afad		7535			JNE 0x42afe4			
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x42afaf		488b442430		MOVQ 0x30(SP), AX		
  0x42afb4		48890424		MOVQ AX, 0(SP)			
  0x42afb8		48b90400000001000000	MOVQ $0x100000004, CX		
  0x42afc2		48894c2408		MOVQ CX, 0x8(SP)		
  0x42afc7		e8d4bcffff		CALL runtime.casgstatus(SB)	
			execute(gp, true) // Schedule it back, never returns.
  0x42afcc		488b442430		MOVQ 0x30(SP), AX		
  0x42afd1		48890424		MOVQ AX, 0(SP)			
  0x42afd5		c644240801		MOVB $0x1, 0x8(SP)		
  0x42afda		e861e9ffff		CALL runtime.execute(SB)	
  0x42afdf		e948ffffff		JMP 0x42af2c			
				traceGoUnpark(gp, 2)
  0x42afe4		488b442430		MOVQ 0x30(SP), AX		
  0x42afe9		48890424		MOVQ AX, 0(SP)			
  0x42afed		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42aff6		e8c5210100		CALL runtime.traceGoUnpark(SB)	
  0x42affb		ebb2			JMP 0x42afaf			
		_g_.m.waitlock = nil
  0x42affd		488db988020000		LEAQ 0x288(CX), DI		
  0x42b004		31c0			XORL AX, AX			
  0x42b006		e875e60100		CALL runtime.gcWriteBarrier(SB)	
		ok := fn(gp, _g_.m.waitlock)
  0x42b00b		80fb00			CMPL $0x0, BL		
		_g_.m.waitlock = nil
  0x42b00e		eb94			JMP 0x42afa4		
		_g_.m.waitunlockf = nil
  0x42b010		488db980020000		LEAQ 0x280(CX), DI	
	_g_ := getg()
  0x42b017		4889c1			MOVQ AX, CX		
		_g_.m.waitunlockf = nil
  0x42b01a		31c0			XORL AX, AX			
  0x42b01c		e85fe60100		CALL runtime.gcWriteBarrier(SB)	
		_g_.m.waitlock = nil
  0x42b021		4889c8			MOVQ CX, AX		
		_g_.m.waitunlockf = nil
  0x42b024		e95effffff		JMP 0x42af87		
		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
  0x42b029		488b4830		MOVQ 0x30(AX), CX		
  0x42b02d		0fb69190020000		MOVZX 0x290(CX), DX		
  0x42b034		488b8998020000		MOVQ 0x298(CX), CX		
  0x42b03b		881424			MOVB DL, 0(SP)			
  0x42b03e		48894c2408		MOVQ CX, 0x8(SP)		
  0x42b043		e8e8200100		CALL runtime.traceGoPark(SB)	
  0x42b048		e97ffeffff		JMP 0x42aecc			
func park_m(gp *g) {
  0x42b04d		e82ec80100		CALL runtime.morestack_noctxt(SB)	
  0x42b052		e939feffff		JMP runtime.park_m(SB)			

TEXT runtime.goschedImpl(SB) /usr/local/go/src/runtime/proc.go
func goschedImpl(gp *g) {
  0x42b060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b069		483b6110		CMPQ 0x10(CX), SP	
  0x42b06d		0f864a020000		JBE 0x42b2bd		
  0x42b073		4883ec30		SUBQ $0x30, SP		
  0x42b077		48896c2428		MOVQ BP, 0x28(SP)	
  0x42b07c		488d6c2428		LEAQ 0x28(SP), BP	
	status := readgstatus(gp)
  0x42b081		90			NOPL			
  0x42b082		488b442438		MOVQ 0x38(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x42b087		8b8890000000		MOVL 0x90(AX), CX	
	if status&^_Gscan != _Grunning {
  0x42b08d		0fbaf10c		BTRL $0xc, CX		
  0x42b091		83f902			CMPL $0x2, CX		
  0x42b094		0f85bc000000		JNE 0x42b156		
	casgstatus(gp, _Grunning, _Grunnable)
  0x42b09a		48890424		MOVQ AX, 0(SP)			
  0x42b09e		48b90200000001000000	MOVQ $0x100000002, CX		
  0x42b0a8		48894c2408		MOVQ CX, 0x8(SP)		
  0x42b0ad		e8eebbffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x42b0b2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x42b0bb		488b4830		MOVQ 0x30(AX), CX	
  0x42b0bf		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x42b0c6		8401			TESTB AL, 0(CX)		
	dropg()
  0x42b0c8		90			NOPL			
	setMNoWB(&_g_.m.curg.m, nil)
  0x42b0c9		90			NOPL			
	(*muintptr)(unsafe.Pointer(mp)).set(new)
  0x42b0ca		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42b0cb		31c9			XORL CX, CX		
  0x42b0cd		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x42b0d1		488b4830		MOVQ 0x30(AX), CX	
  0x42b0d5		8400			TESTB AL, 0(AX)		
  0x42b0d7		90			NOPL			
	(*guintptr)(unsafe.Pointer(gp)).set(new)
  0x42b0d8		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b0d9		31c0			XORL AX, AX		
  0x42b0db		488981c0000000		MOVQ AX, 0xc0(CX)	
	lock(&sched.lock)
  0x42b0e2		488d05c76b0900		LEAQ runtime.sched+16(SB), AX	
  0x42b0e9		48890424		MOVQ AX, 0(SP)			
  0x42b0ed		e8eed5fdff		CALL runtime.lock(SB)		
	globrunqput(gp)
  0x42b0f2		90			NOPL			
	sched.runq.pushBack(gp)
  0x42b0f3		90			NOPL			
	gp.schedlink = 0
  0x42b0f4		488b442438		MOVQ 0x38(SP), AX	
  0x42b0f9		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x42b104		488b0df56b0900		MOVQ runtime.sched+96(SB), CX	
  0x42b10b		4885c9			TESTQ CX, CX			
  0x42b10e		7439			JE 0x42b149			
		q.tail.ptr().schedlink.set(gp)
  0x42b110		90			NOPL			
  0x42b111		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b112		4889c2			MOVQ AX, DX		
  0x42b115		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x42b11c		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b11d		488915dc6b0900		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42b124		ff05de6b0900		INCL runtime.sched+104(SB)	
	unlock(&sched.lock)
  0x42b12a		488d057f6b0900		LEAQ runtime.sched+16(SB), AX	
  0x42b131		48890424		MOVQ AX, 0(SP)			
  0x42b135		e856d7fdff		CALL runtime.unlock(SB)		
	schedule()
  0x42b13a		e8c1f8ffff		CALL runtime.schedule(SB)	
}
  0x42b13f		488b6c2428		MOVQ 0x28(SP), BP	
  0x42b144		4883c430		ADDQ $0x30, SP		
  0x42b148		c3			RET			
		q.head.set(gp)
  0x42b149		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b14a		4889c2			MOVQ AX, DX			
  0x42b14d		488905a46b0900		MOVQ AX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x42b154		ebc6			JMP 0x42b11c		
		dumpgstatus(gp)
  0x42b156		90			NOPL			
	_g_ := getg()
  0x42b157		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b160		48894c2420		MOVQ CX, 0x20(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42b165		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42b166		8b9090000000		MOVL 0x90(AX), DX	
  0x42b16c		89542414		MOVL DX, 0x14(SP)	
	print("runtime: gp: gp=", gp, ", goid=", gp.goid, ", gp->atomicstatus=", readgstatus(gp), "\n")
  0x42b170		488b9898000000		MOVQ 0x98(AX), BX		
  0x42b177		48895c2418		MOVQ BX, 0x18(SP)		
  0x42b17c		e83f8dffff		CALL runtime.printlock(SB)	
  0x42b181		488d050f4f0400		LEAQ 0x44f0f(IP), AX		
  0x42b188		48890424		MOVQ AX, 0(SP)			
  0x42b18c		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x42b195		e85696ffff		CALL runtime.printstring(SB)	
  0x42b19a		488b442438		MOVQ 0x38(SP), AX		
  0x42b19f		48890424		MOVQ AX, 0(SP)			
  0x42b1a3		e80896ffff		CALL runtime.printpointer(SB)	
  0x42b1a8		488d052d410400		LEAQ 0x4412d(IP), AX		
  0x42b1af		48890424		MOVQ AX, 0(SP)			
  0x42b1b3		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42b1bc		e82f96ffff		CALL runtime.printstring(SB)	
  0x42b1c1		488b442418		MOVQ 0x18(SP), AX		
  0x42b1c6		48890424		MOVQ AX, 0(SP)			
  0x42b1ca		e87194ffff		CALL runtime.printint(SB)	
  0x42b1cf		488d05a7510400		LEAQ 0x451a7(IP), AX		
  0x42b1d6		48890424		MOVQ AX, 0(SP)			
  0x42b1da		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x42b1e3		e80896ffff		CALL runtime.printstring(SB)	
  0x42b1e8		8b442414		MOVL 0x14(SP), AX		
  0x42b1ec		89c0			MOVL AX, AX			
  0x42b1ee		48890424		MOVQ AX, 0(SP)			
  0x42b1f2		e84993ffff		CALL runtime.printuint(SB)	
  0x42b1f7		e8548fffff		CALL runtime.printnl(SB)	
  0x42b1fc		e83f8dffff		CALL runtime.printunlock(SB)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x42b201		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42b202		488b442420		MOVQ 0x20(SP), AX	
  0x42b207		8b8890000000		MOVL 0x90(AX), CX	
  0x42b20d		894c2410		MOVL CX, 0x10(SP)	
	print("runtime:  g:  g=", _g_, ", goid=", _g_.goid, ",  g->atomicstatus=", readgstatus(_g_), "\n")
  0x42b211		488b9098000000		MOVQ 0x98(AX), DX		
  0x42b218		4889542418		MOVQ DX, 0x18(SP)		
  0x42b21d		e89e8cffff		CALL runtime.printlock(SB)	
  0x42b222		488d055e4e0400		LEAQ 0x44e5e(IP), AX		
  0x42b229		48890424		MOVQ AX, 0(SP)			
  0x42b22d		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x42b236		e8b595ffff		CALL runtime.printstring(SB)	
  0x42b23b		488b442420		MOVQ 0x20(SP), AX		
  0x42b240		48890424		MOVQ AX, 0(SP)			
  0x42b244		e86795ffff		CALL runtime.printpointer(SB)	
  0x42b249		488d058c400400		LEAQ 0x4408c(IP), AX		
  0x42b250		48890424		MOVQ AX, 0(SP)			
  0x42b254		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42b25d		e88e95ffff		CALL runtime.printstring(SB)	
  0x42b262		488b442418		MOVQ 0x18(SP), AX		
  0x42b267		48890424		MOVQ AX, 0(SP)			
  0x42b26b		e8d093ffff		CALL runtime.printint(SB)	
  0x42b270		488d05f3500400		LEAQ 0x450f3(IP), AX		
  0x42b277		48890424		MOVQ AX, 0(SP)			
  0x42b27b		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x42b284		e86795ffff		CALL runtime.printstring(SB)	
  0x42b289		8b442410		MOVL 0x10(SP), AX		
  0x42b28d		89c0			MOVL AX, AX			
  0x42b28f		48890424		MOVQ AX, 0(SP)			
  0x42b293		e8a892ffff		CALL runtime.printuint(SB)	
  0x42b298		e8b38effff		CALL runtime.printnl(SB)	
  0x42b29d		e89e8cffff		CALL runtime.printunlock(SB)	
		throw("bad g status")
  0x42b2a2		488d05f8470400		LEAQ 0x447f8(IP), AX	
  0x42b2a9		48890424		MOVQ AX, 0(SP)		
  0x42b2ad		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x42b2b6		e8c581ffff		CALL runtime.throw(SB)	
  0x42b2bb		0f0b			UD2			
func goschedImpl(gp *g) {
  0x42b2bd		e8bec50100		CALL runtime.morestack_noctxt(SB)	
  0x42b2c2		e999fdffff		JMP runtime.goschedImpl(SB)		

TEXT runtime.gosched_m(SB) /usr/local/go/src/runtime/proc.go
func gosched_m(gp *g) {
  0x42b2d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b2d9		483b6110		CMPQ 0x10(CX), SP	
  0x42b2dd		7670			JBE 0x42b34f		
  0x42b2df		4883ec30		SUBQ $0x30, SP		
  0x42b2e3		48896c2428		MOVQ BP, 0x28(SP)	
  0x42b2e8		488d6c2428		LEAQ 0x28(SP), BP	
	if trace.enabled {
  0x42b2ed		803ddc180a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42b2f4		7518			JNE 0x42b30e			
	goschedImpl(gp)
  0x42b2f6		488b442438		MOVQ 0x38(SP), AX		
  0x42b2fb		48890424		MOVQ AX, 0(SP)			
  0x42b2ff		e85cfdffff		CALL runtime.goschedImpl(SB)	
}
  0x42b304		488b6c2428		MOVQ 0x28(SP), BP	
  0x42b309		4883c430		ADDQ $0x30, SP		
  0x42b30d		c3			RET			
	_g_ := getg()
  0x42b30e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.tracelastp = _g_.m.p
  0x42b317		488b4830		MOVQ 0x30(AX), CX	
		traceGoSched()
  0x42b31b		90			NOPL			
	_g_.tracelastp = _g_.m.p
  0x42b31c		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42b323		488988d0000000		MOVQ CX, 0xd0(AX)	
	traceEvent(traceEvGoSched, 1)
  0x42b32a		c6042411		MOVB $0x11, 0(SP)		
  0x42b32e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42b337		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42b340		0f57c0			XORPS X0, X0			
  0x42b343		0f11442418		MOVUPS X0, 0x18(SP)		
  0x42b348		e8530b0100		CALL runtime.traceEvent(SB)	
	goschedImpl(gp)
  0x42b34d		eba7			JMP 0x42b2f6		
func gosched_m(gp *g) {
  0x42b34f		e82cc50100		CALL runtime.morestack_noctxt(SB)	
  0x42b354		e977ffffff		JMP runtime.gosched_m(SB)		

TEXT runtime.gopreempt_m(SB) /usr/local/go/src/runtime/proc.go
func gopreempt_m(gp *g) {
  0x42b360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b369		483b6110		CMPQ 0x10(CX), SP	
  0x42b36d		7670			JBE 0x42b3df		
  0x42b36f		4883ec30		SUBQ $0x30, SP		
  0x42b373		48896c2428		MOVQ BP, 0x28(SP)	
  0x42b378		488d6c2428		LEAQ 0x28(SP), BP	
	if trace.enabled {
  0x42b37d		803d4c180a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42b384		7518			JNE 0x42b39e			
	goschedImpl(gp)
  0x42b386		488b442438		MOVQ 0x38(SP), AX		
  0x42b38b		48890424		MOVQ AX, 0(SP)			
  0x42b38f		e8ccfcffff		CALL runtime.goschedImpl(SB)	
}
  0x42b394		488b6c2428		MOVQ 0x28(SP), BP	
  0x42b399		4883c430		ADDQ $0x30, SP		
  0x42b39d		c3			RET			
	_g_ := getg()
  0x42b39e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.tracelastp = _g_.m.p
  0x42b3a7		488b4830		MOVQ 0x30(AX), CX	
		traceGoPreempt()
  0x42b3ab		90			NOPL			
	_g_.tracelastp = _g_.m.p
  0x42b3ac		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42b3b3		488988d0000000		MOVQ CX, 0xd0(AX)	
	traceEvent(traceEvGoPreempt, 1)
  0x42b3ba		c6042412		MOVB $0x12, 0(SP)		
  0x42b3be		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42b3c7		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42b3d0		0f57c0			XORPS X0, X0			
  0x42b3d3		0f11442418		MOVUPS X0, 0x18(SP)		
  0x42b3d8		e8c30a0100		CALL runtime.traceEvent(SB)	
	goschedImpl(gp)
  0x42b3dd		eba7			JMP 0x42b386		
func gopreempt_m(gp *g) {
  0x42b3df		e89cc40100		CALL runtime.morestack_noctxt(SB)	
  0x42b3e4		e977ffffff		JMP runtime.gopreempt_m(SB)		

TEXT runtime.goexit1(SB) /usr/local/go/src/runtime/proc.go
func goexit1() {
  0x42b3f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b3f9		483b6110		CMPQ 0x10(CX), SP	
  0x42b3fd		7657			JBE 0x42b456		
  0x42b3ff		4883ec30		SUBQ $0x30, SP		
  0x42b403		48896c2428		MOVQ BP, 0x28(SP)	
  0x42b408		488d6c2428		LEAQ 0x28(SP), BP	
	if trace.enabled {
  0x42b40d		803dbc170a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42b414		751a			JNE 0x42b430			
	mcall(goexit0)
  0x42b416		488d052b840400		LEAQ 0x4842b(IP), AX	
  0x42b41d		48890424		MOVQ AX, 0(SP)		
  0x42b421		e88ac20100		CALL runtime.mcall(SB)	
}
  0x42b426		488b6c2428		MOVQ 0x28(SP), BP	
  0x42b42b		4883c430		ADDQ $0x30, SP		
  0x42b42f		c3			RET			
		traceGoEnd()
  0x42b430		90			NOPL			
	traceEvent(traceEvGoEnd, -1)
  0x42b431		c604240f		MOVB $0xf, 0(SP)		
  0x42b435		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x42b43e		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42b447		0f57c0			XORPS X0, X0			
  0x42b44a		0f11442418		MOVUPS X0, 0x18(SP)		
  0x42b44f		e84c0a0100		CALL runtime.traceEvent(SB)	
	mcall(goexit0)
  0x42b454		ebc0			JMP 0x42b416		
func goexit1() {
  0x42b456		e825c40100		CALL runtime.morestack_noctxt(SB)	
  0x42b45b		eb93			JMP runtime.goexit1(SB)			

TEXT runtime.goexit0(SB) /usr/local/go/src/runtime/proc.go
func goexit0(gp *g) {
  0x42b460		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b469		483b6110		CMPQ 0x10(CX), SP	
  0x42b46d		0f86aa020000		JBE 0x42b71d		
  0x42b473		4883ec38		SUBQ $0x38, SP		
  0x42b477		48896c2430		MOVQ BP, 0x30(SP)	
  0x42b47c		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x42b481		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42b48a		4889442428		MOVQ AX, 0x28(SP)	
	casgstatus(gp, _Grunning, _Gdead)
  0x42b48f		488b4c2440		MOVQ 0x40(SP), CX		
  0x42b494		48890c24		MOVQ CX, 0(SP)			
  0x42b498		48ba0200000006000000	MOVQ $0x600000002, DX		
  0x42b4a2		4889542408		MOVQ DX, 0x8(SP)		
  0x42b4a7		e8f4b7ffff		CALL runtime.casgstatus(SB)	
	if isSystemGoroutine(gp, false) {
  0x42b4ac		488b442440		MOVQ 0x40(SP), AX			
  0x42b4b1		48890424		MOVQ AX, 0(SP)				
  0x42b4b5		c644240800		MOVB $0x0, 0x8(SP)			
  0x42b4ba		e8515c0100		CALL runtime.isSystemGoroutine(SB)	
  0x42b4bf		807c241000		CMPB $0x0, 0x10(SP)			
  0x42b4c4		7410			JE 0x42b4d6				
		atomic.Xadd(&sched.ngsys, -1)
  0x42b4c6		b9ffffffff		MOVL $-0x1, CX			
  0x42b4cb		488d150e680900		LEAQ runtime.sched+64(SB), DX	
  0x42b4d2		f00fc10a		LOCK XADDL CX, 0(DX)		
	gp.m = nil
  0x42b4d6		488b4c2440		MOVQ 0x40(SP), CX			
  0x42b4db		8401			TESTB AL, 0(CX)				
  0x42b4dd		833d3c190b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42b4e4		0f85cf010000		JNE 0x42b6b9				
  0x42b4ea		48c7413000000000	MOVQ $0x0, 0x30(CX)			
	locked := gp.lockedm != 0
  0x42b4f2		488b91d8000000		MOVQ 0xd8(CX), DX	
  0x42b4f9		4883fa00		CMPQ $0x0, DX		
	gp.lockedm = 0
  0x42b4fd		48c781d800000000000000	MOVQ $0x0, 0xd8(CX)	
	_g_.m.lockedg = 0
  0x42b508		488b5c2428		MOVQ 0x28(SP), BX	
  0x42b50d		488b7330		MOVQ 0x30(BX), SI	
  0x42b511		48c7866801000000000000	MOVQ $0x0, 0x168(SI)	
	gp.paniconfault = false
  0x42b51c		c681b200000000		MOVB $0x0, 0xb2(CX)	
	gp._defer = nil // should be true already but just in case.
  0x42b523		833df6180b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42b52a		0f8579010000		JNE 0x42b6a9				
  0x42b530		48c7412800000000	MOVQ $0x0, 0x28(CX)			
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
  0x42b538		48c7412000000000	MOVQ $0x0, 0x20(CX)	
	gp.writebuf = nil
  0x42b540		0f57c0			XORPS X0, X0				
  0x42b543		0f1181f0000000		MOVUPS X0, 0xf0(CX)			
  0x42b54a		833dcf180b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42b551		0f853c010000		JNE 0x42b693				
  0x42b557		48c781e800000000000000	MOVQ $0x0, 0xe8(CX)			
	gp.waitreason = 0
  0x42b562		c681b000000000		MOVB $0x0, 0xb0(CX)	
	gp.param = nil
  0x42b569		833db0180b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42b570		0f85f0000000		JNE 0x42b666				
  0x42b576		48c7818800000000000000	MOVQ $0x0, 0x88(CX)			
	gp.timer = nil
  0x42b581		0f118158010000		MOVUPS X0, 0x158(CX)	
	if gcBlackenEnabled != 0 && gp.gcAssistBytes > 0 {
  0x42b588		833d41170b0000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x42b58f		7438			JE 0x42b5c9				
  0x42b591		488b8170010000		MOVQ 0x170(CX), AX			
  0x42b598		4885c0			TESTQ AX, AX				
  0x42b59b		7e2c			JLE 0x42b5c9				
		scanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))
  0x42b59d		0f57c0			XORPS X0, X0				
  0x42b5a0		f2480f2ac0		CVTSI2SDQ AX, X0			
  0x42b5a5		f20f5905131c0b00	MULSD runtime.gcController+64(SB), X0	
  0x42b5ad		f2480f2cc0		CVTTSD2SIQ X0, AX			
		atomic.Xaddint64(&gcController.bgScanCredit, scanCredit)
  0x42b5b2		488d35cf1b0b00		LEAQ runtime.gcController+8(SB), SI	
  0x42b5b9		f0480fc106		LOCK XADDQ AX, 0(SI)			
		gp.gcAssistBytes = 0
  0x42b5be		48c7817001000000000000	MOVQ $0x0, 0x170(CX)	
	gp.gcscanvalid = true
  0x42b5c9		c681b500000001		MOVB $0x1, 0xb5(CX)	
	_g_ := getg()
  0x42b5d0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x42b5d9		488b7030		MOVQ 0x30(AX), SI	
  0x42b5dd		488bbec0000000		MOVQ 0xc0(SI), DI	
  0x42b5e4		8406			TESTB AL, 0(SI)		
	dropg()
  0x42b5e6		90			NOPL			
	setMNoWB(&_g_.m.curg.m, nil)
  0x42b5e7		90			NOPL			
	(*muintptr)(unsafe.Pointer(mp)).set(new)
  0x42b5e8		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42b5e9		31f6			XORL SI, SI		
  0x42b5eb		48897730		MOVQ SI, 0x30(DI)	
	setGNoWB(&_g_.m.curg, nil)
  0x42b5ef		488b7030		MOVQ 0x30(AX), SI	
  0x42b5f3		8400			TESTB AL, 0(AX)		
  0x42b5f5		90			NOPL			
	(*guintptr)(unsafe.Pointer(gp)).set(new)
  0x42b5f6		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42b5f7		31c0			XORL AX, AX		
  0x42b5f9		488986c0000000		MOVQ AX, 0xc0(SI)	
	if _g_.m.lockedInt != 0 {
  0x42b600		488b4330		MOVQ 0x30(BX), AX	
  0x42b604		8bb074020000		MOVL 0x274(AX), SI	
  0x42b60a		85f6			TESTL SI, SI		
  0x42b60c		0f85b7000000		JNE 0x42b6c9		
	locked := gp.lockedm != 0
  0x42b612		4889542420		MOVQ DX, 0x20(SP)	
	gfput(_g_.m.p.ptr(), gp)
  0x42b617		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x42b61e		90			NOPL			
  0x42b61f		48890424		MOVQ AX, 0(SP)		
  0x42b623		48894c2408		MOVQ CX, 0x8(SP)	
  0x42b628		e803180000		CALL runtime.gfput(SB)	
	locked := gp.lockedm != 0
  0x42b62d		488b442420		MOVQ 0x20(SP), AX	
  0x42b632		4883f800		CMPQ $0x0, AX		
	if locked {
  0x42b636		750f			JNE 0x42b647		
	schedule()
  0x42b638		e8c3f3ffff		CALL runtime.schedule(SB)	
}
  0x42b63d		488b6c2430		MOVQ 0x30(SP), BP	
  0x42b642		4883c438		ADDQ $0x38, SP		
  0x42b646		c3			RET			
			gogo(&_g_.m.g0.sched)
  0x42b647		488b442428		MOVQ 0x28(SP), AX	
  0x42b64c		488b4030		MOVQ 0x30(AX), AX	
  0x42b650		488b08			MOVQ 0(AX), CX		
  0x42b653		8401			TESTB AL, 0(CX)		
  0x42b655		8400			TESTB AL, 0(AX)		
  0x42b657		488d4138		LEAQ 0x38(CX), AX	
  0x42b65b		48890424		MOVQ AX, 0(SP)		
  0x42b65f		e8ecbf0100		CALL runtime.gogo(SB)	
	schedule()
  0x42b664		ebd2			JMP 0x42b638		
	gp.param = nil
  0x42b666		488db988000000		LEAQ 0x88(CX), DI		
  0x42b66d		31c0			XORL AX, AX			
  0x42b66f		e80ce00100		CALL runtime.gcWriteBarrier(SB)	
	gp.labels = nil
  0x42b674		488db958010000		LEAQ 0x158(CX), DI		
  0x42b67b		e800e00100		CALL runtime.gcWriteBarrier(SB)	
	gp.timer = nil
  0x42b680		488db960010000		LEAQ 0x160(CX), DI		
  0x42b687		31c0			XORL AX, AX			
  0x42b689		e8f2df0100		CALL runtime.gcWriteBarrier(SB)	
	gp.param = nil
  0x42b68e		e9f5feffff		JMP 0x42b588		
	gp.writebuf = nil
  0x42b693		488db9e8000000		LEAQ 0xe8(CX), DI		
  0x42b69a		31c0			XORL AX, AX			
  0x42b69c		e8dfdf0100		CALL runtime.gcWriteBarrier(SB)	
  0x42b6a1		0f57c0			XORPS X0, X0			
  0x42b6a4		e9b9feffff		JMP 0x42b562			
	gp._defer = nil // should be true already but just in case.
  0x42b6a9		488d7928		LEAQ 0x28(CX), DI		
  0x42b6ad		31c0			XORL AX, AX			
  0x42b6af		e8ccdf0100		CALL runtime.gcWriteBarrier(SB)	
  0x42b6b4		e97ffeffff		JMP 0x42b538			
	gp.m = nil
  0x42b6b9		488d7930		LEAQ 0x30(CX), DI		
  0x42b6bd		31c0			XORL AX, AX			
  0x42b6bf		e8bcdf0100		CALL runtime.gcWriteBarrier(SB)	
  0x42b6c4		e929feffff		JMP 0x42b4f2			
	if _g_.m.lockedInt != 0 {
  0x42b6c9		8974241c		MOVL SI, 0x1c(SP)	
		print("invalid m->lockedInt = ", _g_.m.lockedInt, "\n")
  0x42b6cd		e8ee87ffff		CALL runtime.printlock(SB)	
  0x42b6d2		488d0574550400		LEAQ 0x45574(IP), AX		
  0x42b6d9		48890424		MOVQ AX, 0(SP)			
  0x42b6dd		48c744240817000000	MOVQ $0x17, 0x8(SP)		
  0x42b6e6		e80591ffff		CALL runtime.printstring(SB)	
  0x42b6eb		8b44241c		MOVL 0x1c(SP), AX		
  0x42b6ef		48890424		MOVQ AX, 0(SP)			
  0x42b6f3		e8488effff		CALL runtime.printuint(SB)	
  0x42b6f8		e8538affff		CALL runtime.printnl(SB)	
  0x42b6fd		e83e88ffff		CALL runtime.printunlock(SB)	
		throw("internal lockOSThread error")
  0x42b702		488d05955c0400		LEAQ 0x45c95(IP), AX	
  0x42b709		48890424		MOVQ AX, 0(SP)		
  0x42b70d		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x42b716		e8657dffff		CALL runtime.throw(SB)	
  0x42b71b		0f0b			UD2			
func goexit0(gp *g) {
  0x42b71d		e85ec10100		CALL runtime.morestack_noctxt(SB)	
  0x42b722		e939fdffff		JMP runtime.goexit0(SB)			

TEXT runtime.save(SB) /usr/local/go/src/runtime/proc.go
	_g_ := getg()
  0x42b730		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.sched.pc = pc
  0x42b739		488b4c2408		MOVQ 0x8(SP), CX	
  0x42b73e		48894840		MOVQ CX, 0x40(AX)	
	_g_.sched.sp = sp
  0x42b742		488b4c2410		MOVQ 0x10(SP), CX	
  0x42b747		48894838		MOVQ CX, 0x38(AX)	
	_g_.sched.lr = 0
  0x42b74b		48c7406000000000	MOVQ $0x0, 0x60(AX)	
	_g_.sched.ret = 0
  0x42b753		48c7405800000000	MOVQ $0x0, 0x58(AX)	
	_g_.sched.g = guintptr(unsafe.Pointer(_g_))
  0x42b75b		4889c1			MOVQ AX, CX		
  0x42b75e		48894148		MOVQ AX, 0x48(CX)	
	if _g_.sched.ctxt != nil {
  0x42b762		4883795000		CMPQ $0x0, 0x50(CX)	
  0x42b767		7501			JNE 0x42b76a		
  0x42b769		c3			RET			
		badctxt()
  0x42b76a		e841a4ffff		CALL runtime.badctxt(SB)	
  0x42b76f		ebf8			JMP 0x42b769			

TEXT runtime.reentersyscall(SB) /usr/local/go/src/runtime/proc.go
func reentersyscall(pc, sp uintptr) {
  0x42b780		4883ec30		SUBQ $0x30, SP		
  0x42b784		48896c2428		MOVQ BP, 0x28(SP)	
  0x42b789		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x42b78e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42b797		4889442410		MOVQ AX, 0x10(SP)	
	_g_.m.locks++
  0x42b79c		488b4830		MOVQ 0x30(AX), CX	
  0x42b7a0		ff8108010000		INCL 0x108(CX)		
	_g_.stackguard0 = stackPreempt
  0x42b7a6		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	_g_.throwsplit = true
  0x42b7ae		c680b600000001		MOVB $0x1, 0xb6(AX)	
	save(pc, sp)
  0x42b7b5		488b4c2438		MOVQ 0x38(SP), CX	
  0x42b7ba		48890c24		MOVQ CX, 0(SP)		
  0x42b7be		488b542440		MOVQ 0x40(SP), DX	
  0x42b7c3		4889542408		MOVQ DX, 0x8(SP)	
  0x42b7c8		e863ffffff		CALL runtime.save(SB)	
	_g_.syscallsp = sp
  0x42b7cd		488b442440		MOVQ 0x40(SP), AX	
  0x42b7d2		488b4c2410		MOVQ 0x10(SP), CX	
  0x42b7d7		48894170		MOVQ AX, 0x70(CX)	
	_g_.syscallpc = pc
  0x42b7db		488b542438		MOVQ 0x38(SP), DX	
  0x42b7e0		48895178		MOVQ DX, 0x78(CX)	
	casgstatus(_g_, _Grunning, _Gsyscall)
  0x42b7e4		48890c24		MOVQ CX, 0(SP)			
  0x42b7e8		48bb0200000003000000	MOVQ $0x300000002, BX		
  0x42b7f2		48895c2408		MOVQ BX, 0x8(SP)		
  0x42b7f7		e8a4b4ffff		CALL runtime.casgstatus(SB)	
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42b7fc		488b442410		MOVQ 0x10(SP), AX	
  0x42b801		488b4870		MOVQ 0x70(AX), CX	
  0x42b805		483908			CMPQ CX, 0(AX)		
  0x42b808		0f869f010000		JBE 0x42b9ad		
		systemstack(func() {
  0x42b80e		0f57c0			XORPS X0, X0					
  0x42b811		0f11442418		MOVUPS X0, 0x18(SP)				
  0x42b816		488d0dc3b00100		LEAQ runtime.reentersyscall.func1(SB), CX	
  0x42b81d		48894c2418		MOVQ CX, 0x18(SP)				
  0x42b822		4889442420		MOVQ AX, 0x20(SP)				
  0x42b827		488d4c2418		LEAQ 0x18(SP), CX				
  0x42b82c		48890c24		MOVQ CX, 0(SP)					
  0x42b830		e8fbbe0100		CALL runtime.systemstack(SB)			
	if trace.enabled {
  0x42b835		803d94130a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42b83c		0f853e010000		JNE 0x42b980			
	if atomic.Load(&sched.sysmonwait) != 0 {
  0x42b842		8b0560650900		MOVL runtime.sched+264(SB), AX	
  0x42b848		85c0			TESTL AX, AX			
  0x42b84a		0f8503010000		JNE 0x42b953			
	if _g_.m.p.ptr().runSafePointFn != 0 {
  0x42b850		488b442410		MOVQ 0x10(SP), AX	
  0x42b855		488b4830		MOVQ 0x30(AX), CX	
  0x42b859		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42b860		8401			TESTB AL, 0(CX)		
  0x42b862		90			NOPL			
  0x42b863		83b93823000000		CMPL $0x0, 0x2338(CX)	
  0x42b86a		0f85b1000000		JNE 0x42b921		
	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
  0x42b870		488b4830		MOVQ 0x30(AX), CX	
  0x42b874		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42b87b		90			NOPL			
  0x42b87c		8b521c			MOVL 0x1c(DX), DX	
  0x42b87f		8991a4020000		MOVL DX, 0x2a4(CX)	
	_g_.sysblocktraced = true
  0x42b885		c680b800000001		MOVB $0x1, 0xb8(AX)	
	_g_.m.mcache = nil
  0x42b88c		488b4830		MOVQ 0x30(AX), CX	
  0x42b890		48c7816001000000000000	MOVQ $0x0, 0x160(CX)	
	pp := _g_.m.p.ptr()
  0x42b89b		488b4830		MOVQ 0x30(AX), CX	
  0x42b89f		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42b8a6		90			NOPL			
	pp.m = 0
  0x42b8a7		48c7414000000000	MOVQ $0x0, 0x40(CX)	
	_g_.m.oldp.set(pp)
  0x42b8af		488b5030		MOVQ 0x30(AX), DX	
  0x42b8b3		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42b8b4		4889cb			MOVQ CX, BX		
  0x42b8b7		48898ae0000000		MOVQ CX, 0xe0(DX)	
	_g_.m.p = 0
  0x42b8be		488b4830		MOVQ 0x30(AX), CX	
  0x42b8c2		48c781d000000000000000	MOVQ $0x0, 0xd0(CX)	
	atomic.Store(&pp.status, _Psyscall)
  0x42b8cd		b902000000		MOVL $0x2, CX		
  0x42b8d2		874b0c			XCHGL CX, 0xc(BX)	
	if sched.gcwaiting != 0 {
  0x42b8d5		833dbc64090000		CMPL $0x0, runtime.sched+248(SB)	
  0x42b8dc		7514			JNE 0x42b8f2				
	_g_.m.locks--
  0x42b8de		488b4030		MOVQ 0x30(AX), AX	
  0x42b8e2		ff8808010000		DECL 0x108(AX)		
}
  0x42b8e8		488b6c2428		MOVQ 0x28(SP), BP	
  0x42b8ed		4883c430		ADDQ $0x30, SP		
  0x42b8f1		c3			RET			
		systemstack(entersyscall_gcwait)
  0x42b8f2		488d05a77e0400		LEAQ 0x47ea7(IP), AX		
  0x42b8f9		48890424		MOVQ AX, 0(SP)			
  0x42b8fd		e82ebe0100		CALL runtime.systemstack(SB)	
		save(pc, sp)
  0x42b902		488b442438		MOVQ 0x38(SP), AX	
  0x42b907		48890424		MOVQ AX, 0(SP)		
  0x42b90b		488b442440		MOVQ 0x40(SP), AX	
  0x42b910		4889442408		MOVQ AX, 0x8(SP)	
  0x42b915		e816feffff		CALL runtime.save(SB)	
	_g_.m.locks--
  0x42b91a		488b442410		MOVQ 0x10(SP), AX	
		save(pc, sp)
  0x42b91f		ebbd			JMP 0x42b8de		
		systemstack(runSafePointFn)
  0x42b921		488d0538800400		LEAQ 0x48038(IP), AX		
  0x42b928		48890424		MOVQ AX, 0(SP)			
  0x42b92c		e8ffbd0100		CALL runtime.systemstack(SB)	
		save(pc, sp)
  0x42b931		488b442438		MOVQ 0x38(SP), AX	
  0x42b936		48890424		MOVQ AX, 0(SP)		
  0x42b93a		488b4c2440		MOVQ 0x40(SP), CX	
  0x42b93f		48894c2408		MOVQ CX, 0x8(SP)	
  0x42b944		e8e7fdffff		CALL runtime.save(SB)	
	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
  0x42b949		488b442410		MOVQ 0x10(SP), AX	
		save(pc, sp)
  0x42b94e		e91dffffff		JMP 0x42b870		
		systemstack(entersyscall_sysmon)
  0x42b953		488d054e7e0400		LEAQ 0x47e4e(IP), AX		
  0x42b95a		48890424		MOVQ AX, 0(SP)			
  0x42b95e		e8cdbd0100		CALL runtime.systemstack(SB)	
		save(pc, sp)
  0x42b963		488b442438		MOVQ 0x38(SP), AX	
  0x42b968		48890424		MOVQ AX, 0(SP)		
  0x42b96c		488b4c2440		MOVQ 0x40(SP), CX	
  0x42b971		48894c2408		MOVQ CX, 0x8(SP)	
  0x42b976		e8b5fdffff		CALL runtime.save(SB)	
  0x42b97b		e9d0feffff		JMP 0x42b850		
		systemstack(traceGoSysCall)
  0x42b980		488d0541800400		LEAQ 0x48041(IP), AX		
  0x42b987		48890424		MOVQ AX, 0(SP)			
  0x42b98b		e8a0bd0100		CALL runtime.systemstack(SB)	
		save(pc, sp)
  0x42b990		488b442438		MOVQ 0x38(SP), AX	
  0x42b995		48890424		MOVQ AX, 0(SP)		
  0x42b999		488b4c2440		MOVQ 0x40(SP), CX	
  0x42b99e		48894c2408		MOVQ CX, 0x8(SP)	
  0x42b9a3		e888fdffff		CALL runtime.save(SB)	
  0x42b9a8		e995feffff		JMP 0x42b842		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42b9ad		48394808		CMPQ CX, 0x8(AX)	
  0x42b9b1		0f8257feffff		JB 0x42b80e		
  0x42b9b7		e979feffff		JMP 0x42b835		

TEXT runtime.entersyscall(SB) /usr/local/go/src/runtime/proc.go
func entersyscall() {
  0x42b9c0		4883ec18		SUBQ $0x18, SP		
  0x42b9c4		48896c2410		MOVQ BP, 0x10(SP)	
  0x42b9c9		488d6c2410		LEAQ 0x10(SP), BP	
	reentersyscall(getcallerpc(), getcallersp())
  0x42b9ce		488b442418		MOVQ 0x18(SP), AX		
  0x42b9d3		48890424		MOVQ AX, 0(SP)			
  0x42b9d7		488d442420		LEAQ 0x20(SP), AX		
  0x42b9dc		4889442408		MOVQ AX, 0x8(SP)		
  0x42b9e1		e89afdffff		CALL runtime.reentersyscall(SB)	
}
  0x42b9e6		488b6c2410		MOVQ 0x10(SP), BP	
  0x42b9eb		4883c418		ADDQ $0x18, SP		
  0x42b9ef		c3			RET			

TEXT runtime.entersyscall_sysmon(SB) /usr/local/go/src/runtime/proc.go
func entersyscall_sysmon() {
  0x42b9f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42b9f9		483b6110		CMPQ 0x10(CX), SP	
  0x42b9fd		765f			JBE 0x42ba5e		
  0x42b9ff		4883ec10		SUBQ $0x10, SP		
  0x42ba03		48896c2408		MOVQ BP, 0x8(SP)	
  0x42ba08		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.lock)
  0x42ba0d		488d059c620900		LEAQ runtime.sched+16(SB), AX	
  0x42ba14		48890424		MOVQ AX, 0(SP)			
  0x42ba18		e8c3ccfdff		CALL runtime.lock(SB)		
	if atomic.Load(&sched.sysmonwait) != 0 {
  0x42ba1d		8b0585630900		MOVL runtime.sched+264(SB), AX	
  0x42ba23		85c0			TESTL AX, AX			
  0x42ba25		751a			JNE 0x42ba41			
	unlock(&sched.lock)
  0x42ba27		488d0582620900		LEAQ runtime.sched+16(SB), AX	
  0x42ba2e		48890424		MOVQ AX, 0(SP)			
  0x42ba32		e859cefdff		CALL runtime.unlock(SB)		
}
  0x42ba37		488b6c2408		MOVQ 0x8(SP), BP	
  0x42ba3c		4883c410		ADDQ $0x10, SP		
  0x42ba40		c3			RET			
		atomic.Store(&sched.sysmonwait, 0)
  0x42ba41		31c0			XORL AX, AX			
  0x42ba43		488d0d5e630900		LEAQ runtime.sched+264(SB), CX	
  0x42ba4a		8701			XCHGL AX, 0(CX)			
		notewakeup(&sched.sysmonnote)
  0x42ba4c		488d055d630900		LEAQ runtime.sched+272(SB), AX	
  0x42ba53		48890424		MOVQ AX, 0(SP)			
  0x42ba57		e804cffdff		CALL runtime.notewakeup(SB)	
  0x42ba5c		ebc9			JMP 0x42ba27			
func entersyscall_sysmon() {
  0x42ba5e		e81dbe0100		CALL runtime.morestack_noctxt(SB)	
  0x42ba63		eb8b			JMP runtime.entersyscall_sysmon(SB)	

TEXT runtime.entersyscall_gcwait(SB) /usr/local/go/src/runtime/proc.go
func entersyscall_gcwait() {
  0x42ba70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ba79		483b6110		CMPQ 0x10(CX), SP	
  0x42ba7d		0f86d3000000		JBE 0x42bb56		
  0x42ba83		4883ec18		SUBQ $0x18, SP		
  0x42ba87		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ba8c		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x42ba91		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_p_ := _g_.m.oldp.ptr()
  0x42ba9a		488b4030		MOVQ 0x30(AX), AX	
  0x42ba9e		488b80e0000000		MOVQ 0xe0(AX), AX	
  0x42baa5		90			NOPL			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42baa6		4889442408		MOVQ AX, 0x8(SP)	
	lock(&sched.lock)
  0x42baab		488d0dfe610900		LEAQ runtime.sched+16(SB), CX	
  0x42bab2		48890c24		MOVQ CX, 0(SP)			
  0x42bab6		e825ccfdff		CALL runtime.lock(SB)		
	if sched.stopwait > 0 && atomic.Cas(&_p_.status, _Psyscall, _Pgcstop) {
  0x42babb		833dda62090000		CMPL $0x0, runtime.sched+252(SB)	
  0x42bac2		0f8e85000000		JLE 0x42bb4d				
  0x42bac8		b802000000		MOVL $0x2, AX				
  0x42bacd		488b4c2408		MOVQ 0x8(SP), CX			
  0x42bad2		ba03000000		MOVL $0x3, DX				
  0x42bad7		f00fb1510c		LOCK CMPXCHGL DX, 0xc(CX)		
  0x42badc		0f94c2			SETE DL					
  0x42badf		84d2			TESTL DL, DL				
  0x42bae1		7420			JE 0x42bb03				
		if trace.enabled {
  0x42bae3		803de6100a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42baea		7543			JNE 0x42bb2f			
		_p_.syscalltick++
  0x42baec		ff411c			INCL 0x1c(CX)		
		if sched.stopwait--; sched.stopwait == 0 {
  0x42baef		8b05a7620900		MOVL runtime.sched+252(SB), AX	
  0x42baf5		8d48ff			LEAL -0x1(AX), CX		
  0x42baf8		890d9e620900		MOVL CX, runtime.sched+252(SB)	
  0x42bafe		83f801			CMPL $0x1, AX			
  0x42bb01		741a			JE 0x42bb1d			
	unlock(&sched.lock)
  0x42bb03		488d05a6610900		LEAQ runtime.sched+16(SB), AX	
  0x42bb0a		48890424		MOVQ AX, 0(SP)			
  0x42bb0e		e87dcdfdff		CALL runtime.unlock(SB)		
}
  0x42bb13		488b6c2410		MOVQ 0x10(SP), BP	
  0x42bb18		4883c418		ADDQ $0x18, SP		
  0x42bb1c		c3			RET			
			notewakeup(&sched.stopnote)
  0x42bb1d		488d057c620900		LEAQ runtime.sched+256(SB), AX	
  0x42bb24		48890424		MOVQ AX, 0(SP)			
  0x42bb28		e833cefdff		CALL runtime.notewakeup(SB)	
  0x42bb2d		ebd4			JMP 0x42bb03			
			traceGoSysBlock(_p_)
  0x42bb2f		48890c24		MOVQ CX, 0(SP)				
  0x42bb33		e8c8180100		CALL runtime.traceGoSysBlock(SB)	
			traceProcStop(_p_)
  0x42bb38		488b442408		MOVQ 0x8(SP), AX		
  0x42bb3d		48890424		MOVQ AX, 0(SP)			
  0x42bb41		e87a100100		CALL runtime.traceProcStop(SB)	
		_p_.syscalltick++
  0x42bb46		488b4c2408		MOVQ 0x8(SP), CX	
			traceProcStop(_p_)
  0x42bb4b		eb9f			JMP 0x42baec		
		_p_.syscalltick++
  0x42bb4d		488b4c2408		MOVQ 0x8(SP), CX	
  0x42bb52		31d2			XORL DX, DX		
	if sched.stopwait > 0 && atomic.Cas(&_p_.status, _Psyscall, _Pgcstop) {
  0x42bb54		eb89			JMP 0x42badf		
func entersyscall_gcwait() {
  0x42bb56		e825bd0100		CALL runtime.morestack_noctxt(SB)	
  0x42bb5b		e910ffffff		JMP runtime.entersyscall_gcwait(SB)	

TEXT runtime.entersyscallblock(SB) /usr/local/go/src/runtime/proc.go
func entersyscallblock() {
  0x42bb60		4883ec60		SUBQ $0x60, SP		
  0x42bb64		48896c2458		MOVQ BP, 0x58(SP)	
  0x42bb69		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x42bb6e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42bb77		4889442410		MOVQ AX, 0x10(SP)	
	_g_.m.locks++ // see comment in entersyscall
  0x42bb7c		488b4830		MOVQ 0x30(AX), CX	
  0x42bb80		ff8108010000		INCL 0x108(CX)		
	_g_.throwsplit = true
  0x42bb86		c680b600000001		MOVB $0x1, 0xb6(AX)	
	_g_.stackguard0 = stackPreempt // see comment in entersyscall
  0x42bb8d		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
  0x42bb95		488b4830		MOVQ 0x30(AX), CX	
  0x42bb99		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42bba0		90			NOPL			
  0x42bba1		8b521c			MOVL 0x1c(DX), DX	
  0x42bba4		8991a4020000		MOVL DX, 0x2a4(CX)	
	_g_.sysblocktraced = true
  0x42bbaa		c680b800000001		MOVB $0x1, 0xb8(AX)	
	_g_.m.p.ptr().syscalltick++
  0x42bbb1		488b4830		MOVQ 0x30(AX), CX	
  0x42bbb5		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42bbbc		90			NOPL			
  0x42bbbd		ff411c			INCL 0x1c(CX)		
	save(pc, sp)
  0x42bbc0		488b4c2460		MOVQ 0x60(SP), CX	
  0x42bbc5		48890c24		MOVQ CX, 0(SP)		
  0x42bbc9		488d542468		LEAQ 0x68(SP), DX	
  0x42bbce		4889542408		MOVQ DX, 0x8(SP)	
  0x42bbd3		e858fbffff		CALL runtime.save(SB)	
	_g_.syscallsp = _g_.sched.sp
  0x42bbd8		488b442410		MOVQ 0x10(SP), AX	
  0x42bbdd		488b4838		MOVQ 0x38(AX), CX	
  0x42bbe1		48894870		MOVQ CX, 0x70(AX)	
	_g_.syscallpc = _g_.sched.pc
  0x42bbe5		488b5040		MOVQ 0x40(AX), DX	
  0x42bbe9		48895078		MOVQ DX, 0x78(AX)	
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42bbed		483908			CMPQ CX, 0(AX)		
  0x42bbf0		0f86ff000000		JBE 0x42bcf5		
		sp2 := _g_.sched.sp
  0x42bbf6		488b5038		MOVQ 0x38(AX), DX	
		systemstack(func() {
  0x42bbfa		48c744243000000000	MOVQ $0x0, 0x30(SP)				
  0x42bc03		0f57c0			XORPS X0, X0					
  0x42bc06		0f11442438		MOVUPS X0, 0x38(SP)				
  0x42bc0b		0f11442448		MOVUPS X0, 0x48(SP)				
  0x42bc10		488d1dc9ad0100		LEAQ runtime.entersyscallblock.func1(SB), BX	
  0x42bc17		48895c2430		MOVQ BX, 0x30(SP)				
  0x42bc1c		488d5c2468		LEAQ 0x68(SP), BX				
  0x42bc21		48895c2438		MOVQ BX, 0x38(SP)				
  0x42bc26		4889542440		MOVQ DX, 0x40(SP)				
  0x42bc2b		48894c2448		MOVQ CX, 0x48(SP)				
  0x42bc30		4889442450		MOVQ AX, 0x50(SP)				
  0x42bc35		488d4c2430		LEAQ 0x30(SP), CX				
  0x42bc3a		48890c24		MOVQ CX, 0(SP)					
  0x42bc3e		e8edba0100		CALL runtime.systemstack(SB)			
	casgstatus(_g_, _Grunning, _Gsyscall)
  0x42bc43		488b442410		MOVQ 0x10(SP), AX		
  0x42bc48		48890424		MOVQ AX, 0(SP)			
  0x42bc4c		48b90200000003000000	MOVQ $0x300000002, CX		
  0x42bc56		48894c2408		MOVQ CX, 0x8(SP)		
  0x42bc5b		e840b0ffff		CALL runtime.casgstatus(SB)	
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42bc60		488b442410		MOVQ 0x10(SP), AX	
  0x42bc65		488b4870		MOVQ 0x70(AX), CX	
  0x42bc69		483908			CMPQ CX, 0(AX)		
  0x42bc6c		767b			JBE 0x42bce9		
		systemstack(func() {
  0x42bc6e		0f57c0			XORPS X0, X0					
  0x42bc71		0f11442418		MOVUPS X0, 0x18(SP)				
  0x42bc76		48c744242800000000	MOVQ $0x0, 0x28(SP)				
  0x42bc7f		488d0d9aae0100		LEAQ runtime.entersyscallblock.func2(SB), CX	
  0x42bc86		48894c2418		MOVQ CX, 0x18(SP)				
  0x42bc8b		488d4c2468		LEAQ 0x68(SP), CX				
  0x42bc90		48894c2420		MOVQ CX, 0x20(SP)				
  0x42bc95		4889442428		MOVQ AX, 0x28(SP)				
  0x42bc9a		488d542418		LEAQ 0x18(SP), DX				
  0x42bc9f		48891424		MOVQ DX, 0(SP)					
  0x42bca3		e888ba0100		CALL runtime.systemstack(SB)			
	systemstack(entersyscallblock_handoff)
  0x42bca8		488d05017b0400		LEAQ 0x47b01(IP), AX		
  0x42bcaf		48890424		MOVQ AX, 0(SP)			
  0x42bcb3		e878ba0100		CALL runtime.systemstack(SB)	
	save(getcallerpc(), getcallersp())
  0x42bcb8		488b442460		MOVQ 0x60(SP), AX	
  0x42bcbd		48890424		MOVQ AX, 0(SP)		
  0x42bcc1		488d442468		LEAQ 0x68(SP), AX	
  0x42bcc6		4889442408		MOVQ AX, 0x8(SP)	
  0x42bccb		e860faffff		CALL runtime.save(SB)	
	_g_.m.locks--
  0x42bcd0		488b442410		MOVQ 0x10(SP), AX	
  0x42bcd5		488b4030		MOVQ 0x30(AX), AX	
  0x42bcd9		ff8808010000		DECL 0x108(AX)		
}
  0x42bcdf		488b6c2458		MOVQ 0x58(SP), BP	
  0x42bce4		4883c460		ADDQ $0x60, SP		
  0x42bce8		c3			RET			
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42bce9		48394808		CMPQ CX, 0x8(AX)	
  0x42bced		0f827bffffff		JB 0x42bc6e		
  0x42bcf3		ebb3			JMP 0x42bca8		
	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
  0x42bcf5		48394808		CMPQ CX, 0x8(AX)	
  0x42bcf9		0f82f7feffff		JB 0x42bbf6		
  0x42bcff		e93fffffff		JMP 0x42bc43		

TEXT runtime.entersyscallblock_handoff(SB) /usr/local/go/src/runtime/proc.go
func entersyscallblock_handoff() {
  0x42bd10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42bd19		483b6110		CMPQ 0x10(CX), SP	
  0x42bd1d		766f			JBE 0x42bd8e		
  0x42bd1f		4883ec30		SUBQ $0x30, SP		
  0x42bd23		48896c2428		MOVQ BP, 0x28(SP)	
  0x42bd28		488d6c2428		LEAQ 0x28(SP), BP	
	if trace.enabled {
  0x42bd2d		803d9c0e0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42bd34		7514			JNE 0x42bd4a			
	handoffp(releasep())
  0x42bd36		e855290000		CALL runtime.releasep(SB)	
  0x42bd3b		e850d4ffff		CALL runtime.handoffp(SB)	
}
  0x42bd40		488b6c2428		MOVQ 0x28(SP), BP	
  0x42bd45		4883c430		ADDQ $0x30, SP		
  0x42bd49		c3			RET			
		traceGoSysCall()
  0x42bd4a		90			NOPL			
	traceEvent(traceEvGoSysCall, 1)
  0x42bd4b		c604241c		MOVB $0x1c, 0(SP)		
  0x42bd4f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42bd58		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42bd61		0f57c0			XORPS X0, X0			
  0x42bd64		0f11442418		MOVUPS X0, 0x18(SP)		
  0x42bd69		e832010100		CALL runtime.traceEvent(SB)	
		traceGoSysBlock(getg().m.p.ptr())
  0x42bd6e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX			
  0x42bd77		488b4030		MOVQ 0x30(AX), AX			
  0x42bd7b		488b80d0000000		MOVQ 0xd0(AX), AX			
  0x42bd82		90			NOPL					
  0x42bd83		48890424		MOVQ AX, 0(SP)				
  0x42bd87		e874160100		CALL runtime.traceGoSysBlock(SB)	
  0x42bd8c		eba8			JMP 0x42bd36				
func entersyscallblock_handoff() {
  0x42bd8e		e8edba0100		CALL runtime.morestack_noctxt(SB)		
  0x42bd93		e978ffffff		JMP runtime.entersyscallblock_handoff(SB)	

TEXT runtime.exitsyscall(SB) /usr/local/go/src/runtime/proc.go
func exitsyscall() {
  0x42bda0		4883ec28		SUBQ $0x28, SP		
  0x42bda4		48896c2420		MOVQ BP, 0x20(SP)	
  0x42bda9		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x42bdae		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++ // see comment in entersyscall
  0x42bdb7		488b4830		MOVQ 0x30(AX), CX	
  0x42bdbb		ff8108010000		INCL 0x108(CX)		
	if getcallersp() > _g_.syscallsp {
  0x42bdc1		488d4c2430		LEAQ 0x30(SP), CX	
  0x42bdc6		48394870		CMPQ CX, 0x70(AX)	
  0x42bdca		0f8236020000		JB 0x42c006		
	_g_ := getg()
  0x42bdd0		4889442410		MOVQ AX, 0x10(SP)	
	_g_.waitsince = 0
  0x42bdd5		48c780a800000000000000	MOVQ $0x0, 0xa8(AX)	
	oldp := _g_.m.oldp.ptr()
  0x42bde0		488b4830		MOVQ 0x30(AX), CX	
  0x42bde4		488b91e0000000		MOVQ 0xe0(CX), DX	
  0x42bdeb		90			NOPL			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42bdec		4889542418		MOVQ DX, 0x18(SP)	
	_g_.m.oldp = 0
  0x42bdf1		48c781e000000000000000	MOVQ $0x0, 0xe0(CX)	
	if exitsyscallfast(oldp) {
  0x42bdfc		48891424		MOVQ DX, 0(SP)				
  0x42be00		e82b020000		CALL runtime.exitsyscallfast(SB)	
  0x42be05		807c240800		CMPB $0x0, 0x8(SP)			
  0x42be0a		0f85ba000000		JNE 0x42beca				
	_g_.sysexitticks = 0
  0x42be10		488b442410		MOVQ 0x10(SP), AX	
  0x42be15		48c780c000000000000000	MOVQ $0x0, 0xc0(AX)	
	if trace.enabled {
  0x42be20		803da90d0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42be27		0f8498000000		JE 0x42bec5			
		for oldp != nil && oldp.syscalltick == _g_.m.syscalltick {
  0x42be2d		488b4c2418		MOVQ 0x18(SP), CX	
  0x42be32		eb0f			JMP 0x42be43		
			osyield()
  0x42be34		e8b7f70100		CALL runtime.osyield(SB)	
		for oldp != nil && oldp.syscalltick == _g_.m.syscalltick {
  0x42be39		488b442410		MOVQ 0x10(SP), AX	
  0x42be3e		488b4c2418		MOVQ 0x18(SP), CX	
  0x42be43		4885c9			TESTQ CX, CX		
  0x42be46		740f			JE 0x42be57		
  0x42be48		488b5030		MOVQ 0x30(AX), DX	
  0x42be4c		8b92a4020000		MOVL 0x2a4(DX), DX	
  0x42be52		39511c			CMPL DX, 0x1c(CX)	
  0x42be55		74dd			JE 0x42be34		
		_g_.sysexitticks = cputicks()
  0x42be57		e8b4d10100		CALL runtime.cputicks(SB)	
  0x42be5c		488b0424		MOVQ 0(SP), AX			
  0x42be60		488b4c2410		MOVQ 0x10(SP), CX		
  0x42be65		488981c0000000		MOVQ AX, 0xc0(CX)		
	_g_.m.locks--
  0x42be6c		488b4130		MOVQ 0x30(CX), AX	
  0x42be70		ff8808010000		DECL 0x108(AX)		
	mcall(exitsyscall0)
  0x42be76		488d053b790400		LEAQ 0x4793b(IP), AX	
  0x42be7d		48890424		MOVQ AX, 0(SP)		
  0x42be81		e82ab80100		CALL runtime.mcall(SB)	
	if _g_.m.mcache == nil {
  0x42be86		488b442410		MOVQ 0x10(SP), AX	
  0x42be8b		488b4830		MOVQ 0x30(AX), CX	
  0x42be8f		4883b96001000000	CMPQ $0x0, 0x160(CX)	
  0x42be97		0f8433010000		JE 0x42bfd0		
	_g_.syscallsp = 0
  0x42be9d		48c7407000000000	MOVQ $0x0, 0x70(AX)	
	_g_.m.p.ptr().syscalltick++
  0x42bea5		488b4830		MOVQ 0x30(AX), CX	
  0x42bea9		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42beb0		90			NOPL			
  0x42beb1		ff411c			INCL 0x1c(CX)		
	_g_.throwsplit = false
  0x42beb4		c680b600000000		MOVB $0x0, 0xb6(AX)	
}
  0x42bebb		488b6c2420		MOVQ 0x20(SP), BP	
  0x42bec0		4883c428		ADDQ $0x28, SP		
  0x42bec4		c3			RET			
	_g_.m.locks--
  0x42bec5		4889c1			MOVQ AX, CX		
	if trace.enabled {
  0x42bec8		eba2			JMP 0x42be6c		
		if _g_.m.mcache == nil {
  0x42beca		488b442410		MOVQ 0x10(SP), AX	
  0x42becf		488b4830		MOVQ 0x30(AX), CX	
  0x42bed3		4883b96001000000	CMPQ $0x0, 0x160(CX)	
  0x42bedb		0f840a010000		JE 0x42bfeb		
		if trace.enabled {
  0x42bee1		803de80c0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42bee8		7426			JE 0x42bf10			
			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x42beea		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42bef1		90			NOPL			
  0x42bef2		488b5c2418		MOVQ 0x18(SP), BX	
  0x42bef7		4839d3			CMPQ DX, BX		
  0x42befa		0f84bb000000		JE 0x42bfbb		
				systemstack(traceGoStart)
  0x42bf00		488d05b97a0400		LEAQ 0x47ab9(IP), AX		
  0x42bf07		48890424		MOVQ AX, 0(SP)			
  0x42bf0b		e820b80100		CALL runtime.systemstack(SB)	
		_g_.m.p.ptr().syscalltick++
  0x42bf10		488b442410		MOVQ 0x10(SP), AX	
  0x42bf15		488b4830		MOVQ 0x30(AX), CX	
  0x42bf19		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42bf20		90			NOPL			
  0x42bf21		ff411c			INCL 0x1c(CX)		
		casgstatus(_g_, _Gsyscall, _Grunning)
  0x42bf24		48890424		MOVQ AX, 0(SP)			
  0x42bf28		48b90300000002000000	MOVQ $0x200000003, CX		
  0x42bf32		48894c2408		MOVQ CX, 0x8(SP)		
  0x42bf37		e864adffff		CALL runtime.casgstatus(SB)	
		_g_.syscallsp = 0
  0x42bf3c		488b442410		MOVQ 0x10(SP), AX	
  0x42bf41		48c7407000000000	MOVQ $0x0, 0x70(AX)	
		_g_.m.locks--
  0x42bf49		488b4830		MOVQ 0x30(AX), CX	
  0x42bf4d		ff8908010000		DECL 0x108(CX)		
		if _g_.preempt {
  0x42bf53		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x42bf5a		744f			JE 0x42bfab		
			_g_.stackguard0 = stackPreempt
  0x42bf5c		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
		_g_.throwsplit = false
  0x42bf64		c680b600000000		MOVB $0x0, 0xb6(AX)	
		if sched.disable.user && !schedEnabled(_g_) {
  0x42bf6b		803d9e5d090000		CMPB $0x0, runtime.sched+112(SB)	
  0x42bf72		7524			JNE 0x42bf98				
  0x42bf74		31c0			XORL AX, AX				
  0x42bf76		84c0			TESTL AL, AL				
  0x42bf78		750a			JNE 0x42bf84				
		return
  0x42bf7a		488b6c2420		MOVQ 0x20(SP), BP	
  0x42bf7f		4883c428		ADDQ $0x28, SP		
  0x42bf83		c3			RET			
			Gosched()
  0x42bf84		90			NOPL			
	checkTimeouts()
  0x42bf85		90			NOPL			
	mcall(gosched_m)
  0x42bf86		488d05cb780400		LEAQ 0x478cb(IP), AX	
  0x42bf8d		48890424		MOVQ AX, 0(SP)		
  0x42bf91		e81ab70100		CALL runtime.mcall(SB)	
		return
  0x42bf96		ebe2			JMP 0x42bf7a		
		if sched.disable.user && !schedEnabled(_g_) {
  0x42bf98		48890424		MOVQ AX, 0(SP)			
  0x42bf9c		e81f420000		CALL runtime.schedEnabled(SB)	
  0x42bfa1		0fb6442408		MOVZX 0x8(SP), AX		
  0x42bfa6		83f001			XORL $0x1, AX			
  0x42bfa9		ebcb			JMP 0x42bf76			
			_g_.stackguard0 = _g_.stack.lo + _StackGuard
  0x42bfab		488b08			MOVQ 0(AX), CX		
  0x42bfae		4881c170030000		ADDQ $0x370, CX		
  0x42bfb5		48894810		MOVQ CX, 0x10(AX)	
  0x42bfb9		eba9			JMP 0x42bf64		
			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x42bfbb		90			NOPL			
  0x42bfbc		8b521c			MOVL 0x1c(DX), DX	
  0x42bfbf		3991a4020000		CMPL DX, 0x2a4(CX)	
  0x42bfc5		0f8535ffffff		JNE 0x42bf00		
  0x42bfcb		e940ffffff		JMP 0x42bf10		
		throw("lost mcache")
  0x42bfd0		488d055d390400		LEAQ 0x4395d(IP), AX	
  0x42bfd7		48890424		MOVQ AX, 0(SP)		
  0x42bfdb		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42bfe4		e89774ffff		CALL runtime.throw(SB)	
  0x42bfe9		0f0b			UD2			
			throw("lost mcache")
  0x42bfeb		488d0542390400		LEAQ 0x43942(IP), AX	
  0x42bff2		48890424		MOVQ AX, 0(SP)		
  0x42bff6		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x42bfff		e87c74ffff		CALL runtime.throw(SB)	
  0x42c004		0f0b			UD2			
		throw("exitsyscall: syscall frame is no longer valid")
  0x42c006		488d054e6e0400		LEAQ 0x46e4e(IP), AX	
  0x42c00d		48890424		MOVQ AX, 0(SP)		
  0x42c011		48c74424082d000000	MOVQ $0x2d, 0x8(SP)	
  0x42c01a		e86174ffff		CALL runtime.throw(SB)	
  0x42c01f		0f0b			UD2			

TEXT runtime.exitsyscallfast(SB) /usr/local/go/src/runtime/proc.go
func exitsyscallfast(oldp *p) bool {
  0x42c030		4883ec38		SUBQ $0x38, SP		
  0x42c034		48896c2430		MOVQ BP, 0x30(SP)	
  0x42c039		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x42c03e		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	if sched.stopwait == freezeStopWait {
  0x42c047		813d4b5d0900ffffff7f	CMPL $0x7fffffff, runtime.sched+252(SB)	
  0x42c051		0f84c5000000		JE 0x42c11c				
	if oldp != nil && oldp.status == _Psyscall && atomic.Cas(&oldp.status, _Psyscall, _Pidle) {
  0x42c057		488b542440		MOVQ 0x40(SP), DX		
  0x42c05c		4885d2			TESTQ DX, DX			
  0x42c05f		0f84b0000000		JE 0x42c115			
  0x42c065		837a0c02		CMPL $0x2, 0xc(DX)		
  0x42c069		0f859f000000		JNE 0x42c10e			
  0x42c06f		b802000000		MOVL $0x2, AX			
  0x42c074		31db			XORL BX, BX			
  0x42c076		f00fb15a0c		LOCK CMPXCHGL BX, 0xc(DX)	
  0x42c07b		0f94c3			SETE BL				
  0x42c07e		84db			TESTL BL, BL			
  0x42c080		756f			JNE 0x42c0f1			
	if sched.pidle != 0 {
  0x42c082		48833d5e5c090000	CMPQ $0x0, runtime.sched+72(SB)	
  0x42c08a		750f			JNE 0x42c09b			
	return false
  0x42c08c		c644244800		MOVB $0x0, 0x48(SP)	
  0x42c091		488b6c2430		MOVQ 0x30(SP), BP	
  0x42c096		4883c438		ADDQ $0x38, SP		
  0x42c09a		c3			RET			
		var ok bool
  0x42c09b		c644240f00		MOVB $0x0, 0xf(SP)	
		systemstack(func() {
  0x42c0a0		0f57c0			XORPS X0, X0					
  0x42c0a3		0f11442410		MOVUPS X0, 0x10(SP)				
  0x42c0a8		0f11442420		MOVUPS X0, 0x20(SP)				
  0x42c0ad		488d05acab0100		LEAQ runtime.exitsyscallfast.func1(SB), AX	
  0x42c0b4		4889442410		MOVQ AX, 0x10(SP)				
  0x42c0b9		488d44240f		LEAQ 0xf(SP), AX				
  0x42c0be		4889442418		MOVQ AX, 0x18(SP)				
  0x42c0c3		4889542420		MOVQ DX, 0x20(SP)				
  0x42c0c8		48894c2428		MOVQ CX, 0x28(SP)				
  0x42c0cd		488d442410		LEAQ 0x10(SP), AX				
  0x42c0d2		48890424		MOVQ AX, 0(SP)					
  0x42c0d6		e855b60100		CALL runtime.systemstack(SB)			
		if ok {
  0x42c0db		807c240f00		CMPB $0x0, 0xf(SP)	
  0x42c0e0		74aa			JE 0x42c08c		
			return true
  0x42c0e2		c644244801		MOVB $0x1, 0x48(SP)	
  0x42c0e7		488b6c2430		MOVQ 0x30(SP), BP	
  0x42c0ec		4883c438		ADDQ $0x38, SP		
  0x42c0f0		c3			RET			
		wirep(oldp)
  0x42c0f1		48891424		MOVQ DX, 0(SP)		
  0x42c0f5		e836240000		CALL runtime.wirep(SB)	
		exitsyscallfast_reacquired()
  0x42c0fa		e831000000		CALL runtime.exitsyscallfast_reacquired(SB)	
		return true
  0x42c0ff		c644244801		MOVB $0x1, 0x48(SP)	
  0x42c104		488b6c2430		MOVQ 0x30(SP), BP	
  0x42c109		4883c438		ADDQ $0x38, SP		
  0x42c10d		c3			RET			
  0x42c10e		31db			XORL BX, BX		
	if oldp != nil && oldp.status == _Psyscall && atomic.Cas(&oldp.status, _Psyscall, _Pidle) {
  0x42c110		e969ffffff		JMP 0x42c07e		
  0x42c115		31db			XORL BX, BX		
  0x42c117		e962ffffff		JMP 0x42c07e		
		return false
  0x42c11c		c644244800		MOVB $0x0, 0x48(SP)	
  0x42c121		488b6c2430		MOVQ 0x30(SP), BP	
  0x42c126		4883c438		ADDQ $0x38, SP		
  0x42c12a		c3			RET			

TEXT runtime.exitsyscallfast_reacquired(SB) /usr/local/go/src/runtime/proc.go
func exitsyscallfast_reacquired() {
  0x42c130		4883ec28		SUBQ $0x28, SP		
  0x42c134		48896c2420		MOVQ BP, 0x20(SP)	
  0x42c139		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x42c13e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
  0x42c147		488b4830		MOVQ 0x30(AX), CX	
  0x42c14b		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42c152		90			NOPL			
  0x42c153		8b521c			MOVL 0x1c(DX), DX	
  0x42c156		3991a4020000		CMPL DX, 0x2a4(CX)	
  0x42c15c		7418			JE 0x42c176		
		if trace.enabled {
  0x42c15e		803d6b0a0a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42c165		7519			JNE 0x42c180			
		_g_.m.p.ptr().syscalltick++
  0x42c167		488b4030		MOVQ 0x30(AX), AX	
  0x42c16b		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x42c172		90			NOPL			
  0x42c173		ff401c			INCL 0x1c(AX)		
  0x42c176		488b6c2420		MOVQ 0x20(SP), BP	
  0x42c17b		4883c428		ADDQ $0x28, SP		
  0x42c17f		c3			RET			
	_g_ := getg()
  0x42c180		4889442408		MOVQ AX, 0x8(SP)	
			systemstack(func() {
  0x42c185		0f57c0			XORPS X0, X0						
  0x42c188		0f11442410		MOVUPS X0, 0x10(SP)					
  0x42c18d		488d0d7cab0100		LEAQ runtime.exitsyscallfast_reacquired.func1(SB), CX	
  0x42c194		48894c2410		MOVQ CX, 0x10(SP)					
  0x42c199		4889442418		MOVQ AX, 0x18(SP)					
  0x42c19e		488d4c2410		LEAQ 0x10(SP), CX					
  0x42c1a3		48890c24		MOVQ CX, 0(SP)						
  0x42c1a7		e884b50100		CALL runtime.systemstack(SB)				
		_g_.m.p.ptr().syscalltick++
  0x42c1ac		488b442408		MOVQ 0x8(SP), AX	
			systemstack(func() {
  0x42c1b1		ebb4			JMP 0x42c167		

TEXT runtime.exitsyscallfast_pidle(SB) /usr/local/go/src/runtime/proc.go
func exitsyscallfast_pidle() bool {
  0x42c1c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c1c9		483b6110		CMPQ 0x10(CX), SP	
  0x42c1cd		0f86c2000000		JBE 0x42c295		
  0x42c1d3		4883ec18		SUBQ $0x18, SP		
  0x42c1d7		48896c2410		MOVQ BP, 0x10(SP)	
  0x42c1dc		488d6c2410		LEAQ 0x10(SP), BP	
	lock(&sched.lock)
  0x42c1e1		488d05c85a0900		LEAQ runtime.sched+16(SB), AX	
  0x42c1e8		48890424		MOVQ AX, 0(SP)			
  0x42c1ec		e8efc4fdff		CALL runtime.lock(SB)		
	_p_ := pidleget()
  0x42c1f1		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x42c1f2		488b05ef5a0900		MOVQ runtime.sched+72(SB), AX	
  0x42c1f9		90			NOPL				
	if _p_ != nil {
  0x42c1fa		4885c0			TESTQ AX, AX		
  0x42c1fd		741e			JE 0x42c21d		
		sched.pidle = _p_.link
  0x42c1ff		488b4810		MOVQ 0x10(AX), CX		
  0x42c203		48890dde5a0900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42c20a		b9ffffffff		MOVL $-0x1, CX			
  0x42c20f		488d15da5a0900		LEAQ runtime.sched+80(SB), DX	
  0x42c216		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x42c21a		4885c0			TESTQ AX, AX		
	if _p_ != nil && atomic.Load(&sched.sysmonwait) != 0 {
  0x42c21d		7472			JE 0x42c291			
  0x42c21f		8b0d835b0900		MOVL runtime.sched+264(SB), CX	
  0x42c225		85c9			TESTL CX, CX			
  0x42c227		0f95c1			SETNE CL			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42c22a		4889442408		MOVQ AX, 0x8(SP)	
	if _p_ != nil && atomic.Load(&sched.sysmonwait) != 0 {
  0x42c22f		84c9			TESTL CL, CL		
  0x42c231		7541			JNE 0x42c274		
	unlock(&sched.lock)
  0x42c233		488d05765a0900		LEAQ runtime.sched+16(SB), AX	
  0x42c23a		48890424		MOVQ AX, 0(SP)			
  0x42c23e		e84dc6fdff		CALL runtime.unlock(SB)		
	if _p_ != nil {
  0x42c243		488b442408		MOVQ 0x8(SP), AX	
  0x42c248		4885c0			TESTQ AX, AX		
	if _p_ != nil {
  0x42c24b		7418			JE 0x42c265		
		acquirep(_p_)
  0x42c24d		48890424		MOVQ AX, 0(SP)			
  0x42c251		e87a220000		CALL runtime.acquirep(SB)	
		return true
  0x42c256		c644242001		MOVB $0x1, 0x20(SP)	
  0x42c25b		488b6c2410		MOVQ 0x10(SP), BP	
  0x42c260		4883c418		ADDQ $0x18, SP		
  0x42c264		c3			RET			
	return false
  0x42c265		c644242000		MOVB $0x0, 0x20(SP)	
  0x42c26a		488b6c2410		MOVQ 0x10(SP), BP	
  0x42c26f		4883c418		ADDQ $0x18, SP		
  0x42c273		c3			RET			
		atomic.Store(&sched.sysmonwait, 0)
  0x42c274		31c0			XORL AX, AX			
  0x42c276		488d0d2b5b0900		LEAQ runtime.sched+264(SB), CX	
  0x42c27d		8701			XCHGL AX, 0(CX)			
		notewakeup(&sched.sysmonnote)
  0x42c27f		488d052a5b0900		LEAQ runtime.sched+272(SB), AX	
  0x42c286		48890424		MOVQ AX, 0(SP)			
  0x42c28a		e8d1c6fdff		CALL runtime.notewakeup(SB)	
  0x42c28f		eba2			JMP 0x42c233			
  0x42c291		31c9			XORL CX, CX			
	if _p_ != nil && atomic.Load(&sched.sysmonwait) != 0 {
  0x42c293		eb95			JMP 0x42c22a		
func exitsyscallfast_pidle() bool {
  0x42c295		e8e6b50100		CALL runtime.morestack_noctxt(SB)	
  0x42c29a		e921ffffff		JMP runtime.exitsyscallfast_pidle(SB)	

TEXT runtime.exitsyscall0(SB) /usr/local/go/src/runtime/proc.go
func exitsyscall0(gp *g) {
  0x42c2a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c2a9		483b6110		CMPQ 0x10(CX), SP	
  0x42c2ad		0f86c2010000		JBE 0x42c475		
  0x42c2b3		4883ec28		SUBQ $0x28, SP		
  0x42c2b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x42c2bc		488d6c2420		LEAQ 0x20(SP), BP	
	_g_ := getg()
  0x42c2c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42c2ca		4889442418		MOVQ AX, 0x18(SP)	
	casgstatus(gp, _Gsyscall, _Grunnable)
  0x42c2cf		488b4c2430		MOVQ 0x30(SP), CX		
  0x42c2d4		48890c24		MOVQ CX, 0(SP)			
  0x42c2d8		48ba0300000001000000	MOVQ $0x100000003, DX		
  0x42c2e2		4889542408		MOVQ DX, 0x8(SP)		
  0x42c2e7		e8b4a9ffff		CALL runtime.casgstatus(SB)	
	_g_ := getg()
  0x42c2ec		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	setMNoWB(&_g_.m.curg.m, nil)
  0x42c2f5		488b4830		MOVQ 0x30(AX), CX	
  0x42c2f9		488b91c0000000		MOVQ 0xc0(CX), DX	
  0x42c300		8401			TESTB AL, 0(CX)		
	dropg()
  0x42c302		90			NOPL			
	setMNoWB(&_g_.m.curg.m, nil)
  0x42c303		90			NOPL			
	(*muintptr)(unsafe.Pointer(mp)).set(new)
  0x42c304		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42c305		31c9			XORL CX, CX		
  0x42c307		48894a30		MOVQ CX, 0x30(DX)	
	setGNoWB(&_g_.m.curg, nil)
  0x42c30b		488b4830		MOVQ 0x30(AX), CX	
  0x42c30f		8400			TESTB AL, 0(AX)		
  0x42c311		90			NOPL			
	(*guintptr)(unsafe.Pointer(gp)).set(new)
  0x42c312		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c313		31c0			XORL AX, AX		
  0x42c315		488981c0000000		MOVQ AX, 0xc0(CX)	
	lock(&sched.lock)
  0x42c31c		488d058d590900		LEAQ runtime.sched+16(SB), AX	
  0x42c323		48890424		MOVQ AX, 0(SP)			
  0x42c327		e8b4c3fdff		CALL runtime.lock(SB)		
	if schedEnabled(_g_) {
  0x42c32c		488b442418		MOVQ 0x18(SP), AX		
  0x42c331		48890424		MOVQ AX, 0(SP)			
  0x42c335		e8863e0000		CALL runtime.schedEnabled(SB)	
  0x42c33a		807c240800		CMPB $0x0, 0x8(SP)		
  0x42c33f		0f8429010000		JE 0x42c46e			
		_p_ = pidleget()
  0x42c345		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x42c346		488b059b590900		MOVQ runtime.sched+72(SB), AX	
  0x42c34d		90			NOPL				
	if _p_ != nil {
  0x42c34e		4885c0			TESTQ AX, AX		
  0x42c351		741b			JE 0x42c36e		
		sched.pidle = _p_.link
  0x42c353		488b4810		MOVQ 0x10(AX), CX		
  0x42c357		48890d8a590900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42c35e		b9ffffffff		MOVL $-0x1, CX			
  0x42c363		488d1586590900		LEAQ runtime.sched+80(SB), DX	
  0x42c36a		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ == nil {
  0x42c36e		4889442410		MOVQ AX, 0x10(SP)	
  0x42c373		4885c0			TESTQ AX, AX		
  0x42c376		0f84a8000000		JE 0x42c424		
	} else if atomic.Load(&sched.sysmonwait) != 0 {
  0x42c37c		8b0d265a0900		MOVL runtime.sched+264(SB), CX	
  0x42c382		85c9			TESTL CX, CX			
  0x42c384		7579			JNE 0x42c3ff			
	unlock(&sched.lock)
  0x42c386		488d0523590900		LEAQ runtime.sched+16(SB), AX	
  0x42c38d		48890424		MOVQ AX, 0(SP)			
  0x42c391		e8fac4fdff		CALL runtime.unlock(SB)		
	if _p_ == nil {
  0x42c396		488b442410		MOVQ 0x10(SP), AX	
  0x42c39b		4885c0			TESTQ AX, AX		
	if _p_ != nil {
  0x42c39e		7541			JNE 0x42c3e1		
	if _g_.m.lockedg != 0 {
  0x42c3a0		488b442418		MOVQ 0x18(SP), AX	
  0x42c3a5		488b4030		MOVQ 0x30(AX), AX	
  0x42c3a9		4883b86801000000	CMPQ $0x0, 0x168(AX)	
  0x42c3b1		7514			JNE 0x42c3c7		
	stopm()
  0x42c3b3		e828caffff		CALL runtime.stopm(SB)	
	schedule() // Never returns.
  0x42c3b8		e843e6ffff		CALL runtime.schedule(SB)	
}
  0x42c3bd		488b6c2420		MOVQ 0x20(SP), BP	
  0x42c3c2		4883c428		ADDQ $0x28, SP		
  0x42c3c6		c3			RET			
		stoplockedm()
  0x42c3c7		e8d4d0ffff		CALL runtime.stoplockedm(SB)	
		execute(gp, false) // Never returns.
  0x42c3cc		488b442430		MOVQ 0x30(SP), AX		
  0x42c3d1		48890424		MOVQ AX, 0(SP)			
  0x42c3d5		c644240800		MOVB $0x0, 0x8(SP)		
  0x42c3da		e861d5ffff		CALL runtime.execute(SB)	
  0x42c3df		ebd2			JMP 0x42c3b3			
		acquirep(_p_)
  0x42c3e1		48890424		MOVQ AX, 0(SP)			
  0x42c3e5		e8e6200000		CALL runtime.acquirep(SB)	
		execute(gp, false) // Never returns.
  0x42c3ea		488b442430		MOVQ 0x30(SP), AX		
  0x42c3ef		48890424		MOVQ AX, 0(SP)			
  0x42c3f3		c644240800		MOVB $0x0, 0x8(SP)		
  0x42c3f8		e843d5ffff		CALL runtime.execute(SB)	
  0x42c3fd		eba1			JMP 0x42c3a0			
		atomic.Store(&sched.sysmonwait, 0)
  0x42c3ff		31c0			XORL AX, AX			
  0x42c401		488d0da0590900		LEAQ runtime.sched+264(SB), CX	
  0x42c408		8701			XCHGL AX, 0(CX)			
		notewakeup(&sched.sysmonnote)
  0x42c40a		488d059f590900		LEAQ runtime.sched+272(SB), AX	
  0x42c411		48890424		MOVQ AX, 0(SP)			
  0x42c415		e846c5fdff		CALL runtime.notewakeup(SB)	
	if _p_ == nil {
  0x42c41a		488b442410		MOVQ 0x10(SP), AX	
		notewakeup(&sched.sysmonnote)
  0x42c41f		e962ffffff		JMP 0x42c386		
		globrunqput(gp)
  0x42c424		90			NOPL			
	sched.runq.pushBack(gp)
  0x42c425		90			NOPL			
	gp.schedlink = 0
  0x42c426		488b4c2430		MOVQ 0x30(SP), CX	
  0x42c42b		48c781a000000000000000	MOVQ $0x0, 0xa0(CX)	
	if q.tail != 0 {
  0x42c436		488b15c3580900		MOVQ runtime.sched+96(SB), DX	
  0x42c43d		4885d2			TESTQ DX, DX			
  0x42c440		741f			JE 0x42c461			
		q.tail.ptr().schedlink.set(gp)
  0x42c442		90			NOPL			
  0x42c443		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c444		4889cb			MOVQ CX, BX		
  0x42c447		48898aa0000000		MOVQ CX, 0xa0(DX)	
	q.tail.set(gp)
  0x42c44e		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c44f		48891daa580900		MOVQ BX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42c456		ff05ac580900		INCL runtime.sched+104(SB)	
	unlock(&sched.lock)
  0x42c45c		e925ffffff		JMP 0x42c386		
		q.head.set(gp)
  0x42c461		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42c462		4889cb			MOVQ CX, BX			
  0x42c465		48890d8c580900		MOVQ CX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x42c46c		ebe0			JMP 0x42c44e		
  0x42c46e		31c0			XORL AX, AX		
	if _p_ == nil {
  0x42c470		e9f9feffff		JMP 0x42c36e		
func exitsyscall0(gp *g) {
  0x42c475		e806b40100		CALL runtime.morestack_noctxt(SB)	
  0x42c47a		e921feffff		JMP runtime.exitsyscall0(SB)		

TEXT runtime.malg(SB) /usr/local/go/src/runtime/proc.go
func malg(stacksize int32) *g {
  0x42c480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c489		483b6110		CMPQ 0x10(CX), SP	
  0x42c48d		0f86aa000000		JBE 0x42c53d		
  0x42c493		4883ec38		SUBQ $0x38, SP		
  0x42c497		48896c2430		MOVQ BP, 0x30(SP)	
  0x42c49c		488d6c2430		LEAQ 0x30(SP), BP	
	newg := new(g)
  0x42c4a1		488d0558210400		LEAQ 0x42158(IP), AX		
  0x42c4a8		48890424		MOVQ AX, 0(SP)			
  0x42c4ac		e89fe2fdff		CALL runtime.newobject(SB)	
  0x42c4b1		488b442408		MOVQ 0x8(SP), AX		
	if stacksize >= 0 {
  0x42c4b6		8b4c2440		MOVL 0x40(SP), CX	
  0x42c4ba		85c9			TESTL CX, CX		
  0x42c4bc		7d0f			JGE 0x42c4cd		
	return newg
  0x42c4be		4889442448		MOVQ AX, 0x48(SP)	
  0x42c4c3		488b6c2430		MOVQ 0x30(SP), BP	
  0x42c4c8		4883c438		ADDQ $0x38, SP		
  0x42c4cc		c3			RET			
	newg := new(g)
  0x42c4cd		4889442410		MOVQ AX, 0x10(SP)	
		stacksize = round2(_StackSystem + stacksize)
  0x42c4d2		890c24			MOVL CX, 0(SP)		
  0x42c4d5		e8d6b80000		CALL runtime.round2(SB)	
  0x42c4da		8b442408		MOVL 0x8(SP), AX	
		systemstack(func() {
  0x42c4de		48c744241800000000	MOVQ $0x0, 0x18(SP)		
  0x42c4e7		c744242000000000	MOVL $0x0, 0x20(SP)		
  0x42c4ef		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x42c4f8		488d0d71a80100		LEAQ runtime.malg.func1(SB), CX	
  0x42c4ff		48894c2418		MOVQ CX, 0x18(SP)		
  0x42c504		89442420		MOVL AX, 0x20(SP)		
  0x42c508		488b442410		MOVQ 0x10(SP), AX		
  0x42c50d		4889442428		MOVQ AX, 0x28(SP)		
  0x42c512		488d4c2418		LEAQ 0x18(SP), CX		
  0x42c517		48890c24		MOVQ CX, 0(SP)			
  0x42c51b		e810b20100		CALL runtime.systemstack(SB)	
		newg.stackguard0 = newg.stack.lo + _StackGuard
  0x42c520		488b442410		MOVQ 0x10(SP), AX	
  0x42c525		488b08			MOVQ 0(AX), CX		
  0x42c528		4881c170030000		ADDQ $0x370, CX		
  0x42c52f		48894810		MOVQ CX, 0x10(AX)	
		newg.stackguard1 = ^uintptr(0)
  0x42c533		48c74018ffffffff	MOVQ $-0x1, 0x18(AX)	
  0x42c53b		eb81			JMP 0x42c4be		
func malg(stacksize int32) *g {
  0x42c53d		e83eb30100		CALL runtime.morestack_noctxt(SB)	
  0x42c542		e939ffffff		JMP runtime.malg(SB)			

TEXT runtime.newproc(SB) /usr/local/go/src/runtime/proc.go
func newproc(siz int32, fn *funcval) {
  0x42c550		4883ec40		SUBQ $0x40, SP		
  0x42c554		48896c2438		MOVQ BP, 0x38(SP)	
  0x42c559		488d6c2438		LEAQ 0x38(SP), BP	
	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
  0x42c55e		90			NOPL			
  0x42c55f		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	systemstack(func() {
  0x42c568		0f57c0			XORPS X0, X0				
  0x42c56b		0f11442408		MOVUPS X0, 0x8(SP)			
  0x42c570		0f11442418		MOVUPS X0, 0x18(SP)			
  0x42c575		0f11442428		MOVUPS X0, 0x28(SP)			
  0x42c57a		488d0d4fa80100		LEAQ runtime.newproc.func1(SB), CX	
  0x42c581		48894c2408		MOVQ CX, 0x8(SP)			
  0x42c586		488d4c2450		LEAQ 0x50(SP), CX			
  0x42c58b		48894c2410		MOVQ CX, 0x10(SP)			
  0x42c590		488d4c2458		LEAQ 0x58(SP), CX			
  0x42c595		48894c2418		MOVQ CX, 0x18(SP)			
  0x42c59a		8b4c2448		MOVL 0x48(SP), CX			
  0x42c59e		894c2420		MOVL CX, 0x20(SP)			
  0x42c5a2		4889442428		MOVQ AX, 0x28(SP)			
  0x42c5a7		488b442440		MOVQ 0x40(SP), AX			
  0x42c5ac		4889442430		MOVQ AX, 0x30(SP)			
  0x42c5b1		488d442408		LEAQ 0x8(SP), AX			
  0x42c5b6		48890424		MOVQ AX, 0(SP)				
  0x42c5ba		e871b10100		CALL runtime.systemstack(SB)		
}
  0x42c5bf		488b6c2438		MOVQ 0x38(SP), BP	
  0x42c5c4		4883c440		ADDQ $0x40, SP		
  0x42c5c8		c3			RET			

TEXT runtime.newproc1(SB) /usr/local/go/src/runtime/proc.go
func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {
  0x42c5d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42c5d9		483b6110		CMPQ 0x10(CX), SP	
  0x42c5dd		0f86ed040000		JBE 0x42cad0		
  0x42c5e3		4883ec60		SUBQ $0x60, SP		
  0x42c5e7		48896c2458		MOVQ BP, 0x58(SP)	
  0x42c5ec		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg()
  0x42c5f1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if fn == nil {
  0x42c5fa		488b4c2468		MOVQ 0x68(SP), CX	
  0x42c5ff		4885c9			TESTQ CX, CX		
  0x42c602		0f849f040000		JE 0x42caa7		
	_g_.m.locks++ // disable preemption because it can be holding p in a local var
  0x42c608		488b5030		MOVQ 0x30(AX), DX	
  0x42c60c		ff8208010000		INCL 0x108(DX)		
	siz = (siz + 7) &^ 7
  0x42c612		8b542478		MOVL 0x78(SP), DX	
  0x42c616		8d5a07			LEAL 0x7(DX), BX	
  0x42c619		83e3f8			ANDL $-0x8, BX		
	if siz >= _StackMin-4*sys.RegSize-sys.RegSize {
  0x42c61c		81fbd8070000		CMPL $0x7d8, BX		
  0x42c622		0f8d64040000		JGE 0x42ca8c		
	_g_ := getg()
  0x42c628		4889442448		MOVQ AX, 0x48(SP)	
	siz = (siz + 7) &^ 7
  0x42c62d		895c242c		MOVL BX, 0x2c(SP)	
	_p_ := _g_.m.p.ptr()
  0x42c631		488b4830		MOVQ 0x30(AX), CX	
  0x42c635		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x42c63c		90			NOPL			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42c63d		48894c2450		MOVQ CX, 0x50(SP)	
	newg := gfget(_p_)
  0x42c642		48890c24		MOVQ CX, 0(SP)		
  0x42c646		e855090000		CALL runtime.gfget(SB)	
  0x42c64b		488b442408		MOVQ 0x8(SP), AX	
	if newg == nil {
  0x42c650		4885c0			TESTQ AX, AX		
  0x42c653		0f84b7030000		JE 0x42ca10		
	if newg.stack.hi == 0 {
  0x42c659		4883780800		CMPQ $0x0, 0x8(AX)	
  0x42c65e		0f840d040000		JE 0x42ca71		
	if readgstatus(newg) != _Gdead {
  0x42c664		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42c665		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(newg) != _Gdead {
  0x42c66b		83f906			CMPL $0x6, CX		
  0x42c66e		0f85e2030000		JNE 0x42ca56		
	if newg.stack.hi == 0 {
  0x42c674		4889442440		MOVQ AX, 0x40(SP)	
	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
  0x42c679		8b4c242c		MOVL 0x2c(SP), CX	
  0x42c67d		4863c9			MOVSXD CX, CX		
  0x42c680		4883c120		ADDQ $0x20, CX		
	sp := newg.stack.hi - totalSize
  0x42c684		488b5008		MOVQ 0x8(AX), DX	
  0x42c688		4829ca			SUBQ CX, DX		
  0x42c68b		4889542430		MOVQ DX, 0x30(SP)	
	if narg > 0 {
  0x42c690		8b4c2478		MOVL 0x78(SP), CX	
  0x42c694		85c9			TESTL CX, CX		
  0x42c696		0f8fa9020000		JG 0x42c945		
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
  0x42c69c		488d4838		LEAQ 0x38(AX), CX			
  0x42c6a0		48890c24		MOVQ CX, 0(SP)				
  0x42c6a4		48c744240838000000	MOVQ $0x38, 0x8(SP)			
  0x42c6ad		e80ede0100		CALL runtime.memclrNoHeapPointers(SB)	
	newg.sched.sp = sp
  0x42c6b2		488b442430		MOVQ 0x30(SP), AX	
  0x42c6b7		488b4c2440		MOVQ 0x40(SP), CX	
  0x42c6bc		48894138		MOVQ AX, 0x38(CX)	
	newg.stktopsp = sp
  0x42c6c0		48898180000000		MOVQ AX, 0x80(CX)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42c6c7		488d0582710400		LEAQ 0x47182(IP), AX	
  0x42c6ce		8400			TESTB AL, 0(AX)		
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
  0x42c6d0		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42c6d1		488b0578710400		MOVQ 0x47178(IP), AX	
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
  0x42c6d8		48ffc0			INCQ AX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42c6db		90			NOPL			
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
  0x42c6dc		48894140		MOVQ AX, 0x40(CX)	
	newg.sched.g = guintptr(unsafe.Pointer(newg))
  0x42c6e0		4889c8			MOVQ CX, AX		
  0x42c6e3		48894848		MOVQ CX, 0x48(AX)	
	sp := buf.sp
  0x42c6e7		488b4838		MOVQ 0x38(AX), CX	
	sp -= sys.PtrSize
  0x42c6eb		4883c1f8		ADDQ $-0x8, CX		
	*(*uintptr)(unsafe.Pointer(sp)) = buf.pc
  0x42c6ef		4889ca			MOVQ CX, DX		
	gostartcallfn(&newg.sched, fn)
  0x42c6f2		90			NOPL			
		fn = unsafe.Pointer(fv.fn)
  0x42c6f3		488b5c2468		MOVQ 0x68(SP), BX	
  0x42c6f8		488b33			MOVQ 0(BX), SI		
	gostartcall(gobuf, fn, unsafe.Pointer(fv))
  0x42c6fb		90			NOPL			
	*(*uintptr)(unsafe.Pointer(sp)) = buf.pc
  0x42c6fc		488b7840		MOVQ 0x40(AX), DI	
  0x42c700		488939			MOVQ DI, 0(CX)		
	buf.sp = sp
  0x42c703		48895038		MOVQ DX, 0x38(AX)	
	buf.pc = uintptr(fn)
  0x42c707		48897040		MOVQ SI, 0x40(AX)	
	buf.ctxt = ctxt
  0x42c70b		833d0e070b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42c712		0f8516020000		JNE 0x42c92e				
  0x42c718		48895850		MOVQ BX, 0x50(AX)			
	newg.gopc = callerpc
  0x42c71c		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x42c724		48898818010000		MOVQ CX, 0x118(AX)	
	newg.ancestors = saveAncestors(callergp)
  0x42c72b		488b8c2480000000	MOVQ 0x80(SP), CX			
  0x42c733		48890c24		MOVQ CX, 0(SP)				
  0x42c737		e8a4030000		CALL runtime.saveAncestors(SB)		
  0x42c73c		488b442408		MOVQ 0x8(SP), AX			
  0x42c741		833dd8060b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42c748		0f85ca010000		JNE 0x42c918				
  0x42c74e		488b4c2440		MOVQ 0x40(SP), CX			
  0x42c753		48898120010000		MOVQ AX, 0x120(CX)			
	newg.startpc = fn.fn
  0x42c75a		488b542468		MOVQ 0x68(SP), DX	
  0x42c75f		488b12			MOVQ 0(DX), DX		
  0x42c762		48899128010000		MOVQ DX, 0x128(CX)	
	if _g_.m.curg != nil {
  0x42c769		488b542448		MOVQ 0x48(SP), DX	
  0x42c76e		488b5a30		MOVQ 0x30(DX), BX	
  0x42c772		488b9bc0000000		MOVQ 0xc0(BX), BX	
  0x42c779		4885db			TESTQ BX, BX		
  0x42c77c		741b			JE 0x42c799		
		newg.labels = _g_.m.curg.labels
  0x42c77e		488b8358010000		MOVQ 0x158(BX), AX			
  0x42c785		833d94060b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42c78c		0f8575010000		JNE 0x42c907				
  0x42c792		48898158010000		MOVQ AX, 0x158(CX)			
	if isSystemGoroutine(newg, false) {
  0x42c799		48890c24		MOVQ CX, 0(SP)				
  0x42c79d		c644240800		MOVB $0x0, 0x8(SP)			
  0x42c7a2		e869490100		CALL runtime.isSystemGoroutine(SB)	
  0x42c7a7		807c241000		CMPB $0x0, 0x10(SP)			
  0x42c7ac		7410			JE 0x42c7be				
		atomic.Xadd(&sched.ngsys, +1)
  0x42c7ae		b801000000		MOVL $0x1, AX			
  0x42c7b3		488d0d26550900		LEAQ runtime.sched+64(SB), CX	
  0x42c7ba		f00fc101		LOCK XADDL AX, 0(CX)		
	newg.gcscanvalid = false
  0x42c7be		488b442440		MOVQ 0x40(SP), AX	
  0x42c7c3		c680b500000000		MOVB $0x0, 0xb5(AX)	
	casgstatus(newg, _Gdead, _Grunnable)
  0x42c7ca		48890424		MOVQ AX, 0(SP)			
  0x42c7ce		48b90600000001000000	MOVQ $0x100000006, CX		
  0x42c7d8		48894c2408		MOVQ CX, 0x8(SP)		
  0x42c7dd		e8bea4ffff		CALL runtime.casgstatus(SB)	
	if _p_.goidcache == _p_.goidcacheend {
  0x42c7e2		488b442450		MOVQ 0x50(SP), AX	
  0x42c7e7		488b88d8050000		MOVQ 0x5d8(AX), CX	
  0x42c7ee		483988d0050000		CMPQ CX, 0x5d0(AX)	
  0x42c7f5		7527			JNE 0x42c81e		
		_p_.goidcache = atomic.Xadd64(&sched.goidgen, _GoidCacheBatch)
  0x42c7f7		b910000000		MOVL $0x10, CX			
  0x42c7fc		488d159d540900		LEAQ runtime.sched(SB), DX	
  0x42c803		f0480fc10a		LOCK XADDQ CX, 0(DX)		
		_p_.goidcache -= _GoidCacheBatch - 1
  0x42c808		488d5101		LEAQ 0x1(CX), DX	
  0x42c80c		488990d0050000		MOVQ DX, 0x5d0(AX)	
		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
  0x42c813		4883c111		ADDQ $0x11, CX		
  0x42c817		488988d8050000		MOVQ CX, 0x5d8(AX)	
	newg.goid = int64(_p_.goidcache)
  0x42c81e		488b88d0050000		MOVQ 0x5d0(AX), CX	
  0x42c825		488b542440		MOVQ 0x40(SP), DX	
  0x42c82a		48898a98000000		MOVQ CX, 0x98(DX)	
	_p_.goidcache++
  0x42c831		48ff80d0050000		INCQ 0x5d0(AX)		
	if trace.enabled {
  0x42c838		803d91030a0000		CMPB $0x0, runtime.trace+16(SB)	
  0x42c83f		0f859e000000		JNE 0x42c8e3			
	runqput(_p_, newg, true)
  0x42c845		48890424		MOVQ AX, 0(SP)			
  0x42c849		4889542408		MOVQ DX, 0x8(SP)		
  0x42c84e		c644241001		MOVB $0x1, 0x10(SP)		
  0x42c853		e8f83b0000		CALL runtime.runqput(SB)	
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {
  0x42c858		8b0592540900		MOVL runtime.sched+80(SB), AX		
  0x42c85e		85c0			TESTL AX, AX				
  0x42c860		747d			JE 0x42c8df				
  0x42c862		8b0d8c540900		MOVL runtime.sched+84(SB), CX		
  0x42c868		85c9			TESTL CX, CX				
  0x42c86a		0f94c1			SETE CL					
  0x42c86d		84c9			TESTL CL, CL				
  0x42c86f		7423			JE 0x42c894				
  0x42c871		803d39040b0000		CMPB $0x0, runtime.mainStarted(SB)	
  0x42c878		741a			JE 0x42c894				
		wakep()
  0x42c87a		90			NOPL			
	if !atomic.Cas(&sched.nmspinning, 0, 1) {
  0x42c87b		31c0			XORL AX, AX			
  0x42c87d		488d0d70540900		LEAQ runtime.sched+84(SB), CX	
  0x42c884		ba01000000		MOVL $0x1, DX			
  0x42c889		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x42c88d		0f94c1			SETE CL				
  0x42c890		84c9			TESTL CL, CL			
  0x42c892		7537			JNE 0x42c8cb			
	_g_.m.locks--
  0x42c894		488b442448		MOVQ 0x48(SP), AX	
  0x42c899		488b4830		MOVQ 0x30(AX), CX	
  0x42c89d		ff8908010000		DECL 0x108(CX)		
	if _g_.m.locks == 0 && _g_.preempt { // restore the preemption request in case we've cleared it in newstack
  0x42c8a3		488b4830		MOVQ 0x30(AX), CX	
  0x42c8a7		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x42c8ae		7511			JNE 0x42c8c1		
  0x42c8b0		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x42c8b7		7408			JE 0x42c8c1		
		_g_.stackguard0 = stackPreempt
  0x42c8b9		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x42c8c1		488b6c2458		MOVQ 0x58(SP), BP	
  0x42c8c6		4883c460		ADDQ $0x60, SP		
  0x42c8ca		c3			RET			
	startm(nil, true)
  0x42c8cb		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x42c8d3		c644240801		MOVB $0x1, 0x8(SP)	
  0x42c8d8		e893c6ffff		CALL runtime.startm(SB)	
		wakep()
  0x42c8dd		ebb5			JMP 0x42c894		
  0x42c8df		31c9			XORL CX, CX		
	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && mainStarted {
  0x42c8e1		eb8a			JMP 0x42c86d		
		traceGoCreate(newg, newg.startpc)
  0x42c8e3		488b8228010000		MOVQ 0x128(DX), AX		
  0x42c8ea		48891424		MOVQ DX, 0(SP)			
  0x42c8ee		4889442408		MOVQ AX, 0x8(SP)		
  0x42c8f3		e898050100		CALL runtime.traceGoCreate(SB)	
	runqput(_p_, newg, true)
  0x42c8f8		488b442450		MOVQ 0x50(SP), AX	
  0x42c8fd		488b542440		MOVQ 0x40(SP), DX	
		traceGoCreate(newg, newg.startpc)
  0x42c902		e93effffff		JMP 0x42c845		
		newg.labels = _g_.m.curg.labels
  0x42c907		488db958010000		LEAQ 0x158(CX), DI		
  0x42c90e		e86dcd0100		CALL runtime.gcWriteBarrier(SB)	
  0x42c913		e981feffff		JMP 0x42c799			
	newg.ancestors = saveAncestors(callergp)
  0x42c918		488b4c2440		MOVQ 0x40(SP), CX		
  0x42c91d		488db920010000		LEAQ 0x120(CX), DI		
  0x42c924		e857cd0100		CALL runtime.gcWriteBarrier(SB)	
  0x42c929		e92cfeffff		JMP 0x42c75a			
	buf.ctxt = ctxt
  0x42c92e		488d7850		LEAQ 0x50(AX), DI	
	if newg.stack.hi == 0 {
  0x42c932		4889c1			MOVQ AX, CX		
	buf.ctxt = ctxt
  0x42c935		4889d8			MOVQ BX, AX			
  0x42c938		e843cd0100		CALL runtime.gcWriteBarrier(SB)	
	newg.gopc = callerpc
  0x42c93d		4889c8			MOVQ CX, AX		
	buf.ctxt = ctxt
  0x42c940		e9d7fdffff		JMP 0x42c71c		
		memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))
  0x42c945		48891424		MOVQ DX, 0(SP)			
  0x42c949		488b542470		MOVQ 0x70(SP), DX		
  0x42c94e		4889542408		MOVQ DX, 0x8(SP)		
  0x42c953		4863c9			MOVSXD CX, CX			
  0x42c956		48894c2410		MOVQ CX, 0x10(SP)		
  0x42c95b		e8f0dd0100		CALL runtime.memmove(SB)	
		if writeBarrier.needed && !_g_.m.curg.gcscandone {
  0x42c960		803dbd040b0000		CMPB $0x0, runtime.writeBarrier+4(SB)	
  0x42c967		0f8499000000		JE 0x42ca06				
  0x42c96d		488b442448		MOVQ 0x48(SP), AX			
  0x42c972		488b4830		MOVQ 0x30(AX), CX			
  0x42c976		488b89c0000000		MOVQ 0xc0(CX), CX			
  0x42c97d		80b9b400000000		CMPB $0x0, 0xb4(CX)			
  0x42c984		740a			JE 0x42c990				
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
  0x42c986		488b442440		MOVQ 0x40(SP), AX	
  0x42c98b		e90cfdffff		JMP 0x42c69c		
			f := findfunc(fn.fn)
  0x42c990		488b442468		MOVQ 0x68(SP), AX		
  0x42c995		488b08			MOVQ 0(AX), CX			
  0x42c998		48890c24		MOVQ CX, 0(SP)			
  0x42c99c		e85fe10000		CALL runtime.findfunc(SB)	
  0x42c9a1		488b442408		MOVQ 0x8(SP), AX		
  0x42c9a6		488b4c2410		MOVQ 0x10(SP), CX		
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x42c9ab		48890424		MOVQ AX, 0(SP)			
  0x42c9af		48894c2408		MOVQ CX, 0x8(SP)		
  0x42c9b4		c644241000		MOVB $0x0, 0x10(SP)		
  0x42c9b9		e852ee0000		CALL runtime.funcdata(SB)	
  0x42c9be		488b442418		MOVQ 0x18(SP), AX		
			if stkmap.nbit > 0 {
  0x42c9c3		8b4804			MOVL 0x4(AX), CX	
  0x42c9c6		85c9			TESTL CX, CX		
  0x42c9c8		7f07			JG 0x42c9d1		
	if _g_.m.curg != nil {
  0x42c9ca		488b442448		MOVQ 0x48(SP), AX	
	memclrNoHeapPointers(unsafe.Pointer(&newg.sched), unsafe.Sizeof(newg.sched))
  0x42c9cf		ebb5			JMP 0x42c986		
				bv := stackmapdata(stkmap, 0)
  0x42c9d1		90			NOPL			
	return bitvector{stkmap.nbit, addb(&stkmap.bytedata[0], uintptr(n*((stkmap.nbit+7)>>3)))}
  0x42c9d2		90			NOPL			
				bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)
  0x42c9d3		488b542430		MOVQ 0x30(SP), DX	
  0x42c9d8		48891424		MOVQ DX, 0(SP)		
  0x42c9dc		4889542408		MOVQ DX, 0x8(SP)	
  0x42c9e1		4863c9			MOVSXD CX, CX		
  0x42c9e4		48c1e103		SHLQ $0x3, CX		
  0x42c9e8		48894c2410		MOVQ CX, 0x10(SP)	
  0x42c9ed		48c744241800000000	MOVQ $0x0, 0x18(SP)	
	return bitvector{stkmap.nbit, addb(&stkmap.bytedata[0], uintptr(n*((stkmap.nbit+7)>>3)))}
  0x42c9f6		4883c008		ADDQ $0x8, AX		
				bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)
  0x42c9fa		4889442420		MOVQ AX, 0x20(SP)			
  0x42c9ff		e81c1efeff		CALL runtime.bulkBarrierBitmap(SB)	
  0x42ca04		ebc4			JMP 0x42c9ca				
	if _g_.m.curg != nil {
  0x42ca06		488b442448		MOVQ 0x48(SP), AX	
		if writeBarrier.needed && !_g_.m.curg.gcscandone {
  0x42ca0b		e976ffffff		JMP 0x42c986		
		newg = malg(_StackMin)
  0x42ca10		c7042400080000		MOVL $0x800, 0(SP)	
  0x42ca17		e864faffff		CALL runtime.malg(SB)	
  0x42ca1c		488b442408		MOVQ 0x8(SP), AX	
  0x42ca21		4889442438		MOVQ AX, 0x38(SP)	
		casgstatus(newg, _Gidle, _Gdead)
  0x42ca26		48890424		MOVQ AX, 0(SP)			
  0x42ca2a		48b90000000006000000	MOVQ $0x600000000, CX		
  0x42ca34		48894c2408		MOVQ CX, 0x8(SP)		
  0x42ca39		e862a2ffff		CALL runtime.casgstatus(SB)	
		allgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.
  0x42ca3e		488b442438		MOVQ 0x38(SP), AX		
  0x42ca43		48890424		MOVQ AX, 0(SP)			
  0x42ca47		e89491ffff		CALL runtime.allgadd(SB)	
	if newg.stack.hi == 0 {
  0x42ca4c		488b442438		MOVQ 0x38(SP), AX	
		allgadd(newg) // publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.
  0x42ca51		e903fcffff		JMP 0x42c659		
		throw("newproc1: new g is not Gdead")
  0x42ca56		488d05014d0400		LEAQ 0x44d01(IP), AX	
  0x42ca5d		48890424		MOVQ AX, 0(SP)		
  0x42ca61		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42ca6a		e8116affff		CALL runtime.throw(SB)	
  0x42ca6f		0f0b			UD2			
		throw("newproc1: newg missing stack")
  0x42ca71		488d05024d0400		LEAQ 0x44d02(IP), AX	
  0x42ca78		48890424		MOVQ AX, 0(SP)		
  0x42ca7c		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x42ca85		e8f669ffff		CALL runtime.throw(SB)	
  0x42ca8a		0f0b			UD2			
		throw("newproc: function arguments too large for new goroutine")
  0x42ca8c		488d0586690400		LEAQ 0x46986(IP), AX	
  0x42ca93		48890424		MOVQ AX, 0(SP)		
  0x42ca97		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x42caa0		e8db69ffff		CALL runtime.throw(SB)	
  0x42caa5		0f0b			UD2			
		_g_.m.throwing = -1 // do not dump full stacks
  0x42caa7		488b4030		MOVQ 0x30(AX), AX	
  0x42caab		c780f4000000ffffffff	MOVL $-0x1, 0xf4(AX)	
		throw("go of nil func value")
  0x42cab5		488d05b53b0400		LEAQ 0x43bb5(IP), AX	
  0x42cabc		48890424		MOVQ AX, 0(SP)		
  0x42cac0		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x42cac9		e8b269ffff		CALL runtime.throw(SB)	
  0x42cace		0f0b			UD2			
func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {
  0x42cad0		e8abad0100		CALL runtime.morestack_noctxt(SB)	
  0x42cad5		e9f6faffff		JMP runtime.newproc1(SB)		

TEXT runtime.saveAncestors(SB) /usr/local/go/src/runtime/proc.go
func saveAncestors(callergp *g) *[]ancestorInfo {
  0x42cae0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42cae9		488d8424b8fcffff	LEAQ 0xfffffcb8(SP), AX	
  0x42caf1		483b4110		CMPQ 0x10(CX), AX	
  0x42caf5		0f861c030000		JBE 0x42ce17		
  0x42cafb		4881ecc8030000		SUBQ $0x3c8, SP		
  0x42cb02		4889ac24c0030000	MOVQ BP, 0x3c0(SP)	
  0x42cb0a		488dac24c0030000	LEAQ 0x3c0(SP), BP	
	if debug.tracebackancestors <= 0 || callergp.goid == 0 {
  0x42cb12		8b0504040b00		MOVL runtime.debug+60(SB), AX	
  0x42cb18		85c0			TESTL AX, AX			
  0x42cb1a		7f1c			JG 0x42cb38			
		return nil
  0x42cb1c		48c78424d803000000000000	MOVQ $0x0, 0x3d8(SP)	
  0x42cb28		488bac24c0030000		MOVQ 0x3c0(SP), BP	
  0x42cb30		4881c4c8030000			ADDQ $0x3c8, SP		
  0x42cb37		c3				RET			
	if debug.tracebackancestors <= 0 || callergp.goid == 0 {
  0x42cb38		488b8c24d0030000	MOVQ 0x3d0(SP), CX	
  0x42cb40		4883b99800000000	CMPQ $0x0, 0x98(CX)	
  0x42cb48		74d2			JE 0x42cb1c		
	if callergp.ancestors != nil {
  0x42cb4a		488b9120010000		MOVQ 0x120(CX), DX	
  0x42cb51		4885d2			TESTQ DX, DX		
  0x42cb54		0f84ab020000		JE 0x42ce05		
		callerAncestors = *callergp.ancestors
  0x42cb5a		488b5a08		MOVQ 0x8(DX), BX	
  0x42cb5e		488b32			MOVQ 0(DX), SI		
  0x42cb61		488b5210		MOVQ 0x10(DX), DX	
	n := int32(len(callerAncestors)) + 1
  0x42cb65		48895c2448		MOVQ BX, 0x48(SP)	
  0x42cb6a		4889b42490030000	MOVQ SI, 0x390(SP)	
  0x42cb72		4889542450		MOVQ DX, 0x50(SP)	
	ancestors := make([]ancestorInfo, n)
  0x42cb77		488d0d027d0300		LEAQ 0x37d02(IP), CX	
  0x42cb7e		48890c24		MOVQ CX, 0(SP)		
	n := int32(len(callerAncestors)) + 1
  0x42cb82		8d7b01			LEAL 0x1(BX), DI	
	if n > debug.tracebackancestors {
  0x42cb85		39c7			CMPL AX, DI		
	ancestors := make([]ancestorInfo, n)
  0x42cb87		0f4ff8			CMOVG AX, DI			
  0x42cb8a		4863c7			MOVSXD DI, AX			
  0x42cb8d		4889442458		MOVQ AX, 0x58(SP)		
  0x42cb92		4889442408		MOVQ AX, 0x8(SP)		
  0x42cb97		4889442410		MOVQ AX, 0x10(SP)		
  0x42cb9c		e8df900000		CALL runtime.makeslice(SB)	
  0x42cba1		488b442418		MOVQ 0x18(SP), AX		
	copy(ancestors[1:], callerAncestors)
  0x42cba6		488b4c2458		MOVQ 0x58(SP), CX	
  0x42cbab		4883f901		CMPQ $0x1, CX		
	if n > debug.tracebackancestors {
  0x42cbaf		0f825b020000		JB 0x42ce10		
	ancestors := make([]ancestorInfo, n)
  0x42cbb5		4889842488030000	MOVQ AX, 0x388(SP)	
	copy(ancestors[1:], callerAncestors)
  0x42cbbd		488d15bc7c0300		LEAQ 0x37cbc(IP), DX		
  0x42cbc4		48891424		MOVQ DX, 0(SP)			
  0x42cbc8		488d51ff		LEAQ -0x1(CX), DX		
  0x42cbcc		4889d3			MOVQ DX, BX			
  0x42cbcf		48f7da			NEGQ DX				
  0x42cbd2		48c1fa3f		SARQ $0x3f, DX			
  0x42cbd6		4883e228		ANDQ $0x28, DX			
  0x42cbda		4801c2			ADDQ AX, DX			
  0x42cbdd		4889542408		MOVQ DX, 0x8(SP)		
  0x42cbe2		48895c2410		MOVQ BX, 0x10(SP)		
  0x42cbe7		48895c2418		MOVQ BX, 0x18(SP)		
  0x42cbec		488b942490030000	MOVQ 0x390(SP), DX		
  0x42cbf4		4889542420		MOVQ DX, 0x20(SP)		
  0x42cbf9		488b542448		MOVQ 0x48(SP), DX		
  0x42cbfe		4889542428		MOVQ DX, 0x28(SP)		
  0x42cc03		488b542450		MOVQ 0x50(SP), DX		
  0x42cc08		4889542430		MOVQ DX, 0x30(SP)		
  0x42cc0d		e8ee0afeff		CALL runtime.typedslicecopy(SB)	
	var pcs [_TracebackMaxFrames]uintptr
  0x42cc12		488d7c2460		LEAQ 0x60(SP), DI	
  0x42cc17		0f57c0			XORPS X0, X0		
  0x42cc1a		488d7fe0		LEAQ -0x20(DI), DI	
  0x42cc1e		48896c24f0		MOVQ BP, -0x10(SP)	
  0x42cc23		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42cc28		e803d40100		CALL 0x44a030		
  0x42cc2d		488b6d00		MOVQ 0(BP), BP		
	npcs := gcallers(callergp, 0, pcs[:])
  0x42cc31		488b8424d0030000	MOVQ 0x3d0(SP), AX		
  0x42cc39		48890424		MOVQ AX, 0(SP)			
  0x42cc3d		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42cc46		488d4c2460		LEAQ 0x60(SP), CX		
  0x42cc4b		48894c2410		MOVQ CX, 0x10(SP)		
  0x42cc50		48c744241864000000	MOVQ $0x64, 0x18(SP)		
  0x42cc59		48c744242064000000	MOVQ $0x64, 0x20(SP)		
  0x42cc62		e8a9390100		CALL runtime.gcallers(SB)	
  0x42cc67		488b442428		MOVQ 0x28(SP), AX		
  0x42cc6c		4889442440		MOVQ AX, 0x40(SP)		
	ipcs := make([]uintptr, npcs)
  0x42cc71		488d0dc8e60200		LEAQ 0x2e6c8(IP), CX		
  0x42cc78		48890c24		MOVQ CX, 0(SP)			
  0x42cc7c		4889442408		MOVQ AX, 0x8(SP)		
  0x42cc81		4889442410		MOVQ AX, 0x10(SP)		
  0x42cc86		e8f58f0000		CALL runtime.makeslice(SB)	
	copy(ipcs, pcs[:])
  0x42cc8b		488b442440		MOVQ 0x40(SP), AX	
  0x42cc90		4883f864		CMPQ $0x64, AX		
  0x42cc94		b964000000		MOVL $0x64, CX		
  0x42cc99		4889c2			MOVQ AX, DX		
  0x42cc9c		480f4fc1		CMOVG CX, AX		
	ipcs := make([]uintptr, npcs)
  0x42cca0		488b4c2418		MOVQ 0x18(SP), CX	
	copy(ipcs, pcs[:])
  0x42cca5		488d5c2460		LEAQ 0x60(SP), BX	
  0x42ccaa		4839d9			CMPQ BX, CX		
  0x42ccad		0f8521010000		JNE 0x42cdd4		
	ancestors[0] = ancestorInfo{
  0x42ccb3		48c784249803000000000000	MOVQ $0x0, 0x398(SP)	
  0x42ccbf		0f57c0				XORPS X0, X0		
  0x42ccc2		0f118424a0030000		MOVUPS X0, 0x3a0(SP)	
  0x42ccca		0f118424b0030000		MOVUPS X0, 0x3b0(SP)	
  0x42ccd2		48898c2498030000		MOVQ CX, 0x398(SP)	
  0x42ccda		48899424a0030000		MOVQ DX, 0x3a0(SP)	
  0x42cce2		48899424a8030000		MOVQ DX, 0x3a8(SP)	
		goid: callergp.goid,
  0x42ccea		488b8424d0030000	MOVQ 0x3d0(SP), AX	
  0x42ccf2		488b8898000000		MOVQ 0x98(AX), CX	
  0x42ccf9		48898c24b0030000	MOVQ CX, 0x3b0(SP)	
		gopc: callergp.gopc,
  0x42cd01		488b8018010000		MOVQ 0x118(AX), AX	
  0x42cd08		48898424b8030000	MOVQ AX, 0x3b8(SP)	
	ancestors[0] = ancestorInfo{
  0x42cd10		833d09010b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42cd17		0f8588000000		JNE 0x42cda5				
  0x42cd1d		488b842498030000	MOVQ 0x398(SP), AX			
  0x42cd25		488b8c2488030000	MOVQ 0x388(SP), CX			
  0x42cd2d		488901			MOVQ AX, 0(CX)				
  0x42cd30		0f108424a0030000	MOVUPS 0x3a0(SP), X0			
  0x42cd38		0f114108		MOVUPS X0, 0x8(CX)			
  0x42cd3c		0f108424b0030000	MOVUPS 0x3b0(SP), X0			
  0x42cd44		0f114118		MOVUPS X0, 0x18(CX)			
	ancestorsp := new([]ancestorInfo)
  0x42cd48		488d0551cd0200		LEAQ 0x2cd51(IP), AX		
  0x42cd4f		48890424		MOVQ AX, 0(SP)			
  0x42cd53		e8f8d9fdff		CALL runtime.newobject(SB)	
  0x42cd58		488b7c2408		MOVQ 0x8(SP), DI		
	*ancestorsp = ancestors
  0x42cd5d		488b442458		MOVQ 0x58(SP), AX			
  0x42cd62		48894708		MOVQ AX, 0x8(DI)			
  0x42cd66		48894710		MOVQ AX, 0x10(DI)			
  0x42cd6a		833daf000b0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42cd71		7523			JNE 0x42cd96				
  0x42cd73		488b842488030000	MOVQ 0x388(SP), AX			
  0x42cd7b		488907			MOVQ AX, 0(DI)				
	return ancestorsp
  0x42cd7e		4889bc24d8030000	MOVQ DI, 0x3d8(SP)	
  0x42cd86		488bac24c0030000	MOVQ 0x3c0(SP), BP	
  0x42cd8e		4881c4c8030000		ADDQ $0x3c8, SP		
  0x42cd95		c3			RET			
	*ancestorsp = ancestors
  0x42cd96		488b842488030000	MOVQ 0x388(SP), AX		
  0x42cd9e		e8ddc80100		CALL runtime.gcWriteBarrier(SB)	
  0x42cda3		ebd9			JMP 0x42cd7e			
	ancestors[0] = ancestorInfo{
  0x42cda5		488d05d47a0300		LEAQ 0x37ad4(IP), AX		
  0x42cdac		48890424		MOVQ AX, 0(SP)			
  0x42cdb0		488b842488030000	MOVQ 0x388(SP), AX		
  0x42cdb8		4889442408		MOVQ AX, 0x8(SP)		
  0x42cdbd		488d8c2498030000	LEAQ 0x398(SP), CX		
  0x42cdc5		48894c2410		MOVQ CX, 0x10(SP)		
  0x42cdca		e8c107feff		CALL runtime.typedmemmove(SB)	
  0x42cdcf		e974ffffff		JMP 0x42cd48			
	ipcs := make([]uintptr, npcs)
  0x42cdd4		48898c2480030000	MOVQ CX, 0x380(SP)	
	copy(ipcs, pcs[:])
  0x42cddc		48890c24		MOVQ CX, 0(SP)			
  0x42cde0		48895c2408		MOVQ BX, 0x8(SP)		
  0x42cde5		48c1e003		SHLQ $0x3, AX			
  0x42cde9		4889442410		MOVQ AX, 0x10(SP)		
  0x42cdee		e85dd90100		CALL runtime.memmove(SB)	
	ancestors[0] = ancestorInfo{
  0x42cdf3		488b8c2480030000	MOVQ 0x380(SP), CX	
  0x42cdfb		488b542440		MOVQ 0x40(SP), DX	
	copy(ipcs, pcs[:])
  0x42ce00		e9aefeffff		JMP 0x42ccb3		
  0x42ce05		31db			XORL BX, BX		
  0x42ce07		31f6			XORL SI, SI		
  0x42ce09		31d2			XORL DX, DX		
	if callergp.ancestors != nil {
  0x42ce0b		e955fdffff		JMP 0x42cb65		
	copy(ancestors[1:], callerAncestors)
  0x42ce10		e83b52ffff		CALL runtime.panicslice(SB)	
  0x42ce15		0f0b			UD2				
func saveAncestors(callergp *g) *[]ancestorInfo {
  0x42ce17		e864aa0100		CALL runtime.morestack_noctxt(SB)	
  0x42ce1c		e9bffcffff		JMP runtime.saveAncestors(SB)		

TEXT runtime.gfput(SB) /usr/local/go/src/runtime/proc.go
func gfput(_p_ *p, gp *g) {
  0x42ce30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42ce39		483b6110		CMPQ 0x10(CX), SP	
  0x42ce3d		0f864f010000		JBE 0x42cf92		
  0x42ce43		4883ec18		SUBQ $0x18, SP		
  0x42ce47		48896c2410		MOVQ BP, 0x10(SP)	
  0x42ce4c		488d6c2410		LEAQ 0x10(SP), BP	
	if readgstatus(gp) != _Gdead {
  0x42ce51		90			NOPL			
  0x42ce52		488b442428		MOVQ 0x28(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x42ce57		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp) != _Gdead {
  0x42ce5d		83f906			CMPL $0x6, CX		
  0x42ce60		0f8511010000		JNE 0x42cf77		
	stksize := gp.stack.hi - gp.stack.lo
  0x42ce66		488b4808		MOVQ 0x8(AX), CX	
  0x42ce6a		488b10			MOVQ 0(AX), DX		
  0x42ce6d		4889cb			MOVQ CX, BX		
  0x42ce70		4829d1			SUBQ DX, CX		
	if stksize != _FixedStack {
  0x42ce73		4881f900080000		CMPQ $0x800, CX		
  0x42ce7a		0f85d1000000		JNE 0x42cf51		
	_p_.gFree.push(gp)
  0x42ce80		90			NOPL			
	gp.schedlink = l.head
  0x42ce81		488b4c2420		MOVQ 0x20(SP), CX	
  0x42ce86		488b91f00d0000		MOVQ 0xdf0(CX), DX	
  0x42ce8d		488990a0000000		MOVQ DX, 0xa0(AX)	
	l.head.set(gp)
  0x42ce94		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42ce95		488981f00d0000		MOVQ AX, 0xdf0(CX)	
	_p_.gFree.n++
  0x42ce9c		8b81f80d0000		MOVL 0xdf8(CX), AX	
  0x42cea2		ffc0			INCL AX			
  0x42cea4		8981f80d0000		MOVL AX, 0xdf8(CX)	
	if _p_.gFree.n >= 64 {
  0x42ceaa		83f840			CMPL $0x40, AX		
  0x42cead		0f8c94000000		JL 0x42cf47		
		lock(&sched.gFree.lock)
  0x42ceb3		488d05764e0900		LEAQ runtime.sched+144(SB), AX	
  0x42ceba		48890424		MOVQ AX, 0(SP)			
  0x42cebe		e81db8fdff		CALL runtime.lock(SB)		
		for _p_.gFree.n >= 32 {
  0x42cec3		488b442420		MOVQ 0x20(SP), AX	
  0x42cec8		eb06			JMP 0x42ced0		
			sched.gFree.n++
  0x42ceca		ff05784e0900		INCL runtime.sched+168(SB)	
		for _p_.gFree.n >= 32 {
  0x42ced0		8b88f80d0000		MOVL 0xdf8(AX), CX	
  0x42ced6		83f920			CMPL $0x20, CX		
  0x42ced9		7c5c			JL 0x42cf37		
			_p_.gFree.n--
  0x42cedb		ffc9			DECL CX			
  0x42cedd		8988f80d0000		MOVL CX, 0xdf8(AX)	
			gp = _p_.gFree.pop()
  0x42cee3		90			NOPL			
	gp := l.head.ptr()
  0x42cee4		488b88f00d0000		MOVQ 0xdf0(AX), CX	
  0x42ceeb		90			NOPL			
	if gp != nil {
  0x42ceec		4885c9			TESTQ CX, CX		
  0x42ceef		740e			JE 0x42ceff		
		l.head = gp.schedlink
  0x42cef1		488b91a0000000		MOVQ 0xa0(CX), DX	
  0x42cef8		488990f00d0000		MOVQ DX, 0xdf0(AX)	
			if gp.stack.lo == 0 {
  0x42ceff		48833900		CMPQ $0x0, 0(CX)	
  0x42cf03		7519			JNE 0x42cf1e		
				sched.gFree.noStack.push(gp)
  0x42cf05		90			NOPL			
	gp.schedlink = l.head
  0x42cf06		488b15334e0900		MOVQ runtime.sched+160(SB), DX	
  0x42cf0d		488991a0000000		MOVQ DX, 0xa0(CX)		
	l.head.set(gp)
  0x42cf14		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42cf15		48890d244e0900		MOVQ CX, runtime.sched+160(SB)	
			sched.gFree.n++
  0x42cf1c		ebac			JMP 0x42ceca		
				sched.gFree.stack.push(gp)
  0x42cf1e		90			NOPL			
	gp.schedlink = l.head
  0x42cf1f		488b15124e0900		MOVQ runtime.sched+152(SB), DX	
  0x42cf26		488991a0000000		MOVQ DX, 0xa0(CX)		
	l.head.set(gp)
  0x42cf2d		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42cf2e		48890d034e0900		MOVQ CX, runtime.sched+152(SB)	
			sched.gFree.n++
  0x42cf35		eb93			JMP 0x42ceca		
		unlock(&sched.gFree.lock)
  0x42cf37		488d05f24d0900		LEAQ runtime.sched+144(SB), AX	
  0x42cf3e		48890424		MOVQ AX, 0(SP)			
  0x42cf42		e849b9fdff		CALL runtime.unlock(SB)		
  0x42cf47		488b6c2410		MOVQ 0x10(SP), BP		
  0x42cf4c		4883c418		ADDQ $0x18, SP			
  0x42cf50		c3			RET				
		stackfree(gp.stack)
  0x42cf51		48891424		MOVQ DX, 0(SP)			
  0x42cf55		48895c2408		MOVQ BX, 0x8(SP)		
  0x42cf5a		e8619e0000		CALL runtime.stackfree(SB)	
		gp.stack.hi = 0
  0x42cf5f		0f57c0			XORPS X0, X0		
  0x42cf62		488b442428		MOVQ 0x28(SP), AX	
  0x42cf67		0f1100			MOVUPS X0, 0(AX)	
		gp.stackguard0 = 0
  0x42cf6a		48c7401000000000	MOVQ $0x0, 0x10(AX)	
  0x42cf72		e909ffffff		JMP 0x42ce80		
		throw("gfput: bad status (not Gdead)")
  0x42cf77		488d0551490400		LEAQ 0x44951(IP), AX	
  0x42cf7e		48890424		MOVQ AX, 0(SP)		
  0x42cf82		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x42cf8b		e8f064ffff		CALL runtime.throw(SB)	
  0x42cf90		0f0b			UD2			
func gfput(_p_ *p, gp *g) {
  0x42cf92		e8e9a80100		CALL runtime.morestack_noctxt(SB)	
  0x42cf97		e994feffff		JMP runtime.gfput(SB)			

TEXT runtime.gfget(SB) /usr/local/go/src/runtime/proc.go
func gfget(_p_ *p) *g {
  0x42cfa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42cfa9		483b6110		CMPQ 0x10(CX), SP	
  0x42cfad		0f8667010000		JBE 0x42d11a		
  0x42cfb3		4883ec28		SUBQ $0x28, SP		
  0x42cfb7		48896c2420		MOVQ BP, 0x20(SP)	
  0x42cfbc		488d6c2420		LEAQ 0x20(SP), BP	
retry:
  0x42cfc1		488b442430		MOVQ 0x30(SP), AX	
  0x42cfc6		eb7d			JMP 0x42d045		
			sched.gFree.n--
  0x42cfc8		ff0d7a4d0900		DECL runtime.sched+168(SB)	
			_p_.gFree.push(gp)
  0x42cfce		90			NOPL			
	gp.schedlink = l.head
  0x42cfcf		488b90f00d0000		MOVQ 0xdf0(AX), DX	
  0x42cfd6		488991a0000000		MOVQ DX, 0xa0(CX)	
	l.head.set(gp)
  0x42cfdd		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42cfde		488988f00d0000		MOVQ CX, 0xdf0(AX)	
			_p_.gFree.n++
  0x42cfe5		ff80f80d0000		INCL 0xdf8(AX)		
		for _p_.gFree.n < 32 {
  0x42cfeb		83b8f80d000020		CMPL $0x20, 0xdf8(AX)	
  0x42cff2		7d3c			JGE 0x42d030		
			gp := sched.gFree.stack.pop()
  0x42cff4		90			NOPL			
	gp := l.head.ptr()
  0x42cff5		488b0d3c4d0900		MOVQ runtime.sched+152(SB), CX	
  0x42cffc		90			NOPL				
	if gp != nil {
  0x42cffd		4885c9			TESTQ CX, CX		
  0x42d000		740e			JE 0x42d010		
		l.head = gp.schedlink
  0x42d002		488b91a0000000		MOVQ 0xa0(CX), DX		
  0x42d009		488915284d0900		MOVQ DX, runtime.sched+152(SB)	
			if gp == nil {
  0x42d010		75b6			JNE 0x42cfc8		
				gp = sched.gFree.noStack.pop()
  0x42d012		90			NOPL			
	gp := l.head.ptr()
  0x42d013		488b0d264d0900		MOVQ runtime.sched+160(SB), CX	
  0x42d01a		90			NOPL				
	if gp != nil {
  0x42d01b		4885c9			TESTQ CX, CX		
  0x42d01e		740e			JE 0x42d02e		
		l.head = gp.schedlink
  0x42d020		488b91a0000000		MOVQ 0xa0(CX), DX		
  0x42d027		488915124d0900		MOVQ DX, runtime.sched+160(SB)	
				if gp == nil {
  0x42d02e		7598			JNE 0x42cfc8		
		unlock(&sched.gFree.lock)
  0x42d030		488d05f94c0900		LEAQ runtime.sched+144(SB), AX	
  0x42d037		48890424		MOVQ AX, 0(SP)			
  0x42d03b		e850b8fdff		CALL runtime.unlock(SB)		
		goto retry
  0x42d040		488b442430		MOVQ 0x30(SP), AX	
	if _p_.gFree.empty() && (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
  0x42d045		90			NOPL			
	return l.head == 0
  0x42d046		488b88f00d0000		MOVQ 0xdf0(AX), CX	
  0x42d04d		4885c9			TESTQ CX, CX		
	if _p_.gFree.empty() && (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
  0x42d050		7539			JNE 0x42d08b		
  0x42d052		90			NOPL			
	return l.head == 0
  0x42d053		48833ddd4c090000	CMPQ $0x0, runtime.sched+152(SB)	
	if _p_.gFree.empty() && (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
  0x42d05b		0f85af000000		JNE 0x42d110		
	return l.head == 0
  0x42d061		48833dd74c090000	CMPQ $0x0, runtime.sched+160(SB)	
	if _p_.gFree.empty() && (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
  0x42d069		0f95c2			SETNE DL		
  0x42d06c		90			NOPL			
  0x42d06d		84d2			TESTL DL, DL		
  0x42d06f		741a			JE 0x42d08b		
		lock(&sched.gFree.lock)
  0x42d071		488d05b84c0900		LEAQ runtime.sched+144(SB), AX	
  0x42d078		48890424		MOVQ AX, 0(SP)			
  0x42d07c		e85fb6fdff		CALL runtime.lock(SB)		
		for _p_.gFree.n < 32 {
  0x42d081		488b442430		MOVQ 0x30(SP), AX	
  0x42d086		e960ffffff		JMP 0x42cfeb		
	gp := _p_.gFree.pop()
  0x42d08b		90			NOPL			
	gp := l.head.ptr()
  0x42d08c		90			NOPL			
	if gp != nil {
  0x42d08d		4885c9			TESTQ CX, CX		
  0x42d090		740e			JE 0x42d0a0		
		l.head = gp.schedlink
  0x42d092		488b91a0000000		MOVQ 0xa0(CX), DX	
  0x42d099		488990f00d0000		MOVQ DX, 0xdf0(AX)	
	if gp == nil {
  0x42d0a0		745b			JE 0x42d0fd		
	_p_.gFree.n--
  0x42d0a2		ff88f80d0000		DECL 0xdf8(AX)		
	if gp.stack.lo == 0 {
  0x42d0a8		48833900		CMPQ $0x0, 0(CX)	
  0x42d0ac		740f			JE 0x42d0bd		
	return gp
  0x42d0ae		48894c2438		MOVQ CX, 0x38(SP)	
  0x42d0b3		488b6c2420		MOVQ 0x20(SP), BP	
  0x42d0b8		4883c428		ADDQ $0x28, SP		
  0x42d0bc		c3			RET			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42d0bd		48894c2408		MOVQ CX, 0x8(SP)	
		systemstack(func() {
  0x42d0c2		0f57c0			XORPS X0, X0				
  0x42d0c5		0f11442410		MOVUPS X0, 0x10(SP)			
  0x42d0ca		488d055f9d0100		LEAQ runtime.gfget.func1(SB), AX	
  0x42d0d1		4889442410		MOVQ AX, 0x10(SP)			
  0x42d0d6		48894c2418		MOVQ CX, 0x18(SP)			
  0x42d0db		488d442410		LEAQ 0x10(SP), AX			
  0x42d0e0		48890424		MOVQ AX, 0(SP)				
  0x42d0e4		e847a60100		CALL runtime.systemstack(SB)		
		gp.stackguard0 = gp.stack.lo + _StackGuard
  0x42d0e9		488b4c2408		MOVQ 0x8(SP), CX	
  0x42d0ee		488b01			MOVQ 0(CX), AX		
  0x42d0f1		480570030000		ADDQ $0x370, AX		
  0x42d0f7		48894110		MOVQ AX, 0x10(CX)	
  0x42d0fb		ebb1			JMP 0x42d0ae		
		return nil
  0x42d0fd		48c744243800000000	MOVQ $0x0, 0x38(SP)	
  0x42d106		488b6c2420		MOVQ 0x20(SP), BP	
  0x42d10b		4883c428		ADDQ $0x28, SP		
  0x42d10f		c3			RET			
  0x42d110		ba01000000		MOVL $0x1, DX		
	if _p_.gFree.empty() && (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
  0x42d115		e953ffffff		JMP 0x42d06d		
func gfget(_p_ *p) *g {
  0x42d11a		e861a70100		CALL runtime.morestack_noctxt(SB)	
  0x42d11f		e97cfeffff		JMP runtime.gfget(SB)			

TEXT runtime.gfpurge(SB) /usr/local/go/src/runtime/proc.go
func gfpurge(_p_ *p) {
  0x42d130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42d139		483b6110		CMPQ 0x10(CX), SP	
  0x42d13d		0f86a5000000		JBE 0x42d1e8		
  0x42d143		4883ec10		SUBQ $0x10, SP		
  0x42d147		48896c2408		MOVQ BP, 0x8(SP)	
  0x42d14c		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.gFree.lock)
  0x42d151		488d05d84b0900		LEAQ runtime.sched+144(SB), AX	
  0x42d158		48890424		MOVQ AX, 0(SP)			
  0x42d15c		e87fb5fdff		CALL runtime.lock(SB)		
	for !_p_.gFree.empty() {
  0x42d161		488b442418		MOVQ 0x18(SP), AX	
  0x42d166		eb06			JMP 0x42d16e		
		sched.gFree.n++
  0x42d168		ff05da4b0900		INCL runtime.sched+168(SB)	
	for !_p_.gFree.empty() {
  0x42d16e		90			NOPL			
	return l.head == 0
  0x42d16f		488b88f00d0000		MOVQ 0xdf0(AX), CX	
  0x42d176		4885c9			TESTQ CX, CX		
	for !_p_.gFree.empty() {
  0x42d179		7453			JE 0x42d1ce		
		gp := _p_.gFree.pop()
  0x42d17b		90			NOPL			
	gp := l.head.ptr()
  0x42d17c		90			NOPL			
	if gp != nil {
  0x42d17d		4885c9			TESTQ CX, CX		
  0x42d180		740e			JE 0x42d190		
		l.head = gp.schedlink
  0x42d182		488b91a0000000		MOVQ 0xa0(CX), DX	
  0x42d189		488990f00d0000		MOVQ DX, 0xdf0(AX)	
		_p_.gFree.n--
  0x42d190		ff88f80d0000		DECL 0xdf8(AX)		
		if gp.stack.lo == 0 {
  0x42d196		48833900		CMPQ $0x0, 0(CX)	
  0x42d19a		7519			JNE 0x42d1b5		
			sched.gFree.noStack.push(gp)
  0x42d19c		90			NOPL			
	gp.schedlink = l.head
  0x42d19d		488b159c4b0900		MOVQ runtime.sched+160(SB), DX	
  0x42d1a4		488991a0000000		MOVQ DX, 0xa0(CX)		
	l.head.set(gp)
  0x42d1ab		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42d1ac		48890d8d4b0900		MOVQ CX, runtime.sched+160(SB)	
		sched.gFree.n++
  0x42d1b3		ebb3			JMP 0x42d168		
			sched.gFree.stack.push(gp)
  0x42d1b5		90			NOPL			
	gp.schedlink = l.head
  0x42d1b6		488b157b4b0900		MOVQ runtime.sched+152(SB), DX	
  0x42d1bd		488991a0000000		MOVQ DX, 0xa0(CX)		
	l.head.set(gp)
  0x42d1c4		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42d1c5		48890d6c4b0900		MOVQ CX, runtime.sched+152(SB)	
		sched.gFree.n++
  0x42d1cc		eb9a			JMP 0x42d168		
	unlock(&sched.gFree.lock)
  0x42d1ce		488d055b4b0900		LEAQ runtime.sched+144(SB), AX	
  0x42d1d5		48890424		MOVQ AX, 0(SP)			
  0x42d1d9		e8b2b6fdff		CALL runtime.unlock(SB)		
}
  0x42d1de		488b6c2408		MOVQ 0x8(SP), BP	
  0x42d1e3		4883c410		ADDQ $0x10, SP		
  0x42d1e7		c3			RET			
func gfpurge(_p_ *p) {
  0x42d1e8		e893a60100		CALL runtime.morestack_noctxt(SB)	
  0x42d1ed		e93effffff		JMP runtime.gfpurge(SB)			

TEXT runtime.unlockOSThread(SB) /usr/local/go/src/runtime/proc.go
func unlockOSThread() {
  0x42d200		4883ec18		SUBQ $0x18, SP		
  0x42d204		48896c2410		MOVQ BP, 0x10(SP)	
  0x42d209		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x42d20e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedInt == 0 {
  0x42d217		488b4830		MOVQ 0x30(AX), CX	
  0x42d21b		83b97402000000		CMPL $0x0, 0x274(CX)	
  0x42d222		744c			JE 0x42d270		
	_g_.m.lockedInt--
  0x42d224		488b4030		MOVQ 0x30(AX), AX	
  0x42d228		ff8874020000		DECL 0x274(AX)		
	_g_ := getg()
  0x42d22e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.lockedInt != 0 || _g_.m.lockedExt != 0 {
  0x42d237		488b4830		MOVQ 0x30(AX), CX	
	dounlockOSThread()
  0x42d23b		90			NOPL			
	if _g_.m.lockedInt != 0 || _g_.m.lockedExt != 0 {
  0x42d23c		83b97402000000		CMPL $0x0, 0x274(CX)	
  0x42d243		740a			JE 0x42d24f		
  0x42d245		488b6c2410		MOVQ 0x10(SP), BP	
  0x42d24a		4883c418		ADDQ $0x18, SP		
  0x42d24e		c3			RET			
  0x42d24f		83b97002000000		CMPL $0x0, 0x270(CX)	
  0x42d256		75ed			JNE 0x42d245		
	_g_.m.lockedg = 0
  0x42d258		48c7816801000000000000	MOVQ $0x0, 0x168(CX)	
	_g_.lockedm = 0
  0x42d263		48c780d800000000000000	MOVQ $0x0, 0xd8(AX)	
	dounlockOSThread()
  0x42d26e		ebd5			JMP 0x42d245		
	_g_ := getg()
  0x42d270		4889442408		MOVQ AX, 0x8(SP)	
		systemstack(badunlockosthread)
  0x42d275		488d05cc640400		LEAQ 0x464cc(IP), AX		
  0x42d27c		48890424		MOVQ AX, 0(SP)			
  0x42d280		e8aba40100		CALL runtime.systemstack(SB)	
	_g_.m.lockedInt--
  0x42d285		488b442408		MOVQ 0x8(SP), AX	
		systemstack(badunlockosthread)
  0x42d28a		eb98			JMP 0x42d224		

TEXT runtime.badunlockosthread(SB) /usr/local/go/src/runtime/proc.go
func badunlockosthread() {
  0x42d290		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42d299		483b6110		CMPQ 0x10(CX), SP	
  0x42d29d		7629			JBE 0x42d2c8		
  0x42d29f		4883ec18		SUBQ $0x18, SP		
  0x42d2a3		48896c2410		MOVQ BP, 0x10(SP)	
  0x42d2a8		488d6c2410		LEAQ 0x10(SP), BP	
	throw("runtime: internal error: misuse of lockOSThread/unlockOSThread")
  0x42d2ad		488d0535630400		LEAQ 0x46335(IP), AX	
  0x42d2b4		48890424		MOVQ AX, 0(SP)		
  0x42d2b8		48c74424083e000000	MOVQ $0x3e, 0x8(SP)	
  0x42d2c1		e8ba61ffff		CALL runtime.throw(SB)	
  0x42d2c6		0f0b			UD2			
func badunlockosthread() {
  0x42d2c8		e8b3a50100		CALL runtime.morestack_noctxt(SB)	
  0x42d2cd		ebc1			JMP runtime.badunlockosthread(SB)	

TEXT runtime._System(SB) /usr/local/go/src/runtime/proc.go
func _System()                    { _System() }
  0x42d2d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42d2d9		483b6110		CMPQ 0x10(CX), SP			
  0x42d2dd		761a			JBE 0x42d2f9				
  0x42d2df		4883ec08		SUBQ $0x8, SP				
  0x42d2e3		48892c24		MOVQ BP, 0(SP)				
  0x42d2e7		488d2c24		LEAQ 0(SP), BP				
  0x42d2eb		e8e0ffffff		CALL runtime._System(SB)		
  0x42d2f0		488b2c24		MOVQ 0(SP), BP				
  0x42d2f4		4883c408		ADDQ $0x8, SP				
  0x42d2f8		c3			RET					
  0x42d2f9		e882a50100		CALL runtime.morestack_noctxt(SB)	
  0x42d2fe		ebd0			JMP runtime._System(SB)			

TEXT runtime._ExternalCode(SB) /usr/local/go/src/runtime/proc.go
func _ExternalCode()              { _ExternalCode() }
  0x42d300		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42d309		483b6110		CMPQ 0x10(CX), SP			
  0x42d30d		761a			JBE 0x42d329				
  0x42d30f		4883ec08		SUBQ $0x8, SP				
  0x42d313		48892c24		MOVQ BP, 0(SP)				
  0x42d317		488d2c24		LEAQ 0(SP), BP				
  0x42d31b		e8e0ffffff		CALL runtime._ExternalCode(SB)		
  0x42d320		488b2c24		MOVQ 0(SP), BP				
  0x42d324		4883c408		ADDQ $0x8, SP				
  0x42d328		c3			RET					
  0x42d329		e852a50100		CALL runtime.morestack_noctxt(SB)	
  0x42d32e		ebd0			JMP runtime._ExternalCode(SB)		

TEXT runtime._LostExternalCode(SB) /usr/local/go/src/runtime/proc.go
func _LostExternalCode()          { _LostExternalCode() }
  0x42d330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42d339		483b6110		CMPQ 0x10(CX), SP			
  0x42d33d		761a			JBE 0x42d359				
  0x42d33f		4883ec08		SUBQ $0x8, SP				
  0x42d343		48892c24		MOVQ BP, 0(SP)				
  0x42d347		488d2c24		LEAQ 0(SP), BP				
  0x42d34b		e8e0ffffff		CALL runtime._LostExternalCode(SB)	
  0x42d350		488b2c24		MOVQ 0(SP), BP				
  0x42d354		4883c408		ADDQ $0x8, SP				
  0x42d358		c3			RET					
  0x42d359		e822a50100		CALL runtime.morestack_noctxt(SB)	
  0x42d35e		ebd0			JMP runtime._LostExternalCode(SB)	

TEXT runtime._GC(SB) /usr/local/go/src/runtime/proc.go
func _GC()                        { _GC() }
  0x42d360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42d369		483b6110		CMPQ 0x10(CX), SP			
  0x42d36d		761a			JBE 0x42d389				
  0x42d36f		4883ec08		SUBQ $0x8, SP				
  0x42d373		48892c24		MOVQ BP, 0(SP)				
  0x42d377		488d2c24		LEAQ 0(SP), BP				
  0x42d37b		e8e0ffffff		CALL runtime._GC(SB)			
  0x42d380		488b2c24		MOVQ 0(SP), BP				
  0x42d384		4883c408		ADDQ $0x8, SP				
  0x42d388		c3			RET					
  0x42d389		e8f2a40100		CALL runtime.morestack_noctxt(SB)	
  0x42d38e		ebd0			JMP runtime._GC(SB)			

TEXT runtime._VDSO(SB) /usr/local/go/src/runtime/proc.go
func _VDSO()                      { _VDSO() }
  0x42d390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x42d399		483b6110		CMPQ 0x10(CX), SP			
  0x42d39d		761a			JBE 0x42d3b9				
  0x42d39f		4883ec08		SUBQ $0x8, SP				
  0x42d3a3		48892c24		MOVQ BP, 0(SP)				
  0x42d3a7		488d2c24		LEAQ 0(SP), BP				
  0x42d3ab		e8e0ffffff		CALL runtime._VDSO(SB)			
  0x42d3b0		488b2c24		MOVQ 0(SP), BP				
  0x42d3b4		4883c408		ADDQ $0x8, SP				
  0x42d3b8		c3			RET					
  0x42d3b9		e8c2a40100		CALL runtime.morestack_noctxt(SB)	
  0x42d3be		ebd0			JMP runtime._VDSO(SB)			

TEXT runtime.sigprof(SB) /usr/local/go/src/runtime/proc.go
func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
  0x42d3c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42d3c9		488d842418feffff	LEAQ 0xfffffe18(SP), AX	
  0x42d3d1		483b4110		CMPQ 0x10(CX), AX	
  0x42d3d5		0f86d1040000		JBE 0x42d8ac		
  0x42d3db		4881ec68020000		SUBQ $0x268, SP		
  0x42d3e2		4889ac2460020000	MOVQ BP, 0x260(SP)	
  0x42d3ea		488dac2460020000	LEAQ 0x260(SP), BP	
	if prof.hz == 0 {
  0x42d3f2		833dc3f90a0000		CMPL $0x0, runtime.prof+4(SB)	
  0x42d3f9		0f8488040000		JE 0x42d887			
	getg().m.mallocing++
  0x42d3ff		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42d408		488b4030		MOVQ 0x30(AX), AX	
  0x42d40c		ff80f0000000		INCL 0xf0(AX)		
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) || (mp != nil && mp.vdsoSP != 0) {
  0x42d412		488b842488020000	MOVQ 0x288(SP), AX	
  0x42d41a		4885c0			TESTQ AX, AX		
  0x42d41d		0f8452040000		JE 0x42d875		
  0x42d423		488b8c2478020000	MOVQ 0x278(SP), CX	
  0x42d42b		483908			CMPQ CX, 0(AX)		
  0x42d42e		0f8606040000		JBE 0x42d83a		
  0x42d434		ba01000000		MOVL $0x1, DX		
  0x42d439		84d2			TESTL DL, DL		
  0x42d43b		0f84cb030000		JE 0x42d80c		
  0x42d441		31d2			XORL DX, DX		
	var stk [maxCPUProfStack]uintptr
  0x42d443		488d7c2460		LEAQ 0x60(SP), DI	
  0x42d448		0f57c0			XORPS X0, X0		
  0x42d44b		48896c24f0		MOVQ BP, -0x10(SP)	
  0x42d450		488d6c24f0		LEAQ -0x10(SP), BP	
  0x42d455		e82ecc0100		CALL 0x44a088		
  0x42d45a		488b6d00		MOVQ 0(BP), BP		
	if mp.ncgo > 0 && mp.curg != nil && mp.curg.syscallpc != 0 && mp.curg.syscallsp != 0 {
  0x42d45e		488b9c2490020000	MOVQ 0x290(SP), BX	
  0x42d466		83bb3801000000		CMPL $0x0, 0x138(BX)	
  0x42d46d		0f8e1f030000		JLE 0x42d792		
  0x42d473		488bb3c0000000		MOVQ 0xc0(BX), SI	
  0x42d47a		4885f6			TESTQ SI, SI		
  0x42d47d		0f840f030000		JE 0x42d792		
  0x42d483		48837e7800		CMPQ $0x0, 0x78(SI)	
  0x42d488		0f8404030000		JE 0x42d792		
  0x42d48e		48837e7000		CMPQ $0x0, 0x70(SI)	
  0x42d493		0f84f9020000		JE 0x42d792		
		if atomic.Load(&mp.cgoCallersUse) == 0 && mp.cgoCallers != nil && mp.cgoCallers[0] != 0 {
  0x42d499		8b8b3c010000		MOVL 0x13c(BX), CX	
  0x42d49f		85c9			TESTL CX, CX		
  0x42d4a1		0f85df020000		JNE 0x42d786		
  0x42d4a7		488b8b40010000		MOVQ 0x140(BX), CX	
  0x42d4ae		4885c9			TESTQ CX, CX		
  0x42d4b1		0f84cf020000		JE 0x42d786		
  0x42d4b7		48833900		CMPQ $0x0, 0(CX)	
  0x42d4bb		0f84c5020000		JE 0x42d786		
  0x42d4c1		31d2			XORL DX, DX		
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42d4c3		eb03			JMP 0x42d4c8		
				cgoOff++
  0x42d4c5		48ffc2			INCQ DX			
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42d4c8		4883fa20		CMPQ $0x20, DX		
  0x42d4cc		7d09			JGE 0x42d4d7		
  0x42d4ce		488b34d1		MOVQ 0(CX)(DX*8), SI	
  0x42d4d2		4885f6			TESTQ SI, SI		
  0x42d4d5		75ee			JNE 0x42d4c5		
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42d4d7		4885d2			TESTQ DX, DX		
  0x42d4da		0f8cc5030000		JL 0x42d8a5		
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42d4e0		4883fa20		CMPQ $0x20, DX		
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42d4e4		0f87bb030000		JA 0x42d8a5		
  0x42d4ea		4883fa40		CMPQ $0x40, DX		
  0x42d4ee		be40000000		MOVL $0x40, SI		
  0x42d4f3		480f4cf2		CMOVL DX, SI		
  0x42d4f7		488d7c2460		LEAQ 0x60(SP), DI	
  0x42d4fc		4839cf			CMPQ CX, DI		
  0x42d4ff		0f8543020000		JNE 0x42d748		
			mp.cgoCallers[0] = 0
  0x42d505		488b8b40010000		MOVQ 0x140(BX), CX	
  0x42d50c		48c70100000000		MOVQ $0x0, 0(CX)	
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42d513		488b8bc0000000		MOVQ 0xc0(BX), CX		
  0x42d51a		488b7178		MOVQ 0x78(CX), SI		
  0x42d51e		4c8b4170		MOVQ 0x70(CX), R8		
  0x42d522		4883fa40		CMPQ $0x40, DX			
  0x42d526		0f8372030000		JAE 0x42d89e			
  0x42d52c		4889542458		MOVQ DX, 0x58(SP)		
  0x42d531		48893424		MOVQ SI, 0(SP)			
  0x42d535		4c89442408		MOVQ R8, 0x8(SP)		
  0x42d53a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42d543		48894c2418		MOVQ CX, 0x18(SP)		
  0x42d548		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x42d551		488d44d460		LEAQ 0x60(SP)(DX*8), AX		
  0x42d556		4889442428		MOVQ AX, 0x28(SP)		
  0x42d55b		488d42c0		LEAQ -0x40(DX), AX		
  0x42d55f		48f7d8			NEGQ AX				
  0x42d562		4889442430		MOVQ AX, 0x30(SP)		
  0x42d567		0f11442438		MOVUPS X0, 0x38(SP)		
  0x42d56c		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x42d575		e846020100		CALL runtime.gentraceback(SB)	
  0x42d57a		488b442450		MOVQ 0x50(SP), AX		
			n += cgoOff
  0x42d57f		488b4c2458		MOVQ 0x58(SP), CX	
  0x42d584		4801c1			ADDQ AX, CX		
		if n > 0 {
  0x42d587		4885c0			TESTQ AX, AX		
	if n <= 0 {
  0x42d58a		480f4fc1		CMOVG CX, AX		
  0x42d58e		4885c0			TESTQ AX, AX		
  0x42d591		0f8fa9010000		JG 0x42d740		
		if n == 0 && mp != nil && mp.vdsoSP != 0 {
  0x42d597		488b842490020000	MOVQ 0x290(SP), AX	
  0x42d59f		488b8830030000		MOVQ 0x330(AX), CX	
  0x42d5a6		4885c9			TESTQ CX, CX		
  0x42d5a9		0f8527010000		JNE 0x42d6d6		
  0x42d5af		31c9			XORL CX, CX		
		if n == 0 {
  0x42d5b1		4885c9			TESTQ CX, CX		
  0x42d5b4		7474			JE 0x42d62a		
	if prof.hz != 0 {
  0x42d5b6		833dfff70a0000		CMPL $0x0, runtime.prof+4(SB)	
  0x42d5bd		7448			JE 0x42d607			
		cpuprof.add(gp, stk[:n])
  0x42d5bf		4885c9			TESTQ CX, CX				
  0x42d5c2		0f8ccf020000		JL 0x42d897				
  0x42d5c8		4883f940		CMPQ $0x40, CX				
  0x42d5cc		0f87c5020000		JA 0x42d897				
  0x42d5d2		488d05e7500900		LEAQ runtime.cpuprof(SB), AX		
  0x42d5d9		48890424		MOVQ AX, 0(SP)				
  0x42d5dd		488b842488020000	MOVQ 0x288(SP), AX			
  0x42d5e5		4889442408		MOVQ AX, 0x8(SP)			
  0x42d5ea		488d442460		LEAQ 0x60(SP), AX			
  0x42d5ef		4889442410		MOVQ AX, 0x10(SP)			
  0x42d5f4		48894c2418		MOVQ CX, 0x18(SP)			
  0x42d5f9		48c744242040000000	MOVQ $0x40, 0x20(SP)			
  0x42d602		e8a984fdff		CALL runtime.(*cpuProfile).add(SB)	
	getg().m.mallocing--
  0x42d607		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42d610		488b4030		MOVQ 0x30(AX), AX	
  0x42d614		ff88f0000000		DECL 0xf0(AX)		
}
  0x42d61a		488bac2460020000	MOVQ 0x260(SP), BP	
  0x42d622		4881c468020000		ADDQ $0x268, SP		
  0x42d629		c3			RET			
			if inVDSOPage(pc) {
  0x42d62a		488b842470020000	MOVQ 0x270(SP), AX		
  0x42d632		48890424		MOVQ AX, 0(SP)			
  0x42d636		e8e56e0100		CALL runtime.inVDSOPage(SB)	
  0x42d63b		807c240800		CMPB $0x0, 0x8(SP)		
  0x42d640		746c			JE 0x42d6ae			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d642		488d05c7600400		LEAQ 0x460c7(IP), AX	
  0x42d649		8400			TESTB AL, 0(AX)		
				pc = funcPC(_VDSO) + sys.PCQuantum
  0x42d64b		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d64c		488b05bd600400		MOVQ 0x460bd(IP), AX	
				pc = funcPC(_VDSO) + sys.PCQuantum
  0x42d653		48ffc0			INCQ AX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d656		90			NOPL			
			stk[0] = pc
  0x42d657		4889442460		MOVQ AX, 0x60(SP)	
			if mp.preemptoff != "" {
  0x42d65c		488b842490020000	MOVQ 0x290(SP), AX	
  0x42d664		4883b80001000000	CMPQ $0x0, 0x100(AX)	
  0x42d66c		7424			JE 0x42d692		
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d66e		488d0583600400		LEAQ 0x46083(IP), AX	
  0x42d675		8400			TESTB AL, 0(AX)		
				stk[1] = funcPC(_GC) + sys.PCQuantum
  0x42d677		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d678		488b0579600400		MOVQ 0x46079(IP), AX	
				stk[1] = funcPC(_GC) + sys.PCQuantum
  0x42d67f		48ffc0			INCQ AX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d682		90			NOPL			
				stk[1] = funcPC(_GC) + sys.PCQuantum
  0x42d683		4889442468		MOVQ AX, 0x68(SP)	
	if prof.hz != 0 {
  0x42d688		b902000000		MOVL $0x2, CX		
  0x42d68d		e924ffffff		JMP 0x42d5b6		
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d692		488d056f600400		LEAQ 0x4606f(IP), AX	
  0x42d699		8400			TESTB AL, 0(AX)		
				stk[1] = funcPC(_System) + sys.PCQuantum
  0x42d69b		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d69c		488b0565600400		MOVQ 0x46065(IP), AX	
				stk[1] = funcPC(_System) + sys.PCQuantum
  0x42d6a3		48ffc0			INCQ AX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d6a6		90			NOPL			
				stk[1] = funcPC(_System) + sys.PCQuantum
  0x42d6a7		4889442468		MOVQ AX, 0x68(SP)	
  0x42d6ac		ebda			JMP 0x42d688		
			} else if pc > firstmoduledata.etext {
  0x42d6ae		488b842470020000	MOVQ 0x270(SP), AX				
  0x42d6b6		483905eb220900		CMPQ AX, runtime.firstmoduledata+104(SB)	
  0x42d6bd		7398			JAE 0x42d657					
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d6bf		488d052a600400		LEAQ 0x4602a(IP), AX	
  0x42d6c6		8400			TESTB AL, 0(AX)		
				pc = funcPC(_ExternalCode) + sys.PCQuantum
  0x42d6c8		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d6c9		488b0520600400		MOVQ 0x46020(IP), AX	
				pc = funcPC(_ExternalCode) + sys.PCQuantum
  0x42d6d0		48ffc0			INCQ AX			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d6d3		90			NOPL			
				pc = funcPC(_ExternalCode) + sys.PCQuantum
  0x42d6d4		eb81			JMP 0x42d657		
			n = gentraceback(mp.vdsoPC, mp.vdsoSP, 0, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d6d6		488b9038030000		MOVQ 0x338(AX), DX		
  0x42d6dd		48891424		MOVQ DX, 0(SP)			
  0x42d6e1		48894c2408		MOVQ CX, 0x8(SP)		
  0x42d6e6		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42d6ef		488b8c2488020000	MOVQ 0x288(SP), CX		
  0x42d6f7		48894c2418		MOVQ CX, 0x18(SP)		
  0x42d6fc		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x42d705		488d542460		LEAQ 0x60(SP), DX		
  0x42d70a		4889542428		MOVQ DX, 0x28(SP)		
  0x42d70f		48c744243040000000	MOVQ $0x40, 0x30(SP)		
  0x42d718		0f57c0			XORPS X0, X0			
  0x42d71b		0f11442438		MOVUPS X0, 0x38(SP)		
  0x42d720		48c744244806000000	MOVQ $0x6, 0x48(SP)		
  0x42d729		e892000100		CALL runtime.gentraceback(SB)	
  0x42d72e		488b4c2450		MOVQ 0x50(SP), CX		
			if mp.preemptoff != "" {
  0x42d733		488b842490020000	MOVQ 0x290(SP), AX	
			n = gentraceback(mp.vdsoPC, mp.vdsoSP, 0, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d73b		e971feffff		JMP 0x42d5b1		
		cpuprof.add(gp, stk[:n])
  0x42d740		4889c1			MOVQ AX, CX		
	if n <= 0 {
  0x42d743		e96efeffff		JMP 0x42d5b6		
			for cgoOff < len(mp.cgoCallers) && mp.cgoCallers[cgoOff] != 0 {
  0x42d748		4889542458		MOVQ DX, 0x58(SP)	
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42d74d		48893c24		MOVQ DI, 0(SP)			
  0x42d751		48894c2408		MOVQ CX, 0x8(SP)		
  0x42d756		48c1e603		SHLQ $0x3, SI			
  0x42d75a		4889742410		MOVQ SI, 0x10(SP)		
  0x42d75f		e8eccf0100		CALL runtime.memmove(SB)	
		cpuprof.add(gp, stk[:n])
  0x42d764		488b842488020000	MOVQ 0x288(SP), AX	
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42d76c		488b542458		MOVQ 0x58(SP), DX	
			mp.cgoCallers[0] = 0
  0x42d771		488b9c2490020000	MOVQ 0x290(SP), BX	
	var stk [maxCPUProfStack]uintptr
  0x42d779		488d7c2460		LEAQ 0x60(SP), DI	
  0x42d77e		0f57c0			XORPS X0, X0		
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42d781		e97ffdffff		JMP 0x42d505		
	var stk [maxCPUProfStack]uintptr
  0x42d786		488d7c2460		LEAQ 0x60(SP), DI	
  0x42d78b		31d2			XORL DX, DX		
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42d78d		e981fdffff		JMP 0x42d513		
	} else if traceback {
  0x42d792		84d2			TESTL DL, DL		
  0x42d794		750a			JNE 0x42d7a0		
  0x42d796		31c9			XORL CX, CX		
	if n <= 0 {
  0x42d798		4889c8			MOVQ CX, AX		
  0x42d79b		e9eefdffff		JMP 0x42d58e		
		n = gentraceback(pc, sp, lr, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d7a0		488b942470020000	MOVQ 0x270(SP), DX		
  0x42d7a8		48891424		MOVQ DX, 0(SP)			
  0x42d7ac		48894c2408		MOVQ CX, 0x8(SP)		
  0x42d7b1		488b8c2480020000	MOVQ 0x280(SP), CX		
  0x42d7b9		48894c2410		MOVQ CX, 0x10(SP)		
  0x42d7be		4889442418		MOVQ AX, 0x18(SP)		
  0x42d7c3		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x42d7cc		488d4c2460		LEAQ 0x60(SP), CX		
  0x42d7d1		48894c2428		MOVQ CX, 0x28(SP)		
  0x42d7d6		48c744243040000000	MOVQ $0x40, 0x30(SP)		
  0x42d7df		0f11442438		MOVUPS X0, 0x38(SP)		
  0x42d7e4		48c744244806000000	MOVQ $0x6, 0x48(SP)		
  0x42d7ed		e8ceff0000		CALL runtime.gentraceback(SB)	
  0x42d7f2		488b4c2450		MOVQ 0x50(SP), CX		
		cpuprof.add(gp, stk[:n])
  0x42d7f7		488b842488020000	MOVQ 0x288(SP), AX	
		if n == 0 && mp != nil && mp.vdsoSP != 0 {
  0x42d7ff		488b9c2490020000	MOVQ 0x290(SP), BX	
	var stk [maxCPUProfStack]uintptr
  0x42d807		0f57c0			XORPS X0, X0		
		n = gentraceback(pc, sp, lr, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d80a		eb8c			JMP 0x42d798		
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) || (mp != nil && mp.vdsoSP != 0) {
  0x42d80c		488b942490020000	MOVQ 0x290(SP), DX	
  0x42d814		4885d2			TESTQ DX, DX		
  0x42d817		741d			JE 0x42d836		
  0x42d819		4883ba3003000000	CMPQ $0x0, 0x330(DX)	
  0x42d821		0f95c3			SETNE BL		
  0x42d824		84db			TESTL BL, BL		
  0x42d826		0f8515fcffff		JNE 0x42d441		
  0x42d82c		ba01000000		MOVL $0x1, DX		
	var stk [maxCPUProfStack]uintptr
  0x42d831		e90dfcffff		JMP 0x42d443		
  0x42d836		31db			XORL BX, BX		
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) || (mp != nil && mp.vdsoSP != 0) {
  0x42d838		ebea			JMP 0x42d824		
  0x42d83a		48394808		CMPQ CX, 0x8(AX)	
  0x42d83e		730a			JAE 0x42d84a		
  0x42d840		ba01000000		MOVL $0x1, DX		
  0x42d845		e9effbffff		JMP 0x42d439		
  0x42d84a		488b842470020000	MOVQ 0x270(SP), AX	
  0x42d852		48890424		MOVQ AX, 0(SP)		
  0x42d856		e875010000		CALL runtime.setsSP(SB)	
  0x42d85b		0fb6542408		MOVZX 0x8(SP), DX	
		cpuprof.add(gp, stk[:n])
  0x42d860		488b842488020000	MOVQ 0x288(SP), AX	
		n = gentraceback(pc, sp, lr, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d868		488b8c2478020000	MOVQ 0x278(SP), CX	
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) || (mp != nil && mp.vdsoSP != 0) {
  0x42d870		e9c4fbffff		JMP 0x42d439		
		n = gentraceback(pc, sp, lr, gp, 0, &stk[0], len(stk), nil, nil, _TraceTrap|_TraceJumpStack)
  0x42d875		488b8c2478020000	MOVQ 0x278(SP), CX	
  0x42d87d		ba01000000		MOVL $0x1, DX		
	if gp == nil || sp < gp.stack.lo || gp.stack.hi < sp || setsSP(pc) || (mp != nil && mp.vdsoSP != 0) {
  0x42d882		e9b2fbffff		JMP 0x42d439		
		return
  0x42d887		488bac2460020000	MOVQ 0x260(SP), BP	
  0x42d88f		4881c468020000		ADDQ $0x268, SP		
  0x42d896		c3			RET			
		cpuprof.add(gp, stk[:n])
  0x42d897		e8b447ffff		CALL runtime.panicslice(SB)	
  0x42d89c		0f0b			UD2				
		n = gentraceback(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, 0, &stk[cgoOff], len(stk)-cgoOff, nil, nil, 0)
  0x42d89e		e87d46ffff		CALL runtime.panicindex(SB)	
  0x42d8a3		0f0b			UD2				
			copy(stk[:], mp.cgoCallers[:cgoOff])
  0x42d8a5		e8a647ffff		CALL runtime.panicslice(SB)	
  0x42d8aa		0f0b			UD2				
func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
  0x42d8ac		e8cf9f0100		CALL runtime.morestack_noctxt(SB)	
  0x42d8b1		e90afbffff		JMP runtime.sigprof(SB)			

TEXT runtime.sigprofNonGo(SB) /usr/local/go/src/runtime/proc.go
func sigprofNonGo() {
  0x42d8c0		4883ec28		SUBQ $0x28, SP		
  0x42d8c4		48896c2420		MOVQ BP, 0x20(SP)	
  0x42d8c9		488d6c2420		LEAQ 0x20(SP), BP	
	if prof.hz != 0 {
  0x42d8ce		833de7f40a0000		CMPL $0x0, runtime.prof+4(SB)	
  0x42d8d5		744b			JE 0x42d922			
  0x42d8d7		31c0			XORL AX, AX			
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42d8d9		eb03			JMP 0x42d8de		
			n++
  0x42d8db		48ffc0			INCQ AX			
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42d8de		4883f820		CMPQ $0x20, AX				
  0x42d8e2		7d53			JGE 0x42d937				
  0x42d8e4		488d0d35f90a00		LEAQ runtime.sigprofCallers(SB), CX	
  0x42d8eb		488b14c1		MOVQ 0(CX)(AX*8), DX			
  0x42d8ef		4885d2			TESTQ DX, DX				
  0x42d8f2		75e7			JNE 0x42d8db				
		cpuprof.addNonGo(sigprofCallers[:n])
  0x42d8f4		4885c0			TESTQ AX, AX		
  0x42d8f7		7c47			JL 0x42d940		
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42d8f9		4883f820		CMPQ $0x20, AX		
		cpuprof.addNonGo(sigprofCallers[:n])
  0x42d8fd		7741			JA 0x42d940				
  0x42d8ff		488d15ba4d0900		LEAQ runtime.cpuprof(SB), DX		
  0x42d906		48891424		MOVQ DX, 0(SP)				
  0x42d90a		48894c2408		MOVQ CX, 0x8(SP)			
  0x42d90f		4889442410		MOVQ AX, 0x10(SP)			
  0x42d914		48c744241820000000	MOVQ $0x20, 0x18(SP)			
  0x42d91d		e8ae82fdff		CALL runtime.(*cpuProfile).addNonGo(SB)	
	atomic.Store(&sigprofCallersUse, 0)
  0x42d922		31c0			XORL AX, AX				
  0x42d924		488d0dd5f30a00		LEAQ runtime.sigprofCallersUse(SB), CX	
  0x42d92b		8701			XCHGL AX, 0(CX)				
}
  0x42d92d		488b6c2420		MOVQ 0x20(SP), BP			
  0x42d932		4883c428		ADDQ $0x28, SP				
  0x42d936		c3			RET					
  0x42d937		488d0de2f80a00		LEAQ runtime.sigprofCallers(SB), CX	
		for n < len(sigprofCallers) && sigprofCallers[n] != 0 {
  0x42d93e		ebb4			JMP 0x42d8f4		
		cpuprof.addNonGo(sigprofCallers[:n])
  0x42d940		e80b47ffff		CALL runtime.panicslice(SB)	
  0x42d945		0f0b			UD2				

TEXT runtime.sigprofNonGoPC(SB) /usr/local/go/src/runtime/proc.go
func sigprofNonGoPC(pc uintptr) {
  0x42d950		4883ec38		SUBQ $0x38, SP		
  0x42d954		48896c2430		MOVQ BP, 0x30(SP)	
  0x42d959		488d6c2430		LEAQ 0x30(SP), BP	
	if prof.hz != 0 {
  0x42d95e		833d57f40a0000		CMPL $0x0, runtime.prof+4(SB)	
  0x42d965		750a			JNE 0x42d971			
  0x42d967		488b6c2430		MOVQ 0x30(SP), BP		
  0x42d96c		4883c438		ADDQ $0x38, SP			
  0x42d970		c3			RET				
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d971		488d05785d0400		LEAQ 0x45d78(IP), AX	
  0x42d978		8400			TESTB AL, 0(AX)		
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x42d97a		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x42d97b		488b056e5d0400		MOVQ 0x45d6e(IP), AX	
  0x42d982		90			NOPL			
		stk := []uintptr{
  0x42d983		0f57c0			XORPS X0, X0		
  0x42d986		0f11442420		MOVUPS X0, 0x20(SP)	
  0x42d98b		488b4c2440		MOVQ 0x40(SP), CX	
  0x42d990		48894c2420		MOVQ CX, 0x20(SP)	
			funcPC(_ExternalCode) + sys.PCQuantum,
  0x42d995		48ffc0			INCQ AX			
  0x42d998		4889442428		MOVQ AX, 0x28(SP)	
		cpuprof.addNonGo(stk)
  0x42d99d		488d051c4d0900		LEAQ runtime.cpuprof(SB), AX		
  0x42d9a4		48890424		MOVQ AX, 0(SP)				
  0x42d9a8		488d442420		LEAQ 0x20(SP), AX			
  0x42d9ad		4889442408		MOVQ AX, 0x8(SP)			
  0x42d9b2		48c744241002000000	MOVQ $0x2, 0x10(SP)			
  0x42d9bb		48c744241802000000	MOVQ $0x2, 0x18(SP)			
  0x42d9c4		e80782fdff		CALL runtime.(*cpuProfile).addNonGo(SB)	
  0x42d9c9		eb9c			JMP 0x42d967				

TEXT runtime.setsSP(SB) /usr/local/go/src/runtime/proc.go
func setsSP(pc uintptr) bool {
  0x42d9d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42d9d9		483b6110		CMPQ 0x10(CX), SP	
  0x42d9dd		766a			JBE 0x42da49		
  0x42d9df		4883ec20		SUBQ $0x20, SP		
  0x42d9e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x42d9e8		488d6c2418		LEAQ 0x18(SP), BP	
	f := findfunc(pc)
  0x42d9ed		488b442428		MOVQ 0x28(SP), AX		
  0x42d9f2		48890424		MOVQ AX, 0(SP)			
  0x42d9f6		e805d10000		CALL runtime.findfunc(SB)	
  0x42d9fb		488b442408		MOVQ 0x8(SP), AX		
	if !f.valid() {
  0x42da00		90			NOPL			
	return f._func != nil
  0x42da01		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x42da04		7434			JE 0x42da3a		
	switch f.funcID {
  0x42da06		0fb64024		MOVZX 0x24(AX), AX	
	case funcID_gogo, funcID_systemstack, funcID_mcall, funcID_morestack:
  0x42da0a		8d48fc			LEAL -0x4(AX), CX	
  0x42da0d		80f901			CMPL $0x1, CL		
  0x42da10		770f			JA 0x42da21		
		return true
  0x42da12		c644243001		MOVB $0x1, 0x30(SP)	
  0x42da17		488b6c2418		MOVQ 0x18(SP), BP	
  0x42da1c		4883c420		ADDQ $0x20, SP		
  0x42da20		c3			RET			
	case funcID_gogo, funcID_systemstack, funcID_mcall, funcID_morestack:
  0x42da21		80f80d			CMPL $0xd, AL		
  0x42da24		74ec			JE 0x42da12		
  0x42da26		80f80f			CMPL $0xf, AL		
  0x42da29		74e7			JE 0x42da12		
	return false
  0x42da2b		c644243000		MOVB $0x0, 0x30(SP)	
  0x42da30		488b6c2418		MOVQ 0x18(SP), BP	
  0x42da35		4883c420		ADDQ $0x20, SP		
  0x42da39		c3			RET			
		return true
  0x42da3a		c644243001		MOVB $0x1, 0x30(SP)	
  0x42da3f		488b6c2418		MOVQ 0x18(SP), BP	
  0x42da44		4883c420		ADDQ $0x20, SP		
  0x42da48		c3			RET			
func setsSP(pc uintptr) bool {
  0x42da49		e8329e0100		CALL runtime.morestack_noctxt(SB)	
  0x42da4e		eb80			JMP runtime.setsSP(SB)			

TEXT runtime.procresize(SB) /usr/local/go/src/runtime/proc.go
func procresize(nprocs int32) *p {
  0x42da50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42da59		488d4424d8		LEAQ -0x28(SP), AX	
  0x42da5e		483b4110		CMPQ 0x10(CX), AX	
  0x42da62		0f86530a0000		JBE 0x42e4bb		
  0x42da68		4881eca8000000		SUBQ $0xa8, SP		
  0x42da6f		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x42da77		488dac24a0000000	LEAQ 0xa0(SP), BP	
	old := gomaxprocs
  0x42da7f		8b055bf20a00		MOVL runtime.gomaxprocs(SB), AX	
	if old < 0 || nprocs <= 0 {
  0x42da85		85c0			TESTL AX, AX		
  0x42da87		0f8c130a0000		JL 0x42e4a0		
  0x42da8d		8b8c24b0000000		MOVL 0xb0(SP), CX	
  0x42da94		85c9			TESTL CX, CX		
  0x42da96		0f8e040a0000		JLE 0x42e4a0		
	old := gomaxprocs
  0x42da9c		89442440		MOVL AX, 0x40(SP)	
	if trace.enabled {
  0x42daa0		803d29f1090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42daa7		0f8562090000		JNE 0x42e40f			
	now := nanotime()
  0x42daad		e8fed50100		CALL runtime.nanotime(SB)	
  0x42dab2		488b0424		MOVQ 0(SP), AX			
	if sched.procresizetime != 0 {
  0x42dab6		488b0d1b430900		MOVQ runtime.sched+312(SB), CX	
  0x42dabd		4885c9			TESTQ CX, CX			
  0x42dac0		0f843d090000		JE 0x42e403			
		sched.totaltime += int64(old) * (now - sched.procresizetime)
  0x42dac6		8b542440		MOVL 0x40(SP), DX		
  0x42daca		4863da			MOVSXD DX, BX			
  0x42dacd		4889c6			MOVQ AX, SI			
  0x42dad0		4829c8			SUBQ CX, AX			
  0x42dad3		480fafd8		IMULQ AX, BX			
  0x42dad7		48011d02430900		ADDQ BX, runtime.sched+320(SB)	
	sched.procresizetime = now
  0x42dade		488935f3420900		MOVQ SI, runtime.sched+312(SB)	
	if nprocs > int32(len(allp)) {
  0x42dae5		488b053c3f0900		MOVQ runtime.allp+8(SB), AX	
  0x42daec		8b8c24b0000000		MOVL 0xb0(SP), CX		
  0x42daf3		39c1			CMPL AX, CX			
  0x42daf5		0f8ff1070000		JG 0x42e2ec			
	if int32(len(allp)) != nprocs {
  0x42dafb		31c0			XORL AX, AX		
	for i := int32(0); i < nprocs; i++ {
  0x42dafd		eb02			JMP 0x42db01		
  0x42daff		ffc0			INCL AX			
  0x42db01		39c8			CMPL CX, AX		
  0x42db03		0f8db0010000		JGE 0x42dcb9		
		pp := allp[i]
  0x42db09		488b1d103f0900		MOVQ runtime.allp(SB), BX	
  0x42db10		4863f0			MOVSXD AX, SI			
  0x42db13		4839350e3f0900		CMPQ SI, runtime.allp+8(SB)	
  0x42db1a		0f8672090000		JBE 0x42e492			
	for i := int32(0); i < nprocs; i++ {
  0x42db20		89442448		MOVL AX, 0x48(SP)	
		pp := allp[i]
  0x42db24		488b1cf3		MOVQ 0(BX)(SI*8), BX	
		if pp == nil {
  0x42db28		4885db			TESTQ BX, BX		
  0x42db2b		745d			JE 0x42db8a		
		if pp.mcache == nil {
  0x42db2d		48837b4800		CMPQ $0x0, 0x48(BX)	
  0x42db32		75cb			JNE 0x42daff		
  0x42db34		48895c2470		MOVQ BX, 0x70(SP)	
	if old < 0 || nprocs <= 0 {
  0x42db39		85d2			TESTL DX, DX		
			if old == 0 && i == 0 {
  0x42db3b		7527			JNE 0x42db64		
  0x42db3d		85c0			TESTL AX, AX		
  0x42db3f		7523			JNE 0x42db64		
				if getg().m.mcache == nil {
  0x42db41		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x42db4a		488b7630		MOVQ 0x30(SI), SI	
  0x42db4e		488bb660010000		MOVQ 0x160(SI), SI	
  0x42db55		4885f6			TESTQ SI, SI		
  0x42db58		0f8412090000		JE 0x42e470		
				pp.mcache = getg().m.mcache // bootstrap
  0x42db5e		48897348		MOVQ SI, 0x48(BX)	
  0x42db62		eb9b			JMP 0x42daff		
				pp.mcache = allocmcache()
  0x42db64		e8a72bfeff		CALL runtime.allocmcache(SB)	
  0x42db69		488b0424		MOVQ 0(SP), AX			
  0x42db6d		488b4c2470		MOVQ 0x70(SP), CX		
  0x42db72		48894148		MOVQ AX, 0x48(CX)		
	for i := int32(0); i < nprocs; i++ {
  0x42db76		8b442448		MOVL 0x48(SP), AX	
  0x42db7a		8b8c24b0000000		MOVL 0xb0(SP), CX	
	if old < 0 || nprocs <= 0 {
  0x42db81		8b542440		MOVL 0x40(SP), DX	
				pp.mcache = allocmcache()
  0x42db85		e975ffffff		JMP 0x42daff		
		pp := allp[i]
  0x42db8a		4889742468		MOVQ SI, 0x68(SP)	
			pp = new(p)
  0x42db8f		488d058afa0300		LEAQ 0x3fa8a(IP), AX		
  0x42db96		48890424		MOVQ AX, 0(SP)			
  0x42db9a		e8b1cbfdff		CALL runtime.newobject(SB)	
  0x42db9f		488b442408		MOVQ 0x8(SP), AX		
			pp.id = i
  0x42dba4		8b4c2448		MOVL 0x48(SP), CX	
  0x42dba8		894808			MOVL CX, 0x8(AX)	
			pp.status = _Pgcstop
  0x42dbab		c7400c03000000		MOVL $0x3, 0xc(AX)	
			pp.sudogcache = pp.sudogbuf[:0]
  0x42dbb2		48c780080e000000000000	MOVQ $0x0, 0xe08(AX)			
  0x42dbbd		48c780100e000080000000	MOVQ $0x80, 0xe10(AX)			
  0x42dbc8		488d90180e0000		LEAQ 0xe18(AX), DX			
  0x42dbcf		833d4af20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42dbd6		0f85c3000000		JNE 0x42dc9f				
  0x42dbdc		488990000e0000		MOVQ DX, 0xe00(AX)			
  0x42dbe3		31d2			XORL DX, DX				
			for i := range pp.deferpool {
  0x42dbe5		eb04			JMP 0x42dbeb		
  0x42dbe7		488d5601		LEAQ 0x1(SI), DX	
  0x42dbeb		4883fa05		CMPQ $0x5, DX		
  0x42dbef		7d50			JGE 0x42dc41		
				pp.deferpool[i] = pp.deferpoolbuf[i][:0]
  0x42dbf1		488d1c52		LEAQ 0(DX)(DX*2), BX			
  0x42dbf5		48c744d86000000000	MOVQ $0x0, 0x60(AX)(BX*8)		
  0x42dbfe		48c744d86820000000	MOVQ $0x20, 0x68(AX)(BX*8)		
  0x42dc07		488d3cd8		LEAQ 0(AX)(BX*8), DI			
  0x42dc0b		488d7f58		LEAQ 0x58(DI), DI			
  0x42dc0f		4889d6			MOVQ DX, SI				
  0x42dc12		48c1e208		SHLQ $0x8, DX				
  0x42dc16		488d1410		LEAQ 0(AX)(DX*1), DX			
  0x42dc1a		488d92d0000000		LEAQ 0xd0(DX), DX			
  0x42dc21		833df8f10a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42dc28		7507			JNE 0x42dc31				
  0x42dc2a		488954d858		MOVQ DX, 0x58(AX)(BX*8)			
  0x42dc2f		ebb6			JMP 0x42dbe7				
			pp = new(p)
  0x42dc31		4889c3			MOVQ AX, BX		
				pp.deferpool[i] = pp.deferpoolbuf[i][:0]
  0x42dc34		4889d0			MOVQ DX, AX			
  0x42dc37		e844ba0100		CALL runtime.gcWriteBarrier(SB)	
  0x42dc3c		4889d8			MOVQ BX, AX			
  0x42dc3f		eba6			JMP 0x42dbe7			
			pp = new(p)
  0x42dc41		4889442470		MOVQ AX, 0x70(SP)	
			pp.wbBuf.reset()
  0x42dc46		488d8820130000		LEAQ 0x1320(AX), CX		
  0x42dc4d		48890c24		MOVQ CX, 0(SP)			
  0x42dc51		e81a2fffff		CALL runtime.(*wbBuf).reset(SB)	
			atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
  0x42dc56		488b05c33d0900		MOVQ runtime.allp(SB), AX	
  0x42dc5d		488b4c2468		MOVQ 0x68(SP), CX		
  0x42dc62		48390dbf3d0900		CMPQ CX, runtime.allp+8(SB)	
  0x42dc69		0f861c080000		JBE 0x42e48b			
  0x42dc6f		488d04c8		LEAQ 0(AX)(CX*8), AX		
  0x42dc73		48890424		MOVQ AX, 0(SP)			
  0x42dc77		488b442470		MOVQ 0x70(SP), AX		
  0x42dc7c		4889442408		MOVQ AX, 0x8(SP)		
  0x42dc81		e8aa57fdff		CALL runtime.atomicstorep(SB)	
			if old == 0 && i == 0 {
  0x42dc86		8b442448		MOVL 0x48(SP), AX	
	for i := int32(0); i < nprocs; i++ {
  0x42dc8a		8b8c24b0000000		MOVL 0xb0(SP), CX	
	if old < 0 || nprocs <= 0 {
  0x42dc91		8b542440		MOVL 0x40(SP), DX	
		if pp.mcache == nil {
  0x42dc95		488b5c2470		MOVQ 0x70(SP), BX	
			atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
  0x42dc9a		e98efeffff		JMP 0x42db2d		
			pp.sudogcache = pp.sudogbuf[:0]
  0x42dc9f		488db8000e0000		LEAQ 0xe00(AX), DI	
			pp = new(p)
  0x42dca6		4889c3			MOVQ AX, BX		
			pp.sudogcache = pp.sudogbuf[:0]
  0x42dca9		4889d0			MOVQ DX, AX			
  0x42dcac		e8cfb90100		CALL runtime.gcWriteBarrier(SB)	
				pp.deferpool[i] = pp.deferpoolbuf[i][:0]
  0x42dcb1		4889d8			MOVQ BX, AX		
			pp.sudogcache = pp.sudogbuf[:0]
  0x42dcb4		e92affffff		JMP 0x42dbe3		
func procresize(nprocs int32) *p {
  0x42dcb9		89c8			MOVL CX, AX		
	for i := nprocs; i < old; i++ {
  0x42dcbb		e91b020000		JMP 0x42dedb		
	sched.runqsize++
  0x42dcc0		ff0542400900		INCL runtime.sched+104(SB)	
		for p.runqhead != p.runqtail {
  0x42dcc6		8bb3e4050000		MOVL 0x5e4(BX), SI	
  0x42dccc		39b3e0050000		CMPL SI, 0x5e0(BX)	
  0x42dcd2		7444			JE 0x42dd18		
			p.runqtail--
  0x42dcd4		ffce			DECL SI			
  0x42dcd6		89b3e4050000		MOVL SI, 0x5e4(BX)	
			gp := p.runq[p.runqtail%uint32(len(p.runq))].ptr()
  0x42dcdc		400fb6f6		MOVZX SI, SI			
  0x42dce0		488bb4f3e8050000	MOVQ 0x5e8(BX)(SI*8), SI	
  0x42dce8		90			NOPL				
			globrunqputhead(gp)
  0x42dce9		90			NOPL			
	sched.runq.push(gp)
  0x42dcea		90			NOPL			
	gp.schedlink = q.head
  0x42dceb		488b3d06400900		MOVQ runtime.sched+88(SB), DI	
  0x42dcf2		4889bea0000000		MOVQ DI, 0xa0(SI)		
	q.head.set(gp)
  0x42dcf9		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dcfa		4889f7			MOVQ SI, DI			
  0x42dcfd		488935f43f0900		MOVQ SI, runtime.sched+88(SB)	
	if q.tail == 0 {
  0x42dd04		48833df43f090000	CMPQ $0x0, runtime.sched+96(SB)	
  0x42dd0c		75b2			JNE 0x42dcc0			
		q.tail.set(gp)
  0x42dd0e		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dd0f		48893dea3f0900		MOVQ DI, runtime.sched+96(SB)	
	sched.runqsize++
  0x42dd16		eba8			JMP 0x42dcc0		
		if p.runnext != 0 {
  0x42dd18		488bb3e80d0000		MOVQ 0xde8(BX), SI	
  0x42dd1f		4885f6			TESTQ SI, SI		
  0x42dd22		743f			JE 0x42dd63		
			globrunqputhead(p.runnext.ptr())
  0x42dd24		90			NOPL			
  0x42dd25		90			NOPL			
	sched.runq.push(gp)
  0x42dd26		90			NOPL			
	gp.schedlink = q.head
  0x42dd27		488b3dca3f0900		MOVQ runtime.sched+88(SB), DI	
  0x42dd2e		4889bea0000000		MOVQ DI, 0xa0(SI)		
	q.head.set(gp)
  0x42dd35		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dd36		4889f7			MOVQ SI, DI			
  0x42dd39		488935b83f0900		MOVQ SI, runtime.sched+88(SB)	
	if q.tail == 0 {
  0x42dd40		48833db83f090000	CMPQ $0x0, runtime.sched+96(SB)	
  0x42dd48		7508			JNE 0x42dd52			
		q.tail.set(gp)
  0x42dd4a		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dd4b		48893dae3f0900		MOVQ DI, runtime.sched+96(SB)	
	sched.runqsize++
  0x42dd52		ff05b03f0900		INCL runtime.sched+104(SB)	
			p.runnext = 0
  0x42dd58		48c783e80d000000000000	MOVQ $0x0, 0xde8(BX)	
		if gp := p.gcBgMarkWorker.ptr(); gp != nil {
  0x42dd63		488bb358120000		MOVQ 0x1258(BX), SI	
  0x42dd6a		90			NOPL			
  0x42dd6b		4885f6			TESTQ SI, SI		
  0x42dd6e		0f8511020000		JNE 0x42df85		
		if gcphase != _GCoff {
  0x42dd74		833d61ef0a0000		CMPL $0x0, runtime.gcphase(SB)	
  0x42dd7b		0f85d6010000		JNE 0x42df57			
		for i := range p.sudogbuf {
  0x42dd81		488d83180e0000		LEAQ 0xe18(BX), AX			
  0x42dd88		48890424		MOVQ AX, 0(SP)				
  0x42dd8c		48c744240800040000	MOVQ $0x400, 0x8(SP)			
  0x42dd95		e816fbfdff		CALL runtime.memclrHasPointers(SB)	
		p.sudogcache = p.sudogbuf[:0]
  0x42dd9a		488b842480000000	MOVQ 0x80(SP), AX			
  0x42dda2		48c780080e000000000000	MOVQ $0x0, 0xe08(AX)			
  0x42ddad		48c780100e000080000000	MOVQ $0x80, 0xe10(AX)			
  0x42ddb8		488d88180e0000		LEAQ 0xe18(AX), CX			
  0x42ddbf		833d5af00a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42ddc6		0f8571010000		JNE 0x42df3d				
  0x42ddcc		488988000e0000		MOVQ CX, 0xe00(AX)			
  0x42ddd3		31c9			XORL CX, CX				
		for i := range p.deferpool {
  0x42ddd5		eb07			JMP 0x42ddde		
  0x42ddd7		488d4801		LEAQ 0x1(AX), CX	
			for j := range p.deferpoolbuf[i] {
  0x42dddb		4889d0			MOVQ DX, AX		
		for i := range p.deferpool {
  0x42ddde		4883f905		CMPQ $0x5, CX		
  0x42dde2		0f8d8c000000		JGE 0x42de74		
  0x42dde8		48894c2458		MOVQ CX, 0x58(SP)	
			for j := range p.deferpoolbuf[i] {
  0x42dded		48c1e108		SHLQ $0x8, CX				
  0x42ddf1		48894c2468		MOVQ CX, 0x68(SP)			
  0x42ddf6		488d1c08		LEAQ 0(AX)(CX*1), BX			
  0x42ddfa		488d9bd0000000		LEAQ 0xd0(BX), BX			
  0x42de01		48891c24		MOVQ BX, 0(SP)				
  0x42de05		48c744240800010000	MOVQ $0x100, 0x8(SP)			
  0x42de0e		e89dfafdff		CALL runtime.memclrHasPointers(SB)	
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42de13		488b442458		MOVQ 0x58(SP), AX		
  0x42de18		488d0c40		LEAQ 0(AX)(AX*2), CX		
  0x42de1c		488b942480000000	MOVQ 0x80(SP), DX		
  0x42de24		48c744ca6000000000	MOVQ $0x0, 0x60(DX)(CX*8)	
  0x42de2d		48c744ca6820000000	MOVQ $0x20, 0x68(DX)(CX*8)	
			for j := range p.deferpoolbuf[i] {
  0x42de36		488b5c2468		MOVQ 0x68(SP), BX	
  0x42de3b		488d1c1a		LEAQ 0(DX)(BX*1), BX	
  0x42de3f		488d9bd0000000		LEAQ 0xd0(BX), BX	
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42de46		488d3cca		LEAQ 0(DX)(CX*8), DI			
  0x42de4a		488d7f58		LEAQ 0x58(DI), DI			
  0x42de4e		833dcbef0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42de55		750a			JNE 0x42de61				
  0x42de57		48895cca58		MOVQ BX, 0x58(DX)(CX*8)			
  0x42de5c		e976ffffff		JMP 0x42ddd7				
		for i := range p.deferpool {
  0x42de61		4889c1			MOVQ AX, CX		
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42de64		4889d8			MOVQ BX, AX			
  0x42de67		e814b80100		CALL runtime.gcWriteBarrier(SB)	
		for i := range p.deferpool {
  0x42de6c		4889c8			MOVQ CX, AX		
			p.deferpool[i] = p.deferpoolbuf[i][:0]
  0x42de6f		e963ffffff		JMP 0x42ddd7		
		freemcache(p.mcache)
  0x42de74		488b4848		MOVQ 0x48(AX), CX		
  0x42de78		48890c24		MOVQ CX, 0(SP)			
  0x42de7c		e84f29feff		CALL runtime.freemcache(SB)	
		p.mcache = nil
  0x42de81		488b842480000000	MOVQ 0x80(SP), AX	
  0x42de89		48c7404800000000	MOVQ $0x0, 0x48(AX)	
		gfpurge(p)
  0x42de91		48890424		MOVQ AX, 0(SP)			
  0x42de95		e896f2ffff		CALL runtime.gfpurge(SB)	
		traceProcFree(p)
  0x42de9a		488b842480000000	MOVQ 0x80(SP), AX		
  0x42dea2		48890424		MOVQ AX, 0(SP)			
  0x42dea6		e835df0000		CALL runtime.traceProcFree(SB)	
		p.gcAssistTime = 0
  0x42deab		488b842480000000	MOVQ 0x80(SP), AX	
  0x42deb3		48c7804812000000000000	MOVQ $0x0, 0x1248(AX)	
		p.status = _Pdead
  0x42debe		c7400c04000000		MOVL $0x4, 0xc(AX)	
	for i := nprocs; i < old; i++ {
  0x42dec5		8b442444		MOVL 0x44(SP), AX	
  0x42dec9		8d4801			LEAL 0x1(AX), CX	
  0x42decc		8b442440		MOVL 0x40(SP), AX	
	if int32(len(allp)) != nprocs {
  0x42ded0		8b8424b0000000		MOVL 0xb0(SP), AX	
	for i := nprocs; i < old; i++ {
  0x42ded7		8b542440		MOVL 0x40(SP), DX	
  0x42dedb		39d1			CMPL DX, CX		
  0x42dedd		0f8db0010000		JGE 0x42e093		
		p := allp[i]
  0x42dee3		488b1d363b0900		MOVQ runtime.allp(SB), BX	
  0x42deea		4863f1			MOVSXD CX, SI			
  0x42deed		483935343b0900		CMPQ SI, runtime.allp+8(SB)	
  0x42def4		0f866f050000		JBE 0x42e469			
	for i := nprocs; i < old; i++ {
  0x42defa		894c2444		MOVL CX, 0x44(SP)	
		p := allp[i]
  0x42defe		488b1cf3		MOVQ 0(BX)(SI*8), BX	
  0x42df02		48899c2480000000	MOVQ BX, 0x80(SP)	
		if trace.enabled && p == getg().m.p.ptr() {
  0x42df0a		803dbfec090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42df11		0f84affdffff		JE 0x42dcc6			
  0x42df17		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI		
  0x42df20		488b7e30		MOVQ 0x30(SI), DI		
  0x42df24		488bbfd0000000		MOVQ 0xd0(DI), DI		
  0x42df2b		90			NOPL				
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42df2c		4989f8			MOVQ DI, R8		
		if trace.enabled && p == getg().m.p.ptr() {
  0x42df2f		4839df			CMPQ BX, DI		
  0x42df32		0f858efdffff		JNE 0x42dcc6		
  0x42df38		e9fe000000		JMP 0x42e03b		
		p.sudogcache = p.sudogbuf[:0]
  0x42df3d		488db8000e0000		LEAQ 0xe00(AX), DI	
		p := allp[i]
  0x42df44		4889c2			MOVQ AX, DX		
		p.sudogcache = p.sudogbuf[:0]
  0x42df47		4889c8			MOVQ CX, AX			
  0x42df4a		e831b70100		CALL runtime.gcWriteBarrier(SB)	
			for j := range p.deferpoolbuf[i] {
  0x42df4f		4889d0			MOVQ DX, AX		
		p.sudogcache = p.sudogbuf[:0]
  0x42df52		e97cfeffff		JMP 0x42ddd3		
			wbBufFlush1(p)
  0x42df57		48891c24		MOVQ BX, 0(SP)			
  0x42df5b		e8902dffff		CALL runtime.wbBufFlush1(SB)	
			p.gcw.dispose()
  0x42df60		488b842480000000	MOVQ 0x80(SP), AX			
  0x42df68		488d8870120000		LEAQ 0x1270(AX), CX			
  0x42df6f		48890c24		MOVQ CX, 0(SP)				
  0x42df73		e8b8d9feff		CALL runtime.(*gcWork).dispose(SB)	
		for i := range p.sudogbuf {
  0x42df78		488b9c2480000000	MOVQ 0x80(SP), BX	
			p.gcw.dispose()
  0x42df80		e9fcfdffff		JMP 0x42dd81		
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x42df85		4889b42498000000	MOVQ SI, 0x98(SP)	
			casgstatus(gp, _Gwaiting, _Grunnable)
  0x42df8d		48893424		MOVQ SI, 0(SP)			
  0x42df91		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42df9b		4889442408		MOVQ AX, 0x8(SP)		
  0x42dfa0		e8fb8cffff		CALL runtime.casgstatus(SB)	
			if trace.enabled {
  0x42dfa5		803d24ec090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42dfac		756e			JNE 0x42e01c			
			globrunqput(gp)
  0x42dfae		90			NOPL			
	sched.runq.pushBack(gp)
  0x42dfaf		90			NOPL			
	gp.schedlink = 0
  0x42dfb0		488b842498000000	MOVQ 0x98(SP), AX	
  0x42dfb8		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x42dfc3		488b0d363d0900		MOVQ runtime.sched+96(SB), CX	
  0x42dfca		4885c9			TESTQ CX, CX			
  0x42dfcd		7440			JE 0x42e00f			
		q.tail.ptr().schedlink.set(gp)
  0x42dfcf		90			NOPL			
  0x42dfd0		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dfd1		4889c2			MOVQ AX, DX		
  0x42dfd4		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x42dfdb		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dfdc		4889151d3d0900		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42dfe3		ff051f3d0900		INCL runtime.sched+104(SB)	
			p.gcBgMarkWorker.set(nil)
  0x42dfe9		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42dfea		31f6			XORL SI, SI		
  0x42dfec		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x42dff4		4889b358120000		MOVQ SI, 0x1258(BX)	
	if int32(len(allp)) != nprocs {
  0x42dffb		8b8424b0000000		MOVL 0xb0(SP), AX	
	for i := nprocs; i < old; i++ {
  0x42e002		8b4c2444		MOVL 0x44(SP), CX	
  0x42e006		8b542440		MOVL 0x40(SP), DX	
		if gcphase != _GCoff {
  0x42e00a		e965fdffff		JMP 0x42dd74		
		q.head.set(gp)
  0x42e00f		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42e010		4889c2			MOVQ AX, DX			
  0x42e013		488905de3c0900		MOVQ AX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x42e01a		ebbf			JMP 0x42dfdb		
				traceGoUnpark(gp, 0)
  0x42e01c		488b842498000000	MOVQ 0x98(SP), AX		
  0x42e024		48890424		MOVQ AX, 0(SP)			
  0x42e028		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42e031		e88af10000		CALL runtime.traceGoUnpark(SB)	
  0x42e036		e973ffffff		JMP 0x42dfae			
			traceGoSched()
  0x42e03b		90			NOPL			
	_g_.tracelastp = _g_.m.p
  0x42e03c		4c8986d0000000		MOVQ R8, 0xd0(SI)	
	traceEvent(traceEvGoSched, 1)
  0x42e043		c6042411		MOVB $0x11, 0(SP)		
  0x42e047		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42e050		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x42e059		0f57c0			XORPS X0, X0			
  0x42e05c		0f11442418		MOVUPS X0, 0x18(SP)		
  0x42e061		e83ade0000		CALL runtime.traceEvent(SB)	
			traceProcStop(p)
  0x42e066		488b842480000000	MOVQ 0x80(SP), AX		
  0x42e06e		48890424		MOVQ AX, 0(SP)			
  0x42e072		e849eb0000		CALL runtime.traceProcStop(SB)	
	if int32(len(allp)) != nprocs {
  0x42e077		8b8424b0000000		MOVL 0xb0(SP), AX	
	for i := nprocs; i < old; i++ {
  0x42e07e		8b4c2444		MOVL 0x44(SP), CX	
  0x42e082		8b542440		MOVL 0x40(SP), DX	
		for p.runqhead != p.runqtail {
  0x42e086		488b9c2480000000	MOVQ 0x80(SP), BX	
			traceProcStop(p)
  0x42e08e		e933fcffff		JMP 0x42dcc6		
	if int32(len(allp)) != nprocs {
  0x42e093		488b0d8e390900		MOVQ runtime.allp+8(SB), CX	
  0x42e09a		39c8			CMPL CX, AX			
  0x42e09c		0f85f4010000		JNE 0x42e296			
	_g_ := getg()
  0x42e0a2		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e0ab		48898c2490000000	MOVQ CX, 0x90(SP)	
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42e0b3		488b5130		MOVQ 0x30(CX), DX	
  0x42e0b7		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x42e0be		4885d2			TESTQ DX, DX		
  0x42e0c1		0f84c7010000		JE 0x42e28e		
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42e0c7		4889d3			MOVQ DX, BX		
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42e0ca		90			NOPL			
  0x42e0cb		394208			CMPL AX, 0x8(DX)	
  0x42e0ce		0f8c94010000		JL 0x42e268		
  0x42e0d4		4885db			TESTQ BX, BX		
		if _g_.m.p != 0 {
  0x42e0d7		7409			JE 0x42e0e2		
			_g_.m.p.ptr().m = 0
  0x42e0d9		90			NOPL			
  0x42e0da		48c7434000000000	MOVQ $0x0, 0x40(BX)	
		_g_.m.p = 0
  0x42e0e2		488b5130		MOVQ 0x30(CX), DX	
  0x42e0e6		48c782d000000000000000	MOVQ $0x0, 0xd0(DX)	
		_g_.m.mcache = nil
  0x42e0f1		488b5130		MOVQ 0x30(CX), DX	
  0x42e0f5		48c7826001000000000000	MOVQ $0x0, 0x160(DX)	
		p := allp[0]
  0x42e100		488b1519390900		MOVQ runtime.allp(SB), DX	
  0x42e107		48833d1939090000	CMPQ $0x0, runtime.allp+8(SB)	
  0x42e10f		0f8646030000		JBE 0x42e45b			
  0x42e115		488b02			MOVQ 0(DX), AX			
		p.m = 0
  0x42e118		48c7404000000000	MOVQ $0x0, 0x40(AX)	
		p.status = _Pidle
  0x42e120		c7400c00000000		MOVL $0x0, 0xc(AX)	
		acquirep(p)
  0x42e127		48890424		MOVQ AX, 0(SP)			
  0x42e12b		e8a0030000		CALL runtime.acquirep(SB)	
		if trace.enabled {
  0x42e130		803d99ea090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42e137		0f8521010000		JNE 0x42e25e			
	for i := nprocs - 1; i >= 0; i-- {
  0x42e13d		8b8424b0000000		MOVL 0xb0(SP), AX	
  0x42e144		8d48ff			LEAL -0x1(AX), CX	
  0x42e147		488b942490000000	MOVQ 0x90(SP), DX	
  0x42e14f		31db			XORL BX, BX		
  0x42e151		eb02			JMP 0x42e155		
  0x42e153		ffc9			DECL CX			
			p.link.set(runnablePs)
  0x42e155		48895c2478		MOVQ BX, 0x78(SP)	
	for i := nprocs - 1; i >= 0; i-- {
  0x42e15a		85c9			TESTL CX, CX		
  0x42e15c		0f8cbb000000		JL 0x42e21d		
		p := allp[i]
  0x42e162		488b35b7380900		MOVQ runtime.allp(SB), SI	
  0x42e169		4863f9			MOVSXD CX, DI			
  0x42e16c		48393db5380900		CMPQ DI, runtime.allp+8(SB)	
  0x42e173		0f86db020000		JBE 0x42e454			
		if _g_.m.p.ptr() == p {
  0x42e179		4c8b4230		MOVQ 0x30(DX), R8	
		p := allp[i]
  0x42e17d		488b34fe		MOVQ 0(SI)(DI*8), SI	
		if _g_.m.p.ptr() == p {
  0x42e181		498bb8d0000000		MOVQ 0xd0(R8), DI	
  0x42e188		90			NOPL			
  0x42e189		4839f7			CMPQ SI, DI		
  0x42e18c		74c5			JE 0x42e153		
	for i := nprocs - 1; i >= 0; i-- {
  0x42e18e		894c244c		MOVL CX, 0x4c(SP)	
		p := allp[i]
  0x42e192		4889b42488000000	MOVQ SI, 0x88(SP)	
		p.status = _Pidle
  0x42e19a		c7460c00000000		MOVL $0x0, 0xc(SI)	
		if runqempty(p) {
  0x42e1a1		48893424		MOVQ SI, 0(SP)			
  0x42e1a5		e866220000		CALL runtime.runqempty(SB)	
  0x42e1aa		807c240800		CMPB $0x0, 0x8(SP)		
  0x42e1af		7554			JNE 0x42e205			
			p.m.set(mget())
  0x42e1b1		90			NOPL			
	mp := sched.midle.ptr()
  0x42e1b2		488b05ff3a0900		MOVQ runtime.sched+24(SB), AX	
  0x42e1b9		90			NOPL				
	if mp != nil {
  0x42e1ba		4885c0			TESTQ AX, AX		
  0x42e1bd		7414			JE 0x42e1d3		
		sched.midle = mp.schedlink
  0x42e1bf		488b8858010000		MOVQ 0x158(AX), CX		
  0x42e1c6		48890deb3a0900		MOVQ CX, runtime.sched+24(SB)	
		sched.nmidle--
  0x42e1cd		ff0ded3a0900		DECL runtime.sched+32(SB)	
			p.m.set(mget())
  0x42e1d3		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42e1d4		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x42e1dc		48894140		MOVQ AX, 0x40(CX)	
			p.link.set(runnablePs)
  0x42e1e0		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42e1e1		488b442478		MOVQ 0x78(SP), AX	
  0x42e1e6		48894110		MOVQ AX, 0x10(CX)	
	stealOrder.reset(uint32(nprocs))
  0x42e1ea		8b8424b0000000		MOVL 0xb0(SP), AX	
		if _g_.m.p.ptr() == p {
  0x42e1f1		488b942490000000	MOVQ 0x90(SP), DX	
			p.link.set(runnablePs)
  0x42e1f9		4889cb			MOVQ CX, BX		
	for i := nprocs - 1; i >= 0; i-- {
  0x42e1fc		8b4c244c		MOVL 0x4c(SP), CX	
  0x42e200		e94effffff		JMP 0x42e153		
			pidleput(p)
  0x42e205		488b842488000000	MOVQ 0x88(SP), AX		
  0x42e20d		48890424		MOVQ AX, 0(SP)			
  0x42e211		e86a210000		CALL runtime.pidleput(SB)	
			p.link.set(runnablePs)
  0x42e216		488b4c2478		MOVQ 0x78(SP), CX	
			pidleput(p)
  0x42e21b		ebcd			JMP 0x42e1ea		
	stealOrder.reset(uint32(nprocs))
  0x42e21d		488d0d1c390900		LEAQ runtime.stealOrder(SB), CX		
  0x42e224		48890c24		MOVQ CX, 0(SP)				
  0x42e228		89442408		MOVL AX, 0x8(SP)			
  0x42e22c		e83f280000		CALL runtime.(*randomOrder).reset(SB)	
	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))
  0x42e231		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x42e238		488d0da1ea0a00		LEAQ runtime.gomaxprocs(SB), CX	
  0x42e23f		8701			XCHGL AX, 0(CX)			
	return runnablePs
  0x42e241		488b442478		MOVQ 0x78(SP), AX	
  0x42e246		48898424b8000000	MOVQ AX, 0xb8(SP)	
  0x42e24e		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x42e256		4881c4a8000000		ADDQ $0xa8, SP		
  0x42e25d		c3			RET			
			traceGoStart()
  0x42e25e		e82ded0000		CALL runtime.traceGoStart(SB)	
  0x42e263		e9d5feffff		JMP 0x42e13d			
		_g_.m.p.ptr().status = _Prunning
  0x42e268		90			NOPL			
  0x42e269		c7420c01000000		MOVL $0x1, 0xc(DX)	
		_g_.m.p.ptr().mcache.prepareForSweep()
  0x42e270		488b4130		MOVQ 0x30(CX), AX				
  0x42e274		488b80d0000000		MOVQ 0xd0(AX), AX				
  0x42e27b		90			NOPL						
  0x42e27c		488b4048		MOVQ 0x48(AX), AX				
  0x42e280		48890424		MOVQ AX, 0(SP)					
  0x42e284		e88727feff		CALL runtime.(*mcache).prepareForSweep(SB)	
  0x42e289		e9affeffff		JMP 0x42e13d					
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42e28e		4889d3			MOVQ DX, BX		
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42e291		e941feffff		JMP 0x42e0d7		
		lock(&allpLock)
  0x42e296		488d058bea0a00		LEAQ runtime.allpLock(SB), AX	
  0x42e29d		48890424		MOVQ AX, 0(SP)			
  0x42e2a1		e83aa4fdff		CALL runtime.lock(SB)		
		allp = allp[:nprocs]
  0x42e2a6		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x42e2ad		4863c8			MOVSXD AX, CX			
  0x42e2b0		488b1579370900		MOVQ runtime.allp+16(SB), DX	
  0x42e2b7		4885c9			TESTQ CX, CX			
  0x42e2ba		0f8ca2010000		JL 0x42e462			
  0x42e2c0		4839d1			CMPQ DX, CX			
  0x42e2c3		0f8799010000		JA 0x42e462			
  0x42e2c9		48890d58370900		MOVQ CX, runtime.allp+8(SB)	
		unlock(&allpLock)
  0x42e2d0		488d0551ea0a00		LEAQ runtime.allpLock(SB), AX	
  0x42e2d7		48890424		MOVQ AX, 0(SP)			
  0x42e2db		e8b0a5fdff		CALL runtime.unlock(SB)		
	if _g_.m.p != 0 && _g_.m.p.ptr().id < nprocs {
  0x42e2e0		8b8424b0000000		MOVL 0xb0(SP), AX	
		unlock(&allpLock)
  0x42e2e7		e9b6fdffff		JMP 0x42e0a2		
		lock(&allpLock)
  0x42e2ec		488d0535ea0a00		LEAQ runtime.allpLock(SB), AX	
  0x42e2f3		48890424		MOVQ AX, 0(SP)			
  0x42e2f7		e8e4a3fdff		CALL runtime.lock(SB)		
		if nprocs <= int32(cap(allp)) {
  0x42e2fc		488b052d370900		MOVQ runtime.allp+16(SB), AX	
  0x42e303		8b8c24b0000000		MOVL 0xb0(SP), CX		
  0x42e30a		39c1			CMPL AX, CX			
  0x42e30c		7f3c			JG 0x42e34a			
			allp = allp[:nprocs]
  0x42e30e		4863d1			MOVSXD CX, DX			
  0x42e311		4885d2			TESTQ DX, DX			
  0x42e314		0f8c7f010000		JL 0x42e499			
  0x42e31a		4839c2			CMPQ AX, DX			
  0x42e31d		0f8776010000		JA 0x42e499			
  0x42e323		488915fe360900		MOVQ DX, runtime.allp+8(SB)	
		unlock(&allpLock)
  0x42e32a		488d05f7e90a00		LEAQ runtime.allpLock(SB), AX	
  0x42e331		48890424		MOVQ AX, 0(SP)			
  0x42e335		e856a5fdff		CALL runtime.unlock(SB)		
	for i := int32(0); i < nprocs; i++ {
  0x42e33a		8b8c24b0000000		MOVL 0xb0(SP), CX	
	if old < 0 || nprocs <= 0 {
  0x42e341		8b542440		MOVL 0x40(SP), DX	
		unlock(&allpLock)
  0x42e345		e9b1f7ffff		JMP 0x42dafb		
			nallp := make([]*p, nprocs)
  0x42e34a		488d052f9f0200		LEAQ 0x29f2f(IP), AX		
  0x42e351		48890424		MOVQ AX, 0(SP)			
  0x42e355		4863d1			MOVSXD CX, DX			
  0x42e358		4889542450		MOVQ DX, 0x50(SP)		
  0x42e35d		4889542408		MOVQ DX, 0x8(SP)		
  0x42e362		4889542410		MOVQ DX, 0x10(SP)		
  0x42e367		e814790000		CALL runtime.makeslice(SB)	
  0x42e36c		488b442418		MOVQ 0x18(SP), AX		
  0x42e371		4889842498000000	MOVQ AX, 0x98(SP)		
			copy(nallp, allp[:cap(allp)])
  0x42e379		488b0da0360900		MOVQ runtime.allp(SB), CX	
  0x42e380		488b15a9360900		MOVQ runtime.allp+16(SB), DX	
  0x42e387		488d1df29e0200		LEAQ 0x29ef2(IP), BX		
  0x42e38e		48891c24		MOVQ BX, 0(SP)			
  0x42e392		4889442408		MOVQ AX, 0x8(SP)		
  0x42e397		488b5c2450		MOVQ 0x50(SP), BX		
  0x42e39c		48895c2410		MOVQ BX, 0x10(SP)		
  0x42e3a1		48895c2418		MOVQ BX, 0x18(SP)		
  0x42e3a6		48894c2420		MOVQ CX, 0x20(SP)		
  0x42e3ab		4889542428		MOVQ DX, 0x28(SP)		
  0x42e3b0		4889542430		MOVQ DX, 0x30(SP)		
  0x42e3b5		e846f3fdff		CALL runtime.typedslicecopy(SB)	
			allp = nallp
  0x42e3ba		488b442450		MOVQ 0x50(SP), AX			
  0x42e3bf		48890562360900		MOVQ AX, runtime.allp+8(SB)		
  0x42e3c6		48890563360900		MOVQ AX, runtime.allp+16(SB)		
  0x42e3cd		833d4cea0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x42e3d4		7514			JNE 0x42e3ea				
  0x42e3d6		488b842498000000	MOVQ 0x98(SP), AX			
  0x42e3de		4889053b360900		MOVQ AX, runtime.allp(SB)		
  0x42e3e5		e940ffffff		JMP 0x42e32a				
  0x42e3ea		488d3d2f360900		LEAQ runtime.allp(SB), DI		
  0x42e3f1		488b842498000000	MOVQ 0x98(SP), AX			
  0x42e3f9		e882b20100		CALL runtime.gcWriteBarrier(SB)		
  0x42e3fe		e927ffffff		JMP 0x42e32a				
	if old < 0 || nprocs <= 0 {
  0x42e403		8b542440		MOVL 0x40(SP), DX	
	sched.procresizetime = now
  0x42e407		4889c6			MOVQ AX, SI		
	if sched.procresizetime != 0 {
  0x42e40a		e9cff6ffff		JMP 0x42dade		
		traceGomaxprocs(nprocs)
  0x42e40f		90			NOPL			
	traceEvent(traceEvGomaxprocs, 1, uint64(procs))
  0x42e410		48c744246000000000	MOVQ $0x0, 0x60(SP)		
  0x42e419		4863c1			MOVSXD CX, AX			
  0x42e41c		4889442460		MOVQ AX, 0x60(SP)		
  0x42e421		c6042404		MOVB $0x4, 0(SP)		
  0x42e425		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42e42e		488d442460		LEAQ 0x60(SP), AX		
  0x42e433		4889442410		MOVQ AX, 0x10(SP)		
  0x42e438		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x42e441		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x42e44a		e851da0000		CALL runtime.traceEvent(SB)	
	now := nanotime()
  0x42e44f		e959f6ffff		JMP 0x42daad		
		p := allp[i]
  0x42e454		e8c73affff		CALL runtime.panicindex(SB)	
  0x42e459		0f0b			UD2				
		p := allp[0]
  0x42e45b		e8c03affff		CALL runtime.panicindex(SB)	
  0x42e460		0f0b			UD2				
		allp = allp[:nprocs]
  0x42e462		e8e93bffff		CALL runtime.panicslice(SB)	
  0x42e467		0f0b			UD2				
		p := allp[i]
  0x42e469		e8b23affff		CALL runtime.panicindex(SB)	
  0x42e46e		0f0b			UD2				
					throw("missing mcache?")
  0x42e470		488d05281a0400		LEAQ 0x41a28(IP), AX	
  0x42e477		48890424		MOVQ AX, 0(SP)		
  0x42e47b		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x42e484		e8f74fffff		CALL runtime.throw(SB)	
  0x42e489		0f0b			UD2			
			atomicstorep(unsafe.Pointer(&allp[i]), unsafe.Pointer(pp))
  0x42e48b		e8903affff		CALL runtime.panicindex(SB)	
  0x42e490		0f0b			UD2				
		pp := allp[i]
  0x42e492		e8893affff		CALL runtime.panicindex(SB)	
  0x42e497		0f0b			UD2				
			allp = allp[:nprocs]
  0x42e499		e8b23bffff		CALL runtime.panicslice(SB)	
  0x42e49e		0f0b			UD2				
		throw("procresize: invalid arg")
  0x42e4a0		488d0530280400		LEAQ 0x42830(IP), AX	
  0x42e4a7		48890424		MOVQ AX, 0(SP)		
  0x42e4ab		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x42e4b4		e8c74fffff		CALL runtime.throw(SB)	
  0x42e4b9		0f0b			UD2			
func procresize(nprocs int32) *p {
  0x42e4bb		e8c0930100		CALL runtime.morestack_noctxt(SB)	
  0x42e4c0		e98bf5ffff		JMP runtime.procresize(SB)		

TEXT runtime.acquirep(SB) /usr/local/go/src/runtime/proc.go
func acquirep(_p_ *p) {
  0x42e4d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e4d9		483b6110		CMPQ 0x10(CX), SP	
  0x42e4dd		7648			JBE 0x42e527		
  0x42e4df		4883ec10		SUBQ $0x10, SP		
  0x42e4e3		48896c2408		MOVQ BP, 0x8(SP)	
  0x42e4e8		488d6c2408		LEAQ 0x8(SP), BP	
	wirep(_p_)
  0x42e4ed		488b442418		MOVQ 0x18(SP), AX	
  0x42e4f2		48890424		MOVQ AX, 0(SP)		
  0x42e4f6		e835000000		CALL runtime.wirep(SB)	
	_p_.mcache.prepareForSweep()
  0x42e4fb		488b442418		MOVQ 0x18(SP), AX				
  0x42e500		488b4048		MOVQ 0x48(AX), AX				
  0x42e504		48890424		MOVQ AX, 0(SP)					
  0x42e508		e80325feff		CALL runtime.(*mcache).prepareForSweep(SB)	
	if trace.enabled {
  0x42e50d		803dbce6090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42e514		750a			JNE 0x42e520			
  0x42e516		488b6c2408		MOVQ 0x8(SP), BP		
  0x42e51b		4883c410		ADDQ $0x10, SP			
  0x42e51f		c3			RET				
		traceProcStart()
  0x42e520		e81be60000		CALL runtime.traceProcStart(SB)	
  0x42e525		ebef			JMP 0x42e516			
func acquirep(_p_ *p) {
  0x42e527		e854930100		CALL runtime.morestack_noctxt(SB)	
  0x42e52c		eba2			JMP runtime.acquirep(SB)		

TEXT runtime.wirep(SB) /usr/local/go/src/runtime/proc.go
func wirep(_p_ *p) {
  0x42e530		4883ec30		SUBQ $0x30, SP		
  0x42e534		48896c2428		MOVQ BP, 0x28(SP)	
  0x42e539		488d6c2428		LEAQ 0x28(SP), BP	
	_g_ := getg()
  0x42e53e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.p != 0 || _g_.m.mcache != nil {
  0x42e547		488b4830		MOVQ 0x30(AX), CX	
  0x42e54b		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x42e553		0f851b010000		JNE 0x42e674		
  0x42e559		4883b96001000000	CMPQ $0x0, 0x160(CX)	
  0x42e561		0f850d010000		JNE 0x42e674		
	if _p_.m != 0 || _p_.status != _Pidle {
  0x42e567		488b542438		MOVQ 0x38(SP), DX	
  0x42e56c		488b5a40		MOVQ 0x40(DX), BX	
  0x42e570		4885db			TESTQ BX, BX		
  0x42e573		753d			JNE 0x42e5b2		
  0x42e575		837a0c00		CMPL $0x0, 0xc(DX)	
  0x42e579		7534			JNE 0x42e5af		
	_g_.m.mcache = _p_.mcache
  0x42e57b		488b5a48		MOVQ 0x48(DX), BX	
  0x42e57f		48899960010000		MOVQ BX, 0x160(CX)	
	_g_.m.p.set(_p_)
  0x42e586		488b4830		MOVQ 0x30(AX), CX	
  0x42e58a		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42e58b		4889d3			MOVQ DX, BX		
  0x42e58e		488991d0000000		MOVQ DX, 0xd0(CX)	
	_p_.m.set(_g_.m)
  0x42e595		90			NOPL			
  0x42e596		488b4030		MOVQ 0x30(AX), AX	
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x42e59a		48894340		MOVQ AX, 0x40(BX)	
	_p_.status = _Prunning
  0x42e59e		c7430c01000000		MOVL $0x1, 0xc(BX)	
}
  0x42e5a5		488b6c2428		MOVQ 0x28(SP), BP	
  0x42e5aa		4883c430		ADDQ $0x30, SP		
  0x42e5ae		c3			RET			
	if _p_.m != 0 || _p_.status != _Pidle {
  0x42e5af		4885db			TESTQ BX, BX		
  0x42e5b2		48895c2420		MOVQ BX, 0x20(SP)	
		if _p_.m != 0 {
  0x42e5b7		740d			JE 0x42e5c6		
			id = _p_.m.ptr().id
  0x42e5b9		90			NOPL			
  0x42e5ba		488b8be8000000		MOVQ 0xe8(BX), CX	
		print("wirep: p->m=", _p_.m, "(", id, ") p->status=", _p_.status, "\n")
  0x42e5c1		4889c8			MOVQ CX, AX		
			id = _p_.m.ptr().id
  0x42e5c4		eb02			JMP 0x42e5c8		
  0x42e5c6		31c0			XORL AX, AX		
		print("wirep: p->m=", _p_.m, "(", id, ") p->status=", _p_.status, "\n")
  0x42e5c8		4889442410		MOVQ AX, 0x10(SP)		
  0x42e5cd		8b4a0c			MOVL 0xc(DX), CX		
  0x42e5d0		48894c2418		MOVQ CX, 0x18(SP)		
  0x42e5d5		e8e658ffff		CALL runtime.printlock(SB)	
  0x42e5da		488d055c150400		LEAQ 0x4155c(IP), AX		
  0x42e5e1		48890424		MOVQ AX, 0(SP)			
  0x42e5e5		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42e5ee		e8fd61ffff		CALL runtime.printstring(SB)	
  0x42e5f3		488b442420		MOVQ 0x20(SP), AX		
  0x42e5f8		48890424		MOVQ AX, 0(SP)			
  0x42e5fc		e83f5fffff		CALL runtime.printuint(SB)	
  0x42e601		488d05790a0400		LEAQ 0x40a79(IP), AX		
  0x42e608		48890424		MOVQ AX, 0(SP)			
  0x42e60c		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42e615		e8d661ffff		CALL runtime.printstring(SB)	
  0x42e61a		488b442410		MOVQ 0x10(SP), AX		
  0x42e61f		48890424		MOVQ AX, 0(SP)			
  0x42e623		e81860ffff		CALL runtime.printint(SB)	
  0x42e628		488d052a140400		LEAQ 0x4142a(IP), AX		
  0x42e62f		48890424		MOVQ AX, 0(SP)			
  0x42e633		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42e63c		e8af61ffff		CALL runtime.printstring(SB)	
  0x42e641		488b442418		MOVQ 0x18(SP), AX		
  0x42e646		48890424		MOVQ AX, 0(SP)			
  0x42e64a		e8f15effff		CALL runtime.printuint(SB)	
  0x42e64f		e8fc5affff		CALL runtime.printnl(SB)	
  0x42e654		e8e758ffff		CALL runtime.printunlock(SB)	
		throw("wirep: invalid p state")
  0x42e659		488d05f1240400		LEAQ 0x424f1(IP), AX	
  0x42e660		48890424		MOVQ AX, 0(SP)		
  0x42e664		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x42e66d		e80e4effff		CALL runtime.throw(SB)	
  0x42e672		0f0b			UD2			
		throw("wirep: already in go")
  0x42e674		488d050e210400		LEAQ 0x4210e(IP), AX	
  0x42e67b		48890424		MOVQ AX, 0(SP)		
  0x42e67f		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x42e688		e8f34dffff		CALL runtime.throw(SB)	
  0x42e68d		0f0b			UD2			

TEXT runtime.releasep(SB) /usr/local/go/src/runtime/proc.go
func releasep() *p {
  0x42e690		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e699		483b6110		CMPQ 0x10(CX), SP	
  0x42e69d		0f8607020000		JBE 0x42e8aa		
  0x42e6a3		4883ec50		SUBQ $0x50, SP		
  0x42e6a7		48896c2448		MOVQ BP, 0x48(SP)	
  0x42e6ac		488d6c2448		LEAQ 0x48(SP), BP	
	_g_ := getg()
  0x42e6b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if _g_.m.p == 0 || _g_.m.mcache == nil {
  0x42e6ba		488b4830		MOVQ 0x30(AX), CX	
  0x42e6be		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x42e6c5		4885d2			TESTQ DX, DX		
  0x42e6c8		0f84c1010000		JE 0x42e88f		
  0x42e6ce		488b9960010000		MOVQ 0x160(CX), BX	
  0x42e6d5		4885db			TESTQ BX, BX		
  0x42e6d8		0f84b1010000		JE 0x42e88f		
  0x42e6de		48894c2440		MOVQ CX, 0x40(SP)	
  0x42e6e3		48895c2438		MOVQ BX, 0x38(SP)	
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x42e6e8		4889542430		MOVQ DX, 0x30(SP)	
	_p_ := _g_.m.p.ptr()
  0x42e6ed		90			NOPL			
	if _p_.m.ptr() != _g_.m || _p_.mcache != _g_.m.mcache || _p_.status != _Prunning {
  0x42e6ee		488b7240		MOVQ 0x40(DX), SI	
  0x42e6f2		4889742410		MOVQ SI, 0x10(SP)	
  0x42e6f7		90			NOPL			
  0x42e6f8		4839ce			CMPQ CX, SI		
  0x42e6fb		756c			JNE 0x42e769		
  0x42e6fd		48395a48		CMPQ BX, 0x48(DX)	
  0x42e701		7566			JNE 0x42e769		
  0x42e703		837a0c01		CMPL $0x1, 0xc(DX)	
  0x42e707		7560			JNE 0x42e769		
	if trace.enabled {
  0x42e709		803dc0e4090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42e710		753c			JNE 0x42e74e			
	_g_.m.p = 0
  0x42e712		488b4830		MOVQ 0x30(AX), CX	
  0x42e716		48c781d000000000000000	MOVQ $0x0, 0xd0(CX)	
	_g_.m.mcache = nil
  0x42e721		488b4030		MOVQ 0x30(AX), AX	
  0x42e725		48c7806001000000000000	MOVQ $0x0, 0x160(AX)	
	_p_.m = 0
  0x42e730		48c7424000000000	MOVQ $0x0, 0x40(DX)	
	_p_.status = _Pidle
  0x42e738		c7420c00000000		MOVL $0x0, 0xc(DX)	
	return _p_
  0x42e73f		4889542458		MOVQ DX, 0x58(SP)	
  0x42e744		488b6c2448		MOVQ 0x48(SP), BP	
  0x42e749		4883c450		ADDQ $0x50, SP		
  0x42e74d		c3			RET			
	_g_ := getg()
  0x42e74e		4889442420		MOVQ AX, 0x20(SP)	
		traceProcStop(_g_.m.p.ptr())
  0x42e753		90			NOPL				
  0x42e754		48891424		MOVQ DX, 0(SP)			
  0x42e758		e863e40000		CALL runtime.traceProcStop(SB)	
	_g_.m.p = 0
  0x42e75d		488b442420		MOVQ 0x20(SP), AX	
	_p_.m = 0
  0x42e762		488b542430		MOVQ 0x30(SP), DX	
		traceProcStop(_g_.m.p.ptr())
  0x42e767		eba9			JMP 0x42e712		
		print("releasep: m=", _g_.m, " m->p=", _g_.m.p.ptr(), " p->m=", _p_.m, " m->mcache=", _g_.m.mcache, " p->mcache=", _p_.mcache, " p->status=", _p_.status, "\n")
  0x42e769		90			NOPL				
  0x42e76a		488b4248		MOVQ 0x48(DX), AX		
  0x42e76e		4889442428		MOVQ AX, 0x28(SP)		
  0x42e773		8b4a0c			MOVL 0xc(DX), CX		
  0x42e776		48894c2418		MOVQ CX, 0x18(SP)		
  0x42e77b		e84057ffff		CALL runtime.printlock(SB)	
  0x42e780		488d059e130400		LEAQ 0x4139e(IP), AX		
  0x42e787		48890424		MOVQ AX, 0(SP)			
  0x42e78b		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42e794		e85760ffff		CALL runtime.printstring(SB)	
  0x42e799		488b442440		MOVQ 0x40(SP), AX		
  0x42e79e		48890424		MOVQ AX, 0(SP)			
  0x42e7a2		e80960ffff		CALL runtime.printpointer(SB)	
  0x42e7a7		488d05a20a0400		LEAQ 0x40aa2(IP), AX		
  0x42e7ae		48890424		MOVQ AX, 0(SP)			
  0x42e7b2		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42e7bb		e83060ffff		CALL runtime.printstring(SB)	
  0x42e7c0		488b442430		MOVQ 0x30(SP), AX		
  0x42e7c5		48890424		MOVQ AX, 0(SP)			
  0x42e7c9		e8e25fffff		CALL runtime.printpointer(SB)	
  0x42e7ce		488d05870a0400		LEAQ 0x40a87(IP), AX		
  0x42e7d5		48890424		MOVQ AX, 0(SP)			
  0x42e7d9		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42e7e2		e80960ffff		CALL runtime.printstring(SB)	
  0x42e7e7		488b442410		MOVQ 0x10(SP), AX		
  0x42e7ec		48890424		MOVQ AX, 0(SP)			
  0x42e7f0		e84b5dffff		CALL runtime.printuint(SB)	
  0x42e7f5		488d0567100400		LEAQ 0x41067(IP), AX		
  0x42e7fc		48890424		MOVQ AX, 0(SP)			
  0x42e800		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42e809		e8e25fffff		CALL runtime.printstring(SB)	
  0x42e80e		488b442438		MOVQ 0x38(SP), AX		
  0x42e813		48890424		MOVQ AX, 0(SP)			
  0x42e817		e8945fffff		CALL runtime.printpointer(SB)	
  0x42e81c		488d056c100400		LEAQ 0x4106c(IP), AX		
  0x42e823		48890424		MOVQ AX, 0(SP)			
  0x42e827		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42e830		e8bb5fffff		CALL runtime.printstring(SB)	
  0x42e835		488b442428		MOVQ 0x28(SP), AX		
  0x42e83a		48890424		MOVQ AX, 0(SP)			
  0x42e83e		e86d5fffff		CALL runtime.printpointer(SB)	
  0x42e843		488d0550100400		LEAQ 0x41050(IP), AX		
  0x42e84a		48890424		MOVQ AX, 0(SP)			
  0x42e84e		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42e857		e8945fffff		CALL runtime.printstring(SB)	
  0x42e85c		488b442418		MOVQ 0x18(SP), AX		
  0x42e861		48890424		MOVQ AX, 0(SP)			
  0x42e865		e8d65cffff		CALL runtime.printuint(SB)	
  0x42e86a		e8e158ffff		CALL runtime.printnl(SB)	
  0x42e86f		e8cc56ffff		CALL runtime.printunlock(SB)	
		throw("releasep: invalid p state")
  0x42e874		488d0502280400		LEAQ 0x42802(IP), AX	
  0x42e87b		48890424		MOVQ AX, 0(SP)		
  0x42e87f		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42e888		e8f34bffff		CALL runtime.throw(SB)	
  0x42e88d		0f0b			UD2			
		throw("releasep: invalid arg")
  0x42e88f		488d05d71f0400		LEAQ 0x41fd7(IP), AX	
  0x42e896		48890424		MOVQ AX, 0(SP)		
  0x42e89a		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42e8a3		e8d84bffff		CALL runtime.throw(SB)	
  0x42e8a8		0f0b			UD2			
func releasep() *p {
  0x42e8aa		e8d18f0100		CALL runtime.morestack_noctxt(SB)	
  0x42e8af		e9dcfdffff		JMP runtime.releasep(SB)		

TEXT runtime.incidlelocked(SB) /usr/local/go/src/runtime/proc.go
func incidlelocked(v int32) {
  0x42e8c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e8c9		483b6110		CMPQ 0x10(CX), SP	
  0x42e8cd		764d			JBE 0x42e91c		
  0x42e8cf		4883ec10		SUBQ $0x10, SP		
  0x42e8d3		48896c2408		MOVQ BP, 0x8(SP)	
  0x42e8d8		488d6c2408		LEAQ 0x8(SP), BP	
	lock(&sched.lock)
  0x42e8dd		488d05cc330900		LEAQ runtime.sched+16(SB), AX	
  0x42e8e4		48890424		MOVQ AX, 0(SP)			
  0x42e8e8		e8f39dfdff		CALL runtime.lock(SB)		
	sched.nmidlelocked += v
  0x42e8ed		8b442418		MOVL 0x18(SP), AX		
  0x42e8f1		0105cd330900		ADDL AX, runtime.sched+36(SB)	
	if v > 0 {
  0x42e8f7		85c0			TESTL AX, AX		
  0x42e8f9		7f1a			JG 0x42e915		
	unlock(&sched.lock)
  0x42e8fb		488d05ae330900		LEAQ runtime.sched+16(SB), AX	
  0x42e902		48890424		MOVQ AX, 0(SP)			
  0x42e906		e8859ffdff		CALL runtime.unlock(SB)		
}
  0x42e90b		488b6c2408		MOVQ 0x8(SP), BP	
  0x42e910		4883c410		ADDQ $0x10, SP		
  0x42e914		c3			RET			
		checkdead()
  0x42e915		e816000000		CALL runtime.checkdead(SB)	
  0x42e91a		ebdf			JMP 0x42e8fb			
func incidlelocked(v int32) {
  0x42e91c		e85f8f0100		CALL runtime.morestack_noctxt(SB)	
  0x42e921		eb9d			JMP runtime.incidlelocked(SB)		

TEXT runtime.checkdead(SB) /usr/local/go/src/runtime/proc.go
func checkdead() {
  0x42e930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42e939		483b6110		CMPQ 0x10(CX), SP	
  0x42e93d		0f8658040000		JBE 0x42ed9b		
  0x42e943		4883ec58		SUBQ $0x58, SP		
  0x42e947		48896c2450		MOVQ BP, 0x50(SP)	
  0x42e94c		488d6c2450		LEAQ 0x50(SP), BP	
	if islibrary || isarchive {
  0x42e951		803d57e30a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x42e958		0f8531020000		JNE 0x42eb8f				
  0x42e95e		803d48e30a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x42e965		0f8524020000		JNE 0x42eb8f				
	if panicking > 0 {
  0x42e96b		833d82e30a0000		CMPL $0x0, runtime.panicking(SB)	
  0x42e972		0f870d020000		JA 0x42eb85				
	if !iscgo && cgoHasExtraM {
  0x42e978		803d2fe30a0000		CMPB $0x0, runtime.iscgo(SB)	
  0x42e97f		0f84e9010000		JE 0x42eb6e			
  0x42e985		31c0			XORL AX, AX			
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42e987		90			NOPL				
  0x42e988		8b0d32330900		MOVL runtime.sched+32(SB), CX	
	return int32(sched.mnext - sched.nmfreed)
  0x42e98e		488b1533330900		MOVQ runtime.sched+40(SB), DX	
  0x42e995		482b153c330900		SUBQ runtime.sched+56(SB), DX	
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42e99c		4889d3			MOVQ DX, BX			
  0x42e99f		29ca			SUBL CX, DX			
  0x42e9a1		8b351d330900		MOVL runtime.sched+36(SB), SI	
  0x42e9a7		29f2			SUBL SI, DX			
  0x42e9a9		8b3d25330900		MOVL runtime.sched+52(SB), DI	
  0x42e9af		29fa			SUBL DI, DX			
	if run > run0 {
  0x42e9b1		39c2			CMPL AX, DX		
  0x42e9b3		0f8fab010000		JG 0x42eb64		
	if run < 0 {
  0x42e9b9		85d2			TESTL DX, DX		
  0x42e9bb		0f8cf9020000		JL 0x42ecba		
	lock(&allglock)
  0x42e9c1		488d0558e30a00		LEAQ runtime.allglock(SB), AX	
  0x42e9c8		48890424		MOVQ AX, 0(SP)			
  0x42e9cc		e80f9dfdff		CALL runtime.lock(SB)		
  0x42e9d1		31c0			XORL AX, AX			
  0x42e9d3		31c9			XORL CX, CX			
	for i := 0; i < len(allgs); i++ {
  0x42e9d5		eb0e			JMP 0x42e9e5		
  0x42e9d7		488b542428		MOVQ 0x28(SP), DX	
  0x42e9dc		48ffc2			INCQ DX			
			grunning++
  0x42e9df		4889c1			MOVQ AX, CX		
	for i := 0; i < len(allgs); i++ {
  0x42e9e2		4889d0			MOVQ DX, AX		
			grunning++
  0x42e9e5		48894c2430		MOVQ CX, 0x30(SP)	
	for i := 0; i < len(allgs); i++ {
  0x42e9ea		488b150f300900		MOVQ runtime.allgs(SB), DX	
  0x42e9f1		48390510300900		CMPQ AX, runtime.allgs+8(SB)	
  0x42e9f8		7e5a			JLE 0x42ea54			
  0x42e9fa		4889442428		MOVQ AX, 0x28(SP)		
		gp := allgs[i]
  0x42e9ff		488b0cc2		MOVQ 0(DX)(AX*8), CX	
  0x42ea03		48894c2440		MOVQ CX, 0x40(SP)	
		if isSystemGoroutine(gp, false) {
  0x42ea08		48890c24		MOVQ CX, 0(SP)				
  0x42ea0c		c644240800		MOVB $0x0, 0x8(SP)			
  0x42ea11		e8fa260100		CALL runtime.isSystemGoroutine(SB)	
  0x42ea16		807c241000		CMPB $0x0, 0x10(SP)			
  0x42ea1b		7407			JE 0x42ea24				
			grunning++
  0x42ea1d		488b442430		MOVQ 0x30(SP), AX	
			continue
  0x42ea22		ebb3			JMP 0x42e9d7		
		s := readgstatus(gp)
  0x42ea24		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42ea25		488b442440		MOVQ 0x40(SP), AX	
  0x42ea2a		8b8890000000		MOVL 0x90(AX), CX	
		switch s &^ _Gscan {
  0x42ea30		89ca			MOVL CX, DX		
  0x42ea32		0fbaf10c		BTRL $0xc, CX		
		case _Grunnable,
  0x42ea36		8d59ff			LEAL -0x1(CX), BX	
  0x42ea39		83fb02			CMPL $0x2, BX		
  0x42ea3c		0f86da010000		JBE 0x42ec1c		
			grunning++
  0x42ea42		488b442430		MOVQ 0x30(SP), AX	
  0x42ea47		488d5001		LEAQ 0x1(AX), DX	
		case _Gwaiting:
  0x42ea4b		83f904			CMPL $0x4, CX		
			grunning++
  0x42ea4e		480f44c2		CMOVE DX, AX		
		case _Gwaiting:
  0x42ea52		eb83			JMP 0x42e9d7		
	unlock(&allglock)
  0x42ea54		488d05c5e20a00		LEAQ runtime.allglock(SB), AX	
  0x42ea5b		48890424		MOVQ AX, 0(SP)			
  0x42ea5f		e82c9efdff		CALL runtime.unlock(SB)		
	if grunning == 0 { // possible if main goroutine calls runtimeGoexit()
  0x42ea64		488b442430		MOVQ 0x30(SP), AX	
  0x42ea69		4885c0			TESTQ AX, AX		
  0x42ea6c		0f848f010000		JE 0x42ec01		
	gp := timejump()
  0x42ea72		e889d00000		CALL runtime.timejump(SB)	
  0x42ea77		488b0424		MOVQ 0(SP), AX			
	if gp != nil {
  0x42ea7b		4885c0			TESTQ AX, AX		
  0x42ea7e		0f844b010000		JE 0x42ebcf		
	gp := timejump()
  0x42ea84		4889442448		MOVQ AX, 0x48(SP)	
		casgstatus(gp, _Gwaiting, _Grunnable)
  0x42ea89		48b80400000001000000	MOVQ $0x100000004, AX		
  0x42ea93		4889442408		MOVQ AX, 0x8(SP)		
  0x42ea98		e80382ffff		CALL runtime.casgstatus(SB)	
		globrunqput(gp)
  0x42ea9d		90			NOPL			
	sched.runq.pushBack(gp)
  0x42ea9e		90			NOPL			
	gp.schedlink = 0
  0x42ea9f		488b442448		MOVQ 0x48(SP), AX	
  0x42eaa4		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x42eaaf		488b0d4a320900		MOVQ runtime.sched+96(SB), CX	
  0x42eab6		4885c9			TESTQ CX, CX			
  0x42eab9		0f8495000000		JE 0x42eb54			
		q.tail.ptr().schedlink.set(gp)
  0x42eabf		90			NOPL			
  0x42eac0		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42eac1		4889c2			MOVQ AX, DX		
  0x42eac4		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x42eacb		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42eacc		4889152d320900		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x42ead3		ff052f320900		INCL runtime.sched+104(SB)	
		_p_ := pidleget()
  0x42ead9		90			NOPL			
	_p_ := sched.pidle.ptr()
  0x42eada		488b0507320900		MOVQ runtime.sched+72(SB), AX	
  0x42eae1		90			NOPL				
	if _p_ != nil {
  0x42eae2		4885c0			TESTQ AX, AX		
  0x42eae5		741e			JE 0x42eb05		
		sched.pidle = _p_.link
  0x42eae7		488b4810		MOVQ 0x10(AX), CX		
  0x42eaeb		48890df6310900		MOVQ CX, runtime.sched+72(SB)	
		atomic.Xadd(&sched.npidle, -1) // TODO: fast atomic
  0x42eaf2		b9ffffffff		MOVL $-0x1, CX			
  0x42eaf7		488d15f2310900		LEAQ runtime.sched+80(SB), DX	
  0x42eafe		f00fc10a		LOCK XADDL CX, 0(DX)		
	if _p_ != nil {
  0x42eb02		4885c0			TESTQ AX, AX		
		if _p_ == nil {
  0x42eb05		0f84a9000000		JE 0x42ebb4		
		mp := mget()
  0x42eb0b		90			NOPL			
	mp := sched.midle.ptr()
  0x42eb0c		488b0da5310900		MOVQ runtime.sched+24(SB), CX	
  0x42eb13		90			NOPL				
	if mp != nil {
  0x42eb14		4885c9			TESTQ CX, CX		
  0x42eb17		7417			JE 0x42eb30		
		sched.midle = mp.schedlink
  0x42eb19		488b9158010000		MOVQ 0x158(CX), DX		
  0x42eb20		48891591310900		MOVQ DX, runtime.sched+24(SB)	
		sched.nmidle--
  0x42eb27		ff0d93310900		DECL runtime.sched+32(SB)	
	if mp != nil {
  0x42eb2d		4885c9			TESTQ CX, CX		
		if mp == nil {
  0x42eb30		7467			JE 0x42eb99		
		mp.nextp.set(_p_)
  0x42eb32		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x42eb33		488981d8000000		MOVQ AX, 0xd8(CX)	
		notewakeup(&mp.park)
  0x42eb3a		488d8148010000		LEAQ 0x148(CX), AX		
  0x42eb41		48890424		MOVQ AX, 0(SP)			
  0x42eb45		e8169efdff		CALL runtime.notewakeup(SB)	
		return
  0x42eb4a		488b6c2450		MOVQ 0x50(SP), BP	
  0x42eb4f		4883c458		ADDQ $0x58, SP		
  0x42eb53		c3			RET			
		q.head.set(gp)
  0x42eb54		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42eb55		4889c2			MOVQ AX, DX			
  0x42eb58		48890599310900		MOVQ AX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x42eb5f		e967ffffff		JMP 0x42eacb		
		return
  0x42eb64		488b6c2450		MOVQ 0x50(SP), BP	
  0x42eb69		4883c458		ADDQ $0x58, SP		
  0x42eb6d		c3			RET			
	if !iscgo && cgoHasExtraM {
  0x42eb6e		803d30e10a0000		CMPB $0x0, runtime.cgoHasExtraM(SB)	
  0x42eb75		0f840afeffff		JE 0x42e985				
  0x42eb7b		b801000000		MOVL $0x1, AX				
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42eb80		e902feffff		JMP 0x42e987		
		return
  0x42eb85		488b6c2450		MOVQ 0x50(SP), BP	
  0x42eb8a		4883c458		ADDQ $0x58, SP		
  0x42eb8e		c3			RET			
		return
  0x42eb8f		488b6c2450		MOVQ 0x50(SP), BP	
  0x42eb94		4883c458		ADDQ $0x58, SP		
  0x42eb98		c3			RET			
			throw("checkdead: no m for timer")
  0x42eb99		488d0579240400		LEAQ 0x42479(IP), AX	
  0x42eba0		48890424		MOVQ AX, 0(SP)		
  0x42eba4		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42ebad		e8ce48ffff		CALL runtime.throw(SB)	
  0x42ebb2		0f0b			UD2			
			throw("checkdead: no p for timer")
  0x42ebb4		488d0577240400		LEAQ 0x42477(IP), AX	
  0x42ebbb		48890424		MOVQ AX, 0(SP)		
  0x42ebbf		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x42ebc8		e8b348ffff		CALL runtime.throw(SB)	
  0x42ebcd		0f0b			UD2			
	getg().m.throwing = -1 // do not dump full stacks
  0x42ebcf		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x42ebd8		488b4030		MOVQ 0x30(AX), AX	
  0x42ebdc		c780f4000000ffffffff	MOVL $-0x1, 0xf4(AX)	
	throw("all goroutines are asleep - deadlock!")
  0x42ebe6		488d05ac3a0400		LEAQ 0x43aac(IP), AX	
  0x42ebed		48890424		MOVQ AX, 0(SP)		
  0x42ebf1		48c744240825000000	MOVQ $0x25, 0x8(SP)	
  0x42ebfa		e88148ffff		CALL runtime.throw(SB)	
  0x42ebff		0f0b			UD2			
		throw("no goroutines (main called runtime.Goexit) - deadlock!")
  0x42ec01		488d056d470400		LEAQ 0x4476d(IP), AX	
  0x42ec08		48890424		MOVQ AX, 0(SP)		
  0x42ec0c		48c744240836000000	MOVQ $0x36, 0x8(SP)	
  0x42ec15		e86648ffff		CALL runtime.throw(SB)	
  0x42ec1a		0f0b			UD2			
	return atomic.Load(&gp.atomicstatus)
  0x42ec1c		89542424		MOVL DX, 0x24(SP)	
			unlock(&allglock)
  0x42ec20		488d05f9e00a00		LEAQ runtime.allglock(SB), AX	
  0x42ec27		48890424		MOVQ AX, 0(SP)			
  0x42ec2b		e8609cfdff		CALL runtime.unlock(SB)		
			print("runtime: checkdead: find g ", gp.goid, " in status ", s, "\n")
  0x42ec30		488b442440		MOVQ 0x40(SP), AX		
  0x42ec35		488b8098000000		MOVQ 0x98(AX), AX		
  0x42ec3c		4889442438		MOVQ AX, 0x38(SP)		
  0x42ec41		e87a52ffff		CALL runtime.printlock(SB)	
  0x42ec46		488d055f280400		LEAQ 0x4285f(IP), AX		
  0x42ec4d		48890424		MOVQ AX, 0(SP)			
  0x42ec51		48c74424081b000000	MOVQ $0x1b, 0x8(SP)		
  0x42ec5a		e8915bffff		CALL runtime.printstring(SB)	
  0x42ec5f		488b442438		MOVQ 0x38(SP), AX		
  0x42ec64		48890424		MOVQ AX, 0(SP)			
  0x42ec68		e8d359ffff		CALL runtime.printint(SB)	
  0x42ec6d		488d05e40b0400		LEAQ 0x40be4(IP), AX		
  0x42ec74		48890424		MOVQ AX, 0(SP)			
  0x42ec78		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42ec81		e86a5bffff		CALL runtime.printstring(SB)	
  0x42ec86		8b442424		MOVL 0x24(SP), AX		
  0x42ec8a		89c0			MOVL AX, AX			
  0x42ec8c		48890424		MOVQ AX, 0(SP)			
  0x42ec90		e8ab58ffff		CALL runtime.printuint(SB)	
  0x42ec95		e8b654ffff		CALL runtime.printnl(SB)	
  0x42ec9a		e8a152ffff		CALL runtime.printunlock(SB)	
			throw("checkdead: runnable g")
  0x42ec9f		488d055e1b0400		LEAQ 0x41b5e(IP), AX	
  0x42eca6		48890424		MOVQ AX, 0(SP)		
  0x42ecaa		48c744240815000000	MOVQ $0x15, 0x8(SP)	
  0x42ecb3		e8c847ffff		CALL runtime.throw(SB)	
  0x42ecb8		0f0b			UD2			
	return int32(sched.mnext - sched.nmfreed)
  0x42ecba		48895c2438		MOVQ BX, 0x38(SP)	
	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys
  0x42ecbf		894c2420		MOVL CX, 0x20(SP)	
  0x42ecc3		8974241c		MOVL SI, 0x1c(SP)	
  0x42ecc7		897c2418		MOVL DI, 0x18(SP)	
		print("runtime: checkdead: nmidle=", sched.nmidle, " nmidlelocked=", sched.nmidlelocked, " mcount=", mcount(), " nmsys=", sched.nmsys, "\n")
  0x42eccb		90			NOPL				
  0x42eccc		e8ef51ffff		CALL runtime.printlock(SB)	
  0x42ecd1		488d05ef270400		LEAQ 0x427ef(IP), AX		
  0x42ecd8		48890424		MOVQ AX, 0(SP)			
  0x42ecdc		48c74424081b000000	MOVQ $0x1b, 0x8(SP)		
  0x42ece5		e8065bffff		CALL runtime.printstring(SB)	
  0x42ecea		8b442420		MOVL 0x20(SP), AX		
  0x42ecee		4863c0			MOVSXD AX, AX			
  0x42ecf1		48890424		MOVQ AX, 0(SP)			
  0x42ecf5		e84659ffff		CALL runtime.printint(SB)	
  0x42ecfa		488d0503100400		LEAQ 0x41003(IP), AX		
  0x42ed01		48890424		MOVQ AX, 0(SP)			
  0x42ed05		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x42ed0e		e8dd5affff		CALL runtime.printstring(SB)	
  0x42ed13		8b44241c		MOVL 0x1c(SP), AX		
  0x42ed17		4863c0			MOVSXD AX, AX			
  0x42ed1a		48890424		MOVQ AX, 0(SP)			
  0x42ed1e		e81d59ffff		CALL runtime.printint(SB)	
  0x42ed23		488d05c6060400		LEAQ 0x406c6(IP), AX		
  0x42ed2a		48890424		MOVQ AX, 0(SP)			
  0x42ed2e		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x42ed37		e8b45affff		CALL runtime.printstring(SB)	
  0x42ed3c		488b442438		MOVQ 0x38(SP), AX		
  0x42ed41		4863c0			MOVSXD AX, AX			
  0x42ed44		48890424		MOVQ AX, 0(SP)			
  0x42ed48		e8f358ffff		CALL runtime.printint(SB)	
  0x42ed4d		488d057a050400		LEAQ 0x4057a(IP), AX		
  0x42ed54		48890424		MOVQ AX, 0(SP)			
  0x42ed58		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42ed61		e88a5affff		CALL runtime.printstring(SB)	
  0x42ed66		8b442418		MOVL 0x18(SP), AX		
  0x42ed6a		4863c0			MOVSXD AX, AX			
  0x42ed6d		48890424		MOVQ AX, 0(SP)			
  0x42ed71		e8ca58ffff		CALL runtime.printint(SB)	
  0x42ed76		e8d553ffff		CALL runtime.printnl(SB)	
  0x42ed7b		e8c051ffff		CALL runtime.printunlock(SB)	
		throw("checkdead: inconsistent counts")
  0x42ed80		488d05ed2d0400		LEAQ 0x42ded(IP), AX	
  0x42ed87		48890424		MOVQ AX, 0(SP)		
  0x42ed8b		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x42ed94		e8e746ffff		CALL runtime.throw(SB)	
  0x42ed99		0f0b			UD2			
func checkdead() {
  0x42ed9b		e8e08a0100		CALL runtime.morestack_noctxt(SB)	
  0x42eda0		e98bfbffff		JMP runtime.checkdead(SB)		

TEXT runtime.sysmon(SB) /usr/local/go/src/runtime/proc.go
func sysmon() {
  0x42edb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42edb9		488d4424f8		LEAQ -0x8(SP), AX	
  0x42edbe		483b4110		CMPQ 0x10(CX), AX	
  0x42edc2		0f86f9040000		JBE 0x42f2c1		
  0x42edc8		4881ec88000000		SUBQ $0x88, SP		
  0x42edcf		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x42edd7		488dac2480000000	LEAQ 0x80(SP), BP	
	lock(&sched.lock)
  0x42eddf		488d05ca2e0900		LEAQ runtime.sched+16(SB), AX	
  0x42ede6		48890424		MOVQ AX, 0(SP)			
  0x42edea		e8f198fdff		CALL runtime.lock(SB)		
	sched.nmsys++
  0x42edef		ff05df2e0900		INCL runtime.sched+52(SB)	
	checkdead()
  0x42edf5		e836fbffff		CALL runtime.checkdead(SB)	
	unlock(&sched.lock)
  0x42edfa		488d05af2e0900		LEAQ runtime.sched+16(SB), AX	
  0x42ee01		48890424		MOVQ AX, 0(SP)			
  0x42ee05		e8869afdff		CALL runtime.unlock(SB)		
	if debug.scavenge > 0 {
  0x42ee0a		833dffe00a0000		CMPL $0x0, runtime.debug+48(SB)	
  0x42ee11		0f8e9b040000		JLE 0x42f2b2			
		forcegcperiod = 10 * 1e6
  0x42ee17		48c7050e02090080969800	MOVQ $0x989680, runtime.forcegcperiod(SB)	
  0x42ee22		b8002d3101		MOVL $0x1312d00, AX				
		if lastscavenge+scavengelimit/2 < now {
  0x42ee27		4889442430		MOVQ AX, 0x30(SP)	
	lastscavenge := nanotime()
  0x42ee2c		e87fc20100		CALL runtime.nanotime(SB)	
  0x42ee31		488b0424		MOVQ 0(SP), AX			
  0x42ee35		31c9			XORL CX, CX			
  0x42ee37		31d2			XORL DX, DX			
  0x42ee39		31db			XORL BX, BX			
  0x42ee3b		31f6			XORL SI, SI			
	for {
  0x42ee3d		eb10			JMP 0x42ee4f		
		if idle == 0 { // start with 20us sleep...
  0x42ee3f		4889c1			MOVQ AX, CX		
		if lastscavenge+scavengelimit/2 < now {
  0x42ee42		4889f0			MOVQ SI, AX		
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42ee45		4889d3			MOVQ DX, BX		
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42ee48		4c89ce			MOVQ R9, SI		
			delay *= 2
  0x42ee4b		8b542424		MOVL 0x24(SP), DX	
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42ee4f		4889742450		MOVQ SI, 0x50(SP)	
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42ee54		48895c2438		MOVQ BX, 0x38(SP)	
		if lastscavenge+scavengelimit/2 < now {
  0x42ee59		4889442458		MOVQ AX, 0x58(SP)	
		if idle == 0 { // start with 20us sleep...
  0x42ee5e		48894c2460		MOVQ CX, 0x60(SP)	
  0x42ee63		4885c9			TESTQ CX, CX		
  0x42ee66		0f8534040000		JNE 0x42f2a0		
  0x42ee6c		ba14000000		MOVL $0x14, DX		
		if delay > 10*1000 { // up to 10ms
  0x42ee71		81fa10270000		CMPL $0x2710, DX	
		usleep(delay)
  0x42ee77		b810270000		MOVL $0x2710, AX	
  0x42ee7c		0f47d0			CMOVA AX, DX		
  0x42ee7f		89542424		MOVL DX, 0x24(SP)	
  0x42ee83		891424			MOVL DX, 0(SP)		
  0x42ee86		e875c00100		CALL runtime.usleep(SB)	
		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {
  0x42ee8b		833d86e00a0000		CMPL $0x0, runtime.debug+56(SB)	
		if delay > 10*1000 { // up to 10ms
  0x42ee92		0f8f01040000		JG 0x42f299		
		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {
  0x42ee98		833df92e090000		CMPL $0x0, runtime.sched+248(SB)	
  0x42ee9f		0f84de030000		JE 0x42f283				
  0x42eea5		b801000000		MOVL $0x1, AX				
  0x42eeaa		84c0			TESTL AL, AL				
  0x42eeac		0f85cb020000		JNE 0x42f17d				
			delay *= 2
  0x42eeb2		8b442424		MOVL 0x24(SP), AX	
			idle++
  0x42eeb6		488b4c2460		MOVQ 0x60(SP), CX	
  0x42eebb		48894c2460		MOVQ CX, 0x60(SP)	
			delay *= 2
  0x42eec0		89442424		MOVL AX, 0x24(SP)	
		if *cgo_yield != nil {
  0x42eec4		488b155d0c0900		MOVQ runtime.cgo_yield(SB), DX	
  0x42eecb		488b12			MOVQ 0(DX), DX			
  0x42eece		4885d2			TESTQ DX, DX			
  0x42eed1		0f858f020000		JNE 0x42f166			
		lastpoll := int64(atomic.Load64(&sched.lastpoll))
  0x42eed7		488b05ca2d0900		MOVQ runtime.sched+8(SB), AX	
  0x42eede		4889442478		MOVQ AX, 0x78(SP)		
		now := nanotime()
  0x42eee3		e8c8c10100		CALL runtime.nanotime(SB)	
  0x42eee8		488b0424		MOVQ 0(SP), AX			
  0x42eeec		4889442428		MOVQ AX, 0x28(SP)		
		if netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {
  0x42eef1		90			NOPL			
	return atomic.Load(&netpollInited) != 0
  0x42eef2		8b0df0dd0a00		MOVL runtime.netpollInited(SB), CX	
  0x42eef8		85c9			TESTL CX, CX				
		if netpollinited() && lastpoll != 0 && lastpoll+10*1000*1000 < now {
  0x42eefa		741a			JE 0x42ef16		
  0x42eefc		488b4c2478		MOVQ 0x78(SP), CX	
  0x42ef01		4885c9			TESTQ CX, CX		
  0x42ef04		7410			JE 0x42ef16		
  0x42ef06		488d9180969800		LEAQ 0x989680(CX), DX	
  0x42ef0d		4839c2			CMPQ AX, DX		
  0x42ef10		0f8cf0010000		JL 0x42f106		
		if retake(now) != 0 {
  0x42ef16		48890424		MOVQ AX, 0(SP)		
  0x42ef1a		e8b1030000		CALL runtime.retake(SB)	
			idle++
  0x42ef1f		488b442460		MOVQ 0x60(SP), AX	
  0x42ef24		48ffc0			INCQ AX			
		if retake(now) != 0 {
  0x42ef27		837c240800		CMPL $0x0, 0x8(SP)	
		if idle == 0 { // start with 20us sleep...
  0x42ef2c		b900000000		MOVL $0x0, CX		
  0x42ef31		480f45c1		CMOVNE CX, AX		
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42ef35		90			NOPL			
	if !memstats.enablegc || panicking != 0 {
  0x42ef36		803df3fd0a0000		CMPB $0x0, runtime.memstats+4304(SB)	
		if retake(now) != 0 {
  0x42ef3d		740d			JE 0x42ef4c		
	if !memstats.enablegc || panicking != 0 {
  0x42ef3f		833daedd0a0000		CMPL $0x0, runtime.panicking(SB)	
  0x42ef46		0f8468010000		JE 0x42f0b4				
  0x42ef4c		31d2			XORL DX, DX				
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42ef4e		84d2			TESTL DL, DL			
  0x42ef50		0f8457010000		JE 0x42f0ad			
  0x42ef56		8b15342b0900		MOVL runtime.forcegc+16(SB), DX	
  0x42ef5c		85d2			TESTL DX, DX			
  0x42ef5e		0f95c2			SETNE DL			
		if idle == 0 { // start with 20us sleep...
  0x42ef61		4889442460		MOVQ AX, 0x60(SP)	
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42ef66		84d2			TESTL DL, DL		
  0x42ef68		0f85d9000000		JNE 0x42f047		
		if lastscavenge+scavengelimit/2 < now {
  0x42ef6e		488b542430		MOVQ 0x30(SP), DX	
  0x42ef73		4889d3			MOVQ DX, BX		
  0x42ef76		48c1ea3f		SHRQ $0x3f, DX		
  0x42ef7a		4801da			ADDQ BX, DX		
  0x42ef7d		48d1fa			SARQ $0x1, DX		
  0x42ef80		488b742458		MOVQ 0x58(SP), SI	
  0x42ef85		4801f2			ADDQ SI, DX		
  0x42ef88		488b7c2428		MOVQ 0x28(SP), DI	
  0x42ef8d		4839fa			CMPQ DI, DX		
  0x42ef90		7c70			JL 0x42f002		
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42ef92		488b542438		MOVQ 0x38(SP), DX	
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42ef97		448b057adf0a00		MOVL runtime.debug+56(SB), R8	
  0x42ef9e		4585c0			TESTL R8, R8			
  0x42efa1		7e55			JLE 0x42eff8			
  0x42efa3		4d63c0			MOVSXD R8, R8			
  0x42efa6		4d69c040420f00		IMULQ $0xf4240, R8, R8		
  0x42efad		4c8b4c2450		MOVQ 0x50(SP), R9		
  0x42efb2		4d01c8			ADDQ R9, R8			
  0x42efb5		4939f8			CMPQ DI, R8			
  0x42efb8		0f8f81feffff		JG 0x42ee3f			
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42efbe		4889542470		MOVQ DX, 0x70(SP)	
		if lastscavenge+scavengelimit/2 < now {
  0x42efc3		4889742468		MOVQ SI, 0x68(SP)	
			schedtrace(debug.scheddetail > 0)
  0x42efc8		833d45df0a0000		CMPL $0x0, runtime.debug+52(SB)	
  0x42efcf		0f9f0424		SETG 0(SP)			
  0x42efd3		e8b8050000		CALL runtime.schedtrace(SB)	
		if idle == 0 { // start with 20us sleep...
  0x42efd8		488b442460		MOVQ 0x60(SP), AX	
  0x42efdd		31c9			XORL CX, CX		
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42efdf		488b542470		MOVQ 0x70(SP), DX	
		if lastscavenge+scavengelimit/2 < now {
  0x42efe4		488b5c2430		MOVQ 0x30(SP), BX	
  0x42efe9		488b742468		MOVQ 0x68(SP), SI	
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42efee		4c8b4c2428		MOVQ 0x28(SP), R9	
			schedtrace(debug.scheddetail > 0)
  0x42eff3		e947feffff		JMP 0x42ee3f		
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42eff8		4c8b4c2450		MOVQ 0x50(SP), R9	
  0x42effd		e93dfeffff		JMP 0x42ee3f		
			mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))
  0x42f002		488d0537760900		LEAQ runtime.mheap_(SB), AX		
  0x42f009		48890424		MOVQ AX, 0(SP)				
  0x42f00d		488b4c2438		MOVQ 0x38(SP), CX			
  0x42f012		894c2408		MOVL CX, 0x8(SP)			
  0x42f016		48897c2410		MOVQ DI, 0x10(SP)			
  0x42f01b		48895c2418		MOVQ BX, 0x18(SP)			
  0x42f020		e8ebf5feff		CALL runtime.(*mheap).scavenge(SB)	
			nscavenge++
  0x42f025		488b442438		MOVQ 0x38(SP), AX	
  0x42f02a		488d5001		LEAQ 0x1(AX), DX	
		if idle == 0 { // start with 20us sleep...
  0x42f02e		488b442460		MOVQ 0x60(SP), AX	
  0x42f033		31c9			XORL CX, CX		
		if lastscavenge+scavengelimit/2 < now {
  0x42f035		488b5c2430		MOVQ 0x30(SP), BX	
		if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
  0x42f03a		488b7c2428		MOVQ 0x28(SP), DI	
		if lastscavenge+scavengelimit/2 < now {
  0x42f03f		4889fe			MOVQ DI, SI		
			nscavenge++
  0x42f042		e950ffffff		JMP 0x42ef97		
			lock(&forcegc.lock)
  0x42f047		488d05322a0900		LEAQ runtime.forcegc(SB), AX	
  0x42f04e		48890424		MOVQ AX, 0(SP)			
  0x42f052		e88996fdff		CALL runtime.lock(SB)		
			forcegc.idle = 0
  0x42f057		c7052f2a090000000000	MOVL $0x0, runtime.forcegc+16(SB)	
			var list gList
  0x42f061		48c744244800000000	MOVQ $0x0, 0x48(SP)	
			list.push(forcegc.g)
  0x42f06a		488b05172a0900		MOVQ runtime.forcegc+8(SB), AX	
  0x42f071		90			NOPL				
	gp.schedlink = l.head
  0x42f072		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	l.head.set(gp)
  0x42f07d		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x42f07e		4889442448		MOVQ AX, 0x48(SP)	
			injectglist(&list)
  0x42f083		488d442448		LEAQ 0x48(SP), AX		
  0x42f088		48890424		MOVQ AX, 0(SP)			
  0x42f08c		e8dfb7ffff		CALL runtime.injectglist(SB)	
			unlock(&forcegc.lock)
  0x42f091		488d05e8290900		LEAQ runtime.forcegc(SB), AX	
  0x42f098		48890424		MOVQ AX, 0(SP)			
  0x42f09c		e8ef97fdff		CALL runtime.unlock(SB)		
		if idle == 0 { // start with 20us sleep...
  0x42f0a1		488b442460		MOVQ 0x60(SP), AX	
  0x42f0a6		31c9			XORL CX, CX		
			unlock(&forcegc.lock)
  0x42f0a8		e9c1feffff		JMP 0x42ef6e		
  0x42f0ad		31d2			XORL DX, DX		
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42f0af		e9adfeffff		JMP 0x42ef61		
	if gcphase != _GCoff {
  0x42f0b4		833d21dc0a0000		CMPL $0x0, runtime.gcphase(SB)	
  0x42f0bb		7407			JE 0x42f0c4			
  0x42f0bd		31d2			XORL DX, DX			
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42f0bf		e98afeffff		JMP 0x42ef4e		
		if gcpercent < 0 {
  0x42f0c4		833d0ddc0a0000		CMPL $0x0, runtime.gcpercent(SB)	
  0x42f0cb		7d07			JGE 0x42f0d4				
  0x42f0cd		31d2			XORL DX, DX				
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
  0x42f0cf		e97afeffff		JMP 0x42ef4e		
		lastgc := int64(atomic.Load64(&memstats.last_gc_nanotime))
  0x42f0d4		488b15a5020b00		MOVQ runtime.memstats+5920(SB), DX	
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x42f0db		4885d2			TESTQ DX, DX				
  0x42f0de		741a			JE 0x42f0fa				
  0x42f0e0		488b5c2428		MOVQ 0x28(SP), BX			
  0x42f0e5		4889de			MOVQ BX, SI				
  0x42f0e8		4829d3			SUBQ DX, BX				
  0x42f0eb		48391d3eff0800		CMPQ BX, runtime.forcegcperiod(SB)	
  0x42f0f2		0f9cc2			SETL DL					
  0x42f0f5		e954feffff		JMP 0x42ef4e				
		if lastscavenge+scavengelimit/2 < now {
  0x42f0fa		488b742428		MOVQ 0x28(SP), SI	
  0x42f0ff		31d2			XORL DX, DX		
		return lastgc != 0 && t.now-lastgc > forcegcperiod
  0x42f101		e948feffff		JMP 0x42ef4e		
		now := nanotime()
  0x42f106		4889c2			MOVQ AX, DX		
			atomic.Cas64(&sched.lastpoll, uint64(lastpoll), uint64(now))
  0x42f109		4889c8			MOVQ CX, AX			
  0x42f10c		488d1d952b0900		LEAQ runtime.sched+8(SB), BX	
  0x42f113		f0480fb113		LOCK CMPXCHGQ DX, 0(BX)		
  0x42f118		0f94c1			SETE CL				
			list := netpoll(false) // non-blocking - returns list of goroutines
  0x42f11b		c6042400		MOVB $0x0, 0(SP)		
  0x42f11f		e8ac1fffff		CALL runtime.netpoll(SB)	
  0x42f124		488b4c2408		MOVQ 0x8(SP), CX		
  0x42f129		48894c2440		MOVQ CX, 0x40(SP)		
			if !list.empty() {
  0x42f12e		90			NOPL			
	return l.head == 0
  0x42f12f		4885c9			TESTQ CX, CX		
			if !list.empty() {
  0x42f132		750a			JNE 0x42f13e		
		if retake(now) != 0 {
  0x42f134		488b442428		MOVQ 0x28(SP), AX	
  0x42f139		e9d8fdffff		JMP 0x42ef16		
				incidlelocked(-1)
  0x42f13e		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x42f145		e876f7ffff		CALL runtime.incidlelocked(SB)	
				injectglist(&list)
  0x42f14a		488d442440		LEAQ 0x40(SP), AX		
  0x42f14f		48890424		MOVQ AX, 0(SP)			
  0x42f153		e818b7ffff		CALL runtime.injectglist(SB)	
				incidlelocked(1)
  0x42f158		c7042401000000		MOVL $0x1, 0(SP)		
  0x42f15f		e85cf7ffff		CALL runtime.incidlelocked(SB)	
  0x42f164		ebce			JMP 0x42f134			
			asmcgocall(*cgo_yield, nil)
  0x42f166		48891424		MOVQ DX, 0(SP)			
  0x42f16a		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x42f173		e8889d0100		CALL runtime.asmcgocall(SB)	
  0x42f178		e95afdffff		JMP 0x42eed7			
			lock(&sched.lock)
  0x42f17d		488d052c2b0900		LEAQ runtime.sched+16(SB), AX	
  0x42f184		48890424		MOVQ AX, 0(SP)			
  0x42f188		e85395fdff		CALL runtime.lock(SB)		
			if atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {
  0x42f18d		8b05052c0900		MOVL runtime.sched+248(SB), AX	
  0x42f193		85c0			TESTL AX, AX			
  0x42f195		0f84d2000000		JE 0x42f26d			
  0x42f19b		b801000000		MOVL $0x1, AX			
  0x42f1a0		84c0			TESTL AL, AL			
  0x42f1a2		7530			JNE 0x42f1d4			
			delay *= 2
  0x42f1a4		8b442424		MOVL 0x24(SP), AX	
			idle++
  0x42f1a8		488b4c2460		MOVQ 0x60(SP), CX	
  0x42f1ad		48894c2460		MOVQ CX, 0x60(SP)	
			delay *= 2
  0x42f1b2		89442424		MOVL AX, 0x24(SP)	
			unlock(&sched.lock)
  0x42f1b6		488d15f32a0900		LEAQ runtime.sched+16(SB), DX	
  0x42f1bd		48891424		MOVQ DX, 0(SP)			
  0x42f1c1		e8ca96fdff		CALL runtime.unlock(SB)		
			delay *= 2
  0x42f1c6		8b442424		MOVL 0x24(SP), AX	
			idle++
  0x42f1ca		488b4c2460		MOVQ 0x60(SP), CX	
			unlock(&sched.lock)
  0x42f1cf		e9e7fcffff		JMP 0x42eebb		
				atomic.Store(&sched.sysmonwait, 1)
  0x42f1d4		b801000000		MOVL $0x1, AX			
  0x42f1d9		488d0dc82b0900		LEAQ runtime.sched+264(SB), CX	
  0x42f1e0		8701			XCHGL AX, 0(CX)			
				unlock(&sched.lock)
  0x42f1e2		488d05c72a0900		LEAQ runtime.sched+16(SB), AX	
  0x42f1e9		48890424		MOVQ AX, 0(SP)			
  0x42f1ed		e89e96fdff		CALL runtime.unlock(SB)		
				maxsleep := forcegcperiod / 2
  0x42f1f2		488b0537fe0800		MOVQ runtime.forcegcperiod(SB), AX	
  0x42f1f9		4889c1			MOVQ AX, CX				
  0x42f1fc		48c1e83f		SHRQ $0x3f, AX				
  0x42f200		4801c8			ADDQ CX, AX				
  0x42f203		48d1f8			SARQ $0x1, AX				
				if scavengelimit < forcegcperiod {
  0x42f206		488b542430		MOVQ 0x30(SP), DX	
  0x42f20b		4839ca			CMPQ CX, DX		
  0x42f20e		7d58			JGE 0x42f268		
					maxsleep = scavengelimit / 2
  0x42f210		4889d0			MOVQ DX, AX		
  0x42f213		48c1ea3f		SHRQ $0x3f, DX		
  0x42f217		488d0c10		LEAQ 0(AX)(DX*1), CX	
  0x42f21b		48d1f9			SARQ $0x1, CX		
					osRelax(true)
  0x42f21e		90			NOPL			
				notetsleep(&sched.sysmonnote, maxsleep)
  0x42f21f		488d058a2b0900		LEAQ runtime.sched+272(SB), AX	
  0x42f226		48890424		MOVQ AX, 0(SP)			
  0x42f22a		48894c2408		MOVQ CX, 0x8(SP)		
  0x42f22f		e8ac9afdff		CALL runtime.notetsleep(SB)	
					osRelax(false)
  0x42f234		90			NOPL			
				lock(&sched.lock)
  0x42f235		488d05742a0900		LEAQ runtime.sched+16(SB), AX	
  0x42f23c		48890424		MOVQ AX, 0(SP)			
  0x42f240		e89b94fdff		CALL runtime.lock(SB)		
				atomic.Store(&sched.sysmonwait, 0)
  0x42f245		31c0			XORL AX, AX			
  0x42f247		488d0d5a2b0900		LEAQ runtime.sched+264(SB), CX	
  0x42f24e		8701			XCHGL AX, 0(CX)			
				noteclear(&sched.sysmonnote)
  0x42f250		90			NOPL			
	n.key = 0
  0x42f251		48c705542b090000000000	MOVQ $0x0, runtime.sched+272(SB)	
  0x42f25c		b814000000		MOVL $0x14, AX				
  0x42f261		31c9			XORL CX, CX				
			unlock(&sched.lock)
  0x42f263		e945ffffff		JMP 0x42f1ad		
				notetsleep(&sched.sysmonnote, maxsleep)
  0x42f268		4889c1			MOVQ AX, CX		
				if scavengelimit < forcegcperiod {
  0x42f26b		ebb1			JMP 0x42f21e		
			if atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {
  0x42f26d		8b0d7d2a0900		MOVL runtime.sched+80(SB), CX	
  0x42f273		8b1567da0a00		MOVL runtime.gomaxprocs(SB), DX	
  0x42f279		39d1			CMPL DX, CX			
  0x42f27b		0f94c0			SETE AL				
  0x42f27e		e91dffffff		JMP 0x42f1a0			
		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {
  0x42f283		8b0d672a0900		MOVL runtime.sched+80(SB), CX	
  0x42f289		8b1551da0a00		MOVL runtime.gomaxprocs(SB), DX	
  0x42f28f		39d1			CMPL DX, CX			
  0x42f291		0f94c0			SETE AL				
  0x42f294		e911fcffff		JMP 0x42eeaa			
  0x42f299		31c0			XORL AX, AX			
		if delay > 10*1000 { // up to 10ms
  0x42f29b		e90afcffff		JMP 0x42eeaa		
			delay *= 2
  0x42f2a0		89d7			MOVL DX, DI		
  0x42f2a2		d1e2			SHLL $0x1, DX		
		} else if idle > 50 { // start doubling the sleep after 1ms...
  0x42f2a4		4883f932		CMPQ $0x32, CX		
		if delay > 10*1000 { // up to 10ms
  0x42f2a8		0f4ffa			CMOVG DX, DI		
  0x42f2ab		89fa			MOVL DI, DX		
		} else if idle > 50 { // start doubling the sleep after 1ms...
  0x42f2ad		e9bffbffff		JMP 0x42ee71		
  0x42f2b2		48b800b864d945000000	MOVQ $0x45d964b800, AX	
	if debug.scavenge > 0 {
  0x42f2bc		e966fbffff		JMP 0x42ee27		
func sysmon() {
  0x42f2c1		e8ba850100		CALL runtime.morestack_noctxt(SB)	
  0x42f2c6		e9e5faffff		JMP runtime.sysmon(SB)			

TEXT runtime.retake(SB) /usr/local/go/src/runtime/proc.go
func retake(now int64) uint32 {
  0x42f2d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42f2d9		483b6110		CMPQ 0x10(CX), SP	
  0x42f2dd		0f861f020000		JBE 0x42f502		
  0x42f2e3		4883ec38		SUBQ $0x38, SP		
  0x42f2e7		48896c2430		MOVQ BP, 0x30(SP)	
  0x42f2ec		488d6c2430		LEAQ 0x30(SP), BP	
	lock(&allpLock)
  0x42f2f1		488d0530da0a00		LEAQ runtime.allpLock(SB), AX	
  0x42f2f8		48890424		MOVQ AX, 0(SP)			
  0x42f2fc		e8df93fdff		CALL runtime.lock(SB)		
	for i := 0; i < len(allp); i++ {
  0x42f301		488b442440		MOVQ 0x40(SP), AX	
  0x42f306		31c9			XORL CX, CX		
  0x42f308		31d2			XORL DX, DX		
  0x42f30a		eb03			JMP 0x42f30f		
  0x42f30c		48ffc1			INCQ CX			
				n++
  0x42f30f		4889542418		MOVQ DX, 0x18(SP)	
	for i := 0; i < len(allp); i++ {
  0x42f314		488b1d05270900		MOVQ runtime.allp(SB), BX	
  0x42f31b		48390d06270900		CMPQ CX, runtime.allp+8(SB)	
  0x42f322		0f8eb7010000		JLE 0x42f4df			
		_p_ := allp[i]
  0x42f328		488b1ccb		MOVQ 0(BX)(CX*8), BX	
		if _p_ == nil {
  0x42f32c		4885db			TESTQ BX, BX		
  0x42f32f		74db			JE 0x42f30c		
	for i := 0; i < len(allp); i++ {
  0x42f331		48894c2420		MOVQ CX, 0x20(SP)	
		s := _p_.status
  0x42f336		8b730c			MOVL 0xc(BX), SI	
		if s == _Psyscall {
  0x42f339		83fe02			CMPL $0x2, SI		
  0x42f33c		0f8529010000		JNE 0x42f46b		
			t := int64(_p_.syscalltick)
  0x42f342		8b7b1c			MOVL 0x1c(BX), DI	
			if int64(pd.syscalltick) != t {
  0x42f345		448b4330		MOVL 0x30(BX), R8	
  0x42f349		4939f8			CMPQ DI, R8		
  0x42f34c		7409			JE 0x42f357		
				pd.syscalltick = uint32(t)
  0x42f34e		897b30			MOVL DI, 0x30(BX)	
				pd.syscallwhen = now
  0x42f351		48894338		MOVQ AX, 0x38(BX)	
				continue
  0x42f355		ebb5			JMP 0x42f30c		
		_p_ := allp[i]
  0x42f357		48895c2428		MOVQ BX, 0x28(SP)	
		s := _p_.status
  0x42f35c		89742414		MOVL SI, 0x14(SP)	
			if runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {
  0x42f360		48891c24		MOVQ BX, 0(SP)			
  0x42f364		e8a7100000		CALL runtime.runqempty(SB)	
  0x42f369		807c240800		CMPB $0x0, 0x8(SP)		
  0x42f36e		0f84f0000000		JE 0x42f464			
  0x42f374		8b057a290900		MOVL runtime.sched+84(SB), AX	
  0x42f37a		8b0d70290900		MOVL runtime.sched+80(SB), CX	
  0x42f380		01c8			ADDL CX, AX			
  0x42f382		85c0			TESTL AX, AX			
  0x42f384		0f97c0			SETA AL				
  0x42f387		84c0			TESTL AL, AL			
  0x42f389		742c			JE 0x42f3b7			
  0x42f38b		488b442428		MOVQ 0x28(SP), AX		
  0x42f390		488b4838		MOVQ 0x38(AX), CX		
  0x42f394		4881c180969800		ADDQ $0x989680, CX		
  0x42f39b		488b542440		MOVQ 0x40(SP), DX		
  0x42f3a0		4839d1			CMPQ DX, CX			
  0x42f3a3		7e12			JLE 0x42f3b7			
				pd.syscallwhen = now
  0x42f3a5		4889d0			MOVQ DX, AX		
	for i := 0; i < len(allp); i++ {
  0x42f3a8		488b4c2420		MOVQ 0x20(SP), CX	
				n++
  0x42f3ad		488b542418		MOVQ 0x18(SP), DX	
				continue
  0x42f3b2		e955ffffff		JMP 0x42f30c		
			unlock(&allpLock)
  0x42f3b7		488d056ad90a00		LEAQ runtime.allpLock(SB), AX	
  0x42f3be		48890424		MOVQ AX, 0(SP)			
  0x42f3c2		e8c994fdff		CALL runtime.unlock(SB)		
			incidlelocked(-1)
  0x42f3c7		c70424ffffffff		MOVL $-0x1, 0(SP)		
  0x42f3ce		e8edf4ffff		CALL runtime.incidlelocked(SB)	
			if atomic.Cas(&_p_.status, s, _Pidle) {
  0x42f3d3		8b442414		MOVL 0x14(SP), AX		
  0x42f3d7		488b4c2428		MOVQ 0x28(SP), CX		
  0x42f3dc		31d2			XORL DX, DX			
  0x42f3de		f00fb1510c		LOCK CMPXCHGL DX, 0xc(CX)	
  0x42f3e3		0f94c0			SETE AL				
  0x42f3e6		84c0			TESTL AL, AL			
  0x42f3e8		7473			JE 0x42f45d			
				if trace.enabled {
  0x42f3ea		803ddfd7090000		CMPB $0x0, runtime.trace+16(SB)	
  0x42f3f1		754c			JNE 0x42f43f			
				_p_.syscalltick++
  0x42f3f3		ff411c			INCL 0x1c(CX)		
				handoffp(_p_)
  0x42f3f6		48890c24		MOVQ CX, 0(SP)			
  0x42f3fa		e8919dffff		CALL runtime.handoffp(SB)	
				n++
  0x42f3ff		488b442418		MOVQ 0x18(SP), AX	
  0x42f404		48ffc0			INCQ AX			
  0x42f407		4889442418		MOVQ AX, 0x18(SP)	
			incidlelocked(1)
  0x42f40c		c7042401000000		MOVL $0x1, 0(SP)		
  0x42f413		e8a8f4ffff		CALL runtime.incidlelocked(SB)	
			lock(&allpLock)
  0x42f418		488d0509d90a00		LEAQ runtime.allpLock(SB), AX	
  0x42f41f		48890424		MOVQ AX, 0(SP)			
  0x42f423		e8b892fdff		CALL runtime.lock(SB)		
				n++
  0x42f428		488b442418		MOVQ 0x18(SP), AX	
	for i := 0; i < len(allp); i++ {
  0x42f42d		488b4c2420		MOVQ 0x20(SP), CX	
				n++
  0x42f432		4889c2			MOVQ AX, DX		
				pd.syscallwhen = now
  0x42f435		488b442440		MOVQ 0x40(SP), AX	
	for i := 0; i < len(allp); i++ {
  0x42f43a		e9cdfeffff		JMP 0x42f30c		
					traceGoSysBlock(_p_)
  0x42f43f		48890c24		MOVQ CX, 0(SP)				
  0x42f443		e8b8df0000		CALL runtime.traceGoSysBlock(SB)	
					traceProcStop(_p_)
  0x42f448		488b442428		MOVQ 0x28(SP), AX		
  0x42f44d		48890424		MOVQ AX, 0(SP)			
  0x42f451		e86ad70000		CALL runtime.traceProcStop(SB)	
				_p_.syscalltick++
  0x42f456		488b4c2428		MOVQ 0x28(SP), CX	
					traceProcStop(_p_)
  0x42f45b		eb96			JMP 0x42f3f3		
				n++
  0x42f45d		488b442418		MOVQ 0x18(SP), AX	
			incidlelocked(1)
  0x42f462		eba3			JMP 0x42f407		
  0x42f464		31c0			XORL AX, AX		
			if runqempty(_p_) && atomic.Load(&sched.nmspinning)+atomic.Load(&sched.npidle) > 0 && pd.syscallwhen+10*1000*1000 > now {
  0x42f466		e91cffffff		JMP 0x42f387		
		} else if s == _Prunning {
  0x42f46b		83fe01			CMPL $0x1, SI		
  0x42f46e		7545			JNE 0x42f4b5		
			t := int64(_p_.schedtick)
  0x42f470		8b7318			MOVL 0x18(BX), SI	
			if int64(pd.schedtick) != t {
  0x42f473		8b7b20			MOVL 0x20(BX), DI	
  0x42f476		4839f7			CMPQ SI, DI		
  0x42f479		740c			JE 0x42f487		
				pd.schedtick = uint32(t)
  0x42f47b		897320			MOVL SI, 0x20(BX)	
				pd.schedwhen = now
  0x42f47e		48894328		MOVQ AX, 0x28(BX)	
				continue
  0x42f482		e985feffff		JMP 0x42f30c		
			if pd.schedwhen+forcePreemptNS > now {
  0x42f487		488b7328		MOVQ 0x28(BX), SI	
  0x42f48b		4881c680969800		ADDQ $0x989680, SI	
  0x42f492		4839c6			CMPQ AX, SI		
  0x42f495		0f8f71feffff		JG 0x42f30c		
			preemptone(_p_)
  0x42f49b		90			NOPL			
	mp := _p_.m.ptr()
  0x42f49c		488b5b40		MOVQ 0x40(BX), BX	
  0x42f4a0		90			NOPL			
	if mp == nil || mp == getg().m {
  0x42f4a1		4885db			TESTQ BX, BX		
  0x42f4a4		740f			JE 0x42f4b5		
  0x42f4a6		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
  0x42f4af		48395e30		CMPQ BX, 0x30(SI)	
  0x42f4b3		7508			JNE 0x42f4bd		
				n++
  0x42f4b5		4889d0			MOVQ DX, AX		
	for i := 0; i < len(allp); i++ {
  0x42f4b8		e970ffffff		JMP 0x42f42d		
	gp := mp.curg
  0x42f4bd		488bb3c0000000		MOVQ 0xc0(BX), SI	
	if gp == nil || gp == mp.g0 {
  0x42f4c4		4885f6			TESTQ SI, SI		
  0x42f4c7		74ec			JE 0x42f4b5		
  0x42f4c9		483933			CMPQ SI, 0(BX)		
  0x42f4cc		74e7			JE 0x42f4b5		
	gp.preempt = true
  0x42f4ce		c686b100000001		MOVB $0x1, 0xb1(SI)	
	gp.stackguard0 = stackPreempt
  0x42f4d5		48c74610defaffff	MOVQ $-0x522, 0x10(SI)	
			preemptone(_p_)
  0x42f4dd		ebd6			JMP 0x42f4b5		
	unlock(&allpLock)
  0x42f4df		488d0542d80a00		LEAQ runtime.allpLock(SB), AX	
  0x42f4e6		48890424		MOVQ AX, 0(SP)			
  0x42f4ea		e8a193fdff		CALL runtime.unlock(SB)		
	return uint32(n)
  0x42f4ef		488b442418		MOVQ 0x18(SP), AX	
  0x42f4f4		89442448		MOVL AX, 0x48(SP)	
  0x42f4f8		488b6c2430		MOVQ 0x30(SP), BP	
  0x42f4fd		4883c438		ADDQ $0x38, SP		
  0x42f501		c3			RET			
func retake(now int64) uint32 {
  0x42f502		e879830100		CALL runtime.morestack_noctxt(SB)	
  0x42f507		e9c4fdffff		JMP runtime.retake(SB)			

TEXT runtime.preemptall(SB) /usr/local/go/src/runtime/proc.go
	for _, _p_ := range allp {
  0x42f510		488b0511250900		MOVQ runtime.allp+8(SB), AX	
  0x42f517		488b0d02250900		MOVQ runtime.allp(SB), CX	
  0x42f51e		31d2			XORL DX, DX			
  0x42f520		31db			XORL BX, BX			
  0x42f522		eb03			JMP 0x42f527			
  0x42f524		48ffc2			INCQ DX				
  0x42f527		4839c2			CMPQ AX, DX			
  0x42f52a		7d55			JGE 0x42f581			
  0x42f52c		488b34d1		MOVQ 0(CX)(DX*8), SI		
		if _p_.status != _Prunning {
  0x42f530		837e0c01		CMPL $0x1, 0xc(SI)	
  0x42f534		75ee			JNE 0x42f524		
		if preemptone(_p_) {
  0x42f536		90			NOPL			
	mp := _p_.m.ptr()
  0x42f537		488b7640		MOVQ 0x40(SI), SI	
  0x42f53b		90			NOPL			
	if mp == nil || mp == getg().m {
  0x42f53c		4885f6			TESTQ SI, SI		
  0x42f53f		740f			JE 0x42f550		
  0x42f541		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	
  0x42f54a		48397730		CMPQ SI, 0x30(DI)	
  0x42f54e		7506			JNE 0x42f556		
  0x42f550		31f6			XORL SI, SI		
	return res
  0x42f552		09f3			ORL SI, BX		
	for _, _p_ := range allp {
  0x42f554		ebce			JMP 0x42f524		
	gp := mp.curg
  0x42f556		488bbec0000000		MOVQ 0xc0(SI), DI	
	if gp == nil || gp == mp.g0 {
  0x42f55d		4885ff			TESTQ DI, DI		
  0x42f560		7405			JE 0x42f567		
  0x42f562		48393e			CMPQ DI, 0(SI)		
  0x42f565		7504			JNE 0x42f56b		
  0x42f567		31f6			XORL SI, SI		
		if preemptone(_p_) {
  0x42f569		ebe7			JMP 0x42f552		
	gp.preempt = true
  0x42f56b		c687b100000001		MOVB $0x1, 0xb1(DI)	
	gp.stackguard0 = stackPreempt
  0x42f572		48c74710defaffff	MOVQ $-0x522, 0x10(DI)	
  0x42f57a		be01000000		MOVL $0x1, SI		
		if preemptone(_p_) {
  0x42f57f		ebd1			JMP 0x42f552		
	return res
  0x42f581		885c2408		MOVB BL, 0x8(SP)	
  0x42f585		c3			RET			

TEXT runtime.schedtrace(SB) /usr/local/go/src/runtime/proc.go
func schedtrace(detailed bool) {
  0x42f590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x42f599		488d4424a0		LEAQ -0x60(SP), AX	
  0x42f59e		483b4110		CMPQ 0x10(CX), AX	
  0x42f5a2		0f86ba0a0000		JBE 0x430062		
  0x42f5a8		4881ece0000000		SUBQ $0xe0, SP		
  0x42f5af		4889ac24d8000000	MOVQ BP, 0xd8(SP)	
  0x42f5b7		488dac24d8000000	LEAQ 0xd8(SP), BP	
	now := nanotime()
  0x42f5bf		e8ecba0100		CALL runtime.nanotime(SB)	
  0x42f5c4		488b0424		MOVQ 0(SP), AX			
  0x42f5c8		4889442430		MOVQ AX, 0x30(SP)		
	if starttime == 0 {
  0x42f5cd		48833d0bd80a0000	CMPQ $0x0, runtime.starttime(SB)	
  0x42f5d5		7507			JNE 0x42f5de				
		starttime = now
  0x42f5d7		48890502d80a00		MOVQ AX, runtime.starttime(SB)	
	lock(&sched.lock)
  0x42f5de		488d05cb260900		LEAQ runtime.sched+16(SB), AX	
  0x42f5e5		48890424		MOVQ AX, 0(SP)			
  0x42f5e9		e8f290fdff		CALL runtime.lock(SB)		
	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle, " threads=", mcount(), " spinningthreads=", sched.nmspinning, " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)
  0x42f5ee		488b05ebd70a00		MOVQ runtime.starttime(SB), AX		
  0x42f5f5		48898424b0000000	MOVQ AX, 0xb0(SP)			
  0x42f5fd		8b0ded260900		MOVL runtime.sched+80(SB), CX		
  0x42f603		48898c24a8000000	MOVQ CX, 0xa8(SP)			
  0x42f60b		90			NOPL					
  0x42f60c		8b15e2260900		MOVL runtime.sched+84(SB), DX		
  0x42f612		48899424a0000000	MOVQ DX, 0xa0(SP)			
  0x42f61a		48631d9f260900		MOVSXD runtime.sched+32(SB), BX		
  0x42f621		48899c2498000000	MOVQ BX, 0x98(SP)			
  0x42f629		486335d8260900		MOVSXD runtime.sched+104(SB), SI	
  0x42f630		4889b42490000000	MOVQ SI, 0x90(SP)			
	return int32(sched.mnext - sched.nmfreed)
  0x42f638		488b3d89260900		MOVQ runtime.sched+40(SB), DI	
  0x42f63f		482b3d92260900		SUBQ runtime.sched+56(SB), DI	
  0x42f646		4889bc2488000000	MOVQ DI, 0x88(SP)		
	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle, " threads=", mcount(), " spinningthreads=", sched.nmspinning, " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)
  0x42f64e		e86d48ffff		CALL runtime.printlock(SB)		
  0x42f653		488d0526fc0300		LEAQ 0x3fc26(IP), AX			
  0x42f65a		48890424		MOVQ AX, 0(SP)				
  0x42f65e		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x42f667		e88451ffff		CALL runtime.printstring(SB)		
  0x42f66c		488b442430		MOVQ 0x30(SP), AX			
  0x42f671		488b8c24b0000000	MOVQ 0xb0(SP), CX			
  0x42f679		4829c8			SUBQ CX, AX				
  0x42f67c		4889c1			MOVQ AX, CX				
  0x42f67f		48b8db34b6d782de1b43	MOVQ $0x431bde82d7b634db, AX		
  0x42f689		48f7e9			IMULQ CX				
  0x42f68c		48c1fa12		SARQ $0x12, DX				
  0x42f690		48c1f93f		SARQ $0x3f, CX				
  0x42f694		4829ca			SUBQ CX, DX				
  0x42f697		48891424		MOVQ DX, 0(SP)				
  0x42f69b		e8a04fffff		CALL runtime.printint(SB)		
  0x42f6a0		488d0507080400		LEAQ 0x40807(IP), AX			
  0x42f6a7		48890424		MOVQ AX, 0(SP)				
  0x42f6ab		48c74424080f000000	MOVQ $0xf, 0x8(SP)			
  0x42f6b4		e83751ffff		CALL runtime.printstring(SB)		
  0x42f6b9		48630520d60a00		MOVSXD runtime.gomaxprocs(SB), AX	
  0x42f6c0		48890424		MOVQ AX, 0(SP)				
  0x42f6c4		e8774fffff		CALL runtime.printint(SB)		
  0x42f6c9		488d057d010400		LEAQ 0x4017d(IP), AX			
  0x42f6d0		48890424		MOVQ AX, 0(SP)				
  0x42f6d4		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42f6dd		e80e51ffff		CALL runtime.printstring(SB)		
  0x42f6e2		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x42f6ea		48890424		MOVQ AX, 0(SP)				
  0x42f6ee		e84d4effff		CALL runtime.printuint(SB)		
  0x42f6f3		488d050bfe0300		LEAQ 0x3fe0b(IP), AX			
  0x42f6fa		48890424		MOVQ AX, 0(SP)				
  0x42f6fe		48c744240809000000	MOVQ $0x9, 0x8(SP)			
  0x42f707		e8e450ffff		CALL runtime.printstring(SB)		
  0x42f70c		488b842488000000	MOVQ 0x88(SP), AX			
  0x42f714		4863c0			MOVSXD AX, AX				
  0x42f717		48890424		MOVQ AX, 0(SP)				
  0x42f71b		e8204fffff		CALL runtime.printint(SB)		
  0x42f720		488d05d1090400		LEAQ 0x409d1(IP), AX			
  0x42f727		48890424		MOVQ AX, 0(SP)				
  0x42f72b		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x42f734		e8b750ffff		CALL runtime.printstring(SB)		
  0x42f739		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x42f741		48890424		MOVQ AX, 0(SP)				
  0x42f745		e8f64dffff		CALL runtime.printuint(SB)		
  0x42f74a		488d0560040400		LEAQ 0x40460(IP), AX			
  0x42f751		48890424		MOVQ AX, 0(SP)				
  0x42f755		48c74424080d000000	MOVQ $0xd, 0x8(SP)			
  0x42f75e		e88d50ffff		CALL runtime.printstring(SB)		
  0x42f763		488b842498000000	MOVQ 0x98(SP), AX			
  0x42f76b		48890424		MOVQ AX, 0(SP)				
  0x42f76f		e8cc4effff		CALL runtime.printint(SB)		
  0x42f774		488d05bfff0300		LEAQ 0x3ffbf(IP), AX			
  0x42f77b		48890424		MOVQ AX, 0(SP)				
  0x42f77f		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x42f788		e86350ffff		CALL runtime.printstring(SB)		
  0x42f78d		488b842490000000	MOVQ 0x90(SP), AX			
  0x42f795		48890424		MOVQ AX, 0(SP)				
  0x42f799		e8a24effff		CALL runtime.printint(SB)		
  0x42f79e		e89d47ffff		CALL runtime.printunlock(SB)		
func schedtrace(detailed bool) {
  0x42f7a3		0fb68424e8000000	MOVZX 0xe8(SP), AX	
  0x42f7ab		84c0			TESTL AL, AL		
	if detailed {
  0x42f7ad		0f85aa070000		JNE 0x42ff5d		
	for i, _p_ := range allp {
  0x42f7b3		488b0d6e220900		MOVQ runtime.allp+8(SB), CX	
  0x42f7ba		48898c2480000000	MOVQ CX, 0x80(SP)		
  0x42f7c2		488b1557220900		MOVQ runtime.allp(SB), DX	
  0x42f7c9		48899424d0000000	MOVQ DX, 0xd0(SP)		
  0x42f7d1		31db			XORL BX, BX			
  0x42f7d3		eb21			JMP 0x42f7f6			
  0x42f7d5		488b742460		MOVQ 0x60(SP), SI		
  0x42f7da		488d5e01		LEAQ 0x1(SI), BX		
func schedtrace(detailed bool) {
  0x42f7de		0fb68424e8000000	MOVZX 0xe8(SP), AX	
	for i, _p_ := range allp {
  0x42f7e6		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x42f7ee		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x42f7f6		4839cb			CMPQ CX, BX		
  0x42f7f9		0f8d52020000		JGE 0x42fa51		
  0x42f7ff		48895c2460		MOVQ BX, 0x60(SP)	
  0x42f804		488b34da		MOVQ 0(DX)(BX*8), SI	
		mp := _p_.m.ptr()
  0x42f808		488b7e40		MOVQ 0x40(SI), DI	
  0x42f80c		90			NOPL			
		h := atomic.Load(&_p_.runqhead)
  0x42f80d		448b86e0050000		MOVL 0x5e0(SI), R8	
  0x42f814		4489442424		MOVL R8, 0x24(SP)	
		t := atomic.Load(&_p_.runqtail)
  0x42f819		448b8ee4050000		MOVL 0x5e4(SI), R9	
  0x42f820		44894c241c		MOVL R9, 0x1c(SP)	
func schedtrace(detailed bool) {
  0x42f825		84c0			TESTL AL, AL		
		if detailed {
  0x42f827		0f8481010000		JE 0x42f9ae		
			if mp != nil {
  0x42f82d		4885ff			TESTQ DI, DI		
  0x42f830		0f846c010000		JE 0x42f9a2		
				id = mp.id
  0x42f836		488bbfe8000000		MOVQ 0xe8(DI), DI	
			print("  P", i, ": status=", _p_.status, " schedtick=", _p_.schedtick, " syscalltick=", _p_.syscalltick, " m=", id, " runqsize=", t-h, " gfreecnt=", _p_.gFree.n, "\n")
  0x42f83d		48897c2458		MOVQ DI, 0x58(SP)		
  0x42f842		8b460c			MOVL 0xc(SI), AX		
  0x42f845		48898424a8000000	MOVQ AX, 0xa8(SP)		
  0x42f84d		8b4e18			MOVL 0x18(SI), CX		
  0x42f850		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x42f858		8b561c			MOVL 0x1c(SI), DX		
  0x42f85b		4889542478		MOVQ DX, 0x78(SP)		
  0x42f860		48639ef80d0000		MOVSXD 0xdf8(SI), BX		
  0x42f867		48899c24b0000000	MOVQ BX, 0xb0(SP)		
  0x42f86f		e84c46ffff		CALL runtime.printlock(SB)	
  0x42f874		488d053bf80300		LEAQ 0x3f83b(IP), AX		
  0x42f87b		48890424		MOVQ AX, 0(SP)			
  0x42f87f		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42f888		e8634fffff		CALL runtime.printstring(SB)	
  0x42f88d		488b442460		MOVQ 0x60(SP), AX		
  0x42f892		48890424		MOVQ AX, 0(SP)			
  0x42f896		e8a54dffff		CALL runtime.printint(SB)	
  0x42f89b		488d05abfc0300		LEAQ 0x3fcab(IP), AX		
  0x42f8a2		48890424		MOVQ AX, 0(SP)			
  0x42f8a6		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42f8af		e83c4fffff		CALL runtime.printstring(SB)	
  0x42f8b4		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x42f8bc		48890424		MOVQ AX, 0(SP)			
  0x42f8c0		e87b4cffff		CALL runtime.printuint(SB)	
  0x42f8c5		488d05e4ff0300		LEAQ 0x3ffe4(IP), AX		
  0x42f8cc		48890424		MOVQ AX, 0(SP)			
  0x42f8d0		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42f8d9		e8124fffff		CALL runtime.printstring(SB)	
  0x42f8de		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x42f8e6		48890424		MOVQ AX, 0(SP)			
  0x42f8ea		e8514cffff		CALL runtime.printuint(SB)	
  0x42f8ef		488d05fc020400		LEAQ 0x402fc(IP), AX		
  0x42f8f6		48890424		MOVQ AX, 0(SP)			
  0x42f8fa		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x42f903		e8e84effff		CALL runtime.printstring(SB)	
  0x42f908		488b442478		MOVQ 0x78(SP), AX		
  0x42f90d		48890424		MOVQ AX, 0(SP)			
  0x42f911		e82a4cffff		CALL runtime.printuint(SB)	
  0x42f916		488d05a8f70300		LEAQ 0x3f7a8(IP), AX		
  0x42f91d		48890424		MOVQ AX, 0(SP)			
  0x42f921		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42f92a		e8c14effff		CALL runtime.printstring(SB)	
  0x42f92f		488b442458		MOVQ 0x58(SP), AX		
  0x42f934		48890424		MOVQ AX, 0(SP)			
  0x42f938		e8034dffff		CALL runtime.printint(SB)	
  0x42f93d		488d05ecfd0300		LEAQ 0x3fdec(IP), AX		
  0x42f944		48890424		MOVQ AX, 0(SP)			
  0x42f948		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42f951		e89a4effff		CALL runtime.printstring(SB)	
  0x42f956		8b44241c		MOVL 0x1c(SP), AX		
  0x42f95a		8b4c2424		MOVL 0x24(SP), CX		
  0x42f95e		29c8			SUBL CX, AX			
  0x42f960		48890424		MOVQ AX, 0(SP)			
  0x42f964		e8d74bffff		CALL runtime.printuint(SB)	
  0x42f969		488d05a2fd0300		LEAQ 0x3fda2(IP), AX		
  0x42f970		48890424		MOVQ AX, 0(SP)			
  0x42f974		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42f97d		e86e4effff		CALL runtime.printstring(SB)	
  0x42f982		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42f98a		48890424		MOVQ AX, 0(SP)			
  0x42f98e		e8ad4cffff		CALL runtime.printint(SB)	
  0x42f993		e8b847ffff		CALL runtime.printnl(SB)	
  0x42f998		e8a345ffff		CALL runtime.printunlock(SB)	
  0x42f99d		e933feffff		JMP 0x42f7d5			
  0x42f9a2		48c7c7ffffffff		MOVQ $-0x1, DI			
			if mp != nil {
  0x42f9a9		e98ffeffff		JMP 0x42f83d		
			print(" ")
  0x42f9ae		e80d45ffff		CALL runtime.printlock(SB)	
  0x42f9b3		e84847ffff		CALL runtime.printsp(SB)	
  0x42f9b8		e88345ffff		CALL runtime.printunlock(SB)	
			if i == 0 {
  0x42f9bd		488b442460		MOVQ 0x60(SP), AX	
  0x42f9c2		4885c0			TESTQ AX, AX		
  0x42f9c5		7462			JE 0x42fa29		
			print(t - h)
  0x42f9c7		e8f444ffff		CALL runtime.printlock(SB)	
  0x42f9cc		8b44241c		MOVL 0x1c(SP), AX		
  0x42f9d0		8b4c2424		MOVL 0x24(SP), CX		
  0x42f9d4		29c8			SUBL CX, AX			
  0x42f9d6		48890424		MOVQ AX, 0(SP)			
  0x42f9da		e8614bffff		CALL runtime.printuint(SB)	
  0x42f9df		e85c45ffff		CALL runtime.printunlock(SB)	
			if i == len(allp)-1 {
  0x42f9e4		488b053d200900		MOVQ runtime.allp+8(SB), AX	
  0x42f9eb		48ffc8			DECQ AX				
  0x42f9ee		488b4c2460		MOVQ 0x60(SP), CX		
  0x42f9f3		4839c8			CMPQ CX, AX			
  0x42f9f6		0f85d9fdffff		JNE 0x42f7d5			
				print("]\n")
  0x42f9fc		e8bf44ffff		CALL runtime.printlock(SB)	
  0x42fa01		488d05a0f60300		LEAQ 0x3f6a0(IP), AX		
  0x42fa08		48890424		MOVQ AX, 0(SP)			
  0x42fa0c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x42fa15		e8d64dffff		CALL runtime.printstring(SB)	
  0x42fa1a		e82145ffff		CALL runtime.printunlock(SB)	
	for i, _p_ := range allp {
  0x42fa1f		488b4c2460		MOVQ 0x60(SP), CX	
				print("]\n")
  0x42fa24		e9acfdffff		JMP 0x42f7d5		
				print("[")
  0x42fa29		e89244ffff		CALL runtime.printlock(SB)	
  0x42fa2e		488d0557f60300		LEAQ 0x3f657(IP), AX		
  0x42fa35		48890424		MOVQ AX, 0(SP)			
  0x42fa39		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42fa42		e8a94dffff		CALL runtime.printstring(SB)	
  0x42fa47		e8f444ffff		CALL runtime.printunlock(SB)	
  0x42fa4c		e976ffffff		JMP 0x42f9c7			
func schedtrace(detailed bool) {
  0x42fa51		84c0			TESTL AL, AL		
	if !detailed {
  0x42fa53		0f84e4040000		JE 0x42ff3d		
	for mp := allm; mp != nil; mp = mp.alllink {
  0x42fa59		488b05b81e0900		MOVQ runtime.allm(SB), AX	
  0x42fa60		e974020000		JMP 0x42fcd9			
  0x42fa65		48898424c0000000	MOVQ AX, 0xc0(SP)		
		print("  M", mp.id, ": p=", id1, " curg=", id2, " mallocing=", mp.mallocing, " throwing=", mp.throwing, " preemptoff=", mp.preemptoff, ""+" locks=", mp.locks, " dying=", mp.dying, " spinning=", mp.spinning, " blocked=", mp.blocked, " lockedg=", id3, "\n")
  0x42fa6d		48895c2438		MOVQ BX, 0x38(SP)		
  0x42fa72		488b88e8000000		MOVQ 0xe8(AX), CX		
  0x42fa79		48898c24b0000000	MOVQ CX, 0xb0(SP)		
  0x42fa81		486390f0000000		MOVSXD 0xf0(AX), DX		
  0x42fa88		4889942498000000	MOVQ DX, 0x98(SP)		
  0x42fa90		4863b0f4000000		MOVSXD 0xf4(AX), SI		
  0x42fa97		4889b42490000000	MOVQ SI, 0x90(SP)		
  0x42fa9f		488bb8f8000000		MOVQ 0xf8(AX), DI		
  0x42faa6		4889bc24c8000000	MOVQ DI, 0xc8(SP)		
  0x42faae		4c8b8000010000		MOVQ 0x100(AX), R8		
  0x42fab5		4c89842480000000	MOVQ R8, 0x80(SP)		
  0x42fabd		4c638808010000		MOVSXD 0x108(AX), R9		
  0x42fac4		4c898c2488000000	MOVQ R9, 0x88(SP)		
  0x42facc		4c63900c010000		MOVSXD 0x10c(AX), R10		
  0x42fad3		4c89542470		MOVQ R10, 0x70(SP)		
  0x42fad8		440fb69814010000	MOVZX 0x114(AX), R11		
  0x42fae0		44885c2417		MOVB R11, 0x17(SP)		
  0x42fae5		440fb6a015010000	MOVZX 0x115(AX), R12		
  0x42faed		4488642416		MOVB R12, 0x16(SP)		
  0x42faf2		e8c943ffff		CALL runtime.printlock(SB)	
  0x42faf7		488d05b5f50300		LEAQ 0x3f5b5(IP), AX		
  0x42fafe		48890424		MOVQ AX, 0(SP)			
  0x42fb02		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42fb0b		e8e04cffff		CALL runtime.printstring(SB)	
  0x42fb10		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42fb18		48890424		MOVQ AX, 0(SP)			
  0x42fb1c		e81f4bffff		CALL runtime.printint(SB)	
  0x42fb21		488d0505f60300		LEAQ 0x3f605(IP), AX		
  0x42fb28		48890424		MOVQ AX, 0(SP)			
  0x42fb2c		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x42fb35		e8b64cffff		CALL runtime.printstring(SB)	
  0x42fb3a		8b442420		MOVL 0x20(SP), AX		
  0x42fb3e		4863c0			MOVSXD AX, AX			
  0x42fb41		48890424		MOVQ AX, 0(SP)			
  0x42fb45		e8f64affff		CALL runtime.printint(SB)	
  0x42fb4a		488d05e7f60300		LEAQ 0x3f6e7(IP), AX		
  0x42fb51		48890424		MOVQ AX, 0(SP)			
  0x42fb55		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x42fb5e		e88d4cffff		CALL runtime.printstring(SB)	
  0x42fb63		488b442440		MOVQ 0x40(SP), AX		
  0x42fb68		48890424		MOVQ AX, 0(SP)			
  0x42fb6c		e8cf4affff		CALL runtime.printint(SB)	
  0x42fb71		488d05f6fc0300		LEAQ 0x3fcf6(IP), AX		
  0x42fb78		48890424		MOVQ AX, 0(SP)			
  0x42fb7c		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x42fb85		e8664cffff		CALL runtime.printstring(SB)	
  0x42fb8a		488b842498000000	MOVQ 0x98(SP), AX		
  0x42fb92		48890424		MOVQ AX, 0(SP)			
  0x42fb96		e8a54affff		CALL runtime.printint(SB)	
  0x42fb9b		488d05defb0300		LEAQ 0x3fbde(IP), AX		
  0x42fba2		48890424		MOVQ AX, 0(SP)			
  0x42fba6		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42fbaf		e83c4cffff		CALL runtime.printstring(SB)	
  0x42fbb4		488b842490000000	MOVQ 0x90(SP), AX		
  0x42fbbc		48890424		MOVQ AX, 0(SP)			
  0x42fbc0		e87b4affff		CALL runtime.printint(SB)	
  0x42fbc5		488d0521fe0300		LEAQ 0x3fe21(IP), AX		
  0x42fbcc		48890424		MOVQ AX, 0(SP)			
  0x42fbd0		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x42fbd9		e8124cffff		CALL runtime.printstring(SB)	
  0x42fbde		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x42fbe6		48890424		MOVQ AX, 0(SP)			
  0x42fbea		488b842480000000	MOVQ 0x80(SP), AX		
  0x42fbf2		4889442408		MOVQ AX, 0x8(SP)		
  0x42fbf7		e8f44bffff		CALL runtime.printstring(SB)	
  0x42fbfc		488d05bdf60300		LEAQ 0x3f6bd(IP), AX		
  0x42fc03		48890424		MOVQ AX, 0(SP)			
  0x42fc07		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42fc10		e8db4bffff		CALL runtime.printstring(SB)	
  0x42fc15		488b842488000000	MOVQ 0x88(SP), AX		
  0x42fc1d		48890424		MOVQ AX, 0(SP)			
  0x42fc21		e81a4affff		CALL runtime.printint(SB)	
  0x42fc26		488d058cf60300		LEAQ 0x3f68c(IP), AX		
  0x42fc2d		48890424		MOVQ AX, 0(SP)			
  0x42fc31		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x42fc3a		e8b14bffff		CALL runtime.printstring(SB)	
  0x42fc3f		488b442470		MOVQ 0x70(SP), AX		
  0x42fc44		48890424		MOVQ AX, 0(SP)			
  0x42fc48		e8f349ffff		CALL runtime.printint(SB)	
  0x42fc4d		488d05fafa0300		LEAQ 0x3fafa(IP), AX		
  0x42fc54		48890424		MOVQ AX, 0(SP)			
  0x42fc58		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x42fc61		e88a4bffff		CALL runtime.printstring(SB)	
  0x42fc66		0fb6442417		MOVZX 0x17(SP), AX		
  0x42fc6b		880424			MOVB AL, 0(SP)			
  0x42fc6e		e82d45ffff		CALL runtime.printbool(SB)	
  0x42fc73		488d0528f80300		LEAQ 0x3f828(IP), AX		
  0x42fc7a		48890424		MOVQ AX, 0(SP)			
  0x42fc7e		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42fc87		e8644bffff		CALL runtime.printstring(SB)	
  0x42fc8c		0fb6442416		MOVZX 0x16(SP), AX		
  0x42fc91		880424			MOVB AL, 0(SP)			
  0x42fc94		e80745ffff		CALL runtime.printbool(SB)	
  0x42fc99		488d051df80300		LEAQ 0x3f81d(IP), AX		
  0x42fca0		48890424		MOVQ AX, 0(SP)			
  0x42fca4		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42fcad		e83e4bffff		CALL runtime.printstring(SB)	
  0x42fcb2		488b442438		MOVQ 0x38(SP), AX		
  0x42fcb7		48890424		MOVQ AX, 0(SP)			
  0x42fcbb		e88049ffff		CALL runtime.printint(SB)	
  0x42fcc0		e88b44ffff		CALL runtime.printnl(SB)	
  0x42fcc5		e87642ffff		CALL runtime.printunlock(SB)	
	for mp := allm; mp != nil; mp = mp.alllink {
  0x42fcca		488b8424c0000000	MOVQ 0xc0(SP), AX	
  0x42fcd2		488b8050010000		MOVQ 0x150(AX), AX	
  0x42fcd9		4885c0			TESTQ AX, AX		
  0x42fcdc		7461			JE 0x42fd3f		
		_p_ := mp.p.ptr()
  0x42fcde		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x42fce5		90			NOPL			
		gp := mp.curg
  0x42fce6		488b90c0000000		MOVQ 0xc0(AX), DX	
		lockedg := mp.lockedg.ptr()
  0x42fced		488b9868010000		MOVQ 0x168(AX), BX	
  0x42fcf4		90			NOPL			
		if _p_ != nil {
  0x42fcf5		4885c9			TESTQ CX, CX		
  0x42fcf8		743e			JE 0x42fd38		
			id1 = _p_.id
  0x42fcfa		8b4908			MOVL 0x8(CX), CX	
		if gp != nil {
  0x42fcfd		4885d2			TESTQ DX, DX		
  0x42fd00		742d			JE 0x42fd2f		
			id2 = gp.goid
  0x42fd02		488b9298000000		MOVQ 0x98(DX), DX	
		print("  M", mp.id, ": p=", id1, " curg=", id2, " mallocing=", mp.mallocing, " throwing=", mp.throwing, " preemptoff=", mp.preemptoff, ""+" locks=", mp.locks, " dying=", mp.dying, " spinning=", mp.spinning, " blocked=", mp.blocked, " lockedg=", id3, "\n")
  0x42fd09		4889542440		MOVQ DX, 0x40(SP)	
  0x42fd0e		894c2420		MOVL CX, 0x20(SP)	
		if lockedg != nil {
  0x42fd12		4885db			TESTQ BX, BX		
  0x42fd15		740c			JE 0x42fd23		
			id3 = lockedg.goid
  0x42fd17		488b9b98000000		MOVQ 0x98(BX), BX	
  0x42fd1e		e942fdffff		JMP 0x42fa65		
  0x42fd23		48c7c3ffffffff		MOVQ $-0x1, BX		
		if lockedg != nil {
  0x42fd2a		e936fdffff		JMP 0x42fa65		
  0x42fd2f		48c7c2ffffffff		MOVQ $-0x1, DX		
		if gp != nil {
  0x42fd36		ebd1			JMP 0x42fd09		
  0x42fd38		b9ffffffff		MOVL $-0x1, CX		
		if _p_ != nil {
  0x42fd3d		ebbe			JMP 0x42fcfd		
	lock(&allglock)
  0x42fd3f		488d05dacf0a00		LEAQ runtime.allglock(SB), AX	
  0x42fd46		48890424		MOVQ AX, 0(SP)			
  0x42fd4a		e89189fdff		CALL runtime.lock(SB)		
  0x42fd4f		31c0			XORL AX, AX			
	for gi := 0; gi < len(allgs); gi++ {
  0x42fd51		e907010000		JMP 0x42fe5d		
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")
  0x42fd56		4889bc24b8000000	MOVQ DI, 0xb8(SP)		
  0x42fd5e		4c89442428		MOVQ R8, 0x28(SP)		
  0x42fd63		488b8198000000		MOVQ 0x98(CX), AX		
  0x42fd6a		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x42fd72		e84941ffff		CALL runtime.printlock(SB)	
  0x42fd77		488d0532f30300		LEAQ 0x3f332(IP), AX		
  0x42fd7e		48890424		MOVQ AX, 0(SP)			
  0x42fd82		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x42fd8b		e8604affff		CALL runtime.printstring(SB)	
  0x42fd90		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x42fd98		48890424		MOVQ AX, 0(SP)			
  0x42fd9c		e89f48ffff		CALL runtime.printint(SB)	
  0x42fda1		488d05a5f70300		LEAQ 0x3f7a5(IP), AX		
  0x42fda8		48890424		MOVQ AX, 0(SP)			
  0x42fdac		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42fdb5		e8364affff		CALL runtime.printstring(SB)	
  0x42fdba		8b442418		MOVL 0x18(SP), AX		
  0x42fdbe		89c0			MOVL AX, AX			
  0x42fdc0		48890424		MOVQ AX, 0(SP)			
  0x42fdc4		e87747ffff		CALL runtime.printuint(SB)	
  0x42fdc9		488d05b1f20300		LEAQ 0x3f2b1(IP), AX		
  0x42fdd0		48890424		MOVQ AX, 0(SP)			
  0x42fdd4		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x42fddd		e80e4affff		CALL runtime.printstring(SB)	
  0x42fde2		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x42fdea		48890424		MOVQ AX, 0(SP)			
  0x42fdee		488b442428		MOVQ 0x28(SP), AX		
  0x42fdf3		4889442408		MOVQ AX, 0x8(SP)		
  0x42fdf8		e8f349ffff		CALL runtime.printstring(SB)	
  0x42fdfd		488d0519f30300		LEAQ 0x3f319(IP), AX		
  0x42fe04		48890424		MOVQ AX, 0(SP)			
  0x42fe08		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x42fe11		e8da49ffff		CALL runtime.printstring(SB)	
  0x42fe16		488b442450		MOVQ 0x50(SP), AX		
  0x42fe1b		48890424		MOVQ AX, 0(SP)			
  0x42fe1f		e81c48ffff		CALL runtime.printint(SB)	
  0x42fe24		488d059bf60300		LEAQ 0x3f69b(IP), AX		
  0x42fe2b		48890424		MOVQ AX, 0(SP)			
  0x42fe2f		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x42fe38		e8b349ffff		CALL runtime.printstring(SB)	
  0x42fe3d		488b442448		MOVQ 0x48(SP), AX		
  0x42fe42		48890424		MOVQ AX, 0(SP)			
  0x42fe46		e8f547ffff		CALL runtime.printint(SB)	
  0x42fe4b		e80043ffff		CALL runtime.printnl(SB)	
  0x42fe50		e8eb40ffff		CALL runtime.printunlock(SB)	
	for gi := 0; gi < len(allgs); gi++ {
  0x42fe55		488b442468		MOVQ 0x68(SP), AX		
  0x42fe5a		48ffc0			INCQ AX				
  0x42fe5d		488b0d9c1b0900		MOVQ runtime.allgs(SB), CX	
  0x42fe64		4839059d1b0900		CMPQ AX, runtime.allgs+8(SB)	
  0x42fe6b		0f8e9c000000		JLE 0x42ff0d			
		gp := allgs[gi]
  0x42fe71		488b0cc1		MOVQ 0(CX)(AX*8), CX	
		mp := gp.m
  0x42fe75		488b5130		MOVQ 0x30(CX), DX	
		lockedm := gp.lockedm.ptr()
  0x42fe79		488b99d8000000		MOVQ 0xd8(CX), BX	
  0x42fe80		90			NOPL			
		if mp != nil {
  0x42fe81		4885d2			TESTQ DX, DX		
  0x42fe84		747e			JE 0x42ff04		
			id1 = mp.id
  0x42fe86		488b92e8000000		MOVQ 0xe8(DX), DX	
		if lockedm != nil {
  0x42fe8d		4885db			TESTQ BX, BX		
  0x42fe90		7469			JE 0x42fefb		
			id2 = lockedm.id
  0x42fe92		488b9be8000000		MOVQ 0xe8(BX), BX	
	for gi := 0; gi < len(allgs); gi++ {
  0x42fe99		4889442468		MOVQ AX, 0x68(SP)	
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")
  0x42fe9e		48895c2448		MOVQ BX, 0x48(SP)	
  0x42fea3		4889542450		MOVQ DX, 0x50(SP)	
  0x42fea8		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x42fea9		8bb190000000		MOVL 0x90(CX), SI	
  0x42feaf		89742418		MOVL SI, 0x18(SP)	
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")
  0x42feb3		0fb6b9b0000000		MOVZX 0xb0(CX), DI	
  0x42feba		90			NOPL			
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x42febb		4084ff			TESTL DI, DI		
  0x42febe		7312			JAE 0x42fed2		
  0x42fec0		488d3d6b060400		LEAQ 0x4066b(IP), DI	
  0x42fec7		41b813000000		MOVL $0x13, R8		
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")
  0x42fecd		e984feffff		JMP 0x42fd56		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x42fed2		4080ff18		CMPL $0x18, DI		
  0x42fed6		73e8			JAE 0x42fec0		
	return waitReasonStrings[w]
  0x42fed8		4883ff18		CMPQ $0x18, DI				
  0x42fedc		0f8379010000		JAE 0x43005b				
  0x42fee2		48c1e704		SHLQ $0x4, DI				
  0x42fee6		4c8d0d13020900		LEAQ runtime.waitReasonStrings(SB), R9	
  0x42feed		4d8b443908		MOVQ 0x8(R9)(DI*1), R8			
  0x42fef2		498b3c39		MOVQ 0(R9)(DI*1), DI			
		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=", id1, " lockedm=", id2, "\n")
  0x42fef6		e95bfeffff		JMP 0x42fd56		
  0x42fefb		48c7c3ffffffff		MOVQ $-0x1, BX		
		if lockedm != nil {
  0x42ff02		eb95			JMP 0x42fe99		
  0x42ff04		48c7c2ffffffff		MOVQ $-0x1, DX		
		if mp != nil {
  0x42ff0b		eb80			JMP 0x42fe8d		
	unlock(&allglock)
  0x42ff0d		488d050cce0a00		LEAQ runtime.allglock(SB), AX	
  0x42ff14		48890424		MOVQ AX, 0(SP)			
  0x42ff18		e87389fdff		CALL runtime.unlock(SB)		
	unlock(&sched.lock)
  0x42ff1d		488d058c1d0900		LEAQ runtime.sched+16(SB), AX	
  0x42ff24		48890424		MOVQ AX, 0(SP)			
  0x42ff28		e86389fdff		CALL runtime.unlock(SB)		
}
  0x42ff2d		488bac24d8000000	MOVQ 0xd8(SP), BP	
  0x42ff35		4881c4e0000000		ADDQ $0xe0, SP		
  0x42ff3c		c3			RET			
		unlock(&sched.lock)
  0x42ff3d		488d056c1d0900		LEAQ runtime.sched+16(SB), AX	
  0x42ff44		48890424		MOVQ AX, 0(SP)			
  0x42ff48		e84389fdff		CALL runtime.unlock(SB)		
		return
  0x42ff4d		488bac24d8000000	MOVQ 0xd8(SP), BP	
  0x42ff55		4881c4e0000000		ADDQ $0xe0, SP		
  0x42ff5c		c3			RET			
		print(" gcwaiting=", sched.gcwaiting, " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", sched.sysmonwait, "\n")
  0x42ff5d		8b05351e0900		MOVL runtime.sched+248(SB), AX		
  0x42ff63		48898424a8000000	MOVQ AX, 0xa8(SP)			
  0x42ff6b		48630d521d0900		MOVSXD runtime.sched+36(SB), CX		
  0x42ff72		48898c24b0000000	MOVQ CX, 0xb0(SP)			
  0x42ff7a		4863151b1e0900		MOVSXD runtime.sched+252(SB), DX	
  0x42ff81		4889942498000000	MOVQ DX, 0x98(SP)			
  0x42ff89		8b1d191e0900		MOVL runtime.sched+264(SB), BX		
  0x42ff8f		48899c24a0000000	MOVQ BX, 0xa0(SP)			
  0x42ff97		e8243fffff		CALL runtime.printlock(SB)		
  0x42ff9c		488d0589f80300		LEAQ 0x3f889(IP), AX			
  0x42ffa3		48890424		MOVQ AX, 0(SP)				
  0x42ffa7		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x42ffb0		e83b48ffff		CALL runtime.printstring(SB)		
  0x42ffb5		488b8424a8000000	MOVQ 0xa8(SP), AX			
  0x42ffbd		48890424		MOVQ AX, 0(SP)				
  0x42ffc1		e87a45ffff		CALL runtime.printuint(SB)		
  0x42ffc6		488d0537fd0300		LEAQ 0x3fd37(IP), AX			
  0x42ffcd		48890424		MOVQ AX, 0(SP)				
  0x42ffd1		48c74424080e000000	MOVQ $0xe, 0x8(SP)			
  0x42ffda		e81148ffff		CALL runtime.printstring(SB)		
  0x42ffdf		488b8424b0000000	MOVQ 0xb0(SP), AX			
  0x42ffe7		48890424		MOVQ AX, 0(SP)				
  0x42ffeb		e85046ffff		CALL runtime.printint(SB)		
  0x42fff0		488d0561f70300		LEAQ 0x3f761(IP), AX			
  0x42fff7		48890424		MOVQ AX, 0(SP)				
  0x42fffb		48c74424080a000000	MOVQ $0xa, 0x8(SP)			
  0x430004		e8e747ffff		CALL runtime.printstring(SB)		
  0x430009		488b842498000000	MOVQ 0x98(SP), AX			
  0x430011		48890424		MOVQ AX, 0(SP)				
  0x430015		e82646ffff		CALL runtime.printint(SB)		
  0x43001a		488d0508fa0300		LEAQ 0x3fa08(IP), AX			
  0x430021		48890424		MOVQ AX, 0(SP)				
  0x430025		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x43002e		e8bd47ffff		CALL runtime.printstring(SB)		
  0x430033		488b8424a0000000	MOVQ 0xa0(SP), AX			
  0x43003b		48890424		MOVQ AX, 0(SP)				
  0x43003f		e8fc44ffff		CALL runtime.printuint(SB)		
  0x430044		e80741ffff		CALL runtime.printnl(SB)		
  0x430049		e8f23effff		CALL runtime.printunlock(SB)		
func schedtrace(detailed bool) {
  0x43004e		0fb68424e8000000	MOVZX 0xe8(SP), AX	
		print(" gcwaiting=", sched.gcwaiting, " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", sched.sysmonwait, "\n")
  0x430056		e958f7ffff		JMP 0x42f7b3		
	return waitReasonStrings[w]
  0x43005b		e8c01effff		CALL runtime.panicindex(SB)	
  0x430060		0f0b			UD2				
func schedtrace(detailed bool) {
  0x430062		e819780100		CALL runtime.morestack_noctxt(SB)	
  0x430067		e924f5ffff		JMP runtime.schedtrace(SB)		

TEXT runtime.schedEnableUser(SB) /usr/local/go/src/runtime/proc.go
func schedEnableUser(enable bool) {
  0x430070		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430079		483b6110		CMPQ 0x10(CX), SP	
  0x43007d		0f8628010000		JBE 0x4301ab		
  0x430083		4883ec20		SUBQ $0x20, SP		
  0x430087		48896c2418		MOVQ BP, 0x18(SP)	
  0x43008c		488d6c2418		LEAQ 0x18(SP), BP	
	lock(&sched.lock)
  0x430091		488d05181c0900		LEAQ runtime.sched+16(SB), AX	
  0x430098		48890424		MOVQ AX, 0(SP)			
  0x43009c		e83f86fdff		CALL runtime.lock(SB)		
	if sched.disable.user == !enable {
  0x4300a1		0fb6442428		MOVZX 0x28(SP), AX		
  0x4300a6		89c1			MOVL AX, CX			
  0x4300a8		83f001			XORL $0x1, AX			
  0x4300ab		38055f1c0900		CMPB AL, runtime.sched+112(SB)	
  0x4300b1		0f84da000000		JE 0x430191			
	sched.disable.user = !enable
  0x4300b7		8805531c0900		MOVB AL, runtime.sched+112(SB)	
func schedEnableUser(enable bool) {
  0x4300bd		84c9			TESTL CL, CL		
	if enable {
  0x4300bf		0f84ba000000		JE 0x43017f		
		n := sched.disable.n
  0x4300c5		8b055d1c0900		MOVL runtime.sched+136(SB), AX	
		sched.disable.n = 0
  0x4300cb		c705531c090000000000	MOVL $0x0, runtime.sched+136(SB)	
		globrunqputbatch(&sched.disable.runnable, n)
  0x4300d5		90			NOPL			
	sched.runq.pushBackAll(*batch)
  0x4300d6		90			NOPL				
  0x4300d7		488b0d3a1c0900		MOVQ runtime.sched+120(SB), CX	
  0x4300de		488b153b1c0900		MOVQ runtime.sched+128(SB), DX	
	if q2.tail == 0 {
  0x4300e5		4885d2			TESTQ DX, DX		
  0x4300e8		755d			JNE 0x430147		
		n := sched.disable.n
  0x4300ea		89442410		MOVL AX, 0x10(SP)	
	sched.runqsize += n
  0x4300ee		0105141c0900		ADDL AX, runtime.sched+104(SB)	
	*batch = gQueue{}
  0x4300f4		0f57c0			XORPS X0, X0				
  0x4300f7		0f11051a1c0900		MOVUPS X0, runtime.sched+120(SB)	
		unlock(&sched.lock)
  0x4300fe		488d0dab1b0900		LEAQ runtime.sched+16(SB), CX	
  0x430105		48890c24		MOVQ CX, 0(SP)			
  0x430109		e88287fdff		CALL runtime.unlock(SB)		
		for ; n != 0 && sched.npidle != 0; n-- {
  0x43010e		8b442410		MOVL 0x10(SP), AX	
  0x430112		eb1c			JMP 0x430130		
  0x430114		89442414		MOVL AX, 0x14(SP)	
			startm(nil, false)
  0x430118		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x430120		c644240800		MOVB $0x0, 0x8(SP)	
  0x430125		e8468effff		CALL runtime.startm(SB)	
		for ; n != 0 && sched.npidle != 0; n-- {
  0x43012a		8b442414		MOVL 0x14(SP), AX		
  0x43012e		ffc8			DECL AX				
  0x430130		85c0			TESTL AX, AX			
  0x430132		7409			JE 0x43013d			
  0x430134		833db51b090000		CMPL $0x0, runtime.sched+80(SB)	
  0x43013b		75d7			JNE 0x430114			
  0x43013d		488b6c2418		MOVQ 0x18(SP), BP		
  0x430142		4883c420		ADDQ $0x20, SP			
  0x430146		c3			RET				
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x430147		4889d3			MOVQ DX, BX		
	q2.tail.ptr().schedlink = 0
  0x43014a		90			NOPL			
  0x43014b		48c782a000000000000000	MOVQ $0x0, 0xa0(DX)	
	if q.tail != 0 {
  0x430156		488b15a31b0900		MOVQ runtime.sched+96(SB), DX	
  0x43015d		4885d2			TESTQ DX, DX			
  0x430160		7414			JE 0x430176			
		q.tail.ptr().schedlink = q2.head
  0x430162		90			NOPL			
  0x430163		48898aa0000000		MOVQ CX, 0xa0(DX)	
	q.tail = q2.tail
  0x43016a		48891d8f1b0900		MOVQ BX, runtime.sched+96(SB)	
	sched.runq.pushBackAll(*batch)
  0x430171		e974ffffff		JMP 0x4300ea		
		q.head = q2.head
  0x430176		48890d7b1b0900		MOVQ CX, runtime.sched+88(SB)	
  0x43017d		ebeb			JMP 0x43016a			
		unlock(&sched.lock)
  0x43017f		488d052a1b0900		LEAQ runtime.sched+16(SB), AX	
  0x430186		48890424		MOVQ AX, 0(SP)			
  0x43018a		e80187fdff		CALL runtime.unlock(SB)		
  0x43018f		ebac			JMP 0x43013d			
		unlock(&sched.lock)
  0x430191		488d05181b0900		LEAQ runtime.sched+16(SB), AX	
  0x430198		48890424		MOVQ AX, 0(SP)			
  0x43019c		e8ef86fdff		CALL runtime.unlock(SB)		
		return
  0x4301a1		488b6c2418		MOVQ 0x18(SP), BP	
  0x4301a6		4883c420		ADDQ $0x20, SP		
  0x4301aa		c3			RET			
func schedEnableUser(enable bool) {
  0x4301ab		e8d0760100		CALL runtime.morestack_noctxt(SB)	
  0x4301b0		e9bbfeffff		JMP runtime.schedEnableUser(SB)		

TEXT runtime.schedEnabled(SB) /usr/local/go/src/runtime/proc.go
func schedEnabled(gp *g) bool {
  0x4301c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4301c9		483b6110		CMPQ 0x10(CX), SP	
  0x4301cd		764c			JBE 0x43021b		
  0x4301cf		4883ec20		SUBQ $0x20, SP		
  0x4301d3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4301d8		488d6c2418		LEAQ 0x18(SP), BP	
	if sched.disable.user {
  0x4301dd		803d2c1b090000		CMPB $0x0, runtime.sched+112(SB)	
  0x4301e4		7426			JE 0x43020c				
		return isSystemGoroutine(gp, true)
  0x4301e6		488b442428		MOVQ 0x28(SP), AX			
  0x4301eb		48890424		MOVQ AX, 0(SP)				
  0x4301ef		c644240801		MOVB $0x1, 0x8(SP)			
  0x4301f4		e8170f0100		CALL runtime.isSystemGoroutine(SB)	
  0x4301f9		0fb6442410		MOVZX 0x10(SP), AX			
  0x4301fe		88442430		MOVB AL, 0x30(SP)			
  0x430202		488b6c2418		MOVQ 0x18(SP), BP			
  0x430207		4883c420		ADDQ $0x20, SP				
  0x43020b		c3			RET					
	return true
  0x43020c		c644243001		MOVB $0x1, 0x30(SP)	
  0x430211		488b6c2418		MOVQ 0x18(SP), BP	
  0x430216		4883c420		ADDQ $0x20, SP		
  0x43021a		c3			RET			
func schedEnabled(gp *g) bool {
  0x43021b		e860760100		CALL runtime.morestack_noctxt(SB)	
  0x430220		eb9e			JMP runtime.schedEnabled(SB)		

TEXT runtime.globrunqget(SB) /usr/local/go/src/runtime/proc.go
func globrunqget(_p_ *p, max int32) *g {
  0x430230		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430239		483b6110		CMPQ 0x10(CX), SP	
  0x43023d		0f862e010000		JBE 0x430371		
  0x430243		4883ec30		SUBQ $0x30, SP		
  0x430247		48896c2428		MOVQ BP, 0x28(SP)	
  0x43024c		488d6c2428		LEAQ 0x28(SP), BP	
	if sched.runqsize == 0 {
  0x430251		8b05b11a0900		MOVL runtime.sched+104(SB), AX	
  0x430257		85c0			TESTL AX, AX			
  0x430259		0f84f8000000		JE 0x430357			
	n := sched.runqsize/gomaxprocs + 1
  0x43025f		8b0d7bca0a00		MOVL runtime.gomaxprocs(SB), CX	
  0x430265		85c9			TESTL CX, CX			
  0x430267		0f84fd000000		JE 0x43036a			
	if sched.runqsize == 0 {
  0x43026d		89c2			MOVL AX, DX		
  0x43026f		89d3			MOVL DX, BX		
	n := sched.runqsize/gomaxprocs + 1
  0x430271		83f9ff			CMPL $-0x1, CX		
  0x430274		7405			JE 0x43027b		
  0x430276		99			CDQ			
  0x430277		f7f9			IDIVL CX		
  0x430279		eb04			JMP 0x43027f		
  0x43027b		f7d8			NEGL AX			
  0x43027d		31d2			XORL DX, DX		
  0x43027f		8d4801			LEAL 0x1(AX), CX	
	if n > sched.runqsize {
  0x430282		39d9			CMPL BX, CX		
	if n > int32(len(_p_.runq))/2 {
  0x430284		0f4fcb			CMOVG BX, CX		
	if max > 0 && n > max {
  0x430287		8b542440		MOVL 0x40(SP), DX	
  0x43028b		85d2			TESTL DX, DX		
	if n > sched.runqsize {
  0x43028d		0f8ebd000000		JLE 0x430350		
	if max > 0 && n > max {
  0x430293		39d1			CMPL DX, CX		
  0x430295		0f8eb5000000		JLE 0x430350		
	if n > int32(len(_p_.runq))/2 {
  0x43029b		81fa80000000		CMPL $0x80, DX		
	sched.runqsize -= n
  0x4302a1		b880000000		MOVL $0x80, AX			
  0x4302a6		0f4fd0			CMOVG AX, DX			
  0x4302a9		29d3			SUBL DX, BX			
  0x4302ab		891d571a0900		MOVL BX, runtime.sched+104(SB)	
	gp := sched.runq.pop()
  0x4302b1		90			NOPL			
	gp := q.head.ptr()
  0x4302b2		488b053f1a0900		MOVQ runtime.sched+88(SB), AX	
  0x4302b9		90			NOPL				
	if gp != nil {
  0x4302ba		4885c0			TESTQ AX, AX		
	if n > int32(len(_p_.runq))/2 {
  0x4302bd		741e			JE 0x4302dd		
		q.head = gp.schedlink
  0x4302bf		488b88a0000000		MOVQ 0xa0(AX), CX		
  0x4302c6		48890d2b1a0900		MOVQ CX, runtime.sched+88(SB)	
		if q.head == 0 {
  0x4302cd		4885c9			TESTQ CX, CX		
  0x4302d0		750b			JNE 0x4302dd		
			q.tail = 0
  0x4302d2		48c705231a090000000000	MOVQ $0x0, runtime.sched+96(SB)	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4302dd		4889442420		MOVQ AX, 0x20(SP)	
	n--
  0x4302e2		8d4aff			LEAL -0x1(DX), CX	
	for ; n > 0; n-- {
  0x4302e5		eb24			JMP 0x43030b		
		runqput(_p_, gp1, false)
  0x4302e7		488b442438		MOVQ 0x38(SP), AX		
  0x4302ec		48890424		MOVQ AX, 0(SP)			
  0x4302f0		4889542408		MOVQ DX, 0x8(SP)		
  0x4302f5		c644241000		MOVB $0x0, 0x10(SP)		
  0x4302fa		e851010000		CALL runtime.runqput(SB)	
	for ; n > 0; n-- {
  0x4302ff		8b44241c		MOVL 0x1c(SP), AX	
  0x430303		8d48ff			LEAL -0x1(AX), CX	
	return gp
  0x430306		488b442420		MOVQ 0x20(SP), AX	
	for ; n > 0; n-- {
  0x43030b		85c9			TESTL CX, CX		
  0x43030d		7e32			JLE 0x430341		
  0x43030f		894c241c		MOVL CX, 0x1c(SP)	
		gp1 := sched.runq.pop()
  0x430313		90			NOPL			
	gp := q.head.ptr()
  0x430314		488b15dd190900		MOVQ runtime.sched+88(SB), DX	
  0x43031b		90			NOPL				
	if gp != nil {
  0x43031c		4885d2			TESTQ DX, DX		
  0x43031f		74c6			JE 0x4302e7		
		q.head = gp.schedlink
  0x430321		488b9aa0000000		MOVQ 0xa0(DX), BX		
  0x430328		48891dc9190900		MOVQ BX, runtime.sched+88(SB)	
		if q.head == 0 {
  0x43032f		4885db			TESTQ BX, BX		
  0x430332		75b3			JNE 0x4302e7		
			q.tail = 0
  0x430334		48c705c119090000000000	MOVQ $0x0, runtime.sched+96(SB)	
  0x43033f		eba6			JMP 0x4302e7			
	return gp
  0x430341		4889442448		MOVQ AX, 0x48(SP)	
  0x430346		488b6c2428		MOVQ 0x28(SP), BP	
  0x43034b		4883c430		ADDQ $0x30, SP		
  0x43034f		c3			RET			
	if n > int32(len(_p_.runq))/2 {
  0x430350		89ca			MOVL CX, DX		
  0x430352		e944ffffff		JMP 0x43029b		
		return nil
  0x430357		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x430360		488b6c2428		MOVQ 0x28(SP), BP	
  0x430365		4883c430		ADDQ $0x30, SP		
  0x430369		c3			RET			
	n := sched.runqsize/gomaxprocs + 1
  0x43036a		e8111effff		CALL runtime.panicdivide(SB)	
  0x43036f		0f0b			UD2				
func globrunqget(_p_ *p, max int32) *g {
  0x430371		e80a750100		CALL runtime.morestack_noctxt(SB)	
  0x430376		e9b5feffff		JMP runtime.globrunqget(SB)		

TEXT runtime.pidleput(SB) /usr/local/go/src/runtime/proc.go
func pidleput(_p_ *p) {
  0x430380		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430389		483b6110		CMPQ 0x10(CX), SP	
  0x43038d		7670			JBE 0x4303ff		
  0x43038f		4883ec18		SUBQ $0x18, SP		
  0x430393		48896c2410		MOVQ BP, 0x10(SP)	
  0x430398		488d6c2410		LEAQ 0x10(SP), BP	
	if !runqempty(_p_) {
  0x43039d		488b442420		MOVQ 0x20(SP), AX		
  0x4303a2		48890424		MOVQ AX, 0(SP)			
  0x4303a6		e865000000		CALL runtime.runqempty(SB)	
  0x4303ab		807c240800		CMPB $0x0, 0x8(SP)		
  0x4303b0		7432			JE 0x4303e4			
	_p_.link = sched.pidle
  0x4303b2		488b052f190900		MOVQ runtime.sched+72(SB), AX	
  0x4303b9		488b4c2420		MOVQ 0x20(SP), CX		
  0x4303be		48894110		MOVQ AX, 0x10(CX)		
	sched.pidle.set(_p_)
  0x4303c2		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4303c3		48890d1e190900		MOVQ CX, runtime.sched+72(SB)	
	atomic.Xadd(&sched.npidle, 1) // TODO: fast atomic
  0x4303ca		b801000000		MOVL $0x1, AX			
  0x4303cf		488d0d1a190900		LEAQ runtime.sched+80(SB), CX	
  0x4303d6		f00fc101		LOCK XADDL AX, 0(CX)		
}
  0x4303da		488b6c2410		MOVQ 0x10(SP), BP	
  0x4303df		4883c418		ADDQ $0x18, SP		
  0x4303e3		c3			RET			
		throw("pidleput: P has non-empty run queue")
  0x4303e4		488d05da200400		LEAQ 0x420da(IP), AX	
  0x4303eb		48890424		MOVQ AX, 0(SP)		
  0x4303ef		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x4303f8		e88330ffff		CALL runtime.throw(SB)	
  0x4303fd		0f0b			UD2			
func pidleput(_p_ *p) {
  0x4303ff		e87c740100		CALL runtime.morestack_noctxt(SB)	
  0x430404		e977ffffff		JMP runtime.pidleput(SB)		

TEXT runtime.runqempty(SB) /usr/local/go/src/runtime/proc.go
	for {
  0x430410		488b442408		MOVQ 0x8(SP), AX	
		head := atomic.Load(&_p_.runqhead)
  0x430415		8b88e0050000		MOVL 0x5e0(AX), CX	
		tail := atomic.Load(&_p_.runqtail)
  0x43041b		8b90e4050000		MOVL 0x5e4(AX), DX	
		runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&_p_.runnext)))
  0x430421		488b98e80d0000		MOVQ 0xde8(AX), BX	
		if tail == atomic.Load(&_p_.runqtail) {
  0x430428		8bb0e4050000		MOVL 0x5e4(AX), SI	
  0x43042e		39d6			CMPL DX, SI		
  0x430430		75e3			JNE 0x430415		
			return head == tail && runnext == 0
  0x430432		39ca			CMPL CX, DX		
  0x430434		750b			JNE 0x430441		
  0x430436		4885db			TESTQ BX, BX		
  0x430439		0f94c0			SETE AL			
  0x43043c		88442410		MOVB AL, 0x10(SP)	
  0x430440		c3			RET			
  0x430441		31c0			XORL AX, AX		
  0x430443		ebf7			JMP 0x43043c		

TEXT runtime.runqput(SB) /usr/local/go/src/runtime/proc.go
func runqput(_p_ *p, gp *g, next bool) {
  0x430450		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430459		483b6110		CMPQ 0x10(CX), SP	
  0x43045d		0f86de000000		JBE 0x430541		
  0x430463		4883ec38		SUBQ $0x38, SP		
  0x430467		48896c2430		MOVQ BP, 0x30(SP)	
  0x43046c		488d6c2430		LEAQ 0x30(SP), BP	
  0x430471		0fb64c2450		MOVZX 0x50(SP), CX	
  0x430476		84c9			TESTL CL, CL		
	if next {
  0x430478		0f84b4000000		JE 0x430532		
		oldnext := _p_.runnext
  0x43047e		488b4c2440		MOVQ 0x40(SP), CX	
  0x430483		488b542448		MOVQ 0x48(SP), DX	
  0x430488		eb03			JMP 0x43048d		
		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
  0x43048a		4889da			MOVQ BX, DX		
		oldnext := _p_.runnext
  0x43048d		488b81e80d0000		MOVQ 0xde8(CX), AX	
  0x430494		4889442420		MOVQ AX, 0x20(SP)	
		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
  0x430499		90			NOPL			
  0x43049a		4889d3			MOVQ DX, BX		
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x43049d		f0480fb191e80d0000	LOCK CMPXCHGQ DX, 0xde8(CX)	
  0x4304a6		0f94c2			SETE DL				
  0x4304a9		84d2			TESTL DL, DL			
		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
  0x4304ab		74dd			JE 0x43048a		
		if oldnext == 0 {
  0x4304ad		488b442420		MOVQ 0x20(SP), AX	
  0x4304b2		4885c0			TESTQ AX, AX		
  0x4304b5		7471			JE 0x430528		
		gp = oldnext.ptr()
  0x4304b7		90			NOPL			
		_p_.runq[t%uint32(len(_p_.runq))].set(gp)
  0x4304b8		4889442428		MOVQ AX, 0x28(SP)	
	h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x4304bd		eb0a			JMP 0x4304c9		
	if runqputslow(_p_, gp, h, t) {
  0x4304bf		488b442428		MOVQ 0x28(SP), AX	
	h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x4304c4		488b4c2440		MOVQ 0x40(SP), CX	
  0x4304c9		8b91e0050000		MOVL 0x5e0(CX), DX	
	t := _p_.runqtail
  0x4304cf		8b99e4050000		MOVL 0x5e4(CX), BX	
	if t-h < uint32(len(_p_.runq)) {
  0x4304d5		89de			MOVL BX, SI		
  0x4304d7		29d3			SUBL DX, BX		
  0x4304d9		81fb00010000		CMPL $0x100, BX		
  0x4304df		7227			JB 0x430508		
	if runqputslow(_p_, gp, h, t) {
  0x4304e1		48890c24		MOVQ CX, 0(SP)			
  0x4304e5		4889442408		MOVQ AX, 0x8(SP)		
  0x4304ea		89542410		MOVL DX, 0x10(SP)		
  0x4304ee		89742414		MOVL SI, 0x14(SP)		
  0x4304f2		e859000000		CALL runtime.runqputslow(SB)	
  0x4304f7		807c241800		CMPB $0x0, 0x18(SP)		
  0x4304fc		74c1			JE 0x4304bf			
		return
  0x4304fe		488b6c2430		MOVQ 0x30(SP), BP	
  0x430503		4883c438		ADDQ $0x38, SP		
  0x430507		c3			RET			
		_p_.runq[t%uint32(len(_p_.runq))].set(gp)
  0x430508		400fb6d6		MOVZX SI, DX		
  0x43050c		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x43050d		488984d1e8050000	MOVQ AX, 0x5e8(CX)(DX*8)	
		atomic.StoreRel(&_p_.runqtail, t+1) // store-release, makes the item available for consumption
  0x430515		8d4601			LEAL 0x1(SI), AX	
  0x430518		8781e4050000		XCHGL AX, 0x5e4(CX)	
		return
  0x43051e		488b6c2430		MOVQ 0x30(SP), BP	
  0x430523		4883c438		ADDQ $0x38, SP		
  0x430527		c3			RET			
			return
  0x430528		488b6c2430		MOVQ 0x30(SP), BP	
  0x43052d		4883c438		ADDQ $0x38, SP		
  0x430531		c3			RET			
	h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x430532		488b4c2440		MOVQ 0x40(SP), CX	
		_p_.runq[t%uint32(len(_p_.runq))].set(gp)
  0x430537		488b442448		MOVQ 0x48(SP), AX	
	if next {
  0x43053c		e977ffffff		JMP 0x4304b8		
func runqput(_p_ *p, gp *g, next bool) {
  0x430541		e83a730100		CALL runtime.morestack_noctxt(SB)	
  0x430546		e905ffffff		JMP runtime.runqput(SB)			

TEXT runtime.runqputslow(SB) /usr/local/go/src/runtime/proc.go
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
  0x430550		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430559		488d842448fcffff	LEAQ 0xfffffc48(SP), AX	
  0x430561		483b4110		CMPQ 0x10(CX), AX	
  0x430565		0f8609020000		JBE 0x430774		
  0x43056b		4881ec38040000		SUBQ $0x438, SP		
  0x430572		4889ac2430040000	MOVQ BP, 0x430(SP)	
  0x43057a		488dac2430040000	LEAQ 0x430(SP), BP	
	var batch [len(_p_.runq)/2 + 1]*g
  0x430582		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43058b		488d7c2430		LEAQ 0x30(SP), DI		
  0x430590		0f57c0			XORPS X0, X0			
  0x430593		48896c24f0		MOVQ BP, -0x10(SP)		
  0x430598		488d6c24f0		LEAQ -0x10(SP), BP		
  0x43059d		e84e9a0100		CALL runtime.duffzero(SB)	
  0x4305a2		488b6d00		MOVQ 0(BP), BP			
	n := t - h
  0x4305a6		8b8c2454040000		MOVL 0x454(SP), CX	
  0x4305ad		8b842450040000		MOVL 0x450(SP), AX	
  0x4305b4		29c1			SUBL AX, CX		
	n = n / 2
  0x4305b6		d1e9			SHRL $0x1, CX		
	if n != uint32(len(_p_.runq)/2) {
  0x4305b8		81f980000000		CMPL $0x80, CX		
  0x4305be		0f8595010000		JNE 0x430759		
	for i := uint32(0); i < n; i++ {
  0x4305c4		488b942440040000	MOVQ 0x440(SP), DX	
  0x4305cc		31db			XORL BX, BX		
  0x4305ce		eb0e			JMP 0x4305de		
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x4305d0		89df			MOVL BX, DI		
  0x4305d2		48c1e303		SHLQ $0x3, BX		
  0x4305d6		4889741c28		MOVQ SI, 0x28(SP)(BX*1)	
	for i := uint32(0); i < n; i++ {
  0x4305db		8d5f01			LEAL 0x1(DI), BX	
  0x4305de		39cb			CMPL CX, BX		
  0x4305e0		7320			JAE 0x430602		
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x4305e2		8402			TESTB AL, 0(DX)			
  0x4305e4		8d3403			LEAL 0(BX)(AX*1), SI		
  0x4305e7		400fb6f6		MOVZX SI, SI			
  0x4305eb		488bb4f2e8050000	MOVQ 0x5e8(DX)(SI*8), SI	
  0x4305f3		90			NOPL				
  0x4305f4		4881fb81000000		CMPQ $0x81, BX			
  0x4305fb		72d3			JB 0x4305d0			
  0x4305fd		e950010000		JMP 0x430752			
	if !atomic.CasRel(&_p_.runqhead, h, h+n) { // cas-release, commits consume
  0x430602		8d1c01			LEAL 0(CX)(AX*1), BX		
  0x430605		f00fb19ae0050000	LOCK CMPXCHGL BX, 0x5e0(DX)	
  0x43060d		0f94c2			SETE DL				
  0x430610		84d2			TESTL DL, DL			
  0x430612		0f8414010000		JE 0x43072c			
	batch[n] = gp
  0x430618		4881f981000000		CMPQ $0x81, CX		
  0x43061f		0f8326010000		JAE 0x43074b		
  0x430625		89c8			MOVL CX, AX		
  0x430627		48c1e103		SHLQ $0x3, CX		
  0x43062b		488b942448040000	MOVQ 0x448(SP), DX	
  0x430633		4889540c28		MOVQ DX, 0x28(SP)(CX*1)	
  0x430638		31c9			XORL CX, CX		
	for i := uint32(0); i < n; i++ {
  0x43063a		eb0d			JMP 0x430649		
		batch[i].schedlink.set(batch[i+1])
  0x43063c		90			NOPL			
  0x43063d		488b5ccc28		MOVQ 0x28(SP)(CX*8), BX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x430642		48899aa0000000		MOVQ BX, 0xa0(DX)	
	for i := uint32(0); i < n; i++ {
  0x430649		39c1			CMPL AX, CX		
  0x43064b		7324			JAE 0x430671		
		batch[i].schedlink.set(batch[i+1])
  0x43064d		4881f981000000		CMPQ $0x81, CX		
  0x430654		0f83ea000000		JAE 0x430744		
  0x43065a		488b54cc28		MOVQ 0x28(SP)(CX*8), DX	
  0x43065f		8402			TESTB AL, 0(DX)		
  0x430661		ffc1			INCL CX			
  0x430663		4881f981000000		CMPQ $0x81, CX		
  0x43066a		72d0			JB 0x43063c		
  0x43066c		e9d3000000		JMP 0x430744		
	n = n / 2
  0x430671		89442414		MOVL AX, 0x14(SP)	
	var q gQueue
  0x430675		0f11442418		MOVUPS X0, 0x18(SP)	
	q.head.set(batch[0])
  0x43067a		90			NOPL			
  0x43067b		488b4c2428		MOVQ 0x28(SP), CX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x430680		48894c2418		MOVQ CX, 0x18(SP)	
	q.tail.set(batch[n])
  0x430685		90			NOPL			
  0x430686		488b4cc428		MOVQ 0x28(SP)(AX*8), CX	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x43068b		48894c2420		MOVQ CX, 0x20(SP)	
	lock(&sched.lock)
  0x430690		488d0d19160900		LEAQ runtime.sched+16(SB), CX	
  0x430697		48890c24		MOVQ CX, 0(SP)			
  0x43069b		e84080fdff		CALL runtime.lock(SB)		
	globrunqputbatch(&q, int32(n+1))
  0x4306a0		90			NOPL			
	sched.runq.pushBackAll(*batch)
  0x4306a1		90			NOPL			
  0x4306a2		488b442420		MOVQ 0x20(SP), AX	
  0x4306a7		488b4c2418		MOVQ 0x18(SP), CX	
	if q2.tail == 0 {
  0x4306ac		4885c0			TESTQ AX, AX		
  0x4306af		7546			JNE 0x4306f7		
	sched.runqsize += n
  0x4306b1		8b0551160900		MOVL runtime.sched+104(SB), AX	
  0x4306b7		8b4c2414		MOVL 0x14(SP), CX		
  0x4306bb		8d0408			LEAL 0(AX)(CX*1), AX		
  0x4306be		8d4001			LEAL 0x1(AX), AX		
  0x4306c1		890541160900		MOVL AX, runtime.sched+104(SB)	
	*batch = gQueue{}
  0x4306c7		0f57c0			XORPS X0, X0		
  0x4306ca		0f11442418		MOVUPS X0, 0x18(SP)	
	unlock(&sched.lock)
  0x4306cf		488d05da150900		LEAQ runtime.sched+16(SB), AX	
  0x4306d6		48890424		MOVQ AX, 0(SP)			
  0x4306da		e8b181fdff		CALL runtime.unlock(SB)		
	return true
  0x4306df		c684245804000001	MOVB $0x1, 0x458(SP)	
  0x4306e7		488bac2430040000	MOVQ 0x430(SP), BP	
  0x4306ef		4881c438040000		ADDQ $0x438, SP		
  0x4306f6		c3			RET			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4306f7		4889c2			MOVQ AX, DX		
	q2.tail.ptr().schedlink = 0
  0x4306fa		90			NOPL			
  0x4306fb		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x430706		488b05f3150900		MOVQ runtime.sched+96(SB), AX	
  0x43070d		4885c0			TESTQ AX, AX			
  0x430710		7411			JE 0x430723			
		q.tail.ptr().schedlink = q2.head
  0x430712		90			NOPL			
  0x430713		488988a0000000		MOVQ CX, 0xa0(AX)	
	q.tail = q2.tail
  0x43071a		488915df150900		MOVQ DX, runtime.sched+96(SB)	
	sched.runq.pushBackAll(*batch)
  0x430721		eb8e			JMP 0x4306b1		
		q.head = q2.head
  0x430723		48890dce150900		MOVQ CX, runtime.sched+88(SB)	
  0x43072a		ebee			JMP 0x43071a			
		return false
  0x43072c		c684245804000000	MOVB $0x0, 0x458(SP)	
  0x430734		488bac2430040000	MOVQ 0x430(SP), BP	
  0x43073c		4881c438040000		ADDQ $0x438, SP		
  0x430743		c3			RET			
		batch[i].schedlink.set(batch[i+1])
  0x430744		e8d717ffff		CALL runtime.panicindex(SB)	
  0x430749		0f0b			UD2				
	batch[n] = gp
  0x43074b		e8d017ffff		CALL runtime.panicindex(SB)	
  0x430750		0f0b			UD2				
		batch[i] = _p_.runq[(h+i)%uint32(len(_p_.runq))].ptr()
  0x430752		e8c917ffff		CALL runtime.panicindex(SB)	
  0x430757		0f0b			UD2				
		throw("runqputslow: queue is not full")
  0x430759		488d05c8140400		LEAQ 0x414c8(IP), AX	
  0x430760		48890424		MOVQ AX, 0(SP)		
  0x430764		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x43076d		e80e2dffff		CALL runtime.throw(SB)	
  0x430772		0f0b			UD2			
func runqputslow(_p_ *p, gp *g, h, t uint32) bool {
  0x430774		e807710100		CALL runtime.morestack_noctxt(SB)	
  0x430779		e9d2fdffff		JMP runtime.runqputslow(SB)		

TEXT runtime.runqget(SB) /usr/local/go/src/runtime/proc.go
func runqget(_p_ *p) (gp *g, inheritTime bool) {
  0x430780		4883ec10		SUBQ $0x10, SP		
  0x430784		48896c2408		MOVQ BP, 0x8(SP)	
  0x430789		488d6c2408		LEAQ 0x8(SP), BP	
	for {
  0x43078e		488b4c2418		MOVQ 0x18(SP), CX	
		next := _p_.runnext
  0x430793		488b81e80d0000		MOVQ 0xde8(CX), AX	
		if next == 0 {
  0x43079a		4885c0			TESTQ AX, AX		
  0x43079d		7430			JE 0x4307cf		
		next := _p_.runnext
  0x43079f		48890424		MOVQ AX, 0(SP)		
		if _p_.runnext.cas(next, 0) {
  0x4307a3		90			NOPL			
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4307a4		31d2			XORL DX, DX			
  0x4307a6		f0480fb191e80d0000	LOCK CMPXCHGQ DX, 0xde8(CX)	
  0x4307af		0f94c3			SETE BL				
  0x4307b2		84db			TESTL BL, BL			
		if _p_.runnext.cas(next, 0) {
  0x4307b4		74dd			JE 0x430793		
			return next.ptr(), true
  0x4307b6		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x4307b7		488b0424		MOVQ 0(SP), AX		
			return next.ptr(), true
  0x4307bb		4889442420		MOVQ AX, 0x20(SP)	
  0x4307c0		c644242801		MOVB $0x1, 0x28(SP)	
  0x4307c5		488b6c2408		MOVQ 0x8(SP), BP	
  0x4307ca		4883c410		ADDQ $0x10, SP		
  0x4307ce		c3			RET			
		h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x4307cf		8b91e0050000		MOVL 0x5e0(CX), DX	
		t := _p_.runqtail
  0x4307d5		8b99e4050000		MOVL 0x5e4(CX), BX	
		if t == h {
  0x4307db		39d3			CMPL DX, BX		
  0x4307dd		7434			JE 0x430813		
		gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()
  0x4307df		0fb6da			MOVZX DL, BX			
  0x4307e2		488b9cd9e8050000	MOVQ 0x5e8(CX)(BX*8), BX	
  0x4307ea		90			NOPL				
		if atomic.CasRel(&_p_.runqhead, h, h+1) { // cas-release, commits consume
  0x4307eb		8d7201			LEAL 0x1(DX), SI		
  0x4307ee		89d0			MOVL DX, AX			
  0x4307f0		f00fb1b1e0050000	LOCK CMPXCHGL SI, 0x5e0(CX)	
  0x4307f8		0f94c2			SETE DL				
  0x4307fb		84d2			TESTL DL, DL			
  0x4307fd		74d0			JE 0x4307cf			
			return gp, false
  0x4307ff		48895c2420		MOVQ BX, 0x20(SP)	
  0x430804		c644242800		MOVB $0x0, 0x28(SP)	
  0x430809		488b6c2408		MOVQ 0x8(SP), BP	
  0x43080e		4883c410		ADDQ $0x10, SP		
  0x430812		c3			RET			
			return nil, false
  0x430813		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x43081c		c644242800		MOVB $0x0, 0x28(SP)	
  0x430821		488b6c2408		MOVQ 0x8(SP), BP	
  0x430826		4883c410		ADDQ $0x10, SP		
  0x43082a		c3			RET			

TEXT runtime.runqgrab(SB) /usr/local/go/src/runtime/proc.go
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x430830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430839		483b6110		CMPQ 0x10(CX), SP	
  0x43083d		0f8633010000		JBE 0x430976		
  0x430843		4883ec18		SUBQ $0x18, SP		
  0x430847		48896c2410		MOVQ BP, 0x10(SP)	
  0x43084c		488d6c2410		LEAQ 0x10(SP), BP	
	for {
  0x430851		488b4c2428		MOVQ 0x28(SP), CX	
  0x430856		8b542430		MOVL 0x30(SP), DX	
  0x43085a		488b5c2420		MOVQ 0x20(SP), BX	
  0x43085f		0fb6742434		MOVZX 0x34(SP), SI	
		h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x430864		8bbbe0050000		MOVL 0x5e0(BX), DI	
		t := atomic.LoadAcq(&_p_.runqtail) // load-acquire, synchronize with the producer
  0x43086a		448b83e4050000		MOVL 0x5e4(BX), R8	
		n := t - h
  0x430871		4129f8			SUBL DI, R8		
		n = n - n/2
  0x430874		4589c1			MOVL R8, R9		
  0x430877		41d1e8			SHRL $0x1, R8		
  0x43087a		4529c1			SUBL R8, R9		
		if n == 0 {
  0x43087d		4585c9			TESTL R9, R9		
  0x430880		0f8589000000		JNE 0x43090f		
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x430886		4084f6			TESTL SI, SI		
			if stealRunNextG {
  0x430889		7472			JE 0x4308fd		
				if next := _p_.runnext; next != 0 {
  0x43088b		488b83e80d0000		MOVQ 0xde8(BX), AX	
  0x430892		4885c0			TESTQ AX, AX		
  0x430895		7466			JE 0x4308fd		
  0x430897		4889442408		MOVQ AX, 0x8(SP)	
					if _p_.status == _Prunning {
  0x43089c		837b0c01		CMPL $0x1, 0xc(BX)	
  0x4308a0		7435			JE 0x4308d7		
					if !_p_.runnext.cas(next, 0) {
  0x4308a2		90			NOPL			
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4308a3		31ff			XORL DI, DI			
  0x4308a5		f0480fb1bbe80d0000	LOCK CMPXCHGQ DI, 0xde8(BX)	
  0x4308ae		410f94c0		SETE R8				
  0x4308b2		4584c0			TESTL R8, R8			
					if !_p_.runnext.cas(next, 0) {
  0x4308b5		74ad			JE 0x430864		
					batch[batchHead%uint32(len(batch))] = next
  0x4308b7		8401			TESTB AL, 0(CX)		
  0x4308b9		0fb6c2			MOVZX DL, AX		
  0x4308bc		488b542408		MOVQ 0x8(SP), DX	
  0x4308c1		488914c1		MOVQ DX, 0(CX)(AX*8)	
					return 1
  0x4308c5		c744243801000000	MOVL $0x1, 0x38(SP)	
  0x4308cd		488b6c2410		MOVQ 0x10(SP), BP	
  0x4308d2		4883c418		ADDQ $0x18, SP		
  0x4308d6		c3			RET			
							usleep(3)
  0x4308d7		c7042403000000		MOVL $0x3, 0(SP)	
  0x4308de		e81da60100		CALL runtime.usleep(SB)	
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4308e3		488b442408		MOVQ 0x8(SP), AX	
			batch[(batchHead+i)%uint32(len(batch))] = g
  0x4308e8		488b4c2428		MOVQ 0x28(SP), CX	
  0x4308ed		8b542430		MOVL 0x30(SP), DX	
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4308f1		488b5c2420		MOVQ 0x20(SP), BX	
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x4308f6		0fb6742434		MOVZX 0x34(SP), SI	
					if !_p_.runnext.cas(next, 0) {
  0x4308fb		eba5			JMP 0x4308a2		
			return 0
  0x4308fd		c744243800000000	MOVL $0x0, 0x38(SP)	
  0x430905		488b6c2410		MOVQ 0x10(SP), BP	
  0x43090a		4883c418		ADDQ $0x18, SP		
  0x43090e		c3			RET			
		if n > uint32(len(_p_.runq)/2) { // read inconsistent h and t
  0x43090f		4181f980000000		CMPL $0x80, R9		
  0x430916		7607			JBE 0x43091f		
  0x430918		31ff			XORL DI, DI		
			continue
  0x43091a		e945ffffff		JMP 0x430864		
  0x43091f		31c0			XORL AX, AX		
		for i := uint32(0); i < n; i++ {
  0x430921		eb20			JMP 0x430943		
			batch[(batchHead+i)%uint32(len(batch))] = g
  0x430923		8401			TESTB AL, 0(CX)		
			g := _p_.runq[(h+i)%uint32(len(_p_.runq))]
  0x430925		448d0438		LEAL 0(AX)(DI*1), R8		
  0x430929		450fb6c0		MOVZX R8, R8			
  0x43092d		4e8b84c3e8050000	MOVQ 0x5e8(BX)(R8*8), R8	
			batch[(batchHead+i)%uint32(len(batch))] = g
  0x430935		448d1410		LEAL 0(AX)(DX*1), R10	
  0x430939		450fb6d2		MOVZX R10, R10		
  0x43093d		4e8904d1		MOVQ R8, 0(CX)(R10*8)	
		for i := uint32(0); i < n; i++ {
  0x430941		ffc0			INCL AX			
  0x430943		4439c8			CMPL R9, AX		
  0x430946		72db			JB 0x430923		
		if atomic.CasRel(&_p_.runqhead, h, h+n) { // cas-release, commits consume
  0x430948		458d0439		LEAL 0(R9)(DI*1), R8		
  0x43094c		89f8			MOVL DI, AX			
  0x43094e		f0440fb183e0050000	LOCK CMPXCHGL R8, 0x5e0(BX)	
  0x430957		400f94c7		SETE DI				
  0x43095b		4084ff			TESTL DI, DI			
  0x43095e		7507			JNE 0x430967			
  0x430960		31ff			XORL DI, DI			
		h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers
  0x430962		e9fdfeffff		JMP 0x430864		
			return n
  0x430967		44894c2438		MOVL R9, 0x38(SP)	
  0x43096c		488b6c2410		MOVQ 0x10(SP), BP	
  0x430971		4883c418		ADDQ $0x18, SP		
  0x430975		c3			RET			
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
  0x430976		e8056f0100		CALL runtime.morestack_noctxt(SB)	
  0x43097b		e9b0feffff		JMP runtime.runqgrab(SB)		

TEXT runtime.runqsteal(SB) /usr/local/go/src/runtime/proc.go
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x430980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430989		483b6110		CMPQ 0x10(CX), SP	
  0x43098d		0f86d3000000		JBE 0x430a66		
  0x430993		4883ec30		SUBQ $0x30, SP		
  0x430997		48896c2428		MOVQ BP, 0x28(SP)	
  0x43099c		488d6c2428		LEAQ 0x28(SP), BP	
	t := _p_.runqtail
  0x4309a1		488b442438		MOVQ 0x38(SP), AX	
  0x4309a6		8b88e4050000		MOVL 0x5e4(AX), CX	
  0x4309ac		894c2424		MOVL CX, 0x24(SP)	
	n := runqgrab(p2, &_p_.runq, t, stealRunNextG)
  0x4309b0		488b542440		MOVQ 0x40(SP), DX		
  0x4309b5		48891424		MOVQ DX, 0(SP)			
  0x4309b9		488d90e8050000		LEAQ 0x5e8(AX), DX		
  0x4309c0		4889542408		MOVQ DX, 0x8(SP)		
  0x4309c5		894c2410		MOVL CX, 0x10(SP)		
  0x4309c9		0fb6542448		MOVZX 0x48(SP), DX		
  0x4309ce		88542414		MOVB DL, 0x14(SP)		
  0x4309d2		e859feffff		CALL runtime.runqgrab(SB)	
  0x4309d7		8b442418		MOVL 0x18(SP), AX		
	if n == 0 {
  0x4309db		85c0			TESTL AX, AX		
  0x4309dd		7459			JE 0x430a38		
	gp := _p_.runq[(t+n)%uint32(len(_p_.runq))].ptr()
  0x4309df		8b4c2424		MOVL 0x24(SP), CX		
  0x4309e3		8d1408			LEAL 0(AX)(CX*1), DX		
  0x4309e6		8d52ff			LEAL -0x1(DX), DX		
  0x4309e9		0fb6da			MOVZX DL, BX			
  0x4309ec		488b742438		MOVQ 0x38(SP), SI		
  0x4309f1		488b9cdee8050000	MOVQ 0x5e8(SI)(BX*8), BX	
  0x4309f9		90			NOPL				
	if n == 0 {
  0x4309fa		83f801			CMPL $0x1, AX		
  0x4309fd		742a			JE 0x430a29		
	h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with consumers
  0x4309ff		8bbee0050000		MOVL 0x5e0(SI), DI	
	if t-h+n >= uint32(len(_p_.runq)) {
  0x430a05		29f9			SUBL DI, CX		
  0x430a07		8d0401			LEAL 0(CX)(AX*1), AX	
  0x430a0a		8d40ff			LEAL -0x1(AX), AX	
  0x430a0d		3d00010000		CMPL $0x100, AX		
  0x430a12		7337			JAE 0x430a4b		
	atomic.StoreRel(&_p_.runqtail, t+n) // store-release, makes the item available for consumption
  0x430a14		8796e4050000		XCHGL DX, 0x5e4(SI)	
	return gp
  0x430a1a		48895c2450		MOVQ BX, 0x50(SP)	
  0x430a1f		488b6c2428		MOVQ 0x28(SP), BP	
  0x430a24		4883c430		ADDQ $0x30, SP		
  0x430a28		c3			RET			
		return gp
  0x430a29		48895c2450		MOVQ BX, 0x50(SP)	
  0x430a2e		488b6c2428		MOVQ 0x28(SP), BP	
  0x430a33		4883c430		ADDQ $0x30, SP		
  0x430a37		c3			RET			
		return nil
  0x430a38		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x430a41		488b6c2428		MOVQ 0x28(SP), BP	
  0x430a46		4883c430		ADDQ $0x30, SP		
  0x430a4a		c3			RET			
		throw("runqsteal: runq overflow")
  0x430a4b		488d05a0040400		LEAQ 0x404a0(IP), AX	
  0x430a52		48890424		MOVQ AX, 0(SP)		
  0x430a56		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x430a5f		e81c2affff		CALL runtime.throw(SB)	
  0x430a64		0f0b			UD2			
func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {
  0x430a66		e8156e0100		CALL runtime.morestack_noctxt(SB)	
  0x430a6b		e910ffffff		JMP runtime.runqsteal(SB)		

TEXT runtime.(*randomOrder).reset(SB) /usr/local/go/src/runtime/proc.go
func (ord *randomOrder) reset(count uint32) {
  0x430a70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430a79		483b6110		CMPQ 0x10(CX), SP	
  0x430a7d		0f86f6000000		JBE 0x430b79		
  0x430a83		4883ec50		SUBQ $0x50, SP		
  0x430a87		48896c2448		MOVQ BP, 0x48(SP)	
  0x430a8c		488d6c2448		LEAQ 0x48(SP), BP	
	ord.count = count
  0x430a91		8b442460		MOVL 0x60(SP), AX	
  0x430a95		488b4c2458		MOVQ 0x58(SP), CX	
  0x430a9a		8901			MOVL AX, 0(CX)		
	ord.coprimes = ord.coprimes[:0]
  0x430a9c		48c7411000000000	MOVQ $0x0, 0x10(CX)	
  0x430aa4		ba01000000		MOVL $0x1, DX		
	for i := uint32(1); i <= count; i++ {
  0x430aa9		eb0c			JMP 0x430ab7		
  0x430aab		8d5301			LEAL 0x1(BX), DX	
  0x430aae		8b442460		MOVL 0x60(SP), AX	
			ord.coprimes = append(ord.coprimes, i)
  0x430ab2		488b4c2458		MOVQ 0x58(SP), CX	
	for i := uint32(1); i <= count; i++ {
  0x430ab7		39c2			CMPL AX, DX		
  0x430ab9		0f87b0000000		JA 0x430b6f		
  0x430abf		89542444		MOVL DX, 0x44(SP)	
		if gcd(i, count) == 1 {
  0x430ac3		891424			MOVL DX, 0(SP)		
  0x430ac6		89442404		MOVL AX, 0x4(SP)	
  0x430aca		e8c1000000		CALL runtime.gcd(SB)	
  0x430acf		837c240801		CMPL $0x1, 0x8(SP)	
  0x430ad4		0f8587000000		JNE 0x430b61		
			ord.coprimes = append(ord.coprimes, i)
  0x430ada		488b442458		MOVQ 0x58(SP), AX			
  0x430adf		488b4810		MOVQ 0x10(AX), CX			
  0x430ae3		488b5008		MOVQ 0x8(AX), DX			
  0x430ae7		488b5818		MOVQ 0x18(AX), BX			
  0x430aeb		488d7101		LEAQ 0x1(CX), SI			
  0x430aef		4839de			CMPQ BX, SI				
  0x430af2		7711			JA 0x430b05				
  0x430af4		488d5901		LEAQ 0x1(CX), BX			
  0x430af8		48895810		MOVQ BX, 0x10(AX)			
  0x430afc		8b5c2444		MOVL 0x44(SP), BX			
  0x430b00		891c8a			MOVL BX, 0(DX)(CX*4)			
  0x430b03		eba6			JMP 0x430aab				
  0x430b05		488d0574a70200		LEAQ 0x2a774(IP), AX			
  0x430b0c		48890424		MOVQ AX, 0(SP)				
  0x430b10		4889542408		MOVQ DX, 0x8(SP)			
  0x430b15		48894c2410		MOVQ CX, 0x10(SP)			
  0x430b1a		48895c2418		MOVQ BX, 0x18(SP)			
  0x430b1f		4889742420		MOVQ SI, 0x20(SP)			
  0x430b24		e857520000		CALL runtime.growslice(SB)		
  0x430b29		488b442428		MOVQ 0x28(SP), AX			
  0x430b2e		488b4c2430		MOVQ 0x30(SP), CX			
  0x430b33		488b542438		MOVQ 0x38(SP), DX			
  0x430b38		488b5c2458		MOVQ 0x58(SP), BX			
  0x430b3d		48895318		MOVQ DX, 0x18(BX)			
  0x430b41		833dd8c20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x430b48		750c			JNE 0x430b56				
  0x430b4a		48894308		MOVQ AX, 0x8(BX)			
  0x430b4e		4889c2			MOVQ AX, DX				
  0x430b51		4889d8			MOVQ BX, AX				
  0x430b54		eb9e			JMP 0x430af4				
  0x430b56		488d7b08		LEAQ 0x8(BX), DI			
  0x430b5a		e8218b0100		CALL runtime.gcWriteBarrier(SB)		
  0x430b5f		ebed			JMP 0x430b4e				
  0x430b61		488b442458		MOVQ 0x58(SP), AX			
	for i := uint32(1); i <= count; i++ {
  0x430b66		8b5c2444		MOVL 0x44(SP), BX	
  0x430b6a		e93cffffff		JMP 0x430aab		
  0x430b6f		488b6c2448		MOVQ 0x48(SP), BP	
  0x430b74		4883c450		ADDQ $0x50, SP		
  0x430b78		c3			RET			
func (ord *randomOrder) reset(count uint32) {
  0x430b79		e8026d0100		CALL runtime.morestack_noctxt(SB)	
  0x430b7e		e9edfeffff		JMP runtime.(*randomOrder).reset(SB)	

TEXT runtime.gcd(SB) /usr/local/go/src/runtime/proc.go
	for b != 0 {
  0x430b90		8b4c2408		MOVL 0x8(SP), CX	
  0x430b94		8b54240c		MOVL 0xc(SP), DX	
  0x430b98		eb0a			JMP 0x430ba4		
		a, b = b, a%b
  0x430b9a		89c8			MOVL CX, AX		
  0x430b9c		89d3			MOVL DX, BX		
  0x430b9e		31d2			XORL DX, DX		
  0x430ba0		f7f3			DIVL BX			
	return a
  0x430ba2		89d9			MOVL BX, CX		
	for b != 0 {
  0x430ba4		85d2			TESTL DX, DX		
  0x430ba6		75f2			JNE 0x430b9a		
	return a
  0x430ba8		894c2410		MOVL CX, 0x10(SP)	
  0x430bac		c3			RET			

TEXT runtime.(*profBuf).takeOverflow(SB) /usr/local/go/src/runtime/profbuf.go
func (b *profBuf) takeOverflow() (count uint32, time uint64) {
  0x430bb0		4883ec10		SUBQ $0x10, SP		
  0x430bb4		48896c2408		MOVQ BP, 0x8(SP)	
  0x430bb9		488d6c2408		LEAQ 0x8(SP), BP	
	overflow := atomic.Load64(&b.overflow)
  0x430bbe		488b4c2418		MOVQ 0x18(SP), CX	
  0x430bc3		488b5110		MOVQ 0x10(CX), DX	
	time = atomic.Load64(&b.overflowTime)
  0x430bc7		488b5918		MOVQ 0x18(CX), BX	
	for {
  0x430bcb		eb0e			JMP 0x430bdb		
		overflow = atomic.Load64(&b.overflow)
  0x430bcd		488b7110		MOVQ 0x10(CX), SI	
		time = atomic.Load64(&b.overflowTime)
  0x430bd1		488b7918		MOVQ 0x18(CX), DI	
		count = uint32(overflow)
  0x430bd5		4889f2			MOVQ SI, DX		
	return uint32(overflow), time
  0x430bd8		4889fb			MOVQ DI, BX		
		count = uint32(overflow)
  0x430bdb		48891424		MOVQ DX, 0(SP)		
		if count == 0 {
  0x430bdf		85d2			TESTL DX, DX		
  0x430be1		7432			JE 0x430c15		
		if atomic.Cas64(&b.overflow, overflow, ((overflow>>32)+1)<<32) {
  0x430be3		4889d0			MOVQ DX, AX			
  0x430be6		48c1ea20		SHRQ $0x20, DX			
  0x430bea		48ffc2			INCQ DX				
  0x430bed		48c1e220		SHLQ $0x20, DX			
  0x430bf1		f0480fb15110		LOCK CMPXCHGQ DX, 0x10(CX)	
  0x430bf7		0f94c2			SETE DL				
  0x430bfa		84d2			TESTL DL, DL			
  0x430bfc		74cf			JE 0x430bcd			
	return uint32(overflow), time
  0x430bfe		488b0424		MOVQ 0(SP), AX		
  0x430c02		89442420		MOVL AX, 0x20(SP)	
  0x430c06		48895c2428		MOVQ BX, 0x28(SP)	
  0x430c0b		488b6c2408		MOVQ 0x8(SP), BP	
  0x430c10		4883c410		ADDQ $0x10, SP		
  0x430c14		c3			RET			
  0x430c15		31db			XORL BX, BX		
			break
  0x430c17		ebe5			JMP 0x430bfe		

TEXT runtime.(*profBuf).incrementOverflow(SB) /usr/local/go/src/runtime/profbuf.go
	for {
  0x430c20		488b4c2408		MOVQ 0x8(SP), CX	
		overflow := atomic.Load64(&b.overflow)
  0x430c25		488b5110		MOVQ 0x10(CX), DX	
		if uint32(overflow) == 0 {
  0x430c29		85d2			TESTL DX, DX		
  0x430c2b		741a			JE 0x430c47		
		if int32(overflow) == -1 {
  0x430c2d		83faff			CMPL $-0x1, DX		
  0x430c30		7414			JE 0x430c46		
		if atomic.Cas64(&b.overflow, overflow, overflow+1) {
  0x430c32		488d5a01		LEAQ 0x1(DX), BX		
  0x430c36		4889d0			MOVQ DX, AX			
  0x430c39		f0480fb15910		LOCK CMPXCHGQ BX, 0x10(CX)	
  0x430c3f		0f94c2			SETE DL				
  0x430c42		84d2			TESTL DL, DL			
  0x430c44		74df			JE 0x430c25			
  0x430c46		c3			RET				
			atomic.Store64(&b.overflowTime, uint64(now))
  0x430c47		488b442410		MOVQ 0x10(SP), AX	
  0x430c4c		48874118		XCHGQ AX, 0x18(CX)	
			atomic.Store64(&b.overflow, (((overflow>>32)+1)<<32)+1)
  0x430c50		48c1ea20		SHRQ $0x20, DX		
  0x430c54		488d4201		LEAQ 0x1(DX), AX	
  0x430c58		48c1e020		SHLQ $0x20, AX		
  0x430c5c		48ffc0			INCQ AX			
  0x430c5f		48874110		XCHGQ AX, 0x10(CX)	
			break
  0x430c63		ebe1			JMP 0x430c46		

TEXT runtime.(*profBuf).canWriteRecord(SB) /usr/local/go/src/runtime/profbuf.go
func (b *profBuf) canWriteRecord(nstk int) bool {
  0x430c70		4883ec08		SUBQ $0x8, SP		
  0x430c74		48892c24		MOVQ BP, 0(SP)		
  0x430c78		488d2c24		LEAQ 0(SP), BP		
	br := b.r.load()
  0x430c7c		90			NOPL			
  0x430c7d		488b4c2410		MOVQ 0x10(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430c82		488b11			MOVQ 0(CX), DX		
	bw := b.w.load()
  0x430c85		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430c86		488b5908		MOVQ 0x8(CX), BX	
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 1 {
  0x430c8a		90			NOPL			
  0x430c8b		90			NOPL			
  0x430c8c		90			NOPL			
  0x430c8d		488b7150		MOVQ 0x50(CX), SI	
	return uint32(x >> 34)
  0x430c91		4889d7			MOVQ DX, DI		
  0x430c94		48c1ea22		SHRQ $0x22, DX		
  0x430c98		4889d8			MOVQ BX, AX		
  0x430c9b		48c1eb22		SHRQ $0x22, BX		
	return int(int32(x-y) << 2 >> 2)
  0x430c9f		29da			SUBL BX, DX		
  0x430ca1		c1e202			SHLL $0x2, DX		
  0x430ca4		c1fa02			SARL $0x2, DX		
  0x430ca7		4863d2			MOVSXD DX, DX		
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 1 {
  0x430caa		4801f2			ADDQ SI, DX		
  0x430cad		4883fa01		CMPQ $0x1, DX		
  0x430cb1		7c54			JL 0x430d07		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x430cb3		90			NOPL			
  0x430cb4		90			NOPL			
  0x430cb5		90			NOPL			
  0x430cb6		488b5138		MOVQ 0x38(CX), DX	
	return int(int32(x-y) << 2 >> 2)
  0x430cba		29c7			SUBL AX, DI		
  0x430cbc		c1e702			SHLL $0x2, DI		
  0x430cbf		c1ff02			SARL $0x2, DI		
  0x430cc2		4863df			MOVSXD DI, BX		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x430cc5		4801d3			ADDQ DX, BX		
	want := 2 + int(b.hdrsize) + nstk
  0x430cc8		488b742418		MOVQ 0x18(SP), SI	
  0x430ccd		48037128		ADDQ 0x28(CX), SI	
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x430cd1		90			NOPL			
  0x430cd2		85d2			TESTL DX, DX		
  0x430cd4		743f			JE 0x430d15		
  0x430cd6		4889d1			MOVQ DX, CX		
  0x430cd9		31d2			XORL DX, DX		
  0x430cdb		f7f1			DIVL CX			
  0x430cdd		89d2			MOVL DX, DX		
	if i+want > len(b.data) {
  0x430cdf		488d3c32		LEAQ 0(DX)(SI*1), DI	
  0x430ce3		488d7f02		LEAQ 0x2(DI), DI	
  0x430ce7		4839cf			CMPQ CX, DI		
  0x430cea		7e06			JLE 0x430cf2		
		nd -= len(b.data) - i
  0x430cec		4829d1			SUBQ DX, CX		
  0x430cef		4829cb			SUBQ CX, BX		
	want := 2 + int(b.hdrsize) + nstk
  0x430cf2		488d4602		LEAQ 0x2(SI), AX	
	return nd >= want
  0x430cf6		4839c3			CMPQ AX, BX		
  0x430cf9		0f9d442420		SETGE 0x20(SP)		
  0x430cfe		488b2c24		MOVQ 0(SP), BP		
  0x430d02		4883c408		ADDQ $0x8, SP		
  0x430d06		c3			RET			
		return false
  0x430d07		c644242000		MOVB $0x0, 0x20(SP)	
  0x430d0c		488b2c24		MOVQ 0(SP), BP		
  0x430d10		4883c408		ADDQ $0x8, SP		
  0x430d14		c3			RET			
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x430d15		e86614ffff		CALL runtime.panicdivide(SB)	
  0x430d1a		0f0b			UD2				

TEXT runtime.(*profBuf).canWriteTwoRecords(SB) /usr/local/go/src/runtime/profbuf.go
func (b *profBuf) canWriteTwoRecords(nstk1, nstk2 int) bool {
  0x430d20		4883ec08		SUBQ $0x8, SP		
  0x430d24		48892c24		MOVQ BP, 0(SP)		
  0x430d28		488d2c24		LEAQ 0(SP), BP		
	br := b.r.load()
  0x430d2c		90			NOPL			
  0x430d2d		488b4c2410		MOVQ 0x10(SP), CX	
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430d32		488b11			MOVQ 0(CX), DX		
	bw := b.w.load()
  0x430d35		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430d36		488b5908		MOVQ 0x8(CX), BX	
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 2 {
  0x430d3a		90			NOPL			
  0x430d3b		90			NOPL			
  0x430d3c		90			NOPL			
  0x430d3d		488b7150		MOVQ 0x50(CX), SI	
	return uint32(x >> 34)
  0x430d41		4889d7			MOVQ DX, DI		
  0x430d44		48c1ea22		SHRQ $0x22, DX		
  0x430d48		4889d8			MOVQ BX, AX		
  0x430d4b		48c1eb22		SHRQ $0x22, BX		
	return int(int32(x-y) << 2 >> 2)
  0x430d4f		29da			SUBL BX, DX		
  0x430d51		c1e202			SHLL $0x2, DX		
  0x430d54		c1fa02			SARL $0x2, DX		
  0x430d57		4863d2			MOVSXD DX, DX		
	if countSub(br.tagCount(), bw.tagCount())+len(b.tags) < 2 {
  0x430d5a		4801f2			ADDQ SI, DX		
  0x430d5d		4883fa02		CMPQ $0x2, DX		
  0x430d61		0f8c97000000		JL 0x430dfe		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x430d67		90			NOPL			
  0x430d68		90			NOPL			
  0x430d69		90			NOPL			
  0x430d6a		488b5138		MOVQ 0x38(CX), DX	
	return int(int32(x-y) << 2 >> 2)
  0x430d6e		29c7			SUBL AX, DI		
  0x430d70		c1e702			SHLL $0x2, DI		
  0x430d73		c1ff02			SARL $0x2, DI		
  0x430d76		4863df			MOVSXD DI, BX		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x430d79		4801d3			ADDQ DX, BX		
	want := 2 + int(b.hdrsize) + nstk1
  0x430d7c		488b4928		MOVQ 0x28(CX), CX	
  0x430d80		488b742418		MOVQ 0x18(SP), SI	
  0x430d85		488d3c31		LEAQ 0(CX)(SI*1), DI	
  0x430d89		488d7f02		LEAQ 0x2(DI), DI	
  0x430d8d		4801ce			ADDQ CX, SI		
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x430d90		90			NOPL			
  0x430d91		85d2			TESTL DX, DX		
  0x430d93		7477			JE 0x430e0c		
  0x430d95		4989d0			MOVQ DX, R8		
  0x430d98		31d2			XORL DX, DX		
  0x430d9a		41f7f0			DIVL R8			
  0x430d9d		89d2			MOVL DX, DX		
	if i+want > len(b.data) {
  0x430d9f		4c8d0c16		LEAQ 0(SI)(DX*1), R9	
  0x430da3		4d8d4902		LEAQ 0x2(R9), R9	
  0x430da7		4d39c1			CMPQ R8, R9		
  0x430daa		7e4d			JLE 0x430df9		
		nd -= len(b.data) - i
  0x430dac		4c89c0			MOVQ R8, AX		
  0x430daf		4929d0			SUBQ DX, R8		
  0x430db2		4c29c3			SUBQ R8, BX		
  0x430db5		31d2			XORL DX, DX		
	i += want
  0x430db7		4c8d0416		LEAQ 0(SI)(DX*1), R8	
  0x430dbb		4d8d4002		LEAQ 0x2(R8), R8	
  0x430dbf		4801f2			ADDQ SI, DX		
	nd -= want
  0x430dc2		4829fb			SUBQ DI, BX		
	want = 2 + int(b.hdrsize) + nstk2
  0x430dc5		488b742420		MOVQ 0x20(SP), SI	
  0x430dca		488d3c31		LEAQ 0(CX)(SI*1), DI	
  0x430dce		488d7f02		LEAQ 0x2(DI), DI	
  0x430dd2		4801f1			ADDQ SI, CX		
	if i+want > len(b.data) {
  0x430dd5		488d0c11		LEAQ 0(CX)(DX*1), CX	
  0x430dd9		488d4904		LEAQ 0x4(CX), CX	
  0x430ddd		4839c1			CMPQ AX, CX		
  0x430de0		7e06			JLE 0x430de8		
		nd -= len(b.data) - i
  0x430de2		4c29c0			SUBQ R8, AX		
  0x430de5		4829c3			SUBQ AX, BX		
	return nd >= want
  0x430de8		4839fb			CMPQ DI, BX		
  0x430deb		0f9d442428		SETGE 0x28(SP)		
  0x430df0		488b2c24		MOVQ 0(SP), BP		
  0x430df4		4883c408		ADDQ $0x8, SP		
  0x430df8		c3			RET			
	if i+want > len(b.data) {
  0x430df9		4c89c0			MOVQ R8, AX		
	i += want
  0x430dfc		ebb9			JMP 0x430db7		
		return false
  0x430dfe		c644242800		MOVB $0x0, 0x28(SP)	
  0x430e03		488b2c24		MOVQ 0(SP), BP		
  0x430e07		4883c408		ADDQ $0x8, SP		
  0x430e0b		c3			RET			
	i := int(bw.dataCount() % uint32(len(b.data)))
  0x430e0c		e86f13ffff		CALL runtime.panicdivide(SB)	
  0x430e11		0f0b			UD2				

TEXT runtime.(*profBuf).write(SB) /usr/local/go/src/runtime/profbuf.go
func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr) {
  0x430e20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x430e29		483b6110		CMPQ 0x10(CX), SP	
  0x430e2d		0f8665040000		JBE 0x431298		
  0x430e33		4881ec80000000		SUBQ $0x80, SP		
  0x430e3a		48896c2478		MOVQ BP, 0x78(SP)	
  0x430e3f		488d6c2478		LEAQ 0x78(SP), BP	
	if b == nil {
  0x430e44		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x430e4c		4885c9			TESTQ CX, CX		
  0x430e4f		0f84d5030000		JE 0x43122a		
	if len(hdr) > int(b.hdrsize) {
  0x430e55		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x430e5d		48395128		CMPQ DX, 0x28(CX)	
  0x430e61		0f8c16040000		JL 0x43127d		
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x430e67		90			NOPL			
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x430e68		488b5910		MOVQ 0x10(CX), BX	
  0x430e6c		85db			TESTL BX, BX		
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x430e6e		0f8773030000		JA 0x4311e7		
  0x430e74		31c0			XORL AX, AX		
  0x430e76		84c0			TESTL AL, AL		
  0x430e78		0f85e2020000		JNE 0x431160		
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x430e7e		85db			TESTL BX, BX		
	} else if hasOverflow || !b.canWriteRecord(len(stk)) {
  0x430e80		0f86a7020000		JBE 0x43112d		
  0x430e86		b801000000		MOVL $0x1, AX		
  0x430e8b		84c0			TESTL AL, AL		
  0x430e8d		0f8566020000		JNE 0x4310f9		
	br := b.r.load()
  0x430e93		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430e94		488b19			MOVQ 0(CX), BX		
	bw := b.w.load()
  0x430e97		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x430e98		488b5908		MOVQ 0x8(CX), BX	
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x430e9c		90			NOPL			
  0x430e9d		488b7148		MOVQ 0x48(CX), SI	
  0x430ea1		488b7950		MOVQ 0x50(CX), DI	
  0x430ea5		85ff			TESTL DI, DI		
  0x430ea7		0f84c9030000		JE 0x431276		
	return uint32(x >> 34)
  0x430ead		4889d8			MOVQ BX, AX		
  0x430eb0		48c1e822		SHRQ $0x22, AX		
func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr) {
  0x430eb4		4989d0			MOVQ DX, R8		
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x430eb7		31d2			XORL DX, DX		
  0x430eb9		f7f7			DIVL DI			
	if tagPtr != nil {
  0x430ebb		4c8b8c2490000000	MOVQ 0x90(SP), R9	
  0x430ec3		4d85c9			TESTQ R9, R9		
  0x430ec6		7412			JE 0x430eda		
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x430ec8		89d2			MOVL DX, DX		
		*(*uintptr)(unsafe.Pointer(&b.tags[wt])) = uintptr(unsafe.Pointer(*tagPtr))
  0x430eca		4839fa			CMPQ DI, DX		
  0x430ecd		0f839c030000		JAE 0x43126f		
  0x430ed3		498b39			MOVQ 0(R9), DI		
  0x430ed6		48893cd6		MOVQ DI, 0(SI)(DX*8)	
	wd := int(bw.dataCount() % uint32(len(b.data)))
  0x430eda		90			NOPL			
  0x430edb		488b5130		MOVQ 0x30(CX), DX	
  0x430edf		488b7138		MOVQ 0x38(CX), SI	
  0x430ee3		85f6			TESTL SI, SI		
  0x430ee5		0f847d030000		JE 0x431268		
  0x430eeb		4889d8			MOVQ BX, AX		
  0x430eee		4889d3			MOVQ DX, BX		
  0x430ef1		31d2			XORL DX, DX		
  0x430ef3		f7f6			DIVL SI			
  0x430ef5		89d2			MOVL DX, DX		
	nd := countSub(br.dataCount(), bw.dataCount()) + len(b.data)
  0x430ef7		90			NOPL			
  0x430ef8		90			NOPL			
  0x430ef9		90			NOPL			
	if wd+2+int(b.hdrsize)+len(stk) > len(b.data) {
  0x430efa		488b7928		MOVQ 0x28(CX), DI	
  0x430efe		4801d7			ADDQ DX, DI		
  0x430f01		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
  0x430f09		4a8d3c0f		LEAQ 0(DI)(R9*1), DI	
  0x430f0d		488d7f02		LEAQ 0x2(DI), DI	
  0x430f11		4839f7			CMPQ SI, DI		
  0x430f14		0f8ed5010000		JLE 0x4310ef		
		b.data[wd] = 0
  0x430f1a		4839f2			CMPQ SI, DX		
  0x430f1d		0f833e030000		JAE 0x431261		
  0x430f23		48c704d300000000	MOVQ $0x0, 0(BX)(DX*8)	
		skip = len(b.data) - wd
  0x430f2b		488b5938		MOVQ 0x38(CX), BX	
  0x430f2f		4829d3			SUBQ DX, BX		
  0x430f32		31c0			XORL AX, AX		
	data := b.data[wd:]
  0x430f34		488b5130		MOVQ 0x30(CX), DX	
  0x430f38		488b7138		MOVQ 0x38(CX), SI	
  0x430f3c		488b7940		MOVQ 0x40(CX), DI	
  0x430f40		4839f0			CMPQ SI, AX		
  0x430f43		0f8711030000		JA 0x43125a		
  0x430f49		4829c7			SUBQ AX, DI		
  0x430f4c		4989fa			MOVQ DI, R10		
  0x430f4f		48f7df			NEGQ DI			
  0x430f52		48c1ff3f		SARQ $0x3f, DI		
  0x430f56		4989c3			MOVQ AX, R11		
  0x430f59		48c1e003		SHLQ $0x3, AX		
  0x430f5d		4821c7			ANDQ AX, DI		
  0x430f60		4c8d2417		LEAQ 0(DI)(DX*1), R12	
  0x430f64		4c29de			SUBQ R11, SI		
	data[0] = uint64(2 + b.hdrsize + uintptr(len(stk))) // length
  0x430f67		4c8b5928		MOVQ 0x28(CX), R11	
  0x430f6b		4f8d1c19		LEAQ 0(R9)(R11*1), R11	
  0x430f6f		4d8d5b02		LEAQ 0x2(R11), R11	
  0x430f73		4885f6			TESTQ SI, SI		
  0x430f76		0f86d7020000		JBE 0x431253		
  0x430f7c		4c891c3a		MOVQ R11, 0(DX)(DI*1)	
	data[1] = uint64(now)                               // time stamp
  0x430f80		4883fe01		CMPQ $0x1, SI		
  0x430f84		0f86c2020000		JBE 0x43124c		
  0x430f8a		4c8b9c2498000000	MOVQ 0x98(SP), R11	
  0x430f92		4c895c3a08		MOVQ R11, 0x8(DX)(DI*1)	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x430f97		488b5128		MOVQ 0x28(CX), DX	
  0x430f9b		488d7a02		LEAQ 0x2(DX), DI	
  0x430f9f		4885ff			TESTQ DI, DI		
  0x430fa2		0f8c9d020000		JL 0x431245		
  0x430fa8		4883ff02		CMPQ $0x2, DI		
  0x430fac		0f8293020000		JB 0x431245		
  0x430fb2		4c39d7			CMPQ R10, DI		
  0x430fb5		0f878a020000		JA 0x431245		
  0x430fbb		4c39c2			CMPQ R8, DX		
  0x430fbe		490f4fd0		CMOVG R8, DX		
  0x430fc2		498d7afe		LEAQ -0x2(R10), DI	
  0x430fc6		48f7df			NEGQ DI			
  0x430fc9		48c1ff3f		SARQ $0x3f, DI		
  0x430fcd		4883e710		ANDQ $0x10, DI		
  0x430fd1		4c01e7			ADDQ R12, DI		
  0x430fd4		4c8b8424a0000000	MOVQ 0xa0(SP), R8	
  0x430fdc		4c39c7			CMPQ R8, DI		
  0x430fdf		7411			JE 0x430ff2		
  0x430fe1		e9b5000000		JMP 0x43109b		
		data[2+i] = 0
  0x430fe6		49c744d41000000000	MOVQ $0x0, 0x10(R12)(DX*8)	
	for ; i < b.hdrsize; i++ {
  0x430fef		48ffc2			INCQ DX			
  0x430ff2		48395128		CMPQ DX, 0x28(CX)	
  0x430ff6		760e			JBE 0x431006		
		data[2+i] = 0
  0x430ff8		488d7a02		LEAQ 0x2(DX), DI	
  0x430ffc		4839f7			CMPQ SI, DI		
  0x430fff		72e5			JB 0x430fe6		
  0x431001		e938020000		JMP 0x43123e		
	for i, pc := range stk {
  0x431006		488b9424b8000000	MOVQ 0xb8(SP), DX	
  0x43100e		31c0			XORL AX, AX		
  0x431010		eb07			JMP 0x431019		
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x431012		4b893cc4		MOVQ DI, 0(R12)(R8*8)	
	for i, pc := range stk {
  0x431016		48ffc0			INCQ AX			
  0x431019		4c39c8			CMPQ R9, AX		
  0x43101c		7d1a			JGE 0x431038		
  0x43101e		488b3cc2		MOVQ 0(DX)(AX*8), DI	
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x431022		4c8b4128		MOVQ 0x28(CX), R8	
  0x431026		4d8d0400		LEAQ 0(R8)(AX*1), R8	
  0x43102a		4d8d4002		LEAQ 0x2(R8), R8	
  0x43102e		4939f0			CMPQ SI, R8		
  0x431031		72df			JB 0x431012		
  0x431033		e9ff010000		JMP 0x431237		
		old := b.w.load()
  0x431038		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x431039		488b5108		MOVQ 0x8(CX), DX	
  0x43103d		4889542468		MOVQ DX, 0x68(SP)	
		new := old.addCountsAndClearFlags(skip+2+len(stk)+int(b.hdrsize), 1)
  0x431042		90			NOPL			
  0x431043		498d3419		LEAQ 0(R9)(BX*1), SI	
  0x431047		48037128		ADDQ 0x28(CX), SI	
  0x43104b		4883c602		ADDQ $0x2, SI		
		if !b.w.cas(old, new) {
  0x43104f		90			NOPL			
	return profIndex((uint64(x)>>34+uint64(uint32(tag)<<2>>2))<<34 | uint64(uint32(x)+uint32(data)))
  0x431050		4889d0			MOVQ DX, AX		
  0x431053		48c1ea22		SHRQ $0x22, DX		
  0x431057		48ffc2			INCQ DX			
  0x43105a		48c1e222		SHLQ $0x22, DX		
  0x43105e		01c6			ADDL AX, SI		
  0x431060		4809f2			ORQ SI, DX		
	return atomic.Cas64((*uint64)(x), uint64(old), uint64(new))
  0x431063		f0480fb15108		LOCK CMPXCHGQ DX, 0x8(CX)	
  0x431069		0f94c2			SETE DL				
  0x43106c		84d2			TESTL DL, DL			
		if !b.w.cas(old, new) {
  0x43106e		74c8			JE 0x431038		
		if old&profReaderSleeping != 0 {
  0x431070		488b442468		MOVQ 0x68(SP), AX	
  0x431075		480fbae020		BTQ $0x20, AX		
  0x43107a		720d			JB 0x431089		
  0x43107c		488b6c2478		MOVQ 0x78(SP), BP	
  0x431081		4881c480000000		ADDQ $0x80, SP		
  0x431088		c3			RET			
			notewakeup(&b.wait)
  0x431089		488d8180000000		LEAQ 0x80(CX), AX		
  0x431090		48890424		MOVQ AX, 0(SP)			
  0x431094		e8c778fdff		CALL runtime.notewakeup(SB)	
  0x431099		ebe1			JMP 0x43107c			
	data := b.data[wd:]
  0x43109b		4889742458		MOVQ SI, 0x58(SP)	
  0x4310a0		4c89642470		MOVQ R12, 0x70(SP)	
		new := old.addCountsAndClearFlags(skip+2+len(stk)+int(b.hdrsize), 1)
  0x4310a5		48895c2450		MOVQ BX, 0x50(SP)	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x4310aa		4889542460		MOVQ DX, 0x60(SP)		
  0x4310af		48893c24		MOVQ DI, 0(SP)			
  0x4310b3		4c89442408		MOVQ R8, 0x8(SP)		
  0x4310b8		48c1e203		SHLQ $0x3, DX			
  0x4310bc		4889542410		MOVQ DX, 0x10(SP)		
  0x4310c1		e88a960100		CALL runtime.memmove(SB)	
	for ; i < b.hdrsize; i++ {
  0x4310c6		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x4310ce		488b542460		MOVQ 0x60(SP), DX	
		new := old.addCountsAndClearFlags(skip+2+len(stk)+int(b.hdrsize), 1)
  0x4310d3		488b5c2450		MOVQ 0x50(SP), BX	
		data[2+i] = 0
  0x4310d8		488b742458		MOVQ 0x58(SP), SI	
	for i, pc := range stk {
  0x4310dd		4c8b8c24c0000000	MOVQ 0xc0(SP), R9	
		data[2+i] = 0
  0x4310e5		4c8b642470		MOVQ 0x70(SP), R12	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x4310ea		e903ffffff		JMP 0x430ff2		
	data := b.data[wd:]
  0x4310ef		4889d0			MOVQ DX, AX		
  0x4310f2		31db			XORL BX, BX		
  0x4310f4		e93bfeffff		JMP 0x430f34		
		b.incrementOverflow(now)
  0x4310f9		48890c24		MOVQ CX, 0(SP)					
  0x4310fd		488b842498000000	MOVQ 0x98(SP), AX				
  0x431105		4889442408		MOVQ AX, 0x8(SP)				
  0x43110a		e811fbffff		CALL runtime.(*profBuf).incrementOverflow(SB)	
		b.wakeupExtra()
  0x43110f		488b842488000000	MOVQ 0x88(SP), AX			
  0x431117		48890424		MOVQ AX, 0(SP)				
  0x43111b		e890010000		CALL runtime.(*profBuf).wakeupExtra(SB)	
		return
  0x431120		488b6c2478		MOVQ 0x78(SP), BP	
  0x431125		4881c480000000		ADDQ $0x80, SP		
  0x43112c		c3			RET			
	} else if hasOverflow || !b.canWriteRecord(len(stk)) {
  0x43112d		48890c24		MOVQ CX, 0(SP)					
  0x431131		488b8424c0000000	MOVQ 0xc0(SP), AX				
  0x431139		4889442408		MOVQ AX, 0x8(SP)				
  0x43113e		e82dfbffff		CALL runtime.(*profBuf).canWriteRecord(SB)	
  0x431143		0fb6442410		MOVZX 0x10(SP), AX				
  0x431148		83f001			XORL $0x1, AX					
	return profIndex(atomic.Load64((*uint64)(x)))
  0x43114b		488b8c2488000000	MOVQ 0x88(SP), CX	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x431153		488b9424a8000000	MOVQ 0xa8(SP), DX	
	} else if hasOverflow || !b.canWriteRecord(len(stk)) {
  0x43115b		e92bfdffff		JMP 0x430e8b		
		count, time := b.takeOverflow()
  0x431160		48890c24		MOVQ CX, 0(SP)					
  0x431164		e847faffff		CALL runtime.(*profBuf).takeOverflow(SB)	
  0x431169		8b442408		MOVL 0x8(SP), AX				
  0x43116d		488b4c2410		MOVQ 0x10(SP), CX				
		if count > 0 {
  0x431172		85c0			TESTL AX, AX		
  0x431174		7715			JA 0x43118b		
	return profIndex(atomic.Load64((*uint64)(x)))
  0x431176		488b8c2488000000	MOVQ 0x88(SP), CX	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x43117e		488b9424a8000000	MOVQ 0xa8(SP), DX	
	br := b.r.load()
  0x431186		e908fdffff		JMP 0x430e93		
			var stk [1]uintptr
  0x43118b		48c744244800000000	MOVQ $0x0, 0x48(SP)	
			stk[0] = uintptr(count)
  0x431194		4889442448		MOVQ AX, 0x48(SP)	
			b.write(nil, int64(time), nil, stk[:])
  0x431199		488b842488000000	MOVQ 0x88(SP), AX			
  0x4311a1		48890424		MOVQ AX, 0(SP)				
  0x4311a5		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x4311ae		48894c2410		MOVQ CX, 0x10(SP)			
  0x4311b3		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x4311bc		0f57c0			XORPS X0, X0				
  0x4311bf		0f11442420		MOVUPS X0, 0x20(SP)			
  0x4311c4		488d4c2448		LEAQ 0x48(SP), CX			
  0x4311c9		48894c2430		MOVQ CX, 0x30(SP)			
  0x4311ce		48c744243801000000	MOVQ $0x1, 0x38(SP)			
  0x4311d7		48c744244001000000	MOVQ $0x1, 0x40(SP)			
  0x4311e0		e83bfcffff		CALL runtime.(*profBuf).write(SB)	
  0x4311e5		eb8f			JMP 0x431176				
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x4311e7		48895c2468		MOVQ BX, 0x68(SP)	
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x4311ec		48890c24		MOVQ CX, 0(SP)					
  0x4311f0		48c744240801000000	MOVQ $0x1, 0x8(SP)				
  0x4311f9		488b8424c0000000	MOVQ 0xc0(SP), AX				
  0x431201		4889442410		MOVQ AX, 0x10(SP)				
  0x431206		e815fbffff		CALL runtime.(*profBuf).canWriteTwoRecords(SB)	
  0x43120b		0fb6442418		MOVZX 0x18(SP), AX				
	return profIndex(atomic.Load64((*uint64)(x)))
  0x431210		488b8c2488000000	MOVQ 0x88(SP), CX	
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x431218		488b9424a8000000	MOVQ 0xa8(SP), DX	
	return uint32(atomic.Load64(&b.overflow)) > 0
  0x431220		488b5c2468		MOVQ 0x68(SP), BX	
	if hasOverflow := b.hasOverflow(); hasOverflow && b.canWriteTwoRecords(1, len(stk)) {
  0x431225		e94cfcffff		JMP 0x430e76		
		return
  0x43122a		488b6c2478		MOVQ 0x78(SP), BP	
  0x43122f		4881c480000000		ADDQ $0x80, SP		
  0x431236		c3			RET			
		data[2+b.hdrsize+uintptr(i)] = uint64(pc)
  0x431237		e8e40cffff		CALL runtime.panicindex(SB)	
  0x43123c		0f0b			UD2				
		data[2+i] = 0
  0x43123e		e8dd0cffff		CALL runtime.panicindex(SB)	
  0x431243		0f0b			UD2				
	i := uintptr(copy(data[2:2+b.hdrsize], hdr))
  0x431245		e8060effff		CALL runtime.panicslice(SB)	
  0x43124a		0f0b			UD2				
	data[1] = uint64(now)                               // time stamp
  0x43124c		e8cf0cffff		CALL runtime.panicindex(SB)	
  0x431251		0f0b			UD2				
	data[0] = uint64(2 + b.hdrsize + uintptr(len(stk))) // length
  0x431253		e8c80cffff		CALL runtime.panicindex(SB)	
  0x431258		0f0b			UD2				
	data := b.data[wd:]
  0x43125a		e8f10dffff		CALL runtime.panicslice(SB)	
  0x43125f		0f0b			UD2				
		b.data[wd] = 0
  0x431261		e8ba0cffff		CALL runtime.panicindex(SB)	
  0x431266		0f0b			UD2				
	wd := int(bw.dataCount() % uint32(len(b.data)))
  0x431268		e8130fffff		CALL runtime.panicdivide(SB)	
  0x43126d		0f0b			UD2				
		*(*uintptr)(unsafe.Pointer(&b.tags[wt])) = uintptr(unsafe.Pointer(*tagPtr))
  0x43126f		e8ac0cffff		CALL runtime.panicindex(SB)	
  0x431274		0f0b			UD2				
	wt := int(bw.tagCount() % uint32(len(b.tags)))
  0x431276		e8050fffff		CALL runtime.panicdivide(SB)	
  0x43127b		0f0b			UD2				
		throw("misuse of profBuf.write")
  0x43127d		488d050efa0300		LEAQ 0x3fa0e(IP), AX	
  0x431284		48890424		MOVQ AX, 0(SP)		
  0x431288		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x431291		e8ea21ffff		CALL runtime.throw(SB)	
  0x431296		0f0b			UD2			
func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr) {
  0x431298		e8e3650100		CALL runtime.morestack_noctxt(SB)	
  0x43129d		e97efbffff		JMP runtime.(*profBuf).write(SB)	

TEXT runtime.(*profBuf).wakeupExtra(SB) /usr/local/go/src/runtime/profbuf.go
func (b *profBuf) wakeupExtra() {
  0x4312b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4312b9		483b6110		CMPQ 0x10(CX), SP	
  0x4312bd		765b			JBE 0x43131a		
  0x4312bf		4883ec18		SUBQ $0x18, SP		
  0x4312c3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4312c8		488d6c2410		LEAQ 0x10(SP), BP	
	for {
  0x4312cd		488b4c2420		MOVQ 0x20(SP), CX	
		old := b.w.load()
  0x4312d2		90			NOPL			
	return profIndex(atomic.Load64((*uint64)(x)))
  0x4312d3		488b5108		MOVQ 0x8(CX), DX	
  0x4312d7		4889542408		MOVQ DX, 0x8(SP)	
		new := old | profWriteExtra
  0x4312dc		4889d0			MOVQ DX, AX		
  0x4312df		480fbaea21		BTSQ $0x21, DX		
		if !b.w.cas(old, new) {
  0x4312e4		90			NOPL			
	return atomic.Cas64((*uint64)(x), uint64(old), uint64(new))
  0x4312e5		f0480fb15108		LOCK CMPXCHGQ DX, 0x8(CX)	
  0x4312eb		0f94c2			SETE DL				
  0x4312ee		84d2			TESTL DL, DL			
		if !b.w.cas(old, new) {
  0x4312f0		74e0			JE 0x4312d2		
		if old&profReaderSleeping != 0 {
  0x4312f2		488b442408		MOVQ 0x8(SP), AX	
  0x4312f7		480fbae020		BTQ $0x20, AX		
  0x4312fc		720a			JB 0x431308		
  0x4312fe		488b6c2410		MOVQ 0x10(SP), BP	
  0x431303		4883c418		ADDQ $0x18, SP		
  0x431307		c3			RET			
			notewakeup(&b.wait)
  0x431308		488d8180000000		LEAQ 0x80(CX), AX		
  0x43130f		48890424		MOVQ AX, 0(SP)			
  0x431313		e84876fdff		CALL runtime.notewakeup(SB)	
  0x431318		ebe4			JMP 0x4312fe			
func (b *profBuf) wakeupExtra() {
  0x43131a		e861650100		CALL runtime.morestack_noctxt(SB)	
  0x43131f		eb8f			JMP runtime.(*profBuf).wakeupExtra(SB)	

TEXT runtime.args(SB) /usr/local/go/src/runtime/runtime1.go
func args(c int32, v **byte) {
  0x431330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431339		483b6110		CMPQ 0x10(CX), SP	
  0x43133d		7657			JBE 0x431396		
  0x43133f		4883ec18		SUBQ $0x18, SP		
  0x431343		48896c2410		MOVQ BP, 0x10(SP)	
  0x431348		488d6c2410		LEAQ 0x10(SP), BP	
	argc = c
  0x43134d		8b4c2420		MOVL 0x20(SP), CX		
  0x431351		890d65b90a00		MOVL CX, runtime.argc(SB)	
	argv = v
  0x431357		833dc2ba0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43135e		7523			JNE 0x431383				
  0x431360		488b442428		MOVQ 0x28(SP), AX			
  0x431365		488905b4050900		MOVQ AX, runtime.argv(SB)		
	sysargs(c, v)
  0x43136c		890c24			MOVL CX, 0(SP)			
  0x43136f		4889442408		MOVQ AX, 0x8(SP)		
  0x431374		e8c703ffff		CALL runtime.sysargs(SB)	
}
  0x431379		488b6c2410		MOVQ 0x10(SP), BP	
  0x43137e		4883c418		ADDQ $0x18, SP		
  0x431382		c3			RET			
	argv = v
  0x431383		488d3d96050900		LEAQ runtime.argv(SB), DI	
  0x43138a		488b442428		MOVQ 0x28(SP), AX		
  0x43138f		e8ec820100		CALL runtime.gcWriteBarrier(SB)	
  0x431394		ebd6			JMP 0x43136c			
func args(c int32, v **byte) {
  0x431396		e8e5640100		CALL runtime.morestack_noctxt(SB)	
  0x43139b		eb93			JMP runtime.args(SB)			

TEXT runtime.goargs(SB) /usr/local/go/src/runtime/runtime1.go
func goargs() {
  0x4313a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4313a9		483b6110		CMPQ 0x10(CX), SP	
  0x4313ad		0f8623010000		JBE 0x4314d6		
  0x4313b3		4883ec48		SUBQ $0x48, SP		
  0x4313b7		48896c2440		MOVQ BP, 0x40(SP)	
  0x4313bc		488d6c2440		LEAQ 0x40(SP), BP	
	argslice = make([]string, argc)
  0x4313c1		488d05f89d0200		LEAQ 0x29df8(IP), AX			
  0x4313c8		48890424		MOVQ AX, 0(SP)				
  0x4313cc		486305e9b80a00		MOVSXD runtime.argc(SB), AX		
  0x4313d3		4889442408		MOVQ AX, 0x8(SP)			
  0x4313d8		486305ddb80a00		MOVSXD runtime.argc(SB), AX		
  0x4313df		4889442410		MOVQ AX, 0x10(SP)			
  0x4313e4		e897480000		CALL runtime.makeslice(SB)		
  0x4313e9		488b442418		MOVQ 0x18(SP), AX			
  0x4313ee		48630dc7b80a00		MOVSXD runtime.argc(SB), CX		
  0x4313f5		48890d4c060900		MOVQ CX, runtime.argslice+8(SB)		
  0x4313fc		48890d4d060900		MOVQ CX, runtime.argslice+16(SB)	
  0x431403		833d16ba0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43140a		0f85ae000000		JNE 0x4314be				
  0x431410		48890529060900		MOVQ AX, runtime.argslice(SB)		
  0x431417		31c0			XORL AX, AX				
	for i := int32(0); i < argc; i++ {
  0x431419		eb03			JMP 0x43141e			
  0x43141b		8d4101			LEAL 0x1(CX), AX		
  0x43141e		390598b80a00		CMPL AX, runtime.argc(SB)	
  0x431424		0f8e8a000000		JLE 0x4314b4			
  0x43142a		89442424		MOVL AX, 0x24(SP)		
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x43142e		90			NOPL			
  0x43142f		90			NOPL			
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x431430		4863c8			MOVSXD AX, CX		
  0x431433		48c1e103		SHLQ $0x3, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x431437		48030de2040900		ADDQ runtime.argv(SB), CX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x43143e		488b09			MOVQ 0(CX), CX		
  0x431441		48894c2428		MOVQ CX, 0x28(SP)	
  0x431446		90			NOPL			
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x431447		48890c24		MOVQ CX, 0(SP)			
  0x43144b		e8b08b0000		CALL runtime.findnull(SB)	
  0x431450		488b442408		MOVQ 0x8(SP), AX		
  0x431455		0f57c0			XORPS X0, X0			
  0x431458		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43145d		488b4c2428		MOVQ 0x28(SP), CX		
  0x431462		48894c2430		MOVQ CX, 0x30(SP)		
  0x431467		4889442438		MOVQ AX, 0x38(SP)		
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x43146c		8b4c2424		MOVL 0x24(SP), CX		
  0x431470		4863d1			MOVSXD CX, DX			
  0x431473		488b1dc6050900		MOVQ runtime.argslice(SB), BX	
	s := *(*string)(unsafe.Pointer(&ss))
  0x43147a		488b742430		MOVQ 0x30(SP), SI	
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x43147f		483915c2050900		CMPQ DX, runtime.argslice+8(SB)		
  0x431486		7647			JBE 0x4314cf				
  0x431488		48c1e204		SHLQ $0x4, DX				
  0x43148c		4889441308		MOVQ AX, 0x8(BX)(DX*1)			
  0x431491		488d3c13		LEAQ 0(BX)(DX*1), DI			
  0x431495		833d84b90a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43149c		7509			JNE 0x4314a7				
  0x43149e		48893413		MOVQ SI, 0(BX)(DX*1)			
  0x4314a2		e974ffffff		JMP 0x43141b				
  0x4314a7		4889f0			MOVQ SI, AX				
  0x4314aa		e8d1810100		CALL runtime.gcWriteBarrier(SB)		
  0x4314af		e967ffffff		JMP 0x43141b				
  0x4314b4		488b6c2440		MOVQ 0x40(SP), BP			
  0x4314b9		4883c448		ADDQ $0x48, SP				
  0x4314bd		c3			RET					
	argslice = make([]string, argc)
  0x4314be		488d3d7b050900		LEAQ runtime.argslice(SB), DI	
  0x4314c5		e8b6810100		CALL runtime.gcWriteBarrier(SB)	
  0x4314ca		e948ffffff		JMP 0x431417			
		argslice[i] = gostringnocopy(argv_index(argv, i))
  0x4314cf		e84c0affff		CALL runtime.panicindex(SB)	
  0x4314d4		0f0b			UD2				
func goargs() {
  0x4314d6		e8a5630100		CALL runtime.morestack_noctxt(SB)	
  0x4314db		e9c0feffff		JMP runtime.goargs(SB)			

TEXT runtime.goenvs_unix(SB) /usr/local/go/src/runtime/runtime1.go
func goenvs_unix() {
  0x4314e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4314e9		483b6110		CMPQ 0x10(CX), SP	
  0x4314ed		0f862c010000		JBE 0x43161f		
  0x4314f3		4883ec38		SUBQ $0x38, SP		
  0x4314f7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4314fc		488d6c2430		LEAQ 0x30(SP), BP	
  0x431501		31c0			XORL AX, AX		
	for argv_index(argv, argc+1+n) != nil {
  0x431503		eb02			JMP 0x431507		
		n++
  0x431505		ffc0			INCL AX			
	for argv_index(argv, argc+1+n) != nil {
  0x431507		90			NOPL				
  0x431508		8b0daeb70a00		MOVL runtime.argc(SB), CX	
  0x43150e		8d0c08			LEAL 0(AX)(CX*1), CX		
  0x431511		8d4901			LEAL 0x1(CX), CX		
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x431514		90			NOPL			
  0x431515		4863c9			MOVSXD CX, CX		
  0x431518		48c1e103		SHLQ $0x3, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43151c		48030dfd030900		ADDQ runtime.argv(SB), CX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x431523		48833900		CMPQ $0x0, 0(CX)	
	for argv_index(argv, argc+1+n) != nil {
  0x431527		75dc			JNE 0x431505		
  0x431529		89442420		MOVL AX, 0x20(SP)	
	envs = make([]string, n)
  0x43152d		488d0d8c9c0200		LEAQ 0x29c8c(IP), CX			
  0x431534		48890c24		MOVQ CX, 0(SP)				
  0x431538		4863c8			MOVSXD AX, CX				
  0x43153b		48894c2428		MOVQ CX, 0x28(SP)			
  0x431540		48894c2408		MOVQ CX, 0x8(SP)			
  0x431545		48894c2410		MOVQ CX, 0x10(SP)			
  0x43154a		e831470000		CALL runtime.makeslice(SB)		
  0x43154f		488b442418		MOVQ 0x18(SP), AX			
  0x431554		488b4c2428		MOVQ 0x28(SP), CX			
  0x431559		48890d08050900		MOVQ CX, runtime.envs+8(SB)		
  0x431560		48890d09050900		MOVQ CX, runtime.envs+16(SB)		
  0x431567		833db2b80a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43156e		0f8593000000		JNE 0x431607				
  0x431574		488905e5040900		MOVQ AX, runtime.envs(SB)		
  0x43157b		31c0			XORL AX, AX				
	for i := int32(0); i < n; i++ {
  0x43157d		eb03			JMP 0x431582		
  0x43157f		8d4101			LEAL 0x1(CX), AX	
  0x431582		8b4c2420		MOVL 0x20(SP), CX	
  0x431586		39c8			CMPL CX, AX		
  0x431588		7d73			JGE 0x4315fd		
  0x43158a		89442424		MOVL AX, 0x24(SP)	
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x43158e		90			NOPL				
  0x43158f		8b0d27b70a00		MOVL runtime.argc(SB), CX	
  0x431595		8d0c01			LEAL 0(CX)(AX*1), CX		
  0x431598		8d4901			LEAL 0x1(CX), CX		
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x43159b		4863c9			MOVSXD CX, CX		
  0x43159e		48c1e103		SHLQ $0x3, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4315a2		48030d77030900		ADDQ runtime.argv(SB), CX	
	return *(**byte)(add(unsafe.Pointer(argv), uintptr(i)*sys.PtrSize))
  0x4315a9		488b09			MOVQ 0(CX), CX		
  0x4315ac		90			NOPL			
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x4315ad		48890c24		MOVQ CX, 0(SP)				
  0x4315b1		e84a870000		CALL runtime.gostring(SB)		
  0x4315b6		488b05a3040900		MOVQ runtime.envs(SB), AX		
  0x4315bd		8b4c2424		MOVL 0x24(SP), CX			
  0x4315c1		4863d1			MOVSXD CX, DX				
  0x4315c4		488b5c2408		MOVQ 0x8(SP), BX			
  0x4315c9		488b742410		MOVQ 0x10(SP), SI			
  0x4315ce		48391593040900		CMPQ DX, runtime.envs+8(SB)		
  0x4315d5		7641			JBE 0x431618				
  0x4315d7		48c1e204		SHLQ $0x4, DX				
  0x4315db		4889741008		MOVQ SI, 0x8(AX)(DX*1)			
  0x4315e0		488d3c10		LEAQ 0(AX)(DX*1), DI			
  0x4315e4		833d35b80a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4315eb		7506			JNE 0x4315f3				
  0x4315ed		48891c10		MOVQ BX, 0(AX)(DX*1)			
  0x4315f1		eb8c			JMP 0x43157f				
  0x4315f3		4889d8			MOVQ BX, AX				
  0x4315f6		e885800100		CALL runtime.gcWriteBarrier(SB)		
  0x4315fb		eb82			JMP 0x43157f				
  0x4315fd		488b6c2430		MOVQ 0x30(SP), BP			
  0x431602		4883c438		ADDQ $0x38, SP				
  0x431606		c3			RET					
	envs = make([]string, n)
  0x431607		488d3d52040900		LEAQ runtime.envs(SB), DI	
  0x43160e		e86d800100		CALL runtime.gcWriteBarrier(SB)	
  0x431613		e963ffffff		JMP 0x43157b			
		envs[i] = gostring(argv_index(argv, argc+1+i))
  0x431618		e80309ffff		CALL runtime.panicindex(SB)	
  0x43161d		0f0b			UD2				
func goenvs_unix() {
  0x43161f		e85c620100		CALL runtime.morestack_noctxt(SB)	
  0x431624		e9b7feffff		JMP runtime.goenvs_unix(SB)		

TEXT runtime.testAtomic64(SB) /usr/local/go/src/runtime/runtime1.go
func testAtomic64() {
  0x431630		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431639		483b6110		CMPQ 0x10(CX), SP	
  0x43163d		0f863f020000		JBE 0x431882		
  0x431643		4883ec18		SUBQ $0x18, SP		
  0x431647		48896c2410		MOVQ BP, 0x10(SP)	
  0x43164c		488d6c2410		LEAQ 0x10(SP), BP	
	test_z64 = 42
  0x431651		48c7059cb70a002a000000	MOVQ $0x2a, runtime.test_z64(SB)	
	test_x64 = 0
  0x43165c		48c70589b70a0000000000	MOVQ $0x0, runtime.test_x64(SB)	
	if atomic.Cas64(&test_z64, test_x64, 1) {
  0x431667		31c0			XORL AX, AX			
  0x431669		488d0d88b70a00		LEAQ runtime.test_z64(SB), CX	
  0x431670		ba01000000		MOVL $0x1, DX			
  0x431675		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)		
  0x43167a		0f94c3			SETE BL				
  0x43167d		84db			TESTL BL, BL			
  0x43167f		0f85e2010000		JNE 0x431867			
	if test_x64 != 0 {
  0x431685		48833d63b70a0000	CMPQ $0x0, runtime.test_x64(SB)	
  0x43168d		0f85b9010000		JNE 0x43184c			
	test_x64 = 42
  0x431693		48c70552b70a002a000000	MOVQ $0x2a, runtime.test_x64(SB)	
	if !atomic.Cas64(&test_z64, test_x64, 1) {
  0x43169e		b82a000000		MOVL $0x2a, AX		
  0x4316a3		f0480fb111		LOCK CMPXCHGQ DX, 0(CX)	
  0x4316a8		0f94c2			SETE DL			
  0x4316ab		84d2			TESTL DL, DL		
  0x4316ad		0f847e010000		JE 0x431831		
	if test_x64 != 42 || test_z64 != 1 {
  0x4316b3		48833d35b70a002a	CMPQ $0x2a, runtime.test_x64(SB)	
  0x4316bb		0f8555010000		JNE 0x431816				
  0x4316c1		48833d2fb70a0001	CMPQ $0x1, runtime.test_z64(SB)		
  0x4316c9		0f8547010000		JNE 0x431816				
	if atomic.Load64(&test_z64) != 1 {
  0x4316cf		488b0522b70a00		MOVQ runtime.test_z64(SB), AX	
  0x4316d6		4883f801		CMPQ $0x1, AX			
  0x4316da		0f851b010000		JNE 0x4317fb			
	atomic.Store64(&test_z64, (1<<40)+1)
  0x4316e0		48b80100000000010000	MOVQ $0x10000000001, AX	
  0x4316ea		488701			XCHGQ AX, 0(CX)		
	if atomic.Load64(&test_z64) != (1<<40)+1 {
  0x4316ed		488b0504b70a00		MOVQ runtime.test_z64(SB), AX	
  0x4316f4		48ba0100000000010000	MOVQ $0x10000000001, DX		
  0x4316fe		4839c2			CMPQ AX, DX			
  0x431701		0f85d9000000		JNE 0x4317e0			
	if atomic.Xadd64(&test_z64, (1<<40)+1) != (2<<40)+2 {
  0x431707		48b80100000000010000	MOVQ $0x10000000001, AX	
  0x431711		f0480fc101		LOCK XADDQ AX, 0(CX)	
  0x431716		48ba0100000000010000	MOVQ $0x10000000001, DX	
  0x431720		4801d0			ADDQ DX, AX		
  0x431723		48ba0200000000020000	MOVQ $0x20000000002, DX	
  0x43172d		4839c2			CMPQ AX, DX		
  0x431730		0f858f000000		JNE 0x4317c5		
	if atomic.Load64(&test_z64) != (2<<40)+2 {
  0x431736		488b05bbb60a00		MOVQ runtime.test_z64(SB), AX	
  0x43173d		4839d0			CMPQ DX, AX			
  0x431740		7568			JNE 0x4317aa			
	if atomic.Xchg64(&test_z64, (3<<40)+3) != (2<<40)+2 {
  0x431742		48b80300000000030000	MOVQ $0x30000000003, AX	
  0x43174c		488701			XCHGQ AX, 0(CX)		
  0x43174f		4839d0			CMPQ DX, AX		
  0x431752		753b			JNE 0x43178f		
	if atomic.Load64(&test_z64) != (3<<40)+3 {
  0x431754		488b059db60a00		MOVQ runtime.test_z64(SB), AX	
  0x43175b		48b90300000000030000	MOVQ $0x30000000003, CX		
  0x431765		4839c1			CMPQ AX, CX			
  0x431768		750a			JNE 0x431774			
  0x43176a		488b6c2410		MOVQ 0x10(SP), BP		
  0x43176f		4883c418		ADDQ $0x18, SP			
  0x431773		c3			RET				
		throw("xchg64 failed")
  0x431774		488d0561e50300		LEAQ 0x3e561(IP), AX	
  0x43177b		48890424		MOVQ AX, 0(SP)		
  0x43177f		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x431788		e8f31cffff		CALL runtime.throw(SB)	
  0x43178d		0f0b			UD2			
		throw("xchg64 failed")
  0x43178f		488d0546e50300		LEAQ 0x3e546(IP), AX	
  0x431796		48890424		MOVQ AX, 0(SP)		
  0x43179a		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4317a3		e8d81cffff		CALL runtime.throw(SB)	
  0x4317a8		0f0b			UD2			
		throw("xadd64 failed")
  0x4317aa		488d051ee50300		LEAQ 0x3e51e(IP), AX	
  0x4317b1		48890424		MOVQ AX, 0(SP)		
  0x4317b5		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4317be		e8bd1cffff		CALL runtime.throw(SB)	
  0x4317c3		0f0b			UD2			
		throw("xadd64 failed")
  0x4317c5		488d0503e50300		LEAQ 0x3e503(IP), AX	
  0x4317cc		48890424		MOVQ AX, 0(SP)		
  0x4317d0		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4317d9		e8a21cffff		CALL runtime.throw(SB)	
  0x4317de		0f0b			UD2			
		throw("store64 failed")
  0x4317e0		488d0543e60300		LEAQ 0x3e643(IP), AX	
  0x4317e7		48890424		MOVQ AX, 0(SP)		
  0x4317eb		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4317f4		e8871cffff		CALL runtime.throw(SB)	
  0x4317f9		0f0b			UD2			
		throw("load64 failed")
  0x4317fb		488d057fe40300		LEAQ 0x3e47f(IP), AX	
  0x431802		48890424		MOVQ AX, 0(SP)		
  0x431806		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x43180f		e86c1cffff		CALL runtime.throw(SB)	
  0x431814		0f0b			UD2			
		throw("cas64 failed")
  0x431816		488d05a8e20300		LEAQ 0x3e2a8(IP), AX	
  0x43181d		48890424		MOVQ AX, 0(SP)		
  0x431821		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x43182a		e8511cffff		CALL runtime.throw(SB)	
  0x43182f		0f0b			UD2			
		throw("cas64 failed")
  0x431831		488d058de20300		LEAQ 0x3e28d(IP), AX	
  0x431838		48890424		MOVQ AX, 0(SP)		
  0x43183c		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x431845		e8361cffff		CALL runtime.throw(SB)	
  0x43184a		0f0b			UD2			
		throw("cas64 failed")
  0x43184c		488d0572e20300		LEAQ 0x3e272(IP), AX	
  0x431853		48890424		MOVQ AX, 0(SP)		
  0x431857		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x431860		e81b1cffff		CALL runtime.throw(SB)	
  0x431865		0f0b			UD2			
		throw("cas64 failed")
  0x431867		488d0557e20300		LEAQ 0x3e257(IP), AX	
  0x43186e		48890424		MOVQ AX, 0(SP)		
  0x431872		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x43187b		e8001cffff		CALL runtime.throw(SB)	
  0x431880		0f0b			UD2			
func testAtomic64() {
  0x431882		e8f95f0100		CALL runtime.morestack_noctxt(SB)	
  0x431887		e9a4fdffff		JMP runtime.testAtomic64(SB)		

TEXT runtime.check(SB) /usr/local/go/src/runtime/runtime1.go
func check() {
  0x431890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431899		483b6110		CMPQ 0x10(CX), SP	
  0x43189d		0f8681030000		JBE 0x431c24		
  0x4318a3		4883ec40		SUBQ $0x40, SP		
  0x4318a7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4318ac		488d6c2438		LEAQ 0x38(SP), BP	
		e     int32
  0x4318b1		c744242c00000000	MOVL $0x0, 0x2c(SP)	
		i, i1 float32
  0x4318b9		0f57c0			XORPS X0, X0		
  0x4318bc		f30f11442428		MOVSS X0, 0x28(SP)	
		j, j1 float64
  0x4318c2		0f57c0			XORPS X0, X0		
  0x4318c5		f20f11442430		MOVSD_XMM X0, 0x30(SP)	
		m     [4]byte
  0x4318cb		c744242400000000	MOVL $0x0, 0x24(SP)	
	if timediv(12345*1000000000+54321, 1000000000, &e) != 12345 || e != 54321 {
  0x4318d3		48b831ce574b3a0b0000	MOVQ $0xb3a4b57ce31, AX		
  0x4318dd		48890424		MOVQ AX, 0(SP)			
  0x4318e1		c744240800ca9a3b	MOVL $0x3b9aca00, 0x8(SP)	
  0x4318e9		488d44242c		LEAQ 0x2c(SP), AX		
  0x4318ee		4889442410		MOVQ AX, 0x10(SP)		
  0x4318f3		e858080000		CALL runtime.timediv(SB)	
  0x4318f8		817c241839300000	CMPL $0x3039, 0x18(SP)		
  0x431900		0f8503030000		JNE 0x431c09			
  0x431906		817c242c31d40000	CMPL $0xd431, 0x2c(SP)		
  0x43190e		0f85f5020000		JNE 0x431c09			
	var z uint32
  0x431914		c744242000000000	MOVL $0x0, 0x20(SP)	
	z = 1
  0x43191c		c744242001000000	MOVL $0x1, 0x20(SP)	
	if !atomic.Cas(&z, 1, 2) {
  0x431924		b801000000		MOVL $0x1, AX		
  0x431929		488d4c2420		LEAQ 0x20(SP), CX	
  0x43192e		ba02000000		MOVL $0x2, DX		
  0x431933		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x431937		0f94c2			SETE DL			
  0x43193a		84d2			TESTL DL, DL		
  0x43193c		0f84ac020000		JE 0x431bee		
	if z != 2 {
  0x431942		837c242002		CMPL $0x2, 0x20(SP)	
  0x431947		0f8586020000		JNE 0x431bd3		
	z = 4
  0x43194d		c744242004000000	MOVL $0x4, 0x20(SP)	
	if atomic.Cas(&z, 5, 6) {
  0x431955		b805000000		MOVL $0x5, AX		
  0x43195a		ba06000000		MOVL $0x6, DX		
  0x43195f		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x431963		0f94c2			SETE DL			
  0x431966		84d2			TESTL DL, DL		
  0x431968		0f854a020000		JNE 0x431bb8		
	if z != 4 {
  0x43196e		837c242004		CMPL $0x4, 0x20(SP)	
  0x431973		0f8524020000		JNE 0x431b9d		
	z = 0xffffffff
  0x431979		c7442420ffffffff	MOVL $-0x1, 0x20(SP)	
	if !atomic.Cas(&z, 0xffffffff, 0xfffffffe) {
  0x431981		b8ffffffff		MOVL $-0x1, AX		
  0x431986		bafeffffff		MOVL $-0x2, DX		
  0x43198b		f00fb111		LOCK CMPXCHGL DX, 0(CX)	
  0x43198f		0f94c1			SETE CL			
  0x431992		84c9			TESTL CL, CL		
  0x431994		0f84e8010000		JE 0x431b82		
	if z != 0xfffffffe {
  0x43199a		837c2420fe		CMPL $-0x2, 0x20(SP)	
  0x43199f		0f85c2010000		JNE 0x431b67		
	m = [4]byte{1, 1, 1, 1}
  0x4319a5		c744242400000000	MOVL $0x0, 0x24(SP)		
  0x4319ad		c744242401010101	MOVL $0x1010101, 0x24(SP)	
	atomic.Or8(&m[1], 0xf0)
  0x4319b5		b8f0ffffff		MOVL $-0x10, AX		
  0x4319ba		488d4c2425		LEAQ 0x25(SP), CX	
  0x4319bf		f00801			LOCK ORB AL, 0(CX)	
	if m[0] != 1 || m[1] != 0xf1 || m[2] != 1 || m[3] != 1 {
  0x4319c2		807c242401		CMPB $0x1, 0x24(SP)	
  0x4319c7		0f857f010000		JNE 0x431b4c		
  0x4319cd		807c2425f1		CMPB $0xf1, 0x25(SP)	
  0x4319d2		0f8574010000		JNE 0x431b4c		
  0x4319d8		807c242601		CMPB $0x1, 0x26(SP)	
  0x4319dd		0f8569010000		JNE 0x431b4c		
  0x4319e3		807c242701		CMPB $0x1, 0x27(SP)	
  0x4319e8		0f855e010000		JNE 0x431b4c		
	m = [4]byte{0xff, 0xff, 0xff, 0xff}
  0x4319ee		c744242400000000	MOVL $0x0, 0x24(SP)	
  0x4319f6		c7442424ffffffff	MOVL $-0x1, 0x24(SP)	
	atomic.And8(&m[1], 0x1)
  0x4319fe		b801000000		MOVL $0x1, AX		
  0x431a03		f02001			LOCK ANDB AL, 0(CX)	
	if m[0] != 0xff || m[1] != 0x1 || m[2] != 0xff || m[3] != 0xff {
  0x431a06		807c2424ff		CMPB $0xff, 0x24(SP)	
  0x431a0b		0f8520010000		JNE 0x431b31		
  0x431a11		807c242501		CMPB $0x1, 0x25(SP)	
  0x431a16		0f8515010000		JNE 0x431b31		
  0x431a1c		807c2426ff		CMPB $0xff, 0x26(SP)	
  0x431a21		0f850a010000		JNE 0x431b31		
  0x431a27		807c2427ff		CMPB $0xff, 0x27(SP)	
  0x431a2c		0f85ff000000		JNE 0x431b31		
	*(*uint64)(unsafe.Pointer(&j)) = ^uint64(0)
  0x431a32		48c7442430ffffffff	MOVQ $-0x1, 0x30(SP)	
	if j == j1 {
  0x431a3b		f20f10442430		MOVSD_XMM 0x30(SP), X0			
  0x431a41		f20f100dd7b20400	MOVSD_XMM $f64.fffffffffffffffe(SB), X1	
  0x431a49		660f2ec1		UCOMISD X1, X0				
  0x431a4d		7506			JNE 0x431a55				
  0x431a4f		0f8bc1000000		JNP 0x431b16				
	if !(j != j1) {
  0x431a55		7506			JNE 0x431a5d		
  0x431a57		0f8b9e000000		JNP 0x431afb		
	*(*uint32)(unsafe.Pointer(&i)) = ^uint32(0)
  0x431a5d		c7442428ffffffff	MOVL $-0x1, 0x28(SP)	
	if i == i1 {
  0x431a65		f30f10442428		MOVSS 0x28(SP), X0		
  0x431a6b		f30f100d11b20400	MOVSS $f32.fffffffe(SB), X1	
  0x431a73		0f2ec8			UCOMISS X0, X1			
  0x431a76		7502			JNE 0x431a7a			
  0x431a78		7b66			JNP 0x431ae0			
	testAtomic64()
  0x431a7a		e8b1fbffff		CALL runtime.testAtomic64(SB)	
	if _FixedStack != round2(_FixedStack) {
  0x431a7f		c7042400080000		MOVL $0x800, 0(SP)	
  0x431a86		e825630000		CALL runtime.round2(SB)	
  0x431a8b		817c240800080000	CMPL $0x800, 0x8(SP)	
  0x431a93		7530			JNE 0x431ac5		
	if !checkASM() {
  0x431a95		e8a67b0100		CALL runtime.checkASM(SB)	
  0x431a9a		803c2400		CMPB $0x0, 0(SP)		
  0x431a9e		740a			JE 0x431aaa			
  0x431aa0		488b6c2438		MOVQ 0x38(SP), BP		
  0x431aa5		4883c440		ADDQ $0x40, SP			
  0x431aa9		c3			RET				
		throw("assembly checks failed")
  0x431aaa		488d05a6ee0300		LEAQ 0x3eea6(IP), AX	
  0x431ab1		48890424		MOVQ AX, 0(SP)		
  0x431ab5		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x431abe		e8bd19ffff		CALL runtime.throw(SB)	
  0x431ac3		0f0b			UD2			
		throw("FixedStack is not power-of-2")
  0x431ac5		488d050afb0300		LEAQ 0x3fb0a(IP), AX	
  0x431acc		48890424		MOVQ AX, 0(SP)		
  0x431ad0		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x431ad9		e8a219ffff		CALL runtime.throw(SB)	
  0x431ade		0f0b			UD2			
		throw("float32nan2")
  0x431ae0		488d0521de0300		LEAQ 0x3de21(IP), AX	
  0x431ae7		48890424		MOVQ AX, 0(SP)		
  0x431aeb		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x431af4		e88719ffff		CALL runtime.throw(SB)	
  0x431af9		0f0b			UD2			
		throw("float64nan3")
  0x431afb		488d051cde0300		LEAQ 0x3de1c(IP), AX	
  0x431b02		48890424		MOVQ AX, 0(SP)		
  0x431b06		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x431b0f		e86c19ffff		CALL runtime.throw(SB)	
  0x431b14		0f0b			UD2			
		throw("float64nan2")
  0x431b16		488d05f6dd0300		LEAQ 0x3ddf6(IP), AX	
  0x431b1d		48890424		MOVQ AX, 0(SP)		
  0x431b21		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x431b2a		e85119ffff		CALL runtime.throw(SB)	
  0x431b2f		0f0b			UD2			
		throw("atomicand8")
  0x431b31		488d0570dc0300		LEAQ 0x3dc70(IP), AX	
  0x431b38		48890424		MOVQ AX, 0(SP)		
  0x431b3c		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x431b45		e83619ffff		CALL runtime.throw(SB)	
  0x431b4a		0f0b			UD2			
		throw("atomicor8")
  0x431b4c		488d050cda0300		LEAQ 0x3da0c(IP), AX	
  0x431b53		48890424		MOVQ AX, 0(SP)		
  0x431b57		48c744240809000000	MOVQ $0x9, 0x8(SP)	
  0x431b60		e81b19ffff		CALL runtime.throw(SB)	
  0x431b65		0f0b			UD2			
		throw("cas6")
  0x431b67		488d05f3d50300		LEAQ 0x3d5f3(IP), AX	
  0x431b6e		48890424		MOVQ AX, 0(SP)		
  0x431b72		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431b7b		e80019ffff		CALL runtime.throw(SB)	
  0x431b80		0f0b			UD2			
		throw("cas5")
  0x431b82		488d05d4d50300		LEAQ 0x3d5d4(IP), AX	
  0x431b89		48890424		MOVQ AX, 0(SP)		
  0x431b8d		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431b96		e8e518ffff		CALL runtime.throw(SB)	
  0x431b9b		0f0b			UD2			
		throw("cas4")
  0x431b9d		488d05b5d50300		LEAQ 0x3d5b5(IP), AX	
  0x431ba4		48890424		MOVQ AX, 0(SP)		
  0x431ba8		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431bb1		e8ca18ffff		CALL runtime.throw(SB)	
  0x431bb6		0f0b			UD2			
		throw("cas3")
  0x431bb8		488d0596d50300		LEAQ 0x3d596(IP), AX	
  0x431bbf		48890424		MOVQ AX, 0(SP)		
  0x431bc3		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431bcc		e8af18ffff		CALL runtime.throw(SB)	
  0x431bd1		0f0b			UD2			
		throw("cas2")
  0x431bd3		488d0577d50300		LEAQ 0x3d577(IP), AX	
  0x431bda		48890424		MOVQ AX, 0(SP)		
  0x431bde		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431be7		e89418ffff		CALL runtime.throw(SB)	
  0x431bec		0f0b			UD2			
		throw("cas1")
  0x431bee		488d0558d50300		LEAQ 0x3d558(IP), AX	
  0x431bf5		48890424		MOVQ AX, 0(SP)		
  0x431bf9		48c744240804000000	MOVQ $0x4, 0x8(SP)	
  0x431c02		e87918ffff		CALL runtime.throw(SB)	
  0x431c07		0f0b			UD2			
		throw("bad timediv")
  0x431c09		488d05ccdc0300		LEAQ 0x3dccc(IP), AX	
  0x431c10		48890424		MOVQ AX, 0(SP)		
  0x431c14		48c74424080b000000	MOVQ $0xb, 0x8(SP)	
  0x431c1d		e85e18ffff		CALL runtime.throw(SB)	
  0x431c22		0f0b			UD2			
func check() {
  0x431c24		e8575c0100		CALL runtime.morestack_noctxt(SB)	
  0x431c29		e962fcffff		JMP runtime.check(SB)			

TEXT runtime.parsedebugvars(SB) /usr/local/go/src/runtime/runtime1.go
func parsedebugvars() {
  0x431c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431c39		488d4424f8		LEAQ -0x8(SP), AX	
  0x431c3e		483b4110		CMPQ 0x10(CX), AX	
  0x431c42		0f8641030000		JBE 0x431f89		
  0x431c48		4881ec88000000		SUBQ $0x88, SP		
  0x431c4f		4889ac2480000000	MOVQ BP, 0x80(SP)	
  0x431c57		488dac2480000000	LEAQ 0x80(SP), BP	
	debug.cgocheck = 1
  0x431c5f		c7057bb20a0001000000	MOVL $0x1, runtime.debug+4(SB)	
	debug.invalidptr = 1
  0x431c69		c70591b20a0001000000	MOVL $0x1, runtime.debug+36(SB)	
	for p := gogetenv("GODEBUG"); p != ""; {
  0x431c73		488d0570d60300		LEAQ 0x3d670(IP), AX		
  0x431c7a		48890424		MOVQ AX, 0(SP)			
  0x431c7e		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x431c87		e8e443fdff		CALL runtime.gogetenv(SB)	
  0x431c8c		488b442410		MOVQ 0x10(SP), AX		
  0x431c91		488b4c2418		MOVQ 0x18(SP), CX		
  0x431c96		eb0a			JMP 0x431ca2			
  0x431c98		488b442460		MOVQ 0x60(SP), AX		
  0x431c9d		488b4c2428		MOVQ 0x28(SP), CX		
  0x431ca2		4885c9			TESTQ CX, CX			
  0x431ca5		0f8483020000		JE 0x431f2e			
  0x431cab		4889442468		MOVQ AX, 0x68(SP)		
  0x431cb0		48894c2438		MOVQ CX, 0x38(SP)		
		i := index(p, ",")
  0x431cb5		48890424		MOVQ AX, 0(SP)		
  0x431cb9		48894c2408		MOVQ CX, 0x8(SP)	
  0x431cbe		488d15bfd30300		LEAQ 0x3d3bf(IP), DX	
  0x431cc5		4889542410		MOVQ DX, 0x10(SP)	
  0x431cca		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x431cd3		e8f8800000		CALL runtime.index(SB)	
  0x431cd8		488b442420		MOVQ 0x20(SP), AX	
		if i < 0 {
  0x431cdd		4885c0			TESTQ AX, AX		
  0x431ce0		0f8d0a020000		JGE 0x431ef0		
  0x431ce6		31c0			XORL AX, AX		
  0x431ce8		31c9			XORL CX, CX		
		i = index(field, "=")
  0x431cea		488b542438		MOVQ 0x38(SP), DX	
  0x431cef		4889542438		MOVQ DX, 0x38(SP)	
	for p := gogetenv("GODEBUG"); p != ""; {
  0x431cf4		4889442460		MOVQ AX, 0x60(SP)	
  0x431cf9		48894c2428		MOVQ CX, 0x28(SP)	
		i = index(field, "=")
  0x431cfe		488b5c2468		MOVQ 0x68(SP), BX	
  0x431d03		48891c24		MOVQ BX, 0(SP)		
  0x431d07		4889542408		MOVQ DX, 0x8(SP)	
  0x431d0c		488d3577d30300		LEAQ 0x3d377(IP), SI	
  0x431d13		4889742410		MOVQ SI, 0x10(SP)	
  0x431d18		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x431d21		e8aa800000		CALL runtime.index(SB)	
  0x431d26		488b442420		MOVQ 0x20(SP), AX	
		if i < 0 {
  0x431d2b		4885c0			TESTQ AX, AX		
  0x431d2e		0f8c64ffffff		JL 0x431c98		
		key, value := field[:i], field[i+1:]
  0x431d34		488b4c2438		MOVQ 0x38(SP), CX	
  0x431d39		4839c8			CMPQ CX, AX		
  0x431d3c		0f8739020000		JA 0x431f7b		
  0x431d42		488d5001		LEAQ 0x1(AX), DX	
  0x431d46		4839ca			CMPQ CX, DX		
  0x431d49		0f872c020000		JA 0x431f7b		
  0x431d4f		4829d1			SUBQ DX, CX		
  0x431d52		4889cb			MOVQ CX, BX		
  0x431d55		48f7d9			NEGQ CX			
  0x431d58		48c1f93f		SARQ $0x3f, CX		
  0x431d5c		4821d1			ANDQ DX, CX		
  0x431d5f		488b542468		MOVQ 0x68(SP), DX	
  0x431d64		4801d1			ADDQ DX, CX		
		if key == "memprofilerate" {
  0x431d67		4883f80e		CMPQ $0xe, AX			
  0x431d6b		0f8570010000		JNE 0x431ee1			
  0x431d71		48be6d656d70726f6669	MOVQ $0x69666f72706d656d, SI	
  0x431d7b		483932			CMPQ SI, 0(DX)			
  0x431d7e		7515			JNE 0x431d95			
  0x431d80		817a086c657261		CMPL $0x6172656c, 0x8(DX)	
  0x431d87		750c			JNE 0x431d95			
  0x431d89		66817a0c7465		CMPW $0x6574, 0xc(DX)		
  0x431d8f		0f841c010000		JE 0x431eb1			
			for _, v := range dbgvars {
  0x431d95		488b3df4de0800		MOVQ runtime.dbgvars(SB), DI	
  0x431d9c		4c8b05f5de0800		MOVQ runtime.dbgvars+8(SB), R8	
  0x431da3		4d85c0			TESTQ R8, R8			
  0x431da6		0f8eecfeffff		JLE 0x431c98			
		i = index(field, "=")
  0x431dac		4889442430		MOVQ AX, 0x30(SP)	
		key, value := field[:i], field[i+1:]
  0x431db1		48895c2450		MOVQ BX, 0x50(SP)	
  0x431db6		48894c2458		MOVQ CX, 0x58(SP)	
			for _, v := range dbgvars {
  0x431dbb		4c89442448		MOVQ R8, 0x48(SP)	
  0x431dc0		4531c9			XORL R9, R9		
  0x431dc3		eb04			JMP 0x431dc9		
  0x431dc5		4883c718		ADDQ $0x18, DI		
  0x431dc9		4c8b5708		MOVQ 0x8(DI), R10	
  0x431dcd		4c8b1f			MOVQ 0(DI), R11		
  0x431dd0		4c8b6710		MOVQ 0x10(DI), R12	
				if v.name == key {
  0x431dd4		4939c2			CMPQ AX, R10		
  0x431dd7		740d			JE 0x431de6		
			for _, v := range dbgvars {
  0x431dd9		49ffc1			INCQ R9			
  0x431ddc		4d39c1			CMPQ R8, R9		
  0x431ddf		7ce4			JL 0x431dc5		
  0x431de1		e9b2feffff		JMP 0x431c98		
  0x431de6		48897c2478		MOVQ DI, 0x78(SP)	
  0x431deb		4c894c2440		MOVQ R9, 0x40(SP)	
  0x431df0		4c89642470		MOVQ R12, 0x70(SP)	
				if v.name == key {
  0x431df5		4c891c24		MOVQ R11, 0(SP)			
  0x431df9		4889542408		MOVQ DX, 0x8(SP)		
  0x431dfe		4c89542410		MOVQ R10, 0x10(SP)		
  0x431e03		e81804fdff		CALL runtime.memequal(SB)	
  0x431e08		807c241800		CMPB $0x0, 0x18(SP)		
  0x431e0d		752f			JNE 0x431e3e			
  0x431e0f		488b442430		MOVQ 0x30(SP), AX		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e14		488b4c2458		MOVQ 0x58(SP), CX	
				if v.name == key {
  0x431e19		488b542468		MOVQ 0x68(SP), DX	
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e1e		488b5c2450		MOVQ 0x50(SP), BX		
  0x431e23		48be6d656d70726f6669	MOVQ $0x69666f72706d656d, SI	
			for _, v := range dbgvars {
  0x431e2d		488b7c2478		MOVQ 0x78(SP), DI	
  0x431e32		4c8b442448		MOVQ 0x48(SP), R8	
  0x431e37		4c8b4c2440		MOVQ 0x40(SP), R9	
				if v.name == key {
  0x431e3c		eb9b			JMP 0x431dd9		
					if n, ok := atoi32(value); ok {
  0x431e3e		90			NOPL			
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e3f		488b442458		MOVQ 0x58(SP), AX	
  0x431e44		48890424		MOVQ AX, 0(SP)		
  0x431e48		488b4c2450		MOVQ 0x50(SP), CX	
  0x431e4d		48894c2408		MOVQ CX, 0x8(SP)	
  0x431e52		e879800000		CALL runtime.atoi(SB)	
  0x431e57		488b442410		MOVQ 0x10(SP), AX	
  0x431e5c		4863c8			MOVSXD AX, CX		
  0x431e5f		4839c1			CMPQ AX, CX		
					if n, ok := atoi32(value); ok {
  0x431e62		b900000000		MOVL $0x0, CX		
  0x431e67		0f44c8			CMOVE AX, CX		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e6a		0f94c0			SETE AL			
  0x431e6d		0fb6542418		MOVZX 0x18(SP), DX	
					if n, ok := atoi32(value); ok {
  0x431e72		21d0			ANDL DX, AX		
  0x431e74		84c0			TESTL AL, AL		
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e76		7407			JE 0x431e7f		
						*v.value = n
  0x431e78		488b442470		MOVQ 0x70(SP), AX	
  0x431e7d		8908			MOVL CX, 0(AX)		
				if v.name == key {
  0x431e7f		488b442430		MOVQ 0x30(SP), AX	
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e84		488b4c2458		MOVQ 0x58(SP), CX	
				if v.name == key {
  0x431e89		488b542468		MOVQ 0x68(SP), DX	
	if n, ok := atoi(s); n == int(int32(n)) {
  0x431e8e		488b5c2450		MOVQ 0x50(SP), BX		
  0x431e93		48be6d656d70726f6669	MOVQ $0x69666f72706d656d, SI	
			for _, v := range dbgvars {
  0x431e9d		488b7c2478		MOVQ 0x78(SP), DI	
  0x431ea2		4c8b442448		MOVQ 0x48(SP), R8	
  0x431ea7		4c8b4c2440		MOVQ 0x40(SP), R9	
  0x431eac		e928ffffff		JMP 0x431dd9		
			if n, ok := atoi(value); ok {
  0x431eb1		48890c24		MOVQ CX, 0(SP)		
  0x431eb5		48895c2408		MOVQ BX, 0x8(SP)	
  0x431eba		e811800000		CALL runtime.atoi(SB)	
  0x431ebf		488b442410		MOVQ 0x10(SP), AX	
  0x431ec4		807c241800		CMPB $0x0, 0x18(SP)	
  0x431ec9		7407			JE 0x431ed2		
				MemProfileRate = n
  0x431ecb		48890556d10800		MOVQ AX, runtime.MemProfileRate(SB)	
	setTraceback(gogetenv("GOTRACEBACK"))
  0x431ed2		48be6d656d70726f6669	MOVQ $0x69666f72706d656d, SI	
	for p := gogetenv("GODEBUG"); p != ""; {
  0x431edc		e9b7fdffff		JMP 0x431c98			
  0x431ee1		48be6d656d70726f6669	MOVQ $0x69666f72706d656d, SI	
		if key == "memprofilerate" {
  0x431eeb		e9a5feffff		JMP 0x431d95		
			field, p = p[:i], p[i+1:]
  0x431ef0		488b4c2438		MOVQ 0x38(SP), CX	
  0x431ef5		4839c8			CMPQ CX, AX		
  0x431ef8		0f8784000000		JA 0x431f82		
  0x431efe		488d5001		LEAQ 0x1(AX), DX	
  0x431f02		4839ca			CMPQ CX, DX		
  0x431f05		777b			JA 0x431f82		
  0x431f07		4829d1			SUBQ DX, CX		
  0x431f0a		4889cb			MOVQ CX, BX		
  0x431f0d		48f7d9			NEGQ CX			
  0x431f10		48c1f93f		SARQ $0x3f, CX		
  0x431f14		4821d1			ANDQ DX, CX		
  0x431f17		488b742468		MOVQ 0x68(SP), SI	
  0x431f1c		488d3c0e		LEAQ 0(SI)(CX*1), DI	
	for p := gogetenv("GODEBUG"); p != ""; {
  0x431f20		4889d9			MOVQ BX, CX		
		i = index(field, "=")
  0x431f23		4889c2			MOVQ AX, DX		
	for p := gogetenv("GODEBUG"); p != ""; {
  0x431f26		4889f8			MOVQ DI, AX		
			field, p = p[:i], p[i+1:]
  0x431f29		e9c1fdffff		JMP 0x431cef		
	setTraceback(gogetenv("GOTRACEBACK"))
  0x431f2e		488d059cd90300		LEAQ 0x3d99c(IP), AX			
  0x431f35		48890424		MOVQ AX, 0(SP)				
  0x431f39		48c74424080b000000	MOVQ $0xb, 0x8(SP)			
  0x431f42		e82941fdff		CALL runtime.gogetenv(SB)		
  0x431f47		488b442418		MOVQ 0x18(SP), AX			
  0x431f4c		488b4c2410		MOVQ 0x10(SP), CX			
  0x431f51		48890c24		MOVQ CX, 0(SP)				
  0x431f55		4889442408		MOVQ AX, 0x8(SP)			
  0x431f5a		e841000000		CALL runtime/debug.SetTraceback(SB)	
	traceback_env = traceback_cache
  0x431f5f		8b05a7d00800		MOVL runtime.traceback_cache(SB), AX	
  0x431f65		89059dad0a00		MOVL AX, runtime.traceback_env(SB)	
}
  0x431f6b		488bac2480000000	MOVQ 0x80(SP), BP	
  0x431f73		4881c488000000		ADDQ $0x88, SP		
  0x431f7a		c3			RET			
		key, value := field[:i], field[i+1:]
  0x431f7b		e8d000ffff		CALL runtime.panicslice(SB)	
  0x431f80		0f0b			UD2				
			field, p = p[:i], p[i+1:]
  0x431f82		e8c900ffff		CALL runtime.panicslice(SB)	
  0x431f87		0f0b			UD2				
func parsedebugvars() {
  0x431f89		e8f2580100		CALL runtime.morestack_noctxt(SB)	
  0x431f8e		e99dfcffff		JMP runtime.parsedebugvars(SB)		

TEXT runtime/debug.SetTraceback(SB) /usr/local/go/src/runtime/runtime1.go
func setTraceback(level string) {
  0x431fa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x431fa9		483b6110		CMPQ 0x10(CX), SP	
  0x431fad		0f868b010000		JBE 0x43213e		
  0x431fb3		4883ec30		SUBQ $0x30, SP		
  0x431fb7		48896c2428		MOVQ BP, 0x28(SP)	
  0x431fbc		488d6c2428		LEAQ 0x28(SP), BP	
	switch level {
  0x431fc1		488b442440		MOVQ 0x40(SP), AX	
  0x431fc6		4883f804		CMPQ $0x4, AX		
  0x431fca		0f8db2000000		JGE 0x432082		
	case "single", "":
  0x431fd0		4885c0			TESTQ AX, AX		
  0x431fd3		7535			JNE 0x43200a		
	if islibrary || isarchive {
  0x431fd5		b804000000		MOVL $0x4, AX				
  0x431fda		803dceac0a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x431fe1		741c			JE 0x431fff				
		t |= tracebackCrash
  0x431fe3		83c801			ORL $0x1, AX		
	t |= traceback_env
  0x431fe6		0b051cad0a00		ORL runtime.traceback_env(SB), AX	
	atomic.Store(&traceback_cache, t)
  0x431fec		488d0d19d00800		LEAQ runtime.traceback_cache(SB), CX	
  0x431ff3		8701			XCHGL AX, 0(CX)				
}
  0x431ff5		488b6c2428		MOVQ 0x28(SP), BP	
  0x431ffa		4883c430		ADDQ $0x30, SP		
  0x431ffe		c3			RET			
	if islibrary || isarchive {
  0x431fff		803da7ac0a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x432006		75db			JNE 0x431fe3				
  0x432008		ebdc			JMP 0x431fe6				
	case "all":
  0x43200a		4883f803		CMPQ $0x3, AX		
  0x43200e		7567			JNE 0x432077		
  0x432010		488b4c2438		MOVQ 0x38(SP), CX	
  0x432015		668139616c		CMPW $0x6c61, 0(CX)	
  0x43201a		7555			JNE 0x432071		
  0x43201c		8079026c		CMPB $0x6c, 0x2(CX)	
  0x432020		7507			JNE 0x432029		
  0x432022		b806000000		MOVL $0x6, AX		
	switch level {
  0x432027		ebb1			JMP 0x431fda		
  0x432029		4883f804		CMPQ $0x4, AX		
	case "none":
  0x43202d		750c			JNE 0x43203b		
  0x43202f		81396e6f6e65		CMPL $0x656e6f6e, 0(CX)	
  0x432035		7504			JNE 0x43203b		
  0x432037		31c0			XORL AX, AX		
	switch level {
  0x432039		eb9f			JMP 0x431fda		
		if n, ok := atoi(level); ok && n == int(uint32(n)) {
  0x43203b		48890c24		MOVQ CX, 0(SP)		
  0x43203f		4889442408		MOVQ AX, 0x8(SP)	
  0x432044		e8877e0000		CALL runtime.atoi(SB)	
  0x432049		488b442410		MOVQ 0x10(SP), AX	
  0x43204e		807c241800		CMPB $0x0, 0x18(SP)	
  0x432053		7412			JE 0x432067		
  0x432055		89c1			MOVL AX, CX		
  0x432057		4839c1			CMPQ AX, CX		
  0x43205a		750b			JNE 0x432067		
			t |= uint32(n) << tracebackShift
  0x43205c		c1e002			SHLL $0x2, AX		
  0x43205f		83c802			ORL $0x2, AX		
  0x432062		e973ffffff		JMP 0x431fda		
  0x432067		b802000000		MOVL $0x2, AX		
	switch level {
  0x43206c		e969ffffff		JMP 0x431fda		
  0x432071		4883f804		CMPQ $0x4, AX		
	case "all":
  0x432075		ebb6			JMP 0x43202d		
	switch level {
  0x432077		4883f804		CMPQ $0x4, AX		
	case "none":
  0x43207b		488b4c2438		MOVQ 0x38(SP), CX	
	case "all":
  0x432080		ebab			JMP 0x43202d		
	switch level {
  0x432082		7476			JE 0x4320fa		
	case "crash":
  0x432084		4883f805		CMPQ $0x5, AX		
  0x432088		7569			JNE 0x4320f3		
  0x43208a		488b4c2438		MOVQ 0x38(SP), CX	
  0x43208f		813963726173		CMPL $0x73617263, 0(CX)	
  0x432095		7510			JNE 0x4320a7		
  0x432097		80790468		CMPB $0x68, 0x4(CX)	
  0x43209b		750a			JNE 0x4320a7		
  0x43209d		b80b000000		MOVL $0xb, AX		
	switch level {
  0x4320a2		e933ffffff		JMP 0x431fda		
	case "single", "":
  0x4320a7		4883f806		CMPQ $0x6, AX		
  0x4320ab		7518			JNE 0x4320c5		
  0x4320ad		813973696e67		CMPL $0x676e6973, 0(CX)	
  0x4320b3		7538			JNE 0x4320ed		
  0x4320b5		668179046c65		CMPW $0x656c, 0x4(CX)	
  0x4320bb		0f8414ffffff		JE 0x431fd5		
  0x4320c1		4883f806		CMPQ $0x6, AX		
	case "system":
  0x4320c5		0f8570ffffff		JNE 0x43203b		
  0x4320cb		813973797374		CMPL $0x74737973, 0(CX)	
  0x4320d1		0f8564ffffff		JNE 0x43203b		
  0x4320d7		66817904656d		CMPW $0x6d65, 0x4(CX)	
  0x4320dd		0f8558ffffff		JNE 0x43203b		
  0x4320e3		b80a000000		MOVL $0xa, AX		
	switch level {
  0x4320e8		e9edfeffff		JMP 0x431fda		
	case "single", "":
  0x4320ed		4883f806		CMPQ $0x6, AX		
  0x4320f1		ebd2			JMP 0x4320c5		
  0x4320f3		488b4c2438		MOVQ 0x38(SP), CX	
	case "crash":
  0x4320f8		ebad			JMP 0x4320a7		
	switch level {
  0x4320fa		488b4c2438		MOVQ 0x38(SP), CX		
  0x4320ff		48890c24		MOVQ CX, 0(SP)			
  0x432103		4889442408		MOVQ AX, 0x8(SP)		
  0x432108		488d1562d00300		LEAQ 0x3d062(IP), DX		
  0x43210f		4889542410		MOVQ DX, 0x10(SP)		
  0x432114		48c744241804000000	MOVQ $0x4, 0x18(SP)		
  0x43211d		e89efefcff		CALL runtime.cmpstring(SB)	
  0x432122		48837c242000		CMPQ $0x0, 0x20(SP)		
  0x432128		7f0a			JG 0x432134			
	case "single", "":
  0x43212a		488b442440		MOVQ 0x40(SP), AX	
	switch level {
  0x43212f		e99cfeffff		JMP 0x431fd0		
	case "crash":
  0x432134		488b442440		MOVQ 0x40(SP), AX	
	switch level {
  0x432139		e946ffffff		JMP 0x432084		
func setTraceback(level string) {
  0x43213e		e83d570100		CALL runtime.morestack_noctxt(SB)	
  0x432143		e958feffff		JMP runtime/debug.SetTraceback(SB)	

TEXT runtime.timediv(SB) /usr/local/go/src/runtime/runtime1.go
	for bit := 30; bit >= 0; bit-- {
  0x432150		8b442410		MOVL 0x10(SP), AX	
  0x432154		488b542408		MOVQ 0x8(SP), DX	
  0x432159		b91e000000		MOVL $0x1e, CX		
  0x43215e		31db			XORL BX, BX		
  0x432160		eb03			JMP 0x432165		
  0x432162		48ffc9			DECQ CX			
  0x432165		4885c9			TESTQ CX, CX		
  0x432168		7c13			JL 0x43217d		
		if v >= int64(div)<<uint(bit) {
  0x43216a		4863f0			MOVSXD AX, SI		
  0x43216d		48d3e6			SHLQ CL, SI		
  0x432170		4839f2			CMPQ SI, DX		
  0x432173		7ced			JL 0x432162		
			v = v - (int64(div) << uint(bit))
  0x432175		4829f2			SUBQ SI, DX		
			res |= 1 << uint(bit)
  0x432178		0fabcb			BTSL CX, BX		
  0x43217b		ebe5			JMP 0x432162		
	if v >= int64(div) {
  0x43217d		4863c0			MOVSXD AX, AX		
  0x432180		4839c2			CMPQ AX, DX		
  0x432183		7c19			JL 0x43219e		
		if rem != nil {
  0x432185		488b442418		MOVQ 0x18(SP), AX	
  0x43218a		4885c0			TESTQ AX, AX		
  0x43218d		7406			JE 0x432195		
			*rem = 0
  0x43218f		c70000000000		MOVL $0x0, 0(AX)	
		return 0x7fffffff
  0x432195		c7442420ffffff7f	MOVL $0x7fffffff, 0x20(SP)	
  0x43219d		c3			RET				
	if rem != nil {
  0x43219e		488b442418		MOVQ 0x18(SP), AX	
  0x4321a3		4885c0			TESTQ AX, AX		
  0x4321a6		7402			JE 0x4321aa		
		*rem = int32(v)
  0x4321a8		8910			MOVL DX, 0(AX)		
	return res
  0x4321aa		895c2420		MOVL BX, 0x20(SP)	
  0x4321ae		c3			RET			

TEXT runtime.extendRandom(SB) /usr/local/go/src/runtime/runtime2.go
func extendRandom(r []byte, n int) {
  0x4321b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4321b9		483b6110		CMPQ 0x10(CX), SP	
  0x4321bd		0f86c5000000		JBE 0x432288		
  0x4321c3		4883ec30		SUBQ $0x30, SP		
  0x4321c7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4321cc		488d6c2428		LEAQ 0x28(SP), BP	
	if n < 0 {
  0x4321d1		488b442450		MOVQ 0x50(SP), AX	
  0x4321d6		4885c0			TESTQ AX, AX		
	for n < len(r) {
  0x4321d9		b900000000		MOVL $0x0, CX		
  0x4321de		480f4cc1		CMOVL CX, AX		
	if n < 0 {
  0x4321e2		eb1f			JMP 0x432203		
			r[n] = byte(h)
  0x4321e4		88041a			MOVB AL, 0(DX)(BX*1)	
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x4321e7		48ffc6			INCQ SI			
			n++
  0x4321ea		48ffc3			INCQ BX			
			h >>= 8
  0x4321ed		48c1e808		SHRQ $0x8, AX		
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x4321f1		4883fe08		CMPQ $0x8, SI		
  0x4321f5		7d09			JGE 0x432200		
  0x4321f7		4839cb			CMPQ CX, BX		
  0x4321fa		7d04			JGE 0x432200		
			r[n] = byte(h)
  0x4321fc		72e6			JB 0x4321e4		
  0x4321fe		eb7a			JMP 0x43227a		
	for n < len(r) {
  0x432200		4889d8			MOVQ BX, AX		
  0x432203		488b4c2440		MOVQ 0x40(SP), CX	
  0x432208		4839c8			CMPQ CX, AX		
  0x43220b		7d63			JGE 0x432270		
  0x43220d		4889442420		MOVQ AX, 0x20(SP)	
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x432212		e8998e0100		CALL runtime.nanotime(SB)	
		if w > 16 {
  0x432217		488b442420		MOVQ 0x20(SP), AX	
  0x43221c		4883f810		CMPQ $0x10, AX		
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x432220		b910000000		MOVL $0x10, CX		
  0x432225		4889c2			MOVQ AX, DX		
  0x432228		480f4fc1		CMOVG CX, AX		
  0x43222c		4829c2			SUBQ AX, DX		
  0x43222f		488b3424		MOVQ 0(SP), SI		
  0x432233		488b7c2440		MOVQ 0x40(SP), DI	
  0x432238		4839fa			CMPQ DI, DX		
		if w > 16 {
  0x43223b		7344			JAE 0x432281		
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x43223d		488b4c2438		MOVQ 0x38(SP), CX		
  0x432242		4801ca			ADDQ CX, DX			
  0x432245		48891424		MOVQ DX, 0(SP)			
  0x432249		4889742408		MOVQ SI, 0x8(SP)		
  0x43224e		4889442410		MOVQ AX, 0x10(SP)		
  0x432253		e86850fdff		CALL runtime.memhash(SB)	
  0x432258		488b442418		MOVQ 0x18(SP), AX		
		for i := 0; i < sys.PtrSize && n < len(r); i++ {
  0x43225d		488b4c2440		MOVQ 0x40(SP), CX	
  0x432262		488b542438		MOVQ 0x38(SP), DX	
  0x432267		488b5c2420		MOVQ 0x20(SP), BX	
  0x43226c		31f6			XORL SI, SI		
  0x43226e		eb81			JMP 0x4321f1		
  0x432270		488b6c2428		MOVQ 0x28(SP), BP	
  0x432275		4883c430		ADDQ $0x30, SP		
  0x432279		c3			RET			
			r[n] = byte(h)
  0x43227a		e8a1fcfeff		CALL runtime.panicindex(SB)	
  0x43227f		0f0b			UD2				
		h := memhash(unsafe.Pointer(&r[n-w]), uintptr(nanotime()), uintptr(w))
  0x432281		e89afcfeff		CALL runtime.panicindex(SB)	
  0x432286		0f0b			UD2				
func extendRandom(r []byte, n int) {
  0x432288		e8f3550100		CALL runtime.morestack_noctxt(SB)	
  0x43228d		e91effffff		JMP runtime.extendRandom(SB)		

TEXT runtime.waitReason.String(SB) /usr/local/go/src/runtime/runtime2.go
func (w waitReason) String() string {
  0x4322a0		4883ec08		SUBQ $0x8, SP		
  0x4322a4		48892c24		MOVQ BP, 0(SP)		
  0x4322a8		488d2c24		LEAQ 0(SP), BP		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x4322ac		0fb6442410		MOVZX 0x10(SP), AX	
  0x4322b1		84c0			TESTL AL, AL		
  0x4322b3		731e			JAE 0x4322d3		
		return "unknown wait reason"
  0x4322b5		488d0576e20300		LEAQ 0x3e276(IP), AX	
  0x4322bc		4889442418		MOVQ AX, 0x18(SP)	
  0x4322c1		48c744242013000000	MOVQ $0x13, 0x20(SP)	
  0x4322ca		488b2c24		MOVQ 0(SP), BP		
  0x4322ce		4883c408		ADDQ $0x8, SP		
  0x4322d2		c3			RET			
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x4322d3		80f818			CMPL $0x18, AL		
  0x4322d6		73dd			JAE 0x4322b5		
	return waitReasonStrings[w]
  0x4322d8		4883f818		CMPQ $0x18, AX				
  0x4322dc		7327			JAE 0x432305				
  0x4322de		48c1e004		SHLQ $0x4, AX				
  0x4322e2		488d0d17de0800		LEAQ runtime.waitReasonStrings(SB), CX	
  0x4322e9		488b1401		MOVQ 0(CX)(AX*1), DX			
  0x4322ed		488b440108		MOVQ 0x8(CX)(AX*1), AX			
  0x4322f2		4889542418		MOVQ DX, 0x18(SP)			
  0x4322f7		4889442420		MOVQ AX, 0x20(SP)			
  0x4322fc		488b2c24		MOVQ 0(SP), BP				
  0x432300		4883c408		ADDQ $0x8, SP				
  0x432304		c3			RET					
  0x432305		e816fcfeff		CALL runtime.panicindex(SB)		
  0x43230a		0f0b			UD2					

TEXT runtime.(*rwmutex).rlock(SB) /usr/local/go/src/runtime/rwmutex.go
func (rw *rwmutex) rlock() {
  0x432310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432319		483b6110		CMPQ 0x10(CX), SP	
  0x43231d		766c			JBE 0x43238b		
  0x43231f		4883ec20		SUBQ $0x20, SP		
  0x432323		48896c2418		MOVQ BP, 0x18(SP)	
  0x432328		488d6c2418		LEAQ 0x18(SP), BP	
	_g_ := getg()
  0x43232d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x432336		488b4830		MOVQ 0x30(AX), CX	
	acquirem()
  0x43233a		90			NOPL			
	_g_.m.locks++
  0x43233b		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x432341		8400			TESTB AL, 0(AX)		
	if int32(atomic.Xadd(&rw.readerCount, 1)) < 0 {
  0x432343		b801000000		MOVL $0x1, AX		
  0x432348		488b4c2428		MOVQ 0x28(SP), CX	
  0x43234d		f00fc14128		LOCK XADDL AX, 0x28(CX)	
  0x432352		ffc0			INCL AX			
  0x432354		85c0			TESTL AX, AX		
  0x432356		7c0a			JL 0x432362		
  0x432358		488b6c2418		MOVQ 0x18(SP), BP	
  0x43235d		4883c420		ADDQ $0x20, SP		
  0x432361		c3			RET			
		systemstack(func() {
  0x432362		0f57c0			XORPS X0, X0					
  0x432365		0f11442408		MOVUPS X0, 0x8(SP)				
  0x43236a		488d051f4b0100		LEAQ runtime.(*rwmutex).rlock.func1(SB), AX	
  0x432371		4889442408		MOVQ AX, 0x8(SP)				
  0x432376		48894c2410		MOVQ CX, 0x10(SP)				
  0x43237b		488d442408		LEAQ 0x8(SP), AX				
  0x432380		48890424		MOVQ AX, 0(SP)					
  0x432384		e8a7530100		CALL runtime.systemstack(SB)			
  0x432389		ebcd			JMP 0x432358					
func (rw *rwmutex) rlock() {
  0x43238b		e8f0540100		CALL runtime.morestack_noctxt(SB)	
  0x432390		e97bffffff		JMP runtime.(*rwmutex).rlock(SB)	

TEXT runtime.(*rwmutex).runlock(SB) /usr/local/go/src/runtime/rwmutex.go
func (rw *rwmutex) runlock() {
  0x4323a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4323a9		483b6110		CMPQ 0x10(CX), SP	
  0x4323ad		0f86d9000000		JBE 0x43248c		
  0x4323b3		4883ec18		SUBQ $0x18, SP		
  0x4323b7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4323bc		488d6c2410		LEAQ 0x10(SP), BP	
	if r := int32(atomic.Xadd(&rw.readerCount, -1)); r < 0 {
  0x4323c1		b8ffffffff		MOVL $-0x1, AX		
  0x4323c6		488b4c2420		MOVQ 0x20(SP), CX	
  0x4323cb		f00fc14128		LOCK XADDL AX, 0x28(CX)	
  0x4323d0		ffc8			DECL AX			
  0x4323d2		85c0			TESTL AX, AX		
  0x4323d4		7d24			JGE 0x4323fa		
		if r+1 == 0 || r+1 == -rwmutexMaxReaders {
  0x4323d6		83f8ff			CMPL $-0x1, AX		
  0x4323d9		0f8492000000		JE 0x432471		
  0x4323df		3dffffffbf		CMPL $-0x40000001, AX	
  0x4323e4		0f8487000000		JE 0x432471		
		if atomic.Xadd(&rw.readerWait, -1) == 0 {
  0x4323ea		b8ffffffff		MOVL $-0x1, AX		
  0x4323ef		f00fc1412c		LOCK XADDL AX, 0x2c(CX)	
  0x4323f4		ffc8			DECL AX			
  0x4323f6		85c0			TESTL AX, AX		
  0x4323f8		743d			JE 0x432437		
	releasem(getg().m)
  0x4323fa		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x432403		488b4830		MOVQ 0x30(AX), CX	
  0x432407		90			NOPL			
	mp.locks--
  0x432408		8b9108010000		MOVL 0x108(CX), DX	
  0x43240e		8d5aff			LEAL -0x1(DX), BX	
  0x432411		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x432417		83fa01			CMPL $0x1, DX		
  0x43241a		7511			JNE 0x43242d		
  0x43241c		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x432423		7408			JE 0x43242d		
		_g_.stackguard0 = stackPreempt
  0x432425		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43242d		488b6c2410		MOVQ 0x10(SP), BP	
  0x432432		4883c418		ADDQ $0x18, SP		
  0x432436		c3			RET			
			lock(&rw.rLock)
  0x432437		48890c24		MOVQ CX, 0(SP)		
  0x43243b		e8a062fdff		CALL runtime.lock(SB)	
			w := rw.writer.ptr()
  0x432440		488b442420		MOVQ 0x20(SP), AX	
  0x432445		488b4820		MOVQ 0x20(AX), CX	
  0x432449		90			NOPL			
			if w != nil {
  0x43244a		4885c9			TESTQ CX, CX		
  0x43244d		750b			JNE 0x43245a		
			unlock(&rw.rLock)
  0x43244f		48890424		MOVQ AX, 0(SP)		
  0x432453		e83864fdff		CALL runtime.unlock(SB)	
  0x432458		eba0			JMP 0x4323fa		
				notewakeup(&w.park)
  0x43245a		488d8148010000		LEAQ 0x148(CX), AX		
  0x432461		48890424		MOVQ AX, 0(SP)			
  0x432465		e8f664fdff		CALL runtime.notewakeup(SB)	
			unlock(&rw.rLock)
  0x43246a		488b442420		MOVQ 0x20(SP), AX	
				notewakeup(&w.park)
  0x43246f		ebde			JMP 0x43244f		
			throw("runlock of unlocked rwmutex")
  0x432471		488d0519f00300		LEAQ 0x3f019(IP), AX	
  0x432478		48890424		MOVQ AX, 0(SP)		
  0x43247c		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x432485		e8f60fffff		CALL runtime.throw(SB)	
  0x43248a		0f0b			UD2			
func (rw *rwmutex) runlock() {
  0x43248c		e8ef530100		CALL runtime.morestack_noctxt(SB)	
  0x432491		e90affffff		JMP runtime.(*rwmutex).runlock(SB)	

TEXT runtime.readyWithTime(SB) /usr/local/go/src/runtime/sema.go
func readyWithTime(s *sudog, traceskip int) {
  0x4324a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4324a9		483b6110		CMPQ 0x10(CX), SP	
  0x4324ad		7651			JBE 0x432500		
  0x4324af		4883ec18		SUBQ $0x18, SP		
  0x4324b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4324b8		488d6c2410		LEAQ 0x10(SP), BP	
	if s.releasetime != 0 {
  0x4324bd		488b442420		MOVQ 0x20(SP), AX	
  0x4324c2		4883783000		CMPQ $0x0, 0x30(AX)	
  0x4324c7		7520			JNE 0x4324e9		
	goready(s.g, traceskip)
  0x4324c9		488b00			MOVQ 0(AX), AX			
  0x4324cc		48890424		MOVQ AX, 0(SP)			
  0x4324d0		488b442428		MOVQ 0x28(SP), AX		
  0x4324d5		4889442408		MOVQ AX, 0x8(SP)		
  0x4324da		e8c12dffff		CALL runtime.goready(SB)	
}
  0x4324df		488b6c2410		MOVQ 0x10(SP), BP	
  0x4324e4		4883c418		ADDQ $0x18, SP		
  0x4324e8		c3			RET			
		s.releasetime = cputicks()
  0x4324e9		e8226b0100		CALL runtime.cputicks(SB)	
  0x4324ee		488b0424		MOVQ 0(SP), AX			
  0x4324f2		488b4c2420		MOVQ 0x20(SP), CX		
  0x4324f7		48894130		MOVQ AX, 0x30(CX)		
	goready(s.g, traceskip)
  0x4324fb		4889c8			MOVQ CX, AX		
		s.releasetime = cputicks()
  0x4324fe		ebc9			JMP 0x4324c9		
func readyWithTime(s *sudog, traceskip int) {
  0x432500		e87b530100		CALL runtime.morestack_noctxt(SB)	
  0x432505		eb99			JMP runtime.readyWithTime(SB)		

TEXT runtime.semacquire1(SB) /usr/local/go/src/runtime/sema.go
func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
  0x432510		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432519		483b6110		CMPQ 0x10(CX), SP	
  0x43251d		0f86a4020000		JBE 0x4327c7		
  0x432523		4883ec60		SUBQ $0x60, SP		
  0x432527		48896c2458		MOVQ BP, 0x58(SP)	
  0x43252c		488d6c2458		LEAQ 0x58(SP), BP	
	gp := getg()
  0x432531		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if gp != gp.m.curg {
  0x43253a		488b4830		MOVQ 0x30(AX), CX	
  0x43253e		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x432545		0f8561020000		JNE 0x4327ac		
	if cansemacquire(addr) {
  0x43254b		488b442468		MOVQ 0x68(SP), AX		
  0x432550		48890424		MOVQ AX, 0(SP)			
  0x432554		e857040000		CALL runtime.cansemacquire(SB)	
  0x432559		807c240800		CMPB $0x0, 0x8(SP)		
  0x43255e		0f853e020000		JNE 0x4327a2			
	s := acquireSudog()
  0x432564		e8a72dffff		CALL runtime.acquireSudog(SB)	
  0x432569		488b0424		MOVQ 0(SP), AX			
  0x43256d		4889442438		MOVQ AX, 0x38(SP)		
	root := semroot(addr)
  0x432572		90			NOPL			
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432573		488b4c2468		MOVQ 0x68(SP), CX	
  0x432578		4889ca			MOVQ CX, DX		
	s.releasetime = 0
  0x43257b		48c7403000000000	MOVQ $0x0, 0x30(AX)	
	s.acquiretime = 0
  0x432583		48c7402800000000	MOVQ $0x0, 0x28(AX)	
	s.ticket = 0
  0x43258b		c7403800000000		MOVL $0x0, 0x38(AX)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432592		48c1e903		SHRQ $0x3, CX		
	s := acquireSudog()
  0x432596		4889c3			MOVQ AX, BX		
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432599		48b8474140737d7f1905	MOVQ $0x5197f7d73404147, AX	
func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
  0x4325a3		4889d6			MOVQ DX, SI		
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x4325a6		48f7e1			MULQ CX			
  0x4325a9		4801ca			ADDQ CX, DX		
  0x4325ac		48d1da			RCRQ $0x1, DX		
  0x4325af		48c1ea07		SHRQ $0x7, DX		
  0x4325b3		4869c2fb000000		IMULQ $0xfb, DX, AX	
  0x4325ba		4829c1			SUBQ AX, CX		
  0x4325bd		48894c2430		MOVQ CX, 0x30(SP)	
	if profile&semaBlockProfile != 0 && blockprofilerate > 0 {
  0x4325c2		488b442478		MOVQ 0x78(SP), AX			
  0x4325c7		0fbae000		BTL $0x0, AX				
  0x4325cb		730e			JAE 0x4325db				
  0x4325cd		48833d5ba70a0000	CMPQ $0x0, runtime.blockprofilerate(SB)	
  0x4325d5		0f879d010000		JA 0x432778				
  0x4325db		31d2			XORL DX, DX				
	if profile&semaMutexProfile != 0 && mutexprofilerate > 0 {
  0x4325dd		0fbae001		BTL $0x1, AX				
  0x4325e1		7317			JAE 0x4325fa				
  0x4325e3		48833dada70a0000	CMPQ $0x0, runtime.mutexprofilerate(SB)	
  0x4325eb		760d			JBE 0x4325fa				
		if t0 == 0 {
  0x4325ed		4885d2			TESTQ DX, DX		
  0x4325f0		0f8465010000		JE 0x43275b		
		s.acquiretime = t0
  0x4325f6		48895328		MOVQ DX, 0x28(BX)	
		blockevent(s.releasetime-t0, 3)
  0x4325fa		4889542420		MOVQ DX, 0x20(SP)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x4325ff		48c1e106		SHLQ $0x6, CX			
  0x432603		48894c2428		MOVQ CX, 0x28(SP)		
  0x432608		488d05f1660900		LEAQ runtime.semtable(SB), AX	
  0x43260f		488d3c08		LEAQ 0(AX)(CX*1), DI		
  0x432613		48897c2440		MOVQ DI, 0x40(SP)		
		lock(&root.lock)
  0x432618		eb0c			JMP 0x432626			
  0x43261a		488d05df660900		LEAQ runtime.semtable(SB), AX	
  0x432621		488b4c2428		MOVQ 0x28(SP), CX		
  0x432626		488d1408		LEAQ 0(AX)(CX*1), DX		
  0x43262a		4889542450		MOVQ DX, 0x50(SP)		
  0x43262f		48891424		MOVQ DX, 0(SP)			
  0x432633		e8a860fdff		CALL runtime.lock(SB)		
		atomic.Xadd(&root.nwait, 1)
  0x432638		488b442428		MOVQ 0x28(SP), AX		
  0x43263d		488d0dbc660900		LEAQ runtime.semtable(SB), CX	
  0x432644		488d1401		LEAQ 0(CX)(AX*1), DX		
  0x432648		488d5210		LEAQ 0x10(DX), DX		
  0x43264c		4889542448		MOVQ DX, 0x48(SP)		
  0x432651		bb01000000		MOVL $0x1, BX			
  0x432656		f00fc11a		LOCK XADDL BX, 0(DX)		
		if cansemacquire(addr) {
  0x43265a		488b5c2468		MOVQ 0x68(SP), BX		
  0x43265f		48891c24		MOVQ BX, 0(SP)			
  0x432663		e848030000		CALL runtime.cansemacquire(SB)	
  0x432668		807c240800		CMPB $0x0, 0x8(SP)		
  0x43266d		0f85c5000000		JNE 0x432738			
		root.queue(addr, s, lifo)
  0x432673		488b442440		MOVQ 0x40(SP), AX			
  0x432678		48890424		MOVQ AX, 0(SP)				
  0x43267c		488b4c2468		MOVQ 0x68(SP), CX			
  0x432681		48894c2408		MOVQ CX, 0x8(SP)			
  0x432686		488b542438		MOVQ 0x38(SP), DX			
  0x43268b		4889542410		MOVQ DX, 0x10(SP)			
  0x432690		0fb65c2470		MOVZX 0x70(SP), BX			
  0x432695		885c2418		MOVB BL, 0x18(SP)			
  0x432699		e842030000		CALL runtime.(*semaRoot).queue(SB)	
		goparkunlock(&root.lock, waitReasonSemacquire, traceEvGoBlockSync, 4)
  0x43269e		90			NOPL			
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
  0x43269f		488d058a120400		LEAQ 0x4128a(IP), AX	
  0x4326a6		48890424		MOVQ AX, 0(SP)		
  0x4326aa		488b4c2450		MOVQ 0x50(SP), CX	
  0x4326af		48894c2408		MOVQ CX, 0x8(SP)	
  0x4326b4		66c74424101119		MOVW $0x1911, 0x10(SP)	
  0x4326bb		48c744241804000000	MOVQ $0x4, 0x18(SP)	
  0x4326c4		e8872affff		CALL runtime.gopark(SB)	
		if s.ticket != 0 || cansemacquire(addr) {
  0x4326c9		488b442438		MOVQ 0x38(SP), AX	
  0x4326ce		83783800		CMPL $0x0, 0x38(AX)	
  0x4326d2		744a			JE 0x43271e		
  0x4326d4		b901000000		MOVL $0x1, CX		
  0x4326d9		84c9			TESTL CL, CL		
  0x4326db		0f8439ffffff		JE 0x43261a		
	if s.releasetime > 0 {
  0x4326e1		488b4830		MOVQ 0x30(AX), CX	
  0x4326e5		4885c9			TESTQ CX, CX		
  0x4326e8		7f13			JG 0x4326fd		
	releaseSudog(s)
  0x4326ea		48890424		MOVQ AX, 0(SP)			
  0x4326ee		e8bd2fffff		CALL runtime.releaseSudog(SB)	
}
  0x4326f3		488b6c2458		MOVQ 0x58(SP), BP	
  0x4326f8		4883c460		ADDQ $0x60, SP		
  0x4326fc		c3			RET			
		blockevent(s.releasetime-t0, 3)
  0x4326fd		488b442420		MOVQ 0x20(SP), AX		
  0x432702		4829c1			SUBQ AX, CX			
  0x432705		48890c24		MOVQ CX, 0(SP)			
  0x432709		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x432712		e829d8feff		CALL runtime.blockevent(SB)	
	releaseSudog(s)
  0x432717		488b442438		MOVQ 0x38(SP), AX	
		blockevent(s.releasetime-t0, 3)
  0x43271c		ebcc			JMP 0x4326ea		
		if s.ticket != 0 || cansemacquire(addr) {
  0x43271e		488b442468		MOVQ 0x68(SP), AX		
  0x432723		48890424		MOVQ AX, 0(SP)			
  0x432727		e884020000		CALL runtime.cansemacquire(SB)	
  0x43272c		0fb64c2408		MOVZX 0x8(SP), CX		
	if s.releasetime > 0 {
  0x432731		488b442438		MOVQ 0x38(SP), AX	
		if s.ticket != 0 || cansemacquire(addr) {
  0x432736		eba1			JMP 0x4326d9		
			atomic.Xadd(&root.nwait, -1)
  0x432738		b8ffffffff		MOVL $-0x1, AX		
  0x43273d		488b4c2448		MOVQ 0x48(SP), CX	
  0x432742		f00fc101		LOCK XADDL AX, 0(CX)	
			unlock(&root.lock)
  0x432746		488b442450		MOVQ 0x50(SP), AX	
  0x43274b		48890424		MOVQ AX, 0(SP)		
  0x43274f		e83c61fdff		CALL runtime.unlock(SB)	
	if s.releasetime > 0 {
  0x432754		488b442438		MOVQ 0x38(SP), AX	
			break
  0x432759		eb86			JMP 0x4326e1		
			t0 = cputicks()
  0x43275b		e8b0680100		CALL runtime.cputicks(SB)	
  0x432760		488b1424		MOVQ 0(SP), DX			
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432764		488b4c2430		MOVQ 0x30(SP), CX	
		s.acquiretime = t0
  0x432769		488b5c2438		MOVQ 0x38(SP), BX	
		if cansemacquire(addr) {
  0x43276e		488b742468		MOVQ 0x68(SP), SI	
			t0 = cputicks()
  0x432773		e97efeffff		JMP 0x4325f6		
		t0 = cputicks()
  0x432778		e893680100		CALL runtime.cputicks(SB)	
  0x43277d		488b1424		MOVQ 0(SP), DX			
		s.releasetime = -1
  0x432781		488b5c2438		MOVQ 0x38(SP), BX	
  0x432786		48c74330ffffffff	MOVQ $-0x1, 0x30(BX)	
	if profile&semaMutexProfile != 0 && mutexprofilerate > 0 {
  0x43278e		488b442478		MOVQ 0x78(SP), AX	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432793		488b4c2430		MOVQ 0x30(SP), CX	
		if cansemacquire(addr) {
  0x432798		488b742468		MOVQ 0x68(SP), SI	
		s.releasetime = -1
  0x43279d		e93bfeffff		JMP 0x4325dd		
		return
  0x4327a2		488b6c2458		MOVQ 0x58(SP), BP	
  0x4327a7		4883c460		ADDQ $0x60, SP		
  0x4327ab		c3			RET			
		throw("semacquire not on the G stack")
  0x4327ac		488d053ef20300		LEAQ 0x3f23e(IP), AX	
  0x4327b3		48890424		MOVQ AX, 0(SP)		
  0x4327b7		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4327c0		e8bb0cffff		CALL runtime.throw(SB)	
  0x4327c5		0f0b			UD2			
func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
  0x4327c7		e8b4500100		CALL runtime.morestack_noctxt(SB)	
  0x4327cc		e93ffdffff		JMP runtime.semacquire1(SB)		

TEXT runtime.semrelease1(SB) /usr/local/go/src/runtime/sema.go
func semrelease1(addr *uint32, handoff bool) {
  0x4327e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4327e9		483b6110		CMPQ 0x10(CX), SP	
  0x4327ed		0f86ac010000		JBE 0x43299f		
  0x4327f3		4883ec50		SUBQ $0x50, SP		
  0x4327f7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4327fc		488d6c2448		LEAQ 0x48(SP), BP	
	root := semroot(addr)
  0x432801		90			NOPL			
  0x432802		488b4c2458		MOVQ 0x58(SP), CX	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432807		4889ca			MOVQ CX, DX		
	atomic.Xadd(addr, 1)
  0x43280a		bb01000000		MOVL $0x1, BX		
  0x43280f		f00fc11a		LOCK XADDL BX, 0(DX)	
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432813		48c1e903		SHRQ $0x3, CX			
  0x432817		48b8474140737d7f1905	MOVQ $0x5197f7d73404147, AX	
  0x432821		48f7e1			MULQ CX				
  0x432824		4801ca			ADDQ CX, DX			
  0x432827		48d1da			RCRQ $0x1, DX			
  0x43282a		48c1ea07		SHRQ $0x7, DX			
  0x43282e		4869d2fb000000		IMULQ $0xfb, DX, DX		
  0x432835		4829d1			SUBQ DX, CX			
  0x432838		48c1e106		SHLQ $0x6, CX			
	if atomic.Load(&root.nwait) == 0 {
  0x43283c		488d15bd640900		LEAQ runtime.semtable(SB), DX	
  0x432843		488d340a		LEAQ 0(DX)(CX*1), SI		
  0x432847		488d7610		LEAQ 0x10(SI), SI		
  0x43284b		8b3e			MOVL 0(SI), DI			
  0x43284d		85ff			TESTL DI, DI			
  0x43284f		0f8425010000		JE 0x43297a			
  0x432855		4889742440		MOVQ SI, 0x40(SP)		
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x43285a		48894c2428		MOVQ CX, 0x28(SP)	
	lock(&root.lock)
  0x43285f		488d040a		LEAQ 0(DX)(CX*1), AX	
  0x432863		4889442438		MOVQ AX, 0x38(SP)	
  0x432868		48890424		MOVQ AX, 0(SP)		
  0x43286c		e86f5efdff		CALL runtime.lock(SB)	
	if atomic.Load(&root.nwait) == 0 {
  0x432871		488b442440		MOVQ 0x40(SP), AX	
  0x432876		8b08			MOVL 0(AX), CX		
  0x432878		85c9			TESTL CX, CX		
  0x43287a		0f84e2000000		JE 0x432962		
	return &semtable[(uintptr(unsafe.Pointer(addr))>>3)%semTabSize].root
  0x432880		488b442428		MOVQ 0x28(SP), AX		
  0x432885		488d0d74640900		LEAQ runtime.semtable(SB), CX	
  0x43288c		488d0401		LEAQ 0(CX)(AX*1), AX		
	s, t0 := root.dequeue(addr)
  0x432890		48890424		MOVQ AX, 0(SP)				
  0x432894		488b442458		MOVQ 0x58(SP), AX			
  0x432899		4889442408		MOVQ AX, 0x8(SP)			
  0x43289e		e87d050000		CALL runtime.(*semaRoot).dequeue(SB)	
  0x4328a3		488b442410		MOVQ 0x10(SP), AX			
  0x4328a8		4889442430		MOVQ AX, 0x30(SP)			
  0x4328ad		488b4c2418		MOVQ 0x18(SP), CX			
  0x4328b2		48894c2420		MOVQ CX, 0x20(SP)			
	if s != nil {
  0x4328b7		4885c0			TESTQ AX, AX		
  0x4328ba		740e			JE 0x4328ca		
		atomic.Xadd(&root.nwait, -1)
  0x4328bc		baffffffff		MOVL $-0x1, DX		
  0x4328c1		488b5c2440		MOVQ 0x40(SP), BX	
  0x4328c6		f00fc113		LOCK XADDL DX, 0(BX)	
	unlock(&root.lock)
  0x4328ca		488b442438		MOVQ 0x38(SP), AX	
  0x4328cf		48890424		MOVQ AX, 0(SP)		
  0x4328d3		e8b85ffdff		CALL runtime.unlock(SB)	
	if s != nil {
  0x4328d8		488b442430		MOVQ 0x30(SP), AX	
  0x4328dd		4885c0			TESTQ AX, AX		
	if s != nil { // May be slow, so unlock first
  0x4328e0		743b			JE 0x43291d		
		acquiretime := s.acquiretime
  0x4328e2		488b4828		MOVQ 0x28(AX), CX	
		if acquiretime != 0 {
  0x4328e6		4885c9			TESTQ CX, CX		
  0x4328e9		7556			JNE 0x432941		
		if s.ticket != 0 {
  0x4328eb		83783800		CMPL $0x0, 0x38(AX)	
  0x4328ef		0f858f000000		JNE 0x432984		
func semrelease1(addr *uint32, handoff bool) {
  0x4328f5		0fb64c2460		MOVZX 0x60(SP), CX	
  0x4328fa		84c9			TESTL CL, CL		
		if handoff && cansemacquire(addr) {
  0x4328fc		7529			JNE 0x432927		
  0x4328fe		31c9			XORL CX, CX		
  0x432900		84c9			TESTL CL, CL		
  0x432902		7407			JE 0x43290b		
			s.ticket = 1
  0x432904		c7403801000000		MOVL $0x1, 0x38(AX)	
		readyWithTime(s, 5)
  0x43290b		48890424		MOVQ AX, 0(SP)			
  0x43290f		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x432918		e883fbffff		CALL runtime.readyWithTime(SB)	
  0x43291d		488b6c2448		MOVQ 0x48(SP), BP		
  0x432922		4883c450		ADDQ $0x50, SP			
  0x432926		c3			RET				
		if handoff && cansemacquire(addr) {
  0x432927		488b442458		MOVQ 0x58(SP), AX		
  0x43292c		48890424		MOVQ AX, 0(SP)			
  0x432930		e87b000000		CALL runtime.cansemacquire(SB)	
  0x432935		0fb64c2408		MOVZX 0x8(SP), CX		
			s.ticket = 1
  0x43293a		488b442430		MOVQ 0x30(SP), AX	
		if handoff && cansemacquire(addr) {
  0x43293f		ebbf			JMP 0x432900		
			mutexevent(t0-acquiretime, 3)
  0x432941		488b442420		MOVQ 0x20(SP), AX	
  0x432946		4829c8			SUBQ CX, AX		
  0x432949		48890424		MOVQ AX, 0(SP)		
  0x43294d		48c744240803000000	MOVQ $0x3, 0x8(SP)	
  0x432956		e8b5d8feff		CALL sync.event(SB)	
		if s.ticket != 0 {
  0x43295b		488b442430		MOVQ 0x30(SP), AX	
			mutexevent(t0-acquiretime, 3)
  0x432960		eb89			JMP 0x4328eb		
		unlock(&root.lock)
  0x432962		488b442438		MOVQ 0x38(SP), AX	
  0x432967		48890424		MOVQ AX, 0(SP)		
  0x43296b		e8205ffdff		CALL runtime.unlock(SB)	
		return
  0x432970		488b6c2448		MOVQ 0x48(SP), BP	
  0x432975		4883c450		ADDQ $0x50, SP		
  0x432979		c3			RET			
		return
  0x43297a		488b6c2448		MOVQ 0x48(SP), BP	
  0x43297f		4883c450		ADDQ $0x50, SP		
  0x432983		c3			RET			
			throw("corrupted semaphore ticket")
  0x432984		488d0553e80300		LEAQ 0x3e853(IP), AX	
  0x43298b		48890424		MOVQ AX, 0(SP)		
  0x43298f		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x432998		e8e30affff		CALL runtime.throw(SB)	
  0x43299d		0f0b			UD2			
func semrelease1(addr *uint32, handoff bool) {
  0x43299f		e8dc4e0100		CALL runtime.morestack_noctxt(SB)	
  0x4329a4		e937feffff		JMP runtime.semrelease1(SB)		

TEXT runtime.cansemacquire(SB) /usr/local/go/src/runtime/sema.go
	for {
  0x4329b0		488b4c2408		MOVQ 0x8(SP), CX	
		v := atomic.Load(addr)
  0x4329b5		8b11			MOVL 0(CX), DX		
		if v == 0 {
  0x4329b7		85d2			TESTL DX, DX		
  0x4329b9		7416			JE 0x4329d1		
		if atomic.Cas(addr, v, v-1) {
  0x4329bb		8d5aff			LEAL -0x1(DX), BX	
  0x4329be		89d0			MOVL DX, AX		
  0x4329c0		f00fb119		LOCK CMPXCHGL BX, 0(CX)	
  0x4329c4		0f94c2			SETE DL			
  0x4329c7		84d2			TESTL DL, DL		
  0x4329c9		74ea			JE 0x4329b5		
			return true
  0x4329cb		c644241001		MOVB $0x1, 0x10(SP)	
  0x4329d0		c3			RET			
			return false
  0x4329d1		c644241000		MOVB $0x0, 0x10(SP)	
  0x4329d6		c3			RET			

TEXT runtime.(*semaRoot).queue(SB) /usr/local/go/src/runtime/sema.go
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x4329e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4329e9		483b6110		CMPQ 0x10(CX), SP	
  0x4329ed		0f8620040000		JBE 0x432e13		
  0x4329f3		4883ec18		SUBQ $0x18, SP		
  0x4329f7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4329fc		488d6c2410		LEAQ 0x10(SP), BP	
	s.g = getg()
  0x432a01		488b442430		MOVQ 0x30(SP), AX	
  0x432a06		8400			TESTB AL, 0(AX)		
  0x432a08		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
	s.next = nil
  0x432a11		488d7810		LEAQ 0x10(AX), DI	
	s.prev = nil
  0x432a15		488d5018		LEAQ 0x18(AX), DX	
	s.g = getg()
  0x432a19		833d00a40a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432a20		0f8587030000		JNE 0x432dad				
  0x432a26		488908			MOVQ CX, 0(AX)				
	s.elem = unsafe.Pointer(addr)
  0x432a29		488b4c2428		MOVQ 0x28(SP), CX	
  0x432a2e		48894820		MOVQ CX, 0x20(AX)	
	s.prev = nil
  0x432a32		0f57c0			XORPS X0, X0		
  0x432a35		0f114010		MOVUPS X0, 0x10(AX)	
	pt := &root.treap
  0x432a39		488b5c2420		MOVQ 0x20(SP), BX	
  0x432a3e		488d7308		LEAQ 0x8(BX), SI	
	for t := *pt; t != nil; t = *pt {
  0x432a42		4c8b4308		MOVQ 0x8(BX), R8	
  0x432a46		4531c9			XORL R9, R9		
  0x432a49		eb12			JMP 0x432a5d		
  0x432a4b		4c8b11			MOVQ 0(CX), R10		
	s.parent = last
  0x432a4e		4d89c1			MOVQ R8, R9		
	for t := *pt; t != nil; t = *pt {
  0x432a51		4d89d0			MOVQ R10, R8		
		if t.elem == unsafe.Pointer(addr) {
  0x432a54		4989cb			MOVQ CX, R11		
  0x432a57		4889f1			MOVQ SI, CX		
	*pt = s
  0x432a5a		4c89de			MOVQ R11, SI		
	for t := *pt; t != nil; t = *pt {
  0x432a5d		4d85c0			TESTQ R8, R8		
  0x432a60		0f846d020000		JE 0x432cd3		
		if t.elem == unsafe.Pointer(addr) {
  0x432a66		4d8b4820		MOVQ 0x20(R8), R9	
  0x432a6a		4c39c9			CMPQ R9, CX		
  0x432a6d		7414			JE 0x432a83		
		if uintptr(unsafe.Pointer(addr)) < uintptr(t.elem) {
  0x432a6f		4889ce			MOVQ CX, SI		
  0x432a72		4c39c9			CMPQ R9, CX		
  0x432a75		7306			JAE 0x432a7d		
			pt = &t.prev
  0x432a77		498d4818		LEAQ 0x18(R8), CX	
  0x432a7b		ebce			JMP 0x432a4b		
			pt = &t.next
  0x432a7d		498d4810		LEAQ 0x10(R8), CX	
  0x432a81		ebc8			JMP 0x432a4b		
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432a83		0fb64c2438		MOVZX 0x38(SP), CX	
  0x432a88		84c9			TESTL CL, CL		
			if lifo {
  0x432a8a		0f84d5010000		JE 0x432c65		
				*pt = s
  0x432a90		833d89a30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432a97		0f85b5010000		JNE 0x432c52				
  0x432a9d		488906			MOVQ AX, 0(SI)				
				s.ticket = t.ticket
  0x432aa0		418b4838		MOVL 0x38(R8), CX	
  0x432aa4		894838			MOVL CX, 0x38(AX)	
				s.acquiretime = t.acquiretime
  0x432aa7		498b4828		MOVQ 0x28(R8), CX	
  0x432aab		48894828		MOVQ CX, 0x28(AX)	
				s.parent = t.parent
  0x432aaf		498b4840		MOVQ 0x40(R8), CX			
  0x432ab3		833d66a30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432aba		0f8572010000		JNE 0x432c32				
  0x432ac0		48894840		MOVQ CX, 0x40(AX)			
				s.prev = t.prev
  0x432ac4		498b4818		MOVQ 0x18(R8), CX			
  0x432ac8		833d51a30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432acf		0f8541010000		JNE 0x432c16				
  0x432ad5		48894818		MOVQ CX, 0x18(AX)			
				s.next = t.next
  0x432ad9		498b5010		MOVQ 0x10(R8), DX			
  0x432add		833d3ca30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432ae4		0f8519010000		JNE 0x432c03				
  0x432aea		48895010		MOVQ DX, 0x10(AX)			
				if s.prev != nil {
  0x432aee		4885c9			TESTQ CX, CX		
  0x432af1		7411			JE 0x432b04		
					s.prev.parent = s
  0x432af3		833d26a30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432afa		0f85f5000000		JNE 0x432bf5				
  0x432b00		48894140		MOVQ AX, 0x40(CX)			
				if s.next != nil {
  0x432b04		488b4810		MOVQ 0x10(AX), CX	
  0x432b08		4885c9			TESTQ CX, CX		
  0x432b0b		7411			JE 0x432b1e		
					s.next.parent = s
  0x432b0d		833d0ca30a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432b14		0f85cd000000		JNE 0x432be7				
  0x432b1a		48894140		MOVQ AX, 0x40(CX)			
				s.waitlink = t
  0x432b1e		833dfba20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432b25		0f85a5000000		JNE 0x432bd0				
  0x432b2b		4c894048		MOVQ R8, 0x48(AX)			
				s.waittail = t.waittail
  0x432b2f		488d7850		LEAQ 0x50(AX), DI			
  0x432b33		498b4850		MOVQ 0x50(R8), CX			
  0x432b37		833de2a20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432b3e		757d			JNE 0x432bbd				
  0x432b40		48894850		MOVQ CX, 0x50(AX)			
				if s.waittail == nil {
  0x432b44		4885c9			TESTQ CX, CX		
  0x432b47		745b			JE 0x432ba4		
				t.parent = nil
  0x432b49		833dd0a20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432b50		752a			JNE 0x432b7c				
  0x432b52		49c7404000000000	MOVQ $0x0, 0x40(R8)			
				t.prev = nil
  0x432b5a		49c7401800000000	MOVQ $0x0, 0x18(R8)	
				t.next = nil
  0x432b62		49c7401000000000	MOVQ $0x0, 0x10(R8)	
				t.waittail = nil
  0x432b6a		49c7405000000000	MOVQ $0x0, 0x50(R8)	
			return
  0x432b72		488b6c2410		MOVQ 0x10(SP), BP	
  0x432b77		4883c418		ADDQ $0x18, SP		
  0x432b7b		c3			RET			
				s.parent = t.parent
  0x432b7c		498d7840		LEAQ 0x40(R8), DI	
				t.parent = nil
  0x432b80		31c0			XORL AX, AX			
  0x432b82		e8f96a0100		CALL runtime.gcWriteBarrier(SB)	
				s.prev = t.prev
  0x432b87		498d7818		LEAQ 0x18(R8), DI	
				t.prev = nil
  0x432b8b		e8f06a0100		CALL runtime.gcWriteBarrier(SB)	
				s.next = t.next
  0x432b90		498d7810		LEAQ 0x10(R8), DI	
				t.next = nil
  0x432b94		e8e76a0100		CALL runtime.gcWriteBarrier(SB)	
				s.waittail = t.waittail
  0x432b99		498d7850		LEAQ 0x50(R8), DI	
				t.waittail = nil
  0x432b9d		e8de6a0100		CALL runtime.gcWriteBarrier(SB)	
				t.parent = nil
  0x432ba2		ebce			JMP 0x432b72		
					s.waittail = t
  0x432ba4		833d75a20a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432bab		7506			JNE 0x432bb3				
  0x432bad		4c894050		MOVQ R8, 0x50(AX)			
  0x432bb1		eb96			JMP 0x432b49				
  0x432bb3		4c89c0			MOVQ R8, AX				
  0x432bb6		e8c56a0100		CALL runtime.gcWriteBarrier(SB)		
  0x432bbb		eb8c			JMP 0x432b49				
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432bbd		4889c2			MOVQ AX, DX		
				s.waittail = t.waittail
  0x432bc0		4889c8			MOVQ CX, AX			
  0x432bc3		e8b86a0100		CALL runtime.gcWriteBarrier(SB)	
					s.waittail = t
  0x432bc8		4889d0			MOVQ DX, AX		
				s.waittail = t.waittail
  0x432bcb		e974ffffff		JMP 0x432b44		
				s.waitlink = t
  0x432bd0		488d7848		LEAQ 0x48(AX), DI	
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432bd4		4889c1			MOVQ AX, CX		
				s.waitlink = t
  0x432bd7		4c89c0			MOVQ R8, AX			
  0x432bda		e8a16a0100		CALL runtime.gcWriteBarrier(SB)	
				s.waittail = t.waittail
  0x432bdf		4889c8			MOVQ CX, AX		
				s.waitlink = t
  0x432be2		e948ffffff		JMP 0x432b2f		
					s.next.parent = s
  0x432be7		488d7940		LEAQ 0x40(CX), DI		
  0x432beb		e8906a0100		CALL runtime.gcWriteBarrier(SB)	
  0x432bf0		e929ffffff		JMP 0x432b1e			
					s.prev.parent = s
  0x432bf5		488d7940		LEAQ 0x40(CX), DI		
  0x432bf9		e8826a0100		CALL runtime.gcWriteBarrier(SB)	
  0x432bfe		e901ffffff		JMP 0x432b04			
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432c03		4889c3			MOVQ AX, BX		
				s.next = t.next
  0x432c06		4889d0			MOVQ DX, AX			
  0x432c09		e8726a0100		CALL runtime.gcWriteBarrier(SB)	
					s.prev.parent = s
  0x432c0e		4889d8			MOVQ BX, AX		
				s.next = t.next
  0x432c11		e9d8feffff		JMP 0x432aee		
	s.next = nil
  0x432c16		4889fb			MOVQ DI, BX		
				s.prev = t.prev
  0x432c19		4889d7			MOVQ DX, DI		
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432c1c		4889c6			MOVQ AX, SI		
				s.prev = t.prev
  0x432c1f		4889c8			MOVQ CX, AX			
  0x432c22		e8596a0100		CALL runtime.gcWriteBarrier(SB)	
				s.next = t.next
  0x432c27		4889f0			MOVQ SI, AX		
  0x432c2a		4889df			MOVQ BX, DI		
				s.prev = t.prev
  0x432c2d		e9a7feffff		JMP 0x432ad9		
				s.parent = t.parent
  0x432c32		488d5840		LEAQ 0x40(AX), BX	
	s.next = nil
  0x432c36		4889fe			MOVQ DI, SI		
				s.parent = t.parent
  0x432c39		4889df			MOVQ BX, DI		
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432c3c		4989c1			MOVQ AX, R9		
				s.parent = t.parent
  0x432c3f		4889c8			MOVQ CX, AX			
  0x432c42		e8396a0100		CALL runtime.gcWriteBarrier(SB)	
				s.prev = t.prev
  0x432c47		4c89c8			MOVQ R9, AX		
				s.next = t.next
  0x432c4a		4889f7			MOVQ SI, DI		
				s.parent = t.parent
  0x432c4d		e972feffff		JMP 0x432ac4		
	s.next = nil
  0x432c52		4889f9			MOVQ DI, CX		
				*pt = s
  0x432c55		4889f7			MOVQ SI, DI			
  0x432c58		e8236a0100		CALL runtime.gcWriteBarrier(SB)	
				s.next = t.next
  0x432c5d		4889cf			MOVQ CX, DI		
				*pt = s
  0x432c60		e93bfeffff		JMP 0x432aa0		
				if t.waittail == nil {
  0x432c65		498b4850		MOVQ 0x50(R8), CX	
  0x432c69		4885c9			TESTQ CX, CX		
  0x432c6c		744b			JE 0x432cb9		
					t.waittail.waitlink = s
  0x432c6e		833daba10a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432c75		7537			JNE 0x432cae				
  0x432c77		48894148		MOVQ AX, 0x48(CX)			
				t.waittail = s
  0x432c7b		833d9ea10a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432c82		7511			JNE 0x432c95				
  0x432c84		49894050		MOVQ AX, 0x50(R8)			
				s.waitlink = nil
  0x432c88		48c7404800000000	MOVQ $0x0, 0x48(AX)	
				t.waittail = s
  0x432c90		e9ddfeffff		JMP 0x432b72		
				if t.waittail == nil {
  0x432c95		498d7850		LEAQ 0x50(R8), DI	
				t.waittail = s
  0x432c99		e8e2690100		CALL runtime.gcWriteBarrier(SB)	
				s.waitlink = nil
  0x432c9e		488d7848		LEAQ 0x48(AX), DI		
  0x432ca2		31c0			XORL AX, AX			
  0x432ca4		e8d7690100		CALL runtime.gcWriteBarrier(SB)	
				t.waittail = s
  0x432ca9		e9c4feffff		JMP 0x432b72		
					t.waittail.waitlink = s
  0x432cae		488d7948		LEAQ 0x48(CX), DI		
  0x432cb2		e8c9690100		CALL runtime.gcWriteBarrier(SB)	
  0x432cb7		ebc2			JMP 0x432c7b			
					t.waitlink = s
  0x432cb9		833d60a10a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432cc0		7506			JNE 0x432cc8				
  0x432cc2		49894048		MOVQ AX, 0x48(R8)			
  0x432cc6		ebb3			JMP 0x432c7b				
  0x432cc8		498d7848		LEAQ 0x48(R8), DI			
  0x432ccc		e8af690100		CALL runtime.gcWriteBarrier(SB)		
  0x432cd1		eba8			JMP 0x432c7b				
	mp := getg().m
  0x432cd3		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432cdc		488b4930		MOVQ 0x30(CX), CX	
	s.ticket = fastrand() | 1
  0x432ce0		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x432ce1		8b9120010000		MOVL 0x120(CX), DX	
  0x432ce7		448b8124010000		MOVL 0x124(CX), R8	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x432cee		44898120010000		MOVL R8, 0x120(CX)	
	s1 ^= s1 << 17
  0x432cf5		4189d2			MOVL DX, R10		
  0x432cf8		c1e211			SHLL $0x11, DX		
  0x432cfb		4131d2			XORL DX, R10		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x432cfe		4489c2			MOVL R8, DX		
  0x432d01		4531d0			XORL R10, R8		
  0x432d04		41c1ea07		SHRL $0x7, R10		
  0x432d08		4531c2			XORL R8, R10		
  0x432d0b		4189d0			MOVL DX, R8		
  0x432d0e		c1ea10			SHRL $0x10, DX		
  0x432d11		4431d2			XORL R10, DX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x432d14		899124010000		MOVL DX, 0x124(CX)	
	return s0 + s1
  0x432d1a		418d0c10		LEAL 0(R8)(DX*1), CX	
	s.ticket = fastrand() | 1
  0x432d1e		83c901			ORL $0x1, CX		
  0x432d21		894838			MOVL CX, 0x38(AX)	
	s.parent = last
  0x432d24		833df5a00a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432d2b		7564			JNE 0x432d91				
  0x432d2d		4c894840		MOVQ R9, 0x40(AX)			
	*pt = s
  0x432d31		488906			MOVQ AX, 0(SI)		
	for s.parent != nil && s.parent.ticket > s.ticket {
  0x432d34		eb10			JMP 0x432d46		
  0x432d36		488b4c2430		MOVQ 0x30(SP), CX	
  0x432d3b		488b542420		MOVQ 0x20(SP), DX	
  0x432d40		4889c8			MOVQ CX, AX		
			root.rotateLeft(s.parent)
  0x432d43		4889d3			MOVQ DX, BX		
	for s.parent != nil && s.parent.ticket > s.ticket {
  0x432d46		488b4840		MOVQ 0x40(AX), CX	
  0x432d4a		4885c9			TESTQ CX, CX		
  0x432d4d		7438			JE 0x432d87		
  0x432d4f		8b5038			MOVL 0x38(AX), DX	
  0x432d52		395138			CMPL DX, 0x38(CX)	
  0x432d55		7630			JBE 0x432d87		
		if s.parent.prev == s {
  0x432d57		48394118		CMPQ AX, 0x18(CX)	
  0x432d5b		741a			JE 0x432d77		
			if s.parent.next != s {
  0x432d5d		48394110		CMPQ AX, 0x10(CX)	
  0x432d61		0f858e000000		JNE 0x432df5		
			root.rotateLeft(s.parent)
  0x432d67		48891c24		MOVQ BX, 0(SP)				
  0x432d6b		48894c2408		MOVQ CX, 0x8(SP)			
  0x432d70		e83b040000		CALL runtime.(*semaRoot).rotateLeft(SB)	
  0x432d75		ebbf			JMP 0x432d36				
			root.rotateRight(s.parent)
  0x432d77		48891c24		MOVQ BX, 0(SP)					
  0x432d7b		48894c2408		MOVQ CX, 0x8(SP)				
  0x432d80		e83b060000		CALL runtime.(*semaRoot).rotateRight(SB)	
  0x432d85		ebaf			JMP 0x432d36					
  0x432d87		488b6c2410		MOVQ 0x10(SP), BP				
  0x432d8c		4883c418		ADDQ $0x18, SP					
  0x432d90		c3			RET						
	s.parent = last
  0x432d91		488d7840		LEAQ 0x40(AX), DI	
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432d95		4889c1			MOVQ AX, CX		
	s.parent = last
  0x432d98		4c89c8			MOVQ R9, AX			
  0x432d9b		e8e0680100		CALL runtime.gcWriteBarrier(SB)	
	*pt = s
  0x432da0		4889f7			MOVQ SI, DI			
  0x432da3		4889c8			MOVQ CX, AX			
  0x432da6		e8d5680100		CALL runtime.gcWriteBarrier(SB)	
	s.parent = last
  0x432dab		eb99			JMP 0x432d46		
	s.next = nil
  0x432dad		4889fb			MOVQ DI, BX		
	s.g = getg()
  0x432db0		4889c7			MOVQ AX, DI			
  0x432db3		4889c8			MOVQ CX, AX			
  0x432db6		e8c5680100		CALL runtime.gcWriteBarrier(SB)	
	s.elem = unsafe.Pointer(addr)
  0x432dbb		488d7720		LEAQ 0x20(DI), SI	
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432dbf		4889f8			MOVQ DI, AX		
	s.elem = unsafe.Pointer(addr)
  0x432dc2		4889f7			MOVQ SI, DI		
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432dc5		4889c1			MOVQ AX, CX		
	s.elem = unsafe.Pointer(addr)
  0x432dc8		488b442428		MOVQ 0x28(SP), AX		
  0x432dcd		e8ae680100		CALL runtime.gcWriteBarrier(SB)	
	s.next = nil
  0x432dd2		4889df			MOVQ BX, DI		
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432dd5		4889c6			MOVQ AX, SI		
	s.next = nil
  0x432dd8		31c0			XORL AX, AX			
  0x432dda		e8a1680100		CALL runtime.gcWriteBarrier(SB)	
	s.prev = nil
  0x432ddf		4889d7			MOVQ DX, DI			
  0x432de2		e899680100		CALL runtime.gcWriteBarrier(SB)	
				*pt = s
  0x432de7		4889c8			MOVQ CX, AX		
		if t.elem == unsafe.Pointer(addr) {
  0x432dea		4889f1			MOVQ SI, CX		
				s.next = t.next
  0x432ded		4889df			MOVQ BX, DI		
	s.g = getg()
  0x432df0		e944fcffff		JMP 0x432a39		
				panic("semaRoot queue")
  0x432df5		488d05c4830200		LEAQ 0x283c4(IP), AX			
  0x432dfc		48890424		MOVQ AX, 0(SP)				
  0x432e00		488d05b9a10400		LEAQ runtime.statictmp_25(SB), AX	
  0x432e07		4889442408		MOVQ AX, 0x8(SP)			
  0x432e0c		e89f00ffff		CALL runtime.gopanic(SB)		
  0x432e11		0f0b			UD2					
func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) {
  0x432e13		e8684a0100		CALL runtime.morestack_noctxt(SB)	
  0x432e18		e9c3fbffff		JMP runtime.(*semaRoot).queue(SB)	

TEXT runtime.(*semaRoot).dequeue(SB) /usr/local/go/src/runtime/sema.go
func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64) {
  0x432e20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x432e29		483b6110		CMPQ 0x10(CX), SP	
  0x432e2d		0f8664030000		JBE 0x433197		
  0x432e33		4883ec38		SUBQ $0x38, SP		
  0x432e37		48896c2430		MOVQ BP, 0x30(SP)	
  0x432e3c		488d6c2430		LEAQ 0x30(SP), BP	
	ps := &root.treap
  0x432e41		488b4c2440		MOVQ 0x40(SP), CX	
  0x432e46		488d7908		LEAQ 0x8(CX), DI	
	s := *ps
  0x432e4a		488b5108		MOVQ 0x8(CX), DX	
	for ; s != nil; s = *ps {
  0x432e4e		488b5c2448		MOVQ 0x48(SP), BX	
	ps := &root.treap
  0x432e53		4889f8			MOVQ DI, AX		
	for ; s != nil; s = *ps {
  0x432e56		eb0c			JMP 0x432e64		
  0x432e58		488b32			MOVQ 0(DX), SI		
		if s.elem == unsafe.Pointer(addr) {
  0x432e5b		4c89c3			MOVQ R8, BX		
		*ps = t
  0x432e5e		4889d7			MOVQ DX, DI		
	for ; s != nil; s = *ps {
  0x432e61		4889f2			MOVQ SI, DX		
  0x432e64		4885d2			TESTQ DX, DX		
  0x432e67		0f840e030000		JE 0x43317b		
		if s.elem == unsafe.Pointer(addr) {
  0x432e6d		488b7220		MOVQ 0x20(DX), SI	
  0x432e71		4839f3			CMPQ SI, BX		
  0x432e74		7414			JE 0x432e8a		
		if uintptr(unsafe.Pointer(addr)) < uintptr(s.elem) {
  0x432e76		4989d8			MOVQ BX, R8		
  0x432e79		4839f3			CMPQ SI, BX		
  0x432e7c		7306			JAE 0x432e84		
			ps = &s.prev
  0x432e7e		4883c218		ADDQ $0x18, DX		
  0x432e82		ebd4			JMP 0x432e58		
			ps = &s.next
  0x432e84		4883c210		ADDQ $0x10, DX		
  0x432e88		ebce			JMP 0x432e58		
	ps := &root.treap
  0x432e8a		4889442428		MOVQ AX, 0x28(SP)	
	for ; s != nil; s = *ps {
  0x432e8f		4889542418		MOVQ DX, 0x18(SP)	
	if s.acquiretime != 0 {
  0x432e94		48837a2800		CMPQ $0x0, 0x28(DX)	
  0x432e99		0f85b5020000		JNE 0x433154		
  0x432e9f		31db			XORL BX, BX		
	if t := s.waitlink; t != nil {
  0x432ea1		488b7248		MOVQ 0x48(DX), SI	
  0x432ea5		4885f6			TESTQ SI, SI		
  0x432ea8		0f855b010000		JNE 0x433009		
		t.acquiretime = now
  0x432eae		48895c2410		MOVQ BX, 0x10(SP)	
		for s.next != nil || s.prev != nil {
  0x432eb3		eb1a			JMP 0x432ecf		
  0x432eb5		488b742418		MOVQ 0x18(SP), SI	
  0x432eba		4c8b442440		MOVQ 0x40(SP), R8	
			root.treap = nil
  0x432ebf		488b442428		MOVQ 0x28(SP), AX	
				root.rotateRight(s)
  0x432ec4		4c89c1			MOVQ R8, CX		
		for s.next != nil || s.prev != nil {
  0x432ec7		4889f2			MOVQ SI, DX		
	return s, now
  0x432eca		488b5c2410		MOVQ 0x10(SP), BX	
		for s.next != nil || s.prev != nil {
  0x432ecf		488b7210		MOVQ 0x10(DX), SI	
  0x432ed3		4885f6			TESTQ SI, SI		
  0x432ed6		743e			JE 0x432f16		
			if s.next == nil || s.prev != nil && s.prev.ticket < s.next.ticket {
  0x432ed8		7418			JE 0x432ef2		
  0x432eda		488b7a18		MOVQ 0x18(DX), DI	
  0x432ede		4885ff			TESTQ DI, DI		
  0x432ee1		742f			JE 0x432f12		
  0x432ee3		8b7638			MOVL 0x38(SI), SI	
  0x432ee6		397738			CMPL SI, 0x38(DI)	
  0x432ee9		400f92c6		SETB SI			
  0x432eed		4084f6			TESTL SI, SI		
  0x432ef0		7410			JE 0x432f02		
				root.rotateRight(s)
  0x432ef2		48890c24		MOVQ CX, 0(SP)					
  0x432ef6		4889542408		MOVQ DX, 0x8(SP)				
  0x432efb		e8c0040000		CALL runtime.(*semaRoot).rotateRight(SB)	
  0x432f00		ebb3			JMP 0x432eb5					
				root.rotateLeft(s)
  0x432f02		48890c24		MOVQ CX, 0(SP)				
  0x432f06		4889542408		MOVQ DX, 0x8(SP)			
  0x432f0b		e8a0020000		CALL runtime.(*semaRoot).rotateLeft(SB)	
  0x432f10		eba3			JMP 0x432eb5				
  0x432f12		31f6			XORL SI, SI				
			if s.next == nil || s.prev != nil && s.prev.ticket < s.next.ticket {
  0x432f14		ebd7			JMP 0x432eed		
		for s.next != nil || s.prev != nil {
  0x432f16		48837a1800		CMPQ $0x0, 0x18(DX)	
  0x432f1b		7405			JE 0x432f22		
  0x432f1d		4885f6			TESTQ SI, SI		
  0x432f20		ebb6			JMP 0x432ed8		
		if s.parent != nil {
  0x432f22		488b7240		MOVQ 0x40(DX), SI	
  0x432f26		4885f6			TESTQ SI, SI		
  0x432f29		0f84b5000000		JE 0x432fe4		
			if s.parent.prev == s {
  0x432f2f		48395618		CMPQ DX, 0x18(SI)	
  0x432f33		0f8585000000		JNE 0x432fbe		
				s.parent.prev = nil
  0x432f39		833de09e0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432f40		756f			JNE 0x432fb1				
  0x432f42		48c7461800000000	MOVQ $0x0, 0x18(SI)			
	s.parent = nil
  0x432f4a		833dcf9e0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432f51		7532			JNE 0x432f85				
  0x432f53		48c7424000000000	MOVQ $0x0, 0x40(DX)			
	s.elem = nil
  0x432f5b		48c7422000000000	MOVQ $0x0, 0x20(DX)	
	s.prev = nil
  0x432f63		0f57c0			XORPS X0, X0		
  0x432f66		0f114210		MOVUPS X0, 0x10(DX)	
	s.ticket = 0
  0x432f6a		c7423800000000		MOVL $0x0, 0x38(DX)	
	return s, now
  0x432f71		4889542450		MOVQ DX, 0x50(SP)	
  0x432f76		48895c2458		MOVQ BX, 0x58(SP)	
  0x432f7b		488b6c2430		MOVQ 0x30(SP), BP	
  0x432f80		4883c438		ADDQ $0x38, SP		
  0x432f84		c3			RET			
	s.parent = nil
  0x432f85		488d7a40		LEAQ 0x40(DX), DI		
  0x432f89		31c0			XORL AX, AX			
  0x432f8b		e8f0660100		CALL runtime.gcWriteBarrier(SB)	
		if s.elem == unsafe.Pointer(addr) {
  0x432f90		488d7a20		LEAQ 0x20(DX), DI	
	s.elem = nil
  0x432f94		31c0			XORL AX, AX			
  0x432f96		e8e5660100		CALL runtime.gcWriteBarrier(SB)	
	s.next = nil
  0x432f9b		488d7a10		LEAQ 0x10(DX), DI		
  0x432f9f		31c0			XORL AX, AX			
  0x432fa1		e8da660100		CALL runtime.gcWriteBarrier(SB)	
	s.prev = nil
  0x432fa6		488d7a18		LEAQ 0x18(DX), DI		
  0x432faa		e8d1660100		CALL runtime.gcWriteBarrier(SB)	
	s.parent = nil
  0x432faf		ebb9			JMP 0x432f6a		
			if s.parent.prev == s {
  0x432fb1		488d7e18		LEAQ 0x18(SI), DI	
				s.parent.prev = nil
  0x432fb5		31c0			XORL AX, AX			
  0x432fb7		e8c4660100		CALL runtime.gcWriteBarrier(SB)	
  0x432fbc		eb8c			JMP 0x432f4a			
				s.parent.next = nil
  0x432fbe		833d5b9e0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432fc5		750d			JNE 0x432fd4				
  0x432fc7		48c7461000000000	MOVQ $0x0, 0x10(SI)			
  0x432fcf		e976ffffff		JMP 0x432f4a				
  0x432fd4		488d7e10		LEAQ 0x10(SI), DI			
  0x432fd8		31c0			XORL AX, AX				
  0x432fda		e8a1660100		CALL runtime.gcWriteBarrier(SB)		
  0x432fdf		e966ffffff		JMP 0x432f4a				
			root.treap = nil
  0x432fe4		833d359e0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x432feb		750d			JNE 0x432ffa				
  0x432fed		48c7410800000000	MOVQ $0x0, 0x8(CX)			
  0x432ff5		e950ffffff		JMP 0x432f4a				
  0x432ffa		4889c7			MOVQ AX, DI				
  0x432ffd		31c0			XORL AX, AX				
  0x432fff		e87c660100		CALL runtime.gcWriteBarrier(SB)		
  0x433004		e941ffffff		JMP 0x432f4a				
		*ps = t
  0x433009		833d109e0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433010		0f8531010000		JNE 0x433147				
  0x433016		488937			MOVQ SI, 0(DI)				
		t.ticket = s.ticket
  0x433019		8b4a38			MOVL 0x38(DX), CX	
  0x43301c		894e38			MOVL CX, 0x38(SI)	
		t.parent = s.parent
  0x43301f		488b4240		MOVQ 0x40(DX), AX			
  0x433023		833df69d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43302a		0f8509010000		JNE 0x433139				
  0x433030		48894640		MOVQ AX, 0x40(SI)			
		t.prev = s.prev
  0x433034		488b4218		MOVQ 0x18(DX), AX			
  0x433038		833de19d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43303f		0f85e6000000		JNE 0x43312b				
  0x433045		48894618		MOVQ AX, 0x18(SI)			
		if t.prev != nil {
  0x433049		4885c0			TESTQ AX, AX		
  0x43304c		7411			JE 0x43305f		
			t.prev.parent = t
  0x43304e		833dcb9d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433055		0f85bf000000		JNE 0x43311a				
  0x43305b		48897040		MOVQ SI, 0x40(AX)			
		t.next = s.next
  0x43305f		488b4210		MOVQ 0x10(DX), AX			
  0x433063		833db69d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43306a		0f859c000000		JNE 0x43310c				
  0x433070		48894610		MOVQ AX, 0x10(SI)			
		if t.next != nil {
  0x433074		4885c0			TESTQ AX, AX		
  0x433077		740d			JE 0x433086		
			t.next.parent = t
  0x433079		833da09d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433080		7579			JNE 0x4330fb				
  0x433082		48897040		MOVQ SI, 0x40(AX)			
		if t.waitlink != nil {
  0x433086		48837e4800		CMPQ $0x0, 0x48(SI)	
  0x43308b		744e			JE 0x4330db		
			t.waittail = s.waittail
  0x43308d		488b4250		MOVQ 0x50(DX), AX			
  0x433091		833d889d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433098		7536			JNE 0x4330d0				
  0x43309a		48894650		MOVQ AX, 0x50(SI)			
		t.acquiretime = now
  0x43309e		48895e28		MOVQ BX, 0x28(SI)	
		s.waitlink = nil
  0x4330a2		833d779d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4330a9		750c			JNE 0x4330b7				
		s.waittail = nil
  0x4330ab		0f57c0			XORPS X0, X0		
  0x4330ae		0f114248		MOVUPS X0, 0x48(DX)	
		s.waitlink = nil
  0x4330b2		e993feffff		JMP 0x432f4a		
	if t := s.waitlink; t != nil {
  0x4330b7		488d7a48		LEAQ 0x48(DX), DI	
		s.waitlink = nil
  0x4330bb		31c0			XORL AX, AX			
  0x4330bd		e8be650100		CALL runtime.gcWriteBarrier(SB)	
		s.waittail = nil
  0x4330c2		488d7a50		LEAQ 0x50(DX), DI		
  0x4330c6		e8b5650100		CALL runtime.gcWriteBarrier(SB)	
		s.waitlink = nil
  0x4330cb		e97afeffff		JMP 0x432f4a		
			t.waittail = s.waittail
  0x4330d0		488d7e50		LEAQ 0x50(SI), DI		
  0x4330d4		e8a7650100		CALL runtime.gcWriteBarrier(SB)	
  0x4330d9		ebc3			JMP 0x43309e			
			t.waittail = nil
  0x4330db		833d3e9d0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4330e2		750a			JNE 0x4330ee				
  0x4330e4		48c7465000000000	MOVQ $0x0, 0x50(SI)			
  0x4330ec		ebb0			JMP 0x43309e				
  0x4330ee		488d7e50		LEAQ 0x50(SI), DI			
  0x4330f2		31c0			XORL AX, AX				
  0x4330f4		e887650100		CALL runtime.gcWriteBarrier(SB)		
  0x4330f9		eba3			JMP 0x43309e				
			t.next.parent = t
  0x4330fb		488d7840		LEAQ 0x40(AX), DI		
  0x4330ff		4889f0			MOVQ SI, AX			
  0x433102		e879650100		CALL runtime.gcWriteBarrier(SB)	
  0x433107		e97affffff		JMP 0x433086			
		t.next = s.next
  0x43310c		488d7e10		LEAQ 0x10(SI), DI		
  0x433110		e86b650100		CALL runtime.gcWriteBarrier(SB)	
  0x433115		e95affffff		JMP 0x433074			
			t.prev.parent = t
  0x43311a		488d7840		LEAQ 0x40(AX), DI		
  0x43311e		4889f0			MOVQ SI, AX			
  0x433121		e85a650100		CALL runtime.gcWriteBarrier(SB)	
  0x433126		e934ffffff		JMP 0x43305f			
		t.prev = s.prev
  0x43312b		488d7e18		LEAQ 0x18(SI), DI		
  0x43312f		e84c650100		CALL runtime.gcWriteBarrier(SB)	
  0x433134		e910ffffff		JMP 0x433049			
		t.parent = s.parent
  0x433139		488d7e40		LEAQ 0x40(SI), DI		
  0x43313d		e83e650100		CALL runtime.gcWriteBarrier(SB)	
  0x433142		e9edfeffff		JMP 0x433034			
		*ps = t
  0x433147		4889f0			MOVQ SI, AX			
  0x43314a		e831650100		CALL runtime.gcWriteBarrier(SB)	
  0x43314f		e9c5feffff		JMP 0x433019			
  0x433154		48897c2420		MOVQ DI, 0x20(SP)		
		now = cputicks()
  0x433159		e8b25e0100		CALL runtime.cputicks(SB)	
  0x43315e		488b1c24		MOVQ 0(SP), BX			
			root.treap = nil
  0x433162		488b442428		MOVQ 0x28(SP), AX	
				root.rotateRight(s)
  0x433167		488b4c2440		MOVQ 0x40(SP), CX	
	if t := s.waitlink; t != nil {
  0x43316c		488b542418		MOVQ 0x18(SP), DX	
		*ps = t
  0x433171		488b7c2420		MOVQ 0x20(SP), DI	
		now = cputicks()
  0x433176		e926fdffff		JMP 0x432ea1		
	return nil, 0
  0x43317b		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x433184		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x43318d		488b6c2430		MOVQ 0x30(SP), BP	
  0x433192		4883c438		ADDQ $0x38, SP		
  0x433196		c3			RET			
func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64) {
  0x433197		e8e4460100		CALL runtime.morestack_noctxt(SB)	
  0x43319c		e97ffcffff		JMP runtime.(*semaRoot).dequeue(SB)	

TEXT runtime.(*semaRoot).rotateLeft(SB) /usr/local/go/src/runtime/sema.go
func (root *semaRoot) rotateLeft(x *sudog) {
  0x4331b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4331b9		483b6110		CMPQ 0x10(CX), SP	
  0x4331bd		0f86eb010000		JBE 0x4333ae		
  0x4331c3		4883ec18		SUBQ $0x18, SP		
  0x4331c7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4331cc		488d6c2410		LEAQ 0x10(SP), BP	
	a, y := x.prev, x.next
  0x4331d1		488b442428		MOVQ 0x28(SP), AX	
  0x4331d6		488b4810		MOVQ 0x10(AX), CX	
	p := x.parent
  0x4331da		488b5040		MOVQ 0x40(AX), DX	
	a, y := x.prev, x.next
  0x4331de		488b5818		MOVQ 0x18(AX), BX	
	b, c := y.prev, y.next
  0x4331e2		488b7118		MOVQ 0x18(CX), SI	
  0x4331e6		4c8b4110		MOVQ 0x10(CX), R8	
	y.prev = x
  0x4331ea		833d2f9c0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4331f1		0f8570010000		JNE 0x433367				
  0x4331f7		48894118		MOVQ AX, 0x18(CX)			
	x.parent = y
  0x4331fb		48894840		MOVQ CX, 0x40(AX)	
	y.next = c
  0x4331ff		4c894110		MOVQ R8, 0x10(CX)	
	if c != nil {
  0x433203		4d85c0			TESTQ R8, R8		
  0x433206		7411			JE 0x433219		
		c.parent = y
  0x433208		833d119c0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43320f		0f853b010000		JNE 0x433350				
  0x433215		49894840		MOVQ CX, 0x40(R8)			
	x.prev = a
  0x433219		833d009c0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433220		0f8513010000		JNE 0x433339				
  0x433226		48895818		MOVQ BX, 0x18(AX)			
	if a != nil {
  0x43322a		4885db			TESTQ BX, BX		
  0x43322d		7411			JE 0x433240		
		a.parent = x
  0x43322f		833dea9b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433236		0f85ef000000		JNE 0x43332b				
  0x43323c		48894340		MOVQ AX, 0x40(BX)			
	x.next = b
  0x433240		833dd99b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433247		0f85c7000000		JNE 0x433314				
  0x43324d		48897010		MOVQ SI, 0x10(AX)			
	if b != nil {
  0x433251		4885f6			TESTQ SI, SI		
  0x433254		7411			JE 0x433267		
		b.parent = x
  0x433256		833dc39b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43325d		0f85a3000000		JNE 0x433306				
  0x433263		48894640		MOVQ AX, 0x40(SI)			
	y.parent = p
  0x433267		833db29b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43326e		757f			JNE 0x4332ef				
  0x433270		48895140		MOVQ DX, 0x40(CX)			
	if p == nil {
  0x433274		4885d2			TESTQ DX, DX		
  0x433277		7452			JE 0x4332cb		
	} else if p.prev == x {
  0x433279		48394218		CMPQ AX, 0x18(DX)	
  0x43327d		7525			JNE 0x4332a4		
		p.prev = y
  0x43327f		833d9a9b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433286		750e			JNE 0x433296				
  0x433288		48894a18		MOVQ CX, 0x18(DX)			
  0x43328c		488b6c2410		MOVQ 0x10(SP), BP			
  0x433291		4883c418		ADDQ $0x18, SP				
  0x433295		c3			RET					
	} else if p.prev == x {
  0x433296		488d7a18		LEAQ 0x18(DX), DI	
		p.prev = y
  0x43329a		4889c8			MOVQ CX, AX			
  0x43329d		e8de630100		CALL runtime.gcWriteBarrier(SB)	
  0x4332a2		ebe8			JMP 0x43328c			
		if p.next != x {
  0x4332a4		48394210		CMPQ AX, 0x10(DX)	
  0x4332a8		0f85e5000000		JNE 0x433393		
		p.next = y
  0x4332ae		833d6b9b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4332b5		7506			JNE 0x4332bd				
  0x4332b7		48894a10		MOVQ CX, 0x10(DX)			
  0x4332bb		ebcf			JMP 0x43328c				
		if p.next != x {
  0x4332bd		488d7a10		LEAQ 0x10(DX), DI	
		p.next = y
  0x4332c1		4889c8			MOVQ CX, AX			
  0x4332c4		e8b7630100		CALL runtime.gcWriteBarrier(SB)	
  0x4332c9		ebc1			JMP 0x43328c			
		root.treap = y
  0x4332cb		488b542420		MOVQ 0x20(SP), DX			
  0x4332d0		8402			TESTB AL, 0(DX)				
  0x4332d2		833d479b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4332d9		7506			JNE 0x4332e1				
  0x4332db		48894a08		MOVQ CX, 0x8(DX)			
  0x4332df		ebab			JMP 0x43328c				
  0x4332e1		488d7a08		LEAQ 0x8(DX), DI			
  0x4332e5		4889c8			MOVQ CX, AX				
  0x4332e8		e893630100		CALL runtime.gcWriteBarrier(SB)		
  0x4332ed		eb9d			JMP 0x43328c				
	y.parent = p
  0x4332ef		488d7940		LEAQ 0x40(CX), DI	
func (root *semaRoot) rotateLeft(x *sudog) {
  0x4332f3		4889c3			MOVQ AX, BX		
	y.parent = p
  0x4332f6		4889d0			MOVQ DX, AX			
  0x4332f9		e882630100		CALL runtime.gcWriteBarrier(SB)	
	} else if p.prev == x {
  0x4332fe		4889d8			MOVQ BX, AX		
	y.parent = p
  0x433301		e96effffff		JMP 0x433274		
		b.parent = x
  0x433306		488d7e40		LEAQ 0x40(SI), DI		
  0x43330a		e871630100		CALL runtime.gcWriteBarrier(SB)	
  0x43330f		e953ffffff		JMP 0x433267			
	a, y := x.prev, x.next
  0x433314		488d7810		LEAQ 0x10(AX), DI	
func (root *semaRoot) rotateLeft(x *sudog) {
  0x433318		4889c3			MOVQ AX, BX		
	x.next = b
  0x43331b		4889f0			MOVQ SI, AX			
  0x43331e		e85d630100		CALL runtime.gcWriteBarrier(SB)	
		b.parent = x
  0x433323		4889d8			MOVQ BX, AX		
	x.next = b
  0x433326		e926ffffff		JMP 0x433251		
		a.parent = x
  0x43332b		488d7b40		LEAQ 0x40(BX), DI		
  0x43332f		e84c630100		CALL runtime.gcWriteBarrier(SB)	
  0x433334		e907ffffff		JMP 0x433240			
	a, y := x.prev, x.next
  0x433339		488d7818		LEAQ 0x18(AX), DI	
func (root *semaRoot) rotateLeft(x *sudog) {
  0x43333d		4989c0			MOVQ AX, R8		
	x.prev = a
  0x433340		4889d8			MOVQ BX, AX			
  0x433343		e838630100		CALL runtime.gcWriteBarrier(SB)	
		a.parent = x
  0x433348		4c89c0			MOVQ R8, AX		
	x.prev = a
  0x43334b		e9dafeffff		JMP 0x43322a		
		c.parent = y
  0x433350		498d7840		LEAQ 0x40(R8), DI	
func (root *semaRoot) rotateLeft(x *sudog) {
  0x433354		4989c0			MOVQ AX, R8		
		c.parent = y
  0x433357		4889c8			MOVQ CX, AX			
  0x43335a		e821630100		CALL runtime.gcWriteBarrier(SB)	
	x.prev = a
  0x43335f		4c89c0			MOVQ R8, AX		
		c.parent = y
  0x433362		e9b2feffff		JMP 0x433219		
	b, c := y.prev, y.next
  0x433367		488d7918		LEAQ 0x18(CX), DI	
	y.prev = x
  0x43336b		e810630100		CALL runtime.gcWriteBarrier(SB)	
	p := x.parent
  0x433370		488d7840		LEAQ 0x40(AX), DI	
func (root *semaRoot) rotateLeft(x *sudog) {
  0x433374		4989c1			MOVQ AX, R9		
	x.parent = y
  0x433377		4889c8			MOVQ CX, AX			
  0x43337a		e801630100		CALL runtime.gcWriteBarrier(SB)	
	b, c := y.prev, y.next
  0x43337f		488d7810		LEAQ 0x10(AX), DI	
	y.next = c
  0x433383		4c89c0			MOVQ R8, AX			
  0x433386		e8f5620100		CALL runtime.gcWriteBarrier(SB)	
	x.prev = a
  0x43338b		4c89c8			MOVQ R9, AX		
	y.prev = x
  0x43338e		e970feffff		JMP 0x433203		
			throw("semaRoot rotateLeft")
  0x433393		488d055fd10300		LEAQ 0x3d15f(IP), AX	
  0x43339a		48890424		MOVQ AX, 0(SP)		
  0x43339e		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x4333a7		e8d400ffff		CALL runtime.throw(SB)	
  0x4333ac		0f0b			UD2			
func (root *semaRoot) rotateLeft(x *sudog) {
  0x4333ae		e8cd440100		CALL runtime.morestack_noctxt(SB)	
  0x4333b3		e9f8fdffff		JMP runtime.(*semaRoot).rotateLeft(SB)	

TEXT runtime.(*semaRoot).rotateRight(SB) /usr/local/go/src/runtime/sema.go
func (root *semaRoot) rotateRight(y *sudog) {
  0x4333c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4333c9		483b6110		CMPQ 0x10(CX), SP	
  0x4333cd		0f86c3010000		JBE 0x433596		
  0x4333d3		4883ec18		SUBQ $0x18, SP		
  0x4333d7		48896c2410		MOVQ BP, 0x10(SP)	
  0x4333dc		488d6c2410		LEAQ 0x10(SP), BP	
	p := y.parent
  0x4333e1		488b442428		MOVQ 0x28(SP), AX	
	x, c := y.prev, y.next
  0x4333e6		488b4818		MOVQ 0x18(AX), CX	
	p := y.parent
  0x4333ea		488b5040		MOVQ 0x40(AX), DX	
	x, c := y.prev, y.next
  0x4333ee		488b5810		MOVQ 0x10(AX), BX	
	a, b := x.prev, x.next
  0x4333f2		488b7118		MOVQ 0x18(CX), SI	
  0x4333f6		4c8b4110		MOVQ 0x10(CX), R8	
	if a != nil {
  0x4333fa		4885f6			TESTQ SI, SI		
  0x4333fd		7411			JE 0x433410		
		a.parent = x
  0x4333ff		833d1a9a0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433406		0f8558010000		JNE 0x433564				
  0x43340c		48894e40		MOVQ CX, 0x40(SI)			
	x.next = y
  0x433410		833d099a0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433417		0f851b010000		JNE 0x433538				
  0x43341d		48894110		MOVQ AX, 0x10(CX)			
	y.parent = x
  0x433421		48894840		MOVQ CX, 0x40(AX)	
	y.prev = b
  0x433425		4c894018		MOVQ R8, 0x18(AX)	
	if b != nil {
  0x433429		4d85c0			TESTQ R8, R8		
  0x43342c		7411			JE 0x43343f		
		b.parent = y
  0x43342e		833deb990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433435		0f85ef000000		JNE 0x43352a				
  0x43343b		49894040		MOVQ AX, 0x40(R8)			
	y.next = c
  0x43343f		833dda990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433446		0f85c7000000		JNE 0x433513				
  0x43344c		48895810		MOVQ BX, 0x10(AX)			
	if c != nil {
  0x433450		4885db			TESTQ BX, BX		
  0x433453		7411			JE 0x433466		
		c.parent = y
  0x433455		833dc4990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43345c		0f85a3000000		JNE 0x433505				
  0x433462		48894340		MOVQ AX, 0x40(BX)			
	x.parent = p
  0x433466		833db3990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43346d		757f			JNE 0x4334ee				
  0x43346f		48895140		MOVQ DX, 0x40(CX)			
	if p == nil {
  0x433473		4885d2			TESTQ DX, DX		
  0x433476		7452			JE 0x4334ca		
	} else if p.prev == y {
  0x433478		48394218		CMPQ AX, 0x18(DX)	
  0x43347c		7525			JNE 0x4334a3		
		p.prev = x
  0x43347e		833d9b990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x433485		750e			JNE 0x433495				
  0x433487		48894a18		MOVQ CX, 0x18(DX)			
  0x43348b		488b6c2410		MOVQ 0x10(SP), BP			
  0x433490		4883c418		ADDQ $0x18, SP				
  0x433494		c3			RET					
	} else if p.prev == y {
  0x433495		488d7a18		LEAQ 0x18(DX), DI	
		p.prev = x
  0x433499		4889c8			MOVQ CX, AX			
  0x43349c		e8df610100		CALL runtime.gcWriteBarrier(SB)	
  0x4334a1		ebe8			JMP 0x43348b			
		if p.next != y {
  0x4334a3		48394210		CMPQ AX, 0x10(DX)	
  0x4334a7		0f85ce000000		JNE 0x43357b		
		p.next = x
  0x4334ad		833d6c990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4334b4		7506			JNE 0x4334bc				
  0x4334b6		48894a10		MOVQ CX, 0x10(DX)			
  0x4334ba		ebcf			JMP 0x43348b				
		if p.next != y {
  0x4334bc		488d7a10		LEAQ 0x10(DX), DI	
		p.next = x
  0x4334c0		4889c8			MOVQ CX, AX			
  0x4334c3		e8b8610100		CALL runtime.gcWriteBarrier(SB)	
  0x4334c8		ebc1			JMP 0x43348b			
		root.treap = x
  0x4334ca		488b542420		MOVQ 0x20(SP), DX			
  0x4334cf		8402			TESTB AL, 0(DX)				
  0x4334d1		833d48990a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4334d8		7506			JNE 0x4334e0				
  0x4334da		48894a08		MOVQ CX, 0x8(DX)			
  0x4334de		ebab			JMP 0x43348b				
  0x4334e0		488d7a08		LEAQ 0x8(DX), DI			
  0x4334e4		4889c8			MOVQ CX, AX				
  0x4334e7		e894610100		CALL runtime.gcWriteBarrier(SB)		
  0x4334ec		eb9d			JMP 0x43348b				
	x.parent = p
  0x4334ee		488d7940		LEAQ 0x40(CX), DI	
func (root *semaRoot) rotateRight(y *sudog) {
  0x4334f2		4889c3			MOVQ AX, BX		
	x.parent = p
  0x4334f5		4889d0			MOVQ DX, AX			
  0x4334f8		e883610100		CALL runtime.gcWriteBarrier(SB)	
	} else if p.prev == y {
  0x4334fd		4889d8			MOVQ BX, AX		
	x.parent = p
  0x433500		e96effffff		JMP 0x433473		
		c.parent = y
  0x433505		488d7b40		LEAQ 0x40(BX), DI		
  0x433509		e872610100		CALL runtime.gcWriteBarrier(SB)	
  0x43350e		e953ffffff		JMP 0x433466			
	x, c := y.prev, y.next
  0x433513		488d7810		LEAQ 0x10(AX), DI	
func (root *semaRoot) rotateRight(y *sudog) {
  0x433517		4889c6			MOVQ AX, SI		
	y.next = c
  0x43351a		4889d8			MOVQ BX, AX			
  0x43351d		e85e610100		CALL runtime.gcWriteBarrier(SB)	
		c.parent = y
  0x433522		4889f0			MOVQ SI, AX		
	y.next = c
  0x433525		e926ffffff		JMP 0x433450		
		b.parent = y
  0x43352a		498d7840		LEAQ 0x40(R8), DI		
  0x43352e		e84d610100		CALL runtime.gcWriteBarrier(SB)	
  0x433533		e907ffffff		JMP 0x43343f			
	a, b := x.prev, x.next
  0x433538		488d7910		LEAQ 0x10(CX), DI	
	x.next = y
  0x43353c		e83f610100		CALL runtime.gcWriteBarrier(SB)	
	p := y.parent
  0x433541		488d7840		LEAQ 0x40(AX), DI	
func (root *semaRoot) rotateRight(y *sudog) {
  0x433545		4889c6			MOVQ AX, SI		
	y.parent = x
  0x433548		4889c8			MOVQ CX, AX			
  0x43354b		e830610100		CALL runtime.gcWriteBarrier(SB)	
	x, c := y.prev, y.next
  0x433550		488d7e18		LEAQ 0x18(SI), DI	
	y.prev = b
  0x433554		4c89c0			MOVQ R8, AX			
  0x433557		e824610100		CALL runtime.gcWriteBarrier(SB)	
		b.parent = y
  0x43355c		4889f0			MOVQ SI, AX		
	x.next = y
  0x43355f		e9c5feffff		JMP 0x433429		
		a.parent = x
  0x433564		488d7e40		LEAQ 0x40(SI), DI	
func (root *semaRoot) rotateRight(y *sudog) {
  0x433568		4889c6			MOVQ AX, SI		
		a.parent = x
  0x43356b		4889c8			MOVQ CX, AX			
  0x43356e		e80d610100		CALL runtime.gcWriteBarrier(SB)	
	x.next = y
  0x433573		4889f0			MOVQ SI, AX		
		a.parent = x
  0x433576		e995feffff		JMP 0x433410		
			throw("semaRoot rotateRight")
  0x43357b		488d05dfd10300		LEAQ 0x3d1df(IP), AX	
  0x433582		48890424		MOVQ AX, 0(SP)		
  0x433586		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x43358f		e8ecfefeff		CALL runtime.throw(SB)	
  0x433594		0f0b			UD2			
func (root *semaRoot) rotateRight(y *sudog) {
  0x433596		e8e5420100		CALL runtime.morestack_noctxt(SB)	
  0x43359b		e920feffff		JMP runtime.(*semaRoot).rotateRight(SB)	

TEXT runtime.dumpregs(SB) /usr/local/go/src/runtime/signal_amd64x.go
func dumpregs(c *sigctxt) {
  0x4335a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4335a9		488d4424d0		LEAQ -0x30(SP), AX	
  0x4335ae		483b4110		CMPQ 0x10(CX), AX	
  0x4335b2		0f86c2060000		JBE 0x433c7a		
  0x4335b8		4881ecb0000000		SUBQ $0xb0, SP		
  0x4335bf		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x4335c7		488dac24a8000000	LEAQ 0xa8(SP), BP	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4335cf		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4335d7		488b4808		MOVQ 0x8(AX), CX	
  0x4335db		8400			TESTB AL, 0(AX)		
	print("rax    ", hex(c.rax()), "\n")
  0x4335dd		90			NOPL			
func (c *sigctxt) rax() uint64 { return c.regs().rax }
  0x4335de		90			NOPL			
  0x4335df		488b8990000000		MOVQ 0x90(CX), CX	
  0x4335e6		48894c2460		MOVQ CX, 0x60(SP)	
	print("rax    ", hex(c.rax()), "\n")
  0x4335eb		e8d008ffff		CALL runtime.printlock(SB)	
  0x4335f0		488d0578bd0300		LEAQ 0x3bd78(IP), AX		
  0x4335f7		48890424		MOVQ AX, 0(SP)			
  0x4335fb		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433604		e8e711ffff		CALL runtime.printstring(SB)	
  0x433609		488b442460		MOVQ 0x60(SP), AX		
  0x43360e		48890424		MOVQ AX, 0(SP)			
  0x433612		e89910ffff		CALL runtime.printhex(SB)	
  0x433617		e8340bffff		CALL runtime.printnl(SB)	
  0x43361c		e81f09ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433621		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433629		488b4808		MOVQ 0x8(AX), CX	
	print("rbx    ", hex(c.rbx()), "\n")
  0x43362d		90			NOPL			
func (c *sigctxt) rbx() uint64 { return c.regs().rbx }
  0x43362e		90			NOPL			
  0x43362f		488b8980000000		MOVQ 0x80(CX), CX	
  0x433636		48894c2478		MOVQ CX, 0x78(SP)	
	print("rbx    ", hex(c.rbx()), "\n")
  0x43363b		e88008ffff		CALL runtime.printlock(SB)	
  0x433640		488d0536bd0300		LEAQ 0x3bd36(IP), AX		
  0x433647		48890424		MOVQ AX, 0(SP)			
  0x43364b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433654		e89711ffff		CALL runtime.printstring(SB)	
  0x433659		488b442478		MOVQ 0x78(SP), AX		
  0x43365e		48890424		MOVQ AX, 0(SP)			
  0x433662		e84910ffff		CALL runtime.printhex(SB)	
  0x433667		e8e40affff		CALL runtime.printnl(SB)	
  0x43366c		e8cf08ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433671		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433679		488b4808		MOVQ 0x8(AX), CX	
	print("rcx    ", hex(c.rcx()), "\n")
  0x43367d		90			NOPL			
func (c *sigctxt) rcx() uint64 { return c.regs().rcx }
  0x43367e		90			NOPL			
  0x43367f		488b8998000000		MOVQ 0x98(CX), CX	
  0x433686		48894c2458		MOVQ CX, 0x58(SP)	
	print("rcx    ", hex(c.rcx()), "\n")
  0x43368b		e83008ffff		CALL runtime.printlock(SB)	
  0x433690		488d05edbc0300		LEAQ 0x3bced(IP), AX		
  0x433697		48890424		MOVQ AX, 0(SP)			
  0x43369b		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4336a4		e84711ffff		CALL runtime.printstring(SB)	
  0x4336a9		488b442458		MOVQ 0x58(SP), AX		
  0x4336ae		48890424		MOVQ AX, 0(SP)			
  0x4336b2		e8f90fffff		CALL runtime.printhex(SB)	
  0x4336b7		e8940affff		CALL runtime.printnl(SB)	
  0x4336bc		e87f08ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4336c1		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4336c9		488b4808		MOVQ 0x8(AX), CX	
	print("rdx    ", hex(c.rdx()), "\n")
  0x4336cd		90			NOPL			
func (c *sigctxt) rdx() uint64 { return c.regs().rdx }
  0x4336ce		90			NOPL			
  0x4336cf		488b8988000000		MOVQ 0x88(CX), CX	
  0x4336d6		48894c2438		MOVQ CX, 0x38(SP)	
	print("rdx    ", hex(c.rdx()), "\n")
  0x4336db		e8e007ffff		CALL runtime.printlock(SB)	
  0x4336e0		488d05abbc0300		LEAQ 0x3bcab(IP), AX		
  0x4336e7		48890424		MOVQ AX, 0(SP)			
  0x4336eb		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4336f4		e8f710ffff		CALL runtime.printstring(SB)	
  0x4336f9		488b442438		MOVQ 0x38(SP), AX		
  0x4336fe		48890424		MOVQ AX, 0(SP)			
  0x433702		e8a90fffff		CALL runtime.printhex(SB)	
  0x433707		e8440affff		CALL runtime.printnl(SB)	
  0x43370c		e82f08ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433711		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433719		488b4808		MOVQ 0x8(AX), CX	
	print("rdi    ", hex(c.rdi()), "\n")
  0x43371d		90			NOPL			
func (c *sigctxt) rdi() uint64 { return c.regs().rdi }
  0x43371e		90			NOPL			
  0x43371f		488b4968		MOVQ 0x68(CX), CX	
  0x433723		48894c2440		MOVQ CX, 0x40(SP)	
	print("rdi    ", hex(c.rdi()), "\n")
  0x433728		e89307ffff		CALL runtime.printlock(SB)	
  0x43372d		488d0557bc0300		LEAQ 0x3bc57(IP), AX		
  0x433734		48890424		MOVQ AX, 0(SP)			
  0x433738		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433741		e8aa10ffff		CALL runtime.printstring(SB)	
  0x433746		488b442440		MOVQ 0x40(SP), AX		
  0x43374b		48890424		MOVQ AX, 0(SP)			
  0x43374f		e85c0fffff		CALL runtime.printhex(SB)	
  0x433754		e8f709ffff		CALL runtime.printnl(SB)	
  0x433759		e8e207ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43375e		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433766		488b4808		MOVQ 0x8(AX), CX	
	print("rsi    ", hex(c.rsi()), "\n")
  0x43376a		90			NOPL			
func (c *sigctxt) rsi() uint64 { return c.regs().rsi }
  0x43376b		90			NOPL			
  0x43376c		488b4970		MOVQ 0x70(CX), CX	
  0x433770		48894c2468		MOVQ CX, 0x68(SP)	
	print("rsi    ", hex(c.rsi()), "\n")
  0x433775		e84607ffff		CALL runtime.printlock(SB)	
  0x43377a		488d0526bc0300		LEAQ 0x3bc26(IP), AX		
  0x433781		48890424		MOVQ AX, 0(SP)			
  0x433785		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43378e		e85d10ffff		CALL runtime.printstring(SB)	
  0x433793		488b442468		MOVQ 0x68(SP), AX		
  0x433798		48890424		MOVQ AX, 0(SP)			
  0x43379c		e80f0fffff		CALL runtime.printhex(SB)	
  0x4337a1		e8aa09ffff		CALL runtime.printnl(SB)	
  0x4337a6		e89507ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4337ab		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4337b3		488b4808		MOVQ 0x8(AX), CX	
	print("rbp    ", hex(c.rbp()), "\n")
  0x4337b7		90			NOPL			
func (c *sigctxt) rbp() uint64 { return c.regs().rbp }
  0x4337b8		90			NOPL			
  0x4337b9		488b4978		MOVQ 0x78(CX), CX	
  0x4337bd		48898c2490000000	MOVQ CX, 0x90(SP)	
	print("rbp    ", hex(c.rbp()), "\n")
  0x4337c5		e8f606ffff		CALL runtime.printlock(SB)	
  0x4337ca		488d05a5bb0300		LEAQ 0x3bba5(IP), AX		
  0x4337d1		48890424		MOVQ AX, 0(SP)			
  0x4337d5		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4337de		e80d10ffff		CALL runtime.printstring(SB)	
  0x4337e3		488b842490000000	MOVQ 0x90(SP), AX		
  0x4337eb		48890424		MOVQ AX, 0(SP)			
  0x4337ef		e8bc0effff		CALL runtime.printhex(SB)	
  0x4337f4		e85709ffff		CALL runtime.printnl(SB)	
  0x4337f9		e84207ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4337fe		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433806		488b4808		MOVQ 0x8(AX), CX	
	print("rsp    ", hex(c.rsp()), "\n")
  0x43380a		90			NOPL			
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x43380b		90			NOPL			
  0x43380c		488b89a0000000		MOVQ 0xa0(CX), CX	
  0x433813		48894c2418		MOVQ CX, 0x18(SP)	
	print("rsp    ", hex(c.rsp()), "\n")
  0x433818		e8a306ffff		CALL runtime.printlock(SB)	
  0x43381d		488d058abb0300		LEAQ 0x3bb8a(IP), AX		
  0x433824		48890424		MOVQ AX, 0(SP)			
  0x433828		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433831		e8ba0fffff		CALL runtime.printstring(SB)	
  0x433836		488b442418		MOVQ 0x18(SP), AX		
  0x43383b		48890424		MOVQ AX, 0(SP)			
  0x43383f		e86c0effff		CALL runtime.printhex(SB)	
  0x433844		e80709ffff		CALL runtime.printnl(SB)	
  0x433849		e8f206ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43384e		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433856		488b4808		MOVQ 0x8(AX), CX	
	print("r8     ", hex(c.r8()), "\n")
  0x43385a		90			NOPL			
func (c *sigctxt) r8() uint64  { return c.regs().r8 }
  0x43385b		90			NOPL			
  0x43385c		488b4928		MOVQ 0x28(CX), CX	
  0x433860		48894c2410		MOVQ CX, 0x10(SP)	
	print("r8     ", hex(c.r8()), "\n")
  0x433865		e85606ffff		CALL runtime.printlock(SB)	
  0x43386a		488d05f0ba0300		LEAQ 0x3baf0(IP), AX		
  0x433871		48890424		MOVQ AX, 0(SP)			
  0x433875		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43387e		e86d0fffff		CALL runtime.printstring(SB)	
  0x433883		488b442410		MOVQ 0x10(SP), AX		
  0x433888		48890424		MOVQ AX, 0(SP)			
  0x43388c		e81f0effff		CALL runtime.printhex(SB)	
  0x433891		e8ba08ffff		CALL runtime.printnl(SB)	
  0x433896		e8a506ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43389b		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4338a3		488b4808		MOVQ 0x8(AX), CX	
	print("r9     ", hex(c.r9()), "\n")
  0x4338a7		90			NOPL			
func (c *sigctxt) r9() uint64  { return c.regs().r9 }
  0x4338a8		90			NOPL			
  0x4338a9		488b4930		MOVQ 0x30(CX), CX	
  0x4338ad		48898c2488000000	MOVQ CX, 0x88(SP)	
	print("r9     ", hex(c.r9()), "\n")
  0x4338b5		e80606ffff		CALL runtime.printlock(SB)	
  0x4338ba		488d05a7ba0300		LEAQ 0x3baa7(IP), AX		
  0x4338c1		48890424		MOVQ AX, 0(SP)			
  0x4338c5		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4338ce		e81d0fffff		CALL runtime.printstring(SB)	
  0x4338d3		488b842488000000	MOVQ 0x88(SP), AX		
  0x4338db		48890424		MOVQ AX, 0(SP)			
  0x4338df		e8cc0dffff		CALL runtime.printhex(SB)	
  0x4338e4		e86708ffff		CALL runtime.printnl(SB)	
  0x4338e9		e85206ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4338ee		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4338f6		488b4808		MOVQ 0x8(AX), CX	
	print("r10    ", hex(c.r10()), "\n")
  0x4338fa		90			NOPL			
func (c *sigctxt) r10() uint64 { return c.regs().r10 }
  0x4338fb		90			NOPL			
  0x4338fc		488b4938		MOVQ 0x38(CX), CX	
  0x433900		48898c2480000000	MOVQ CX, 0x80(SP)	
	print("r10    ", hex(c.r10()), "\n")
  0x433908		e8b305ffff		CALL runtime.printlock(SB)	
  0x43390d		488d0523ba0300		LEAQ 0x3ba23(IP), AX		
  0x433914		48890424		MOVQ AX, 0(SP)			
  0x433918		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433921		e8ca0effff		CALL runtime.printstring(SB)	
  0x433926		488b842480000000	MOVQ 0x80(SP), AX		
  0x43392e		48890424		MOVQ AX, 0(SP)			
  0x433932		e8790dffff		CALL runtime.printhex(SB)	
  0x433937		e81408ffff		CALL runtime.printnl(SB)	
  0x43393c		e8ff05ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433941		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433949		488b4808		MOVQ 0x8(AX), CX	
	print("r11    ", hex(c.r11()), "\n")
  0x43394d		90			NOPL			
func (c *sigctxt) r11() uint64 { return c.regs().r11 }
  0x43394e		90			NOPL			
  0x43394f		488b4940		MOVQ 0x40(CX), CX	
  0x433953		48894c2470		MOVQ CX, 0x70(SP)	
	print("r11    ", hex(c.r11()), "\n")
  0x433958		e86305ffff		CALL runtime.printlock(SB)	
  0x43395d		488d05dab90300		LEAQ 0x3b9da(IP), AX		
  0x433964		48890424		MOVQ AX, 0(SP)			
  0x433968		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433971		e87a0effff		CALL runtime.printstring(SB)	
  0x433976		488b442470		MOVQ 0x70(SP), AX		
  0x43397b		48890424		MOVQ AX, 0(SP)			
  0x43397f		e82c0dffff		CALL runtime.printhex(SB)	
  0x433984		e8c707ffff		CALL runtime.printnl(SB)	
  0x433989		e8b205ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x43398e		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433996		488b4808		MOVQ 0x8(AX), CX	
	print("r12    ", hex(c.r12()), "\n")
  0x43399a		90			NOPL			
func (c *sigctxt) r12() uint64 { return c.regs().r12 }
  0x43399b		90			NOPL			
  0x43399c		488b4948		MOVQ 0x48(CX), CX	
  0x4339a0		48898c2498000000	MOVQ CX, 0x98(SP)	
	print("r12    ", hex(c.r12()), "\n")
  0x4339a8		e81305ffff		CALL runtime.printlock(SB)	
  0x4339ad		488d0591b90300		LEAQ 0x3b991(IP), AX		
  0x4339b4		48890424		MOVQ AX, 0(SP)			
  0x4339b8		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4339c1		e82a0effff		CALL runtime.printstring(SB)	
  0x4339c6		488b842498000000	MOVQ 0x98(SP), AX		
  0x4339ce		48890424		MOVQ AX, 0(SP)			
  0x4339d2		e8d90cffff		CALL runtime.printhex(SB)	
  0x4339d7		e87407ffff		CALL runtime.printnl(SB)	
  0x4339dc		e85f05ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4339e1		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x4339e9		488b4808		MOVQ 0x8(AX), CX	
	print("r13    ", hex(c.r13()), "\n")
  0x4339ed		90			NOPL			
func (c *sigctxt) r13() uint64 { return c.regs().r13 }
  0x4339ee		90			NOPL			
  0x4339ef		488b4950		MOVQ 0x50(CX), CX	
  0x4339f3		48894c2450		MOVQ CX, 0x50(SP)	
	print("r13    ", hex(c.r13()), "\n")
  0x4339f8		e8c304ffff		CALL runtime.printlock(SB)	
  0x4339fd		488d0548b90300		LEAQ 0x3b948(IP), AX		
  0x433a04		48890424		MOVQ AX, 0(SP)			
  0x433a08		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433a11		e8da0dffff		CALL runtime.printstring(SB)	
  0x433a16		488b442450		MOVQ 0x50(SP), AX		
  0x433a1b		48890424		MOVQ AX, 0(SP)			
  0x433a1f		e88c0cffff		CALL runtime.printhex(SB)	
  0x433a24		e82707ffff		CALL runtime.printnl(SB)	
  0x433a29		e81205ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433a2e		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433a36		488b4808		MOVQ 0x8(AX), CX	
	print("r14    ", hex(c.r14()), "\n")
  0x433a3a		90			NOPL			
func (c *sigctxt) r14() uint64 { return c.regs().r14 }
  0x433a3b		90			NOPL			
  0x433a3c		488b4958		MOVQ 0x58(CX), CX	
  0x433a40		48894c2448		MOVQ CX, 0x48(SP)	
	print("r14    ", hex(c.r14()), "\n")
  0x433a45		e87604ffff		CALL runtime.printlock(SB)	
  0x433a4a		488d0502b90300		LEAQ 0x3b902(IP), AX		
  0x433a51		48890424		MOVQ AX, 0(SP)			
  0x433a55		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433a5e		e88d0dffff		CALL runtime.printstring(SB)	
  0x433a63		488b442448		MOVQ 0x48(SP), AX		
  0x433a68		48890424		MOVQ AX, 0(SP)			
  0x433a6c		e83f0cffff		CALL runtime.printhex(SB)	
  0x433a71		e8da06ffff		CALL runtime.printnl(SB)	
  0x433a76		e8c504ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433a7b		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433a83		488b4808		MOVQ 0x8(AX), CX	
	print("r15    ", hex(c.r15()), "\n")
  0x433a87		90			NOPL			
func (c *sigctxt) r15() uint64 { return c.regs().r15 }
  0x433a88		90			NOPL			
  0x433a89		488b4960		MOVQ 0x60(CX), CX	
  0x433a8d		48894c2420		MOVQ CX, 0x20(SP)	
	print("r15    ", hex(c.r15()), "\n")
  0x433a92		e82904ffff		CALL runtime.printlock(SB)	
  0x433a97		488d05bcb80300		LEAQ 0x3b8bc(IP), AX		
  0x433a9e		48890424		MOVQ AX, 0(SP)			
  0x433aa2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433aab		e8400dffff		CALL runtime.printstring(SB)	
  0x433ab0		488b442420		MOVQ 0x20(SP), AX		
  0x433ab5		48890424		MOVQ AX, 0(SP)			
  0x433ab9		e8f20bffff		CALL runtime.printhex(SB)	
  0x433abe		e88d06ffff		CALL runtime.printnl(SB)	
  0x433ac3		e87804ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433ac8		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433ad0		488b4808		MOVQ 0x8(AX), CX	
	print("rip    ", hex(c.rip()), "\n")
  0x433ad4		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x433ad5		90			NOPL			
  0x433ad6		488b89a8000000		MOVQ 0xa8(CX), CX	
  0x433add		48894c2428		MOVQ CX, 0x28(SP)	
	print("rip    ", hex(c.rip()), "\n")
  0x433ae2		e8d903ffff		CALL runtime.printlock(SB)	
  0x433ae7		488d05b2b80300		LEAQ 0x3b8b2(IP), AX		
  0x433aee		48890424		MOVQ AX, 0(SP)			
  0x433af2		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433afb		e8f00cffff		CALL runtime.printstring(SB)	
  0x433b00		488b442428		MOVQ 0x28(SP), AX		
  0x433b05		48890424		MOVQ AX, 0(SP)			
  0x433b09		e8a20bffff		CALL runtime.printhex(SB)	
  0x433b0e		e83d06ffff		CALL runtime.printnl(SB)	
  0x433b13		e82804ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433b18		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433b20		488b4808		MOVQ 0x8(AX), CX	
	print("rflags ", hex(c.rflags()), "\n")
  0x433b24		90			NOPL			
func (c *sigctxt) rflags() uint64  { return c.regs().eflags }
  0x433b25		90			NOPL			
  0x433b26		488b89b0000000		MOVQ 0xb0(CX), CX	
  0x433b2d		48894c2430		MOVQ CX, 0x30(SP)	
	print("rflags ", hex(c.rflags()), "\n")
  0x433b32		e88903ffff		CALL runtime.printlock(SB)	
  0x433b37		488d055bb80300		LEAQ 0x3b85b(IP), AX		
  0x433b3e		48890424		MOVQ AX, 0(SP)			
  0x433b42		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433b4b		e8a00cffff		CALL runtime.printstring(SB)	
  0x433b50		488b442430		MOVQ 0x30(SP), AX		
  0x433b55		48890424		MOVQ AX, 0(SP)			
  0x433b59		e8520bffff		CALL runtime.printhex(SB)	
  0x433b5e		e8ed05ffff		CALL runtime.printnl(SB)	
  0x433b63		e8d803ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433b68		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433b70		488b4808		MOVQ 0x8(AX), CX	
	print("cs     ", hex(c.cs()), "\n")
  0x433b74		90			NOPL			
func (c *sigctxt) cs() uint64      { return uint64(c.regs().cs) }
  0x433b75		90			NOPL			
  0x433b76		0fb789b8000000		MOVZX 0xb8(CX), CX	
  0x433b7d		48898c24a0000000	MOVQ CX, 0xa0(SP)	
	print("cs     ", hex(c.cs()), "\n")
  0x433b85		e83603ffff		CALL runtime.printlock(SB)	
  0x433b8a		488d0583b70300		LEAQ 0x3b783(IP), AX		
  0x433b91		48890424		MOVQ AX, 0(SP)			
  0x433b95		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433b9e		e84d0cffff		CALL runtime.printstring(SB)	
  0x433ba3		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x433bab		48890424		MOVQ AX, 0(SP)			
  0x433baf		e8fc0affff		CALL runtime.printhex(SB)	
  0x433bb4		e89705ffff		CALL runtime.printnl(SB)	
  0x433bb9		e88203ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433bbe		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433bc6		488b4808		MOVQ 0x8(AX), CX	
	print("fs     ", hex(c.fs()), "\n")
  0x433bca		90			NOPL			
func (c *sigctxt) fs() uint64      { return uint64(c.regs().fs) }
  0x433bcb		90			NOPL			
  0x433bcc		0fb789bc000000		MOVZX 0xbc(CX), CX	
  0x433bd3		48898c24a0000000	MOVQ CX, 0xa0(SP)	
	print("fs     ", hex(c.fs()), "\n")
  0x433bdb		e8e002ffff		CALL runtime.printlock(SB)	
  0x433be0		488d0534b70300		LEAQ 0x3b734(IP), AX		
  0x433be7		48890424		MOVQ AX, 0(SP)			
  0x433beb		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433bf4		e8f70bffff		CALL runtime.printstring(SB)	
  0x433bf9		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x433c01		48890424		MOVQ AX, 0(SP)			
  0x433c05		e8a60affff		CALL runtime.printhex(SB)	
  0x433c0a		e84105ffff		CALL runtime.printnl(SB)	
  0x433c0f		e82c03ffff		CALL runtime.printunlock(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433c14		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x433c1c		488b4008		MOVQ 0x8(AX), AX	
	print("gs     ", hex(c.gs()), "\n")
  0x433c20		90			NOPL			
func (c *sigctxt) gs() uint64      { return uint64(c.regs().gs) }
  0x433c21		90			NOPL			
  0x433c22		0fb780ba000000		MOVZX 0xba(AX), AX	
  0x433c29		48898424a0000000	MOVQ AX, 0xa0(SP)	
	print("gs     ", hex(c.gs()), "\n")
  0x433c31		e88a02ffff		CALL runtime.printlock(SB)	
  0x433c36		488d05ecb60300		LEAQ 0x3b6ec(IP), AX		
  0x433c3d		48890424		MOVQ AX, 0(SP)			
  0x433c41		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x433c4a		e8a10bffff		CALL runtime.printstring(SB)	
  0x433c4f		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x433c57		48890424		MOVQ AX, 0(SP)			
  0x433c5b		e8500affff		CALL runtime.printhex(SB)	
  0x433c60		e8eb04ffff		CALL runtime.printnl(SB)	
  0x433c65		e8d602ffff		CALL runtime.printunlock(SB)	
}
  0x433c6a		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x433c72		4881c4b0000000		ADDQ $0xb0, SP		
  0x433c79		c3			RET			
func dumpregs(c *sigctxt) {
  0x433c7a		e8013c0100		CALL runtime.morestack_noctxt(SB)	
  0x433c7f		e91cf9ffff		JMP runtime.dumpregs(SB)		

TEXT runtime.(*sigctxt).preparePanic(SB) /usr/local/go/src/runtime/signal_amd64x.go
func (c *sigctxt) preparePanic(sig uint32, gp *g) {
  0x433c90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433c99		483b6110		CMPQ 0x10(CX), SP	
  0x433c9d		0f86ad000000		JBE 0x433d50		
  0x433ca3		4883ec38		SUBQ $0x38, SP		
  0x433ca7		48896c2430		MOVQ BP, 0x30(SP)	
  0x433cac		488d6c2430		LEAQ 0x30(SP), BP	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x433cb1		488b442440		MOVQ 0x40(SP), AX	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433cb6		488b4808		MOVQ 0x8(AX), CX	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x433cba		488b91a0000000		MOVQ 0xa0(CX), DX	
  0x433cc1		4889542428		MOVQ DX, 0x28(SP)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433cc6		8400			TESTB AL, 0(AX)		
	pc := uintptr(c.rip())
  0x433cc8		90			NOPL			
	sp := uintptr(c.rsp())
  0x433cc9		90			NOPL			
	if shouldPushSigpanic(gp, pc, *(*uintptr)(unsafe.Pointer(sp))) {
  0x433cca		488b12			MOVQ 0(DX), DX		
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x433ccd		90			NOPL			
  0x433cce		488b89a8000000		MOVQ 0xa8(CX), CX	
  0x433cd5		48894c2420		MOVQ CX, 0x20(SP)	
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x433cda		90			NOPL			
	if shouldPushSigpanic(gp, pc, *(*uintptr)(unsafe.Pointer(sp))) {
  0x433cdb		488b742450		MOVQ 0x50(SP), SI			
  0x433ce0		48893424		MOVQ SI, 0(SP)				
  0x433ce4		48894c2408		MOVQ CX, 0x8(SP)			
  0x433ce9		4889542410		MOVQ DX, 0x10(SP)			
  0x433cee		e8bdfffeff		CALL runtime.shouldPushSigpanic(SB)	
  0x433cf3		807c241800		CMPB $0x0, 0x18(SP)			
  0x433cf8		744f			JE 0x433d49				
		sp -= sys.PtrSize
  0x433cfa		488b442428		MOVQ 0x28(SP), AX	
  0x433cff		4883c0f8		ADDQ $-0x8, AX		
		*(*uintptr)(unsafe.Pointer(sp)) = pc
  0x433d03		4889c1			MOVQ AX, CX		
  0x433d06		488b542420		MOVQ 0x20(SP), DX	
  0x433d0b		488910			MOVQ DX, 0(AX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433d0e		488b442440		MOVQ 0x40(SP), AX	
  0x433d13		488b5008		MOVQ 0x8(AX), DX	
		c.set_rsp(uint64(sp))
  0x433d17		90			NOPL			
func (c *sigctxt) set_rsp(x uint64)     { c.regs().rsp = x }
  0x433d18		90			NOPL			
  0x433d19		48898aa0000000		MOVQ CX, 0xa0(DX)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x433d20		488d0d49fc0300		LEAQ 0x3fc49(IP), CX	
  0x433d27		8401			TESTB AL, 0(CX)		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433d29		488b4008		MOVQ 0x8(AX), AX	
	c.set_rip(uint64(funcPC(sigpanic)))
  0x433d2d		90			NOPL			
  0x433d2e		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x433d2f		488b0d3afc0300		MOVQ 0x3fc3a(IP), CX	
  0x433d36		90			NOPL			
func (c *sigctxt) set_rip(x uint64)     { c.regs().rip = x }
  0x433d37		90			NOPL			
  0x433d38		488988a8000000		MOVQ CX, 0xa8(AX)	
  0x433d3f		488b6c2430		MOVQ 0x30(SP), BP	
  0x433d44		4883c438		ADDQ $0x38, SP		
  0x433d48		c3			RET			
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433d49		488b442440		MOVQ 0x40(SP), AX	
	c.set_rip(uint64(funcPC(sigpanic)))
  0x433d4e		ebd0			JMP 0x433d20		
func (c *sigctxt) preparePanic(sig uint32, gp *g) {
  0x433d50		e82b3b0100		CALL runtime.morestack_noctxt(SB)	
  0x433d55		e936ffffff		JMP runtime.(*sigctxt).preparePanic(SB)	

TEXT runtime.sighandler(SB) /usr/local/go/src/runtime/signal_sighandler.go
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x433d60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x433d69		483b6110		CMPQ 0x10(CX), SP	
  0x433d6d		0f862f070000		JBE 0x4344a2		
  0x433d73		4883ec78		SUBQ $0x78, SP		
  0x433d77		48896c2470		MOVQ BP, 0x70(SP)	
  0x433d7c		488d6c2470		LEAQ 0x70(SP), BP	
	_g_ := getg()
  0x433d81		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	c := &sigctxt{info, ctxt}
  0x433d8a		0f57c0			XORPS X0, X0		
  0x433d8d		0f11442460		MOVUPS X0, 0x60(SP)	
  0x433d92		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x433d9a		48894c2460		MOVQ CX, 0x60(SP)	
  0x433d9f		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x433da7		48895c2468		MOVQ BX, 0x68(SP)	
	if sig == _SIGPROF {
  0x433dac		8bb42480000000		MOVL 0x80(SP), SI	
  0x433db3		83fe1b			CMPL $0x1b, SI		
  0x433db6		0f8485060000		JE 0x434441		
	_g_ := getg()
  0x433dbc		4889442450		MOVQ AX, 0x50(SP)	
	if sig == _SIGTRAP && testSigtrap != nil && testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) {
  0x433dc1		83fe05			CMPL $0x5, SI				
  0x433dc4		0f8570060000		JNE 0x43443a				
  0x433dca		488b15cfdb0800		MOVQ runtime.testSigtrap(SB), DX	
  0x433dd1		4885d2			TESTQ DX, DX				
  0x433dd4		0f8529060000		JNE 0x434403				
  0x433dda		31c9			XORL CX, CX				
  0x433ddc		84c9			TESTL CL, CL				
  0x433dde		0f8515060000		JNE 0x4343f9				
	if sig < uint32(len(sigtable)) {
  0x433de4		83fe41			CMPL $0x41, SI		
  0x433de7		0f83fb050000		JAE 0x4343e8		
		flags = sigtable[sig].flags
  0x433ded		4883fe41		CMPQ $0x41, SI			
  0x433df1		0f83a4060000		JAE 0x43449b			
  0x433df7		488d0c76		LEAQ 0(SI)(SI*2), CX		
  0x433dfb		488d157ec40800		LEAQ runtime.sigtable(SB), DX	
  0x433e02		8b0cca			MOVL 0(DX)(CX*8), CX		
	if flags&_SigPanic != 0 && gp.throwsplit {
  0x433e05		0fbae103		BTL $0x3, CX		
  0x433e09		0f83cc050000		JAE 0x4343db		
  0x433e0f		488b9c2498000000	MOVQ 0x98(SP), BX	
  0x433e17		80bbb600000000		CMPB $0x0, 0xb6(BX)	
  0x433e1e		7406			JE 0x433e26		
		flags = (flags &^ _SigPanic) | _SigThrow
  0x433e20		83e1f7			ANDL $-0x9, CX		
  0x433e23		83c904			ORL $0x4, CX		
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433e26		488b7c2468		MOVQ 0x68(SP), DI	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x433e2b		4c8d05e6f80300		LEAQ 0x3f8e6(IP), R8	
  0x433e32		418400			TESTB AL, 0(R8)		
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433e35		4c8b442460		MOVQ 0x60(SP), R8	
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x433e3a		488bbfa8000000		MOVQ 0xa8(DI), DI	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x433e41		48393dd0f80300		CMPQ DI, 0x3f8d0(IP)	
	if flags&_SigKill != 0 {
  0x433e48		bf04000000		MOVL $0x4, DI		
  0x433e4d		0f44cf			CMOVE DI, CX		
	if isAbortPC(c.sigpc()) {
  0x433e50		90			NOPL			
  0x433e51		90			NOPL			
	if c.sigcode() != _SI_USER && flags&_SigPanic != 0 {
  0x433e52		90			NOPL			
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x433e53		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x433e54		90			NOPL			
	return pc == funcPC(abort) || ((GOARCH == "arm" || GOARCH == "arm64") && pc == funcPC(abort)+sys.PCQuantum)
  0x433e55		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x433e56		90			NOPL			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433e57		49637808		MOVSXD 0x8(R8), DI	
	if c.sigcode() != _SI_USER && flags&_SigPanic != 0 {
  0x433e5b		4885ff			TESTQ DI, DI		
	if isAbortPC(c.sigpc()) {
  0x433e5e		740d			JE 0x433e6d		
	if c.sigcode() != _SI_USER && flags&_SigPanic != 0 {
  0x433e60		0fbae103		BTL $0x3, CX		
  0x433e64		0f8211050000		JB 0x43437b		
  0x433e6a		4885ff			TESTQ DI, DI		
	if flags&_SigKill != 0 {
  0x433e6d		894c2428		MOVL CX, 0x28(SP)	
	if c.sigcode() == _SI_USER || flags&_SigNotify != 0 {
  0x433e71		90			NOPL			
  0x433e72		0f85f4040000		JNE 0x43436c		
		if sigsend(sig) {
  0x433e78		893424			MOVL SI, 0(SP)			
  0x433e7b		e8701c0000		CALL runtime.sigsend(SB)	
  0x433e80		807c240800		CMPB $0x0, 0x8(SP)		
  0x433e85		0f85d7040000		JNE 0x434362			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433e8b		488b442460		MOVQ 0x60(SP), AX	
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x433e90		90			NOPL			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433e91		48634008		MOVSXD 0x8(AX), AX	
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x433e95		4885c0			TESTQ AX, AX		
  0x433e98		0f85b6040000		JNE 0x434354		
  0x433e9e		90			NOPL			
	i := atomic.Load(&sig.ignored[s/32])
  0x433e9f		8b842480000000		MOVL 0x80(SP), AX		
  0x433ea6		89c1			MOVL AX, CX			
  0x433ea8		c1e805			SHRL $0x5, AX			
  0x433eab		4883f803		CMPQ $0x3, AX			
  0x433eaf		0f83df050000		JAE 0x434494			
  0x433eb5		488d15c4900a00		LEAQ runtime.sig+32(SB), DX	
  0x433ebc		488d0482		LEAQ 0(DX)(AX*4), AX		
  0x433ec0		8b00			MOVL 0(AX), AX			
	return i&(1<<(s&31)) != 0
  0x433ec2		0fa3c8			BTL CX, AX		
  0x433ec5		0f92c0			SETB AL			
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x433ec8		84c0			TESTL AL, AL		
  0x433eca		0f857a040000		JNE 0x43434a		
	if flags&_SigKill != 0 {
  0x433ed0		8b442428		MOVL 0x28(SP), AX	
  0x433ed4		0fbae001		BTL $0x1, AX		
  0x433ed8		0f8254040000		JB 0x434332		
	if flags&_SigThrow == 0 {
  0x433ede		0fbae002		BTL $0x2, AX		
  0x433ee2		0f8340040000		JAE 0x434328		
	_g_.m.throwing = 1
  0x433ee8		488b442450		MOVQ 0x50(SP), AX	
  0x433eed		488b5030		MOVQ 0x30(AX), DX	
  0x433ef1		c782f400000001000000	MOVL $0x1, 0xf4(DX)	
	_g_.m.caughtsig.set(gp)
  0x433efb		488b5030		MOVQ 0x30(AX), DX	
  0x433eff		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x433f00		488b9c2498000000	MOVQ 0x98(SP), BX	
  0x433f08		4889de			MOVQ BX, SI		
  0x433f0b		48899ac8000000		MOVQ BX, 0xc8(DX)	
	if crashing == 0 {
  0x433f12		833da78d0a0000		CMPL $0x0, runtime.crashing(SB)	
  0x433f19		0f84e8030000		JE 0x434307			
	if sig < uint32(len(sigtable)) {
  0x433f1f		83f941			CMPL $0x41, CX		
	if sig < uint32(len(sigtable)) {
  0x433f22		0f83a2030000		JAE 0x4342ca		
		print(sigtable[sig].name, "\n")
  0x433f28		4883f941		CMPQ $0x41, CX			
  0x433f2c		0f835b050000		JAE 0x43448d			
  0x433f32		488d0449		LEAQ 0(CX)(CX*2), AX		
  0x433f36		488d0d43c30800		LEAQ runtime.sigtable(SB), CX	
  0x433f3d		488b54c108		MOVQ 0x8(CX)(AX*8), DX		
  0x433f42		4889542458		MOVQ DX, 0x58(SP)		
  0x433f47		488b44c110		MOVQ 0x10(CX)(AX*8), AX		
  0x433f4c		4889442448		MOVQ AX, 0x48(SP)		
  0x433f51		e86afffeff		CALL runtime.printlock(SB)	
  0x433f56		488b442458		MOVQ 0x58(SP), AX		
  0x433f5b		48890424		MOVQ AX, 0(SP)			
  0x433f5f		488b442448		MOVQ 0x48(SP), AX		
  0x433f64		4889442408		MOVQ AX, 0x8(SP)		
  0x433f69		e88208ffff		CALL runtime.printstring(SB)	
  0x433f6e		e8dd01ffff		CALL runtime.printnl(SB)	
  0x433f73		e8c8fffeff		CALL runtime.printunlock(SB)	
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x433f78		488b442450		MOVQ 0x50(SP), AX	
  0x433f7d		488b4830		MOVQ 0x30(AX), CX	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x433f81		488b542468		MOVQ 0x68(SP), DX	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433f86		488b5c2460		MOVQ 0x60(SP), BX	
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x433f8b		90			NOPL			
  0x433f8c		488b89e8000000		MOVQ 0xe8(CX), CX	
  0x433f93		48894c2440		MOVQ CX, 0x40(SP)	
  0x433f98		90			NOPL			
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x433f99		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x433f9a		90			NOPL			
  0x433f9b		488b92a8000000		MOVQ 0xa8(DX), DX	
  0x433fa2		4889542430		MOVQ DX, 0x30(SP)	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x433fa7		48635b08		MOVSXD 0x8(BX), BX	
  0x433fab		48895c2438		MOVQ BX, 0x38(SP)	
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x433fb0		e80bfffeff		CALL runtime.printlock(SB)	
  0x433fb5		488d0515b10300		LEAQ 0x3b115(IP), AX		
  0x433fbc		48890424		MOVQ AX, 0(SP)			
  0x433fc0		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x433fc9		e82208ffff		CALL runtime.printstring(SB)	
  0x433fce		488b442430		MOVQ 0x30(SP), AX		
  0x433fd3		48890424		MOVQ AX, 0(SP)			
  0x433fd7		e8d406ffff		CALL runtime.printhex(SB)	
  0x433fdc		488d05e2b00300		LEAQ 0x3b0e2(IP), AX		
  0x433fe3		48890424		MOVQ AX, 0(SP)			
  0x433fe7		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x433ff0		e8fb07ffff		CALL runtime.printstring(SB)	
  0x433ff5		488b442440		MOVQ 0x40(SP), AX		
  0x433ffa		48890424		MOVQ AX, 0(SP)			
  0x433ffe		e83d06ffff		CALL runtime.printint(SB)	
  0x434003		488d05f2b40300		LEAQ 0x3b4f2(IP), AX		
  0x43400a		48890424		MOVQ AX, 0(SP)			
  0x43400e		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x434017		e8d407ffff		CALL runtime.printstring(SB)	
  0x43401c		488b442438		MOVQ 0x38(SP), AX		
  0x434021		48890424		MOVQ AX, 0(SP)			
  0x434025		e81605ffff		CALL runtime.printuint(SB)	
  0x43402a		e82101ffff		CALL runtime.printnl(SB)	
  0x43402f		e80cfffeff		CALL runtime.printunlock(SB)	
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x434034		488b442450		MOVQ 0x50(SP), AX	
  0x434039		488b4830		MOVQ 0x30(AX), CX	
  0x43403d		4883b96801000000	CMPQ $0x0, 0x168(CX)	
  0x434045		0f8472020000		JE 0x4342bd		
  0x43404b		83b93801000000		CMPL $0x0, 0x138(CX)	
  0x434052		0f8e58020000		JLE 0x4342b0		
  0x434058		488b942498000000	MOVQ 0x98(SP), DX	
  0x434060		483911			CMPQ DX, 0(CX)		
  0x434063		0f840e020000		JE 0x434277		
		goroutineheader(gp)
  0x434069		4889942498000000	MOVQ DX, 0x98(SP)	
	print("\n")
  0x434071		e84afefeff		CALL runtime.printlock(SB)	
  0x434076		e8d500ffff		CALL runtime.printnl(SB)	
  0x43407b		e8c0fefeff		CALL runtime.printunlock(SB)	
	level, _, docrash := gotraceback()
  0x434080		90			NOPL			
	_g_ := getg()
  0x434081		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x43408a		8b0d7caf0800		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x434090		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x434094		0fb68029010000		MOVZX 0x129(AX), AX	
		level = int32(t >> tracebackShift)
  0x43409b		89ca			MOVL CX, DX		
  0x43409d		c1e902			SHRL $0x2, CX		
	if _g_.m.traceback != 0 {
  0x4340a0		84c0			TESTL AL, AL		
	level, _, docrash := gotraceback()
  0x4340a2		0f45c8			CMOVNE AX, CX		
	if level > 0 {
  0x4340a5		85c9			TESTL CX, CX		
	if _g_.m.traceback != 0 {
  0x4340a7		0f8f85000000		JG 0x434132		
	crash = t&tracebackCrash != 0
  0x4340ad		0fbae200		BTL $0x0, DX		
	if docrash {
  0x4340b1		732c			JAE 0x4340df		
		crashing++
  0x4340b3		8b05078c0a00		MOVL runtime.crashing(SB), AX	
  0x4340b9		ffc0			INCL AX				
  0x4340bb		8905ff8b0a00		MOVL AX, runtime.crashing(SB)	
		if crashing < mcount()-int32(extraMCount) {
  0x4340c1		90			NOPL			
	return int32(sched.mnext - sched.nmfreed)
  0x4340c2		488b0dffdb0800		MOVQ runtime.sched+40(SB), CX	
  0x4340c9		482b0d08dc0800		SUBQ runtime.sched+56(SB), CX	
		if crashing < mcount()-int32(extraMCount) {
  0x4340d0		2b0dee8b0a00		SUBL runtime.extraMCount(SB), CX	
  0x4340d6		39c8			CMPL CX, AX				
  0x4340d8		7c1b			JL 0x4340f5				
		crash()
  0x4340da		e8e1110000		CALL runtime.crash(SB)	
	exit(2)
  0x4340df		c7042402000000		MOVL $0x2, 0(SP)	
  0x4340e6		e8356d0100		CALL runtime.exit(SB)	
}
  0x4340eb		488b6c2470		MOVQ 0x70(SP), BP	
  0x4340f0		4883c478		ADDQ $0x78, SP		
  0x4340f4		c3			RET			
			print("\n-----\n\n")
  0x4340f5		e8c6fdfeff		CALL runtime.printlock(SB)	
  0x4340fa		488d054fb30300		LEAQ 0x3b34f(IP), AX		
  0x434101		48890424		MOVQ AX, 0(SP)			
  0x434105		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43410e		e8dd06ffff		CALL runtime.printstring(SB)	
  0x434113		e828fefeff		CALL runtime.printunlock(SB)	
			raiseproc(_SIGQUIT)
  0x434118		c7042403000000		MOVL $0x3, 0(SP)		
  0x43411f		e86c6e0100		CALL runtime.raiseproc(SB)	
			usleep(5 * 1000 * 1000)
  0x434124		c70424404b4c00		MOVL $runtime.timers+1280(SB), 0(SP)	
  0x43412b		e8d06d0100		CALL runtime.usleep(SB)			
  0x434130		eba8			JMP 0x4340da				
	t := atomic.Load(&traceback_cache)
  0x434132		8954242c		MOVL DX, 0x2c(SP)	
		goroutineheader(gp)
  0x434136		488b842498000000	MOVQ 0x98(SP), AX			
  0x43413e		48890424		MOVQ AX, 0(SP)				
  0x434142		e849c80000		CALL runtime.goroutineheader(SB)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x434147		488b442468		MOVQ 0x68(SP), AX	
		tracebacktrap(c.sigpc(), c.sigsp(), c.siglr(), gp)
  0x43414c		90			NOPL			
  0x43414d		90			NOPL			
  0x43414e		90			NOPL			
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x43414f		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x434150		90			NOPL			
  0x434151		488b88a8000000		MOVQ 0xa8(AX), CX	
func (c *sigctxt) sigsp() uintptr { return uintptr(c.rsp()) }
  0x434158		90			NOPL			
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x434159		90			NOPL			
  0x43415a		488b80a0000000		MOVQ 0xa0(AX), AX	
		tracebacktrap(c.sigpc(), c.sigsp(), c.siglr(), gp)
  0x434161		48890c24		MOVQ CX, 0(SP)			
  0x434165		4889442408		MOVQ AX, 0x8(SP)		
  0x43416a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x434173		488b842498000000	MOVQ 0x98(SP), AX		
  0x43417b		4889442418		MOVQ AX, 0x18(SP)		
  0x434180		e89bba0000		CALL runtime.tracebacktrap(SB)	
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x434185		833d348b0a0000		CMPL $0x0, runtime.crashing(SB)	
  0x43418c		0f8ed1000000		JLE 0x434263			
  0x434192		488b442450		MOVQ 0x50(SP), AX		
  0x434197		488b4830		MOVQ 0x30(AX), CX		
  0x43419b		488b89c0000000		MOVQ 0xc0(CX), CX		
  0x4341a2		488b942498000000	MOVQ 0x98(SP), DX		
  0x4341aa		4839ca			CMPQ CX, DX			
  0x4341ad		0f84a9000000		JE 0x43425c			
  0x4341b3		4885c9			TESTQ CX, CX			
  0x4341b6		0f8499000000		JE 0x434255			
  0x4341bc		90			NOPL				
	return atomic.Load(&gp.atomicstatus)
  0x4341bd		8b8990000000		MOVL 0x90(CX), CX	
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x4341c3		0fbaf10c		BTRL $0xc, CX		
  0x4341c7		83f902			CMPL $0x2, CX		
  0x4341ca		0f94c1			SETE CL			
  0x4341cd		84c9			TESTL CL, CL		
  0x4341cf		753a			JNE 0x43420b		
		} else if crashing == 0 {
  0x4341d1		833de88a0a0000		CMPL $0x0, runtime.crashing(SB)	
  0x4341d8		7417			JE 0x4341f1			
		dumpregs(c)
  0x4341da		488d442460		LEAQ 0x60(SP), AX		
  0x4341df		48890424		MOVQ AX, 0(SP)			
  0x4341e3		e8b8f3ffff		CALL runtime.dumpregs(SB)	
	crash = t&tracebackCrash != 0
  0x4341e8		8b54242c		MOVL 0x2c(SP), DX	
		dumpregs(c)
  0x4341ec		e9bcfeffff		JMP 0x4340ad		
			tracebackothers(gp)
  0x4341f1		48891424		MOVQ DX, 0(SP)				
  0x4341f5		e876ca0000		CALL runtime.tracebackothers(SB)	
			print("\n")
  0x4341fa		e8c1fcfeff		CALL runtime.printlock(SB)	
  0x4341ff		e84cfffeff		CALL runtime.printnl(SB)	
  0x434204		e837fdfeff		CALL runtime.printunlock(SB)	
  0x434209		ebcf			JMP 0x4341da			
			goroutineheader(_g_.m.curg)
  0x43420b		488b4830		MOVQ 0x30(AX), CX			
  0x43420f		488b89c0000000		MOVQ 0xc0(CX), CX			
  0x434216		48890c24		MOVQ CX, 0(SP)				
  0x43421a		e871c70000		CALL runtime.goroutineheader(SB)	
			traceback(^uintptr(0), ^uintptr(0), 0, _g_.m.curg)
  0x43421f		488b442450		MOVQ 0x50(SP), AX		
  0x434224		488b4030		MOVQ 0x30(AX), AX		
  0x434228		488b80c0000000		MOVQ 0xc0(AX), AX		
  0x43422f		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x434237		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x434240		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x434249		4889442418		MOVQ AX, 0x18(SP)		
  0x43424e		e85db90000		CALL runtime.traceback(SB)	
  0x434253		eb85			JMP 0x4341da			
  0x434255		31c9			XORL CX, CX			
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x434257		e971ffffff		JMP 0x4341cd		
  0x43425c		31c9			XORL CX, CX		
  0x43425e		e96affffff		JMP 0x4341cd		
			goroutineheader(_g_.m.curg)
  0x434263		488b442450		MOVQ 0x50(SP), AX	
			tracebackothers(gp)
  0x434268		488b942498000000	MOVQ 0x98(SP), DX	
  0x434270		31c9			XORL CX, CX		
		if crashing > 0 && gp != _g_.m.curg && _g_.m.curg != nil && readgstatus(_g_.m.curg)&^_Gscan == _Grunning {
  0x434272		e956ffffff		JMP 0x4341cd		
		print("signal arrived during cgo execution\n")
  0x434277		e844fcfeff		CALL runtime.printlock(SB)	
  0x43427c		488d0584e30300		LEAQ 0x3e384(IP), AX		
  0x434283		48890424		MOVQ AX, 0(SP)			
  0x434287		48c744240824000000	MOVQ $0x24, 0x8(SP)		
  0x434290		e85b05ffff		CALL runtime.printstring(SB)	
  0x434295		e8a6fcfeff		CALL runtime.printunlock(SB)	
		gp = _g_.m.lockedg.ptr()
  0x43429a		488b442450		MOVQ 0x50(SP), AX	
  0x43429f		488b4830		MOVQ 0x30(AX), CX	
  0x4342a3		488b9168010000		MOVQ 0x168(CX), DX	
  0x4342aa		90			NOPL			
  0x4342ab		e9b9fdffff		JMP 0x434069		
		goroutineheader(gp)
  0x4342b0		488b942498000000	MOVQ 0x98(SP), DX	
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x4342b8		e9acfdffff		JMP 0x434069		
		goroutineheader(gp)
  0x4342bd		488b942498000000	MOVQ 0x98(SP), DX	
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x4342c5		e99ffdffff		JMP 0x434069		
		print("Signal ", sig, "\n")
  0x4342ca		e8f1fbfeff		CALL runtime.printlock(SB)	
  0x4342cf		488d0522b00300		LEAQ 0x3b022(IP), AX		
  0x4342d6		48890424		MOVQ AX, 0(SP)			
  0x4342da		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4342e3		e80805ffff		CALL runtime.printstring(SB)	
  0x4342e8		8b842480000000		MOVL 0x80(SP), AX		
  0x4342ef		48890424		MOVQ AX, 0(SP)			
  0x4342f3		e84802ffff		CALL runtime.printuint(SB)	
  0x4342f8		e853fefeff		CALL runtime.printnl(SB)	
  0x4342fd		e83efcfeff		CALL runtime.printunlock(SB)	
  0x434302		e971fcffff		JMP 0x433f78			
		startpanic_m()
  0x434307		e884f4feff		CALL runtime.startpanic_m(SB)	
	if sig < uint32(len(sigtable)) {
  0x43430c		8b8c2480000000		MOVL 0x80(SP), CX	
  0x434313		83f941			CMPL $0x41, CX		
	print("PC=", hex(c.sigpc()), " m=", _g_.m.id, " sigcode=", c.sigcode(), "\n")
  0x434316		488b442450		MOVQ 0x50(SP), AX	
	if _g_.m.lockedg != 0 && _g_.m.ncgo > 0 && gp == _g_.m.g0 {
  0x43431b		488bb42498000000	MOVQ 0x98(SP), SI	
		startpanic_m()
  0x434323		e9fafbffff		JMP 0x433f22		
		return
  0x434328		488b6c2470		MOVQ 0x70(SP), BP	
  0x43432d		4883c478		ADDQ $0x78, SP		
  0x434331		c3			RET			
		dieFromSignal(sig)
  0x434332		890c24			MOVL CX, 0(SP)			
  0x434335		e8c60d0000		CALL runtime.dieFromSignal(SB)	
	if flags&_SigThrow == 0 {
  0x43433a		8b442428		MOVL 0x28(SP), AX	
	if sig < uint32(len(sigtable)) {
  0x43433e		8b8c2480000000		MOVL 0x80(SP), CX	
		dieFromSignal(sig)
  0x434345		e994fbffff		JMP 0x433ede		
		return
  0x43434a		488b6c2470		MOVQ 0x70(SP), BP	
  0x43434f		4883c478		ADDQ $0x78, SP		
  0x434353		c3			RET			
	if sig < uint32(len(sigtable)) {
  0x434354		8b8c2480000000		MOVL 0x80(SP), CX	
  0x43435b		31c0			XORL AX, AX		
	if c.sigcode() == _SI_USER && signal_ignored(sig) {
  0x43435d		e966fbffff		JMP 0x433ec8		
			return
  0x434362		488b6c2470		MOVQ 0x70(SP), BP	
  0x434367		4883c478		ADDQ $0x78, SP		
  0x43436b		c3			RET			
	if c.sigcode() == _SI_USER || flags&_SigNotify != 0 {
  0x43436c		0fbae100		BTL $0x0, CX		
  0x434370		0f8202fbffff		JB 0x433e78		
  0x434376		e910fbffff		JMP 0x433e8b		
		gp.sig = sig
  0x43437b		89b3e0000000		MOVL SI, 0xe0(BX)	
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x434381		488b442460		MOVQ 0x60(SP), AX	
		gp.sigcode0 = uintptr(c.sigcode())
  0x434386		90			NOPL			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x434387		48634008		MOVSXD 0x8(AX), AX	
		gp.sigcode0 = uintptr(c.sigcode())
  0x43438b		48898300010000		MOVQ AX, 0x100(BX)	
func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }
  0x434392		488b442460		MOVQ 0x60(SP), AX	
		gp.sigcode1 = uintptr(c.fault())
  0x434397		90			NOPL			
func (c *sigctxt) fault() uintptr { return uintptr(c.sigaddr()) }
  0x434398		90			NOPL			
func (c *sigctxt) sigaddr() uint64 { return c.info.si_addr }
  0x434399		488b4010		MOVQ 0x10(AX), AX	
		gp.sigcode1 = uintptr(c.fault())
  0x43439d		48898308010000		MOVQ AX, 0x108(BX)	
	return (*sigcontext)(unsafe.Pointer(&(*ucontext)(c.ctxt).uc_mcontext))
  0x4343a4		488b442468		MOVQ 0x68(SP), AX	
		gp.sigpc = c.sigpc()
  0x4343a9		90			NOPL			
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x4343aa		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x4343ab		90			NOPL			
  0x4343ac		488b80a8000000		MOVQ 0xa8(AX), AX	
		gp.sigpc = c.sigpc()
  0x4343b3		48898310010000		MOVQ AX, 0x110(BX)	
		c.preparePanic(sig, gp)
  0x4343ba		488d442460		LEAQ 0x60(SP), AX				
  0x4343bf		48890424		MOVQ AX, 0(SP)					
  0x4343c3		89742408		MOVL SI, 0x8(SP)				
  0x4343c7		48895c2410		MOVQ BX, 0x10(SP)				
  0x4343cc		e8bff8ffff		CALL runtime.(*sigctxt).preparePanic(SB)	
		return
  0x4343d1		488b6c2470		MOVQ 0x70(SP), BP	
  0x4343d6		4883c478		ADDQ $0x78, SP		
  0x4343da		c3			RET			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4343db		488b9c2498000000	MOVQ 0x98(SP), BX	
	if flags&_SigPanic != 0 && gp.throwsplit {
  0x4343e3		e93efaffff		JMP 0x433e26			
  0x4343e8		488d1591be0800		LEAQ runtime.sigtable(SB), DX	
  0x4343ef		b904000000		MOVL $0x4, CX			
	if sig < uint32(len(sigtable)) {
  0x4343f4		e90cfaffff		JMP 0x433e05		
		return
  0x4343f9		488b6c2470		MOVQ 0x70(SP), BP	
  0x4343fe		4883c478		ADDQ $0x78, SP		
  0x434402		c3			RET			
	if sig == _SIGTRAP && testSigtrap != nil && testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) {
  0x434403		90			NOPL			
  0x434404		48890c24		MOVQ CX, 0(SP)		
  0x434408		488d442460		LEAQ 0x60(SP), AX	
  0x43440d		4889442408		MOVQ AX, 0x8(SP)	
  0x434412		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x43441a		48894c2410		MOVQ CX, 0x10(SP)	
  0x43441f		488b1a			MOVQ 0(DX), BX		
  0x434422		ffd3			CALL BX			
  0x434424		0fb64c2418		MOVZX 0x18(SP), CX	
	_g_.m.throwing = 1
  0x434429		488b442450		MOVQ 0x50(SP), AX	
	if sig < uint32(len(sigtable)) {
  0x43442e		8bb42480000000		MOVL 0x80(SP), SI	
	if sig == _SIGTRAP && testSigtrap != nil && testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) {
  0x434435		e9a2f9ffff		JMP 0x433ddc		
  0x43443a		31c9			XORL CX, CX		
  0x43443c		e99bf9ffff		JMP 0x433ddc		
		sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m)
  0x434441		90			NOPL			
  0x434442		90			NOPL			
  0x434443		90			NOPL			
  0x434444		488b4030		MOVQ 0x30(AX), AX	
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x434448		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x434449		90			NOPL			
  0x43444a		488b8ba8000000		MOVQ 0xa8(BX), CX	
func (c *sigctxt) sigsp() uintptr { return uintptr(c.rsp()) }
  0x434451		90			NOPL			
func (c *sigctxt) rsp() uint64 { return c.regs().rsp }
  0x434452		90			NOPL			
  0x434453		488b93a0000000		MOVQ 0xa0(BX), DX	
		sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, _g_.m)
  0x43445a		48890c24		MOVQ CX, 0(SP)			
  0x43445e		4889542408		MOVQ DX, 0x8(SP)		
  0x434463		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43446c		488b8c2498000000	MOVQ 0x98(SP), CX		
  0x434474		48894c2418		MOVQ CX, 0x18(SP)		
  0x434479		4889442420		MOVQ AX, 0x20(SP)		
  0x43447e		e83d8fffff		CALL runtime.sigprof(SB)	
		return
  0x434483		488b6c2470		MOVQ 0x70(SP), BP	
  0x434488		4883c478		ADDQ $0x78, SP		
  0x43448c		c3			RET			
		print(sigtable[sig].name, "\n")
  0x43448d		e88edafeff		CALL runtime.panicindex(SB)	
  0x434492		0f0b			UD2				
	i := atomic.Load(&sig.ignored[s/32])
  0x434494		e887dafeff		CALL runtime.panicindex(SB)	
  0x434499		0f0b			UD2				
		flags = sigtable[sig].flags
  0x43449b		e880dafeff		CALL runtime.panicindex(SB)	
  0x4344a0		0f0b			UD2				
func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
  0x4344a2		e8d9330100		CALL runtime.morestack_noctxt(SB)	
  0x4344a7		e9b4f8ffff		JMP runtime.sighandler(SB)		

TEXT runtime.init.6(SB) /usr/local/go/src/runtime/signal_unix.go
func init() {
  0x4344b0		c3			RET			

TEXT runtime.initsig(SB) /usr/local/go/src/runtime/signal_unix.go
func initsig(preinit bool) {
  0x4344c0		4883ec50		SUBQ $0x50, SP		
  0x4344c4		48896c2448		MOVQ BP, 0x48(SP)	
  0x4344c9		488d6c2448		LEAQ 0x48(SP), BP	
  0x4344ce		0fb6442458		MOVZX 0x58(SP), AX	
  0x4344d3		84c0			TESTL AL, AL		
	if !preinit {
  0x4344d5		0f84be010000		JE 0x434699		
	if (isarchive || islibrary) && !preinit {
  0x4344db		803dcb870a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x4344e2		0f849d010000		JE 0x434685				
func initsig(preinit bool) {
  0x4344e8		84c0			TESTL AL, AL		
	if (isarchive || islibrary) && !preinit {
  0x4344ea		0f848b010000		JE 0x43467b		
  0x4344f0		31c0			XORL AX, AX		
	for i := uint32(0); i < _NSIG; i++ {
  0x4344f2		eb02			JMP 0x4344f6		
  0x4344f4		ffc0			INCL AX			
  0x4344f6		83f841			CMPL $0x41, AX		
  0x4344f9		0f8372010000		JAE 0x434671		
		t := &sigtable[i]
  0x4344ff		4883f841		CMPQ $0x41, AX		
  0x434503		0f83a3010000		JAE 0x4346ac		
  0x434509		488d0c40		LEAQ 0(AX)(AX*2), CX	
		if t.flags == 0 || t.flags&_SigDefault != 0 {
  0x43450d		488d156cbd0800		LEAQ runtime.sigtable(SB), DX	
  0x434514		8b1cca			MOVL 0(DX)(CX*8), BX		
  0x434517		85db			TESTL BX, BX			
  0x434519		74d9			JE 0x4344f4			
  0x43451b		0fbae304		BTL $0x4, BX			
  0x43451f		72d3			JB 0x4344f4			
	for i := uint32(0); i < _NSIG; i++ {
  0x434521		8944241c		MOVL AX, 0x1c(SP)	
		t := &sigtable[i]
  0x434525		48894c2420		MOVQ CX, 0x20(SP)	
		fwdSig[i] = getsig(i)
  0x43452a		90			NOPL			
	var sa sigactiont
  0x43452b		0f57c0			XORPS X0, X0		
  0x43452e		0f11442428		MOVUPS X0, 0x28(SP)	
  0x434533		0f11442438		MOVUPS X0, 0x38(SP)	
	sigaction(i, nil, &sa)
  0x434538		890424			MOVL AX, 0(SP)			
  0x43453b		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x434544		488d4c2428		LEAQ 0x28(SP), CX		
  0x434549		48894c2410		MOVQ CX, 0x10(SP)		
  0x43454e		e83df1fcff		CALL runtime.sigaction(SB)	
	return sa.sa_handler
  0x434553		488b442428		MOVQ 0x28(SP), AX	
		fwdSig[i] = getsig(i)
  0x434558		8b4c241c		MOVL 0x1c(SP), CX		
  0x43455c		488d15dd900a00		LEAQ runtime.fwdSig(SB), DX	
  0x434563		488904ca		MOVQ AX, 0(DX)(CX*8)		
		if !sigInstallGoHandler(i) {
  0x434567		90			NOPL			
	case _SIGHUP, _SIGINT:
  0x434568		8d41ff			LEAL -0x1(CX), AX	
  0x43456b		83f801			CMPL $0x1, AX		
  0x43456e		0f87b1000000		JA 0x434625		
		fwdSig[i] = getsig(i)
  0x434574		488d04ca		LEAQ 0(DX)(CX*8), AX	
		if atomic.Loaduintptr(&fwdSig[sig]) == _SIG_IGN {
  0x434578		488b00			MOVQ 0(AX), AX		
  0x43457b		4883f801		CMPQ $0x1, AX		
  0x43457f		0f85a0000000		JNE 0x434625		
  0x434585		31c0			XORL AX, AX		
		if !sigInstallGoHandler(i) {
  0x434587		84c0			TESTL AL, AL		
  0x434589		755d			JNE 0x4345e8		
			if fwdSig[i] != _SIG_DFL && fwdSig[i] != _SIG_IGN {
  0x43458b		488b04ca		MOVQ 0(DX)(CX*8), AX	
  0x43458f		4885c0			TESTQ AX, AX		
  0x434592		7406			JE 0x43459a		
  0x434594		4883f801		CMPQ $0x1, AX		
  0x434598		7539			JNE 0x4345d3		
			} else if fwdSig[i] == _SIG_IGN {
  0x43459a		4883f801		CMPQ $0x1, AX		
  0x43459e		752f			JNE 0x4345cf		
				sigInitIgnored(i)
  0x4345a0		90			NOPL			
	i := sig.ignored[s/32]
  0x4345a1		89c8			MOVL CX, AX			
  0x4345a3		c1e905			SHRL $0x5, CX			
  0x4345a6		4883f903		CMPQ $0x3, CX			
  0x4345aa		0f83f5000000		JAE 0x4346a5			
  0x4345b0		488d1dc9890a00		LEAQ runtime.sig+32(SB), BX	
  0x4345b7		8b348b			MOVL 0(BX)(CX*4), SI		
  0x4345ba		488d0c8b		LEAQ 0(BX)(CX*4), CX		
	i |= 1 << (s & 31)
  0x4345be		0fabc6			BTSL AX, SI		
	atomic.Store(&sig.ignored[s/32], i)
  0x4345c1		8731			XCHGL SI, 0(CX)		
		t := &sigtable[i]
  0x4345c3		488d15b6bc0800		LEAQ runtime.sigtable(SB), DX	
			continue
  0x4345ca		e925ffffff		JMP 0x4344f4		
	for i := uint32(0); i < _NSIG; i++ {
  0x4345cf		89c8			MOVL CX, AX		
			} else if fwdSig[i] == _SIG_IGN {
  0x4345d1		ebf0			JMP 0x4345c3		
				setsigstack(i)
  0x4345d3		890c24			MOVL CX, 0(SP)			
  0x4345d6		e895d7feff		CALL runtime.setsigstack(SB)	
	for i := uint32(0); i < _NSIG; i++ {
  0x4345db		8b44241c		MOVL 0x1c(SP), AX		
  0x4345df		488d155a900a00		LEAQ runtime.fwdSig(SB), DX	
				setsigstack(i)
  0x4345e6		ebdb			JMP 0x4345c3		
		handlingSig[i] = 1
  0x4345e8		488d05318d0a00		LEAQ runtime.handlingSig(SB), AX	
  0x4345ef		c7048801000000		MOVL $0x1, 0(AX)(CX*4)			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x4345f6		488d156bf30300		LEAQ 0x3f36b(IP), DX	
  0x4345fd		8402			TESTB AL, 0(DX)		
		setsig(i, funcPC(sighandler))
  0x4345ff		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x434600		488b1d61f30300		MOVQ 0x3f361(IP), BX	
  0x434607		90			NOPL			
		setsig(i, funcPC(sighandler))
  0x434608		890c24			MOVL CX, 0(SP)		
  0x43460b		48895c2408		MOVQ BX, 0x8(SP)	
  0x434610		e89bd6feff		CALL runtime.setsig(SB)	
	for i := uint32(0); i < _NSIG; i++ {
  0x434615		8b44241c		MOVL 0x1c(SP), AX		
  0x434619		488d1560bc0800		LEAQ runtime.sigtable(SB), DX	
		setsig(i, funcPC(sighandler))
  0x434620		e9cffeffff		JMP 0x4344f4		
	if t.flags&_SigSetStack != 0 {
  0x434625		488b442420		MOVQ 0x20(SP), AX		
  0x43462a		488d1d4fbc0800		LEAQ runtime.sigtable(SB), BX	
  0x434631		8b04c3			MOVL 0(BX)(AX*8), AX		
  0x434634		0fbae006		BTL $0x6, AX			
  0x434638		7307			JAE 0x434641			
  0x43463a		31c0			XORL AX, AX			
		if !sigInstallGoHandler(i) {
  0x43463c		e946ffffff		JMP 0x434587		
	if (isarchive || islibrary) && t.flags&_SigPanic == 0 && sig != _SIGPIPE {
  0x434641		803d65860a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x434648		741c			JE 0x434666				
  0x43464a		0fbae003		BTL $0x3, AX				
  0x43464e		720c			JB 0x43465c				
  0x434650		83f90d			CMPL $0xd, CX				
  0x434653		7407			JE 0x43465c				
  0x434655		31c0			XORL AX, AX				
		if !sigInstallGoHandler(i) {
  0x434657		e92bffffff		JMP 0x434587		
  0x43465c		b801000000		MOVL $0x1, AX		
  0x434661		e921ffffff		JMP 0x434587		
	if (isarchive || islibrary) && t.flags&_SigPanic == 0 && sig != _SIGPIPE {
  0x434666		803d42860a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x43466d		75db			JNE 0x43464a				
  0x43466f		ebeb			JMP 0x43465c				
  0x434671		488b6c2448		MOVQ 0x48(SP), BP			
  0x434676		4883c450		ADDQ $0x50, SP				
  0x43467a		c3			RET					
		return
  0x43467b		488b6c2448		MOVQ 0x48(SP), BP	
  0x434680		4883c450		ADDQ $0x50, SP		
  0x434684		c3			RET			
	if (isarchive || islibrary) && !preinit {
  0x434685		803d23860a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x43468c		0f845efeffff		JE 0x4344f0				
func initsig(preinit bool) {
  0x434692		84c0			TESTL AL, AL		
	if (isarchive || islibrary) && !preinit {
  0x434694		e951feffff		JMP 0x4344ea		
		signalsOK = true
  0x434699		c60512860a0001		MOVB $0x1, runtime.signalsOK(SB)	
  0x4346a0		e936feffff		JMP 0x4344db				
	i := sig.ignored[s/32]
  0x4346a5		e876d8feff		CALL runtime.panicindex(SB)	
  0x4346aa		0f0b			UD2				
		t := &sigtable[i]
  0x4346ac		e86fd8feff		CALL runtime.panicindex(SB)	
  0x4346b1		0f0b			UD2				

TEXT runtime.setThreadCPUProfiler(SB) /usr/local/go/src/runtime/signal_unix.go
func setThreadCPUProfiler(hz int32) {
  0x4346c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4346c9		483b6110		CMPQ 0x10(CX), SP	
  0x4346cd		0f86b7000000		JBE 0x43478a		
  0x4346d3		4883ec40		SUBQ $0x40, SP		
  0x4346d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4346dc		488d6c2438		LEAQ 0x38(SP), BP	
	var it itimerval
  0x4346e1		0f57c0			XORPS X0, X0		
  0x4346e4		0f11442418		MOVUPS X0, 0x18(SP)	
  0x4346e9		0f11442428		MOVUPS X0, 0x28(SP)	
	if hz == 0 {
  0x4346ee		8b4c2448		MOVL 0x48(SP), CX	
  0x4346f2		85c9			TESTL CX, CX		
  0x4346f4		7540			JNE 0x434736		
		setitimer(_ITIMER_PROF, &it, nil)
  0x4346f6		c7042402000000		MOVL $0x2, 0(SP)		
  0x4346fd		488d442418		LEAQ 0x18(SP), AX		
  0x434702		4889442408		MOVQ AX, 0x8(SP)		
  0x434707		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x434710		e89b680100		CALL runtime.setitimer(SB)	
	_g_ := getg()
  0x434715		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.profilehz = hz
  0x43471e		488b4030		MOVQ 0x30(AX), AX	
  0x434722		8b4c2448		MOVL 0x48(SP), CX	
  0x434726		898810010000		MOVL CX, 0x110(AX)	
}
  0x43472c		488b6c2438		MOVQ 0x38(SP), BP	
  0x434731		4883c440		ADDQ $0x40, SP		
  0x434735		c3			RET			
		it.it_interval.set_usec(1000000 / hz)
  0x434736		b840420f00		MOVL $0xf4240, AX	
  0x43473b		83f9ff			CMPL $-0x1, CX		
  0x43473e		7405			JE 0x434745		
  0x434740		99			CDQ			
  0x434741		f7f9			IDIVL CX		
  0x434743		eb04			JMP 0x434749		
  0x434745		f7d8			NEGL AX			
  0x434747		31d2			XORL DX, DX		
		it.it_interval.tv_sec = 0
  0x434749		48c744241800000000	MOVQ $0x0, 0x18(SP)	
		it.it_interval.set_usec(1000000 / hz)
  0x434752		90			NOPL			
	tv.tv_usec = int64(x)
  0x434753		4863d0			MOVSXD AX, DX		
  0x434756		4889542420		MOVQ DX, 0x20(SP)	
		it.it_value = it.it_interval
  0x43475b		48c744242800000000	MOVQ $0x0, 0x28(SP)	
  0x434764		4889542430		MOVQ DX, 0x30(SP)	
		setitimer(_ITIMER_PROF, &it, nil)
  0x434769		c7042402000000		MOVL $0x2, 0(SP)		
  0x434770		488d542418		LEAQ 0x18(SP), DX		
  0x434775		4889542408		MOVQ DX, 0x8(SP)		
  0x43477a		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x434783		e828680100		CALL runtime.setitimer(SB)	
  0x434788		eb8b			JMP 0x434715			
func setThreadCPUProfiler(hz int32) {
  0x43478a		e8f1300100		CALL runtime.morestack_noctxt(SB)	
  0x43478f		e92cffffff		JMP runtime.setThreadCPUProfiler(SB)	

TEXT runtime.sigtrampgo(SB) /usr/local/go/src/runtime/signal_unix.go
func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {
  0x4347a0		4881eca8000000		SUBQ $0xa8, SP		
  0x4347a7		4889ac24a0000000	MOVQ BP, 0xa0(SP)	
  0x4347af		488dac24a0000000	LEAQ 0xa0(SP), BP	
	if sigfwdgo(sig, info, ctx) {
  0x4347b7		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x4347be		890424			MOVL AX, 0(SP)			
  0x4347c1		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x4347c9		4889442408		MOVQ AX, 0x8(SP)		
  0x4347ce		488b8c24c0000000	MOVQ 0xc0(SP), CX		
  0x4347d6		48894c2410		MOVQ CX, 0x10(SP)		
  0x4347db		e8200d0000		CALL runtime.sigfwdgo(SB)	
  0x4347e0		807c241800		CMPB $0x0, 0x18(SP)		
  0x4347e5		0f8537040000		JNE 0x434c22			
	g := getg()
  0x4347eb		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g == nil {
  0x4347f4		4885c0			TESTQ AX, AX		
  0x4347f7		0f84b1030000		JE 0x434bae		
	g := getg()
  0x4347fd		4889442458		MOVQ AX, 0x58(SP)	
	var gsignalStack gsignalStack
  0x434802		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x43480b		0f57c0			XORPS X0, X0		
  0x43480e		0f11442438		MOVUPS X0, 0x38(SP)	
  0x434813		0f11442448		MOVUPS X0, 0x48(SP)	
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x434818		488b4830		MOVQ 0x30(AX), CX	
  0x43481c		488b5150		MOVQ 0x50(CX), DX	
	sp := uintptr(unsafe.Pointer(&sig))
  0x434820		488d9c24b0000000	LEAQ 0xb0(SP), BX	
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x434828		48391a			CMPQ BX, 0(DX)		
  0x43482b		0f866c030000		JBE 0x434b9d		
	sp := uintptr(unsafe.Pointer(&sig))
  0x434831		48895c2428		MOVQ BX, 0x28(SP)	
		if sp >= g.m.g0.stack.lo && sp < g.m.g0.stack.hi {
  0x434836		488b09			MOVQ 0(CX), CX		
  0x434839		483919			CMPQ BX, 0(CX)		
  0x43483c		0f87d1010000		JA 0x434a13		
  0x434842		48395908		CMPQ BX, 0x8(CX)	
  0x434846		0f86c7010000		JBE 0x434a13		
			st := stackt{ss_size: g.m.g0.stack.hi - g.m.g0.stack.lo}
  0x43484c		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x434855		0f11442478		MOVUPS X0, 0x78(SP)	
  0x43485a		488b4830		MOVQ 0x30(AX), CX	
  0x43485e		488b09			MOVQ 0(CX), CX		
  0x434861		488b5108		MOVQ 0x8(CX), DX	
  0x434865		482b11			SUBQ 0(CX), DX		
  0x434868		4889942480000000	MOVQ DX, 0x80(SP)	
			setSignalstackSP(&st, g.m.g0.stack.lo)
  0x434870		488b4830		MOVQ 0x30(AX), CX	
  0x434874		488b09			MOVQ 0(CX), CX		
  0x434877		90			NOPL			
  0x434878		488b09			MOVQ 0(CX), CX		
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x43487b		48894c2470		MOVQ CX, 0x70(SP)	
	g := getg()
  0x434880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
		old.stack = g.m.gsignal.stack
  0x434889		488b5130		MOVQ 0x30(CX), DX	
  0x43488d		488b5250		MOVQ 0x50(DX), DX	
			setGsignalStack(&st, &gsignalStack)
  0x434891		90			NOPL			
		old.stack = g.m.gsignal.stack
  0x434892		488b5a08		MOVQ 0x8(DX), BX	
  0x434896		488b12			MOVQ 0(DX), DX		
  0x434899		4889542430		MOVQ DX, 0x30(SP)	
  0x43489e		48895c2438		MOVQ BX, 0x38(SP)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x4348a3		488b5130		MOVQ 0x30(CX), DX	
  0x4348a7		488b5250		MOVQ 0x50(DX), DX	
  0x4348ab		488b5210		MOVQ 0x10(DX), DX	
  0x4348af		4889542440		MOVQ DX, 0x40(SP)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x4348b4		488b5130		MOVQ 0x30(CX), DX	
  0x4348b8		488b5250		MOVQ 0x50(DX), DX	
  0x4348bc		488b5218		MOVQ 0x18(DX), DX	
  0x4348c0		4889542448		MOVQ DX, 0x48(SP)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x4348c5		488b5130		MOVQ 0x30(CX), DX	
  0x4348c9		488b5250		MOVQ 0x50(DX), DX	
  0x4348cd		488b9280000000		MOVQ 0x80(DX), DX	
  0x4348d4		4889542450		MOVQ DX, 0x50(SP)	
	g.m.gsignal.stack.lo = stsp
  0x4348d9		488b5130		MOVQ 0x30(CX), DX	
  0x4348dd		488b5250		MOVQ 0x50(DX), DX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x4348e1		488b5c2470		MOVQ 0x70(SP), BX	
	g.m.gsignal.stack.lo = stsp
  0x4348e6		48891a			MOVQ BX, 0(DX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x4348e9		488b5130		MOVQ 0x30(CX), DX	
  0x4348ed		488b5250		MOVQ 0x50(DX), DX	
  0x4348f1		488bb42480000000	MOVQ 0x80(SP), SI	
  0x4348f9		4801de			ADDQ BX, SI		
  0x4348fc		48897208		MOVQ SI, 0x8(DX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x434900		488b5130		MOVQ 0x30(CX), DX	
  0x434904		488b5250		MOVQ 0x50(DX), DX	
  0x434908		4881c370030000		ADDQ $0x370, BX		
  0x43490f		48895a10		MOVQ BX, 0x10(DX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x434913		488b4930		MOVQ 0x30(CX), CX	
  0x434917		488b4950		MOVQ 0x50(CX), CX	
  0x43491b		48895918		MOVQ BX, 0x18(CX)	
			g.m.gsignal.stktopsp = getcallersp()
  0x43491f		488b4830		MOVQ 0x30(AX), CX	
  0x434923		488b4950		MOVQ 0x50(CX), CX	
  0x434927		488d9424b0000000	LEAQ 0xb0(SP), DX	
  0x43492f		48899180000000		MOVQ DX, 0x80(CX)	
	setg(g.m.gsignal)
  0x434936		b901000000		MOVL $0x1, CX		
	if setStack {
  0x43493b		884c2427		MOVB CL, 0x27(SP)	
	setg(g.m.gsignal)
  0x43493f		488b5030		MOVQ 0x30(AX), DX	
  0x434943		488b5250		MOVQ 0x50(DX), DX	
  0x434947		48891424		MOVQ DX, 0(SP)		
  0x43494b		e870460100		CALL runtime.setg(SB)	
	if g.stackguard0 == stackFork {
  0x434950		488b442458		MOVQ 0x58(SP), AX	
  0x434955		488178102efbffff	CMPQ $-0x4d2, 0x10(AX)	
  0x43495d		0f8497000000		JE 0x4349fa		
	c.fixsigcode(sig)
  0x434963		90			NOPL			
	sighandler(sig, info, ctx, g)
  0x434964		8b8c24b0000000		MOVL 0xb0(SP), CX		
  0x43496b		890c24			MOVL CX, 0(SP)			
  0x43496e		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x434976		48894c2408		MOVQ CX, 0x8(SP)		
  0x43497b		488b8c24c0000000	MOVQ 0xc0(SP), CX		
  0x434983		48894c2410		MOVQ CX, 0x10(SP)		
  0x434988		4889442418		MOVQ AX, 0x18(SP)		
  0x43498d		e8cef3ffff		CALL runtime.sighandler(SB)	
	setg(g)
  0x434992		488b442458		MOVQ 0x58(SP), AX	
  0x434997		48890424		MOVQ AX, 0(SP)		
  0x43499b		e820460100		CALL runtime.setg(SB)	
	if setStack {
  0x4349a0		0fb6442427		MOVZX 0x27(SP), AX	
  0x4349a5		84c0			TESTL AL, AL		
  0x4349a7		7441			JE 0x4349ea		
	gp := getg().m.gsignal
  0x4349a9		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4349b2		488b4030		MOVQ 0x30(AX), AX	
  0x4349b6		488b4050		MOVQ 0x50(AX), AX	
		restoreGsignalStack(&gsignalStack)
  0x4349ba		90			NOPL			
	gp.stack = st.stack
  0x4349bb		488b4c2438		MOVQ 0x38(SP), CX	
  0x4349c0		488b542430		MOVQ 0x30(SP), DX	
  0x4349c5		488910			MOVQ DX, 0(AX)		
  0x4349c8		48894808		MOVQ CX, 0x8(AX)	
	gp.stackguard0 = st.stackguard0
  0x4349cc		488b4c2440		MOVQ 0x40(SP), CX	
  0x4349d1		48894810		MOVQ CX, 0x10(AX)	
	gp.stackguard1 = st.stackguard1
  0x4349d5		488b4c2448		MOVQ 0x48(SP), CX	
  0x4349da		48894818		MOVQ CX, 0x18(AX)	
	gp.stktopsp = st.stktopsp
  0x4349de		488b4c2450		MOVQ 0x50(SP), CX	
  0x4349e3		48898880000000		MOVQ CX, 0x80(AX)	
  0x4349ea		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x4349f2		4881c4a8000000		ADDQ $0xa8, SP		
  0x4349f9		c3			RET			
		signalDuringFork(sig)
  0x4349fa		8b8424b0000000		MOVL 0xb0(SP), AX			
  0x434a01		890424			MOVL AX, 0(SP)				
  0x434a04		e8070a0000		CALL runtime.signalDuringFork(SB)	
	sighandler(sig, info, ctx, g)
  0x434a09		488b442458		MOVQ 0x58(SP), AX	
		signalDuringFork(sig)
  0x434a0e		e950ffffff		JMP 0x434963		
			var st stackt
  0x434a13		48c784248800000000000000	MOVQ $0x0, 0x88(SP)	
  0x434a1f		0f11842490000000		MOVUPS X0, 0x90(SP)	
			sigaltstack(nil, &st)
  0x434a27		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x434a2f		488d842488000000	LEAQ 0x88(SP), AX		
  0x434a37		4889442408		MOVQ AX, 0x8(SP)		
  0x434a3c		e82f6b0100		CALL runtime.sigaltstack(SB)	
			if st.ss_flags&_SS_DISABLE != 0 {
  0x434a41		8b842490000000		MOVL 0x90(SP), AX	
  0x434a48		0fbae001		BTL $0x1, AX		
  0x434a4c		0f821c010000		JB 0x434b6e		
			stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x434a52		488b842488000000	MOVQ 0x88(SP), AX	
			if sp < stsp || sp >= stsp+st.ss_size {
  0x434a5a		488b4c2428		MOVQ 0x28(SP), CX	
  0x434a5f		4839c1			CMPQ AX, CX		
  0x434a62		0f83ed000000		JAE 0x434b55		
				setg(nil)
  0x434a68		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x434a70		e84b450100		CALL runtime.setg(SB)	
				needm(0)
  0x434a75		c6042400		MOVB $0x0, 0(SP)	
  0x434a79		e8323affff		CALL runtime.needm(SB)	
				sigNotOnStack(sig)
  0x434a7e		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x434a85		890424			MOVL AX, 0(SP)			
  0x434a88		e8f3080000		CALL runtime.sigNotOnStack(SB)	
				dropm()
  0x434a8d		e8ee3dffff		CALL runtime.dropm(SB)	
	g := getg()
  0x434a92		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
		old.stack = g.m.gsignal.stack
  0x434a9b		488b5130		MOVQ 0x30(CX), DX	
  0x434a9f		488b5250		MOVQ 0x50(DX), DX	
			setGsignalStack(&st, &gsignalStack)
  0x434aa3		90			NOPL			
		old.stack = g.m.gsignal.stack
  0x434aa4		488b5a08		MOVQ 0x8(DX), BX	
  0x434aa8		488b12			MOVQ 0(DX), DX		
  0x434aab		4889542430		MOVQ DX, 0x30(SP)	
  0x434ab0		48895c2438		MOVQ BX, 0x38(SP)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x434ab5		488b5130		MOVQ 0x30(CX), DX	
  0x434ab9		488b5250		MOVQ 0x50(DX), DX	
  0x434abd		488b5210		MOVQ 0x10(DX), DX	
  0x434ac1		4889542440		MOVQ DX, 0x40(SP)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x434ac6		488b5130		MOVQ 0x30(CX), DX	
  0x434aca		488b5250		MOVQ 0x50(DX), DX	
  0x434ace		488b5218		MOVQ 0x18(DX), DX	
  0x434ad2		4889542448		MOVQ DX, 0x48(SP)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x434ad7		488b5130		MOVQ 0x30(CX), DX	
  0x434adb		488b5250		MOVQ 0x50(DX), DX	
  0x434adf		488b9280000000		MOVQ 0x80(DX), DX	
  0x434ae6		4889542450		MOVQ DX, 0x50(SP)	
	g.m.gsignal.stack.lo = stsp
  0x434aeb		488b5130		MOVQ 0x30(CX), DX	
  0x434aef		488b5250		MOVQ 0x50(DX), DX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x434af3		488b9c2488000000	MOVQ 0x88(SP), BX	
	g.m.gsignal.stack.lo = stsp
  0x434afb		48891a			MOVQ BX, 0(DX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x434afe		488b5130		MOVQ 0x30(CX), DX	
  0x434b02		488b5250		MOVQ 0x50(DX), DX	
  0x434b06		488bb42498000000	MOVQ 0x98(SP), SI	
  0x434b0e		4801de			ADDQ BX, SI		
  0x434b11		48897208		MOVQ SI, 0x8(DX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x434b15		488b5130		MOVQ 0x30(CX), DX	
  0x434b19		488b5250		MOVQ 0x50(DX), DX	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x434b1d		4881c370030000		ADDQ $0x370, BX		
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x434b24		48895a10		MOVQ BX, 0x10(DX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x434b28		488b4930		MOVQ 0x30(CX), CX	
  0x434b2c		488b4950		MOVQ 0x50(CX), CX	
  0x434b30		48895918		MOVQ BX, 0x18(CX)	
			g.m.gsignal.stktopsp = getcallersp()
  0x434b34		488b442458		MOVQ 0x58(SP), AX	
  0x434b39		488b4830		MOVQ 0x30(AX), CX	
  0x434b3d		488b4950		MOVQ 0x50(CX), CX	
  0x434b41		488d9424b0000000	LEAQ 0xb0(SP), DX	
  0x434b49		48899180000000		MOVQ DX, 0x80(CX)	
			setStack = true
  0x434b50		e9e1fdffff		JMP 0x434936		
			if sp < stsp || sp >= stsp+st.ss_size {
  0x434b55		488b942498000000	MOVQ 0x98(SP), DX	
  0x434b5d		4801d0			ADDQ DX, AX		
  0x434b60		4839c1			CMPQ AX, CX		
  0x434b63		0f83fffeffff		JAE 0x434a68		
  0x434b69		e924ffffff		JMP 0x434a92		
				setg(nil)
  0x434b6e		48c7042400000000	MOVQ $0x0, 0(SP)	
  0x434b76		e845440100		CALL runtime.setg(SB)	
				needm(0)
  0x434b7b		c6042400		MOVB $0x0, 0(SP)	
  0x434b7f		e82c39ffff		CALL runtime.needm(SB)	
				noSignalStack(sig)
  0x434b84		8b8424b0000000		MOVL 0xb0(SP), AX		
  0x434b8b		890424			MOVL AX, 0(SP)			
  0x434b8e		e85d070000		CALL runtime.noSignalStack(SB)	
				dropm()
  0x434b93		e8e83cffff		CALL runtime.dropm(SB)	
  0x434b98		e9b5feffff		JMP 0x434a52		
	if sp < g.m.gsignal.stack.lo || sp >= g.m.gsignal.stack.hi {
  0x434b9d		48395a08		CMPQ BX, 0x8(DX)	
  0x434ba1		0f868afcffff		JBE 0x434831		
  0x434ba7		31c9			XORL CX, CX		
	setg(g.m.gsignal)
  0x434ba9		e98dfdffff		JMP 0x43493b		
		c := &sigctxt{info, ctx}
  0x434bae		0f57c0			XORPS X0, X0		
  0x434bb1		0f11442460		MOVUPS X0, 0x60(SP)	
  0x434bb6		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x434bbe		4889442460		MOVQ AX, 0x60(SP)	
  0x434bc3		488b8424c0000000	MOVQ 0xc0(SP), AX	
  0x434bcb		4889442468		MOVQ AX, 0x68(SP)	
		if sig == _SIGPROF {
  0x434bd0		8b8c24b0000000		MOVL 0xb0(SP), CX	
  0x434bd7		83f91b			CMPL $0x1b, CX		
  0x434bda		7523			JNE 0x434bff		
			sigprofNonGoPC(c.sigpc())
  0x434bdc		90			NOPL			
func (c *sigctxt) sigpc() uintptr { return uintptr(c.rip()) }
  0x434bdd		90			NOPL			
func (c *sigctxt) rip() uint64 { return c.regs().rip }
  0x434bde		90			NOPL			
  0x434bdf		488b80a8000000		MOVQ 0xa8(AX), AX	
			sigprofNonGoPC(c.sigpc())
  0x434be6		48890424		MOVQ AX, 0(SP)			
  0x434bea		e8618dffff		CALL runtime.sigprofNonGoPC(SB)	
			return
  0x434bef		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x434bf7		4881c4a8000000		ADDQ $0xa8, SP		
  0x434bfe		c3			RET			
		badsignal(uintptr(sig), c)
  0x434bff		48890c24		MOVQ CX, 0(SP)			
  0x434c03		488d442460		LEAQ 0x60(SP), AX		
  0x434c08		4889442408		MOVQ AX, 0x8(SP)		
  0x434c0d		e88e080000		CALL runtime.badsignal(SB)	
		return
  0x434c12		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x434c1a		4881c4a8000000		ADDQ $0xa8, SP		
  0x434c21		c3			RET			
		return
  0x434c22		488bac24a0000000	MOVQ 0xa0(SP), BP	
  0x434c2a		4881c4a8000000		ADDQ $0xa8, SP		
  0x434c31		c3			RET			

TEXT runtime.sigpanic(SB) /usr/local/go/src/runtime/signal_unix.go
func sigpanic() {
  0x434c40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x434c49		483b6110		CMPQ 0x10(CX), SP	
  0x434c4d		0f8698040000		JBE 0x4350eb		
  0x434c53		4883ec28		SUBQ $0x28, SP		
  0x434c57		48896c2420		MOVQ BP, 0x20(SP)	
  0x434c5c		488d6c2420		LEAQ 0x20(SP), BP	
	g := getg()
  0x434c61		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if !canpanic(g) {
  0x434c6a		90			NOPL			
	_m_ := _g_.m
  0x434c6b		488b4830		MOVQ 0x30(AX), CX	
	if gp == nil || gp != _m_.curg {
  0x434c6f		4885c0			TESTQ AX, AX		
  0x434c72		740d			JE 0x434c81		
  0x434c74		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x434c7b		0f84a6020000		JE 0x434f27		
  0x434c81		31c9			XORL CX, CX		
	if !canpanic(g) {
  0x434c83		84c9			TESTL CL, CL		
  0x434c85		0f8445040000		JE 0x4350d0		
	switch g.sig {
  0x434c8b		8b88e0000000		MOVL 0xe0(AX), CX	
	case _SIGBUS:
  0x434c91		83f907			CMPL $0x7, CX		
  0x434c94		0f859e000000		JNE 0x434d38		
		if g.sigcode0 == _BUS_ADRERR && g.sigcode1 < 0x1000 {
  0x434c9a		4883b80001000002	CMPQ $0x2, 0x100(AX)	
  0x434ca2		750d			JNE 0x434cb1		
  0x434ca4		4881b80801000000100000	CMPQ $0x1000, 0x108(AX)	
  0x434caf		724a			JB 0x434cfb		
		if g.paniconfault {
  0x434cb1		80b8b200000000		CMPB $0x0, 0xb2(AX)	
  0x434cb8		0f84a5030000		JE 0x435063		
			panicmem()
  0x434cbe		90			NOPL			
	panicCheckMalloc(memoryError)
  0x434cbf		488b05f2ae0800		MOVQ runtime.memoryError+8(SB), AX	
  0x434cc6		488b0de3ae0800		MOVQ runtime.memoryError(SB), CX	
  0x434ccd		48890c24		MOVQ CX, 0(SP)				
  0x434cd1		4889442408		MOVQ AX, 0x8(SP)			
  0x434cd6		e895d1feff		CALL runtime.panicCheckMalloc(SB)	
	panic(memoryError)
  0x434cdb		488b05d6ae0800		MOVQ runtime.memoryError+8(SB), AX	
  0x434ce2		488b0dc7ae0800		MOVQ runtime.memoryError(SB), CX	
  0x434ce9		4885c9			TESTQ CX, CX				
  0x434cec		0f8461030000		JE 0x435053				
  0x434cf2		488b4908		MOVQ 0x8(CX), CX			
  0x434cf6		e958030000		JMP 0x435053				
			panicmem()
  0x434cfb		90			NOPL			
	panicCheckMalloc(memoryError)
  0x434cfc		488b05adae0800		MOVQ runtime.memoryError(SB), AX	
  0x434d03		488b0daeae0800		MOVQ runtime.memoryError+8(SB), CX	
  0x434d0a		48890424		MOVQ AX, 0(SP)				
  0x434d0e		48894c2408		MOVQ CX, 0x8(SP)			
  0x434d13		e858d1feff		CALL runtime.panicCheckMalloc(SB)	
	panic(memoryError)
  0x434d18		488b0591ae0800		MOVQ runtime.memoryError(SB), AX	
  0x434d1f		488b0d92ae0800		MOVQ runtime.memoryError+8(SB), CX	
  0x434d26		4885c0			TESTQ AX, AX				
  0x434d29		0f8491030000		JE 0x4350c0				
  0x434d2f		488b4008		MOVQ 0x8(AX), AX			
  0x434d33		e988030000		JMP 0x4350c0				
	case _SIGFPE:
  0x434d38		83f908			CMPL $0x8, CX		
  0x434d3b		0f85ce000000		JNE 0x434e0f		
		switch g.sigcode0 {
  0x434d41		488b8000010000		MOVQ 0x100(AX), AX	
		case _FPE_INTDIV:
  0x434d48		4883f801		CMPQ $0x1, AX		
  0x434d4c		0f8480000000		JE 0x434dd2		
		case _FPE_INTOVF:
  0x434d52		4883f802		CMPQ $0x2, AX		
  0x434d56		753d			JNE 0x434d95		
			panicoverflow()
  0x434d58		90			NOPL			
	panicCheckMalloc(overflowError)
  0x434d59		488b0568ae0800		MOVQ runtime.overflowError+8(SB), AX	
  0x434d60		488b0d59ae0800		MOVQ runtime.overflowError(SB), CX	
  0x434d67		48890c24		MOVQ CX, 0(SP)				
  0x434d6b		4889442408		MOVQ AX, 0x8(SP)			
  0x434d70		e8fbd0feff		CALL runtime.panicCheckMalloc(SB)	
	panic(overflowError)
  0x434d75		488b054cae0800		MOVQ runtime.overflowError+8(SB), AX	
  0x434d7c		488b0d3dae0800		MOVQ runtime.overflowError(SB), CX	
  0x434d83		4885c9			TESTQ CX, CX				
  0x434d86		0f842a020000		JE 0x434fb6				
  0x434d8c		488b4908		MOVQ 0x8(CX), CX			
  0x434d90		e921020000		JMP 0x434fb6				
		panicfloat()
  0x434d95		90			NOPL			
	panicCheckMalloc(floatError)
  0x434d96		488b05f3ad0800		MOVQ runtime.floatError(SB), AX		
  0x434d9d		488b0df4ad0800		MOVQ runtime.floatError+8(SB), CX	
  0x434da4		48890424		MOVQ AX, 0(SP)				
  0x434da8		48894c2408		MOVQ CX, 0x8(SP)			
  0x434dad		e8bed0feff		CALL runtime.panicCheckMalloc(SB)	
	panic(floatError)
  0x434db2		488b05dfad0800		MOVQ runtime.floatError+8(SB), AX	
  0x434db9		488b0dd0ad0800		MOVQ runtime.floatError(SB), CX		
  0x434dc0		4885c9			TESTQ CX, CX				
  0x434dc3		0f84dd010000		JE 0x434fa6				
  0x434dc9		488b4908		MOVQ 0x8(CX), CX			
  0x434dcd		e9d4010000		JMP 0x434fa6				
			panicdivide()
  0x434dd2		90			NOPL			
	panicCheckMalloc(divideError)
  0x434dd3		488b05aead0800		MOVQ runtime.divideError+8(SB), AX	
  0x434dda		488b0d9fad0800		MOVQ runtime.divideError(SB), CX	
  0x434de1		48890c24		MOVQ CX, 0(SP)				
  0x434de5		4889442408		MOVQ AX, 0x8(SP)			
  0x434dea		e881d0feff		CALL runtime.panicCheckMalloc(SB)	
	panic(divideError)
  0x434def		488b0592ad0800		MOVQ runtime.divideError+8(SB), AX	
  0x434df6		488b0d83ad0800		MOVQ runtime.divideError(SB), CX	
  0x434dfd		4885c9			TESTQ CX, CX				
  0x434e00		0f84c0010000		JE 0x434fc6				
  0x434e06		488b4908		MOVQ 0x8(CX), CX			
  0x434e0a		e9b7010000		JMP 0x434fc6				
	case _SIGSEGV:
  0x434e0f		83f90b			CMPL $0xb, CX		
  0x434e12		0f85bd000000		JNE 0x434ed5		
		if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 {
  0x434e18		488b8800010000		MOVQ 0x100(AX), CX	
  0x434e1f		4885c9			TESTQ CX, CX		
  0x434e22		0f8594000000		JNE 0x434ebc		
  0x434e28		4881b80801000000100000	CMPQ $0x1000, 0x108(AX)	
  0x434e33		724a			JB 0x434e7f		
		if g.paniconfault {
  0x434e35		80b8b200000000		CMPB $0x0, 0xb2(AX)	
  0x434e3c		0f84a4010000		JE 0x434fe6		
			panicmem()
  0x434e42		90			NOPL			
	panicCheckMalloc(memoryError)
  0x434e43		488b0566ad0800		MOVQ runtime.memoryError(SB), AX	
  0x434e4a		488b0d67ad0800		MOVQ runtime.memoryError+8(SB), CX	
  0x434e51		48890424		MOVQ AX, 0(SP)				
  0x434e55		48894c2408		MOVQ CX, 0x8(SP)			
  0x434e5a		e811d0feff		CALL runtime.panicCheckMalloc(SB)	
	panic(memoryError)
  0x434e5f		488b054aad0800		MOVQ runtime.memoryError(SB), AX	
  0x434e66		488b0d4bad0800		MOVQ runtime.memoryError+8(SB), CX	
  0x434e6d		4885c0			TESTQ AX, AX				
  0x434e70		0f8460010000		JE 0x434fd6				
  0x434e76		488b4008		MOVQ 0x8(AX), AX			
  0x434e7a		e957010000		JMP 0x434fd6				
			panicmem()
  0x434e7f		90			NOPL			
	panicCheckMalloc(memoryError)
  0x434e80		488b0531ad0800		MOVQ runtime.memoryError+8(SB), AX	
  0x434e87		488b0d22ad0800		MOVQ runtime.memoryError(SB), CX	
  0x434e8e		48890c24		MOVQ CX, 0(SP)				
  0x434e92		4889442408		MOVQ AX, 0x8(SP)			
  0x434e97		e8d4cffeff		CALL runtime.panicCheckMalloc(SB)	
	panic(memoryError)
  0x434e9c		488b0515ad0800		MOVQ runtime.memoryError+8(SB), AX	
  0x434ea3		488b0d06ad0800		MOVQ runtime.memoryError(SB), CX	
  0x434eaa		4885c9			TESTQ CX, CX				
  0x434ead		0f8490010000		JE 0x435043				
  0x434eb3		488b4908		MOVQ 0x8(CX), CX			
  0x434eb7		e987010000		JMP 0x435043				
		if (g.sigcode0 == 0 || g.sigcode0 == _SEGV_MAPERR || g.sigcode0 == _SEGV_ACCERR) && g.sigcode1 < 0x1000 {
  0x434ebc		4883f901		CMPQ $0x1, CX		
  0x434ec0		0f8462ffffff		JE 0x434e28		
  0x434ec6		4883f902		CMPQ $0x2, CX		
  0x434eca		0f8458ffffff		JE 0x434e28		
  0x434ed0		e960ffffff		JMP 0x434e35		
	if g.sig >= uint32(len(sigtable)) {
  0x434ed5		83f941			CMPL $0x41, CX		
  0x434ed8		0f83ad000000		JAE 0x434f8b		
	panic(errorString(sigtable[g.sig].name))
  0x434ede		4883f941		CMPQ $0x41, CX			
  0x434ee2		0f839c000000		JAE 0x434f84			
  0x434ee8		488d0449		LEAQ 0(CX)(CX*2), AX		
  0x434eec		488d0d8db30800		LEAQ runtime.sigtable(SB), CX	
  0x434ef3		488b54c110		MOVQ 0x10(CX)(AX*8), DX		
  0x434ef8		488b44c108		MOVQ 0x8(CX)(AX*8), AX		
  0x434efd		48890424		MOVQ AX, 0(SP)			
  0x434f01		4889542408		MOVQ DX, 0x8(SP)		
  0x434f06		e8b533fdff		CALL runtime.convTstring(SB)	
  0x434f0b		488b442410		MOVQ 0x10(SP), AX		
  0x434f10		488d0dc9a00200		LEAQ 0x2a0c9(IP), CX		
  0x434f17		48890c24		MOVQ CX, 0(SP)			
  0x434f1b		4889442408		MOVQ AX, 0x8(SP)		
  0x434f20		e88bdffeff		CALL runtime.gopanic(SB)	
  0x434f25		0f0b			UD2				
	if _m_.locks != 0 || _m_.mallocing != 0 || _m_.throwing != 0 || _m_.preemptoff != "" || _m_.dying != 0 {
  0x434f27		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x434f2e		7407			JE 0x434f37		
  0x434f30		31c9			XORL CX, CX		
	if !canpanic(g) {
  0x434f32		e94cfdffff		JMP 0x434c83		
	if _m_.locks != 0 || _m_.mallocing != 0 || _m_.throwing != 0 || _m_.preemptoff != "" || _m_.dying != 0 {
  0x434f37		83b9f000000000		CMPL $0x0, 0xf0(CX)	
  0x434f3e		75f0			JNE 0x434f30		
  0x434f40		83b9f400000000		CMPL $0x0, 0xf4(CX)	
  0x434f47		75e7			JNE 0x434f30		
  0x434f49		4883b90001000000	CMPQ $0x0, 0x100(CX)	
  0x434f51		75dd			JNE 0x434f30		
  0x434f53		83b90c01000000		CMPL $0x0, 0x10c(CX)	
  0x434f5a		75d4			JNE 0x434f30		
	status := readgstatus(gp)
  0x434f5c		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x434f5d		8b8890000000		MOVL 0x90(AX), CX	
	if status&^_Gscan != _Grunning || gp.syscallsp != 0 {
  0x434f63		0fbaf10c		BTRL $0xc, CX		
  0x434f67		83f902			CMPL $0x2, CX		
  0x434f6a		7407			JE 0x434f73		
  0x434f6c		31c9			XORL CX, CX		
	if !canpanic(g) {
  0x434f6e		e910fdffff		JMP 0x434c83		
	if status&^_Gscan != _Grunning || gp.syscallsp != 0 {
  0x434f73		4883787000		CMPQ $0x0, 0x70(AX)	
  0x434f78		75f2			JNE 0x434f6c		
  0x434f7a		b901000000		MOVL $0x1, CX		
	if !canpanic(g) {
  0x434f7f		e9fffcffff		JMP 0x434c83		
	panic(errorString(sigtable[g.sig].name))
  0x434f84		e897cffeff		CALL runtime.panicindex(SB)	
  0x434f89		0f0b			UD2				
		throw("unexpected signal value")
  0x434f8b		488d052bbe0300		LEAQ 0x3be2b(IP), AX	
  0x434f92		48890424		MOVQ AX, 0(SP)		
  0x434f96		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x434f9f		e8dce4feff		CALL runtime.throw(SB)	
  0x434fa4		0f0b			UD2			
	panic(floatError)
  0x434fa6		48890c24		MOVQ CX, 0(SP)			
  0x434faa		4889442408		MOVQ AX, 0x8(SP)		
  0x434faf		e8fcdefeff		CALL runtime.gopanic(SB)	
  0x434fb4		0f0b			UD2				
	panic(overflowError)
  0x434fb6		48890c24		MOVQ CX, 0(SP)			
  0x434fba		4889442408		MOVQ AX, 0x8(SP)		
  0x434fbf		e8ecdefeff		CALL runtime.gopanic(SB)	
  0x434fc4		0f0b			UD2				
	panic(divideError)
  0x434fc6		48890c24		MOVQ CX, 0(SP)			
  0x434fca		4889442408		MOVQ AX, 0x8(SP)		
  0x434fcf		e8dcdefeff		CALL runtime.gopanic(SB)	
  0x434fd4		0f0b			UD2				
	panic(memoryError)
  0x434fd6		48890424		MOVQ AX, 0(SP)			
  0x434fda		48894c2408		MOVQ CX, 0x8(SP)		
  0x434fdf		e8ccdefeff		CALL runtime.gopanic(SB)	
  0x434fe4		0f0b			UD2				
		print("unexpected fault address ", hex(g.sigcode1), "\n")
  0x434fe6		488b8008010000		MOVQ 0x108(AX), AX		
  0x434fed		4889442418		MOVQ AX, 0x18(SP)		
  0x434ff2		e8c9eefeff		CALL runtime.printlock(SB)	
  0x434ff7		488d0579c10300		LEAQ 0x3c179(IP), AX		
  0x434ffe		48890424		MOVQ AX, 0(SP)			
  0x435002		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x43500b		e8e0f7feff		CALL runtime.printstring(SB)	
  0x435010		488b442418		MOVQ 0x18(SP), AX		
  0x435015		48890424		MOVQ AX, 0(SP)			
  0x435019		e892f6feff		CALL runtime.printhex(SB)	
  0x43501e		e82df1feff		CALL runtime.printnl(SB)	
  0x435023		e818effeff		CALL runtime.printunlock(SB)	
		throw("fault")
  0x435028		488d05c8a10300		LEAQ 0x3a1c8(IP), AX	
  0x43502f		48890424		MOVQ AX, 0(SP)		
  0x435033		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x43503c		e83fe4feff		CALL runtime.throw(SB)	
  0x435041		0f0b			UD2			
	panic(memoryError)
  0x435043		48890c24		MOVQ CX, 0(SP)			
  0x435047		4889442408		MOVQ AX, 0x8(SP)		
  0x43504c		e85fdefeff		CALL runtime.gopanic(SB)	
  0x435051		0f0b			UD2				
  0x435053		48890c24		MOVQ CX, 0(SP)			
  0x435057		4889442408		MOVQ AX, 0x8(SP)		
  0x43505c		e84fdefeff		CALL runtime.gopanic(SB)	
  0x435061		0f0b			UD2				
		print("unexpected fault address ", hex(g.sigcode1), "\n")
  0x435063		488b8008010000		MOVQ 0x108(AX), AX		
  0x43506a		4889442418		MOVQ AX, 0x18(SP)		
  0x43506f		e84ceefeff		CALL runtime.printlock(SB)	
  0x435074		488d05fcc00300		LEAQ 0x3c0fc(IP), AX		
  0x43507b		48890424		MOVQ AX, 0(SP)			
  0x43507f		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x435088		e863f7feff		CALL runtime.printstring(SB)	
  0x43508d		488b442418		MOVQ 0x18(SP), AX		
  0x435092		48890424		MOVQ AX, 0(SP)			
  0x435096		e815f6feff		CALL runtime.printhex(SB)	
  0x43509b		e8b0f0feff		CALL runtime.printnl(SB)	
  0x4350a0		e89beefeff		CALL runtime.printunlock(SB)	
		throw("fault")
  0x4350a5		488d054ba10300		LEAQ 0x3a14b(IP), AX	
  0x4350ac		48890424		MOVQ AX, 0(SP)		
  0x4350b0		48c744240805000000	MOVQ $0x5, 0x8(SP)	
  0x4350b9		e8c2e3feff		CALL runtime.throw(SB)	
  0x4350be		0f0b			UD2			
	panic(memoryError)
  0x4350c0		48890424		MOVQ AX, 0(SP)			
  0x4350c4		48894c2408		MOVQ CX, 0x8(SP)		
  0x4350c9		e8e2ddfeff		CALL runtime.gopanic(SB)	
  0x4350ce		0f0b			UD2				
		throw("unexpected signal during runtime execution")
  0x4350d0		488d05a9db0300		LEAQ 0x3dba9(IP), AX	
  0x4350d7		48890424		MOVQ AX, 0(SP)		
  0x4350db		48c74424082a000000	MOVQ $0x2a, 0x8(SP)	
  0x4350e4		e897e3feff		CALL runtime.throw(SB)	
  0x4350e9		0f0b			UD2			
func sigpanic() {
  0x4350eb		e890270100		CALL runtime.morestack_noctxt(SB)	
  0x4350f0		e94bfbffff		JMP runtime.sigpanic(SB)		

TEXT runtime.dieFromSignal(SB) /usr/local/go/src/runtime/signal_unix.go
func dieFromSignal(sig uint32) {
  0x435100		4883ec18		SUBQ $0x18, SP		
  0x435104		48896c2410		MOVQ BP, 0x10(SP)	
  0x435109		488d6c2410		LEAQ 0x10(SP), BP	
	unblocksig(sig)
  0x43510e		8b442420		MOVL 0x20(SP), AX		
  0x435112		890424			MOVL AX, 0(SP)			
  0x435115		e8a6050000		CALL runtime.unblocksig(SB)	
	atomic.Store(&handlingSig[sig], 0)
  0x43511a		8b442420		MOVL 0x20(SP), AX			
  0x43511e		4883f841		CMPQ $0x41, AX				
  0x435122		736c			JAE 0x435190				
  0x435124		488d0df5810a00		LEAQ runtime.handlingSig(SB), CX	
  0x43512b		488d0c81		LEAQ 0(CX)(AX*4), CX			
  0x43512f		31d2			XORL DX, DX				
  0x435131		8711			XCHGL DX, 0(CX)				
	raise(sig)
  0x435133		890424			MOVL AX, 0(SP)		
  0x435136		e8255e0100		CALL runtime.raise(SB)	
	osyield()
  0x43513b		e8b0640100		CALL runtime.osyield(SB)	
	osyield()
  0x435140		e8ab640100		CALL runtime.osyield(SB)	
	osyield()
  0x435145		e8a6640100		CALL runtime.osyield(SB)	
	setsig(sig, _SIG_DFL)
  0x43514a		8b442420		MOVL 0x20(SP), AX	
  0x43514e		890424			MOVL AX, 0(SP)		
  0x435151		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x43515a		e851cbfeff		CALL runtime.setsig(SB)	
	raise(sig)
  0x43515f		8b442420		MOVL 0x20(SP), AX	
  0x435163		890424			MOVL AX, 0(SP)		
  0x435166		e8f55d0100		CALL runtime.raise(SB)	
	osyield()
  0x43516b		e880640100		CALL runtime.osyield(SB)	
	osyield()
  0x435170		e87b640100		CALL runtime.osyield(SB)	
	osyield()
  0x435175		e876640100		CALL runtime.osyield(SB)	
	exit(2)
  0x43517a		c7042402000000		MOVL $0x2, 0(SP)	
  0x435181		e89a5c0100		CALL runtime.exit(SB)	
}
  0x435186		488b6c2410		MOVQ 0x10(SP), BP	
  0x43518b		4883c418		ADDQ $0x18, SP		
  0x43518f		c3			RET			
	atomic.Store(&handlingSig[sig], 0)
  0x435190		e88bcdfeff		CALL runtime.panicindex(SB)	
  0x435195		0f0b			UD2				

TEXT runtime.raisebadsignal(SB) /usr/local/go/src/runtime/signal_unix.go
func raisebadsignal(sig uint32, c *sigctxt) {
  0x4351a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4351a9		483b6110		CMPQ 0x10(CX), SP	
  0x4351ad		0f86f5000000		JBE 0x4352a8		
  0x4351b3		4883ec20		SUBQ $0x20, SP		
  0x4351b7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4351bc		488d6c2418		LEAQ 0x18(SP), BP	
	if sig == _SIGPROF {
  0x4351c1		8b442428		MOVL 0x28(SP), AX	
  0x4351c5		83f81b			CMPL $0x1b, AX		
  0x4351c8		0f84c9000000		JE 0x435297		
	if sig >= _NSIG {
  0x4351ce		83f841			CMPL $0x41, AX		
  0x4351d1		0f82a4000000		JB 0x43527b		
  0x4351d7		31c9			XORL CX, CX		
	setsig(sig, handler)
  0x4351d9		48894c2410		MOVQ CX, 0x10(SP)	
	unblocksig(sig)
  0x4351de		890424			MOVL AX, 0(SP)			
  0x4351e1		e8da040000		CALL runtime.unblocksig(SB)	
	setsig(sig, handler)
  0x4351e6		8b442428		MOVL 0x28(SP), AX	
  0x4351ea		890424			MOVL AX, 0(SP)		
  0x4351ed		488b4c2410		MOVQ 0x10(SP), CX	
  0x4351f2		48894c2408		MOVQ CX, 0x8(SP)	
  0x4351f7		e8b4cafeff		CALL runtime.setsig(SB)	
	if GOOS != "freebsd" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x4351fc		803daa7a0a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x435203		746b			JE 0x435270				
  0x435205		488b442410		MOVQ 0x10(SP), AX			
  0x43520a		4885c0			TESTQ AX, AX				
  0x43520d		7512			JNE 0x435221				
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x43520f		488b442430		MOVQ 0x30(SP), AX	
  0x435214		488b00			MOVQ 0(AX), AX		
	if GOOS != "freebsd" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x435217		90			NOPL			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x435218		48634008		MOVSXD 0x8(AX), AX	
	if GOOS != "freebsd" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x43521c		4885c0			TESTQ AX, AX		
  0x43521f		7545			JNE 0x435266		
	raise(sig)
  0x435221		8b442428		MOVL 0x28(SP), AX	
  0x435225		890424			MOVL AX, 0(SP)		
  0x435228		e8335d0100		CALL runtime.raise(SB)	
	usleep(1000)
  0x43522d		c70424e8030000		MOVL $0x3e8, 0(SP)	
  0x435234		e8c75c0100		CALL runtime.usleep(SB)	
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x435239		488d0528e70300		LEAQ 0x3e728(IP), AX	
  0x435240		8400			TESTB AL, 0(AX)		
	setsig(sig, funcPC(sighandler))
  0x435242		90			NOPL			
	return **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))
  0x435243		488b051ee70300		MOVQ 0x3e71e(IP), AX	
  0x43524a		90			NOPL			
	setsig(sig, funcPC(sighandler))
  0x43524b		8b4c2428		MOVL 0x28(SP), CX	
  0x43524f		890c24			MOVL CX, 0(SP)		
  0x435252		4889442408		MOVQ AX, 0x8(SP)	
  0x435257		e854cafeff		CALL runtime.setsig(SB)	
}
  0x43525c		488b6c2418		MOVQ 0x18(SP), BP	
  0x435261		4883c420		ADDQ $0x20, SP		
  0x435265		c3			RET			
		return
  0x435266		488b6c2418		MOVQ 0x18(SP), BP	
  0x43526b		4883c420		ADDQ $0x20, SP		
  0x43526f		c3			RET			
	if GOOS != "freebsd" && (isarchive || islibrary) && handler == _SIG_DFL && c.sigcode() != _SI_USER {
  0x435270		803d387a0a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x435277		758c			JNE 0x435205				
  0x435279		eba6			JMP 0x435221				
		handler = atomic.Loaduintptr(&fwdSig[sig])
  0x43527b		4883f841		CMPQ $0x41, AX			
  0x43527f		7320			JAE 0x4352a1			
  0x435281		488d15b8830a00		LEAQ runtime.fwdSig(SB), DX	
  0x435288		488d14c2		LEAQ 0(DX)(AX*8), DX		
  0x43528c		488b12			MOVQ 0(DX), DX			
	setsig(sig, handler)
  0x43528f		4889d1			MOVQ DX, CX		
		handler = atomic.Loaduintptr(&fwdSig[sig])
  0x435292		e942ffffff		JMP 0x4351d9		
		return
  0x435297		488b6c2418		MOVQ 0x18(SP), BP	
  0x43529c		4883c420		ADDQ $0x20, SP		
  0x4352a0		c3			RET			
		handler = atomic.Loaduintptr(&fwdSig[sig])
  0x4352a1		e87accfeff		CALL runtime.panicindex(SB)	
  0x4352a6		0f0b			UD2				
func raisebadsignal(sig uint32, c *sigctxt) {
  0x4352a8		e8d3250100		CALL runtime.morestack_noctxt(SB)	
  0x4352ad		e9eefeffff		JMP runtime.raisebadsignal(SB)		

TEXT runtime.crash(SB) /usr/local/go/src/runtime/signal_unix.go
func crash() {
  0x4352c0		4883ec10		SUBQ $0x10, SP		
  0x4352c4		48896c2408		MOVQ BP, 0x8(SP)	
  0x4352c9		488d6c2408		LEAQ 0x8(SP), BP	
	dieFromSignal(_SIGABRT)
  0x4352ce		c7042406000000		MOVL $0x6, 0(SP)		
  0x4352d5		e826feffff		CALL runtime.dieFromSignal(SB)	
}
  0x4352da		488b6c2408		MOVQ 0x8(SP), BP	
  0x4352df		4883c410		ADDQ $0x10, SP		
  0x4352e3		c3			RET			

TEXT runtime.noSignalStack(SB) /usr/local/go/src/runtime/signal_unix.go
func noSignalStack(sig uint32) {
  0x4352f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4352f9		483b6110		CMPQ 0x10(CX), SP	
  0x4352fd		7672			JBE 0x435371		
  0x4352ff		4883ec18		SUBQ $0x18, SP		
  0x435303		48896c2410		MOVQ BP, 0x10(SP)	
  0x435308		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received on thread with no signal stack")
  0x43530d		e8aeebfeff		CALL runtime.printlock(SB)	
  0x435312		488d05a3a00300		LEAQ 0x3a0a3(IP), AX		
  0x435319		48890424		MOVQ AX, 0(SP)			
  0x43531d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x435326		e8c5f4feff		CALL runtime.printstring(SB)	
  0x43532b		8b442420		MOVL 0x20(SP), AX		
  0x43532f		48890424		MOVQ AX, 0(SP)			
  0x435333		e808f2feff		CALL runtime.printuint(SB)	
  0x435338		488d05d3d60300		LEAQ 0x3d6d3(IP), AX		
  0x43533f		48890424		MOVQ AX, 0(SP)			
  0x435343		48c744240829000000	MOVQ $0x29, 0x8(SP)		
  0x43534c		e89ff4feff		CALL runtime.printstring(SB)	
  0x435351		e8eaebfeff		CALL runtime.printunlock(SB)	
	throw("non-Go code disabled sigaltstack")
  0x435356		488d05b4cb0300		LEAQ 0x3cbb4(IP), AX	
  0x43535d		48890424		MOVQ AX, 0(SP)		
  0x435361		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x43536a		e811e1feff		CALL runtime.throw(SB)	
  0x43536f		0f0b			UD2			
func noSignalStack(sig uint32) {
  0x435371		e80a250100		CALL runtime.morestack_noctxt(SB)	
  0x435376		e975ffffff		JMP runtime.noSignalStack(SB)		

TEXT runtime.sigNotOnStack(SB) /usr/local/go/src/runtime/signal_unix.go
func sigNotOnStack(sig uint32) {
  0x435380		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435389		483b6110		CMPQ 0x10(CX), SP	
  0x43538d		7672			JBE 0x435401		
  0x43538f		4883ec18		SUBQ $0x18, SP		
  0x435393		48896c2410		MOVQ BP, 0x10(SP)	
  0x435398		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received but handler not on signal stack")
  0x43539d		e81eebfeff		CALL runtime.printlock(SB)	
  0x4353a2		488d0513a00300		LEAQ 0x3a013(IP), AX		
  0x4353a9		48890424		MOVQ AX, 0(SP)			
  0x4353ad		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x4353b6		e835f4feff		CALL runtime.printstring(SB)	
  0x4353bb		8b442420		MOVL 0x20(SP), AX		
  0x4353bf		48890424		MOVQ AX, 0(SP)			
  0x4353c3		e878f1feff		CALL runtime.printuint(SB)	
  0x4353c8		488d058bd70300		LEAQ 0x3d78b(IP), AX		
  0x4353cf		48890424		MOVQ AX, 0(SP)			
  0x4353d3		48c74424082a000000	MOVQ $0x2a, 0x8(SP)		
  0x4353dc		e80ff4feff		CALL runtime.printstring(SB)	
  0x4353e1		e85aebfeff		CALL runtime.printunlock(SB)	
	throw("non-Go code set up signal handler without SA_ONSTACK flag")
  0x4353e6		488d05d4e00300		LEAQ 0x3e0d4(IP), AX	
  0x4353ed		48890424		MOVQ AX, 0(SP)		
  0x4353f1		48c744240839000000	MOVQ $0x39, 0x8(SP)	
  0x4353fa		e881e0feff		CALL runtime.throw(SB)	
  0x4353ff		0f0b			UD2			
func sigNotOnStack(sig uint32) {
  0x435401		e87a240100		CALL runtime.morestack_noctxt(SB)	
  0x435406		e975ffffff		JMP runtime.sigNotOnStack(SB)		

TEXT runtime.signalDuringFork(SB) /usr/local/go/src/runtime/signal_unix.go
func signalDuringFork(sig uint32) {
  0x435410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435419		483b6110		CMPQ 0x10(CX), SP	
  0x43541d		7672			JBE 0x435491		
  0x43541f		4883ec18		SUBQ $0x18, SP		
  0x435423		48896c2410		MOVQ BP, 0x10(SP)	
  0x435428		488d6c2410		LEAQ 0x10(SP), BP	
	println("signal", sig, "received during fork")
  0x43542d		e88eeafeff		CALL runtime.printlock(SB)	
  0x435432		488d05839f0300		LEAQ 0x39f83(IP), AX		
  0x435439		48890424		MOVQ AX, 0(SP)			
  0x43543d		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x435446		e8a5f3feff		CALL runtime.printstring(SB)	
  0x43544b		8b442420		MOVL 0x20(SP), AX		
  0x43544f		48890424		MOVQ AX, 0(SP)			
  0x435453		e8e8f0feff		CALL runtime.printuint(SB)	
  0x435458		488d05b6b40300		LEAQ 0x3b4b6(IP), AX		
  0x43545f		48890424		MOVQ AX, 0(SP)			
  0x435463		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x43546c		e87ff3feff		CALL runtime.printstring(SB)	
  0x435471		e8caeafeff		CALL runtime.printunlock(SB)	
	throw("signal received during fork")
  0x435476		488d059bc00300		LEAQ 0x3c09b(IP), AX	
  0x43547d		48890424		MOVQ AX, 0(SP)		
  0x435481		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x43548a		e8f1dffeff		CALL runtime.throw(SB)	
  0x43548f		0f0b			UD2			
func signalDuringFork(sig uint32) {
  0x435491		e8ea230100		CALL runtime.morestack_noctxt(SB)	
  0x435496		e975ffffff		JMP runtime.signalDuringFork(SB)	

TEXT runtime.badsignal(SB) /usr/local/go/src/runtime/signal_unix.go
func badsignal(sig uintptr, c *sigctxt) {
  0x4354a0		4883ec18		SUBQ $0x18, SP		
  0x4354a4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4354a9		488d6c2410		LEAQ 0x10(SP), BP	
	needm(0)
  0x4354ae		c6042400		MOVB $0x0, 0(SP)	
  0x4354b2		e8f92fffff		CALL runtime.needm(SB)	
	if !sigsend(uint32(sig)) {
  0x4354b7		488b442420		MOVQ 0x20(SP), AX		
  0x4354bc		890424			MOVL AX, 0(SP)			
  0x4354bf		e82c060000		CALL runtime.sigsend(SB)	
  0x4354c4		807c240800		CMPB $0x0, 0x8(SP)		
  0x4354c9		740f			JE 0x4354da			
	dropm()
  0x4354cb		e8b033ffff		CALL runtime.dropm(SB)	
}
  0x4354d0		488b6c2410		MOVQ 0x10(SP), BP	
  0x4354d5		4883c418		ADDQ $0x18, SP		
  0x4354d9		c3			RET			
		raisebadsignal(uint32(sig), c)
  0x4354da		488b442420		MOVQ 0x20(SP), AX		
  0x4354df		890424			MOVL AX, 0(SP)			
  0x4354e2		488b442428		MOVQ 0x28(SP), AX		
  0x4354e7		4889442408		MOVQ AX, 0x8(SP)		
  0x4354ec		e8affcffff		CALL runtime.raisebadsignal(SB)	
  0x4354f1		ebd8			JMP 0x4354cb			

TEXT runtime.sigfwdgo(SB) /usr/local/go/src/runtime/signal_unix.go
func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {
  0x435500		4883ec28		SUBQ $0x28, SP		
  0x435504		48896c2420		MOVQ BP, 0x20(SP)	
  0x435509		488d6c2420		LEAQ 0x20(SP), BP	
	if sig >= uint32(len(sigtable)) {
  0x43550e		8b442430		MOVL 0x30(SP), AX	
  0x435512		83f841			CMPL $0x41, AX		
  0x435515		0f838c010000		JAE 0x4356a7		
	fwdFn := atomic.Loaduintptr(&fwdSig[sig])
  0x43551b		4883f841		CMPQ $0x41, AX			
  0x43551f		0f8391010000		JAE 0x4356b6			
  0x435525		488d0d14810a00		LEAQ runtime.fwdSig(SB), CX	
  0x43552c		488d0cc1		LEAQ 0(CX)(AX*8), CX		
  0x435530		488b09			MOVQ 0(CX), CX			
	flags := sigtable[sig].flags
  0x435533		488d1440		LEAQ 0(AX)(AX*2), DX		
  0x435537		488d1d42ad0800		LEAQ runtime.sigtable(SB), BX	
  0x43553e		8b14d3			MOVL 0(BX)(DX*8), DX		
	if atomic.Load(&handlingSig[sig]) == 0 || !signalsOK {
  0x435541		488d1dd87d0a00		LEAQ runtime.handlingSig(SB), BX	
  0x435548		488d1c83		LEAQ 0(BX)(AX*4), BX			
  0x43554c		8b1b			MOVL 0(BX), BX				
  0x43554e		85db			TESTL BX, BX				
  0x435550		0f858a000000		JNE 0x4355e0				
		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL && flags&_SigIgn != 0) {
  0x435556		4883f901		CMPQ $0x1, CX		
  0x43555a		750f			JNE 0x43556b		
			return true
  0x43555c		c644244801		MOVB $0x1, 0x48(SP)	
  0x435561		488b6c2420		MOVQ 0x20(SP), BP	
  0x435566		4883c428		ADDQ $0x28, SP		
  0x43556a		c3			RET			
		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL && flags&_SigIgn != 0) {
  0x43556b		4885c9			TESTQ CX, CX		
  0x43556e		756c			JNE 0x4355dc		
  0x435570		0fbae208		BTL $0x8, DX		
  0x435574		0f92c2			SETB DL			
  0x435577		84d2			TESTL DL, DL		
  0x435579		75e1			JNE 0x43555c		
  0x43557b		4885c9			TESTQ CX, CX		
		if fwdFn == _SIG_DFL {
  0x43557e		752c			JNE 0x4355ac		
			setsig(sig, _SIG_DFL)
  0x435580		890424			MOVL AX, 0(SP)		
  0x435583		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x43558c		e81fc7feff		CALL runtime.setsig(SB)	
			dieFromSignal(sig)
  0x435591		8b442430		MOVL 0x30(SP), AX		
  0x435595		890424			MOVL AX, 0(SP)			
  0x435598		e863fbffff		CALL runtime.dieFromSignal(SB)	
			return false
  0x43559d		c644244800		MOVB $0x0, 0x48(SP)	
  0x4355a2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4355a7		4883c428		ADDQ $0x28, SP		
  0x4355ab		c3			RET			
		sigfwd(fwdFn, sig, info, ctx)
  0x4355ac		48890c24		MOVQ CX, 0(SP)		
  0x4355b0		89442408		MOVL AX, 0x8(SP)	
  0x4355b4		488b442438		MOVQ 0x38(SP), AX	
  0x4355b9		4889442410		MOVQ AX, 0x10(SP)	
  0x4355be		488b442440		MOVQ 0x40(SP), AX	
  0x4355c3		4889442418		MOVQ AX, 0x18(SP)	
  0x4355c8		e8335c0100		CALL runtime.sigfwd(SB)	
		return true
  0x4355cd		c644244801		MOVB $0x1, 0x48(SP)	
  0x4355d2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4355d7		4883c428		ADDQ $0x28, SP		
  0x4355db		c3			RET			
  0x4355dc		31d2			XORL DX, DX		
		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL && flags&_SigIgn != 0) {
  0x4355de		eb97			JMP 0x435577		
	if atomic.Load(&handlingSig[sig]) == 0 || !signalsOK {
  0x4355e0		803dcb760a0000		CMPB $0x0, runtime.signalsOK(SB)	
  0x4355e7		0f8469ffffff		JE 0x435556				
	if fwdFn == _SIG_DFL {
  0x4355ed		4885c9			TESTQ CX, CX		
  0x4355f0		0f84a2000000		JE 0x435698		
	if (c.sigcode() == _SI_USER || flags&_SigPanic == 0) && sig != _SIGPIPE {
  0x4355f6		90			NOPL			
func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }
  0x4355f7		488b5c2438		MOVQ 0x38(SP), BX	
  0x4355fc		48637308		MOVSXD 0x8(BX), SI	
	if (c.sigcode() == _SI_USER || flags&_SigPanic == 0) && sig != _SIGPIPE {
  0x435600		4885f6			TESTQ SI, SI		
  0x435603		0f8580000000		JNE 0x435689		
  0x435609		83f80d			CMPL $0xd, AX		
  0x43560c		756c			JNE 0x43567a		
	g := getg()
  0x43560e		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
	if g != nil && g.m != nil && g.m.curg != nil && !g.m.incgo {
  0x435617		4885d2			TESTQ DX, DX		
  0x43561a		741c			JE 0x435638		
  0x43561c		488b5230		MOVQ 0x30(DX), DX	
  0x435620		4885d2			TESTQ DX, DX		
  0x435623		7413			JE 0x435638		
  0x435625		4883bac000000000	CMPQ $0x0, 0xc0(DX)	
  0x43562d		7409			JE 0x435638		
  0x43562f		80ba1901000000		CMPB $0x0, 0x119(DX)	
  0x435636		7433			JE 0x43566b		
	if fwdFn != _SIG_IGN {
  0x435638		4883f901		CMPQ $0x1, CX		
  0x43563c		750f			JNE 0x43564d		
	return true
  0x43563e		c644244801		MOVB $0x1, 0x48(SP)	
  0x435643		488b6c2420		MOVQ 0x20(SP), BP	
  0x435648		4883c428		ADDQ $0x28, SP		
  0x43564c		c3			RET			
		sigfwd(fwdFn, sig, info, ctx)
  0x43564d		48890c24		MOVQ CX, 0(SP)		
  0x435651		89442408		MOVL AX, 0x8(SP)	
  0x435655		48895c2410		MOVQ BX, 0x10(SP)	
  0x43565a		488b442440		MOVQ 0x40(SP), AX	
  0x43565f		4889442418		MOVQ AX, 0x18(SP)	
  0x435664		e8975b0100		CALL runtime.sigfwd(SB)	
  0x435669		ebd3			JMP 0x43563e		
		return false
  0x43566b		c644244800		MOVB $0x0, 0x48(SP)	
  0x435670		488b6c2420		MOVQ 0x20(SP), BP	
  0x435675		4883c428		ADDQ $0x28, SP		
  0x435679		c3			RET			
		return false
  0x43567a		c644244800		MOVB $0x0, 0x48(SP)	
  0x43567f		488b6c2420		MOVQ 0x20(SP), BP	
  0x435684		4883c428		ADDQ $0x28, SP		
  0x435688		c3			RET			
	if (c.sigcode() == _SI_USER || flags&_SigPanic == 0) && sig != _SIGPIPE {
  0x435689		0fbae203		BTL $0x3, DX		
  0x43568d		0f8376ffffff		JAE 0x435609		
  0x435693		e976ffffff		JMP 0x43560e		
		return false
  0x435698		c644244800		MOVB $0x0, 0x48(SP)	
  0x43569d		488b6c2420		MOVQ 0x20(SP), BP	
  0x4356a2		4883c428		ADDQ $0x28, SP		
  0x4356a6		c3			RET			
		return false
  0x4356a7		c644244800		MOVB $0x0, 0x48(SP)	
  0x4356ac		488b6c2420		MOVQ 0x20(SP), BP	
  0x4356b1		4883c428		ADDQ $0x28, SP		
  0x4356b5		c3			RET			
	fwdFn := atomic.Loaduintptr(&fwdSig[sig])
  0x4356b6		e865c8feff		CALL runtime.panicindex(SB)	
  0x4356bb		0f0b			UD2				

TEXT runtime.unblocksig(SB) /usr/local/go/src/runtime/signal_unix.go
func unblocksig(sig uint32) {
  0x4356c0		4883ec30		SUBQ $0x30, SP		
  0x4356c4		48896c2428		MOVQ BP, 0x28(SP)	
  0x4356c9		488d6c2428		LEAQ 0x28(SP), BP	
	var set sigset
  0x4356ce		48c744242000000000	MOVQ $0x0, 0x20(SP)	
	sigaddset(&set, int(sig))
  0x4356d7		90			NOPL			
	(*mask)[(i-1)/32] |= 1 << ((uint32(i) - 1) & 31)
  0x4356d8		8b442438		MOVL 0x38(SP), AX	
  0x4356dc		488d48ff		LEAQ -0x1(AX), CX	
  0x4356e0		48c1f93f		SARQ $0x3f, CX		
  0x4356e4		48c1e93b		SHRQ $0x3b, CX		
  0x4356e8		488d0c01		LEAQ 0(CX)(AX*1), CX	
  0x4356ec		488d49ff		LEAQ -0x1(CX), CX	
  0x4356f0		48c1f905		SARQ $0x5, CX		
  0x4356f4		4883f902		CMPQ $0x2, CX		
  0x4356f8		7343			JAE 0x43573d		
  0x4356fa		8b548c20		MOVL 0x20(SP)(CX*4), DX	
  0x4356fe		48c1e102		SHLQ $0x2, CX		
  0x435702		ffc8			DECL AX			
  0x435704		0fabc2			BTSL AX, DX		
  0x435707		89540c20		MOVL DX, 0x20(SP)(CX*1)	
	sigprocmask(_SIG_UNBLOCK, &set, nil)
  0x43570b		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x43570c		c7042401000000		MOVL $0x1, 0(SP)		
  0x435713		488d442420		LEAQ 0x20(SP), AX		
  0x435718		4889442408		MOVQ AX, 0x8(SP)		
  0x43571d		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x435726		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x43572e		e83d5a0100		CALL runtime.rtsigprocmask(SB)	
  0x435733		488b6c2428		MOVQ 0x28(SP), BP		
  0x435738		4883c430		ADDQ $0x30, SP			
  0x43573c		c3			RET				
	(*mask)[(i-1)/32] |= 1 << ((uint32(i) - 1) & 31)
  0x43573d		e8dec7feff		CALL runtime.panicindex(SB)	
  0x435742		0f0b			UD2				

TEXT runtime.minitSignals(SB) /usr/local/go/src/runtime/signal_unix.go
func minitSignals() {
  0x435750		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435759		483b6110		CMPQ 0x10(CX), SP	
  0x43575d		761f			JBE 0x43577e		
  0x43575f		4883ec08		SUBQ $0x8, SP		
  0x435763		48892c24		MOVQ BP, 0(SP)		
  0x435767		488d2c24		LEAQ 0(SP), BP		
	minitSignalStack()
  0x43576b		e820000000		CALL runtime.minitSignalStack(SB)	
	minitSignalMask()
  0x435770		e87b010000		CALL runtime.minitSignalMask(SB)	
}
  0x435775		488b2c24		MOVQ 0(SP), BP		
  0x435779		4883c408		ADDQ $0x8, SP		
  0x43577d		c3			RET			
func minitSignals() {
  0x43577e		e8fd200100		CALL runtime.morestack_noctxt(SB)	
  0x435783		ebcb			JMP runtime.minitSignals(SB)		

TEXT runtime.minitSignalStack(SB) /usr/local/go/src/runtime/signal_unix.go
func minitSignalStack() {
  0x435790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435799		483b6110		CMPQ 0x10(CX), SP	
  0x43579d		0f8637010000		JBE 0x4358da		
  0x4357a3		4883ec38		SUBQ $0x38, SP		
  0x4357a7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4357ac		488d6c2430		LEAQ 0x30(SP), BP	
	_g_ := getg()
  0x4357b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4357ba		4889442410		MOVQ AX, 0x10(SP)	
	var st stackt
  0x4357bf		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x4357c8		0f57c0			XORPS X0, X0		
  0x4357cb		0f11442420		MOVUPS X0, 0x20(SP)	
	sigaltstack(nil, &st)
  0x4357d0		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x4357d8		488d4c2418		LEAQ 0x18(SP), CX		
  0x4357dd		48894c2408		MOVQ CX, 0x8(SP)		
  0x4357e2		e8895d0100		CALL runtime.sigaltstack(SB)	
	if st.ss_flags&_SS_DISABLE != 0 {
  0x4357e7		8b442420		MOVL 0x20(SP), AX	
  0x4357eb		0fbae001		BTL $0x1, AX		
  0x4357ef		0f82b7000000		JB 0x4358ac		
		setGsignalStack(&st, &_g_.m.goSigStack)
  0x4357f5		488b442410		MOVQ 0x10(SP), AX	
  0x4357fa		488b4830		MOVQ 0x30(AX), CX	
  0x4357fe		8400			TESTB AL, 0(AX)		
	g := getg()
  0x435800		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
		old.stack = g.m.gsignal.stack
  0x435809		488b5a30		MOVQ 0x30(DX), BX	
  0x43580d		488b5b50		MOVQ 0x50(BX), BX	
		setGsignalStack(&st, &_g_.m.goSigStack)
  0x435811		90			NOPL			
		old.stack = g.m.gsignal.stack
  0x435812		488b7308		MOVQ 0x8(BX), SI	
  0x435816		488b1b			MOVQ 0(BX), BX		
  0x435819		48895958		MOVQ BX, 0x58(CX)	
  0x43581d		48897160		MOVQ SI, 0x60(CX)	
		old.stackguard0 = g.m.gsignal.stackguard0
  0x435821		488b5a30		MOVQ 0x30(DX), BX	
  0x435825		488b5b50		MOVQ 0x50(BX), BX	
  0x435829		488b5b10		MOVQ 0x10(BX), BX	
  0x43582d		48895968		MOVQ BX, 0x68(CX)	
		old.stackguard1 = g.m.gsignal.stackguard1
  0x435831		488b5a30		MOVQ 0x30(DX), BX	
  0x435835		488b5b50		MOVQ 0x50(BX), BX	
  0x435839		488b5b18		MOVQ 0x18(BX), BX	
  0x43583d		48895970		MOVQ BX, 0x70(CX)	
		old.stktopsp = g.m.gsignal.stktopsp
  0x435841		488b5a30		MOVQ 0x30(DX), BX	
  0x435845		488b5b50		MOVQ 0x50(BX), BX	
  0x435849		488b9b80000000		MOVQ 0x80(BX), BX	
  0x435850		48895978		MOVQ BX, 0x78(CX)	
	g.m.gsignal.stack.lo = stsp
  0x435854		488b4a30		MOVQ 0x30(DX), CX	
  0x435858		488b4950		MOVQ 0x50(CX), CX	
	stsp := uintptr(unsafe.Pointer(st.ss_sp))
  0x43585c		488b5c2418		MOVQ 0x18(SP), BX	
	g.m.gsignal.stack.lo = stsp
  0x435861		488919			MOVQ BX, 0(CX)		
	g.m.gsignal.stack.hi = stsp + st.ss_size
  0x435864		488b4a30		MOVQ 0x30(DX), CX	
  0x435868		488b4950		MOVQ 0x50(CX), CX	
  0x43586c		488b742428		MOVQ 0x28(SP), SI	
  0x435871		4801de			ADDQ BX, SI		
  0x435874		48897108		MOVQ SI, 0x8(CX)	
	g.m.gsignal.stackguard0 = stsp + _StackGuard
  0x435878		488b4a30		MOVQ 0x30(DX), CX	
  0x43587c		488b4950		MOVQ 0x50(CX), CX	
  0x435880		4881c370030000		ADDQ $0x370, BX		
  0x435887		48895910		MOVQ BX, 0x10(CX)	
	g.m.gsignal.stackguard1 = stsp + _StackGuard
  0x43588b		488b4a30		MOVQ 0x30(DX), CX	
  0x43588f		488b4950		MOVQ 0x50(CX), CX	
  0x435893		48895918		MOVQ BX, 0x18(CX)	
		_g_.m.newSigstack = false
  0x435897		488b4030		MOVQ 0x30(AX), AX	
  0x43589b		c6801701000000		MOVB $0x0, 0x117(AX)	
  0x4358a2		488b6c2430		MOVQ 0x30(SP), BP	
  0x4358a7		4883c438		ADDQ $0x38, SP		
  0x4358ab		c3			RET			
		signalstack(&_g_.m.gsignal.stack)
  0x4358ac		488b442410		MOVQ 0x10(SP), AX		
  0x4358b1		488b4830		MOVQ 0x30(AX), CX		
  0x4358b5		488b5150		MOVQ 0x50(CX), DX		
  0x4358b9		8402			TESTB AL, 0(DX)			
  0x4358bb		8400			TESTB AL, 0(AX)			
  0x4358bd		8401			TESTB AL, 0(CX)			
  0x4358bf		48891424		MOVQ DX, 0(SP)			
  0x4358c3		e8c8010000		CALL runtime.signalstack(SB)	
		_g_.m.newSigstack = true
  0x4358c8		488b442410		MOVQ 0x10(SP), AX	
  0x4358cd		488b4030		MOVQ 0x30(AX), AX	
  0x4358d1		c6801701000001		MOVB $0x1, 0x117(AX)	
  0x4358d8		ebc8			JMP 0x4358a2		
func minitSignalStack() {
  0x4358da		e8a11f0100		CALL runtime.morestack_noctxt(SB)	
  0x4358df		e9acfeffff		JMP runtime.minitSignalStack(SB)	

TEXT runtime.minitSignalMask(SB) /usr/local/go/src/runtime/signal_unix.go
func minitSignalMask() {
  0x4358f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4358f9		483b6110		CMPQ 0x10(CX), SP	
  0x4358fd		0f86e4000000		JBE 0x4359e7		
  0x435903		4883ec30		SUBQ $0x30, SP		
  0x435907		48896c2428		MOVQ BP, 0x28(SP)	
  0x43590c		488d6c2428		LEAQ 0x28(SP), BP	
	nmask := getg().m.sigmask
  0x435911		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43591a		488b4030		MOVQ 0x30(AX), AX	
  0x43591e		488b8080000000		MOVQ 0x80(AX), AX	
  0x435925		4889442420		MOVQ AX, 0x20(SP)	
  0x43592a		31c0			XORL AX, AX		
	for i := range sigtable {
  0x43592c		eb03			JMP 0x435931		
  0x43592e		48ffc0			INCQ AX			
  0x435931		4883f841		CMPQ $0x41, AX		
  0x435935		7d70			JGE 0x4359a7		
		if !blockableSig(uint32(i)) {
  0x435937		90			NOPL			
	flags := sigtable[sig].flags
  0x435938		89c1			MOVL AX, CX			
  0x43593a		4883f941		CMPQ $0x41, CX			
  0x43593e		0f839c000000		JAE 0x4359e0			
  0x435944		488d0c49		LEAQ 0(CX)(CX*2), CX		
  0x435948		488d1531a90800		LEAQ runtime.sigtable(SB), DX	
  0x43594f		8b0cca			MOVL 0(DX)(CX*8), CX		
	if flags&_SigUnblock != 0 {
  0x435952		0fbae107		BTL $0x7, CX		
  0x435956		7333			JAE 0x43598b		
			sigdelset(&nmask, i)
  0x435958		90			NOPL			
	(*mask)[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)
  0x435959		488d48ff		LEAQ -0x1(AX), CX	
  0x43595d		48c1f93f		SARQ $0x3f, CX		
  0x435961		48c1e93b		SHRQ $0x3b, CX		
  0x435965		488d0c01		LEAQ 0(CX)(AX*1), CX	
  0x435969		488d49ff		LEAQ -0x1(CX), CX	
  0x43596d		48c1f905		SARQ $0x5, CX		
  0x435971		4883f902		CMPQ $0x2, CX		
  0x435975		7362			JAE 0x4359d9		
  0x435977		8b5c8c20		MOVL 0x20(SP)(CX*4), BX	
  0x43597b		48c1e102		SHLQ $0x2, CX		
  0x43597f		8d70ff			LEAL -0x1(AX), SI	
  0x435982		0fb3f3			BTRL SI, BX		
  0x435985		895c0c20		MOVL BX, 0x20(SP)(CX*1)	
	for i := range sigtable {
  0x435989		eba3			JMP 0x43592e		
	if isarchive || islibrary {
  0x43598b		803d1b730a0000		CMPB $0x0, runtime.isarchive(SB)	
  0x435992		759a			JNE 0x43592e				
  0x435994		803d14730a0000		CMPB $0x0, runtime.islibrary(SB)	
  0x43599b		7591			JNE 0x43592e				
	return flags&(_SigKill|_SigThrow) == 0
  0x43599d		f7c106000000		TESTL $0x6, CX		
		if !blockableSig(uint32(i)) {
  0x4359a3		7489			JE 0x43592e		
  0x4359a5		ebb1			JMP 0x435958		
	sigprocmask(_SIG_SETMASK, &nmask, nil)
  0x4359a7		90			NOPL			
	rtsigprocmask(how, new, old, int32(unsafe.Sizeof(*new)))
  0x4359a8		c7042402000000		MOVL $0x2, 0(SP)		
  0x4359af		488d442420		LEAQ 0x20(SP), AX		
  0x4359b4		4889442408		MOVQ AX, 0x8(SP)		
  0x4359b9		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x4359c2		c744241808000000	MOVL $0x8, 0x18(SP)		
  0x4359ca		e8a1570100		CALL runtime.rtsigprocmask(SB)	
  0x4359cf		488b6c2428		MOVQ 0x28(SP), BP		
  0x4359d4		4883c430		ADDQ $0x30, SP			
  0x4359d8		c3			RET				
	(*mask)[(i-1)/32] &^= 1 << ((uint32(i) - 1) & 31)
  0x4359d9		e842c5feff		CALL runtime.panicindex(SB)	
  0x4359de		0f0b			UD2				
	flags := sigtable[sig].flags
  0x4359e0		e83bc5feff		CALL runtime.panicindex(SB)	
  0x4359e5		0f0b			UD2				
func minitSignalMask() {
  0x4359e7		e8941e0100		CALL runtime.morestack_noctxt(SB)	
  0x4359ec		e9fffeffff		JMP runtime.minitSignalMask(SB)		

TEXT runtime.unminitSignals(SB) /usr/local/go/src/runtime/signal_unix.go
func unminitSignals() {
  0x435a00		4883ec30		SUBQ $0x30, SP		
  0x435a04		48896c2428		MOVQ BP, 0x28(SP)	
  0x435a09		488d6c2428		LEAQ 0x28(SP), BP	
	if getg().m.newSigstack {
  0x435a0e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x435a17		488b4030		MOVQ 0x30(AX), AX	
  0x435a1b		80b81701000000		CMPB $0x0, 0x117(AX)	
  0x435a22		7539			JNE 0x435a5d		
	gp := getg().m.gsignal
  0x435a24		488b4850		MOVQ 0x50(AX), CX	
		restoreGsignalStack(&getg().m.goSigStack)
  0x435a28		90			NOPL			
	gp.stack = st.stack
  0x435a29		488b5060		MOVQ 0x60(AX), DX	
  0x435a2d		488b5858		MOVQ 0x58(AX), BX	
  0x435a31		488919			MOVQ BX, 0(CX)		
  0x435a34		48895108		MOVQ DX, 0x8(CX)	
	gp.stackguard0 = st.stackguard0
  0x435a38		488b5068		MOVQ 0x68(AX), DX	
  0x435a3c		48895110		MOVQ DX, 0x10(CX)	
	gp.stackguard1 = st.stackguard1
  0x435a40		488b5070		MOVQ 0x70(AX), DX	
  0x435a44		48895118		MOVQ DX, 0x18(CX)	
	gp.stktopsp = st.stktopsp
  0x435a48		488b4078		MOVQ 0x78(AX), AX	
  0x435a4c		48898180000000		MOVQ AX, 0x80(CX)	
  0x435a53		488b6c2428		MOVQ 0x28(SP), BP	
  0x435a58		4883c430		ADDQ $0x30, SP		
  0x435a5c		c3			RET			
		st := stackt{ss_flags: _SS_DISABLE}
  0x435a5d		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x435a66		0f57c0			XORPS X0, X0		
  0x435a69		0f11442418		MOVUPS X0, 0x18(SP)	
  0x435a6e		c744241802000000	MOVL $0x2, 0x18(SP)	
		sigaltstack(&st, nil)
  0x435a76		488d442410		LEAQ 0x10(SP), AX		
  0x435a7b		48890424		MOVQ AX, 0(SP)			
  0x435a7f		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x435a88		e8e35a0100		CALL runtime.sigaltstack(SB)	
  0x435a8d		ebc4			JMP 0x435a53			

TEXT runtime.signalstack(SB) /usr/local/go/src/runtime/signal_unix.go
func signalstack(s *stack) {
  0x435a90		4883ec30		SUBQ $0x30, SP		
  0x435a94		48896c2428		MOVQ BP, 0x28(SP)	
  0x435a99		488d6c2428		LEAQ 0x28(SP), BP	
	st := stackt{ss_size: s.hi - s.lo}
  0x435a9e		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x435aa7		0f57c0			XORPS X0, X0		
  0x435aaa		0f11442418		MOVUPS X0, 0x18(SP)	
  0x435aaf		488b442438		MOVQ 0x38(SP), AX	
  0x435ab4		488b4808		MOVQ 0x8(AX), CX	
  0x435ab8		482b08			SUBQ 0(AX), CX		
  0x435abb		48894c2420		MOVQ CX, 0x20(SP)	
	setSignalstackSP(&st, s.lo)
  0x435ac0		90			NOPL			
  0x435ac1		488b00			MOVQ 0(AX), AX		
	*(*uintptr)(unsafe.Pointer(&s.ss_sp)) = sp
  0x435ac4		4889442410		MOVQ AX, 0x10(SP)	
	sigaltstack(&st, nil)
  0x435ac9		488d442410		LEAQ 0x10(SP), AX		
  0x435ace		48890424		MOVQ AX, 0(SP)			
  0x435ad2		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x435adb		e8905a0100		CALL runtime.sigaltstack(SB)	
}
  0x435ae0		488b6c2428		MOVQ 0x28(SP), BP	
  0x435ae5		4883c430		ADDQ $0x30, SP		
  0x435ae9		c3			RET			

TEXT runtime.sigsend(SB) /usr/local/go/src/runtime/sigqueue.go
func sigsend(s uint32) bool {
  0x435af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435af9		483b6110		CMPQ 0x10(CX), SP	
  0x435afd		0f866d010000		JBE 0x435c70		
  0x435b03		4883ec18		SUBQ $0x18, SP		
  0x435b07		48896c2410		MOVQ BP, 0x10(SP)	
  0x435b0c		488d6c2410		LEAQ 0x10(SP), BP	
	if !sig.inuse || s >= uint32(32*len(sig.wanted)) {
  0x435b11		803d88740a0000		CMPB $0x0, runtime.sig+64(SB)	
  0x435b18		0f8421010000		JE 0x435c3f			
  0x435b1e		8b4c2420		MOVL 0x20(SP), CX		
  0x435b22		83f960			CMPL $0x60, CX			
  0x435b25		0f8314010000		JAE 0x435c3f			
	atomic.Xadd(&sig.delivering, 1)
  0x435b2b		ba01000000		MOVL $0x1, DX			
  0x435b30		488d1d65740a00		LEAQ runtime.sig+60(SB), BX	
  0x435b37		f00fc113		LOCK XADDL DX, 0(BX)		
	if w := atomic.Load(&sig.wanted[s/32]); w&bit == 0 {
  0x435b3b		89ca			MOVL CX, DX			
  0x435b3d		c1e905			SHRL $0x5, CX			
  0x435b40		4883f903		CMPQ $0x3, CX			
  0x435b44		0f831f010000		JAE 0x435c69			
  0x435b4a		488d3523740a00		LEAQ runtime.sig+20(SB), SI	
  0x435b51		488d348e		LEAQ 0(SI)(CX*4), SI		
  0x435b55		8b36			MOVL 0(SI), SI			
  0x435b57		0fa3d6			BTL DX, SI			
  0x435b5a		0f83c7000000		JAE 0x435c27			
		mask := sig.mask[s/32]
  0x435b60		488d3501740a00		LEAQ runtime.sig+8(SB), SI	
  0x435b67		8b048e			MOVL 0(SI)(CX*4), AX		
		if mask&bit != 0 {
  0x435b6a		0fa3d0			BTL DX, AX		
  0x435b6d		0f829c000000		JB 0x435c0f		
		mask := sig.mask[s/32]
  0x435b73		488d348e		LEAQ 0(SI)(CX*4), SI	
		if atomic.Cas(&sig.mask[s/32], mask, mask|bit) {
  0x435b77		89c7			MOVL AX, DI		
  0x435b79		0fabd0			BTSL DX, AX		
  0x435b7c		4189c0			MOVL AX, R8		
  0x435b7f		89f8			MOVL DI, AX		
  0x435b81		f0440fb106		LOCK CMPXCHGL R8, 0(SI)	
  0x435b86		400f94c6		SETE SI			
  0x435b8a		4084f6			TESTL SI, SI		
  0x435b8d		74d1			JE 0x435b60		
		switch atomic.Load(&sig.state) {
  0x435b8f		8b0d03740a00		MOVL runtime.sig+56(SB), CX	
		case sigIdle:
  0x435b95		85c9			TESTL CX, CX		
  0x435b97		7531			JNE 0x435bca		
			if atomic.Cas(&sig.state, sigIdle, sigSending) {
  0x435b99		31c0			XORL AX, AX			
  0x435b9b		488d0df6730a00		LEAQ runtime.sig+56(SB), CX	
  0x435ba2		ba02000000		MOVL $0x2, DX			
  0x435ba7		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x435bab		0f94c1			SETE CL				
  0x435bae		84c9			TESTL CL, CL			
  0x435bb0		74dd			JE 0x435b8f			
	atomic.Xadd(&sig.delivering, -1)
  0x435bb2		b8ffffffff		MOVL $-0x1, AX		
  0x435bb7		f00fc103		LOCK XADDL AX, 0(BX)	
	return true
  0x435bbb		c644242801		MOVB $0x1, 0x28(SP)	
  0x435bc0		488b6c2410		MOVQ 0x10(SP), BP	
  0x435bc5		4883c418		ADDQ $0x18, SP		
  0x435bc9		c3			RET			
		case sigReceiving:
  0x435bca		83f901			CMPL $0x1, CX		
  0x435bcd		7539			JNE 0x435c08		
			if atomic.Cas(&sig.state, sigReceiving, sigIdle) {
  0x435bcf		b801000000		MOVL $0x1, AX			
  0x435bd4		488d0dbd730a00		LEAQ runtime.sig+56(SB), CX	
  0x435bdb		31d2			XORL DX, DX			
  0x435bdd		f00fb111		LOCK CMPXCHGL DX, 0(CX)		
  0x435be1		0f94c1			SETE CL				
  0x435be4		84c9			TESTL CL, CL			
  0x435be6		7507			JNE 0x435bef			
  0x435be8		ba02000000		MOVL $0x2, DX			
		switch atomic.Load(&sig.state) {
  0x435bed		eba0			JMP 0x435b8f		
				notewakeup(&sig.note)
  0x435bef		488d056a730a00		LEAQ runtime.sig(SB), AX	
  0x435bf6		48890424		MOVQ AX, 0(SP)			
  0x435bfa		e8612dfdff		CALL runtime.notewakeup(SB)	
	atomic.Xadd(&sig.delivering, 1)
  0x435bff		488d1d96730a00		LEAQ runtime.sig+60(SB), BX	
				break Send
  0x435c06		ebaa			JMP 0x435bb2		
		case sigSending:
  0x435c08		83f902			CMPL $0x2, CX		
  0x435c0b		74a5			JE 0x435bb2		
  0x435c0d		eb3f			JMP 0x435c4e		
			atomic.Xadd(&sig.delivering, -1)
  0x435c0f		b8ffffffff		MOVL $-0x1, AX		
  0x435c14		f00fc103		LOCK XADDL AX, 0(BX)	
			return true // signal already in queue
  0x435c18		c644242801		MOVB $0x1, 0x28(SP)	
  0x435c1d		488b6c2410		MOVQ 0x10(SP), BP	
  0x435c22		4883c418		ADDQ $0x18, SP		
  0x435c26		c3			RET			
		atomic.Xadd(&sig.delivering, -1)
  0x435c27		b8ffffffff		MOVL $-0x1, AX		
  0x435c2c		f00fc103		LOCK XADDL AX, 0(BX)	
		return false
  0x435c30		c644242800		MOVB $0x0, 0x28(SP)	
  0x435c35		488b6c2410		MOVQ 0x10(SP), BP	
  0x435c3a		4883c418		ADDQ $0x18, SP		
  0x435c3e		c3			RET			
		return false
  0x435c3f		c644242800		MOVB $0x0, 0x28(SP)	
  0x435c44		488b6c2410		MOVQ 0x10(SP), BP	
  0x435c49		4883c418		ADDQ $0x18, SP		
  0x435c4d		c3			RET			
			throw("sigsend: inconsistent state")
  0x435c4e		488d05deb80300		LEAQ 0x3b8de(IP), AX	
  0x435c55		48890424		MOVQ AX, 0(SP)		
  0x435c59		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x435c62		e819d8feff		CALL runtime.throw(SB)	
  0x435c67		0f0b			UD2			
	if w := atomic.Load(&sig.wanted[s/32]); w&bit == 0 {
  0x435c69		e8b2c2feff		CALL runtime.panicindex(SB)	
  0x435c6e		0f0b			UD2				
func sigsend(s uint32) bool {
  0x435c70		e80b1c0100		CALL runtime.morestack_noctxt(SB)	
  0x435c75		e976feffff		JMP runtime.sigsend(SB)			

TEXT runtime.makeslice(SB) /usr/local/go/src/runtime/slice.go
func makeslice(et *_type, len, cap int) unsafe.Pointer {
  0x435c80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435c89		483b6110		CMPQ 0x10(CX), SP	
  0x435c8d		0f86e1000000		JBE 0x435d74		
  0x435c93		4883ec28		SUBQ $0x28, SP		
  0x435c97		48896c2420		MOVQ BP, 0x20(SP)	
  0x435c9c		488d6c2420		LEAQ 0x20(SP), BP	
	mem, overflow := math.MulUintptr(et.size, uintptr(cap))
  0x435ca1		488b4c2430		MOVQ 0x30(SP), CX	
  0x435ca6		488b01			MOVQ 0(CX), AX		
  0x435ca9		488b542440		MOVQ 0x40(SP), DX	
  0x435cae		4889c3			MOVQ AX, BX		
  0x435cb1		48f7e2			MULQ DX			
	if overflow || mem > maxAlloc || len < 0 || len > cap {
  0x435cb4		706f			JO 0x435d25			
  0x435cb6		48ba0000000000000100	MOVQ $0x1000000000000, DX	
  0x435cc0		4839d0			CMPQ DX, AX			
  0x435cc3		7759			JA 0x435d1e			
  0x435cc5		488b742438		MOVQ 0x38(SP), SI		
  0x435cca		4885f6			TESTQ SI, SI			
  0x435ccd		7c31			JL 0x435d00			
  0x435ccf		488b7c2440		MOVQ 0x40(SP), DI		
  0x435cd4		4839fe			CMPQ DI, SI			
  0x435cd7		7f27			JG 0x435d00			
	return mallocgc(mem, et, true)
  0x435cd9		48890424		MOVQ AX, 0(SP)			
  0x435cdd		48894c2408		MOVQ CX, 0x8(SP)		
  0x435ce2		c644241001		MOVB $0x1, 0x10(SP)		
  0x435ce7		e8243ffdff		CALL runtime.mallocgc(SB)	
  0x435cec		488b442418		MOVQ 0x18(SP), AX		
  0x435cf1		4889442448		MOVQ AX, 0x48(SP)		
  0x435cf6		488b6c2420		MOVQ 0x20(SP), BP		
  0x435cfb		4883c428		ADDQ $0x28, SP			
  0x435cff		c3			RET				
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
  0x435d00		4889d8			MOVQ BX, AX		
  0x435d03		48f7e6			MULQ SI			
		if overflow || mem > maxAlloc || len < 0 {
  0x435d06		702e			JO 0x435d36			
  0x435d08		48b90000000000000100	MOVQ $0x1000000000000, CX	
  0x435d12		4839c8			CMPQ CX, AX			
  0x435d15		771f			JA 0x435d36			
  0x435d17		4885f6			TESTQ SI, SI			
  0x435d1a		7c1a			JL 0x435d36			
  0x435d1c		eb37			JMP 0x435d55			
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
  0x435d1e		488b742438		MOVQ 0x38(SP), SI	
	if overflow || mem > maxAlloc || len < 0 || len > cap {
  0x435d23		ebdb			JMP 0x435d00			
  0x435d25		48ba0000000000000100	MOVQ $0x1000000000000, DX	
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
  0x435d2f		488b742438		MOVQ 0x38(SP), SI	
	if overflow || mem > maxAlloc || len < 0 || len > cap {
  0x435d34		ebca			JMP 0x435d00		
			panicmakeslicelen()
  0x435d36		90			NOPL			
	panic(errorString("makeslice: len out of range"))
  0x435d37		488d05a2920200		LEAQ 0x292a2(IP), AX			
  0x435d3e		48890424		MOVQ AX, 0(SP)				
  0x435d42		488d0587720400		LEAQ runtime.statictmp_28(SB), AX	
  0x435d49		4889442408		MOVQ AX, 0x8(SP)			
  0x435d4e		e85dd1feff		CALL runtime.gopanic(SB)		
  0x435d53		0f0b			UD2					
		panicmakeslicecap()
  0x435d55		90			NOPL			
	panic(errorString("makeslice: cap out of range"))
  0x435d56		488d0583920200		LEAQ 0x29283(IP), AX			
  0x435d5d		48890424		MOVQ AX, 0(SP)				
  0x435d61		488d0578720400		LEAQ runtime.statictmp_29(SB), AX	
  0x435d68		4889442408		MOVQ AX, 0x8(SP)			
  0x435d6d		e83ed1feff		CALL runtime.gopanic(SB)		
  0x435d72		0f0b			UD2					
func makeslice(et *_type, len, cap int) unsafe.Pointer {
  0x435d74		e8071b0100		CALL runtime.morestack_noctxt(SB)	
  0x435d79		e902ffffff		JMP runtime.makeslice(SB)		

TEXT runtime.growslice(SB) /usr/local/go/src/runtime/slice.go
func growslice(et *_type, old slice, cap int) slice {
  0x435d80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x435d89		483b6110		CMPQ 0x10(CX), SP	
  0x435d8d		0f8620060000		JBE 0x4363b3		
  0x435d93		4883ec60		SUBQ $0x60, SP		
  0x435d97		48896c2458		MOVQ BP, 0x58(SP)	
  0x435d9c		488d6c2458		LEAQ 0x58(SP), BP	
	if cap < old.cap {
  0x435da1		488b942488000000	MOVQ 0x88(SP), DX	
  0x435da9		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x435db1		4839da			CMPQ BX, DX		
  0x435db4		0f8cdb050000		JL 0x436395		
	if et.size == 0 {
  0x435dba		488b742468		MOVQ 0x68(SP), SI	
  0x435dbf		488b3e			MOVQ 0(SI), DI		
  0x435dc2		4885ff			TESTQ DI, DI		
  0x435dc5		0f8446050000		JE 0x436311		
	doublecap := newcap + newcap
  0x435dcb		4c8d041b		LEAQ 0(BX)(BX*1), R8	
	if cap > doublecap {
  0x435dcf		4c39c2			CMPQ R8, DX		
  0x435dd2		0f8f2c050000		JG 0x436304		
		if old.len < 1024 {
  0x435dd8		4c8b4c2478		MOVQ 0x78(SP), R9	
  0x435ddd		4981f900040000		CMPQ $0x400, R9		
  0x435de4		7d1c			JGE 0x435e02		
  0x435de6		e90e050000		JMP 0x4362f9		
				newcap += newcap / 4
  0x435deb		4989d8			MOVQ BX, R8		
  0x435dee		48c1fb3f		SARQ $0x3f, BX		
  0x435df2		48c1eb3e		SHRQ $0x3e, BX		
  0x435df6		4e8d1403		LEAQ 0(BX)(R8*1), R10	
  0x435dfa		49c1fa02		SARQ $0x2, R10		
  0x435dfe		4b8d1c02		LEAQ 0(R10)(R8*1), BX	
			for 0 < newcap && newcap < cap {
  0x435e02		4885db			TESTQ BX, BX		
  0x435e05		7e08			JLE 0x435e0f		
  0x435e07		4839d3			CMPQ DX, BX		
  0x435e0a		7cdf			JL 0x435deb		
  0x435e0c		4885db			TESTQ BX, BX		
			if newcap <= 0 {
  0x435e0f		0f8fd9040000		JG 0x4362ee		
func growslice(et *_type, old slice, cap int) slice {
  0x435e15		4889d0			MOVQ DX, AX		
	case et.size == 1:
  0x435e18		4883ff01		CMPQ $0x1, DI		
  0x435e1c		0f85e3010000		JNE 0x436005		
		capmem = roundupsize(uintptr(newcap))
  0x435e22		90			NOPL			
	if size < _MaxSmallSize {
  0x435e23		4881fa00800000		CMPQ $0x8000, DX	
  0x435e2a		0f83ad010000		JAE 0x435fdd		
		if size <= smallSizeMax-8 {
  0x435e30		4881faf8030000		CMPQ $0x3f8, DX		
  0x435e37		0f8763010000		JA 0x435fa0		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x435e3d		488d4a07		LEAQ 0x7(DX), CX			
  0x435e41		48c1e903		SHRQ $0x3, CX				
  0x435e45		4881f981000000		CMPQ $0x81, CX				
  0x435e4c		0f833c050000		JAE 0x43638e				
  0x435e52		488d1de7920800		LEAQ runtime.size_to_class8(SB), BX	
  0x435e59		0fb60c19		MOVZX 0(CX)(BX*1), CX			
  0x435e5d		4883f943		CMPQ $0x43, CX				
  0x435e61		0f8327050000		JAE 0x43638e				
  0x435e67		488d1d72930800		LEAQ runtime.class_to_size(SB), BX	
  0x435e6e		0fb70c4b		MOVZX 0(BX)(CX*2), CX			
		overflow = uintptr(newcap) > maxAlloc
  0x435e72		48bb0000000000000100	MOVQ $0x1000000000000, BX	
  0x435e7c		4839da			CMPQ BX, DX			
  0x435e7f		0f97c2			SETA DL				
func growslice(et *_type, old slice, cap int) slice {
  0x435e82		4c89cf			MOVQ R9, DI		
	return slice{p, old.len, newcap}
  0x435e85		4989c8			MOVQ CX, R8		
	if overflow || capmem > maxAlloc {
  0x435e88		84d2			TESTL DL, DL		
  0x435e8a		0f85af040000		JNE 0x43633f		
  0x435e90		4839d9			CMPQ BX, CX		
  0x435e93		0f87a6040000		JA 0x43633f		
			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
  0x435e99		4c894c2430		MOVQ R9, 0x30(SP)	
	return slice{p, old.len, newcap}
  0x435e9e		4c89442428		MOVQ R8, 0x28(SP)	
	if et.kind&kindNoPointers != 0 {
  0x435ea3		0fb65617		MOVZX 0x17(SI), DX	
  0x435ea7		f6c280			TESTL $0x80, DL		
  0x435eaa		0f84a3000000		JE 0x435f53		
		p = mallocgc(capmem, et, true)
  0x435eb0		48894c2438		MOVQ CX, 0x38(SP)	
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
  0x435eb5		4889442420		MOVQ AX, 0x20(SP)	
		p = mallocgc(capmem, nil, false)
  0x435eba		48890c24		MOVQ CX, 0(SP)			
  0x435ebe		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x435ec7		c644241000		MOVB $0x0, 0x10(SP)		
  0x435ecc		e83f3dfdff		CALL runtime.mallocgc(SB)	
  0x435ed1		488b442418		MOVQ 0x18(SP), AX		
  0x435ed6		4889442450		MOVQ AX, 0x50(SP)		
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
  0x435edb		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x435edc		488b4c2420		MOVQ 0x20(SP), CX	
  0x435ee1		488d1408		LEAQ 0(AX)(CX*1), DX	
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
  0x435ee5		48891424		MOVQ DX, 0(SP)				
  0x435ee9		488b542438		MOVQ 0x38(SP), DX			
  0x435eee		4829ca			SUBQ CX, DX				
  0x435ef1		4889542408		MOVQ DX, 0x8(SP)			
  0x435ef6		e8c5450100		CALL runtime.memclrNoHeapPointers(SB)	
	memmove(p, old.array, lenmem)
  0x435efb		488b442450		MOVQ 0x50(SP), AX		
  0x435f00		4889442448		MOVQ AX, 0x48(SP)		
  0x435f05		48890424		MOVQ AX, 0(SP)			
  0x435f09		488b4c2470		MOVQ 0x70(SP), CX		
  0x435f0e		48894c2408		MOVQ CX, 0x8(SP)		
  0x435f13		488b4c2430		MOVQ 0x30(SP), CX		
  0x435f18		48894c2410		MOVQ CX, 0x10(SP)		
  0x435f1d		e82e480100		CALL runtime.memmove(SB)	
	return slice{p, old.len, newcap}
  0x435f22		488b442448		MOVQ 0x48(SP), AX	
  0x435f27		4889842490000000	MOVQ AX, 0x90(SP)	
  0x435f2f		488b442478		MOVQ 0x78(SP), AX	
  0x435f34		4889842498000000	MOVQ AX, 0x98(SP)	
  0x435f3c		488b442428		MOVQ 0x28(SP), AX	
  0x435f41		48898424a0000000	MOVQ AX, 0xa0(SP)	
  0x435f49		488b6c2458		MOVQ 0x58(SP), BP	
  0x435f4e		4883c460		ADDQ $0x60, SP		
  0x435f52		c3			RET			
		p = mallocgc(capmem, et, true)
  0x435f53		48890c24		MOVQ CX, 0(SP)			
  0x435f57		4889742408		MOVQ SI, 0x8(SP)		
  0x435f5c		c644241001		MOVB $0x1, 0x10(SP)		
  0x435f61		e8aa3cfdff		CALL runtime.mallocgc(SB)	
  0x435f66		488b442418		MOVQ 0x18(SP), AX		
		if writeBarrier.enabled {
  0x435f6b		803dae6e0a0000		CMPB $0x0, runtime.writeBarrier(SB)	
  0x435f72		748c			JE 0x435f00				
		p = mallocgc(capmem, et, true)
  0x435f74		4889442448		MOVQ AX, 0x48(SP)	
			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
  0x435f79		48890424		MOVQ AX, 0(SP)					
  0x435f7d		488b442470		MOVQ 0x70(SP), AX				
  0x435f82		4889442408		MOVQ AX, 0x8(SP)				
  0x435f87		488b442430		MOVQ 0x30(SP), AX				
  0x435f8c		4889442410		MOVQ AX, 0x10(SP)				
  0x435f91		e88a86fdff		CALL runtime.bulkBarrierPreWriteSrcOnly(SB)	
	memmove(p, old.array, lenmem)
  0x435f96		488b442448		MOVQ 0x48(SP), AX	
			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
  0x435f9b		e960ffffff		JMP 0x435f00		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x435fa0		488d8a7ffcffff		LEAQ 0xfffffc7f(DX), CX			
  0x435fa7		48c1e907		SHRQ $0x7, CX				
  0x435fab		4881f9f9000000		CMPQ $0xf9, CX				
  0x435fb2		0f83cf030000		JAE 0x436387				
  0x435fb8		488d1dc1920800		LEAQ runtime.size_to_class128(SB), BX	
  0x435fbf		0fb60c19		MOVZX 0(CX)(BX*1), CX			
  0x435fc3		4883f943		CMPQ $0x43, CX				
  0x435fc7		0f83ba030000		JAE 0x436387				
  0x435fcd		488d1d0c920800		LEAQ runtime.class_to_size(SB), BX	
  0x435fd4		0fb70c4b		MOVZX 0(BX)(CX*2), CX			
		capmem = roundupsize(uintptr(newcap))
  0x435fd8		e995feffff		JMP 0x435e72		
	if size+_PageSize < size {
  0x435fdd		488d8a00200000		LEAQ 0x2000(DX), CX	
  0x435fe4		4839d1			CMPQ DX, CX		
  0x435fe7		7308			JAE 0x435ff1		
		capmem = roundupsize(uintptr(newcap))
  0x435fe9		4889d1			MOVQ DX, CX		
  0x435fec		e981feffff		JMP 0x435e72		
	return round(size, _PageSize)
  0x435ff1		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x435ff2		488d8aff1f0000		LEAQ 0x1fff(DX), CX	
  0x435ff9		4881e100e0ffff		ANDQ $-0x2000, CX	
		capmem = roundupsize(uintptr(newcap))
  0x436000		e96dfeffff		JMP 0x435e72		
	case et.size == sys.PtrSize:
  0x436005		4883ff08		CMPQ $0x8, DI		
  0x436009		0f85e5000000		JNE 0x4360f4		
		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
  0x43600f		90			NOPL			
  0x436010		4889d1			MOVQ DX, CX		
  0x436013		48c1e203		SHLQ $0x3, DX		
	if size < _MaxSmallSize {
  0x436017		4881fa00800000		CMPQ $0x8000, DX	
  0x43601e		0f83b0000000		JAE 0x4360d4		
		if size <= smallSizeMax-8 {
  0x436024		4881faf8030000		CMPQ $0x3f8, DX		
  0x43602b		776d			JA 0x43609a		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x43602d		4883c207		ADDQ $0x7, DX				
  0x436031		48c1ea03		SHRQ $0x3, DX				
  0x436035		4881fa81000000		CMPQ $0x81, DX				
  0x43603c		0f833e030000		JAE 0x436380				
  0x436042		488d1df7900800		LEAQ runtime.size_to_class8(SB), BX	
  0x436049		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x43604d		4883fa43		CMPQ $0x43, DX				
  0x436051		0f8329030000		JAE 0x436380				
  0x436057		488d1d82910800		LEAQ runtime.class_to_size(SB), BX	
  0x43605e		0fb71453		MOVZX 0(BX)(DX*2), DX			
		overflow = uintptr(newcap) > maxAlloc/sys.PtrSize
  0x436062		49ba0000000000200000	MOVQ $0x200000000000, R10	
  0x43606c		4c39d1			CMPQ R10, CX			
  0x43606f		410f97c2		SETA R10			
		lenmem = uintptr(old.len) * sys.PtrSize
  0x436073		4c89cf			MOVQ R9, DI		
  0x436076		49c1e103		SHLQ $0x3, R9		
		newlenmem = uintptr(cap) * sys.PtrSize
  0x43607a		48c1e003		SHLQ $0x3, AX		
		newcap = int(capmem / sys.PtrSize)
  0x43607e		4989d0			MOVQ DX, R8			
  0x436081		49c1e803		SHRQ $0x3, R8			
  0x436085		48bb0000000000000100	MOVQ $0x1000000000000, BX	
		p = mallocgc(capmem, et, true)
  0x43608f		4889d1			MOVQ DX, CX		
	if overflow || capmem > maxAlloc {
  0x436092		4489d2			MOVL R10, DX		
	switch {
  0x436095		e9eefdffff		JMP 0x435e88		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x43609a		4881c27ffcffff		ADDQ $-0x381, DX			
  0x4360a1		48c1ea07		SHRQ $0x7, DX				
  0x4360a5		4881faf9000000		CMPQ $0xf9, DX				
  0x4360ac		0f83c7020000		JAE 0x436379				
  0x4360b2		488d1dc7910800		LEAQ runtime.size_to_class128(SB), BX	
  0x4360b9		0fb6141a		MOVZX 0(DX)(BX*1), DX			
  0x4360bd		4883fa43		CMPQ $0x43, DX				
  0x4360c1		0f83b2020000		JAE 0x436379				
  0x4360c7		488d1d12910800		LEAQ runtime.class_to_size(SB), BX	
  0x4360ce		0fb71453		MOVZX 0(BX)(DX*2), DX			
		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
  0x4360d2		eb8e			JMP 0x436062		
	if size+_PageSize < size {
  0x4360d4		488d9a00200000		LEAQ 0x2000(DX), BX	
  0x4360db		4839d3			CMPQ DX, BX		
  0x4360de		7282			JB 0x436062		
	return round(size, _PageSize)
  0x4360e0		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x4360e1		4881c2ff1f0000		ADDQ $0x1fff, DX	
  0x4360e8		4881e200e0ffff		ANDQ $-0x2000, DX	
		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
  0x4360ef		e96effffff		JMP 0x436062		
	case isPowerOfTwo(et.size):
  0x4360f4		90			NOPL			
	return x&(x-1) == 0
  0x4360f5		488d5fff		LEAQ -0x1(DI), BX	
  0x4360f9		4885df			TESTQ BX, DI		
	case isPowerOfTwo(et.size):
  0x4360fc		0f85ef000000		JNE 0x4361f1		
			shift = uintptr(sys.Ctz64(uint64(et.size))) & 63
  0x436102		480fbcdf		BSFQ DI, BX		
		lenmem = uintptr(old.len) << shift
  0x436106		4889d9			MOVQ BX, CX		
  0x436109		4c89cf			MOVQ R9, DI		
  0x43610c		49d3e1			SHLQ CL, R9		
		newlenmem = uintptr(cap) << shift
  0x43610f		48d3e0			SHLQ CL, AX		
		capmem = roundupsize(uintptr(newcap) << shift)
  0x436112		90			NOPL			
  0x436113		4989d0			MOVQ DX, R8		
  0x436116		48d3e2			SHLQ CL, DX		
	if size < _MaxSmallSize {
  0x436119		4881fa00800000		CMPQ $0x8000, DX	
  0x436120		0f83ab000000		JAE 0x4361d1		
		if size <= smallSizeMax-8 {
  0x436126		4881faf8030000		CMPQ $0x3f8, DX		
  0x43612d		7766			JA 0x436195		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x43612f		4883c207		ADDQ $0x7, DX				
  0x436133		48c1ea03		SHRQ $0x3, DX				
  0x436137		4881fa81000000		CMPQ $0x81, DX				
  0x43613e		0f832e020000		JAE 0x436372				
  0x436144		4c8d15f58f0800		LEAQ runtime.size_to_class8(SB), R10	
  0x43614b		420fb61412		MOVZX 0(DX)(R10*1), DX			
  0x436150		4883fa43		CMPQ $0x43, DX				
  0x436154		0f8318020000		JAE 0x436372				
  0x43615a		4c8d157f900800		LEAQ runtime.class_to_size(SB), R10	
  0x436161		410fb71452		MOVZX 0(R10)(DX*2), DX			
		overflow = uintptr(newcap) > (maxAlloc >> shift)
  0x436166		49ba0000000000000100	MOVQ $0x1000000000000, R10	
  0x436170		49d3ea			SHRQ CL, R10			
  0x436173		4d39d0			CMPQ R10, R8			
  0x436176		410f97c2		SETA R10			
		newcap = int(capmem >> shift)
  0x43617a		4989d0			MOVQ DX, R8			
  0x43617d		49d3e8			SHRQ CL, R8			
  0x436180		48bb0000000000000100	MOVQ $0x1000000000000, BX	
		p = mallocgc(capmem, et, true)
  0x43618a		4889d1			MOVQ DX, CX		
	if overflow || capmem > maxAlloc {
  0x43618d		4489d2			MOVL R10, DX		
	switch {
  0x436190		e9f3fcffff		JMP 0x435e88		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x436195		4881c27ffcffff		ADDQ $-0x381, DX			
  0x43619c		48c1ea07		SHRQ $0x7, DX				
  0x4361a0		4881faf9000000		CMPQ $0xf9, DX				
  0x4361a7		0f83be010000		JAE 0x43636b				
  0x4361ad		4c8d15cc900800		LEAQ runtime.size_to_class128(SB), R10	
  0x4361b4		420fb61412		MOVZX 0(DX)(R10*1), DX			
  0x4361b9		4883fa43		CMPQ $0x43, DX				
  0x4361bd		0f83a8010000		JAE 0x43636b				
  0x4361c3		4c8d1516900800		LEAQ runtime.class_to_size(SB), R10	
  0x4361ca		410fb71452		MOVZX 0(R10)(DX*2), DX			
		capmem = roundupsize(uintptr(newcap) << shift)
  0x4361cf		eb95			JMP 0x436166		
	if size+_PageSize < size {
  0x4361d1		4c8d9200200000		LEAQ 0x2000(DX), R10	
  0x4361d8		4939d2			CMPQ DX, R10		
  0x4361db		7289			JB 0x436166		
	return round(size, _PageSize)
  0x4361dd		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x4361de		4881c2ff1f0000		ADDQ $0x1fff, DX	
  0x4361e5		4881e200e0ffff		ANDQ $-0x2000, DX	
		capmem = roundupsize(uintptr(newcap) << shift)
  0x4361ec		e975ffffff		JMP 0x436166		
func growslice(et *_type, old slice, cap int) slice {
  0x4361f1		4889c1			MOVQ AX, CX		
		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
  0x4361f4		4889d0			MOVQ DX, AX		
		capmem = roundupsize(uintptr(newcap) << shift)
  0x4361f7		4889c3			MOVQ AX, BX		
		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
  0x4361fa		48f7e7			MULQ DI			
		lenmem = uintptr(old.len) * et.size
  0x4361fd		4c89ca			MOVQ R9, DX		
  0x436200		4c0fafcf		IMULQ DI, R9		
		newlenmem = uintptr(cap) * et.size
  0x436204		480fafcf		IMULQ DI, CX		
		capmem = roundupsize(capmem)
  0x436208		90			NOPL			
	if size < _MaxSmallSize {
  0x436209		483d00800000		CMPQ $0x8000, AX	
  0x43620f		0f83b1000000		JAE 0x4362c6		
		if size <= smallSizeMax-8 {
  0x436215		483df8030000		CMPQ $0x3f8, AX		
  0x43621b		776d			JA 0x43628a		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x43621d		4c8d4007		LEAQ 0x7(AX), R8			
  0x436221		49c1e803		SHRQ $0x3, R8				
  0x436225		4981f881000000		CMPQ $0x81, R8				
  0x43622c		0f8332010000		JAE 0x436364				
  0x436232		4c8d15078f0800		LEAQ runtime.size_to_class8(SB), R10	
  0x436239		470fb60410		MOVZX 0(R8)(R10*1), R8			
  0x43623e		4983f843		CMPQ $0x43, R8				
  0x436242		0f831c010000		JAE 0x436364				
  0x436248		4c8d15918f0800		LEAQ runtime.class_to_size(SB), R10	
  0x43624f		470fb70442		MOVZX 0(R10)(R8*2), R8			
		newcap = int(capmem / et.size)
  0x436254		4c89c0			MOVQ R8, AX		
func growslice(et *_type, old slice, cap int) slice {
  0x436257		4989d2			MOVQ DX, R10		
		newcap = int(capmem / et.size)
  0x43625a		31d2			XORL DX, DX		
  0x43625c		48f7f7			DIVQ DI			
  0x43625f		4889442440		MOVQ AX, 0x40(SP)	
		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
  0x436264		4889d8			MOVQ BX, AX			
  0x436267		48f7e7			MULQ DI				
  0x43626a		0f90c2			SETO DL				
  0x43626d		48bb0000000000000100	MOVQ $0x1000000000000, BX	
	return slice{p, old.len, newcap}
  0x436277		4c89d7			MOVQ R10, DI		
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
  0x43627a		4889c8			MOVQ CX, AX		
		p = mallocgc(capmem, et, true)
  0x43627d		4c89c1			MOVQ R8, CX		
	return slice{p, old.len, newcap}
  0x436280		4c8b442440		MOVQ 0x40(SP), R8	
	switch {
  0x436285		e9fefbffff		JMP 0x435e88		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x43628a		4c8d807ffcffff		LEAQ 0xfffffc7f(AX), R8			
  0x436291		49c1e807		SHRQ $0x7, R8				
  0x436295		4981f8f9000000		CMPQ $0xf9, R8				
  0x43629c		0f83bb000000		JAE 0x43635d				
  0x4362a2		4c8d15d78f0800		LEAQ runtime.size_to_class128(SB), R10	
  0x4362a9		470fb60410		MOVZX 0(R8)(R10*1), R8			
  0x4362ae		4983f843		CMPQ $0x43, R8				
  0x4362b2		0f83a5000000		JAE 0x43635d				
  0x4362b8		4c8d15218f0800		LEAQ runtime.class_to_size(SB), R10	
  0x4362bf		470fb70442		MOVZX 0(R10)(R8*2), R8			
		capmem = roundupsize(capmem)
  0x4362c4		eb8e			JMP 0x436254		
	if size+_PageSize < size {
  0x4362c6		4c8d8000200000		LEAQ 0x2000(AX), R8	
  0x4362cd		4939c0			CMPQ AX, R8		
  0x4362d0		7308			JAE 0x4362da		
		capmem = roundupsize(capmem)
  0x4362d2		4989c0			MOVQ AX, R8		
  0x4362d5		e97affffff		JMP 0x436254		
	return round(size, _PageSize)
  0x4362da		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x4362db		4c8d80ff1f0000		LEAQ 0x1fff(AX), R8	
  0x4362e2		4981e000e0ffff		ANDQ $-0x2000, R8	
		capmem = roundupsize(capmem)
  0x4362e9		e966ffffff		JMP 0x436254		
		newlenmem = uintptr(cap) << shift
  0x4362ee		4889d0			MOVQ DX, AX		
		capmem = roundupsize(uintptr(newcap) << shift)
  0x4362f1		4889da			MOVQ BX, DX		
			if newcap <= 0 {
  0x4362f4		e91ffbffff		JMP 0x435e18		
		newlenmem = uintptr(cap) << shift
  0x4362f9		4889d0			MOVQ DX, AX		
		capmem = roundupsize(uintptr(newcap) << shift)
  0x4362fc		4c89c2			MOVQ R8, DX		
			newcap = doublecap
  0x4362ff		e914fbffff		JMP 0x435e18		
		newlenmem = uintptr(cap) << shift
  0x436304		4889d0			MOVQ DX, AX		
		lenmem = uintptr(old.len) << shift
  0x436307		4c8b4c2478		MOVQ 0x78(SP), R9	
		newcap = cap
  0x43630c		e907fbffff		JMP 0x435e18		
		return slice{unsafe.Pointer(&zerobase), old.len, cap}
  0x436311		488d05f86a0a00		LEAQ runtime.zerobase(SB), AX	
  0x436318		4889842490000000	MOVQ AX, 0x90(SP)		
  0x436320		488b442478		MOVQ 0x78(SP), AX		
  0x436325		4889842498000000	MOVQ AX, 0x98(SP)		
  0x43632d		48899424a0000000	MOVQ DX, 0xa0(SP)		
  0x436335		488b6c2458		MOVQ 0x58(SP), BP		
  0x43633a		4883c460		ADDQ $0x60, SP			
  0x43633e		c3			RET				
		panic(errorString("growslice: cap out of range"))
  0x43633f		488d059a8c0200		LEAQ 0x28c9a(IP), AX			
  0x436346		48890424		MOVQ AX, 0(SP)				
  0x43634a		488d05bf6c0400		LEAQ runtime.statictmp_33(SB), AX	
  0x436351		4889442408		MOVQ AX, 0x8(SP)			
  0x436356		e855cbfeff		CALL runtime.gopanic(SB)		
  0x43635b		0f0b			UD2					
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x43635d		e8bebbfeff		CALL runtime.panicindex(SB)	
  0x436362		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x436364		e8b7bbfeff		CALL runtime.panicindex(SB)	
  0x436369		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x43636b		e8b0bbfeff		CALL runtime.panicindex(SB)	
  0x436370		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x436372		e8a9bbfeff		CALL runtime.panicindex(SB)	
  0x436377		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x436379		e8a2bbfeff		CALL runtime.panicindex(SB)	
  0x43637e		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x436380		e89bbbfeff		CALL runtime.panicindex(SB)	
  0x436385		0f0b			UD2				
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x436387		e894bbfeff		CALL runtime.panicindex(SB)	
  0x43638c		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x43638e		e88dbbfeff		CALL runtime.panicindex(SB)	
  0x436393		0f0b			UD2				
		panic(errorString("growslice: cap out of range"))
  0x436395		488d05448c0200		LEAQ 0x28c44(IP), AX			
  0x43639c		48890424		MOVQ AX, 0(SP)				
  0x4363a0		488d05596c0400		LEAQ runtime.statictmp_32(SB), AX	
  0x4363a7		4889442408		MOVQ AX, 0x8(SP)			
  0x4363ac		e8ffcafeff		CALL runtime.gopanic(SB)		
  0x4363b1		0f0b			UD2					
func growslice(et *_type, old slice, cap int) slice {
  0x4363b3		e8c8140100		CALL runtime.morestack_noctxt(SB)	
  0x4363b8		e9c3f9ffff		JMP runtime.growslice(SB)		

TEXT runtime.stackinit(SB) /usr/local/go/src/runtime/stack.go
func stackinit() {
  0x4363c0		31c0			XORL AX, AX		
	for i := range stackpool {
  0x4363c2		eb24			JMP 0x4363e8		
		stackpool[i].init()
  0x4363c4		4889c1			MOVQ AX, CX		
  0x4363c7		48c1e004		SHLQ $0x4, AX		
  0x4363cb		90			NOPL			
	list.first = nil
  0x4363cc		488d15edb70800		LEAQ runtime.stackpool(SB), DX	
  0x4363d3		48c7040200000000	MOVQ $0x0, 0(DX)(AX*1)		
	list.last = nil
  0x4363db		48c744020800000000	MOVQ $0x0, 0x8(DX)(AX*1)	
	for i := range stackpool {
  0x4363e4		488d4101		LEAQ 0x1(CX), AX	
  0x4363e8		4883f804		CMPQ $0x4, AX		
  0x4363ec		7cd6			JL 0x4363c4		
  0x4363ee		31c0			XORL AX, AX		
	for i := range stackLarge.free {
  0x4363f0		eb24			JMP 0x436416		
		stackLarge.free[i].init()
  0x4363f2		4889c1			MOVQ AX, CX		
  0x4363f5		48c1e004		SHLQ $0x4, AX		
  0x4363f9		90			NOPL			
	list.first = nil
  0x4363fa		488d1527bd0800		LEAQ runtime.stackLarge+8(SB), DX	
  0x436401		48c7040200000000	MOVQ $0x0, 0(DX)(AX*1)			
	list.last = nil
  0x436409		48c744020800000000	MOVQ $0x0, 0x8(DX)(AX*1)	
	for i := range stackLarge.free {
  0x436412		488d4101		LEAQ 0x1(CX), AX	
  0x436416		4883f823		CMPQ $0x23, AX		
  0x43641a		7cd6			JL 0x4363f2		
  0x43641c		c3			RET			

TEXT runtime.stacklog2(SB) /usr/local/go/src/runtime/stack.go
	for n > 1 {
  0x436420		488b442408		MOVQ 0x8(SP), AX	
  0x436425		31c9			XORL CX, CX		
  0x436427		eb06			JMP 0x43642f		
		n >>= 1
  0x436429		48d1e8			SHRQ $0x1, AX		
		log2++
  0x43642c		48ffc1			INCQ CX			
	for n > 1 {
  0x43642f		4883f801		CMPQ $0x1, AX		
  0x436433		77f4			JA 0x436429		
	return log2
  0x436435		48894c2410		MOVQ CX, 0x10(SP)	
  0x43643a		c3			RET			

TEXT runtime.stackpoolalloc(SB) /usr/local/go/src/runtime/stack.go
func stackpoolalloc(order uint8) gclinkptr {
  0x436440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436449		483b6110		CMPQ 0x10(CX), SP	
  0x43644d		0f86b7010000		JBE 0x43660a		
  0x436453		4883ec40		SUBQ $0x40, SP		
  0x436457		48896c2438		MOVQ BP, 0x38(SP)	
  0x43645c		488d6c2438		LEAQ 0x38(SP), BP	
	list := &stackpool[order]
  0x436461		0fb6442448		MOVZX 0x48(SP), AX		
  0x436466		4883f804		CMPQ $0x4, AX			
  0x43646a		0f8393010000		JAE 0x436603			
  0x436470		48c1e004		SHLQ $0x4, AX			
  0x436474		488d1545b70800		LEAQ runtime.stackpool(SB), DX	
  0x43647b		488d1c02		LEAQ 0(DX)(AX*1), BX		
  0x43647f		48895c2430		MOVQ BX, 0x30(SP)		
	s := list.first
  0x436484		488b0402		MOVQ 0(DX)(AX*1), AX	
	if s == nil {
  0x436488		4885c0			TESTQ AX, AX		
  0x43648b		0f85af000000		JNE 0x436540		
		s = mheap_.allocManual(_StackCacheSize>>_PageShift, &memstats.stacks_inuse)
  0x436491		488d05a8010900		LEAQ runtime.mheap_(SB), AX		
  0x436498		48890424		MOVQ AX, 0(SP)				
  0x43649c		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x4364a5		488d0514780a00		LEAQ runtime.memstats+96(SB), AX	
  0x4364ac		4889442410		MOVQ AX, 0x10(SP)			
  0x4364b1		e8ea70feff		CALL runtime.(*mheap).allocManual(SB)	
  0x4364b6		488b442418		MOVQ 0x18(SP), AX			
		if s == nil {
  0x4364bb		4885c0			TESTQ AX, AX		
  0x4364be		0f8424010000		JE 0x4365e8		
		if s.allocCount != 0 {
  0x4364c4		6683786000		CMPW $0x0, 0x60(AX)	
  0x4364c9		0f85fe000000		JNE 0x4365cd		
		if s.manualFreeList.ptr() != nil {
  0x4364cf		488b5028		MOVQ 0x28(AX), DX	
  0x4364d3		90			NOPL			
  0x4364d4		4885d2			TESTQ DX, DX		
  0x4364d7		0f85d5000000		JNE 0x4365b2		
		s.elemsize = _FixedStack << order
  0x4364dd		0fb64c2448		MOVZX 0x48(SP), CX	
  0x4364e2		80f940			CMPL $0x40, CL		
  0x4364e5		4819d2			SBBQ DX, DX		
		osStackAlloc(s)
  0x4364e8		90			NOPL			
		s.elemsize = _FixedStack << order
  0x4364e9		bb00080000		MOVL $0x800, BX		
  0x4364ee		48d3e3			SHLQ CL, BX		
  0x4364f1		4821d3			ANDQ DX, BX		
  0x4364f4		48895868		MOVQ BX, 0x68(AX)	
  0x4364f8		31c9			XORL CX, CX		
		for i := uintptr(0); i < _StackCacheSize; i += s.elemsize {
  0x4364fa		eb1e			JMP 0x43651a		
	return s.startAddr
  0x4364fc		488b5018		MOVQ 0x18(AX), DX	
			x := gclinkptr(s.base() + i)
  0x436500		4801ca			ADDQ CX, DX		
	return (*gclink)(unsafe.Pointer(p))
  0x436503		4889d3			MOVQ DX, BX		
			x := gclinkptr(s.base() + i)
  0x436506		90			NOPL			
			x.ptr().next = s.manualFreeList
  0x436507		90			NOPL			
  0x436508		488b7028		MOVQ 0x28(AX), SI	
  0x43650c		488932			MOVQ SI, 0(DX)		
			s.manualFreeList = x
  0x43650f		48895828		MOVQ BX, 0x28(AX)	
		for i := uintptr(0); i < _StackCacheSize; i += s.elemsize {
  0x436513		488b5068		MOVQ 0x68(AX), DX	
  0x436517		4801d1			ADDQ DX, CX		
  0x43651a		4881f900800000		CMPQ $0x8000, CX	
  0x436521		72d9			JB 0x4364fc		
		s = mheap_.allocManual(_StackCacheSize>>_PageShift, &memstats.stacks_inuse)
  0x436523		4889442428		MOVQ AX, 0x28(SP)	
		list.insert(s)
  0x436528		488b4c2430		MOVQ 0x30(SP), CX			
  0x43652d		48890c24		MOVQ CX, 0(SP)				
  0x436531		4889442408		MOVQ AX, 0x8(SP)			
  0x436536		e80585feff		CALL runtime.(*mSpanList).insert(SB)	
	x := s.manualFreeList
  0x43653b		488b442428		MOVQ 0x28(SP), AX	
  0x436540		488b4828		MOVQ 0x28(AX), CX	
	if x.ptr() == nil {
  0x436544		90			NOPL			
	return (*gclink)(unsafe.Pointer(p))
  0x436545		4889ca			MOVQ CX, DX		
	if x.ptr() == nil {
  0x436548		4885c9			TESTQ CX, CX		
  0x43654b		744a			JE 0x436597		
	s.manualFreeList = x.ptr().next
  0x43654d		90			NOPL			
  0x43654e		488b09			MOVQ 0(CX), CX		
  0x436551		48894828		MOVQ CX, 0x28(AX)	
	s.allocCount++
  0x436555		0fb74860		MOVZX 0x60(AX), CX	
  0x436559		ffc1			INCL CX			
  0x43655b		66894860		MOVW CX, 0x60(AX)	
	if s.manualFreeList.ptr() == nil {
  0x43655f		488b4828		MOVQ 0x28(AX), CX	
  0x436563		90			NOPL			
  0x436564		4885c9			TESTQ CX, CX		
  0x436567		740f			JE 0x436578		
	return x
  0x436569		4889542450		MOVQ DX, 0x50(SP)	
  0x43656e		488b6c2438		MOVQ 0x38(SP), BP	
  0x436573		4883c440		ADDQ $0x40, SP		
  0x436577		c3			RET			
	x := s.manualFreeList
  0x436578		4889542420		MOVQ DX, 0x20(SP)	
		list.remove(s)
  0x43657d		488b4c2430		MOVQ 0x30(SP), CX			
  0x436582		48890c24		MOVQ CX, 0(SP)				
  0x436586		4889442408		MOVQ AX, 0x8(SP)			
  0x43658b		e82083feff		CALL runtime.(*mSpanList).remove(SB)	
	return x
  0x436590		488b542420		MOVQ 0x20(SP), DX	
		list.remove(s)
  0x436595		ebd2			JMP 0x436569		
		throw("span has no free stacks")
  0x436597		488d05f1a70300		LEAQ 0x3a7f1(IP), AX	
  0x43659e		48890424		MOVQ AX, 0(SP)		
  0x4365a2		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x4365ab		e8d0cefeff		CALL runtime.throw(SB)	
  0x4365b0		0f0b			UD2			
			throw("bad manualFreeList")
  0x4365b2		488d051f9d0300		LEAQ 0x39d1f(IP), AX	
  0x4365b9		48890424		MOVQ AX, 0(SP)		
  0x4365bd		48c744240812000000	MOVQ $0x12, 0x8(SP)	
  0x4365c6		e8b5cefeff		CALL runtime.throw(SB)	
  0x4365cb		0f0b			UD2			
			throw("bad allocCount")
  0x4365cd		488d05bc970300		LEAQ 0x397bc(IP), AX	
  0x4365d4		48890424		MOVQ AX, 0(SP)		
  0x4365d8		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4365e1		e89acefeff		CALL runtime.throw(SB)	
  0x4365e6		0f0b			UD2			
			throw("out of memory")
  0x4365e8		488d05ac960300		LEAQ 0x396ac(IP), AX	
  0x4365ef		48890424		MOVQ AX, 0(SP)		
  0x4365f3		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x4365fc		e87fcefeff		CALL runtime.throw(SB)	
  0x436601		0f0b			UD2			
	list := &stackpool[order]
  0x436603		e818b9feff		CALL runtime.panicindex(SB)	
  0x436608		0f0b			UD2				
func stackpoolalloc(order uint8) gclinkptr {
  0x43660a		e871120100		CALL runtime.morestack_noctxt(SB)	
  0x43660f		e92cfeffff		JMP runtime.stackpoolalloc(SB)		

TEXT runtime.stackpoolfree(SB) /usr/local/go/src/runtime/stack.go
func stackpoolfree(x gclinkptr, order uint8) {
  0x436620		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436629		483b6110		CMPQ 0x10(CX), SP	
  0x43662d		0f866a010000		JBE 0x43679d		
  0x436633		4883ec28		SUBQ $0x28, SP		
  0x436637		48896c2420		MOVQ BP, 0x20(SP)	
  0x43663c		488d6c2420		LEAQ 0x20(SP), BP	
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436641		488b0508030900		MOVQ runtime.mheap_+784(SB), AX	
  0x436648		8400			TESTB AL, 0(AX)			
	s := spanOfUnchecked(uintptr(x))
  0x43664a		90			NOPL			
	ai := arenaIndex(p)
  0x43664b		90			NOPL			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x43664c		90			NOPL			
  0x43664d		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x43664e		48b90000000000800000	MOVQ $0x800000000000, CX	
  0x436658		488b542430		MOVQ 0x30(SP), DX		
  0x43665d		4801d1			ADDQ DX, CX			
  0x436660		48c1e91a		SHRQ $0x1a, CX			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436664		4881f900004000		CMPQ $0x400000, CX		
  0x43666b		0f8325010000		JAE 0x436796			
  0x436671		488b04c8		MOVQ 0(AX)(CX*8), AX		
  0x436675		4889d1			MOVQ DX, CX			
  0x436678		48c1ea0d		SHRQ $0xd, DX			
  0x43667c		4881e2ff1f0000		ANDQ $0x1fff, DX		
  0x436683		488b94d000002000	MOVQ 0x200000(AX)(DX*8), DX	
  0x43668b		8400			TESTB AL, 0(AX)			
	if s.state != mSpanManual {
  0x43668d		807a6302		CMPB $0x2, 0x63(DX)	
  0x436691		0f85e4000000		JNE 0x43677b		
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436697		4889542418		MOVQ DX, 0x18(SP)	
	if s.manualFreeList.ptr() == nil {
  0x43669c		488b4228		MOVQ 0x28(DX), AX	
  0x4366a0		90			NOPL			
  0x4366a1		4885c0			TESTQ AX, AX		
  0x4366a4		0f848d000000		JE 0x436737		
	return (*gclink)(unsafe.Pointer(p))
  0x4366aa		4889c8			MOVQ CX, AX		
	x.ptr().next = s.manualFreeList
  0x4366ad		90			NOPL			
  0x4366ae		488b5a28		MOVQ 0x28(DX), BX	
  0x4366b2		488919			MOVQ BX, 0(CX)		
	s.manualFreeList = x
  0x4366b5		48894228		MOVQ AX, 0x28(DX)	
	s.allocCount--
  0x4366b9		0fb74260		MOVZX 0x60(DX), AX	
  0x4366bd		8d48ff			LEAL -0x1(AX), CX	
  0x4366c0		66894a60		MOVW CX, 0x60(DX)	
	if gcphase == _GCoff && s.allocCount == 0 {
  0x4366c4		833d11660a0000		CMPL $0x0, runtime.gcphase(SB)	
  0x4366cb		7560			JNE 0x43672d			
  0x4366cd		6683f801		CMPW $0x1, AX			
  0x4366d1		755a			JNE 0x43672d			
		stackpool[order].remove(s)
  0x4366d3		0fb6442438		MOVZX 0x38(SP), AX			
  0x4366d8		4883f804		CMPQ $0x4, AX				
  0x4366dc		0f838b000000		JAE 0x43676d				
  0x4366e2		48c1e004		SHLQ $0x4, AX				
  0x4366e6		488d0dd3b40800		LEAQ runtime.stackpool(SB), CX		
  0x4366ed		4801c8			ADDQ CX, AX				
  0x4366f0		48890424		MOVQ AX, 0(SP)				
  0x4366f4		4889542408		MOVQ DX, 0x8(SP)			
  0x4366f9		e8b281feff		CALL runtime.(*mSpanList).remove(SB)	
		s.manualFreeList = 0
  0x4366fe		488b442418		MOVQ 0x18(SP), AX	
  0x436703		48c7402800000000	MOVQ $0x0, 0x28(AX)	
		osStackFree(s)
  0x43670b		90			NOPL			
		mheap_.freeManual(s, &memstats.stacks_inuse)
  0x43670c		488d0d2dff0800		LEAQ runtime.mheap_(SB), CX		
  0x436713		48890c24		MOVQ CX, 0(SP)				
  0x436717		4889442408		MOVQ AX, 0x8(SP)			
  0x43671c		488d059d750a00		LEAQ runtime.memstats+96(SB), AX	
  0x436723		4889442410		MOVQ AX, 0x10(SP)			
  0x436728		e86378feff		CALL runtime.(*mheap).freeManual(SB)	
  0x43672d		488b6c2420		MOVQ 0x20(SP), BP			
  0x436732		4883c428		ADDQ $0x28, SP				
  0x436736		c3			RET					
		stackpool[order].insert(s)
  0x436737		0fb6442438		MOVZX 0x38(SP), AX			
  0x43673c		4883f804		CMPQ $0x4, AX				
  0x436740		7332			JAE 0x436774				
  0x436742		48c1e004		SHLQ $0x4, AX				
  0x436746		488d1d73b40800		LEAQ runtime.stackpool(SB), BX		
  0x43674d		4801d8			ADDQ BX, AX				
  0x436750		48890424		MOVQ AX, 0(SP)				
  0x436754		4889542408		MOVQ DX, 0x8(SP)			
  0x436759		e8e282feff		CALL runtime.(*mSpanList).insert(SB)	
	return (*gclink)(unsafe.Pointer(p))
  0x43675e		488b4c2430		MOVQ 0x30(SP), CX	
	x.ptr().next = s.manualFreeList
  0x436763		488b542418		MOVQ 0x18(SP), DX	
		stackpool[order].insert(s)
  0x436768		e93dffffff		JMP 0x4366aa		
		stackpool[order].remove(s)
  0x43676d		e8aeb7feff		CALL runtime.panicindex(SB)	
  0x436772		0f0b			UD2				
		stackpool[order].insert(s)
  0x436774		e8a7b7feff		CALL runtime.panicindex(SB)	
  0x436779		0f0b			UD2				
		throw("freeing stack not in a stack span")
  0x43677b		488d05b6b90300		LEAQ 0x3b9b6(IP), AX	
  0x436782		48890424		MOVQ AX, 0(SP)		
  0x436786		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x43678f		e8ecccfeff		CALL runtime.throw(SB)	
  0x436794		0f0b			UD2			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436796		e885b7feff		CALL runtime.panicindex(SB)	
  0x43679b		0f0b			UD2				
func stackpoolfree(x gclinkptr, order uint8) {
  0x43679d		e8de100100		CALL runtime.morestack_noctxt(SB)	
  0x4367a2		e979feffff		JMP runtime.stackpoolfree(SB)		

TEXT runtime.stackcacherefill(SB) /usr/local/go/src/runtime/stack.go
func stackcacherefill(c *mcache, order uint8) {
  0x4367b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4367b9		483b6118		CMPQ 0x18(CX), SP	
  0x4367bd		0f86cd000000		JBE 0x436890		
  0x4367c3		4883ec28		SUBQ $0x28, SP		
  0x4367c7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4367cc		488d6c2420		LEAQ 0x20(SP), BP	
	lock(&stackpoolmu)
  0x4367d1		488d0500660a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x4367d8		48890424		MOVQ AX, 0(SP)				
  0x4367dc		e8ff1efdff		CALL runtime.lock(SB)			
  0x4367e1		31c0			XORL AX, AX				
  0x4367e3		31c9			XORL CX, CX				
	for size < _StackCacheSize/2 {
  0x4367e5		eb46			JMP 0x43682d		
		x := stackpoolalloc(order)
  0x4367e7		0fb6442438		MOVZX 0x38(SP), AX		
  0x4367ec		880424			MOVB AL, 0(SP)			
  0x4367ef		e84cfcffff		CALL runtime.stackpoolalloc(SB)	
  0x4367f4		488b442408		MOVQ 0x8(SP), AX		
	return (*gclink)(unsafe.Pointer(p))
  0x4367f9		4889c1			MOVQ AX, CX		
		x.ptr().next = list
  0x4367fc		90			NOPL			
  0x4367fd		488b542418		MOVQ 0x18(SP), DX	
  0x436802		488910			MOVQ DX, 0(AX)		
		size += _FixedStack << order
  0x436805		0fb6442438		MOVZX 0x38(SP), AX	
  0x43680a		3c40			CMPL $0x40, AL		
  0x43680c		4819d2			SBBQ DX, DX		
		x := stackpoolalloc(order)
  0x43680f		4889cb			MOVQ CX, BX		
		size += _FixedStack << order
  0x436812		89c1			MOVL AX, CX		
  0x436814		be00080000		MOVL $0x800, SI		
  0x436819		48d3e6			SHLQ CL, SI		
  0x43681c		4821d6			ANDQ DX, SI		
  0x43681f		488b542410		MOVQ 0x10(SP), DX	
  0x436824		4801f2			ADDQ SI, DX		
	for size < _StackCacheSize/2 {
  0x436827		4889d0			MOVQ DX, AX		
		x.ptr().next = list
  0x43682a		4889d9			MOVQ BX, CX		
	for size < _StackCacheSize/2 {
  0x43682d		4889442410		MOVQ AX, 0x10(SP)	
		x.ptr().next = list
  0x436832		48894c2418		MOVQ CX, 0x18(SP)	
	for size < _StackCacheSize/2 {
  0x436837		483d00400000		CMPQ $0x4000, AX	
  0x43683d		72a8			JB 0x4367e7		
	unlock(&stackpoolmu)
  0x43683f		488d0592650a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436846		48890424		MOVQ AX, 0(SP)				
  0x43684a		e84120fdff		CALL runtime.unlock(SB)			
	c.stackcache[order].list = list
  0x43684f		488b442430		MOVQ 0x30(SP), AX		
  0x436854		8400			TESTB AL, 0(AX)			
  0x436856		0fb64c2438		MOVZX 0x38(SP), CX		
  0x43685b		4883f904		CMPQ $0x4, CX			
  0x43685f		7328			JAE 0x436889			
  0x436861		48c1e104		SHLQ $0x4, CX			
  0x436865		488b542418		MOVQ 0x18(SP), DX		
  0x43686a		4889940858040000	MOVQ DX, 0x458(AX)(CX*1)	
	c.stackcache[order].size = size
  0x436872		488b542410		MOVQ 0x10(SP), DX		
  0x436877		4889940860040000	MOVQ DX, 0x460(AX)(CX*1)	
}
  0x43687f		488b6c2420		MOVQ 0x20(SP), BP	
  0x436884		4883c428		ADDQ $0x28, SP		
  0x436888		c3			RET			
	c.stackcache[order].list = list
  0x436889		e892b6feff		CALL runtime.panicindex(SB)	
  0x43688e		0f0b			UD2				
func stackcacherefill(c *mcache, order uint8) {
  0x436890		e83b2e0000		CALL runtime.morestackc(SB)		
  0x436895		e916ffffff		JMP runtime.stackcacherefill(SB)	

TEXT runtime.stackcacherelease(SB) /usr/local/go/src/runtime/stack.go
func stackcacherelease(c *mcache, order uint8) {
  0x4368a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4368a9		483b6118		CMPQ 0x18(CX), SP	
  0x4368ad		0f86fb000000		JBE 0x4369ae		
  0x4368b3		4883ec40		SUBQ $0x40, SP		
  0x4368b7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4368bc		488d6c2438		LEAQ 0x38(SP), BP	
	x := c.stackcache[order].list
  0x4368c1		488b442448		MOVQ 0x48(SP), AX		
  0x4368c6		8400			TESTB AL, 0(AX)			
  0x4368c8		0fb64c2450		MOVZX 0x50(SP), CX		
  0x4368cd		4883f904		CMPQ $0x4, CX			
  0x4368d1		0f83d0000000		JAE 0x4369a7			
  0x4368d7		48c1e104		SHLQ $0x4, CX			
  0x4368db		48894c2430		MOVQ CX, 0x30(SP)		
  0x4368e0		488b9c0858040000	MOVQ 0x458(AX)(CX*1), BX	
  0x4368e8		48895c2418		MOVQ BX, 0x18(SP)		
	size := c.stackcache[order].size
  0x4368ed		488bb40860040000	MOVQ 0x460(AX)(CX*1), SI	
  0x4368f5		4889742420		MOVQ SI, 0x20(SP)		
	lock(&stackpoolmu)
  0x4368fa		488d3dd7640a00		LEAQ runtime.stackpoolmu(SB), DI	
  0x436901		48893c24		MOVQ DI, 0(SP)				
  0x436905		e8d61dfdff		CALL runtime.lock(SB)			
	for size > _StackCacheSize/2 {
  0x43690a		488b442420		MOVQ 0x20(SP), AX	
	c.stackcache[order].list = x
  0x43690f		488b4c2418		MOVQ 0x18(SP), CX	
	for size > _StackCacheSize/2 {
  0x436914		eb41			JMP 0x436957		
	return (*gclink)(unsafe.Pointer(p))
  0x436916		4889c8			MOVQ CX, AX		
		y := x.ptr().next
  0x436919		90			NOPL			
  0x43691a		488b09			MOVQ 0(CX), CX		
  0x43691d		48894c2410		MOVQ CX, 0x10(SP)	
		stackpoolfree(x, order)
  0x436922		48890424		MOVQ AX, 0(SP)			
  0x436926		0fb6442450		MOVZX 0x50(SP), AX		
  0x43692b		88442408		MOVB AL, 0x8(SP)		
  0x43692f		e8ecfcffff		CALL runtime.stackpoolfree(SB)	
		size -= _FixedStack << order
  0x436934		0fb64c2450		MOVZX 0x50(SP), CX	
  0x436939		80f940			CMPL $0x40, CL		
  0x43693c		4819c0			SBBQ AX, AX		
  0x43693f		ba00080000		MOVL $0x800, DX		
  0x436944		48d3e2			SHLQ CL, DX		
  0x436947		4821c2			ANDQ AX, DX		
  0x43694a		488b442420		MOVQ 0x20(SP), AX	
  0x43694f		4829d0			SUBQ DX, AX		
	c.stackcache[order].list = x
  0x436952		488b4c2410		MOVQ 0x10(SP), CX	
	for size > _StackCacheSize/2 {
  0x436957		4889442420		MOVQ AX, 0x20(SP)	
  0x43695c		483d00400000		CMPQ $0x4000, AX	
  0x436962		77b2			JA 0x436916		
	c.stackcache[order].list = x
  0x436964		48894c2428		MOVQ CX, 0x28(SP)	
	unlock(&stackpoolmu)
  0x436969		488d0568640a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436970		48890424		MOVQ AX, 0(SP)				
  0x436974		e8171ffdff		CALL runtime.unlock(SB)			
	c.stackcache[order].list = x
  0x436979		488b442430		MOVQ 0x30(SP), AX		
  0x43697e		488b4c2428		MOVQ 0x28(SP), CX		
  0x436983		488b542448		MOVQ 0x48(SP), DX		
  0x436988		48898c0258040000	MOVQ CX, 0x458(DX)(AX*1)	
	c.stackcache[order].size = size
  0x436990		488b4c2420		MOVQ 0x20(SP), CX		
  0x436995		48898c0260040000	MOVQ CX, 0x460(DX)(AX*1)	
}
  0x43699d		488b6c2438		MOVQ 0x38(SP), BP	
  0x4369a2		4883c440		ADDQ $0x40, SP		
  0x4369a6		c3			RET			
	x := c.stackcache[order].list
  0x4369a7		e874b5feff		CALL runtime.panicindex(SB)	
  0x4369ac		0f0b			UD2				
func stackcacherelease(c *mcache, order uint8) {
  0x4369ae		e81d2d0000		CALL runtime.morestackc(SB)		
  0x4369b3		e9e8feffff		JMP runtime.stackcacherelease(SB)	

TEXT runtime.stackcache_clear(SB) /usr/local/go/src/runtime/stack.go
func stackcache_clear(c *mcache) {
  0x4369c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4369c9		483b6118		CMPQ 0x18(CX), SP	
  0x4369cd		0f86bc000000		JBE 0x436a8f		
  0x4369d3		4883ec30		SUBQ $0x30, SP		
  0x4369d7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4369dc		488d6c2428		LEAQ 0x28(SP), BP	
	lock(&stackpoolmu)
  0x4369e1		488d05f0630a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x4369e8		48890424		MOVQ AX, 0(SP)				
  0x4369ec		e8ef1cfdff		CALL runtime.lock(SB)			
	for order := uint8(0); order < _NumStackOrders; order++ {
  0x4369f1		488b442438		MOVQ 0x38(SP), AX	
  0x4369f6		31c9			XORL CX, CX		
  0x4369f8		eb4d			JMP 0x436a47		
			y := x.ptr().next
  0x4369fa		90			NOPL			
  0x4369fb		488b03			MOVQ 0(BX), AX		
  0x4369fe		4889442418		MOVQ AX, 0x18(SP)	
			stackpoolfree(x, order)
  0x436a03		48893424		MOVQ SI, 0(SP)			
  0x436a07		884c2408		MOVB CL, 0x8(SP)		
  0x436a0b		e810fcffff		CALL runtime.stackpoolfree(SB)	
		c.stackcache[order].list = 0
  0x436a10		488b442438		MOVQ 0x38(SP), AX	
			stackpoolfree(x, order)
  0x436a15		0fb64c2417		MOVZX 0x17(SP), CX	
		c.stackcache[order].list = 0
  0x436a1a		488b542420		MOVQ 0x20(SP), DX	
		for x.ptr() != nil {
  0x436a1f		488b5c2418		MOVQ 0x18(SP), BX	
  0x436a24		90			NOPL			
	return (*gclink)(unsafe.Pointer(p))
  0x436a25		4889de			MOVQ BX, SI		
		for x.ptr() != nil {
  0x436a28		4885db			TESTQ BX, BX		
  0x436a2b		75cd			JNE 0x4369fa		
		c.stackcache[order].list = 0
  0x436a2d		48c784105804000000000000	MOVQ $0x0, 0x458(AX)(DX*1)	
		c.stackcache[order].size = 0
  0x436a39		48c784106004000000000000	MOVQ $0x0, 0x460(AX)(DX*1)	
	for order := uint8(0); order < _NumStackOrders; order++ {
  0x436a45		ffc1			INCL CX			
  0x436a47		80f904			CMPL $0x4, CL		
  0x436a4a		7322			JAE 0x436a6e		
		x := c.stackcache[order].list
  0x436a4c		8400			TESTB AL, 0(AX)		
  0x436a4e		0fb6d1			MOVZX CL, DX		
  0x436a51		4883fa04		CMPQ $0x4, DX		
  0x436a55		7331			JAE 0x436a88		
	for order := uint8(0); order < _NumStackOrders; order++ {
  0x436a57		884c2417		MOVB CL, 0x17(SP)	
		x := c.stackcache[order].list
  0x436a5b		48c1e204		SHLQ $0x4, DX			
  0x436a5f		4889542420		MOVQ DX, 0x20(SP)		
  0x436a64		488b9c1058040000	MOVQ 0x458(AX)(DX*1), BX	
		for x.ptr() != nil {
  0x436a6c		ebb6			JMP 0x436a24		
	unlock(&stackpoolmu)
  0x436a6e		488d0563630a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436a75		48890424		MOVQ AX, 0(SP)				
  0x436a79		e8121efdff		CALL runtime.unlock(SB)			
}
  0x436a7e		488b6c2428		MOVQ 0x28(SP), BP	
  0x436a83		4883c430		ADDQ $0x30, SP		
  0x436a87		c3			RET			
		x := c.stackcache[order].list
  0x436a88		e893b4feff		CALL runtime.panicindex(SB)	
  0x436a8d		0f0b			UD2				
func stackcache_clear(c *mcache) {
  0x436a8f		e83c2c0000		CALL runtime.morestackc(SB)		
  0x436a94		e927ffffff		JMP runtime.stackcache_clear(SB)	

TEXT runtime.stackalloc(SB) /usr/local/go/src/runtime/stack.go
func stackalloc(n uint32) stack {
  0x436aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436aa9		483b6118		CMPQ 0x18(CX), SP	
  0x436aad		0f86fa020000		JBE 0x436dad		
  0x436ab3		4883ec68		SUBQ $0x68, SP		
  0x436ab7		48896c2460		MOVQ BP, 0x60(SP)	
  0x436abc		488d6c2460		LEAQ 0x60(SP), BP	
	thisg := getg()
  0x436ac1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if thisg != thisg.m.g0 {
  0x436aca		488b4830		MOVQ 0x30(AX), CX	
  0x436ace		483901			CMPQ AX, 0(CX)		
  0x436ad1		0f85bb020000		JNE 0x436d92		
	if n&(n-1) != 0 {
  0x436ad7		8b442470		MOVL 0x70(SP), AX	
  0x436adb		8d50ff			LEAL -0x1(AX), DX	
  0x436ade		85c2			TESTL AX, DX		
  0x436ae0		0f8591020000		JNE 0x436d77		
	if debug.efence != 0 || stackFromSystem != 0 {
  0x436ae6		833dff630a0000		CMPL $0x0, runtime.debug+12(SB)	
  0x436aed		0f85e2010000		JNE 0x436cd5			
	if n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
  0x436af3		3d00800000		CMPL $0x8000, AX	
  0x436af8		0f83fd000000		JAE 0x436bfb		
func stackalloc(n uint32) stack {
  0x436afe		89c2			MOVL AX, DX		
  0x436b00		31db			XORL BX, BX		
		for n2 > _FixedStack {
  0x436b02		eb04			JMP 0x436b08		
			order++
  0x436b04		ffc3			INCL BX			
			n2 >>= 1
  0x436b06		d1e8			SHRL $0x1, AX		
		for n2 > _FixedStack {
  0x436b08		3d00080000		CMPL $0x800, AX		
  0x436b0d		77f5			JA 0x436b04		
			x = c.stackcache[order].list
  0x436b0f		885c2427		MOVB BL, 0x27(SP)	
		c := thisg.m.mcache
  0x436b13		488b8160010000		MOVQ 0x160(CX), AX	
		if stackNoCache != 0 || c == nil || thisg.m.preemptoff != "" {
  0x436b1a		4885c0			TESTQ AX, AX		
  0x436b1d		740a			JE 0x436b29		
  0x436b1f		4883b90001000000	CMPQ $0x0, 0x100(CX)	
  0x436b27		745a			JE 0x436b83		
			lock(&stackpoolmu)
  0x436b29		488d05a8620a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436b30		48890424		MOVQ AX, 0(SP)				
  0x436b34		e8a71bfdff		CALL runtime.lock(SB)			
			x = stackpoolalloc(order)
  0x436b39		0fb6442427		MOVZX 0x27(SP), AX		
  0x436b3e		880424			MOVB AL, 0(SP)			
  0x436b41		e8faf8ffff		CALL runtime.stackpoolalloc(SB)	
  0x436b46		488b442408		MOVQ 0x8(SP), AX		
  0x436b4b		4889442428		MOVQ AX, 0x28(SP)		
			unlock(&stackpoolmu)
  0x436b50		488d0d81620a00		LEAQ runtime.stackpoolmu(SB), CX	
  0x436b57		48890c24		MOVQ CX, 0(SP)				
  0x436b5b		e8301dfdff		CALL runtime.unlock(SB)			
		v = unsafe.Pointer(x)
  0x436b60		488b442428		MOVQ 0x28(SP), AX	
	return stack{uintptr(v), uintptr(v) + uintptr(n)}
  0x436b65		4889442478		MOVQ AX, 0x78(SP)	
  0x436b6a		8b4c2470		MOVL 0x70(SP), CX	
  0x436b6e		4801c8			ADDQ CX, AX		
  0x436b71		4889842480000000	MOVQ AX, 0x80(SP)	
  0x436b79		488b6c2460		MOVQ 0x60(SP), BP	
  0x436b7e		4883c468		ADDQ $0x68, SP		
  0x436b82		c3			RET			
			x = c.stackcache[order].list
  0x436b83		0fb6cb			MOVZX BL, CX			
  0x436b86		4883f904		CMPQ $0x4, CX			
  0x436b8a		0f83c5010000		JAE 0x436d55			
  0x436b90		48c1e104		SHLQ $0x4, CX			
  0x436b94		488bb40858040000	MOVQ 0x458(AX)(CX*1), SI	
			if x.ptr() == nil {
  0x436b9c		90			NOPL			
	return (*gclink)(unsafe.Pointer(p))
  0x436b9d		4889f7			MOVQ SI, DI		
			if x.ptr() == nil {
  0x436ba0		4885f6			TESTQ SI, SI		
  0x436ba3		7427			JE 0x436bcc		
	return (*gclink)(unsafe.Pointer(p))
  0x436ba5		4889fb			MOVQ DI, BX		
			c.stackcache[order].list = x.ptr().next
  0x436ba8		90			NOPL				
  0x436ba9		488b37			MOVQ 0(DI), SI			
  0x436bac		4889b40858040000	MOVQ SI, 0x458(AX)(CX*1)	
			c.stackcache[order].size -= uintptr(n)
  0x436bb4		488bb40860040000	MOVQ 0x460(AX)(CX*1), SI	
  0x436bbc		4829d6			SUBQ DX, SI			
  0x436bbf		4889b40860040000	MOVQ SI, 0x460(AX)(CX*1)	
		v = unsafe.Pointer(x)
  0x436bc7		4889d8			MOVQ BX, AX		
			c.stackcache[order].size -= uintptr(n)
  0x436bca		eb99			JMP 0x436b65		
		c := thisg.m.mcache
  0x436bcc		4889442450		MOVQ AX, 0x50(SP)	
			x = c.stackcache[order].list
  0x436bd1		48894c2440		MOVQ CX, 0x40(SP)	
				stackcacherefill(c, order)
  0x436bd6		48890424		MOVQ AX, 0(SP)				
  0x436bda		885c2408		MOVB BL, 0x8(SP)			
  0x436bde		e8cdfbffff		CALL runtime.stackcacherefill(SB)	
				x = c.stackcache[order].list
  0x436be3		488b4c2440		MOVQ 0x40(SP), CX		
  0x436be8		488b442450		MOVQ 0x50(SP), AX		
  0x436bed		488bbc0858040000	MOVQ 0x458(AX)(CX*1), DI	
			c.stackcache[order].size -= uintptr(n)
  0x436bf5		8b542470		MOVL 0x70(SP), DX	
				x = c.stackcache[order].list
  0x436bf9		ebaa			JMP 0x436ba5		
		npage := uintptr(n) >> _PageShift
  0x436bfb		48c1e80d		SHRQ $0xd, AX		
  0x436bff		4889442438		MOVQ AX, 0x38(SP)	
		log2npage := stacklog2(npage)
  0x436c04		48890424		MOVQ AX, 0(SP)			
  0x436c08		e813f8ffff		CALL runtime.stacklog2(SB)	
  0x436c0d		488b442408		MOVQ 0x8(SP), AX		
  0x436c12		4889442430		MOVQ AX, 0x30(SP)		
		lock(&stackLarge.lock)
  0x436c17		488d0d02b50800		LEAQ runtime.stackLarge(SB), CX	
  0x436c1e		48890c24		MOVQ CX, 0(SP)			
  0x436c22		e8b91afdff		CALL runtime.lock(SB)		
		if !stackLarge.free[log2npage].isEmpty() {
  0x436c27		488b442430		MOVQ 0x30(SP), AX	
  0x436c2c		4883f823		CMPQ $0x23, AX		
  0x436c30		0f8318010000		JAE 0x436d4e		
  0x436c36		48c1e004		SHLQ $0x4, AX		
  0x436c3a		90			NOPL			
	return list.first == nil
  0x436c3b		488d0de6b40800		LEAQ runtime.stackLarge+8(SB), CX	
  0x436c42		488b1401		MOVQ 0(CX)(AX*1), DX			
  0x436c46		4885d2			TESTQ DX, DX				
		if !stackLarge.free[log2npage].isEmpty() {
  0x436c49		756a			JNE 0x436cb5		
  0x436c4b		31c0			XORL AX, AX		
		if s == nil {
  0x436c4d		4889442448		MOVQ AX, 0x48(SP)	
		unlock(&stackLarge.lock)
  0x436c52		488d0dc7b40800		LEAQ runtime.stackLarge(SB), CX	
  0x436c59		48890c24		MOVQ CX, 0(SP)			
  0x436c5d		e82e1cfdff		CALL runtime.unlock(SB)		
		if s == nil {
  0x436c62		488b442448		MOVQ 0x48(SP), AX	
  0x436c67		4885c0			TESTQ AX, AX		
  0x436c6a		740a			JE 0x436c76		
	return s.startAddr
  0x436c6c		488b4018		MOVQ 0x18(AX), AX	
		v = unsafe.Pointer(s.base())
  0x436c70		90			NOPL			
  0x436c71		e9effeffff		JMP 0x436b65		
			s = mheap_.allocManual(npage, &memstats.stacks_inuse)
  0x436c76		488d05c3f90800		LEAQ runtime.mheap_(SB), AX		
  0x436c7d		48890424		MOVQ AX, 0(SP)				
  0x436c81		488b442438		MOVQ 0x38(SP), AX			
  0x436c86		4889442408		MOVQ AX, 0x8(SP)			
  0x436c8b		488d052e700a00		LEAQ runtime.memstats+96(SB), AX	
  0x436c92		4889442410		MOVQ AX, 0x10(SP)			
  0x436c97		e80469feff		CALL runtime.(*mheap).allocManual(SB)	
  0x436c9c		488b442418		MOVQ 0x18(SP), AX			
			if s == nil {
  0x436ca1		4885c0			TESTQ AX, AX		
  0x436ca4		0f8489000000		JE 0x436d33		
			osStackAlloc(s)
  0x436caa		90			NOPL			
			s.elemsize = uintptr(n)
  0x436cab		8b4c2470		MOVL 0x70(SP), CX	
  0x436caf		48894868		MOVQ CX, 0x68(AX)	
  0x436cb3		ebb7			JMP 0x436c6c		
	return list.first == nil
  0x436cb5		4889542458		MOVQ DX, 0x58(SP)	
		if !stackLarge.free[log2npage].isEmpty() {
  0x436cba		4801c8			ADDQ CX, AX		
			stackLarge.free[log2npage].remove(s)
  0x436cbd		48890424		MOVQ AX, 0(SP)				
  0x436cc1		4889542408		MOVQ DX, 0x8(SP)			
  0x436cc6		e8e57bfeff		CALL runtime.(*mSpanList).remove(SB)	
		if s == nil {
  0x436ccb		488b442458		MOVQ 0x58(SP), AX	
			stackLarge.free[log2npage].remove(s)
  0x436cd0		e978ffffff		JMP 0x436c4d		
		n = uint32(round(uintptr(n), physPageSize))
  0x436cd5		90			NOPL					
  0x436cd6		488b0dcb600a00		MOVQ runtime.physPageSize(SB), CX	
	return (n + a - 1) &^ (a - 1)
  0x436cdd		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x436ce1		488d40ff		LEAQ -0x1(AX), AX	
  0x436ce5		48ffc9			DECQ CX			
  0x436ce8		48f7d1			NOTQ CX			
  0x436ceb		4821c8			ANDQ CX, AX		
		v := sysAlloc(uintptr(n), &memstats.stacks_sys)
  0x436cee		89c0			MOVL AX, AX				
  0x436cf0		4889442438		MOVQ AX, 0x38(SP)			
  0x436cf5		48890424		MOVQ AX, 0(SP)				
  0x436cf9		488d0dc86f0a00		LEAQ runtime.memstats+104(SB), CX	
  0x436d00		48894c2408		MOVQ CX, 0x8(SP)			
  0x436d05		e8f6a6fdff		CALL runtime.sysAlloc(SB)		
  0x436d0a		488b442410		MOVQ 0x10(SP), AX			
		if v == nil {
  0x436d0f		4885c0			TESTQ AX, AX		
  0x436d12		7448			JE 0x436d5c		
		return stack{uintptr(v), uintptr(v) + uintptr(n)}
  0x436d14		4889442478		MOVQ AX, 0x78(SP)	
  0x436d19		488b4c2438		MOVQ 0x38(SP), CX	
  0x436d1e		4801c8			ADDQ CX, AX		
  0x436d21		4889842480000000	MOVQ AX, 0x80(SP)	
  0x436d29		488b6c2460		MOVQ 0x60(SP), BP	
  0x436d2e		4883c468		ADDQ $0x68, SP		
  0x436d32		c3			RET			
				throw("out of memory")
  0x436d33		488d05618f0300		LEAQ 0x38f61(IP), AX	
  0x436d3a		48890424		MOVQ AX, 0(SP)		
  0x436d3e		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x436d47		e834c7feff		CALL runtime.throw(SB)	
  0x436d4c		0f0b			UD2			
		if !stackLarge.free[log2npage].isEmpty() {
  0x436d4e		e8cdb1feff		CALL runtime.panicindex(SB)	
  0x436d53		0f0b			UD2				
			x = c.stackcache[order].list
  0x436d55		e8c6b1feff		CALL runtime.panicindex(SB)	
  0x436d5a		0f0b			UD2				
			throw("out of memory (stackalloc)")
  0x436d5c		488d0531a50300		LEAQ 0x3a531(IP), AX	
  0x436d63		48890424		MOVQ AX, 0(SP)		
  0x436d67		48c74424081a000000	MOVQ $0x1a, 0x8(SP)	
  0x436d70		e80bc7feff		CALL runtime.throw(SB)	
  0x436d75		0f0b			UD2			
		throw("stack size not a power of 2")
  0x436d77		488d05d0a70300		LEAQ 0x3a7d0(IP), AX	
  0x436d7e		48890424		MOVQ AX, 0(SP)		
  0x436d82		48c74424081b000000	MOVQ $0x1b, 0x8(SP)	
  0x436d8b		e8f0c6feff		CALL runtime.throw(SB)	
  0x436d90		0f0b			UD2			
		throw("stackalloc not on scheduler stack")
  0x436d92		488d05e9b40300		LEAQ 0x3b4e9(IP), AX	
  0x436d99		48890424		MOVQ AX, 0(SP)		
  0x436d9d		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x436da6		e8d5c6feff		CALL runtime.throw(SB)	
  0x436dab		0f0b			UD2			
func stackalloc(n uint32) stack {
  0x436dad		e81e290000		CALL runtime.morestackc(SB)	
  0x436db2		e9e9fcffff		JMP runtime.stackalloc(SB)	

TEXT runtime.stackfree(SB) /usr/local/go/src/runtime/stack.go
func stackfree(stk stack) {
  0x436dc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x436dc9		483b6118		CMPQ 0x18(CX), SP	
  0x436dcd		0f8623030000		JBE 0x4370f6		
  0x436dd3		4883ec78		SUBQ $0x78, SP		
  0x436dd7		48896c2470		MOVQ BP, 0x70(SP)	
  0x436ddc		488d6c2470		LEAQ 0x70(SP), BP	
	gp := getg()
  0x436de1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	v := unsafe.Pointer(stk.lo)
  0x436dea		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x436df2		4889ca			MOVQ CX, DX		
	n := stk.hi - stk.lo
  0x436df5		488b9c2488000000	MOVQ 0x88(SP), BX	
  0x436dfd		4889de			MOVQ BX, SI		
  0x436e00		4829d3			SUBQ DX, BX		
	if n&(n-1) != 0 {
  0x436e03		488d7bff		LEAQ -0x1(BX), DI	
  0x436e07		4885fb			TESTQ DI, BX		
  0x436e0a		0f85cb020000		JNE 0x4370db		
	if stk.lo+n < stk.hi {
  0x436e10		488d3c1a		LEAQ 0(DX)(BX*1), DI	
  0x436e14		4839f7			CMPQ SI, DI		
  0x436e17		0f82a3020000		JB 0x4370c0		
	if debug.efence != 0 || stackFromSystem != 0 {
  0x436e1d		833dc8600a0000		CMPL $0x0, runtime.debug+12(SB)	
  0x436e24		0f85f5010000		JNE 0x43701f			
	if n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
  0x436e2a		4881fb00800000		CMPQ $0x8000, BX	
  0x436e31		0f83fd000000		JAE 0x436f34		
	n := stk.hi - stk.lo
  0x436e37		4889d9			MOVQ BX, CX		
  0x436e3a		31f6			XORL SI, SI		
		for n2 > _FixedStack {
  0x436e3c		eb05			JMP 0x436e43		
			order++
  0x436e3e		ffc6			INCL SI			
			n2 >>= 1
  0x436e40		48d1eb			SHRQ $0x1, BX		
		for n2 > _FixedStack {
  0x436e43		4881fb00080000		CMPQ $0x800, BX		
  0x436e4a		77f2			JA 0x436e3e		
			if c.stackcache[order].size >= _StackCacheSize {
  0x436e4c		4088742437		MOVB SI, 0x37(SP)	
		c := gp.m.mcache
  0x436e51		488b4030		MOVQ 0x30(AX), AX	
  0x436e55		488b9860010000		MOVQ 0x160(AX), BX	
		if stackNoCache != 0 || c == nil || gp.m.preemptoff != "" {
  0x436e5c		4885db			TESTQ BX, BX		
  0x436e5f		740a			JE 0x436e6b		
  0x436e61		4883b80001000000	CMPQ $0x0, 0x100(AX)	
  0x436e69		7444			JE 0x436eaf		
			lock(&stackpoolmu)
  0x436e6b		488d05665f0a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436e72		48890424		MOVQ AX, 0(SP)				
  0x436e76		e86518fdff		CALL runtime.lock(SB)			
			stackpoolfree(x, order)
  0x436e7b		488b842480000000	MOVQ 0x80(SP), AX		
  0x436e83		48890424		MOVQ AX, 0(SP)			
  0x436e87		0fb6442437		MOVZX 0x37(SP), AX		
  0x436e8c		88442408		MOVB AL, 0x8(SP)		
  0x436e90		e88bf7ffff		CALL runtime.stackpoolfree(SB)	
			unlock(&stackpoolmu)
  0x436e95		488d053c5f0a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x436e9c		48890424		MOVQ AX, 0(SP)				
  0x436ea0		e8eb19fdff		CALL runtime.unlock(SB)			
  0x436ea5		488b6c2470		MOVQ 0x70(SP), BP			
  0x436eaa		4883c478		ADDQ $0x78, SP				
  0x436eae		c3			RET					
			if c.stackcache[order].size >= _StackCacheSize {
  0x436eaf		400fb6c6		MOVZX SI, AX			
  0x436eb3		4883f804		CMPQ $0x4, AX			
  0x436eb7		0f83fc010000		JAE 0x4370b9			
  0x436ebd		48c1e004		SHLQ $0x4, AX			
  0x436ec1		488bbc0360040000	MOVQ 0x460(BX)(AX*1), DI	
  0x436ec9		4881ff00800000		CMPQ $0x8000, DI		
  0x436ed0		732c			JAE 0x436efe			
	return (*gclink)(unsafe.Pointer(p))
  0x436ed2		4889d6			MOVQ DX, SI		
			x.ptr().next = c.stackcache[order].list
  0x436ed5		90			NOPL				
  0x436ed6		488bbc0358040000	MOVQ 0x458(BX)(AX*1), DI	
  0x436ede		48893a			MOVQ DI, 0(DX)			
			c.stackcache[order].list = x
  0x436ee1		4889b40358040000	MOVQ SI, 0x458(BX)(AX*1)	
			c.stackcache[order].size += n
  0x436ee9		488b940360040000	MOVQ 0x460(BX)(AX*1), DX	
  0x436ef1		4801d1			ADDQ DX, CX			
  0x436ef4		48898c0360040000	MOVQ CX, 0x460(BX)(AX*1)	
  0x436efc		eba7			JMP 0x436ea5			
	n := stk.hi - stk.lo
  0x436efe		48894c2450		MOVQ CX, 0x50(SP)	
		c := gp.m.mcache
  0x436f03		48895c2468		MOVQ BX, 0x68(SP)	
			if c.stackcache[order].size >= _StackCacheSize {
  0x436f08		4889442448		MOVQ AX, 0x48(SP)	
				stackcacherelease(c, order)
  0x436f0d		48891c24		MOVQ BX, 0(SP)				
  0x436f11		4088742408		MOVB SI, 0x8(SP)			
  0x436f16		e885f9ffff		CALL runtime.stackcacherelease(SB)	
			x.ptr().next = c.stackcache[order].list
  0x436f1b		488b442448		MOVQ 0x48(SP), AX	
			c.stackcache[order].size += n
  0x436f20		488b4c2450		MOVQ 0x50(SP), CX	
	return (*gclink)(unsafe.Pointer(p))
  0x436f25		488b942480000000	MOVQ 0x80(SP), DX	
			x.ptr().next = c.stackcache[order].list
  0x436f2d		488b5c2468		MOVQ 0x68(SP), BX	
				stackcacherelease(c, order)
  0x436f32		eb9e			JMP 0x436ed2		
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436f34		488b0515fa0800		MOVQ runtime.mheap_+784(SB), AX	
  0x436f3b		8400			TESTB AL, 0(AX)			
		s := spanOfUnchecked(uintptr(v))
  0x436f3d		90			NOPL			
	ai := arenaIndex(p)
  0x436f3e		90			NOPL			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436f3f		90			NOPL			
  0x436f40		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x436f41		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x436f4b		4801d3			ADDQ DX, BX			
  0x436f4e		48c1eb1a		SHRQ $0x1a, BX			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436f52		4881fb00004000		CMPQ $0x400000, BX		
  0x436f59		0f8353010000		JAE 0x4370b2			
  0x436f5f		488b04d8		MOVQ 0(AX)(BX*8), AX		
  0x436f63		48c1ea0d		SHRQ $0xd, DX			
  0x436f67		4881e2ff1f0000		ANDQ $0x1fff, DX		
  0x436f6e		488b94d000002000	MOVQ 0x200000(AX)(DX*8), DX	
  0x436f76		8400			TESTB AL, 0(AX)			
		if s.state != mSpanManual {
  0x436f78		807a6302		CMPB $0x2, 0x63(DX)	
  0x436f7c		0f85d6000000		JNE 0x437058		
		if gcphase == _GCoff {
  0x436f82		833d535d0a0000		CMPL $0x0, runtime.gcphase(SB)	
  0x436f89		7527			JNE 0x436fb2			
			osStackFree(s)
  0x436f8b		90			NOPL			
			mheap_.freeManual(s, &memstats.stacks_inuse)
  0x436f8c		488d05adf60800		LEAQ runtime.mheap_(SB), AX		
  0x436f93		48890424		MOVQ AX, 0(SP)				
  0x436f97		4889542408		MOVQ DX, 0x8(SP)			
  0x436f9c		488d051d6d0a00		LEAQ runtime.memstats+96(SB), AX	
  0x436fa3		4889442410		MOVQ AX, 0x10(SP)			
  0x436fa8		e8e36ffeff		CALL runtime.(*mheap).freeManual(SB)	
  0x436fad		e9f3feffff		JMP 0x436ea5				
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x436fb2		4889542460		MOVQ DX, 0x60(SP)	
			log2npage := stacklog2(s.npages)
  0x436fb7		488b4220		MOVQ 0x20(DX), AX		
  0x436fbb		48890424		MOVQ AX, 0(SP)			
  0x436fbf		e85cf4ffff		CALL runtime.stacklog2(SB)	
  0x436fc4		488b442408		MOVQ 0x8(SP), AX		
  0x436fc9		4889442440		MOVQ AX, 0x40(SP)		
			lock(&stackLarge.lock)
  0x436fce		488d0d4bb10800		LEAQ runtime.stackLarge(SB), CX	
  0x436fd5		48890c24		MOVQ CX, 0(SP)			
  0x436fd9		e80217fdff		CALL runtime.lock(SB)		
			stackLarge.free[log2npage].insert(s)
  0x436fde		488b442440		MOVQ 0x40(SP), AX			
  0x436fe3		4883f823		CMPQ $0x23, AX				
  0x436fe7		7368			JAE 0x437051				
  0x436fe9		48c1e004		SHLQ $0x4, AX				
  0x436fed		488d0d34b10800		LEAQ runtime.stackLarge+8(SB), CX	
  0x436ff4		4801c8			ADDQ CX, AX				
  0x436ff7		48890424		MOVQ AX, 0(SP)				
  0x436ffb		488b442460		MOVQ 0x60(SP), AX			
  0x437000		4889442408		MOVQ AX, 0x8(SP)			
  0x437005		e8367afeff		CALL runtime.(*mSpanList).insert(SB)	
			unlock(&stackLarge.lock)
  0x43700a		488d050fb10800		LEAQ runtime.stackLarge(SB), AX	
  0x437011		48890424		MOVQ AX, 0(SP)			
  0x437015		e87618fdff		CALL runtime.unlock(SB)		
  0x43701a		e986feffff		JMP 0x436ea5			
			sysFault(v, n)
  0x43701f		90			NOPL			
	mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, -1, 0)
  0x437020		48890c24		MOVQ CX, 0(SP)		
  0x437024		48895c2408		MOVQ BX, 0x8(SP)	
  0x437029		48b80000000032000000	MOVQ $0x3200000000, AX	
  0x437033		4889442410		MOVQ AX, 0x10(SP)	
  0x437038		b8ffffffff		MOVL $-0x1, AX		
  0x43703d		4889442418		MOVQ AX, 0x18(SP)	
  0x437042		e839c4fcff		CALL runtime.mmap(SB)	
		return
  0x437047		488b6c2470		MOVQ 0x70(SP), BP	
  0x43704c		4883c478		ADDQ $0x78, SP		
  0x437050		c3			RET			
			stackLarge.free[log2npage].insert(s)
  0x437051		e8caaefeff		CALL runtime.panicindex(SB)	
  0x437056		0f0b			UD2				
	v := unsafe.Pointer(stk.lo)
  0x437058		48894c2458		MOVQ CX, 0x58(SP)	
			println(hex(s.base()), v)
  0x43705d		90			NOPL			
	return s.startAddr
  0x43705e		488b4218		MOVQ 0x18(DX), AX	
  0x437062		4889442438		MOVQ AX, 0x38(SP)	
			println(hex(s.base()), v)
  0x437067		e854cefeff		CALL runtime.printlock(SB)	
  0x43706c		488b442438		MOVQ 0x38(SP), AX		
  0x437071		48890424		MOVQ AX, 0(SP)			
  0x437075		e836d6feff		CALL runtime.printhex(SB)	
  0x43707a		e881d0feff		CALL runtime.printsp(SB)	
  0x43707f		488b442458		MOVQ 0x58(SP), AX		
  0x437084		48890424		MOVQ AX, 0(SP)			
  0x437088		e823d7feff		CALL runtime.printpointer(SB)	
  0x43708d		e8bed0feff		CALL runtime.printnl(SB)	
  0x437092		e8a9cefeff		CALL runtime.printunlock(SB)	
			throw("bad span state")
  0x437097		488d05008d0300		LEAQ 0x38d00(IP), AX	
  0x43709e		48890424		MOVQ AX, 0(SP)		
  0x4370a2		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4370ab		e8d0c3feff		CALL runtime.throw(SB)	
  0x4370b0		0f0b			UD2			
	return mheap_.arenas[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]
  0x4370b2		e869aefeff		CALL runtime.panicindex(SB)	
  0x4370b7		0f0b			UD2				
			if c.stackcache[order].size >= _StackCacheSize {
  0x4370b9		e862aefeff		CALL runtime.panicindex(SB)	
  0x4370be		0f0b			UD2				
		throw("bad stack size")
  0x4370c0		488d05e58c0300		LEAQ 0x38ce5(IP), AX	
  0x4370c7		48890424		MOVQ AX, 0(SP)		
  0x4370cb		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4370d4		e8a7c3feff		CALL runtime.throw(SB)	
  0x4370d9		0f0b			UD2			
		throw("stack not a power of 2")
  0x4370db		488d05179a0300		LEAQ 0x39a17(IP), AX	
  0x4370e2		48890424		MOVQ AX, 0(SP)		
  0x4370e6		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x4370ef		e88cc3feff		CALL runtime.throw(SB)	
  0x4370f4		0f0b			UD2			
func stackfree(stk stack) {
  0x4370f6		e8d5250000		CALL runtime.morestackc(SB)	
  0x4370fb		e9c0fcffff		JMP runtime.stackfree(SB)	

TEXT runtime.adjustpointers(SB) /usr/local/go/src/runtime/stack.go
func adjustpointers(scanp unsafe.Pointer, bv *bitvector, adjinfo *adjustinfo, f funcInfo) {
  0x437100		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437109		483b6110		CMPQ 0x10(CX), SP	
  0x43710d		0f8612020000		JBE 0x437325		
  0x437113		4883ec58		SUBQ $0x58, SP		
  0x437117		48896c2450		MOVQ BP, 0x50(SP)	
  0x43711c		488d6c2450		LEAQ 0x50(SP), BP	
	minp := adjinfo.old.lo
  0x437121		488b4c2470		MOVQ 0x70(SP), CX	
  0x437126		488b11			MOVQ 0(CX), DX		
	maxp := adjinfo.old.hi
  0x437129		488b5908		MOVQ 0x8(CX), BX	
	delta := adjinfo.delta
  0x43712d		488b7110		MOVQ 0x10(CX), SI	
	num := uintptr(bv.n)
  0x437131		488b7c2468		MOVQ 0x68(SP), DI	
  0x437136		4c6307			MOVSXD 0(DI), R8	
  0x437139		4c89442438		MOVQ R8, 0x38(SP)	
	useCAS := uintptr(scanp) < adjinfo.sghi
  0x43713e		4c8b4c2460		MOVQ 0x60(SP), R9	
  0x437143		4d89ca			MOVQ R9, R10		
  0x437146		488b8918010000		MOVQ 0x118(CX), CX	
  0x43714d		4c39c9			CMPQ R9, CX		
	for i := uintptr(0); i < num; i += 8 {
  0x437150		4c8b5c2478		MOVQ 0x78(SP), R11	
  0x437155		31c0			XORL AX, AX		
  0x437157		e9b7000000		JMP 0x437213		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x43715c		488b442468		MOVQ 0x68(SP), AX	
	for i := uintptr(0); i < num; i += 8 {
  0x437161		4c8b442438		MOVQ 0x38(SP), R8	
			pp := (*uintptr)(add(scanp, (i+j)*sys.PtrSize))
  0x437166		4c8b642428		MOVQ 0x28(SP), R12	
			p := *pp
  0x43716b		4f8b04ea		MOVQ 0(R10)(R13*8), R8	
  0x43716f		4c89442420		MOVQ R8, 0x20(SP)	
			if f.valid() && 0 < p && p < minLegalPointer && debug.invalidptr != 0 {
  0x437174		90			NOPL			
	return f._func != nil
  0x437175		4d85db			TESTQ R11, R11		
			if f.valid() && 0 < p && p < minLegalPointer && debug.invalidptr != 0 {
  0x437178		741b			JE 0x437195			
  0x43717a		4d85c0			TESTQ R8, R8			
  0x43717d		7616			JBE 0x437195			
  0x43717f		4981f800100000		CMPQ $0x1000, R8		
  0x437186		730d			JAE 0x437195			
  0x437188		833d755d0a0000		CMPL $0x0, runtime.debug+36(SB)	
  0x43718f		0f85a4000000		JNE 0x437239			
			if minp <= p && p < maxp {
  0x437195		4c39c2			CMPQ R8, DX		
  0x437198		7723			JA 0x4371bd		
  0x43719a		4939d8			CMPQ BX, R8		
  0x43719d		731e			JAE 0x4371bd		
	useCAS := uintptr(scanp) < adjinfo.sghi
  0x43719f		4c39c9			CMPQ R9, CX		
				if useCAS {
  0x4371a2		765b			JBE 0x4371ff		
					if !atomic.Casp1(ppu, unsafe.Pointer(p), unsafe.Pointer(p+delta)) {
  0x4371a4		4c8b642420		MOVQ 0x20(SP), R12		
  0x4371a9		4901f4			ADDQ SI, R12			
  0x4371ac		4c89c0			MOVQ R8, AX			
  0x4371af		f04c0fb127		LOCK CMPXCHGQ R12, 0(DI)	
  0x4371b4		410f94c0		SETE R8				
  0x4371b8		4584c0			TESTL R8, R8			
  0x4371bb		749f			JE 0x43715c			
		for b != 0 {
  0x4371bd		488b442428		MOVQ 0x28(SP), AX	
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x4371c2		488b7c2468		MOVQ 0x68(SP), DI	
	for i := uintptr(0); i < num; i += 8 {
  0x4371c7		4c8b442438		MOVQ 0x38(SP), R8	
			pp := (*uintptr)(add(scanp, (i+j)*sys.PtrSize))
  0x4371cc		4989c4			MOVQ AX, R12		
		for b != 0 {
  0x4371cf		4589f5			MOVL R14, R13		
  0x4371d2		4584ed			TESTL R13, R13		
  0x4371d5		7437			JE 0x43720e		
			j := uintptr(sys.Ctz8(b))
  0x4371d7		90			NOPL			
			b &= b - 1
  0x4371d8		458d75ff		LEAL -0x1(R13), R14	
  0x4371dc		4521ee			ANDL R13, R14		
			pp := (*uintptr)(add(scanp, (i+j)*sys.PtrSize))
  0x4371df		90			NOPL			
	return int(ntz8tab[x])
  0x4371e0		450fb6ed		MOVZX R13, R13					
  0x4371e4		4c8d3d95830800		LEAQ runtime/internal/sys.ntz8tab(SB), R15	
  0x4371eb		470fb62c2f		MOVZX 0(R15)(R13*1), R13			
			pp := (*uintptr)(add(scanp, (i+j)*sys.PtrSize))
  0x4371f0		4d01e5			ADDQ R12, R13		
func adjustpointers(scanp unsafe.Pointer, bv *bitvector, adjinfo *adjustinfo, f funcInfo) {
  0x4371f3		4889f8			MOVQ DI, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x4371f6		4b8d3cea		LEAQ 0(R10)(R13*8), DI	
		retry:
  0x4371fa		e96cffffff		JMP 0x43716b		
			pp := (*uintptr)(add(scanp, (i+j)*sys.PtrSize))
  0x4371ff		49c1e503		SHLQ $0x3, R13		
					*pp = p + delta
  0x437203		498d3c30		LEAQ 0(R8)(SI*1), DI	
  0x437207		4b897c1500		MOVQ DI, 0(R13)(R10*1)	
  0x43720c		ebaf			JMP 0x4371bd		
	for i := uintptr(0); i < num; i += 8 {
  0x43720e		498d442408		LEAQ 0x8(R12), AX	
  0x437213		4c39c0			CMPQ R8, AX		
  0x437216		7317			JAE 0x43722f		
  0x437218		4889442428		MOVQ AX, 0x28(SP)	
		b := *(addb(bv.bytedata, i/8))
  0x43721d		4989c4			MOVQ AX, R12		
  0x437220		48c1e803		SHRQ $0x3, AX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x437224		48034708		ADDQ 0x8(DI), AX	
		b := *(addb(bv.bytedata, i/8))
  0x437228		440fb628		MOVZX 0(AX), R13	
  0x43722c		90			NOPL			
		for b != 0 {
  0x43722d		eba3			JMP 0x4371d2		
  0x43722f		488b6c2450		MOVQ 0x50(SP), BP	
  0x437234		4883c458		ADDQ $0x58, SP		
  0x437238		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x437239		48897c2448		MOVQ DI, 0x48(SP)	
				getg().m.traceback = 2
  0x43723e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x437247		488b4030		MOVQ 0x30(AX), AX	
  0x43724b		c6802901000002		MOVB $0x2, 0x129(AX)	
				print("runtime: bad pointer in frame ", funcname(f), " at ", pp, ": ", hex(p), "\n")
  0x437252		4c891c24		MOVQ R11, 0(SP)			
  0x437256		488b842480000000	MOVQ 0x80(SP), AX		
  0x43725e		4889442408		MOVQ AX, 0x8(SP)		
  0x437263		e8d83f0000		CALL runtime.funcname(SB)	
  0x437268		488b442418		MOVQ 0x18(SP), AX		
  0x43726d		4889442430		MOVQ AX, 0x30(SP)		
  0x437272		488b4c2410		MOVQ 0x10(SP), CX		
  0x437277		48894c2440		MOVQ CX, 0x40(SP)		
  0x43727c		e83fccfeff		CALL runtime.printlock(SB)	
  0x437281		488d05bea90300		LEAQ 0x3a9be(IP), AX		
  0x437288		48890424		MOVQ AX, 0(SP)			
  0x43728c		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x437295		e856d5feff		CALL runtime.printstring(SB)	
  0x43729a		488b442440		MOVQ 0x40(SP), AX		
  0x43729f		48890424		MOVQ AX, 0(SP)			
  0x4372a3		488b442430		MOVQ 0x30(SP), AX		
  0x4372a8		4889442408		MOVQ AX, 0x8(SP)		
  0x4372ad		e83ed5feff		CALL runtime.printstring(SB)	
  0x4372b2		488d05407e0300		LEAQ 0x37e40(IP), AX		
  0x4372b9		48890424		MOVQ AX, 0(SP)			
  0x4372bd		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4372c6		e825d5feff		CALL runtime.printstring(SB)	
  0x4372cb		488b442448		MOVQ 0x48(SP), AX		
  0x4372d0		48890424		MOVQ AX, 0(SP)			
  0x4372d4		e8d7d4feff		CALL runtime.printpointer(SB)	
  0x4372d9		488d05c07d0300		LEAQ 0x37dc0(IP), AX		
  0x4372e0		48890424		MOVQ AX, 0(SP)			
  0x4372e4		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4372ed		e8fed4feff		CALL runtime.printstring(SB)	
  0x4372f2		488b442420		MOVQ 0x20(SP), AX		
  0x4372f7		48890424		MOVQ AX, 0(SP)			
  0x4372fb		e8b0d3feff		CALL runtime.printhex(SB)	
  0x437300		e84bcefeff		CALL runtime.printnl(SB)	
  0x437305		e836ccfeff		CALL runtime.printunlock(SB)	
				throw("invalid pointer found on stack")
  0x43730a		488d05dba80300		LEAQ 0x3a8db(IP), AX	
  0x437311		48890424		MOVQ AX, 0(SP)		
  0x437315		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x43731e		e85dc1feff		CALL runtime.throw(SB)	
  0x437323		0f0b			UD2			
func adjustpointers(scanp unsafe.Pointer, bv *bitvector, adjinfo *adjustinfo, f funcInfo) {
  0x437325		e856050100		CALL runtime.morestack_noctxt(SB)	
  0x43732a		e9d1fdffff		JMP runtime.adjustpointers(SB)		

TEXT runtime.adjustframe(SB) /usr/local/go/src/runtime/stack.go
func adjustframe(frame *stkframe, arg unsafe.Pointer) bool {
  0x437330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437339		488d4424b8		LEAQ -0x48(SP), AX	
  0x43733e		483b4110		CMPQ 0x10(CX), AX	
  0x437342		0f862d040000		JBE 0x437775		
  0x437348		4881ecc8000000		SUBQ $0xc8, SP		
  0x43734f		4889ac24c0000000	MOVQ BP, 0xc0(SP)	
  0x437357		488dac24c0000000	LEAQ 0xc0(SP), BP	
	if frame.continpc == 0 {
  0x43735f		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x437367		4883781800		CMPQ $0x0, 0x18(AX)	
  0x43736c		0f8436030000		JE 0x4376a8		
	f := frame.fn
  0x437372		488b08			MOVQ 0(AX), CX		
  0x437375		488b5008		MOVQ 0x8(AX), DX	
	if f.funcID == funcID_systemstack_switch {
  0x437379		8079240c		CMPB $0xc, 0x24(CX)	
  0x43737d		0f840d030000		JE 0x437690		
	f := frame.fn
  0x437383		4889942498000000	MOVQ DX, 0x98(SP)	
  0x43738b		48898c2490000000	MOVQ CX, 0x90(SP)	
	locals, args, objs := getStackMap(frame, &adjinfo.cache, true)
  0x437393		488b8c24d8000000	MOVQ 0xd8(SP), CX		
  0x43739b		8401			TESTB AL, 0(CX)			
  0x43739d		48890424		MOVQ AX, 0(SP)			
  0x4373a1		488d5118		LEAQ 0x18(CX), DX		
  0x4373a5		4889542408		MOVQ DX, 0x8(SP)		
  0x4373aa		c644241001		MOVB $0x1, 0x10(SP)		
  0x4373af		e87c1a0000		CALL runtime.getStackMap(SB)	
  0x4373b4		488b442438		MOVQ 0x38(SP), AX		
  0x4373b9		4889442478		MOVQ AX, 0x78(SP)		
  0x4373be		488b4c2440		MOVQ 0x40(SP), CX		
  0x4373c3		48894c2458		MOVQ CX, 0x58(SP)		
  0x4373c8		8b542428		MOVL 0x28(SP), DX		
  0x4373cc		488b5c2420		MOVQ 0x20(SP), BX		
  0x4373d1		8b742418		MOVL 0x18(SP), SI		
  0x4373d5		488b7c2430		MOVQ 0x30(SP), DI		
  0x4373da		89b424a0000000		MOVL SI, 0xa0(SP)		
  0x4373e1		48899c24a8000000	MOVQ BX, 0xa8(SP)		
  0x4373e9		899424b0000000		MOVL DX, 0xb0(SP)		
  0x4373f0		4889bc24b8000000	MOVQ DI, 0xb8(SP)		
	if locals.n > 0 {
  0x4373f8		8b9424a0000000		MOVL 0xa0(SP), DX	
  0x4373ff		85d2			TESTL DX, DX		
  0x437401		0f8f27020000		JG 0x43762e		
	if sys.ArchFamily == sys.AMD64 && frame.argp-frame.varp == 2*sys.RegSize {
  0x437407		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x43740f		488b5a40		MOVQ 0x40(DX), BX	
  0x437413		488b7238		MOVQ 0x38(DX), SI	
  0x437417		4829f3			SUBQ SI, BX		
  0x43741a		4883fb10		CMPQ $0x10, BX		
  0x43741e		0f85fd010000		JNE 0x437621		
		if !framepointer_enabled {
  0x437424		803df586080000		CMPB $0x0, 0x886f5(IP)	
  0x43742b		0f848f020000		JE 0x4376c0		
		adjustpointer(adjinfo, unsafe.Pointer(frame.varp))
  0x437431		90			NOPL			
	p := *pp
  0x437432		488b1e			MOVQ 0(SI), BX		
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437435		488bbc24d8000000	MOVQ 0xd8(SP), DI	
  0x43743d		48391f			CMPQ BX, 0(DI)		
  0x437440		7710			JA 0x437452		
  0x437442		48395f08		CMPQ BX, 0x8(DI)	
  0x437446		760a			JBE 0x437452		
		*pp = p + adjinfo.delta
  0x437448		4c8b4710		MOVQ 0x10(DI), R8	
  0x43744c		4c01c3			ADDQ R8, BX		
  0x43744f		48891e			MOVQ BX, 0(SI)		
	if args.n > 0 {
  0x437452		83bc24b000000000	CMPL $0x0, 0xb0(SP)	
  0x43745a		0f8f7b010000		JG 0x4375db		
	if frame.varp != 0 {
  0x437460		48837a3800		CMPQ $0x0, 0x38(DX)	
  0x437465		7432			JE 0x437499		
		for _, obj := range objs {
  0x437467		4885c9			TESTQ CX, CX		
  0x43746a		7e2d			JLE 0x437499		
  0x43746c		31db			XORL BX, BX		
  0x43746e		eb04			JMP 0x437474		
  0x437470		4883c010		ADDQ $0x10, AX		
  0x437474		488b7008		MOVQ 0x8(AX), SI	
  0x437478		4c8b00			MOVQ 0(AX), R8		
			base := frame.varp // locals base pointer
  0x43747b		4c8b4a38		MOVQ 0x38(DX), R9	
			if off >= 0 {
  0x43747f		4d85c0			TESTQ R8, R8		
  0x437482		7c04			JL 0x437488		
				base = frame.argp // arguments and return values base pointer
  0x437484		4c8b4a40		MOVQ 0x40(DX), R9	
			p := base + uintptr(off)
  0x437488		4d01c8			ADDQ R9, R8		
			if p < frame.sp {
  0x43748b		4c394228		CMPQ R8, 0x28(DX)	
  0x43748f		7620			JBE 0x4374b1		
		for _, obj := range objs {
  0x437491		48ffc3			INCQ BX			
  0x437494		4839cb			CMPQ CX, BX		
  0x437497		7cd7			JL 0x437470		
	return true
  0x437499		c68424e000000001	MOVB $0x1, 0xe0(SP)	
  0x4374a1		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x4374a9		4881c4c8000000		ADDQ $0xc8, SP		
  0x4374b0		c3			RET			
		for _, obj := range objs {
  0x4374b1		4889842488000000	MOVQ AX, 0x88(SP)	
  0x4374b9		48895c2470		MOVQ BX, 0x70(SP)	
			gcdata := t.gcdata
  0x4374be		4c8b4e20		MOVQ 0x20(SI), R9	
			if t.kind&kindGCProg != 0 {
  0x4374c2		440fb65617		MOVZX 0x17(SI), R10	
  0x4374c7		41f6c240		TESTL $0x40, R10	
  0x4374cb		0f85ae000000		JNE 0x43757f		
  0x4374d1		4531d2			XORL R10, R10		
			if s != nil {
  0x4374d4		4531db			XORL R11, R11		
			for i := uintptr(0); i < t.ptrdata; i += sys.PtrSize {
  0x4374d7		eb07			JMP 0x4374e0		
  0x4374d9		4d8d5d08		LEAQ 0x8(R13), R11	
		for _, obj := range objs {
  0x4374dd		4c89f1			MOVQ R14, CX		
			for i := uintptr(0); i < t.ptrdata; i += sys.PtrSize {
  0x4374e0		4c395e08		CMPQ R11, 0x8(SI)	
  0x4374e4		7647			JBE 0x43752d		
				if *addb(gcdata, i/(8*sys.PtrSize))>>(i/sys.PtrSize&7)&1 != 0 {
  0x4374e6		4d89dc			MOVQ R11, R12		
  0x4374e9		49c1eb06		SHRQ $0x6, R11		
  0x4374ed		470fb61c19		MOVZX 0(R9)(R11*1), R11	
  0x4374f2		90			NOPL			
  0x4374f3		4d89e5			MOVQ R12, R13		
  0x4374f6		49c1ec03		SHRQ $0x3, R12		
  0x4374fa		4983e407		ANDQ $0x7, R12		
	locals, args, objs := getStackMap(frame, &adjinfo.cache, true)
  0x4374fe		4989ce			MOVQ CX, R14		
				if *addb(gcdata, i/(8*sys.PtrSize))>>(i/sys.PtrSize&7)&1 != 0 {
  0x437501		4c89e1			MOVQ R12, CX		
  0x437504		41d2eb			SHRL CL, R11		
  0x437507		41f6c301		TESTL $0x1, R11		
  0x43750b		74cc			JE 0x4374d9		
					adjustpointer(adjinfo, unsafe.Pointer(p+i))
  0x43750d		4f8d5c0500		LEAQ 0(R13)(R8*1), R11	
  0x437512		90			NOPL			
	p := *pp
  0x437513		4d8b23			MOVQ 0(R11), R12	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437516		4c3927			CMPQ R12, 0(DI)		
  0x437519		77be			JA 0x4374d9		
  0x43751b		4c396708		CMPQ R12, 0x8(DI)	
  0x43751f		76b8			JBE 0x4374d9		
		*pp = p + adjinfo.delta
  0x437521		4c8b7f10		MOVQ 0x10(DI), R15	
  0x437525		4d01fc			ADDQ R15, R12		
  0x437528		4d8923			MOVQ R12, 0(R11)	
			for i := uintptr(0); i < t.ptrdata; i += sys.PtrSize {
  0x43752b		ebac			JMP 0x4374d9		
			if s != nil {
  0x43752d		4d85d2			TESTQ R10, R10		
  0x437530		0f845bffffff		JE 0x437491		
				dematerializeGCProg(s)
  0x437536		90			NOPL			
	mheap_.freeManual(s, &memstats.gc_sys)
  0x437537		488d0502f10800		LEAQ runtime.mheap_(SB), AX		
  0x43753e		48890424		MOVQ AX, 0(SP)				
  0x437542		4c89542408		MOVQ R10, 0x8(SP)			
  0x437547		488d0daa670a00		LEAQ runtime.memstats+152(SB), CX	
  0x43754e		48894c2410		MOVQ CX, 0x10(SP)			
  0x437553		e8386afeff		CALL runtime.(*mheap).freeManual(SB)	
		for _, obj := range objs {
  0x437558		488b842488000000	MOVQ 0x88(SP), AX	
  0x437560		488b4c2458		MOVQ 0x58(SP), CX	
			base := frame.varp // locals base pointer
  0x437565		488b9424d0000000	MOVQ 0xd0(SP), DX	
		for _, obj := range objs {
  0x43756d		488b5c2470		MOVQ 0x70(SP), BX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437572		488bbc24d8000000	MOVQ 0xd8(SP), DI	
		for _, obj := range objs {
  0x43757a		e912ffffff		JMP 0x437491		
			p := base + uintptr(off)
  0x43757f		4c89442450		MOVQ R8, 0x50(SP)	
		for _, obj := range objs {
  0x437584		4889b42480000000	MOVQ SI, 0x80(SP)	
				s = materializeGCProg(t.ptrdata, gcdata)
  0x43758c		488b4608		MOVQ 0x8(SI), AX			
  0x437590		48890424		MOVQ AX, 0(SP)				
  0x437594		4c894c2408		MOVQ R9, 0x8(SP)			
  0x437599		e8c290fdff		CALL runtime.materializeGCProg(SB)	
  0x43759e		4c8b542410		MOVQ 0x10(SP), R10			
				gcdata = (*byte)(unsafe.Pointer(s.startAddr))
  0x4375a3		4d8b4a18		MOVQ 0x18(R10), R9	
		for _, obj := range objs {
  0x4375a7		488b842488000000	MOVQ 0x88(SP), AX	
  0x4375af		488b4c2458		MOVQ 0x58(SP), CX	
			base := frame.varp // locals base pointer
  0x4375b4		488b9424d0000000	MOVQ 0xd0(SP), DX	
		for _, obj := range objs {
  0x4375bc		488b5c2470		MOVQ 0x70(SP), BX	
			for i := uintptr(0); i < t.ptrdata; i += sys.PtrSize {
  0x4375c1		488bb42480000000	MOVQ 0x80(SP), SI	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x4375c9		488bbc24d8000000	MOVQ 0xd8(SP), DI	
					adjustpointer(adjinfo, unsafe.Pointer(p+i))
  0x4375d1		4c8b442450		MOVQ 0x50(SP), R8	
				gcdata = (*byte)(unsafe.Pointer(s.startAddr))
  0x4375d6		e9f9feffff		JMP 0x4374d4		
		adjustpointers(unsafe.Pointer(frame.argp), &args, adjinfo, funcInfo{})
  0x4375db		488b4240		MOVQ 0x40(DX), AX		
  0x4375df		48890424		MOVQ AX, 0(SP)			
  0x4375e3		488d8424b0000000	LEAQ 0xb0(SP), AX		
  0x4375eb		4889442408		MOVQ AX, 0x8(SP)		
  0x4375f0		48897c2410		MOVQ DI, 0x10(SP)		
  0x4375f5		0f57c0			XORPS X0, X0			
  0x4375f8		0f11442418		MOVUPS X0, 0x18(SP)		
  0x4375fd		e8fefaffff		CALL runtime.adjustpointers(SB)	
		for _, obj := range objs {
  0x437602		488b442478		MOVQ 0x78(SP), AX	
  0x437607		488b4c2458		MOVQ 0x58(SP), CX	
	if frame.varp != 0 {
  0x43760c		488b9424d0000000	MOVQ 0xd0(SP), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437614		488bbc24d8000000	MOVQ 0xd8(SP), DI	
		adjustpointers(unsafe.Pointer(frame.argp), &args, adjinfo, funcInfo{})
  0x43761c		e93ffeffff		JMP 0x437460		
  0x437621		488bbc24d8000000	MOVQ 0xd8(SP), DI	
	if sys.ArchFamily == sys.AMD64 && frame.argp-frame.varp == 2*sys.RegSize {
  0x437629		e924feffff		JMP 0x437452		
		size := uintptr(locals.n) * sys.PtrSize
  0x43762e		4863c2			MOVSXD DX, AX		
  0x437631		48c1e003		SHLQ $0x3, AX		
		adjustpointers(unsafe.Pointer(frame.varp-size), &locals, adjinfo, f)
  0x437635		488b8c24d0000000	MOVQ 0xd0(SP), CX		
  0x43763d		488b5138		MOVQ 0x38(CX), DX		
  0x437641		4829c2			SUBQ AX, DX			
  0x437644		48891424		MOVQ DX, 0(SP)			
  0x437648		488d8424a0000000	LEAQ 0xa0(SP), AX		
  0x437650		4889442408		MOVQ AX, 0x8(SP)		
  0x437655		488b8424d8000000	MOVQ 0xd8(SP), AX		
  0x43765d		4889442410		MOVQ AX, 0x10(SP)		
  0x437662		488b942490000000	MOVQ 0x90(SP), DX		
  0x43766a		4889542418		MOVQ DX, 0x18(SP)		
  0x43766f		488b942498000000	MOVQ 0x98(SP), DX		
  0x437677		4889542420		MOVQ DX, 0x20(SP)		
  0x43767c		e87ffaffff		CALL runtime.adjustpointers(SB)	
		for _, obj := range objs {
  0x437681		488b442478		MOVQ 0x78(SP), AX	
  0x437686		488b4c2458		MOVQ 0x58(SP), CX	
		adjustpointers(unsafe.Pointer(frame.varp-size), &locals, adjinfo, f)
  0x43768b		e977fdffff		JMP 0x437407		
		return true
  0x437690		c68424e000000001	MOVB $0x1, 0xe0(SP)	
  0x437698		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x4376a0		4881c4c8000000		ADDQ $0xc8, SP		
  0x4376a7		c3			RET			
		return true
  0x4376a8		c68424e000000001	MOVB $0x1, 0xe0(SP)	
  0x4376b0		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x4376b8		4881c4c8000000		ADDQ $0xc8, SP		
  0x4376bf		c3			RET			
			print("runtime: found space for saved base pointer, but no framepointer experiment\n")
  0x4376c0		e8fbc7feff		CALL runtime.printlock(SB)	
  0x4376c5		488d059fbf0300		LEAQ 0x3bf9f(IP), AX		
  0x4376cc		48890424		MOVQ AX, 0(SP)			
  0x4376d0		48c74424084c000000	MOVQ $0x4c, 0x8(SP)		
  0x4376d9		e812d1feff		CALL runtime.printstring(SB)	
  0x4376de		e85dc8feff		CALL runtime.printunlock(SB)	
			print("argp=", hex(frame.argp), " varp=", hex(frame.varp), "\n")
  0x4376e3		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4376eb		488b4840		MOVQ 0x40(AX), CX		
  0x4376ef		48894c2468		MOVQ CX, 0x68(SP)		
  0x4376f4		488b4038		MOVQ 0x38(AX), AX		
  0x4376f8		4889442460		MOVQ AX, 0x60(SP)		
  0x4376fd		e8bec7feff		CALL runtime.printlock(SB)	
  0x437702		488d05e47a0300		LEAQ 0x37ae4(IP), AX		
  0x437709		48890424		MOVQ AX, 0(SP)			
  0x43770d		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x437716		e8d5d0feff		CALL runtime.printstring(SB)	
  0x43771b		488b442468		MOVQ 0x68(SP), AX		
  0x437720		48890424		MOVQ AX, 0(SP)			
  0x437724		e887cffeff		CALL runtime.printhex(SB)	
  0x437729		488d053e7b0300		LEAQ 0x37b3e(IP), AX		
  0x437730		48890424		MOVQ AX, 0(SP)			
  0x437734		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x43773d		e8aed0feff		CALL runtime.printstring(SB)	
  0x437742		488b442460		MOVQ 0x60(SP), AX		
  0x437747		48890424		MOVQ AX, 0(SP)			
  0x43774b		e860cffeff		CALL runtime.printhex(SB)	
  0x437750		e8fbc9feff		CALL runtime.printnl(SB)	
  0x437755		e8e6c7feff		CALL runtime.printunlock(SB)	
			throw("bad frame layout")
  0x43775a		488d0546880300		LEAQ 0x38846(IP), AX	
  0x437761		48890424		MOVQ AX, 0(SP)		
  0x437765		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43776e		e80dbdfeff		CALL runtime.throw(SB)	
  0x437773		0f0b			UD2			
func adjustframe(frame *stkframe, arg unsafe.Pointer) bool {
  0x437775		e806010100		CALL runtime.morestack_noctxt(SB)	
  0x43777a		e9b1fbffff		JMP runtime.adjustframe(SB)		

TEXT runtime.adjustctxt(SB) /usr/local/go/src/runtime/stack.go
	adjustpointer(adjinfo, unsafe.Pointer(&gp.sched.ctxt))
  0x437780		90			NOPL			
  0x437781		488b442408		MOVQ 0x8(SP), AX	
	p := *pp
  0x437786		488b4850		MOVQ 0x50(AX), CX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x43778a		488b542410		MOVQ 0x10(SP), DX	
  0x43778f		48390a			CMPQ CX, 0(DX)		
  0x437792		7711			JA 0x4377a5		
  0x437794		48394a08		CMPQ CX, 0x8(DX)	
  0x437798		760b			JBE 0x4377a5		
		*pp = p + adjinfo.delta
  0x43779a		488b5a10		MOVQ 0x10(DX), BX	
  0x43779e		4801d9			ADDQ BX, CX		
  0x4377a1		48894850		MOVQ CX, 0x50(AX)	
	if !framepointer_enabled {
  0x4377a5		803d7483080000		CMPB $0x0, 0x88374(IP)	
  0x4377ac		741c			JE 0x4377ca		
	adjustpointer(adjinfo, unsafe.Pointer(&gp.sched.bp))
  0x4377ae		90			NOPL			
	p := *pp
  0x4377af		488b4868		MOVQ 0x68(AX), CX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x4377b3		48390a			CMPQ CX, 0(DX)		
  0x4377b6		7711			JA 0x4377c9		
  0x4377b8		48394a08		CMPQ CX, 0x8(DX)	
  0x4377bc		760b			JBE 0x4377c9		
		*pp = p + adjinfo.delta
  0x4377be		488b5210		MOVQ 0x10(DX), DX	
  0x4377c2		4801d1			ADDQ DX, CX		
  0x4377c5		48894868		MOVQ CX, 0x68(AX)	
  0x4377c9		c3			RET			
		return
  0x4377ca		c3			RET			

TEXT runtime.adjustdefers(SB) /usr/local/go/src/runtime/stack.go
func adjustdefers(gp *g, adjinfo *adjustinfo) {
  0x4377d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4377d9		483b6110		CMPQ 0x10(CX), SP	
  0x4377dd		0f86a9000000		JBE 0x43788c		
  0x4377e3		4883ec20		SUBQ $0x20, SP		
  0x4377e7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4377ec		488d6c2418		LEAQ 0x18(SP), BP	
	tracebackdefers(gp, adjustframe, noescape(unsafe.Pointer(adjinfo)))
  0x4377f1		90			NOPL					
  0x4377f2		488b442428		MOVQ 0x28(SP), AX			
  0x4377f7		48890424		MOVQ AX, 0(SP)				
  0x4377fb		488d0d1ebf0300		LEAQ 0x3bf1e(IP), CX			
  0x437802		48894c2408		MOVQ CX, 0x8(SP)			
  0x437807		488b4c2430		MOVQ 0x30(SP), CX			
  0x43780c		48894c2410		MOVQ CX, 0x10(SP)			
  0x437811		e87a5d0000		CALL runtime.tracebackdefers(SB)	
	for d := gp._defer; d != nil; d = d.link {
  0x437816		488b442428		MOVQ 0x28(SP), AX	
  0x43781b		488b4028		MOVQ 0x28(AX), AX	
  0x43781f		488b4c2430		MOVQ 0x30(SP), CX	
  0x437824		eb04			JMP 0x43782a		
  0x437826		488b4028		MOVQ 0x28(AX), AX	
  0x43782a		4885c0			TESTQ AX, AX		
  0x43782d		7453			JE 0x437882		
		adjustpointer(adjinfo, unsafe.Pointer(&d.fn))
  0x43782f		90			NOPL			
	p := *pp
  0x437830		488b5018		MOVQ 0x18(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437834		483911			CMPQ DX, 0(CX)		
  0x437837		7711			JA 0x43784a		
  0x437839		48395108		CMPQ DX, 0x8(CX)	
  0x43783d		760b			JBE 0x43784a		
		*pp = p + adjinfo.delta
  0x43783f		488b5910		MOVQ 0x10(CX), BX	
  0x437843		4801da			ADDQ BX, DX		
  0x437846		48895018		MOVQ DX, 0x18(AX)	
		adjustpointer(adjinfo, unsafe.Pointer(&d.sp))
  0x43784a		90			NOPL			
	p := *pp
  0x43784b		488b5008		MOVQ 0x8(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x43784f		483911			CMPQ DX, 0(CX)		
  0x437852		7711			JA 0x437865		
  0x437854		48395108		CMPQ DX, 0x8(CX)	
  0x437858		760b			JBE 0x437865		
		*pp = p + adjinfo.delta
  0x43785a		488b5910		MOVQ 0x10(CX), BX	
  0x43785e		4801da			ADDQ BX, DX		
  0x437861		48895008		MOVQ DX, 0x8(AX)	
		adjustpointer(adjinfo, unsafe.Pointer(&d._panic))
  0x437865		90			NOPL			
	p := *pp
  0x437866		488b5020		MOVQ 0x20(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x43786a		483911			CMPQ DX, 0(CX)		
  0x43786d		77b7			JA 0x437826		
  0x43786f		48395108		CMPQ DX, 0x8(CX)	
  0x437873		76b1			JBE 0x437826		
		*pp = p + adjinfo.delta
  0x437875		488b5910		MOVQ 0x10(CX), BX	
  0x437879		4801da			ADDQ BX, DX		
  0x43787c		48895020		MOVQ DX, 0x20(AX)	
	for d := gp._defer; d != nil; d = d.link {
  0x437880		eba4			JMP 0x437826		
  0x437882		488b6c2418		MOVQ 0x18(SP), BP	
  0x437887		4883c420		ADDQ $0x20, SP		
  0x43788b		c3			RET			
func adjustdefers(gp *g, adjinfo *adjustinfo) {
  0x43788c		e8efff0000		CALL runtime.morestack_noctxt(SB)	
  0x437891		e93affffff		JMP runtime.adjustdefers(SB)		

TEXT runtime.adjustsudogs(SB) /usr/local/go/src/runtime/stack.go
	for s := gp.waiting; s != nil; s = s.waitlink {
  0x4378a0		488b442408		MOVQ 0x8(SP), AX	
  0x4378a5		488b8038010000		MOVQ 0x138(AX), AX	
  0x4378ac		488b4c2410		MOVQ 0x10(SP), CX	
  0x4378b1		eb04			JMP 0x4378b7		
  0x4378b3		488b4048		MOVQ 0x48(AX), AX	
  0x4378b7		4885c0			TESTQ AX, AX		
  0x4378ba		741d			JE 0x4378d9		
		adjustpointer(adjinfo, unsafe.Pointer(&s.elem))
  0x4378bc		90			NOPL			
	p := *pp
  0x4378bd		488b5020		MOVQ 0x20(AX), DX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x4378c1		483911			CMPQ DX, 0(CX)		
  0x4378c4		77ed			JA 0x4378b3		
  0x4378c6		48395108		CMPQ DX, 0x8(CX)	
  0x4378ca		76e7			JBE 0x4378b3		
		*pp = p + adjinfo.delta
  0x4378cc		488b5910		MOVQ 0x10(CX), BX	
  0x4378d0		4801da			ADDQ BX, DX		
  0x4378d3		48895020		MOVQ DX, 0x20(AX)	
	for s := gp.waiting; s != nil; s = s.waitlink {
  0x4378d7		ebda			JMP 0x4378b3		
  0x4378d9		c3			RET			

TEXT runtime.findsghi(SB) /usr/local/go/src/runtime/stack.go
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4378e0		488b442408		MOVQ 0x8(SP), AX	
  0x4378e5		488b8038010000		MOVQ 0x138(AX), AX	
  0x4378ec		488b4c2418		MOVQ 0x18(SP), CX	
  0x4378f1		488b542410		MOVQ 0x10(SP), DX	
  0x4378f6		31db			XORL BX, BX		
  0x4378f8		eb07			JMP 0x437901		
  0x4378fa		488b4048		MOVQ 0x48(AX), AX	
		if stk.lo <= p && p < stk.hi && p > sghi {
  0x4378fe		4889f3			MOVQ SI, BX		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437901		4885c0			TESTQ AX, AX		
  0x437904		7423			JE 0x437929		
		p := uintptr(sg.elem) + uintptr(sg.c.elemsize)
  0x437906		488b7058		MOVQ 0x58(AX), SI	
  0x43790a		488b7820		MOVQ 0x20(AX), DI	
  0x43790e		0fb77618		MOVZX 0x18(SI), SI	
  0x437912		4801fe			ADDQ DI, SI		
		if stk.lo <= p && p < stk.hi && p > sghi {
  0x437915		4839f2			CMPQ SI, DX		
  0x437918		770a			JA 0x437924		
  0x43791a		4839ce			CMPQ CX, SI		
  0x43791d		7305			JAE 0x437924		
  0x43791f		4839de			CMPQ BX, SI		
  0x437922		77d6			JA 0x4378fa		
  0x437924		4889de			MOVQ BX, SI		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437927		ebd1			JMP 0x4378fa		
	return sghi
  0x437929		48895c2420		MOVQ BX, 0x20(SP)	
  0x43792e		c3			RET			

TEXT runtime.syncadjustsudogs(SB) /usr/local/go/src/runtime/stack.go
func syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr {
  0x437930		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437939		483b6110		CMPQ 0x10(CX), SP	
  0x43793d		0f8631010000		JBE 0x437a74		
  0x437943		4883ec38		SUBQ $0x38, SP		
  0x437947		48896c2430		MOVQ BP, 0x30(SP)	
  0x43794c		488d6c2430		LEAQ 0x30(SP), BP	
	if gp.waiting == nil {
  0x437951		488b442440		MOVQ 0x40(SP), AX	
  0x437956		488b8838010000		MOVQ 0x138(AX), CX	
  0x43795d		4885c9			TESTQ CX, CX		
  0x437960		0f84fb000000		JE 0x437a61		
  0x437966		31d2			XORL DX, DX		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437968		eb0b			JMP 0x437975		
  0x43796a		488b5948		MOVQ 0x48(CX), BX	
		lastc = sg.c
  0x43796e		488b5158		MOVQ 0x58(CX), DX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437972		4889d9			MOVQ BX, CX		
  0x437975		4885c9			TESTQ CX, CX		
  0x437978		7429			JE 0x4379a3		
		if sg.c != lastc {
  0x43797a		488b5958		MOVQ 0x58(CX), BX	
  0x43797e		4839da			CMPQ BX, DX		
  0x437981		74e7			JE 0x43796a		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437983		48894c2428		MOVQ CX, 0x28(SP)	
			lock(&sg.c.lock)
  0x437988		8403			TESTB AL, 0(BX)		
  0x43798a		488d4358		LEAQ 0x58(BX), AX	
  0x43798e		48890424		MOVQ AX, 0(SP)		
  0x437992		e8490dfdff		CALL runtime.lock(SB)	
	adjustsudogs(gp, adjinfo)
  0x437997		488b442440		MOVQ 0x40(SP), AX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x43799c		488b4c2428		MOVQ 0x28(SP), CX	
			lock(&sg.c.lock)
  0x4379a1		ebc7			JMP 0x43796a		
	adjustsudogs(gp, adjinfo)
  0x4379a3		48890424		MOVQ AX, 0(SP)			
  0x4379a7		488b4c2450		MOVQ 0x50(SP), CX		
  0x4379ac		48894c2408		MOVQ CX, 0x8(SP)		
  0x4379b1		e8eafeffff		CALL runtime.adjustsudogs(SB)	
	if adjinfo.sghi != 0 {
  0x4379b6		488b442450		MOVQ 0x50(SP), AX	
  0x4379bb		488b8818010000		MOVQ 0x118(AX), CX	
  0x4379c2		4885c9			TESTQ CX, CX		
  0x4379c5		755f			JNE 0x437a26		
  0x4379c7		31c0			XORL AX, AX		
	return sgsize
  0x4379c9		4889442418		MOVQ AX, 0x18(SP)	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4379ce		488b4c2440		MOVQ 0x40(SP), CX	
  0x4379d3		488b8938010000		MOVQ 0x138(CX), CX	
  0x4379da		31d2			XORL DX, DX		
  0x4379dc		eb0b			JMP 0x4379e9		
  0x4379de		488b5948		MOVQ 0x48(CX), BX	
		lastc = sg.c
  0x4379e2		488b5158		MOVQ 0x58(CX), DX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4379e6		4889d9			MOVQ BX, CX		
  0x4379e9		4885c9			TESTQ CX, CX		
  0x4379ec		7429			JE 0x437a17		
		if sg.c != lastc {
  0x4379ee		488b5958		MOVQ 0x58(CX), BX	
  0x4379f2		4839da			CMPQ BX, DX		
  0x4379f5		74e7			JE 0x4379de		
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x4379f7		48894c2420		MOVQ CX, 0x20(SP)	
			unlock(&sg.c.lock)
  0x4379fc		8403			TESTB AL, 0(BX)		
  0x4379fe		488d4358		LEAQ 0x58(BX), AX	
  0x437a02		48890424		MOVQ AX, 0(SP)		
  0x437a06		e8850efdff		CALL runtime.unlock(SB)	
	return sgsize
  0x437a0b		488b442418		MOVQ 0x18(SP), AX	
	for sg := gp.waiting; sg != nil; sg = sg.waitlink {
  0x437a10		488b4c2420		MOVQ 0x20(SP), CX	
			unlock(&sg.c.lock)
  0x437a15		ebc7			JMP 0x4379de		
	return sgsize
  0x437a17		4889442458		MOVQ AX, 0x58(SP)	
  0x437a1c		488b6c2430		MOVQ 0x30(SP), BP	
  0x437a21		4883c438		ADDQ $0x38, SP		
  0x437a25		c3			RET			
		oldBot := adjinfo.old.hi - used
  0x437a26		488b5008		MOVQ 0x8(AX), DX	
  0x437a2a		488b5c2448		MOVQ 0x48(SP), BX	
  0x437a2f		4829da			SUBQ BX, DX		
		newBot := oldBot + adjinfo.delta
  0x437a32		488b4010		MOVQ 0x10(AX), AX	
  0x437a36		4801d0			ADDQ DX, AX		
		memmove(unsafe.Pointer(newBot), unsafe.Pointer(oldBot), sgsize)
  0x437a39		48890424		MOVQ AX, 0(SP)		
  0x437a3d		4889d0			MOVQ DX, AX		
  0x437a40		4889542408		MOVQ DX, 0x8(SP)	
		sgsize = adjinfo.sghi - oldBot
  0x437a45		4829c1			SUBQ AX, CX		
  0x437a48		48894c2418		MOVQ CX, 0x18(SP)	
		memmove(unsafe.Pointer(newBot), unsafe.Pointer(oldBot), sgsize)
  0x437a4d		48894c2410		MOVQ CX, 0x10(SP)		
  0x437a52		e8f92c0100		CALL runtime.memmove(SB)	
	return sgsize
  0x437a57		488b442418		MOVQ 0x18(SP), AX	
		memmove(unsafe.Pointer(newBot), unsafe.Pointer(oldBot), sgsize)
  0x437a5c		e968ffffff		JMP 0x4379c9		
		return 0
  0x437a61		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x437a6a		488b6c2430		MOVQ 0x30(SP), BP	
  0x437a6f		4883c438		ADDQ $0x38, SP		
  0x437a73		c3			RET			
func syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr {
  0x437a74		e807fe0000		CALL runtime.morestack_noctxt(SB)	
  0x437a79		e9b2feffff		JMP runtime.syncadjustsudogs(SB)	

TEXT runtime.copystack(SB) /usr/local/go/src/runtime/stack.go
func copystack(gp *g, newsize uintptr, sync bool) {
  0x437a80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437a89		488d8424d0feffff	LEAQ 0xfffffed0(SP), AX	
  0x437a91		483b4110		CMPQ 0x10(CX), AX	
  0x437a95		0f8606030000		JBE 0x437da1		
  0x437a9b		4881ecb0010000		SUBQ $0x1b0, SP		
  0x437aa2		4889ac24a8010000	MOVQ BP, 0x1a8(SP)	
  0x437aaa		488dac24a8010000	LEAQ 0x1a8(SP), BP	
	if gp.syscallsp != 0 {
  0x437ab2		488b8424b8010000	MOVQ 0x1b8(SP), AX	
  0x437aba		4883787000		CMPQ $0x0, 0x70(AX)	
  0x437abf		0f85c1020000		JNE 0x437d86		
	old := gp.stack
  0x437ac5		488b4808		MOVQ 0x8(AX), CX	
  0x437ac9		488b10			MOVQ 0(AX), DX		
	if old.lo == 0 {
  0x437acc		4885d2			TESTQ DX, DX		
  0x437acf		0f8496020000		JE 0x437d6b		
	old := gp.stack
  0x437ad5		4889942480000000	MOVQ DX, 0x80(SP)	
  0x437add		48894c2478		MOVQ CX, 0x78(SP)	
	used := old.hi - gp.sched.sp
  0x437ae2		488b4838		MOVQ 0x38(AX), CX	
  0x437ae6		48894c2470		MOVQ CX, 0x70(SP)	
	new := stackalloc(uint32(newsize))
  0x437aeb		488b9424c0010000	MOVQ 0x1c0(SP), DX		
  0x437af3		891424			MOVL DX, 0(SP)			
  0x437af6		e8a5efffff		CALL runtime.stackalloc(SB)	
  0x437afb		488b442410		MOVQ 0x10(SP), AX		
  0x437b00		4889442468		MOVQ AX, 0x68(SP)		
  0x437b05		488b4c2408		MOVQ 0x8(SP), CX		
  0x437b0a		48894c2460		MOVQ CX, 0x60(SP)		
	var adjinfo adjustinfo
  0x437b0f		488dbc2488000000	LEAQ 0x88(SP), DI	
  0x437b17		0f57c0			XORPS X0, X0		
  0x437b1a		488d7fe0		LEAQ -0x20(DI), DI	
  0x437b1e		48896c24f0		MOVQ BP, -0x10(SP)	
  0x437b23		488d6c24f0		LEAQ -0x10(SP), BP	
  0x437b28		e89b250100		CALL 0x44a0c8		
  0x437b2d		488b6d00		MOVQ 0(BP), BP		
	adjinfo.old = old
  0x437b31		488b942480000000	MOVQ 0x80(SP), DX	
  0x437b39		4889942488000000	MOVQ DX, 0x88(SP)	
  0x437b41		488b5c2478		MOVQ 0x78(SP), BX	
  0x437b46		48899c2490000000	MOVQ BX, 0x90(SP)	
	adjinfo.delta = new.hi - old.hi
  0x437b4e		4829d8			SUBQ BX, AX		
  0x437b51		4889842498000000	MOVQ AX, 0x98(SP)	
	used := old.hi - gp.sched.sp
  0x437b59		488b442470		MOVQ 0x70(SP), AX	
  0x437b5e		4889df			MOVQ BX, DI		
  0x437b61		4829c3			SUBQ AX, BX		
  0x437b64		48895c2458		MOVQ BX, 0x58(SP)	
func copystack(gp *g, newsize uintptr, sync bool) {
  0x437b69		0fb68424c8010000	MOVZX 0x1c8(SP), AX	
  0x437b71		84c0			TESTL AL, AL		
	if sync {
  0x437b73		0f848d010000		JE 0x437d06		
		adjustsudogs(gp, &adjinfo)
  0x437b79		488b8424b8010000	MOVQ 0x1b8(SP), AX		
  0x437b81		48890424		MOVQ AX, 0(SP)			
  0x437b85		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x437b8d		48894c2408		MOVQ CX, 0x8(SP)		
  0x437b92		e809fdffff		CALL runtime.adjustsudogs(SB)	
	memmove(unsafe.Pointer(new.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)
  0x437b97		488b442458		MOVQ 0x58(SP), AX		
  0x437b9c		488b4c2468		MOVQ 0x68(SP), CX		
  0x437ba1		4829c1			SUBQ AX, CX			
  0x437ba4		48890c24		MOVQ CX, 0(SP)			
  0x437ba8		488b4c2478		MOVQ 0x78(SP), CX		
  0x437bad		4829c1			SUBQ AX, CX			
  0x437bb0		48894c2408		MOVQ CX, 0x8(SP)		
  0x437bb5		4889442410		MOVQ AX, 0x10(SP)		
  0x437bba		e8912b0100		CALL runtime.memmove(SB)	
	adjustctxt(gp, &adjinfo)
  0x437bbf		488b8424b8010000	MOVQ 0x1b8(SP), AX		
  0x437bc7		48890424		MOVQ AX, 0(SP)			
  0x437bcb		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x437bd3		48894c2408		MOVQ CX, 0x8(SP)		
  0x437bd8		e8a3fbffff		CALL runtime.adjustctxt(SB)	
	adjustdefers(gp, &adjinfo)
  0x437bdd		488b8424b8010000	MOVQ 0x1b8(SP), AX		
  0x437be5		48890424		MOVQ AX, 0(SP)			
  0x437be9		488d8c2488000000	LEAQ 0x88(SP), CX		
  0x437bf1		48894c2408		MOVQ CX, 0x8(SP)		
  0x437bf6		e8d5fbffff		CALL runtime.adjustdefers(SB)	
	adjustpanics(gp, &adjinfo)
  0x437bfb		90			NOPL			
	adjustpointer(adjinfo, unsafe.Pointer(&gp._panic))
  0x437bfc		90			NOPL			
	p := *pp
  0x437bfd		488b8424b8010000	MOVQ 0x1b8(SP), AX	
  0x437c05		488b4820		MOVQ 0x20(AX), CX	
	if adjinfo.old.lo <= p && p < adjinfo.old.hi {
  0x437c09		48398c2488000000	CMPQ CX, 0x88(SP)	
  0x437c11		7719			JA 0x437c2c		
  0x437c13		48398c2490000000	CMPQ CX, 0x90(SP)	
  0x437c1b		760f			JBE 0x437c2c		
		*pp = p + adjinfo.delta
  0x437c1d		488b942498000000	MOVQ 0x98(SP), DX	
  0x437c25		4801d1			ADDQ DX, CX		
  0x437c28		48894820		MOVQ CX, 0x20(AX)	
	if adjinfo.sghi != 0 {
  0x437c2c		488b8c24a0010000	MOVQ 0x1a0(SP), CX	
  0x437c34		4885c9			TESTQ CX, CX		
  0x437c37		7413			JE 0x437c4c		
		adjinfo.sghi += adjinfo.delta
  0x437c39		488b942498000000	MOVQ 0x98(SP), DX	
  0x437c41		4801d1			ADDQ DX, CX		
  0x437c44		48898c24a0010000	MOVQ CX, 0x1a0(SP)	
	gp.stack = new
  0x437c4c		488b4c2460		MOVQ 0x60(SP), CX	
  0x437c51		488908			MOVQ CX, 0(AX)		
  0x437c54		488b542468		MOVQ 0x68(SP), DX	
  0x437c59		48895008		MOVQ DX, 0x8(AX)	
	gp.stackguard0 = new.lo + _StackGuard // NOTE: might clobber a preempt request
  0x437c5d		4881c170030000		ADDQ $0x370, CX		
  0x437c64		48894810		MOVQ CX, 0x10(AX)	
	gp.sched.sp = new.hi - used
  0x437c68		488b4c2458		MOVQ 0x58(SP), CX	
  0x437c6d		4829ca			SUBQ CX, DX		
  0x437c70		48895038		MOVQ DX, 0x38(AX)	
	gp.stktopsp += adjinfo.delta
  0x437c74		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x437c7c		48018880000000		ADDQ CX, 0x80(AX)	
	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&adjinfo)), 0)
  0x437c83		90			NOPL				
  0x437c84		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x437c8c		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x437c95		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x437c9e		4889442418		MOVQ AX, 0x18(SP)		
  0x437ca3		0f57c0			XORPS X0, X0			
  0x437ca6		0f11442420		MOVUPS X0, 0x20(SP)		
  0x437cab		48c7442430ffffff7f	MOVQ $0x7fffffff, 0x30(SP)	
  0x437cb4		488d0565ba0300		LEAQ 0x3ba65(IP), AX		
  0x437cbb		4889442438		MOVQ AX, 0x38(SP)		
  0x437cc0		488d842488000000	LEAQ 0x88(SP), AX		
  0x437cc8		4889442440		MOVQ AX, 0x40(SP)		
  0x437ccd		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x437cd6		e8e55a0000		CALL runtime.gentraceback(SB)	
	stackfree(old)
  0x437cdb		488b842480000000	MOVQ 0x80(SP), AX		
  0x437ce3		48890424		MOVQ AX, 0(SP)			
  0x437ce7		488b442478		MOVQ 0x78(SP), AX		
  0x437cec		4889442408		MOVQ AX, 0x8(SP)		
  0x437cf1		e8caf0ffff		CALL runtime.stackfree(SB)	
}
  0x437cf6		488bac24a8010000	MOVQ 0x1a8(SP), BP	
  0x437cfe		4881c4b0010000		ADDQ $0x1b0, SP		
  0x437d05		c3			RET			
		adjinfo.sghi = findsghi(gp, old)
  0x437d06		488b8424b8010000	MOVQ 0x1b8(SP), AX		
  0x437d0e		48890424		MOVQ AX, 0(SP)			
  0x437d12		4889542408		MOVQ DX, 0x8(SP)		
  0x437d17		48897c2410		MOVQ DI, 0x10(SP)		
  0x437d1c		e8bffbffff		CALL runtime.findsghi(SB)	
  0x437d21		488b442418		MOVQ 0x18(SP), AX		
  0x437d26		48898424a0010000	MOVQ AX, 0x1a0(SP)		
		ncopy -= syncadjustsudogs(gp, used, &adjinfo)
  0x437d2e		488b8424b8010000	MOVQ 0x1b8(SP), AX			
  0x437d36		48890424		MOVQ AX, 0(SP)				
  0x437d3a		488b4c2458		MOVQ 0x58(SP), CX			
  0x437d3f		48894c2408		MOVQ CX, 0x8(SP)			
  0x437d44		488d942488000000	LEAQ 0x88(SP), DX			
  0x437d4c		4889542410		MOVQ DX, 0x10(SP)			
  0x437d51		e8dafbffff		CALL runtime.syncadjustsudogs(SB)	
  0x437d56		488b442418		MOVQ 0x18(SP), AX			
  0x437d5b		488b4c2458		MOVQ 0x58(SP), CX			
  0x437d60		4829c1			SUBQ AX, CX				
	memmove(unsafe.Pointer(new.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)
  0x437d63		4889c8			MOVQ CX, AX		
		ncopy -= syncadjustsudogs(gp, used, &adjinfo)
  0x437d66		e931feffff		JMP 0x437b9c		
		throw("nil stackbase")
  0x437d6b		488d051c7f0300		LEAQ 0x37f1c(IP), AX	
  0x437d72		48890424		MOVQ AX, 0(SP)		
  0x437d76		48c74424080d000000	MOVQ $0xd, 0x8(SP)	
  0x437d7f		e8fcb6feff		CALL runtime.throw(SB)	
  0x437d84		0f0b			UD2			
		throw("stack growth not allowed in system call")
  0x437d86		488d056eab0300		LEAQ 0x3ab6e(IP), AX	
  0x437d8d		48890424		MOVQ AX, 0(SP)		
  0x437d91		48c744240827000000	MOVQ $0x27, 0x8(SP)	
  0x437d9a		e8e1b6feff		CALL runtime.throw(SB)	
  0x437d9f		0f0b			UD2			
func copystack(gp *g, newsize uintptr, sync bool) {
  0x437da1		e8dafa0000		CALL runtime.morestack_noctxt(SB)	
  0x437da6		e9d5fcffff		JMP runtime.copystack(SB)		

TEXT runtime.round2(SB) /usr/local/go/src/runtime/stack.go
	for 1<<s < x {
  0x437db0		8b442408		MOVL 0x8(SP), AX	
  0x437db4		31c9			XORL CX, CX		
  0x437db6		eb03			JMP 0x437dbb		
		s++
  0x437db8		48ffc1			INCQ CX			
	for 1<<s < x {
  0x437dbb		4883f920		CMPQ $0x20, CX		
  0x437dbf		19d2			SBBL DX, DX		
  0x437dc1		bb01000000		MOVL $0x1, BX		
  0x437dc6		d3e3			SHLL CL, BX		
  0x437dc8		21d3			ANDL DX, BX		
  0x437dca		39c3			CMPL AX, BX		
  0x437dcc		7cea			JL 0x437db8		
	return 1 << s
  0x437dce		895c2410		MOVL BX, 0x10(SP)	
  0x437dd2		c3			RET			

TEXT runtime.newstack(SB) /usr/local/go/src/runtime/stack.go
func newstack() {
  0x437de0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x437de9		488d8424f8feffff	LEAQ 0xfffffef8(SP), AX	
  0x437df1		483b4110		CMPQ 0x10(CX), AX	
  0x437df5		0f86020d0000		JBE 0x438afd		
  0x437dfb		4881ec88010000		SUBQ $0x188, SP		
  0x437e02		4889ac2480010000	MOVQ BP, 0x180(SP)	
  0x437e0a		488dac2480010000	LEAQ 0x180(SP), BP	
	thisg := getg()
  0x437e12		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if thisg.m.morebuf.g.ptr().stackguard0 == stackFork {
  0x437e1b		488b4830		MOVQ 0x30(AX), CX	
  0x437e1f		488b5118		MOVQ 0x18(CX), DX	
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x437e23		4889d3			MOVQ DX, BX		
	if thisg.m.morebuf.g.ptr().stackguard0 == stackFork {
  0x437e26		90			NOPL			
  0x437e27		48817a102efbffff	CMPQ $-0x4d2, 0x10(DX)	
  0x437e2f		0f84ad0c0000		JE 0x438ae2		
	thisg := getg()
  0x437e35		4889842498000000	MOVQ AX, 0x98(SP)	
	if thisg.m.morebuf.g.ptr() != thisg.m.curg {
  0x437e3d		90			NOPL			
  0x437e3e		488bb1c0000000		MOVQ 0xc0(CX), SI	
  0x437e45		4889b424d0000000	MOVQ SI, 0xd0(SP)	
  0x437e4d		4839f2			CMPQ SI, DX		
  0x437e50		0f85f80a0000		JNE 0x43894e		
	if thisg.m.curg.throwsplit {
  0x437e56		80beb600000000		CMPB $0x0, 0xb6(SI)	
  0x437e5d		0f854c050000		JNE 0x4383af		
	morebuf := thisg.m.morebuf
  0x437e63		488b5108		MOVQ 0x8(CX), DX	
  0x437e67		48899424d8000000	MOVQ DX, 0xd8(SP)	
  0x437e6f		0f104110		MOVUPS 0x10(CX), X0	
  0x437e73		0f118424e0000000	MOVUPS X0, 0xe0(SP)	
  0x437e7b		0f104120		MOVUPS 0x20(CX), X0	
  0x437e7f		0f118424f0000000	MOVUPS X0, 0xf0(SP)	
  0x437e87		0f104130		MOVUPS 0x30(CX), X0	
  0x437e8b		0f11842400010000	MOVUPS X0, 0x100(SP)	
	thisg.m.morebuf.pc = 0
  0x437e93		488b4830		MOVQ 0x30(AX), CX	
  0x437e97		48c7411000000000	MOVQ $0x0, 0x10(CX)	
	thisg.m.morebuf.lr = 0
  0x437e9f		488b4830		MOVQ 0x30(AX), CX	
  0x437ea3		48c7413000000000	MOVQ $0x0, 0x30(CX)	
	thisg.m.morebuf.sp = 0
  0x437eab		488b4830		MOVQ 0x30(AX), CX	
  0x437eaf		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	thisg.m.morebuf.g = 0
  0x437eb7		488b4830		MOVQ 0x30(AX), CX	
  0x437ebb		48c7411800000000	MOVQ $0x0, 0x18(CX)	
	preempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt
  0x437ec3		488b4e10		MOVQ 0x10(SI), CX	
  0x437ec7		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x437ecf		4881f9defaffff		CMPQ $-0x522, CX	
	if preempt {
  0x437ed6		752b			JNE 0x437f03		
		if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != "" || thisg.m.p.ptr().status != _Prunning {
  0x437ed8		488b5030		MOVQ 0x30(AX), DX	
  0x437edc		83ba0801000000		CMPL $0x0, 0x108(DX)	
  0x437ee3		0f8494040000		JE 0x43837d		
			gp.stackguard0 = gp.stack.lo + _StackGuard
  0x437ee9		488b06			MOVQ 0(SI), AX		
  0x437eec		480570030000		ADDQ $0x370, AX		
  0x437ef2		48894610		MOVQ AX, 0x10(SI)	
			gogo(&gp.sched) // never return
  0x437ef6		488d4638		LEAQ 0x38(SI), AX	
  0x437efa		48890424		MOVQ AX, 0(SP)		
  0x437efe		e84df70000		CALL runtime.gogo(SB)	
	if gp.stack.lo == 0 {
  0x437f03		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x437f0b		488b08			MOVQ 0(AX), CX		
  0x437f0e		4885c9			TESTQ CX, CX		
  0x437f11		0f8432070000		JE 0x438649		
	sp := gp.sched.sp
  0x437f17		488b5038		MOVQ 0x38(AX), DX	
		sp -= sys.PtrSize
  0x437f1b		488d5af8		LEAQ -0x8(DX), BX	
  0x437f1f		48895c2428		MOVQ BX, 0x28(SP)	
	if stackDebug >= 1 || sp < gp.stack.lo {
  0x437f24		4839cb			CMPQ CX, BX		
  0x437f27		0f822e020000		JB 0x43815b		
	if sp < gp.stack.lo {
  0x437f2d		483918			CMPQ BX, 0(AX)		
  0x437f30		0f87d2050000		JA 0x438508		
	preempt := atomic.Loaduintptr(&gp.stackguard0) == stackPreempt
  0x437f36		488b8c2490000000	MOVQ 0x90(SP), CX	
  0x437f3e		4881f9defaffff		CMPQ $-0x522, CX	
	if preempt {
  0x437f45		0f8530010000		JNE 0x43807b		
		if gp == thisg.m.g0 {
  0x437f4b		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x437f53		488b4930		MOVQ 0x30(CX), CX	
  0x437f57		483901			CMPQ AX, 0(CX)		
  0x437f5a		0f848d050000		JE 0x4384ed		
		if thisg.m.p == 0 && thisg.m.locks == 0 {
  0x437f60		4883b9d000000000	CMPQ $0x0, 0xd0(CX)	
  0x437f68		750d			JNE 0x437f77		
  0x437f6a		83b90801000000		CMPL $0x0, 0x108(CX)	
  0x437f71		0f845b050000		JE 0x4384d2		
		casgstatus(gp, _Grunning, _Gwaiting)
  0x437f77		48890424		MOVQ AX, 0(SP)			
  0x437f7b		48b90200000004000000	MOVQ $0x400000002, CX		
  0x437f85		48894c2408		MOVQ CX, 0x8(SP)		
  0x437f8a		e811edfeff		CALL runtime.casgstatus(SB)	
		if gp.preemptscan {
  0x437f8f		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x437f97		80b8b300000000		CMPB $0x0, 0xb3(AX)	
  0x437f9e		750d			JNE 0x437fad		
  0x437fa0		e9a5000000		JMP 0x43804a		
			for !castogscanstatus(gp, _Gwaiting, _Gscanwaiting) {
  0x437fa5		488b8424d0000000	MOVQ 0xd0(SP), AX			
  0x437fad		48890424		MOVQ AX, 0(SP)				
  0x437fb1		48b90400000004100000	MOVQ $0x100400000004, CX		
  0x437fbb		48894c2408		MOVQ CX, 0x8(SP)			
  0x437fc0		e8fbebfeff		CALL runtime.castogscanstatus(SB)	
  0x437fc5		807c241000		CMPB $0x0, 0x10(SP)			
  0x437fca		74d9			JE 0x437fa5				
			if !gp.gcscandone {
  0x437fcc		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x437fd4		80b8b400000000		CMPB $0x0, 0xb4(AX)	
  0x437fdb		0f8441010000		JE 0x438122		
			gp.preemptscan = false
  0x437fe1		c680b300000000		MOVB $0x0, 0xb3(AX)	
			gp.preempt = false
  0x437fe8		c680b100000000		MOVB $0x0, 0xb1(AX)	
			casfrom_Gscanstatus(gp, _Gscanwaiting, _Gwaiting)
  0x437fef		48890424		MOVQ AX, 0(SP)				
  0x437ff3		48b90410000004000000	MOVQ $0x400001004, CX			
  0x437ffd		48894c2408		MOVQ CX, 0x8(SP)			
  0x438002		e859e7feff		CALL runtime.casfrom_Gscanstatus(SB)	
			casgstatus(gp, _Gwaiting, _Grunning)
  0x438007		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43800f		48890424		MOVQ AX, 0(SP)			
  0x438013		48b90400000002000000	MOVQ $0x200000004, CX		
  0x43801d		48894c2408		MOVQ CX, 0x8(SP)		
  0x438022		e879ecfeff		CALL runtime.casgstatus(SB)	
			gp.stackguard0 = gp.stack.lo + _StackGuard
  0x438027		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x43802f		488b08			MOVQ 0(AX), CX		
  0x438032		4881c170030000		ADDQ $0x370, CX		
  0x438039		48894810		MOVQ CX, 0x10(AX)	
			gogo(&gp.sched) // never return
  0x43803d		488d4838		LEAQ 0x38(AX), CX	
  0x438041		48890c24		MOVQ CX, 0(SP)		
  0x438045		e806f60000		CALL runtime.gogo(SB)	
		casgstatus(gp, _Gwaiting, _Grunning)
  0x43804a		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x438052		48890424		MOVQ AX, 0(SP)			
  0x438056		48b90400000002000000	MOVQ $0x200000004, CX		
  0x438060		48894c2408		MOVQ CX, 0x8(SP)		
  0x438065		e836ecfeff		CALL runtime.casgstatus(SB)	
		gopreempt_m(gp) // never return
  0x43806a		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x438072		48890424		MOVQ AX, 0(SP)			
  0x438076		e8e532ffff		CALL runtime.gopreempt_m(SB)	
	oldsize := gp.stack.hi - gp.stack.lo
  0x43807b		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x438083		488b4808		MOVQ 0x8(AX), CX	
  0x438087		482b08			SUBQ 0(AX), CX		
	newsize := oldsize * 2
  0x43808a		48d1e1			SHLQ $0x1, CX		
	if newsize > maxstacksize {
  0x43808d		48390db46f0800		CMPQ CX, runtime.maxstacksize(SB)	
  0x438094		0f82d1030000		JB 0x43846b				
	newsize := oldsize * 2
  0x43809a		48898c2488000000	MOVQ CX, 0x88(SP)	
	casgstatus(gp, _Grunning, _Gcopystack)
  0x4380a2		48890424		MOVQ AX, 0(SP)			
  0x4380a6		48b90200000008000000	MOVQ $0x800000002, CX		
  0x4380b0		48894c2408		MOVQ CX, 0x8(SP)		
  0x4380b5		e8e6ebfeff		CALL runtime.casgstatus(SB)	
	copystack(gp, newsize, true)
  0x4380ba		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4380c2		48890424		MOVQ AX, 0(SP)			
  0x4380c6		488b8c2488000000	MOVQ 0x88(SP), CX		
  0x4380ce		48894c2408		MOVQ CX, 0x8(SP)		
  0x4380d3		c644241001		MOVB $0x1, 0x10(SP)		
  0x4380d8		e8a3f9ffff		CALL runtime.copystack(SB)	
	casgstatus(gp, _Gcopystack, _Grunning)
  0x4380dd		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4380e5		48890424		MOVQ AX, 0(SP)			
  0x4380e9		48b90800000002000000	MOVQ $0x200000008, CX		
  0x4380f3		48894c2408		MOVQ CX, 0x8(SP)		
  0x4380f8		e8a3ebfeff		CALL runtime.casgstatus(SB)	
	gogo(&gp.sched)
  0x4380fd		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x438105		4883c038		ADDQ $0x38, AX		
  0x438109		48890424		MOVQ AX, 0(SP)		
  0x43810d		e83ef50000		CALL runtime.gogo(SB)	
}
  0x438112		488bac2480010000	MOVQ 0x180(SP), BP	
  0x43811a		4881c488010000		ADDQ $0x188, SP		
  0x438121		c3			RET			
				gcw := &gp.m.p.ptr().gcw
  0x438122		488b4830		MOVQ 0x30(AX), CX	
  0x438126		488b91d0000000		MOVQ 0xd0(CX), DX	
  0x43812d		8402			TESTB AL, 0(DX)		
  0x43812f		8401			TESTB AL, 0(CX)		
  0x438131		90			NOPL			
				scanstack(gp, gcw)
  0x438132		48890424		MOVQ AX, 0(SP)		
				gcw := &gp.m.p.ptr().gcw
  0x438136		488d8a70120000		LEAQ 0x1270(DX), CX	
				scanstack(gp, gcw)
  0x43813d		48894c2408		MOVQ CX, 0x8(SP)		
  0x438142		e899f6fdff		CALL runtime.scanstack(SB)	
				gp.gcscandone = true
  0x438147		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x43814f		c680b400000001		MOVB $0x1, 0xb4(AX)	
  0x438156		e986feffff		JMP 0x437fe1		
	if gp.stack.lo == 0 {
  0x43815b		48898c2488000000	MOVQ CX, 0x88(SP)	
	sp := gp.sched.sp
  0x438163		4889942480000000	MOVQ DX, 0x80(SP)	
		print("runtime: newstack sp=", hex(sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x43816b		488b4808		MOVQ 0x8(AX), CX	
  0x43816f		48894c2478		MOVQ CX, 0x78(SP)	
			"\tmorebuf={pc:", hex(morebuf.pc), " sp:", hex(morebuf.sp), " lr:", hex(morebuf.lr), "}\n",
  0x438174		488b9424e0000000	MOVQ 0xe0(SP), DX	
  0x43817c		4889542470		MOVQ DX, 0x70(SP)	
  0x438181		488b9c24d8000000	MOVQ 0xd8(SP), BX	
  0x438189		48895c2468		MOVQ BX, 0x68(SP)	
  0x43818e		488bb42400010000	MOVQ 0x100(SP), SI	
  0x438196		4889742460		MOVQ SI, 0x60(SP)	
			"\tsched={pc:", hex(gp.sched.pc), " sp:", hex(gp.sched.sp), " lr:", hex(gp.sched.lr), " ctxt:", gp.sched.ctxt, "}\n")
  0x43819b		488b7840		MOVQ 0x40(AX), DI	
  0x43819f		48897c2458		MOVQ DI, 0x58(SP)	
  0x4381a4		4c8b4060		MOVQ 0x60(AX), R8	
  0x4381a8		4c89442450		MOVQ R8, 0x50(SP)	
  0x4381ad		4c8b4850		MOVQ 0x50(AX), R9	
  0x4381b1		4c898c24c8000000	MOVQ R9, 0xc8(SP)	
		print("runtime: newstack sp=", hex(sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x4381b9		e802bdfeff		CALL runtime.printlock(SB)	
  0x4381be		488d05e7860300		LEAQ 0x386e7(IP), AX		
  0x4381c5		48890424		MOVQ AX, 0(SP)			
  0x4381c9		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4381d2		e819c6feff		CALL runtime.printstring(SB)	
  0x4381d7		488b442428		MOVQ 0x28(SP), AX		
  0x4381dc		48890424		MOVQ AX, 0(SP)			
  0x4381e0		e8cbc4feff		CALL runtime.printhex(SB)	
  0x4381e5		488d053c720300		LEAQ 0x3723c(IP), AX		
  0x4381ec		48890424		MOVQ AX, 0(SP)			
  0x4381f0		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4381f9		e8f2c5feff		CALL runtime.printstring(SB)	
  0x4381fe		488b842488000000	MOVQ 0x88(SP), AX		
  0x438206		48890424		MOVQ AX, 0(SP)			
  0x43820a		e8a1c4feff		CALL runtime.printhex(SB)	
  0x43820f		488d05866e0300		LEAQ 0x36e86(IP), AX		
  0x438216		48890424		MOVQ AX, 0(SP)			
  0x43821a		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x438223		e8c8c5feff		CALL runtime.printstring(SB)	
  0x438228		488b442478		MOVQ 0x78(SP), AX		
  0x43822d		48890424		MOVQ AX, 0(SP)			
  0x438231		e87ac4feff		CALL runtime.printhex(SB)	
  0x438236		488d05267c0300		LEAQ 0x37c26(IP), AX		
  0x43823d		48890424		MOVQ AX, 0(SP)			
  0x438241		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x43824a		e8a1c5feff		CALL runtime.printstring(SB)	
  0x43824f		488b442470		MOVQ 0x70(SP), AX		
  0x438254		48890424		MOVQ AX, 0(SP)			
  0x438258		e853c4feff		CALL runtime.printhex(SB)	
  0x43825d		488d05ad6e0300		LEAQ 0x36ead(IP), AX		
  0x438264		48890424		MOVQ AX, 0(SP)			
  0x438268		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438271		e87ac5feff		CALL runtime.printstring(SB)	
  0x438276		488b442468		MOVQ 0x68(SP), AX		
  0x43827b		48890424		MOVQ AX, 0(SP)			
  0x43827f		e82cc4feff		CALL runtime.printhex(SB)	
  0x438284		488d057a6e0300		LEAQ 0x36e7a(IP), AX		
  0x43828b		48890424		MOVQ AX, 0(SP)			
  0x43828f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438298		e853c5feff		CALL runtime.printstring(SB)	
  0x43829d		488b442460		MOVQ 0x60(SP), AX		
  0x4382a2		48890424		MOVQ AX, 0(SP)			
  0x4382a6		e805c4feff		CALL runtime.printhex(SB)	
  0x4382ab		488d05377a0300		LEAQ 0x37a37(IP), AX		
  0x4382b2		48890424		MOVQ AX, 0(SP)			
  0x4382b6		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4382bf		e82cc5feff		CALL runtime.printstring(SB)	
  0x4382c4		488b442458		MOVQ 0x58(SP), AX		
  0x4382c9		48890424		MOVQ AX, 0(SP)			
  0x4382cd		e8dec3feff		CALL runtime.printhex(SB)	
  0x4382d2		488d05386e0300		LEAQ 0x36e38(IP), AX		
  0x4382d9		48890424		MOVQ AX, 0(SP)			
  0x4382dd		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4382e6		e805c5feff		CALL runtime.printstring(SB)	
  0x4382eb		488b842480000000	MOVQ 0x80(SP), AX		
  0x4382f3		48890424		MOVQ AX, 0(SP)			
  0x4382f7		e8b4c3feff		CALL runtime.printhex(SB)	
  0x4382fc		488d05026e0300		LEAQ 0x36e02(IP), AX		
  0x438303		48890424		MOVQ AX, 0(SP)			
  0x438307		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438310		e8dbc4feff		CALL runtime.printstring(SB)	
  0x438315		488b442450		MOVQ 0x50(SP), AX		
  0x43831a		48890424		MOVQ AX, 0(SP)			
  0x43831e		e88dc3feff		CALL runtime.printhex(SB)	
  0x438323		488d05086f0300		LEAQ 0x36f08(IP), AX		
  0x43832a		48890424		MOVQ AX, 0(SP)			
  0x43832e		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x438337		e8b4c4feff		CALL runtime.printstring(SB)	
  0x43833c		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x438344		48890424		MOVQ AX, 0(SP)			
  0x438348		e863c4feff		CALL runtime.printpointer(SB)	
  0x43834d		488d055a6d0300		LEAQ 0x36d5a(IP), AX		
  0x438354		48890424		MOVQ AX, 0(SP)			
  0x438358		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x438361		e88ac4feff		CALL runtime.printstring(SB)	
  0x438366		e8d5bbfeff		CALL runtime.printunlock(SB)	
	if sp < gp.stack.lo {
  0x43836b		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x438373		488b5c2428		MOVQ 0x28(SP), BX	
		print("runtime: newstack sp=", hex(sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x438378		e9b0fbffff		JMP 0x437f2d		
		if thisg.m.locks != 0 || thisg.m.mallocing != 0 || thisg.m.preemptoff != "" || thisg.m.p.ptr().status != _Prunning {
  0x43837d		83baf000000000		CMPL $0x0, 0xf0(DX)	
  0x438384		0f855ffbffff		JNE 0x437ee9		
  0x43838a		4883ba0001000000	CMPQ $0x0, 0x100(DX)	
  0x438392		0f8551fbffff		JNE 0x437ee9		
  0x438398		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x43839f		90			NOPL			
  0x4383a0		837a0c01		CMPL $0x1, 0xc(DX)	
  0x4383a4		0f853ffbffff		JNE 0x437ee9		
  0x4383aa		e954fbffff		JMP 0x437f03		
		morebuf := thisg.m.morebuf
  0x4383af		488b4108		MOVQ 0x8(CX), AX	
  0x4383b3		4889842410010000	MOVQ AX, 0x110(SP)	
  0x4383bb		0f104110		MOVUPS 0x10(CX), X0	
  0x4383bf		0f11842418010000	MOVUPS X0, 0x118(SP)	
  0x4383c7		0f104120		MOVUPS 0x20(CX), X0	
  0x4383cb		0f11842428010000	MOVUPS X0, 0x128(SP)	
  0x4383d3		0f104130		MOVUPS 0x30(CX), X0	
  0x4383d7		0f11842438010000	MOVUPS X0, 0x138(SP)	
		gp.syscallsp = morebuf.sp
  0x4383df		488b842410010000	MOVQ 0x110(SP), AX	
  0x4383e7		48894670		MOVQ AX, 0x70(SI)	
		gp.syscallpc = morebuf.pc
  0x4383eb		488b842418010000	MOVQ 0x118(SP), AX	
  0x4383f3		48894678		MOVQ AX, 0x78(SI)	
		f := findfunc(gp.sched.pc)
  0x4383f7		488b4640		MOVQ 0x40(SI), AX		
  0x4383fb		48890424		MOVQ AX, 0(SP)			
  0x4383ff		e8fc260000		CALL runtime.findfunc(SB)	
  0x438404		488b442410		MOVQ 0x10(SP), AX		
  0x438409		488b4c2408		MOVQ 0x8(SP), CX		
		if f.valid() {
  0x43840e		90			NOPL			
	return f._func != nil
  0x43840f		4885c9			TESTQ CX, CX		
		if f.valid() {
  0x438412		751b			JNE 0x43842f		
			" sp=", hex(gp.sched.sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x438414		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x43841c		b809000000		MOVL $0x9, AX		
  0x438421		488d0d01710300		LEAQ 0x37101(IP), CX	
  0x438428		31db			XORL BX, BX		
		if f.valid() {
  0x43842a		e935020000		JMP 0x438664		
		f := findfunc(gp.sched.pc)
  0x43842f		48898c24c0000000	MOVQ CX, 0xc0(SP)	
			pcname = funcname(f)
  0x438437		48890c24		MOVQ CX, 0(SP)			
  0x43843b		4889442408		MOVQ AX, 0x8(SP)		
  0x438440		e8fb2d0000		CALL runtime.funcname(SB)	
  0x438445		488b442418		MOVQ 0x18(SP), AX		
  0x43844a		488b4c2410		MOVQ 0x10(SP), CX		
			pcoff = gp.sched.pc - f.entry
  0x43844f		488b9424d0000000	MOVQ 0xd0(SP), DX	
  0x438457		488b5a40		MOVQ 0x40(DX), BX	
  0x43845b		488bb424c0000000	MOVQ 0xc0(SP), SI	
  0x438463		482b1e			SUBQ 0(SI), BX		
  0x438466		e9f9010000		JMP 0x438664		
		print("runtime: goroutine stack exceeds ", maxstacksize, "-byte limit\n")
  0x43846b		e850bafeff		CALL runtime.printlock(SB)		
  0x438470		488d05669d0300		LEAQ 0x39d66(IP), AX			
  0x438477		48890424		MOVQ AX, 0(SP)				
  0x43847b		48c744240821000000	MOVQ $0x21, 0x8(SP)			
  0x438484		e867c3feff		CALL runtime.printstring(SB)		
  0x438489		488b05b86b0800		MOVQ runtime.maxstacksize(SB), AX	
  0x438490		48890424		MOVQ AX, 0(SP)				
  0x438494		e8a7c0feff		CALL runtime.printuint(SB)		
  0x438499		488d05dd750300		LEAQ 0x375dd(IP), AX			
  0x4384a0		48890424		MOVQ AX, 0(SP)				
  0x4384a4		48c74424080c000000	MOVQ $0xc, 0x8(SP)			
  0x4384ad		e83ec3feff		CALL runtime.printstring(SB)		
  0x4384b2		e889bafeff		CALL runtime.printunlock(SB)		
		throw("stack overflow")
  0x4384b7		488d0550790300		LEAQ 0x37950(IP), AX	
  0x4384be		48890424		MOVQ AX, 0(SP)		
  0x4384c2		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x4384cb		e8b0affeff		CALL runtime.throw(SB)	
  0x4384d0		0f0b			UD2			
			throw("runtime: g is running but p is not")
  0x4384d2		488d05b59e0300		LEAQ 0x39eb5(IP), AX	
  0x4384d9		48890424		MOVQ AX, 0(SP)		
  0x4384dd		48c744240822000000	MOVQ $0x22, 0x8(SP)	
  0x4384e6		e895affeff		CALL runtime.throw(SB)	
  0x4384eb		0f0b			UD2			
			throw("runtime: preempt g0")
  0x4384ed		488d05f27f0300		LEAQ 0x37ff2(IP), AX	
  0x4384f4		48890424		MOVQ AX, 0(SP)		
  0x4384f8		48c744240813000000	MOVQ $0x13, 0x8(SP)	
  0x438501		e87aaffeff		CALL runtime.throw(SB)	
  0x438506		0f0b			UD2			
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->status=", hex(readgstatus(gp)), "\n ")
  0x438508		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x438509		8b8890000000		MOVL 0x90(AX), CX	
  0x43850f		894c2424		MOVL CX, 0x24(SP)	
		print("runtime: gp=", gp, ", goid=", gp.goid, ", gp->status=", hex(readgstatus(gp)), "\n ")
  0x438513		488b9098000000		MOVQ 0x98(AX), DX		
  0x43851a		4889542448		MOVQ DX, 0x48(SP)		
  0x43851f		e89cb9feff		CALL runtime.printlock(SB)	
  0x438524		488d0506760300		LEAQ 0x37606(IP), AX		
  0x43852b		48890424		MOVQ AX, 0(SP)			
  0x43852f		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x438538		e8b3c2feff		CALL runtime.printstring(SB)	
  0x43853d		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x438545		48890424		MOVQ AX, 0(SP)			
  0x438549		e862c2feff		CALL runtime.printpointer(SB)	
  0x43854e		488d05876d0300		LEAQ 0x36d87(IP), AX		
  0x438555		48890424		MOVQ AX, 0(SP)			
  0x438559		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x438562		e889c2feff		CALL runtime.printstring(SB)	
  0x438567		488b442448		MOVQ 0x48(SP), AX		
  0x43856c		48890424		MOVQ AX, 0(SP)			
  0x438570		e8cbc0feff		CALL runtime.printint(SB)	
  0x438575		488d059d760300		LEAQ 0x3769d(IP), AX		
  0x43857c		48890424		MOVQ AX, 0(SP)			
  0x438580		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x438589		e862c2feff		CALL runtime.printstring(SB)	
  0x43858e		8b442424		MOVL 0x24(SP), AX		
  0x438592		89c0			MOVL AX, AX			
  0x438594		48890424		MOVQ AX, 0(SP)			
  0x438598		e813c1feff		CALL runtime.printhex(SB)	
  0x43859d		488d05026b0300		LEAQ 0x36b02(IP), AX		
  0x4385a4		48890424		MOVQ AX, 0(SP)			
  0x4385a8		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4385b1		e83ac2feff		CALL runtime.printstring(SB)	
  0x4385b6		e885b9feff		CALL runtime.printunlock(SB)	
		print("runtime: split stack overflow: ", hex(sp), " < ", hex(gp.stack.lo), "\n")
  0x4385bb		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4385c3		488b00			MOVQ 0(AX), AX			
  0x4385c6		4889842488000000	MOVQ AX, 0x88(SP)		
  0x4385ce		e8edb8feff		CALL runtime.printlock(SB)	
  0x4385d3		488d0578980300		LEAQ 0x39878(IP), AX		
  0x4385da		48890424		MOVQ AX, 0(SP)			
  0x4385de		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x4385e7		e804c2feff		CALL runtime.printstring(SB)	
  0x4385ec		488b442428		MOVQ 0x28(SP), AX		
  0x4385f1		48890424		MOVQ AX, 0(SP)			
  0x4385f5		e8b6c0feff		CALL runtime.printhex(SB)	
  0x4385fa		488d05be6a0300		LEAQ 0x36abe(IP), AX		
  0x438601		48890424		MOVQ AX, 0(SP)			
  0x438605		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43860e		e8ddc1feff		CALL runtime.printstring(SB)	
  0x438613		488b842488000000	MOVQ 0x88(SP), AX		
  0x43861b		48890424		MOVQ AX, 0(SP)			
  0x43861f		e88cc0feff		CALL runtime.printhex(SB)	
  0x438624		e827bbfeff		CALL runtime.printnl(SB)	
  0x438629		e812b9feff		CALL runtime.printunlock(SB)	
		throw("runtime: split stack overflow")
  0x43862e		488d0548930300		LEAQ 0x39348(IP), AX	
  0x438635		48890424		MOVQ AX, 0(SP)		
  0x438639		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x438642		e839aefeff		CALL runtime.throw(SB)	
  0x438647		0f0b			UD2			
		throw("missing stack in newstack")
  0x438649		488d05fb890300		LEAQ 0x389fb(IP), AX	
  0x438650		48890424		MOVQ AX, 0(SP)		
  0x438654		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x43865d		e81eaefeff		CALL runtime.throw(SB)	
  0x438662		0f0b			UD2			
		print("runtime: newstack at ", pcname, "+", hex(pcoff),
  0x438664		4889442438		MOVQ AX, 0x38(SP)	
  0x438669		48898c24a0000000	MOVQ CX, 0xa0(SP)	
  0x438671		48895c2430		MOVQ BX, 0x30(SP)	
			" sp=", hex(gp.sched.sp), " stack=[", hex(gp.stack.lo), ", ", hex(gp.stack.hi), "]\n",
  0x438676		488b32			MOVQ 0(DX), SI		
  0x438679		4889b42488000000	MOVQ SI, 0x88(SP)	
  0x438681		488b7a08		MOVQ 0x8(DX), DI	
  0x438685		4889bc2480000000	MOVQ DI, 0x80(SP)	
			"\tmorebuf={pc:", hex(morebuf.pc), " sp:", hex(morebuf.sp), " lr:", hex(morebuf.lr), "}\n",
  0x43868d		4c8b842418010000	MOVQ 0x118(SP), R8	
  0x438695		4c89442478		MOVQ R8, 0x78(SP)	
  0x43869a		4c8b8c2410010000	MOVQ 0x110(SP), R9	
  0x4386a2		4c894c2470		MOVQ R9, 0x70(SP)	
  0x4386a7		4c8b942438010000	MOVQ 0x138(SP), R10	
  0x4386af		4c89542468		MOVQ R10, 0x68(SP)	
			"\tsched={pc:", hex(gp.sched.pc), " sp:", hex(gp.sched.sp), " lr:", hex(gp.sched.lr), " ctxt:", gp.sched.ctxt, "}\n")
  0x4386b4		4c8b5a40		MOVQ 0x40(DX), R11	
  0x4386b8		4c895c2460		MOVQ R11, 0x60(SP)	
  0x4386bd		4c8b6238		MOVQ 0x38(DX), R12	
  0x4386c1		4c89642458		MOVQ R12, 0x58(SP)	
  0x4386c6		4c8b6a60		MOVQ 0x60(DX), R13	
  0x4386ca		4c896c2450		MOVQ R13, 0x50(SP)	
  0x4386cf		4c8b7250		MOVQ 0x50(DX), R14	
  0x4386d3		4c89b424c8000000	MOVQ R14, 0xc8(SP)	
		print("runtime: newstack at ", pcname, "+", hex(pcoff),
  0x4386db		e8e0b7feff		CALL runtime.printlock(SB)	
  0x4386e0		488d05b0810300		LEAQ 0x381b0(IP), AX		
  0x4386e7		48890424		MOVQ AX, 0(SP)			
  0x4386eb		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4386f4		e8f7c0feff		CALL runtime.printstring(SB)	
  0x4386f9		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x438701		48890424		MOVQ AX, 0(SP)			
  0x438705		488b442438		MOVQ 0x38(SP), AX		
  0x43870a		4889442408		MOVQ AX, 0x8(SP)		
  0x43870f		e8dcc0feff		CALL runtime.printstring(SB)	
  0x438714		488d0568690300		LEAQ 0x36968(IP), AX		
  0x43871b		48890424		MOVQ AX, 0(SP)			
  0x43871f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x438728		e8c3c0feff		CALL runtime.printstring(SB)	
  0x43872d		488b442430		MOVQ 0x30(SP), AX		
  0x438732		48890424		MOVQ AX, 0(SP)			
  0x438736		e875bffeff		CALL runtime.printhex(SB)	
  0x43873b		488d05d3690300		LEAQ 0x369d3(IP), AX		
  0x438742		48890424		MOVQ AX, 0(SP)			
  0x438746		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43874f		e89cc0feff		CALL runtime.printstring(SB)	
  0x438754		488b442458		MOVQ 0x58(SP), AX		
  0x438759		48890424		MOVQ AX, 0(SP)			
  0x43875d		e84ebffeff		CALL runtime.printhex(SB)	
  0x438762		488d05bf6c0300		LEAQ 0x36cbf(IP), AX		
  0x438769		48890424		MOVQ AX, 0(SP)			
  0x43876d		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x438776		e875c0feff		CALL runtime.printstring(SB)	
  0x43877b		488b842488000000	MOVQ 0x88(SP), AX		
  0x438783		48890424		MOVQ AX, 0(SP)			
  0x438787		e824bffeff		CALL runtime.printhex(SB)	
  0x43878c		488d0509690300		LEAQ 0x36909(IP), AX		
  0x438793		48890424		MOVQ AX, 0(SP)			
  0x438797		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4387a0		e84bc0feff		CALL runtime.printstring(SB)	
  0x4387a5		488b842480000000	MOVQ 0x80(SP), AX		
  0x4387ad		48890424		MOVQ AX, 0(SP)			
  0x4387b1		e8fabefeff		CALL runtime.printhex(SB)	
  0x4387b6		488d05a6760300		LEAQ 0x376a6(IP), AX		
  0x4387bd		48890424		MOVQ AX, 0(SP)			
  0x4387c1		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x4387ca		e821c0feff		CALL runtime.printstring(SB)	
  0x4387cf		488b442478		MOVQ 0x78(SP), AX		
  0x4387d4		48890424		MOVQ AX, 0(SP)			
  0x4387d8		e8d3befeff		CALL runtime.printhex(SB)	
  0x4387dd		488d052d690300		LEAQ 0x3692d(IP), AX		
  0x4387e4		48890424		MOVQ AX, 0(SP)			
  0x4387e8		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4387f1		e8fabffeff		CALL runtime.printstring(SB)	
  0x4387f6		488b442470		MOVQ 0x70(SP), AX		
  0x4387fb		48890424		MOVQ AX, 0(SP)			
  0x4387ff		e8acbefeff		CALL runtime.printhex(SB)	
  0x438804		488d05fa680300		LEAQ 0x368fa(IP), AX		
  0x43880b		48890424		MOVQ AX, 0(SP)			
  0x43880f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438818		e8d3bffeff		CALL runtime.printstring(SB)	
  0x43881d		488b442468		MOVQ 0x68(SP), AX		
  0x438822		48890424		MOVQ AX, 0(SP)			
  0x438826		e885befeff		CALL runtime.printhex(SB)	
  0x43882b		488d05b7740300		LEAQ 0x374b7(IP), AX		
  0x438832		48890424		MOVQ AX, 0(SP)			
  0x438836		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x43883f		e8acbffeff		CALL runtime.printstring(SB)	
  0x438844		488b442460		MOVQ 0x60(SP), AX		
  0x438849		48890424		MOVQ AX, 0(SP)			
  0x43884d		e85ebefeff		CALL runtime.printhex(SB)	
  0x438852		488d05b8680300		LEAQ 0x368b8(IP), AX		
  0x438859		48890424		MOVQ AX, 0(SP)			
  0x43885d		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x438866		e885bffeff		CALL runtime.printstring(SB)	
  0x43886b		488b442458		MOVQ 0x58(SP), AX		
  0x438870		48890424		MOVQ AX, 0(SP)			
  0x438874		e837befeff		CALL runtime.printhex(SB)	
  0x438879		488d0585680300		LEAQ 0x36885(IP), AX		
  0x438880		48890424		MOVQ AX, 0(SP)			
  0x438884		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43888d		e85ebffeff		CALL runtime.printstring(SB)	
  0x438892		488b442450		MOVQ 0x50(SP), AX		
  0x438897		48890424		MOVQ AX, 0(SP)			
  0x43889b		e810befeff		CALL runtime.printhex(SB)	
  0x4388a0		488d058b690300		LEAQ 0x3698b(IP), AX		
  0x4388a7		48890424		MOVQ AX, 0(SP)			
  0x4388ab		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x4388b4		e837bffeff		CALL runtime.printstring(SB)	
  0x4388b9		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x4388c1		48890424		MOVQ AX, 0(SP)			
  0x4388c5		e8e6befeff		CALL runtime.printpointer(SB)	
  0x4388ca		488d05dd670300		LEAQ 0x367dd(IP), AX		
  0x4388d1		48890424		MOVQ AX, 0(SP)			
  0x4388d5		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4388de		e80dbffeff		CALL runtime.printstring(SB)	
  0x4388e3		e858b6feff		CALL runtime.printunlock(SB)	
		thisg.m.traceback = 2 // Include runtime frames
  0x4388e8		488b842498000000	MOVQ 0x98(SP), AX	
  0x4388f0		488b4030		MOVQ 0x30(AX), AX	
  0x4388f4		c6802901000002		MOVB $0x2, 0x129(AX)	
		traceback(morebuf.pc, morebuf.sp, morebuf.lr, gp)
  0x4388fb		488b842418010000	MOVQ 0x118(SP), AX		
  0x438903		48890424		MOVQ AX, 0(SP)			
  0x438907		488b842410010000	MOVQ 0x110(SP), AX		
  0x43890f		4889442408		MOVQ AX, 0x8(SP)		
  0x438914		488b842438010000	MOVQ 0x138(SP), AX		
  0x43891c		4889442410		MOVQ AX, 0x10(SP)		
  0x438921		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x438929		4889442418		MOVQ AX, 0x18(SP)		
  0x43892e		e87d720000		CALL runtime.traceback(SB)	
		throw("runtime: stack split at bad time")
  0x438933		488d0557960300		LEAQ 0x39657(IP), AX	
  0x43893a		48890424		MOVQ AX, 0(SP)		
  0x43893e		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x438947		e834abfeff		CALL runtime.throw(SB)	
  0x43894c		0f0b			UD2			
	if thisg.m.morebuf.g.ptr().stackguard0 == stackFork {
  0x43894e		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x438956		48895c2440		MOVQ BX, 0x40(SP)	
		print("runtime: newstack called from g=", hex(thisg.m.morebuf.g), "\n"+"\tm=", thisg.m, " m->curg=", thisg.m.curg, " m->g0=", thisg.m.g0, " m->gsignal=", thisg.m.gsignal, "\n")
  0x43895b		488b01			MOVQ 0(CX), AX			
  0x43895e		48898424b0000000	MOVQ AX, 0xb0(SP)		
  0x438966		488b5150		MOVQ 0x50(CX), DX		
  0x43896a		48899424a8000000	MOVQ DX, 0xa8(SP)		
  0x438972		e849b5feff		CALL runtime.printlock(SB)	
  0x438977		488d05f3950300		LEAQ 0x395f3(IP), AX		
  0x43897e		48890424		MOVQ AX, 0(SP)			
  0x438982		48c744240820000000	MOVQ $0x20, 0x8(SP)		
  0x43898b		e860befeff		CALL runtime.printstring(SB)	
  0x438990		488b442440		MOVQ 0x40(SP), AX		
  0x438995		48890424		MOVQ AX, 0(SP)			
  0x438999		e812bdfeff		CALL runtime.printhex(SB)	
  0x43899e		488d0590670300		LEAQ 0x36790(IP), AX		
  0x4389a5		48890424		MOVQ AX, 0(SP)			
  0x4389a9		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x4389b2		e839befeff		CALL runtime.printstring(SB)	
  0x4389b7		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x4389bf		48890424		MOVQ AX, 0(SP)			
  0x4389c3		e8e8bdfeff		CALL runtime.printpointer(SB)	
  0x4389c8		488d05006b0300		LEAQ 0x36b00(IP), AX		
  0x4389cf		48890424		MOVQ AX, 0(SP)			
  0x4389d3		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x4389dc		e80fbefeff		CALL runtime.printstring(SB)	
  0x4389e1		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x4389e9		48890424		MOVQ AX, 0(SP)			
  0x4389ed		e8bebdfeff		CALL runtime.printpointer(SB)	
  0x4389f2		488d05ce680300		LEAQ 0x368ce(IP), AX		
  0x4389f9		48890424		MOVQ AX, 0(SP)			
  0x4389fd		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x438a06		e8e5bdfeff		CALL runtime.printstring(SB)	
  0x438a0b		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x438a13		48890424		MOVQ AX, 0(SP)			
  0x438a17		e894bdfeff		CALL runtime.printpointer(SB)	
  0x438a1c		488d058e6f0300		LEAQ 0x36f8e(IP), AX		
  0x438a23		48890424		MOVQ AX, 0(SP)			
  0x438a27		48c74424080c000000	MOVQ $0xc, 0x8(SP)		
  0x438a30		e8bbbdfeff		CALL runtime.printstring(SB)	
  0x438a35		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x438a3d		48890424		MOVQ AX, 0(SP)			
  0x438a41		e86abdfeff		CALL runtime.printpointer(SB)	
  0x438a46		e805b7feff		CALL runtime.printnl(SB)	
  0x438a4b		e8f0b4feff		CALL runtime.printunlock(SB)	
		morebuf := thisg.m.morebuf
  0x438a50		488b842498000000	MOVQ 0x98(SP), AX	
  0x438a58		488b4830		MOVQ 0x30(AX), CX	
  0x438a5c		8400			TESTB AL, 0(AX)		
  0x438a5e		488b4108		MOVQ 0x8(CX), AX	
  0x438a62		4889842448010000	MOVQ AX, 0x148(SP)	
  0x438a6a		0f104110		MOVUPS 0x10(CX), X0	
  0x438a6e		0f11842450010000	MOVUPS X0, 0x150(SP)	
  0x438a76		0f104120		MOVUPS 0x20(CX), X0	
  0x438a7a		0f11842460010000	MOVUPS X0, 0x160(SP)	
  0x438a82		0f104130		MOVUPS 0x30(CX), X0	
  0x438a86		0f11842470010000	MOVUPS X0, 0x170(SP)	
		traceback(morebuf.pc, morebuf.sp, morebuf.lr, morebuf.g.ptr())
  0x438a8e		488b842450010000	MOVQ 0x150(SP), AX		
  0x438a96		488b8c2458010000	MOVQ 0x158(SP), CX		
  0x438a9e		90			NOPL				
  0x438a9f		48890424		MOVQ AX, 0(SP)			
  0x438aa3		488b842448010000	MOVQ 0x148(SP), AX		
  0x438aab		4889442408		MOVQ AX, 0x8(SP)		
  0x438ab0		488b842470010000	MOVQ 0x170(SP), AX		
  0x438ab8		4889442410		MOVQ AX, 0x10(SP)		
  0x438abd		48894c2418		MOVQ CX, 0x18(SP)		
  0x438ac2		e8e9700000		CALL runtime.traceback(SB)	
		throw("runtime: wrong goroutine in newstack")
  0x438ac7		488d05159b0300		LEAQ 0x39b15(IP), AX	
  0x438ace		48890424		MOVQ AX, 0(SP)		
  0x438ad2		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x438adb		e8a0a9feff		CALL runtime.throw(SB)	
  0x438ae0		0f0b			UD2			
		throw("stack growth after fork")
  0x438ae2		488d05bd820300		LEAQ 0x382bd(IP), AX	
  0x438ae9		48890424		MOVQ AX, 0(SP)		
  0x438aed		48c744240817000000	MOVQ $0x17, 0x8(SP)	
  0x438af6		e885a9feff		CALL runtime.throw(SB)	
  0x438afb		0f0b			UD2			
func newstack() {
  0x438afd		e87eed0000		CALL runtime.morestack_noctxt(SB)	
  0x438b02		e9d9f2ffff		JMP runtime.newstack(SB)		

TEXT runtime.shrinkstack(SB) /usr/local/go/src/runtime/stack.go
func shrinkstack(gp *g) {
  0x438b10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438b19		483b6110		CMPQ 0x10(CX), SP	
  0x438b1d		0f865c010000		JBE 0x438c7f		
  0x438b23		4883ec20		SUBQ $0x20, SP		
  0x438b27		48896c2418		MOVQ BP, 0x18(SP)	
  0x438b2c		488d6c2418		LEAQ 0x18(SP), BP	
	gstatus := readgstatus(gp)
  0x438b31		90			NOPL			
  0x438b32		488b442428		MOVQ 0x28(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x438b37		8b8890000000		MOVL 0x90(AX), CX	
	if gstatus&^_Gscan == _Gdead {
  0x438b3d		89ca			MOVL CX, DX		
  0x438b3f		0fbaf10c		BTRL $0xc, CX		
  0x438b43		83f906			CMPL $0x6, CX		
  0x438b46		7531			JNE 0x438b79		
		if gp.stack.lo != 0 {
  0x438b48		488b08			MOVQ 0(AX), CX		
  0x438b4b		4885c9			TESTQ CX, CX		
  0x438b4e		750a			JNE 0x438b5a		
		return
  0x438b50		488b6c2418		MOVQ 0x18(SP), BP	
  0x438b55		4883c420		ADDQ $0x20, SP		
  0x438b59		c3			RET			
			stackfree(gp.stack)
  0x438b5a		488b5008		MOVQ 0x8(AX), DX		
  0x438b5e		48890c24		MOVQ CX, 0(SP)			
  0x438b62		4889542408		MOVQ DX, 0x8(SP)		
  0x438b67		e854e2ffff		CALL runtime.stackfree(SB)	
			gp.stack.hi = 0
  0x438b6c		0f57c0			XORPS X0, X0		
  0x438b6f		488b442428		MOVQ 0x28(SP), AX	
  0x438b74		0f1100			MOVUPS X0, 0(AX)	
  0x438b77		ebd7			JMP 0x438b50		
	if gp.stack.lo == 0 {
  0x438b79		48833800		CMPQ $0x0, 0(AX)	
  0x438b7d		0f84e1000000		JE 0x438c64		
	if gstatus&_Gscan == 0 {
  0x438b83		0fbae20c		BTL $0xc, DX		
  0x438b87		0f83bc000000		JAE 0x438c49		
	if debug.gcshrinkstackoff > 0 {
  0x438b8d		833d64430a0000		CMPL $0x0, runtime.debug+24(SB)	
  0x438b94		0f8fa5000000		JG 0x438c3f			
	f := findfunc(gp.startpc)
  0x438b9a		488b8828010000		MOVQ 0x128(AX), CX		
  0x438ba1		48890c24		MOVQ CX, 0(SP)			
  0x438ba5		e8561f0000		CALL runtime.findfunc(SB)	
  0x438baa		488b442408		MOVQ 0x8(SP), AX		
	if f.valid() && f.funcID == funcID_gcBgMarkWorker {
  0x438baf		90			NOPL			
	return f._func != nil
  0x438bb0		4885c0			TESTQ AX, AX		
	if f.valid() && f.funcID == funcID_gcBgMarkWorker {
  0x438bb3		7406			JE 0x438bbb		
  0x438bb5		8078240b		CMPB $0xb, 0x24(AX)	
  0x438bb9		747a			JE 0x438c35		
	oldsize := gp.stack.hi - gp.stack.lo
  0x438bbb		488b442428		MOVQ 0x28(SP), AX	
  0x438bc0		488b4808		MOVQ 0x8(AX), CX	
  0x438bc4		488b10			MOVQ 0(AX), DX		
  0x438bc7		4889cb			MOVQ CX, BX		
  0x438bca		4829d1			SUBQ DX, CX		
	newsize := oldsize / 2
  0x438bcd		4889ca			MOVQ CX, DX		
  0x438bd0		48d1e9			SHRQ $0x1, CX		
	if newsize < _FixedStack {
  0x438bd3		4881f900080000		CMPQ $0x800, CX		
  0x438bda		724f			JB 0x438c2b		
	if used := gp.stack.hi - gp.sched.sp + _StackLimit; used >= avail/4 {
  0x438bdc		488b7038		MOVQ 0x38(AX), SI	
  0x438be0		4829f3			SUBQ SI, BX		
  0x438be3		4881c3f0020000		ADDQ $0x2f0, BX		
  0x438bea		48c1ea02		SHRQ $0x2, DX		
  0x438bee		4839d3			CMPQ DX, BX		
  0x438bf1		732e			JAE 0x438c21		
	if gp.syscallsp != 0 {
  0x438bf3		4883787000		CMPQ $0x0, 0x70(AX)	
  0x438bf8		740a			JE 0x438c04		
		return
  0x438bfa		488b6c2418		MOVQ 0x18(SP), BP	
  0x438bff		4883c420		ADDQ $0x20, SP		
  0x438c03		c3			RET			
	copystack(gp, newsize, false)
  0x438c04		48890424		MOVQ AX, 0(SP)			
  0x438c08		48894c2408		MOVQ CX, 0x8(SP)		
  0x438c0d		c644241000		MOVB $0x0, 0x10(SP)		
  0x438c12		e869eeffff		CALL runtime.copystack(SB)	
}
  0x438c17		488b6c2418		MOVQ 0x18(SP), BP	
  0x438c1c		4883c420		ADDQ $0x20, SP		
  0x438c20		c3			RET			
		return
  0x438c21		488b6c2418		MOVQ 0x18(SP), BP	
  0x438c26		4883c420		ADDQ $0x20, SP		
  0x438c2a		c3			RET			
		return
  0x438c2b		488b6c2418		MOVQ 0x18(SP), BP	
  0x438c30		4883c420		ADDQ $0x20, SP		
  0x438c34		c3			RET			
		return
  0x438c35		488b6c2418		MOVQ 0x18(SP), BP	
  0x438c3a		4883c420		ADDQ $0x20, SP		
  0x438c3e		c3			RET			
		return
  0x438c3f		488b6c2418		MOVQ 0x18(SP), BP	
  0x438c44		4883c420		ADDQ $0x20, SP		
  0x438c48		c3			RET			
		throw("bad status in shrinkstack")
  0x438c49		488d0597830300		LEAQ 0x38397(IP), AX	
  0x438c50		48890424		MOVQ AX, 0(SP)		
  0x438c54		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x438c5d		e81ea8feff		CALL runtime.throw(SB)	
  0x438c62		0f0b			UD2			
		throw("missing stack in shrinkstack")
  0x438c64		488d05bb8a0300		LEAQ 0x38abb(IP), AX	
  0x438c6b		48890424		MOVQ AX, 0(SP)		
  0x438c6f		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x438c78		e803a8feff		CALL runtime.throw(SB)	
  0x438c7d		0f0b			UD2			
func shrinkstack(gp *g) {
  0x438c7f		e8fceb0000		CALL runtime.morestack_noctxt(SB)	
  0x438c84		e987feffff		JMP runtime.shrinkstack(SB)		

TEXT runtime.freeStackSpans(SB) /usr/local/go/src/runtime/stack.go
func freeStackSpans() {
  0x438c90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x438c99		483b6110		CMPQ 0x10(CX), SP	
  0x438c9d		0f8681010000		JBE 0x438e24		
  0x438ca3		4883ec60		SUBQ $0x60, SP		
  0x438ca7		48896c2458		MOVQ BP, 0x58(SP)	
  0x438cac		488d6c2458		LEAQ 0x58(SP), BP	
	lock(&stackpoolmu)
  0x438cb1		488d0520410a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x438cb8		48890424		MOVQ AX, 0(SP)				
  0x438cbc		e81ffafcff		CALL runtime.lock(SB)			
  0x438cc1		31c0			XORL AX, AX				
	for order := range stackpool {
  0x438cc3		eb75			JMP 0x438d3a		
		for s := list.first; s != nil; {
  0x438cc5		4889f0			MOVQ SI, AX		
  0x438cc8		4885c0			TESTQ AX, AX		
  0x438ccb		7469			JE 0x438d36		
			next := s.next
  0x438ccd		488b30			MOVQ 0(AX), SI		
			if s.allocCount == 0 {
  0x438cd0		6683786000		CMPW $0x0, 0x60(AX)	
  0x438cd5		75ee			JNE 0x438cc5		
		for s := list.first; s != nil; {
  0x438cd7		4889442428		MOVQ AX, 0x28(SP)	
			next := s.next
  0x438cdc		4889742438		MOVQ SI, 0x38(SP)	
				list.remove(s)
  0x438ce1		48891c24		MOVQ BX, 0(SP)				
  0x438ce5		4889442408		MOVQ AX, 0x8(SP)			
  0x438cea		e8c15bfeff		CALL runtime.(*mSpanList).remove(SB)	
				s.manualFreeList = 0
  0x438cef		488b442428		MOVQ 0x28(SP), AX	
  0x438cf4		48c7402800000000	MOVQ $0x0, 0x28(AX)	
				osStackFree(s)
  0x438cfc		90			NOPL			
				mheap_.freeManual(s, &memstats.stacks_inuse)
  0x438cfd		488d0d3cd90800		LEAQ runtime.mheap_(SB), CX		
  0x438d04		48890c24		MOVQ CX, 0(SP)				
  0x438d08		4889442408		MOVQ AX, 0x8(SP)			
  0x438d0d		488d05ac4f0a00		LEAQ runtime.memstats+96(SB), AX	
  0x438d14		4889442410		MOVQ AX, 0x10(SP)			
  0x438d19		e87252feff		CALL runtime.(*mheap).freeManual(SB)	
	for order := range stackpool {
  0x438d1e		488b4c2418		MOVQ 0x18(SP), CX		
  0x438d23		488d15968e0800		LEAQ runtime.stackpool(SB), DX	
				list.remove(s)
  0x438d2a		488b5c2448		MOVQ 0x48(SP), BX	
		for s := list.first; s != nil; {
  0x438d2f		488b742438		MOVQ 0x38(SP), SI	
				mheap_.freeManual(s, &memstats.stacks_inuse)
  0x438d34		eb8f			JMP 0x438cc5		
	for order := range stackpool {
  0x438d36		488d4101		LEAQ 0x1(CX), AX	
  0x438d3a		4883f804		CMPQ $0x4, AX		
  0x438d3e		7d25			JGE 0x438d65		
  0x438d40		4889442418		MOVQ AX, 0x18(SP)	
		list := &stackpool[order]
  0x438d45		4889c1			MOVQ AX, CX			
  0x438d48		48c1e004		SHLQ $0x4, AX			
  0x438d4c		488d156d8e0800		LEAQ runtime.stackpool(SB), DX	
  0x438d53		488d1c02		LEAQ 0(DX)(AX*1), BX		
  0x438d57		48895c2448		MOVQ BX, 0x48(SP)		
		for s := list.first; s != nil; {
  0x438d5c		488b0402		MOVQ 0(DX)(AX*1), AX	
  0x438d60		e963ffffff		JMP 0x438cc8		
	unlock(&stackpoolmu)
  0x438d65		488d056c400a00		LEAQ runtime.stackpoolmu(SB), AX	
  0x438d6c		48890424		MOVQ AX, 0(SP)				
  0x438d70		e81bfbfcff		CALL runtime.unlock(SB)			
	lock(&stackLarge.lock)
  0x438d75		488d05a4930800		LEAQ runtime.stackLarge(SB), AX	
  0x438d7c		48890424		MOVQ AX, 0(SP)			
  0x438d80		e85bf9fcff		CALL runtime.lock(SB)		
  0x438d85		31c0			XORL AX, AX			
	for i := range stackLarge.free {
  0x438d87		eb5a			JMP 0x438de3		
		for s := stackLarge.free[i].first; s != nil; {
  0x438d89		48895c2430		MOVQ BX, 0x30(SP)	
			next := s.next
  0x438d8e		488b0b			MOVQ 0(BX), CX		
  0x438d91		48894c2440		MOVQ CX, 0x40(SP)	
			stackLarge.free[i].remove(s)
  0x438d96		48890424		MOVQ AX, 0(SP)				
  0x438d9a		48895c2408		MOVQ BX, 0x8(SP)			
  0x438d9f		e80c5bfeff		CALL runtime.(*mSpanList).remove(SB)	
			osStackFree(s)
  0x438da4		90			NOPL			
			mheap_.freeManual(s, &memstats.stacks_inuse)
  0x438da5		488d0594d80800		LEAQ runtime.mheap_(SB), AX		
  0x438dac		48890424		MOVQ AX, 0(SP)				
  0x438db0		488b4c2430		MOVQ 0x30(SP), CX			
  0x438db5		48894c2408		MOVQ CX, 0x8(SP)			
  0x438dba		488d0dff4e0a00		LEAQ runtime.memstats+96(SB), CX	
  0x438dc1		48894c2410		MOVQ CX, 0x10(SP)			
  0x438dc6		e8c551feff		CALL runtime.(*mheap).freeManual(SB)	
			stackLarge.free[i].remove(s)
  0x438dcb		488b442450		MOVQ 0x50(SP), AX	
	for i := range stackLarge.free {
  0x438dd0		488b4c2420		MOVQ 0x20(SP), CX	
		for s := stackLarge.free[i].first; s != nil; {
  0x438dd5		488b5c2440		MOVQ 0x40(SP), BX	
  0x438dda		4885db			TESTQ BX, BX		
  0x438ddd		75aa			JNE 0x438d89		
	for i := range stackLarge.free {
  0x438ddf		488d4101		LEAQ 0x1(CX), AX	
  0x438de3		4883f823		CMPQ $0x23, AX		
  0x438de7		7d21			JGE 0x438e0a		
  0x438de9		4889442420		MOVQ AX, 0x20(SP)	
		for s := stackLarge.free[i].first; s != nil; {
  0x438dee		4889c1			MOVQ AX, CX				
  0x438df1		48c1e004		SHLQ $0x4, AX				
  0x438df5		488d152c930800		LEAQ runtime.stackLarge+8(SB), DX	
  0x438dfc		488b1c02		MOVQ 0(DX)(AX*1), BX			
  0x438e00		4801d0			ADDQ DX, AX				
  0x438e03		4889442450		MOVQ AX, 0x50(SP)			
  0x438e08		ebd0			JMP 0x438dda				
	unlock(&stackLarge.lock)
  0x438e0a		488d050f930800		LEAQ runtime.stackLarge(SB), AX	
  0x438e11		48890424		MOVQ AX, 0(SP)			
  0x438e15		e876fafcff		CALL runtime.unlock(SB)		
}
  0x438e1a		488b6c2458		MOVQ 0x58(SP), BP	
  0x438e1f		4883c460		ADDQ $0x60, SP		
  0x438e23		c3			RET			
func freeStackSpans() {
  0x438e24		e857ea0000		CALL runtime.morestack_noctxt(SB)	
  0x438e29		e962feffff		JMP runtime.freeStackSpans(SB)		

TEXT runtime.getStackMap(SB) /usr/local/go/src/runtime/stack.go
func getStackMap(frame *stkframe, cache *pcvalueCache, debug bool) (locals, args bitvector, objs []stackObjectRecord) {
  0x438e30		64488b0c25f8ffffff		MOVQ FS:0xfffffff8, CX	
  0x438e39		488d4424b8			LEAQ -0x48(SP), AX	
  0x438e3e		483b4110			CMPQ 0x10(CX), AX	
  0x438e42		0f867e080000			JBE 0x4396c6		
  0x438e48		4881ecc8000000			SUBQ $0xc8, SP		
  0x438e4f		4889ac24c0000000		MOVQ BP, 0xc0(SP)	
  0x438e57		488dac24c0000000		LEAQ 0xc0(SP), BP	
  0x438e5f		48c784240801000000000000	MOVQ $0x0, 0x108(SP)	
  0x438e6b		0f57c0				XORPS X0, X0		
  0x438e6e		0f11842410010000		MOVUPS X0, 0x110(SP)	
	targetpc := frame.continpc
  0x438e76		488b8424d0000000	MOVQ 0xd0(SP), AX	
  0x438e7e		488b4818		MOVQ 0x18(AX), CX	
	if targetpc == 0 {
  0x438e82		4885c9			TESTQ CX, CX		
  0x438e85		0f845b030000		JE 0x4391e6		
	f := frame.fn
  0x438e8b		488b10			MOVQ 0(AX), DX		
  0x438e8e		48899424b8000000	MOVQ DX, 0xb8(SP)	
  0x438e96		488b5808		MOVQ 0x8(AX), BX	
  0x438e9a		48899c24b0000000	MOVQ BX, 0xb0(SP)	
	if targetpc != f.entry {
  0x438ea2		48390a			CMPQ CX, 0(DX)		
  0x438ea5		0f85e4020000		JNE 0x43918f		
  0x438eab		beffffffff		MOVL $-0x1, SI		
				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n")
  0x438eb0		48894c2448		MOVQ CX, 0x48(SP)	
	if pcdata == -1 {
  0x438eb5		83feff			CMPL $-0x1, SI		
			if pcdata < 0 || pcdata >= stackmap.n {
  0x438eb8		bf00000000		MOVL $0x0, DI		
  0x438ebd		0f44f7			CMOVE DI, SI		
  0x438ec0		8974243c		MOVL SI, 0x3c(SP)	
	size := frame.varp - frame.sp
  0x438ec4		4c8b4038		MOVQ 0x38(AX), R8	
  0x438ec8		4c2b4028		SUBQ 0x28(AX), R8	
	if size > minsize {
  0x438ecc		4d85c0			TESTQ R8, R8		
	if pcdata == -1 {
  0x438ecf		0f86b1020000		JBE 0x439186		
	size := frame.varp - frame.sp
  0x438ed5		4c89442450		MOVQ R8, 0x50(SP)	
		if f.funcID != funcID_debugCallV1 {
  0x438eda		807a2411		CMPB $0x11, 0x24(DX)	
  0x438ede		0f84e9010000		JE 0x4390cd		
			stkmap = (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
  0x438ee4		48891424		MOVQ DX, 0(SP)			
  0x438ee8		48895c2408		MOVQ BX, 0x8(SP)		
  0x438eed		c644241001		MOVB $0x1, 0x10(SP)		
  0x438ef2		e819290000		CALL runtime.funcdata(SB)	
  0x438ef7		488b442418		MOVQ 0x18(SP), AX		
			if stackid < 0 || stackid >= stkmap.n {
  0x438efc		8b4c243c		MOVL 0x3c(SP), CX	
		if stkmap == nil || stkmap.n <= 0 {
  0x438f00		4885c0			TESTQ AX, AX		
  0x438f03		0f8472060000		JE 0x43957b		
  0x438f09		8b10			MOVL 0(AX), DX		
  0x438f0b		85d2			TESTL DX, DX		
  0x438f0d		0f8e68060000		JLE 0x43957b		
		if stkmap.nbit > 0 {
  0x438f13		8b5804			MOVL 0x4(AX), BX	
  0x438f16		85db			TESTL BX, BX		
  0x438f18		0f8ea6010000		JLE 0x4390c4		
		if stkmap == nil || stkmap.n <= 0 {
  0x438f1e		4889842480000000	MOVQ AX, 0x80(SP)	
			if stackid < 0 || stackid >= stkmap.n {
  0x438f26		894c2438		MOVL CX, 0x38(SP)	
  0x438f2a		85c9			TESTL CX, CX		
  0x438f2c		0f8c1b050000		JL 0x43944d		
  0x438f32		39d1			CMPL DX, CX		
  0x438f34		0f8d13050000		JGE 0x43944d		
			locals = stackmapdata(stkmap, stackid)
  0x438f3a		90			NOPL			
	return bitvector{stkmap.nbit, addb(&stkmap.bytedata[0], uintptr(n*((stkmap.nbit+7)>>3)))}
  0x438f3b		90			NOPL			
  0x438f3c		8d5307			LEAL 0x7(BX), DX	
  0x438f3f		c1fa03			SARL $0x3, DX		
  0x438f42		0fafca			IMULL DX, CX		
  0x438f45		4863c9			MOVSXD CX, CX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x438f48		488d0408		LEAQ 0(AX)(CX*1), AX	
  0x438f4c		488d4008		LEAQ 0x8(AX), AX	
	return
  0x438f50		48898424a8000000	MOVQ AX, 0xa8(SP)	
  0x438f58		895c2444		MOVL BX, 0x44(SP)	
	if frame.arglen > 0 {
  0x438f5c		488b8c24d0000000	MOVQ 0xd0(SP), CX	
  0x438f64		488b5148		MOVQ 0x48(CX), DX	
  0x438f68		4885d2			TESTQ DX, DX		
  0x438f6b		0f864a010000		JBE 0x4390bb		
		if frame.argmap != nil {
  0x438f71		488b7150		MOVQ 0x50(CX), SI	
  0x438f75		4885f6			TESTQ SI, SI		
  0x438f78		0f84af000000		JE 0x43902d		
			args = *frame.argmap
  0x438f7e		8b0e			MOVL 0(SI), CX		
			n := int32(frame.arglen / sys.PtrSize)
  0x438f80		48c1ea03		SHRQ $0x3, DX		
			if n < args.n {
  0x438f84		39ca			CMPL CX, DX		
	return
  0x438f86		0f4cca			CMOVL DX, CX		
			args = *frame.argmap
  0x438f89		488b5608		MOVQ 0x8(SI), DX	
	return
  0x438f8d		894c2440		MOVL CX, 0x40(SP)	
  0x438f91		48899424a0000000	MOVQ DX, 0xa0(SP)	
	p := funcdata(f, _FUNCDATA_StackObjects)
  0x438f99		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x438fa1		48890424		MOVQ AX, 0(SP)			
  0x438fa5		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x438fad		4889442408		MOVQ AX, 0x8(SP)		
  0x438fb2		c644241004		MOVB $0x4, 0x10(SP)		
  0x438fb7		e854280000		CALL runtime.funcdata(SB)	
  0x438fbc		488b442418		MOVQ 0x18(SP), AX		
	if p != nil {
  0x438fc1		4885c0			TESTQ AX, AX		
  0x438fc4		7421			JE 0x438fe7		
		n := *(*uintptr)(p)
  0x438fc6		488b08			MOVQ 0(AX), CX		
		p = add(p, sys.PtrSize)
  0x438fc9		90			NOPL			
		*(*slice)(unsafe.Pointer(&objs)) = slice{array: noescape(p), len: int(n), cap: int(n)}
  0x438fca		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x438fcb		4883c008		ADDQ $0x8, AX		
		*(*slice)(unsafe.Pointer(&objs)) = slice{array: noescape(p), len: int(n), cap: int(n)}
  0x438fcf		4889842408010000	MOVQ AX, 0x108(SP)	
  0x438fd7		48898c2410010000	MOVQ CX, 0x110(SP)	
  0x438fdf		48898c2418010000	MOVQ CX, 0x118(SP)	
	return
  0x438fe7		8b442444		MOVL 0x44(SP), AX	
  0x438feb		898424e8000000		MOVL AX, 0xe8(SP)	
  0x438ff2		488b8424a8000000	MOVQ 0xa8(SP), AX	
  0x438ffa		48898424f0000000	MOVQ AX, 0xf0(SP)	
  0x439002		8b442440		MOVL 0x40(SP), AX	
  0x439006		898424f8000000		MOVL AX, 0xf8(SP)	
  0x43900d		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x439015		4889842400010000	MOVQ AX, 0x100(SP)	
  0x43901d		488bac24c0000000	MOVQ 0xc0(SP), BP	
  0x439025		4881c4c8000000		ADDQ $0xc8, SP		
  0x43902c		c3			RET			
			stackmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x43902d		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x439035		48890424		MOVQ AX, 0(SP)			
  0x439039		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x439041		48894c2408		MOVQ CX, 0x8(SP)		
  0x439046		c644241000		MOVB $0x0, 0x10(SP)		
  0x43904b		e8c0270000		CALL runtime.funcdata(SB)	
  0x439050		488b442418		MOVQ 0x18(SP), AX		
			if stackmap == nil || stackmap.n <= 0 {
  0x439055		4885c0			TESTQ AX, AX		
  0x439058		0f84f4020000		JE 0x439352		
  0x43905e		8b08			MOVL 0(AX), CX		
  0x439060		85c9			TESTL CX, CX		
  0x439062		0f8eea020000		JLE 0x439352		
			stackmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
  0x439068		4889842498000000	MOVQ AX, 0x98(SP)	
			if pcdata < 0 || pcdata >= stackmap.n {
  0x439070		8b54243c		MOVL 0x3c(SP), DX	
  0x439074		85d2			TESTL DX, DX		
  0x439076		0f8ca8010000		JL 0x439224		
  0x43907c		39ca			CMPL CX, DX		
  0x43907e		0f8da0010000		JGE 0x439224		
			if stackmap.nbit > 0 {
  0x439084		8b4804			MOVL 0x4(AX), CX	
  0x439087		85c9			TESTL CX, CX		
  0x439089		7e2a			JLE 0x4390b5		
				args = stackmapdata(stackmap, pcdata)
  0x43908b		90			NOPL			
	return bitvector{stkmap.nbit, addb(&stkmap.bytedata[0], uintptr(n*((stkmap.nbit+7)>>3)))}
  0x43908c		90			NOPL			
  0x43908d		8d5907			LEAL 0x7(CX), BX	
  0x439090		c1fb03			SARL $0x3, BX		
  0x439093		0fafda			IMULL DX, BX		
  0x439096		4863d3			MOVSXD BX, DX		
	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))
  0x439099		488d0410		LEAQ 0(AX)(DX*1), AX	
  0x43909d		488d4008		LEAQ 0x8(AX), AX	
	return
  0x4390a1		8b5c2444		MOVL 0x44(SP), BX	
  0x4390a5		4889c2			MOVQ AX, DX		
  0x4390a8		488b8424a8000000	MOVQ 0xa8(SP), AX	
	p := funcdata(f, _FUNCDATA_StackObjects)
  0x4390b0		e9d8feffff		JMP 0x438f8d		
  0x4390b5		31c9			XORL CX, CX		
  0x4390b7		31c0			XORL AX, AX		
			if stackmap.nbit > 0 {
  0x4390b9		ebe6			JMP 0x4390a1		
  0x4390bb		31c9			XORL CX, CX		
  0x4390bd		31d2			XORL DX, DX		
	if frame.arglen > 0 {
  0x4390bf		e9c9feffff		JMP 0x438f8d		
  0x4390c4		31c0			XORL AX, AX		
  0x4390c6		31db			XORL BX, BX		
  0x4390c8		e983feffff		JMP 0x438f50		
			callerPC := frame.lr
  0x4390cd		488b4820		MOVQ 0x20(AX), CX	
  0x4390d1		48894c2458		MOVQ CX, 0x58(SP)	
			caller := findfunc(callerPC)
  0x4390d6		48890c24		MOVQ CX, 0(SP)			
  0x4390da		e8211a0000		CALL runtime.findfunc(SB)	
  0x4390df		488b442410		MOVQ 0x10(SP), AX		
  0x4390e4		488b4c2408		MOVQ 0x8(SP), CX		
			if !caller.valid() {
  0x4390e9		90			NOPL			
	return f._func != nil
  0x4390ea		4885c9			TESTQ CX, CX		
			if !caller.valid() {
  0x4390ed		0f8482050000		JE 0x439675		
			if callerPC != caller.entry {
  0x4390f3		488b542458		MOVQ 0x58(SP), DX	
  0x4390f8		483911			CMPQ DX, 0(CX)		
  0x4390fb		7535			JNE 0x439132		
  0x4390fd		baffffffff		MOVL $-0x1, DX		
			if stackid == -1 {
  0x439102		89542434		MOVL DX, 0x34(SP)	
			stkmap = (*stackmap)(funcdata(caller, _FUNCDATA_RegPointerMaps))
  0x439106		48890c24		MOVQ CX, 0(SP)			
  0x43910a		4889442408		MOVQ AX, 0x8(SP)		
  0x43910f		c644241003		MOVB $0x3, 0x10(SP)		
  0x439114		e8f7260000		CALL runtime.funcdata(SB)	
			if stackid == -1 {
  0x439119		8b4c2434		MOVL 0x34(SP), CX	
  0x43911d		83f9ff			CMPL $-0x1, CX		
			if stackid < 0 || stackid >= stkmap.n {
  0x439120		b800000000		MOVL $0x0, AX		
  0x439125		0f44c8			CMOVE AX, CX		
			stkmap = (*stackmap)(funcdata(caller, _FUNCDATA_RegPointerMaps))
  0x439128		488b442418		MOVQ 0x18(SP), AX	
			if stackid == -1 {
  0x43912d		e9cefdffff		JMP 0x438f00		
			caller := findfunc(callerPC)
  0x439132		4889842490000000	MOVQ AX, 0x90(SP)	
  0x43913a		48898c2488000000	MOVQ CX, 0x88(SP)	
				stackid = pcdatavalue(caller, _PCDATA_RegMapIndex, callerPC, cache)
  0x439142		48890c24		MOVQ CX, 0(SP)		
  0x439146		4889442408		MOVQ AX, 0x8(SP)	
  0x43914b		c744241002000000	MOVL $0x2, 0x10(SP)	
				callerPC--
  0x439153		48ffca			DECQ DX			
				stackid = pcdatavalue(caller, _PCDATA_RegMapIndex, callerPC, cache)
  0x439156		4889542418		MOVQ DX, 0x18(SP)		
  0x43915b		488b9424d8000000	MOVQ 0xd8(SP), DX		
  0x439163		4889542420		MOVQ DX, 0x20(SP)		
  0x439168		e8f3250000		CALL runtime.pcdatavalue(SB)	
  0x43916d		8b542428		MOVL 0x28(SP), DX		
			stkmap = (*stackmap)(funcdata(caller, _FUNCDATA_RegPointerMaps))
  0x439171		488b842490000000	MOVQ 0x90(SP), AX	
  0x439179		488b8c2488000000	MOVQ 0x88(SP), CX	
				stackid = pcdatavalue(caller, _PCDATA_RegMapIndex, callerPC, cache)
  0x439181		e97cffffff		JMP 0x439102		
  0x439186		31c0			XORL AX, AX		
  0x439188		31db			XORL BX, BX		
	if pcdata == -1 {
  0x43918a		e9c1fdffff		JMP 0x438f50		
		pcdata = pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache)
  0x43918f		48891424		MOVQ DX, 0(SP)		
  0x439193		48895c2408		MOVQ BX, 0x8(SP)	
  0x439198		c744241000000000	MOVL $0x0, 0x10(SP)	
		targetpc--
  0x4391a0		488d41ff		LEAQ -0x1(CX), AX	
  0x4391a4		4889442448		MOVQ AX, 0x48(SP)	
		pcdata = pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache)
  0x4391a9		4889442418		MOVQ AX, 0x18(SP)		
  0x4391ae		488b8c24d8000000	MOVQ 0xd8(SP), CX		
  0x4391b6		48894c2420		MOVQ CX, 0x20(SP)		
  0x4391bb		e8a0250000		CALL runtime.pcdatavalue(SB)	
  0x4391c0		8b742428		MOVL 0x28(SP), SI		
	size := frame.varp - frame.sp
  0x4391c4		488b8424d0000000	MOVQ 0xd0(SP), AX	
		if f.funcID != funcID_debugCallV1 {
  0x4391cc		488b9424b8000000	MOVQ 0xb8(SP), DX	
			stkmap = (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
  0x4391d4		488b9c24b0000000	MOVQ 0xb0(SP), BX	
				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n")
  0x4391dc		488b4c2448		MOVQ 0x48(SP), CX	
		pcdata = pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache)
  0x4391e1		e9cafcffff		JMP 0x438eb0		
		return
  0x4391e6		c78424e800000000000000		MOVL $0x0, 0xe8(SP)	
  0x4391f1		48c78424f000000000000000	MOVQ $0x0, 0xf0(SP)	
  0x4391fd		c78424f800000000000000		MOVL $0x0, 0xf8(SP)	
  0x439208		48c784240001000000000000	MOVQ $0x0, 0x100(SP)	
  0x439214		488bac24c0000000		MOVQ 0xc0(SP), BP	
  0x43921c		4881c4c8000000			ADDQ $0xc8, SP		
  0x439223		c3				RET			
				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n")
  0x439224		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x43922c		48890424		MOVQ AX, 0(SP)			
  0x439230		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x439238		4889442408		MOVQ AX, 0x8(SP)		
  0x43923d		e8fe1f0000		CALL runtime.funcname(SB)	
  0x439242		488b842498000000	MOVQ 0x98(SP), AX		
  0x43924a		486300			MOVSXD 0(AX), AX		
  0x43924d		4889442478		MOVQ AX, 0x78(SP)		
  0x439252		488b4c2410		MOVQ 0x10(SP), CX		
  0x439257		48898c24a8000000	MOVQ CX, 0xa8(SP)		
  0x43925f		488b542418		MOVQ 0x18(SP), DX		
  0x439264		4889542470		MOVQ DX, 0x70(SP)		
  0x439269		e852acfeff		CALL runtime.printlock(SB)	
  0x43926e		488d055e720300		LEAQ 0x3725e(IP), AX		
  0x439275		48890424		MOVQ AX, 0(SP)			
  0x439279		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x439282		e869b5feff		CALL runtime.printstring(SB)	
  0x439287		8b44243c		MOVL 0x3c(SP), AX		
  0x43928b		4863c0			MOVSXD AX, AX			
  0x43928e		48890424		MOVQ AX, 0(SP)			
  0x439292		e8a9b3feff		CALL runtime.printint(SB)	
  0x439297		488d05095f0300		LEAQ 0x35f09(IP), AX		
  0x43929e		48890424		MOVQ AX, 0(SP)			
  0x4392a2		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4392ab		e840b5feff		CALL runtime.printstring(SB)	
  0x4392b0		488b442478		MOVQ 0x78(SP), AX		
  0x4392b5		48890424		MOVQ AX, 0(SP)			
  0x4392b9		e882b3feff		CALL runtime.printint(SB)	
  0x4392be		488d05f5820300		LEAQ 0x382f5(IP), AX		
  0x4392c5		48890424		MOVQ AX, 0(SP)			
  0x4392c9		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x4392d2		e819b5feff		CALL runtime.printstring(SB)	
  0x4392d7		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x4392df		48890424		MOVQ AX, 0(SP)			
  0x4392e3		488b442470		MOVQ 0x70(SP), AX		
  0x4392e8		4889442408		MOVQ AX, 0x8(SP)		
  0x4392ed		e8feb4feff		CALL runtime.printstring(SB)	
  0x4392f2		488d0528650300		LEAQ 0x36528(IP), AX		
  0x4392f9		48890424		MOVQ AX, 0(SP)			
  0x4392fd		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x439306		e8e5b4feff		CALL runtime.printstring(SB)	
  0x43930b		488b442448		MOVQ 0x48(SP), AX		
  0x439310		48890424		MOVQ AX, 0(SP)			
  0x439314		e897b3feff		CALL runtime.printhex(SB)	
  0x439319		488d057a5d0300		LEAQ 0x35d7a(IP), AX		
  0x439320		48890424		MOVQ AX, 0(SP)			
  0x439324		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43932d		e8beb4feff		CALL runtime.printstring(SB)	
  0x439332		e809acfeff		CALL runtime.printunlock(SB)	
				throw("bad symbol table")
  0x439337		488d05896c0300		LEAQ 0x36c89(IP), AX	
  0x43933e		48890424		MOVQ AX, 0(SP)		
  0x439342		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43934b		e830a1feff		CALL runtime.throw(SB)	
  0x439350		0f0b			UD2			
				print("runtime: frame ", funcname(f), " untyped args ", hex(frame.argp), "+", hex(frame.arglen), "\n")
  0x439352		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x43935a		48890424		MOVQ AX, 0(SP)			
  0x43935e		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x439366		4889442408		MOVQ AX, 0x8(SP)		
  0x43936b		e8d01e0000		CALL runtime.funcname(SB)	
  0x439370		488b442418		MOVQ 0x18(SP), AX		
  0x439375		4889442470		MOVQ AX, 0x70(SP)		
  0x43937a		488b4c2410		MOVQ 0x10(SP), CX		
  0x43937f		48898c24a8000000	MOVQ CX, 0xa8(SP)		
  0x439387		488b9424d0000000	MOVQ 0xd0(SP), DX		
  0x43938f		488b5a40		MOVQ 0x40(DX), BX		
  0x439393		48895c2468		MOVQ BX, 0x68(SP)		
  0x439398		488b5248		MOVQ 0x48(DX), DX		
  0x43939c		4889542460		MOVQ DX, 0x60(SP)		
  0x4393a1		e81aabfeff		CALL runtime.printlock(SB)	
  0x4393a6		488d052e6b0300		LEAQ 0x36b2e(IP), AX		
  0x4393ad		48890424		MOVQ AX, 0(SP)			
  0x4393b1		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x4393ba		e831b4feff		CALL runtime.printstring(SB)	
  0x4393bf		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x4393c7		48890424		MOVQ AX, 0(SP)			
  0x4393cb		488b442470		MOVQ 0x70(SP), AX		
  0x4393d0		4889442408		MOVQ AX, 0x8(SP)		
  0x4393d5		e816b4feff		CALL runtime.printstring(SB)	
  0x4393da		488d054d690300		LEAQ 0x3694d(IP), AX		
  0x4393e1		48890424		MOVQ AX, 0(SP)			
  0x4393e5		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x4393ee		e8fdb3feff		CALL runtime.printstring(SB)	
  0x4393f3		488b442468		MOVQ 0x68(SP), AX		
  0x4393f8		48890424		MOVQ AX, 0(SP)			
  0x4393fc		e8afb2feff		CALL runtime.printhex(SB)	
  0x439401		488d057b5c0300		LEAQ 0x35c7b(IP), AX		
  0x439408		48890424		MOVQ AX, 0(SP)			
  0x43940c		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x439415		e8d6b3feff		CALL runtime.printstring(SB)	
  0x43941a		488b442460		MOVQ 0x60(SP), AX		
  0x43941f		48890424		MOVQ AX, 0(SP)			
  0x439423		e888b2feff		CALL runtime.printhex(SB)	
  0x439428		e823adfeff		CALL runtime.printnl(SB)	
  0x43942d		e80eabfeff		CALL runtime.printunlock(SB)	
				throw("missing stackmap")
  0x439432		488d050e6c0300		LEAQ 0x36c0e(IP), AX	
  0x439439		48890424		MOVQ AX, 0(SP)		
  0x43943d		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x439446		e835a0feff		CALL runtime.throw(SB)	
  0x43944b		0f0b			UD2			
				print("runtime: pcdata is ", stackid, " and ", stkmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", hex(targetpc), ")\n")
  0x43944d		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x439455		48890424		MOVQ AX, 0(SP)			
  0x439459		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x439461		4889442408		MOVQ AX, 0x8(SP)		
  0x439466		e8d51d0000		CALL runtime.funcname(SB)	
  0x43946b		488b842480000000	MOVQ 0x80(SP), AX		
  0x439473		486300			MOVSXD 0(AX), AX		
  0x439476		4889442478		MOVQ AX, 0x78(SP)		
  0x43947b		488b4c2418		MOVQ 0x18(SP), CX		
  0x439480		48894c2470		MOVQ CX, 0x70(SP)		
  0x439485		488b542410		MOVQ 0x10(SP), DX		
  0x43948a		48899424a8000000	MOVQ DX, 0xa8(SP)		
  0x439492		e829aafeff		CALL runtime.printlock(SB)	
  0x439497		488d0535700300		LEAQ 0x37035(IP), AX		
  0x43949e		48890424		MOVQ AX, 0(SP)			
  0x4394a2		48c744240813000000	MOVQ $0x13, 0x8(SP)		
  0x4394ab		e840b3feff		CALL runtime.printstring(SB)	
  0x4394b0		8b442438		MOVL 0x38(SP), AX		
  0x4394b4		4863c0			MOVSXD AX, AX			
  0x4394b7		48890424		MOVQ AX, 0(SP)			
  0x4394bb		e880b1feff		CALL runtime.printint(SB)	
  0x4394c0		488d05e05c0300		LEAQ 0x35ce0(IP), AX		
  0x4394c7		48890424		MOVQ AX, 0(SP)			
  0x4394cb		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x4394d4		e817b3feff		CALL runtime.printstring(SB)	
  0x4394d9		488b442478		MOVQ 0x78(SP), AX		
  0x4394de		48890424		MOVQ AX, 0(SP)			
  0x4394e2		e859b1feff		CALL runtime.printint(SB)	
  0x4394e7		488d0596850300		LEAQ 0x38596(IP), AX		
  0x4394ee		48890424		MOVQ AX, 0(SP)			
  0x4394f2		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x4394fb		e8f0b2feff		CALL runtime.printstring(SB)	
  0x439500		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x439508		48890424		MOVQ AX, 0(SP)			
  0x43950c		488b442470		MOVQ 0x70(SP), AX		
  0x439511		4889442408		MOVQ AX, 0x8(SP)		
  0x439516		e8d5b2feff		CALL runtime.printstring(SB)	
  0x43951b		488d05ff620300		LEAQ 0x362ff(IP), AX		
  0x439522		48890424		MOVQ AX, 0(SP)			
  0x439526		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x43952f		e8bcb2feff		CALL runtime.printstring(SB)	
  0x439534		488b442448		MOVQ 0x48(SP), AX		
  0x439539		48890424		MOVQ AX, 0(SP)			
  0x43953d		e86eb1feff		CALL runtime.printhex(SB)	
  0x439542		488d05515b0300		LEAQ 0x35b51(IP), AX		
  0x439549		48890424		MOVQ AX, 0(SP)			
  0x43954d		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x439556		e895b2feff		CALL runtime.printstring(SB)	
  0x43955b		e8e0a9feff		CALL runtime.printunlock(SB)	
				throw("bad symbol table")
  0x439560		488d05606a0300		LEAQ 0x36a60(IP), AX	
  0x439567		48890424		MOVQ AX, 0(SP)		
  0x43956b		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x439574		e8079ffeff		CALL runtime.throw(SB)	
  0x439579		0f0b			UD2			
			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n")
  0x43957b		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x439583		48890424		MOVQ AX, 0(SP)			
  0x439587		488b8424b0000000	MOVQ 0xb0(SP), AX		
  0x43958f		4889442408		MOVQ AX, 0x8(SP)		
  0x439594		e8a71c0000		CALL runtime.funcname(SB)	
  0x439599		488b442418		MOVQ 0x18(SP), AX		
  0x43959e		4889442470		MOVQ AX, 0x70(SP)		
  0x4395a3		488b4c2410		MOVQ 0x10(SP), CX		
  0x4395a8		48898c24a8000000	MOVQ CX, 0xa8(SP)		
  0x4395b0		488b9424d0000000	MOVQ 0xd0(SP), DX		
  0x4395b8		488b5238		MOVQ 0x38(DX), DX		
  0x4395bc		4889542468		MOVQ DX, 0x68(SP)		
  0x4395c1		e8faa8feff		CALL runtime.printlock(SB)	
  0x4395c6		488d050e690300		LEAQ 0x3690e(IP), AX		
  0x4395cd		48890424		MOVQ AX, 0(SP)			
  0x4395d1		48c74424080f000000	MOVQ $0xf, 0x8(SP)		
  0x4395da		e811b2feff		CALL runtime.printstring(SB)	
  0x4395df		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x4395e7		48890424		MOVQ AX, 0(SP)			
  0x4395eb		488b442470		MOVQ 0x70(SP), AX		
  0x4395f0		4889442408		MOVQ AX, 0x8(SP)		
  0x4395f5		e8f6b1feff		CALL runtime.printstring(SB)	
  0x4395fa		488d0546690300		LEAQ 0x36946(IP), AX		
  0x439601		48890424		MOVQ AX, 0(SP)			
  0x439605		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x43960e		e8ddb1feff		CALL runtime.printstring(SB)	
  0x439613		488b442468		MOVQ 0x68(SP), AX		
  0x439618		488b4c2450		MOVQ 0x50(SP), CX		
  0x43961d		4829c8			SUBQ CX, AX			
  0x439620		48890424		MOVQ AX, 0(SP)			
  0x439624		e887b0feff		CALL runtime.printhex(SB)	
  0x439629		488d05535a0300		LEAQ 0x35a53(IP), AX		
  0x439630		48890424		MOVQ AX, 0(SP)			
  0x439634		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43963d		e8aeb1feff		CALL runtime.printstring(SB)	
  0x439642		488b442450		MOVQ 0x50(SP), AX		
  0x439647		48890424		MOVQ AX, 0(SP)			
  0x43964b		e860b0feff		CALL runtime.printhex(SB)	
  0x439650		e8fbaafeff		CALL runtime.printnl(SB)	
  0x439655		e8e6a8feff		CALL runtime.printunlock(SB)	
			throw("missing stackmap")
  0x43965a		488d05e6690300		LEAQ 0x369e6(IP), AX	
  0x439661		48890424		MOVQ AX, 0(SP)		
  0x439665		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43966e		e80d9efeff		CALL runtime.throw(SB)	
  0x439673		0f0b			UD2			
				println("runtime: debugCallV1 called by unknown caller", hex(callerPC))
  0x439675		e846a8feff		CALL runtime.printlock(SB)	
  0x43967a		488d05bd980300		LEAQ 0x398bd(IP), AX		
  0x439681		48890424		MOVQ AX, 0(SP)			
  0x439685		48c74424082e000000	MOVQ $0x2e, 0x8(SP)		
  0x43968e		e85db1feff		CALL runtime.printstring(SB)	
  0x439693		488b442458		MOVQ 0x58(SP), AX		
  0x439698		48890424		MOVQ AX, 0(SP)			
  0x43969c		e80fb0feff		CALL runtime.printhex(SB)	
  0x4396a1		e8aaaafeff		CALL runtime.printnl(SB)	
  0x4396a6		e895a8feff		CALL runtime.printunlock(SB)	
				throw("bad debugCallV1")
  0x4396ab		488d05c0670300		LEAQ 0x367c0(IP), AX	
  0x4396b2		48890424		MOVQ AX, 0(SP)		
  0x4396b6		48c74424080f000000	MOVQ $0xf, 0x8(SP)	
  0x4396bf		e8bc9dfeff		CALL runtime.throw(SB)	
  0x4396c4		0f0b			UD2			
func getStackMap(frame *stkframe, cache *pcvalueCache, debug bool) (locals, args bitvector, objs []stackObjectRecord) {
  0x4396c6		e8b5e10000		CALL runtime.morestack_noctxt(SB)	
  0x4396cb		e960f7ffff		JMP runtime.getStackMap(SB)		

TEXT runtime.morestackc(SB) /usr/local/go/src/runtime/stack.go
func morestackc() {
  0x4396d0		4883ec18		SUBQ $0x18, SP		
  0x4396d4		48896c2410		MOVQ BP, 0x10(SP)	
  0x4396d9		488d6c2410		LEAQ 0x10(SP), BP	
	throw("attempt to execute system stack code on user stack")
  0x4396de		488d05be9a0300		LEAQ 0x39abe(IP), AX	
  0x4396e5		48890424		MOVQ AX, 0(SP)		
  0x4396e9		48c744240832000000	MOVQ $0x32, 0x8(SP)	
  0x4396f2		e8899dfeff		CALL runtime.throw(SB)	
  0x4396f7		0f0b			UD2			

TEXT runtime.concatstrings(SB) /usr/local/go/src/runtime/string.go
func concatstrings(buf *tmpBuf, a []string) string {
  0x439700		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439709		488d4424f0		LEAQ -0x10(SP), AX	
  0x43970e		483b4110		CMPQ 0x10(CX), AX	
  0x439712		0f86b6020000		JBE 0x4399ce		
  0x439718		4881ec90000000		SUBQ $0x90, SP		
  0x43971f		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x439727		488dac2488000000	LEAQ 0x88(SP), BP	
	for i, x := range a {
  0x43972f		488b8424a8000000	MOVQ 0xa8(SP), AX	
  0x439737		4885c0			TESTQ AX, AX		
  0x43973a		0f8e4a020000		JLE 0x43998a		
  0x439740		488b8c24a0000000	MOVQ 0xa0(SP), CX	
func concatstrings(buf *tmpBuf, a []string) string {
  0x439748		4889ca			MOVQ CX, DX		
  0x43974b		31db			XORL BX, BX		
  0x43974d		31f6			XORL SI, SI		
  0x43974f		31ff			XORL DI, DI		
  0x439751		4531c0			XORL R8, R8		
	for i, x := range a {
  0x439754		eb04			JMP 0x43975a		
  0x439756		4883c110		ADDQ $0x10, CX		
  0x43975a		4c8b4908		MOVQ 0x8(CX), R9	
		if n == 0 {
  0x43975e		4d85c9			TESTQ R9, R9		
  0x439761		0f850c020000		JNE 0x439973		
	for i, x := range a {
  0x439767		48ffc3			INCQ BX			
  0x43976a		4839c3			CMPQ AX, BX		
  0x43976d		7ce7			JL 0x439756		
	if count == 0 {
  0x43976f		4885f6			TESTQ SI, SI		
  0x439772		0f84e0010000		JE 0x439958		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x439778		4883fe01		CMPQ $0x1, SI		
  0x43977c		0f85c7010000		JNE 0x439949		
  0x439782		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x43978a		4885c9			TESTQ CX, CX		
  0x43978d		0f845f010000		JE 0x4398f2		
  0x439793		bb01000000		MOVL $0x1, BX		
  0x439798		84db			TESTL BL, BL		
  0x43979a		0f851c010000		JNE 0x4398bc		
	s, b := rawstringtmp(buf, l)
  0x4397a0		48890c24		MOVQ CX, 0(SP)			
  0x4397a4		4c89442408		MOVQ R8, 0x8(SP)		
  0x4397a9		e812040000		CALL runtime.rawstringtmp(SB)	
  0x4397ae		488b442420		MOVQ 0x20(SP), AX		
  0x4397b3		488b4c2418		MOVQ 0x18(SP), CX		
  0x4397b8		488b542410		MOVQ 0x10(SP), DX		
  0x4397bd		488b5c2430		MOVQ 0x30(SP), BX		
  0x4397c2		488b742428		MOVQ 0x28(SP), SI		
	for i, x := range a {
  0x4397c7		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x4397cf		4885ff			TESTQ DI, DI		
	for _, x := range a {
  0x4397d2		7e62			JLE 0x439836		
	s, b := rawstringtmp(buf, l)
  0x4397d4		48894c2440		MOVQ CX, 0x40(SP)	
  0x4397d9		4889542460		MOVQ DX, 0x60(SP)	
	for _, x := range a {
  0x4397de		4c8b8424a0000000	MOVQ 0xa0(SP), R8	
  0x4397e6		4531c9			XORL R9, R9		
  0x4397e9		eb0d			JMP 0x4397f8		
  0x4397eb		4983c010		ADDQ $0x10, R8		
		copy(b, x)
  0x4397ef		4c89cb			MOVQ R9, BX		
	for _, x := range a {
  0x4397f2		4989f1			MOVQ SI, R9		
		copy(b, x)
  0x4397f5		4c89de			MOVQ R11, SI		
	for _, x := range a {
  0x4397f8		4d8b5008		MOVQ 0x8(R8), R10	
		copy(b, x)
  0x4397fc		4c39d6			CMPQ R10, SI		
  0x4397ff		4989f3			MOVQ SI, R11		
  0x439802		490f4ff2		CMOVG R10, SI		
	for _, x := range a {
  0x439806		4d8b20			MOVQ 0(R8), R12		
		copy(b, x)
  0x439809		4c39e0			CMPQ R12, AX		
  0x43980c		7548			JNE 0x439856		
		b = b[len(x):]
  0x43980e		4d39da			CMPQ R11, R10		
  0x439811		0f8787010000		JA 0x43999e		
	for _, x := range a {
  0x439817		498d7101		LEAQ 0x1(R9), SI	
		b = b[len(x):]
  0x43981b		4c29d3			SUBQ R10, BX		
  0x43981e		4989d9			MOVQ BX, R9		
  0x439821		48f7db			NEGQ BX			
  0x439824		48c1fb3f		SARQ $0x3f, BX		
  0x439828		4c21d3			ANDQ R10, BX		
  0x43982b		4801d8			ADDQ BX, AX		
  0x43982e		4d29d3			SUBQ R10, R11		
	for _, x := range a {
  0x439831		4839fe			CMPQ DI, SI		
  0x439834		7cb5			JL 0x4397eb		
	return s
  0x439836		48899424b8000000	MOVQ DX, 0xb8(SP)	
  0x43983e		48898c24c0000000	MOVQ CX, 0xc0(SP)	
  0x439846		488bac2488000000	MOVQ 0x88(SP), BP	
  0x43984e		4881c490000000		ADDQ $0x90, SP		
  0x439855		c3			RET			
		copy(b, x)
  0x439856		4889442468		MOVQ AX, 0x68(SP)	
	for _, x := range a {
  0x43985b		4c89542438		MOVQ R10, 0x38(SP)	
  0x439860		4c89442470		MOVQ R8, 0x70(SP)	
  0x439865		4c894c2458		MOVQ R9, 0x58(SP)	
		copy(b, x)
  0x43986a		4c895c2450		MOVQ R11, 0x50(SP)		
  0x43986f		48895c2448		MOVQ BX, 0x48(SP)		
  0x439874		48890424		MOVQ AX, 0(SP)			
  0x439878		4c89642408		MOVQ R12, 0x8(SP)		
  0x43987d		4889742410		MOVQ SI, 0x10(SP)		
  0x439882		e8c90e0100		CALL runtime.memmove(SB)	
		b = b[len(x):]
  0x439887		488b442468		MOVQ 0x68(SP), AX	
	return s
  0x43988c		488b4c2440		MOVQ 0x40(SP), CX	
  0x439891		488b542460		MOVQ 0x60(SP), DX	
		b = b[len(x):]
  0x439896		488b5c2448		MOVQ 0x48(SP), BX	
	for _, x := range a {
  0x43989b		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x4398a3		4c8b442470		MOVQ 0x70(SP), R8	
  0x4398a8		4c8b4c2458		MOVQ 0x58(SP), R9	
		b = b[len(x):]
  0x4398ad		4c8b542438		MOVQ 0x38(SP), R10	
  0x4398b2		4c8b5c2450		MOVQ 0x50(SP), R11	
		copy(b, x)
  0x4398b7		e952ffffff		JMP 0x43980e		
		return a[idx]
  0x4398bc		4839c7			CMPQ AX, DI		
  0x4398bf		0f83e0000000		JAE 0x4399a5		
  0x4398c5		48c1e704		SHLQ $0x4, DI		
  0x4398c9		488b443a08		MOVQ 0x8(DX)(DI*1), AX	
  0x4398ce		488b0c3a		MOVQ 0(DX)(DI*1), CX	
  0x4398d2		48898c24b8000000	MOVQ CX, 0xb8(SP)	
  0x4398da		48898424c0000000	MOVQ AX, 0xc0(SP)	
  0x4398e2		488bac2488000000	MOVQ 0x88(SP), BP	
  0x4398ea		4881c490000000		ADDQ $0x90, SP		
  0x4398f1		c3			RET			
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x4398f2		4839c7			CMPQ AX, DI		
  0x4398f5		0f83b1000000		JAE 0x4399ac		
  0x4398fb		4889fb			MOVQ DI, BX		
  0x4398fe		48c1e704		SHLQ $0x4, DI		
  0x439902		488b743a08		MOVQ 0x8(DX)(DI*1), SI	
  0x439907		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x43990b		48897c2478		MOVQ DI, 0x78(SP)	
  0x439910		4889b42480000000	MOVQ SI, 0x80(SP)	
  0x439918		90			NOPL			
	ptr := uintptr(stringStructOf(&s).str)
  0x439919		488b742478		MOVQ 0x78(SP), SI	
  0x43991e		90			NOPL			
	stk := getg().stack
  0x43991f		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	
  0x439928		4c8b4f08		MOVQ 0x8(DI), R9	
	return stk.lo <= ptr && ptr < stk.hi
  0x43992c		483937			CMPQ SI, 0(DI)		
  0x43992f		7714			JA 0x439945		
  0x439931		4c39ce			CMPQ R9, SI		
  0x439934		400f92c6		SETB SI			
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x439938		83f601			XORL $0x1, SI		
		return a[idx]
  0x43993b		4889df			MOVQ BX, DI		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x43993e		89f3			MOVL SI, BX		
  0x439940		e953feffff		JMP 0x439798		
  0x439945		31f6			XORL SI, SI		
	return stk.lo <= ptr && ptr < stk.hi
  0x439947		ebef			JMP 0x439938		
	s, b := rawstringtmp(buf, l)
  0x439949		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x439951		31db			XORL BX, BX		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x439953		e940feffff		JMP 0x439798		
		return ""
  0x439958		0f57c0			XORPS X0, X0		
  0x43995b		0f118424b8000000	MOVUPS X0, 0xb8(SP)	
  0x439963		488bac2488000000	MOVQ 0x88(SP), BP	
  0x43996b		4881c490000000		ADDQ $0x90, SP		
  0x439972		c3			RET			
		if l+n < l {
  0x439973		4b8d3c08		LEAQ 0(R8)(R9*1), DI	
  0x439977		4c39c7			CMPQ R8, DI		
  0x43997a		7c37			JL 0x4399b3		
		count++
  0x43997c		48ffc6			INCQ SI			
	s, b := rawstringtmp(buf, l)
  0x43997f		4989f8			MOVQ DI, R8		
		return a[idx]
  0x439982		4889df			MOVQ BX, DI		
		idx = i
  0x439985		e9ddfdffff		JMP 0x439767		
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x43998a		488b9424a0000000	MOVQ 0xa0(SP), DX	
  0x439992		31f6			XORL SI, SI		
  0x439994		31ff			XORL DI, DI		
  0x439996		4531c0			XORL R8, R8		
	for i, x := range a {
  0x439999		e9d1fdffff		JMP 0x43976f		
		b = b[len(x):]
  0x43999e		e8ad86feff		CALL runtime.panicslice(SB)	
  0x4399a3		0f0b			UD2				
		return a[idx]
  0x4399a5		e87685feff		CALL runtime.panicindex(SB)	
  0x4399aa		0f0b			UD2				
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
  0x4399ac		e86f85feff		CALL runtime.panicindex(SB)	
  0x4399b1		0f0b			UD2				
			throw("string concatenation too long")
  0x4399b3		488d0554800300		LEAQ 0x38054(IP), AX	
  0x4399ba		48890424		MOVQ AX, 0(SP)		
  0x4399be		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x4399c7		e8b49afeff		CALL runtime.throw(SB)	
  0x4399cc		0f0b			UD2			
func concatstrings(buf *tmpBuf, a []string) string {
  0x4399ce		e8adde0000		CALL runtime.morestack_noctxt(SB)	
  0x4399d3		e928fdffff		JMP runtime.concatstrings(SB)		

TEXT runtime.concatstring2(SB) /usr/local/go/src/runtime/string.go
func concatstring2(buf *tmpBuf, a [2]string) string {
  0x4399e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4399e9		483b6110		CMPQ 0x10(CX), SP	
  0x4399ed		7656			JBE 0x439a45		
  0x4399ef		4883ec38		SUBQ $0x38, SP		
  0x4399f3		48896c2430		MOVQ BP, 0x30(SP)	
  0x4399f8		488d6c2430		LEAQ 0x30(SP), BP	
	return concatstrings(buf, a[:])
  0x4399fd		488b442440		MOVQ 0x40(SP), AX		
  0x439a02		48890424		MOVQ AX, 0(SP)			
  0x439a06		488d442448		LEAQ 0x48(SP), AX		
  0x439a0b		4889442408		MOVQ AX, 0x8(SP)		
  0x439a10		48c744241002000000	MOVQ $0x2, 0x10(SP)		
  0x439a19		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x439a22		e8d9fcffff		CALL runtime.concatstrings(SB)	
  0x439a27		488b442428		MOVQ 0x28(SP), AX		
  0x439a2c		488b4c2420		MOVQ 0x20(SP), CX		
  0x439a31		48894c2468		MOVQ CX, 0x68(SP)		
  0x439a36		4889442470		MOVQ AX, 0x70(SP)		
  0x439a3b		488b6c2430		MOVQ 0x30(SP), BP		
  0x439a40		4883c438		ADDQ $0x38, SP			
  0x439a44		c3			RET				
func concatstring2(buf *tmpBuf, a [2]string) string {
  0x439a45		e836de0000		CALL runtime.morestack_noctxt(SB)	
  0x439a4a		eb94			JMP runtime.concatstring2(SB)		

TEXT runtime.concatstring4(SB) /usr/local/go/src/runtime/string.go
func concatstring4(buf *tmpBuf, a [4]string) string {
  0x439a50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439a59		483b6110		CMPQ 0x10(CX), SP	
  0x439a5d		765c			JBE 0x439abb		
  0x439a5f		4883ec38		SUBQ $0x38, SP		
  0x439a63		48896c2430		MOVQ BP, 0x30(SP)	
  0x439a68		488d6c2430		LEAQ 0x30(SP), BP	
	return concatstrings(buf, a[:])
  0x439a6d		488b442440		MOVQ 0x40(SP), AX		
  0x439a72		48890424		MOVQ AX, 0(SP)			
  0x439a76		488d442448		LEAQ 0x48(SP), AX		
  0x439a7b		4889442408		MOVQ AX, 0x8(SP)		
  0x439a80		48c744241004000000	MOVQ $0x4, 0x10(SP)		
  0x439a89		48c744241804000000	MOVQ $0x4, 0x18(SP)		
  0x439a92		e869fcffff		CALL runtime.concatstrings(SB)	
  0x439a97		488b442428		MOVQ 0x28(SP), AX		
  0x439a9c		488b4c2420		MOVQ 0x20(SP), CX		
  0x439aa1		48898c2488000000	MOVQ CX, 0x88(SP)		
  0x439aa9		4889842490000000	MOVQ AX, 0x90(SP)		
  0x439ab1		488b6c2430		MOVQ 0x30(SP), BP		
  0x439ab6		4883c438		ADDQ $0x38, SP			
  0x439aba		c3			RET				
func concatstring4(buf *tmpBuf, a [4]string) string {
  0x439abb		e8c0dd0000		CALL runtime.morestack_noctxt(SB)	
  0x439ac0		eb8e			JMP runtime.concatstring4(SB)		

TEXT runtime.slicebytetostring(SB) /usr/local/go/src/runtime/string.go
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
  0x439ad0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439ad9		483b6110		CMPQ 0x10(CX), SP	
  0x439add		0f86cb000000		JBE 0x439bae		
  0x439ae3		4883ec28		SUBQ $0x28, SP		
  0x439ae7		48896c2420		MOVQ BP, 0x20(SP)	
  0x439aec		488d6c2420		LEAQ 0x20(SP), BP	
  0x439af1		0f57c0			XORPS X0, X0		
  0x439af4		0f11442450		MOVUPS X0, 0x50(SP)	
	l := len(b)
  0x439af9		488b442440		MOVQ 0x40(SP), AX	
  0x439afe		488b4c2438		MOVQ 0x38(SP), CX	
	if l == 0 {
  0x439b03		4885c0			TESTQ AX, AX		
  0x439b06		0f8493000000		JE 0x439b9f		
	if l == 1 {
  0x439b0c		4883f801		CMPQ $0x1, AX		
  0x439b10		7466			JE 0x439b78		
	if buf != nil && len(b) <= len(buf) {
  0x439b12		488b4c2430		MOVQ 0x30(SP), CX	
  0x439b17		4885c9			TESTQ CX, CX		
  0x439b1a		743e			JE 0x439b5a		
  0x439b1c		4883f820		CMPQ $0x20, AX		
  0x439b20		7f38			JG 0x439b5a		
	stringStructOf(&str).str = p
  0x439b22		90			NOPL			
  0x439b23		48894c2450		MOVQ CX, 0x50(SP)	
	stringStructOf(&str).len = len(b)
  0x439b28		90			NOPL			
  0x439b29		488b442440		MOVQ 0x40(SP), AX	
  0x439b2e		4889442458		MOVQ AX, 0x58(SP)	
	memmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))
  0x439b33		488b442438		MOVQ 0x38(SP), AX		
  0x439b38		488b542440		MOVQ 0x40(SP), DX		
  0x439b3d		48890c24		MOVQ CX, 0(SP)			
  0x439b41		4889442408		MOVQ AX, 0x8(SP)		
  0x439b46		4889542410		MOVQ DX, 0x10(SP)		
  0x439b4b		e8000c0100		CALL runtime.memmove(SB)	
	return
  0x439b50		488b6c2420		MOVQ 0x20(SP), BP	
  0x439b55		4883c428		ADDQ $0x28, SP		
  0x439b59		c3			RET			
		p = mallocgc(uintptr(len(b)), nil, false)
  0x439b5a		48890424		MOVQ AX, 0(SP)			
  0x439b5e		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x439b67		c644241000		MOVB $0x0, 0x10(SP)		
  0x439b6c		e89f00fdff		CALL runtime.mallocgc(SB)	
  0x439b71		488b4c2418		MOVQ 0x18(SP), CX		
  0x439b76		ebaa			JMP 0x439b22			
		stringStructOf(&str).str = unsafe.Pointer(&staticbytes[b[0]])
  0x439b78		90			NOPL					
  0x439b79		0fb601			MOVZX 0(CX), AX				
  0x439b7c		488d0dfd580800		LEAQ runtime.staticbytes(SB), CX	
  0x439b83		4801c8			ADDQ CX, AX				
  0x439b86		4889442450		MOVQ AX, 0x50(SP)			
		stringStructOf(&str).len = 1
  0x439b8b		90			NOPL			
  0x439b8c		48c744245801000000	MOVQ $0x1, 0x58(SP)	
		return
  0x439b95		488b6c2420		MOVQ 0x20(SP), BP	
  0x439b9a		4883c428		ADDQ $0x28, SP		
  0x439b9e		c3			RET			
		return ""
  0x439b9f		0f11442450		MOVUPS X0, 0x50(SP)	
  0x439ba4		488b6c2420		MOVQ 0x20(SP), BP	
  0x439ba9		4883c428		ADDQ $0x28, SP		
  0x439bad		c3			RET			
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
  0x439bae		e8cddc0000		CALL runtime.morestack_noctxt(SB)	
  0x439bb3		e918ffffff		JMP runtime.slicebytetostring(SB)	

TEXT runtime.rawstringtmp(SB) /usr/local/go/src/runtime/string.go
func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {
  0x439bc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439bc9		483b6110		CMPQ 0x10(CX), SP	
  0x439bcd		0f8688000000		JBE 0x439c5b		
  0x439bd3		4883ec38		SUBQ $0x38, SP		
  0x439bd7		48896c2430		MOVQ BP, 0x30(SP)	
  0x439bdc		488d6c2430		LEAQ 0x30(SP), BP	
	if buf != nil && l <= len(buf) {
  0x439be1		488b442440		MOVQ 0x40(SP), AX	
  0x439be6		4885c0			TESTQ AX, AX		
  0x439be9		7462			JE 0x439c4d		
  0x439beb		488b4c2448		MOVQ 0x48(SP), CX	
  0x439bf0		4883f920		CMPQ $0x20, CX		
  0x439bf4		7f33			JG 0x439c29		
		b = buf[:l]
  0x439bf6		4885c9			TESTQ CX, CX		
  0x439bf9		7c59			JL 0x439c54		
	return
  0x439bfb		4889c2			MOVQ AX, DX		
  0x439bfe		bb20000000		MOVL $0x20, BX		
  0x439c03		4889ce			MOVQ CX, SI		
  0x439c06		4889542450		MOVQ DX, 0x50(SP)	
  0x439c0b		4889742458		MOVQ SI, 0x58(SP)	
  0x439c10		4889442460		MOVQ AX, 0x60(SP)	
  0x439c15		48894c2468		MOVQ CX, 0x68(SP)	
  0x439c1a		48895c2470		MOVQ BX, 0x70(SP)	
  0x439c1f		488b6c2430		MOVQ 0x30(SP), BP	
  0x439c24		4883c438		ADDQ $0x38, SP		
  0x439c28		c3			RET			
		s, b = rawstring(l)
  0x439c29		48890c24		MOVQ CX, 0(SP)			
  0x439c2d		e83e000000		CALL runtime.rawstring(SB)	
  0x439c32		488b542408		MOVQ 0x8(SP), DX		
  0x439c37		488b742410		MOVQ 0x10(SP), SI		
  0x439c3c		488b442418		MOVQ 0x18(SP), AX		
  0x439c41		488b4c2420		MOVQ 0x20(SP), CX		
  0x439c46		488b5c2428		MOVQ 0x28(SP), BX		
  0x439c4b		ebb9			JMP 0x439c06			
  0x439c4d		488b4c2448		MOVQ 0x48(SP), CX		
	if buf != nil && l <= len(buf) {
  0x439c52		ebd5			JMP 0x439c29		
		b = buf[:l]
  0x439c54		e8f783feff		CALL runtime.panicslice(SB)	
  0x439c59		0f0b			UD2				
func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {
  0x439c5b		e820dc0000		CALL runtime.morestack_noctxt(SB)	
  0x439c60		e95bffffff		JMP runtime.rawstringtmp(SB)		

TEXT runtime.rawstring(SB) /usr/local/go/src/runtime/string.go
func rawstring(size int) (s string, b []byte) {
  0x439c70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439c79		483b6110		CMPQ 0x10(CX), SP	
  0x439c7d		766f			JBE 0x439cee		
  0x439c7f		4883ec28		SUBQ $0x28, SP		
  0x439c83		48896c2420		MOVQ BP, 0x20(SP)	
  0x439c88		488d6c2420		LEAQ 0x20(SP), BP	
  0x439c8d		0f57c0			XORPS X0, X0		
  0x439c90		0f11442438		MOVUPS X0, 0x38(SP)	
  0x439c95		48c744244800000000	MOVQ $0x0, 0x48(SP)	
  0x439c9e		0f11442450		MOVUPS X0, 0x50(SP)	
	p := mallocgc(uintptr(size), nil, false)
  0x439ca3		488b442430		MOVQ 0x30(SP), AX		
  0x439ca8		48890424		MOVQ AX, 0(SP)			
  0x439cac		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x439cb5		c644241000		MOVB $0x0, 0x10(SP)		
  0x439cba		e851fffcff		CALL runtime.mallocgc(SB)	
  0x439cbf		488b442418		MOVQ 0x18(SP), AX		
	stringStructOf(&s).str = p
  0x439cc4		90			NOPL			
  0x439cc5		4889442438		MOVQ AX, 0x38(SP)	
	stringStructOf(&s).len = size
  0x439cca		90			NOPL			
  0x439ccb		488b4c2430		MOVQ 0x30(SP), CX	
  0x439cd0		48894c2440		MOVQ CX, 0x40(SP)	
	*(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}
  0x439cd5		4889442448		MOVQ AX, 0x48(SP)	
  0x439cda		48894c2450		MOVQ CX, 0x50(SP)	
  0x439cdf		48894c2458		MOVQ CX, 0x58(SP)	
	return
  0x439ce4		488b6c2420		MOVQ 0x20(SP), BP	
  0x439ce9		4883c428		ADDQ $0x28, SP		
  0x439ced		c3			RET			
func rawstring(size int) (s string, b []byte) {
  0x439cee		e88ddb0000		CALL runtime.morestack_noctxt(SB)	
  0x439cf3		e978ffffff		JMP runtime.rawstring(SB)		

TEXT runtime.gostring(SB) /usr/local/go/src/runtime/string.go
func gostring(p *byte) string {
  0x439d00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439d09		483b6110		CMPQ 0x10(CX), SP	
  0x439d0d		0f86a9000000		JBE 0x439dbc		
  0x439d13		4883ec50		SUBQ $0x50, SP		
  0x439d17		48896c2448		MOVQ BP, 0x48(SP)	
  0x439d1c		488d6c2448		LEAQ 0x48(SP), BP	
	l := findnull(p)
  0x439d21		488b442458		MOVQ 0x58(SP), AX		
  0x439d26		48890424		MOVQ AX, 0(SP)			
  0x439d2a		e8d1020000		CALL runtime.findnull(SB)	
  0x439d2f		488b442408		MOVQ 0x8(SP), AX		
	if l == 0 {
  0x439d34		4885c0			TESTQ AX, AX		
  0x439d37		746a			JE 0x439da3		
	l := findnull(p)
  0x439d39		4889442438		MOVQ AX, 0x38(SP)	
	s, b := rawstring(l)
  0x439d3e		48890424		MOVQ AX, 0(SP)			
  0x439d42		e829ffffff		CALL runtime.rawstring(SB)	
  0x439d47		488b442418		MOVQ 0x18(SP), AX		
  0x439d4c		488b4c2410		MOVQ 0x10(SP), CX		
  0x439d51		488b542408		MOVQ 0x8(SP), DX		
  0x439d56		48837c242000		CMPQ $0x0, 0x20(SP)		
	memmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))
  0x439d5c		7657			JBE 0x439db5		
	s, b := rawstring(l)
  0x439d5e		48894c2430		MOVQ CX, 0x30(SP)	
  0x439d63		4889542440		MOVQ DX, 0x40(SP)	
	memmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))
  0x439d68		48890424		MOVQ AX, 0(SP)			
  0x439d6c		488b442458		MOVQ 0x58(SP), AX		
  0x439d71		4889442408		MOVQ AX, 0x8(SP)		
  0x439d76		488b442438		MOVQ 0x38(SP), AX		
  0x439d7b		4889442410		MOVQ AX, 0x10(SP)		
  0x439d80		e8cb090100		CALL runtime.memmove(SB)	
	return s
  0x439d85		488b442440		MOVQ 0x40(SP), AX	
  0x439d8a		4889442460		MOVQ AX, 0x60(SP)	
  0x439d8f		488b442430		MOVQ 0x30(SP), AX	
  0x439d94		4889442468		MOVQ AX, 0x68(SP)	
  0x439d99		488b6c2448		MOVQ 0x48(SP), BP	
  0x439d9e		4883c450		ADDQ $0x50, SP		
  0x439da2		c3			RET			
		return ""
  0x439da3		0f57c0			XORPS X0, X0		
  0x439da6		0f11442460		MOVUPS X0, 0x60(SP)	
  0x439dab		488b6c2448		MOVQ 0x48(SP), BP	
  0x439db0		4883c450		ADDQ $0x50, SP		
  0x439db4		c3			RET			
	memmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))
  0x439db5		e86681feff		CALL runtime.panicindex(SB)	
  0x439dba		0f0b			UD2				
func gostring(p *byte) string {
  0x439dbc		e8bfda0000		CALL runtime.morestack_noctxt(SB)	
  0x439dc1		e93affffff		JMP runtime.gostring(SB)		

TEXT runtime.index(SB) /usr/local/go/src/runtime/string.go
func index(s, t string) int {
  0x439dd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x439dd9		483b6110		CMPQ 0x10(CX), SP	
  0x439ddd		0f86d9000000		JBE 0x439ebc		
  0x439de3		4883ec30		SUBQ $0x30, SP		
  0x439de7		48896c2428		MOVQ BP, 0x28(SP)	
  0x439dec		488d6c2428		LEAQ 0x28(SP), BP	
	if len(t) == 0 {
  0x439df1		488b442450		MOVQ 0x50(SP), AX	
  0x439df6		4885c0			TESTQ AX, AX		
  0x439df9		0f84aa000000		JE 0x439ea9		
	for i := 0; i < len(s); i++ {
  0x439dff		488b4c2440		MOVQ 0x40(SP), CX	
  0x439e04		488b542448		MOVQ 0x48(SP), DX	
  0x439e09		488b5c2438		MOVQ 0x38(SP), BX	
  0x439e0e		31f6			XORL SI, SI		
  0x439e10		eb06			JMP 0x439e18		
  0x439e12		48ffc6			INCQ SI			
  0x439e15		4889f9			MOVQ DI, CX		
  0x439e18		4839ce			CMPQ CX, SI		
  0x439e1b		7d79			JGE 0x439e96		
		if s[i] == t[0] && hasPrefix(s[i:], t) {
  0x439e1d		0fb63c33		MOVZX 0(BX)(SI*1), DI	
  0x439e21		40383a			CMPB DI, 0(DX)		
  0x439e24		7569			JNE 0x439e8f		
  0x439e26		90			NOPL			
  0x439e27		4889cf			MOVQ CX, DI		
  0x439e2a		4829f1			SUBQ SI, CX		
  0x439e2d		4989c8			MOVQ CX, R8		
  0x439e30		48f7d9			NEGQ CX			
  0x439e33		48c1f93f		SARQ $0x3f, CX		
  0x439e37		4821f1			ANDQ SI, CX		
  0x439e3a		4801d9			ADDQ BX, CX		
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x439e3d		4939c0			CMPQ AX, R8		
  0x439e40		7d15			JGE 0x439e57		
  0x439e42		31c9			XORL CX, CX		
		if s[i] == t[0] && hasPrefix(s[i:], t) {
  0x439e44		84c9			TESTL CL, CL		
  0x439e46		74ca			JE 0x439e12		
			return i
  0x439e48		4889742458		MOVQ SI, 0x58(SP)	
  0x439e4d		488b6c2428		MOVQ 0x28(SP), BP	
  0x439e52		4883c430		ADDQ $0x30, SP		
  0x439e56		c3			RET			
	for i := 0; i < len(s); i++ {
  0x439e57		4889742420		MOVQ SI, 0x20(SP)	
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x439e5c		48890c24		MOVQ CX, 0(SP)			
  0x439e60		4889542408		MOVQ DX, 0x8(SP)		
  0x439e65		4889442410		MOVQ AX, 0x10(SP)		
  0x439e6a		e8b183fcff		CALL runtime.memequal(SB)	
  0x439e6f		0fb64c2418		MOVZX 0x18(SP), CX		
  0x439e74		488b442450		MOVQ 0x50(SP), AX		
		if s[i] == t[0] && hasPrefix(s[i:], t) {
  0x439e79		488b542448		MOVQ 0x48(SP), DX	
  0x439e7e		488b5c2438		MOVQ 0x38(SP), BX	
	for i := 0; i < len(s); i++ {
  0x439e83		488b742420		MOVQ 0x20(SP), SI	
  0x439e88		488b7c2440		MOVQ 0x40(SP), DI	
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x439e8d		ebb5			JMP 0x439e44		
	for i := 0; i < len(s); i++ {
  0x439e8f		4889cf			MOVQ CX, DI		
  0x439e92		31c9			XORL CX, CX		
		if s[i] == t[0] && hasPrefix(s[i:], t) {
  0x439e94		ebae			JMP 0x439e44		
	return -1
  0x439e96		48c7442458ffffffff	MOVQ $-0x1, 0x58(SP)	
  0x439e9f		488b6c2428		MOVQ 0x28(SP), BP	
  0x439ea4		4883c430		ADDQ $0x30, SP		
  0x439ea8		c3			RET			
		return 0
  0x439ea9		48c744245800000000	MOVQ $0x0, 0x58(SP)	
  0x439eb2		488b6c2428		MOVQ 0x28(SP), BP	
  0x439eb7		4883c430		ADDQ $0x30, SP		
  0x439ebb		c3			RET			
func index(s, t string) int {
  0x439ebc		e8bfd90000		CALL runtime.morestack_noctxt(SB)	
  0x439ec1		e90affffff		JMP runtime.index(SB)			

TEXT runtime.atoi(SB) /usr/local/go/src/runtime/string.go
	if s == "" {
  0x439ed0		488b442410		MOVQ 0x10(SP), AX	
  0x439ed5		4885c0			TESTQ AX, AX		
  0x439ed8		0f8409010000		JE 0x439fe7		
	if s[0] == '-' {
  0x439ede		488b4c2408		MOVQ 0x8(SP), CX	
  0x439ee3		80392d			CMPB $0x2d, 0(CX)	
  0x439ee6		0f85ee000000		JNE 0x439fda		
		s = s[1:]
  0x439eec		48ffc8			DECQ AX			
  0x439eef		4889c2			MOVQ AX, DX		
  0x439ef2		48f7d8			NEGQ AX			
  0x439ef5		48c1f83f		SARQ $0x3f, AX		
  0x439ef9		4883e001		ANDQ $0x1, AX		
  0x439efd		4801c8			ADDQ CX, AX		
  0x439f00		b901000000		MOVL $0x1, CX		
	if !neg && un > uint(maxInt) {
  0x439f05		31db			XORL BX, BX		
  0x439f07		31f6			XORL SI, SI		
	for i := 0; i < len(s); i++ {
  0x439f09		eb06			JMP 0x439f11		
  0x439f0b		48ffc3			INCQ BX			
	n := int(un)
  0x439f0e		4889fe			MOVQ DI, SI		
	for i := 0; i < len(s); i++ {
  0x439f11		4839d3			CMPQ DX, BX		
  0x439f14		7d63			JGE 0x439f79		
		c := s[i]
  0x439f16		0fb63c18		MOVZX 0(AX)(BX*1), DI	
		if c < '0' || c > '9' {
  0x439f1a		4080ff30		CMPL $0x30, DI		
  0x439f1e		724a			JB 0x439f6a		
  0x439f20		4080ff39		CMPL $0x39, DI		
  0x439f24		7744			JA 0x439f6a		
		if un > maxUint/10 {
  0x439f26		49b89999999999999919	MOVQ $0x1999999999999999, R8	
  0x439f30		4c39c6			CMPQ R8, SI			
  0x439f33		7726			JA 0x439f5b			
		un *= 10
  0x439f35		488d34b6		LEAQ 0(SI)(SI*4), SI	
  0x439f39		4989f1			MOVQ SI, R9		
  0x439f3c		48d1e6			SHLQ $0x1, SI		
		un1 := un + uint(c) - '0'
  0x439f3f		4a8d3c4f		LEAQ 0(DI)(R9*2), DI	
  0x439f43		488d7fd0		LEAQ -0x30(DI), DI	
		if un1 < un {
  0x439f47		4839f7			CMPQ SI, DI		
  0x439f4a		73bf			JAE 0x439f0b		
			return 0, false
  0x439f4c		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439f55		c644242000		MOVB $0x0, 0x20(SP)	
  0x439f5a		c3			RET			
			return 0, false
  0x439f5b		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439f64		c644242000		MOVB $0x0, 0x20(SP)	
  0x439f69		c3			RET			
			return 0, false
  0x439f6a		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439f73		c644242000		MOVB $0x0, 0x20(SP)	
  0x439f78		c3			RET			
	if !neg && un > uint(maxInt) {
  0x439f79		84c9			TESTL CL, CL		
  0x439f7b		743b			JE 0x439fb8		
	if neg && un > uint(maxInt)+1 {
  0x439f7d		740f			JE 0x439f8e			
  0x439f7f		48b80000000000000080	MOVQ $0x8000000000000000, AX	
  0x439f89		4839c6			CMPQ AX, SI			
  0x439f8c		771b			JA 0x439fa9			
		n = -n
  0x439f8e		4889f0			MOVQ SI, AX		
  0x439f91		48f7de			NEGQ SI			
	return n, true
  0x439f94		0fb6c9			MOVZX CL, CX		
  0x439f97		4885c9			TESTQ CX, CX		
  0x439f9a		480f45c6		CMOVNE SI, AX		
  0x439f9e		4889442418		MOVQ AX, 0x18(SP)	
  0x439fa3		c644242001		MOVB $0x1, 0x20(SP)	
	if neg {
  0x439fa8		c3			RET			
		return 0, false
  0x439fa9		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439fb2		c644242000		MOVB $0x0, 0x20(SP)	
  0x439fb7		c3			RET			
	if !neg && un > uint(maxInt) {
  0x439fb8		48b8ffffffffffffff7f	MOVQ $0x7fffffffffffffff, AX	
  0x439fc2		4839c6			CMPQ AX, SI			
  0x439fc5		7704			JA 0x439fcb			
  0x439fc7		84c9			TESTL CL, CL			
  0x439fc9		ebb2			JMP 0x439f7d			
		return 0, false
  0x439fcb		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439fd4		c644242000		MOVB $0x0, 0x20(SP)	
  0x439fd9		c3			RET			
	for i := 0; i < len(s); i++ {
  0x439fda		4889c2			MOVQ AX, DX		
  0x439fdd		4889c8			MOVQ CX, AX		
  0x439fe0		31c9			XORL CX, CX		
	if s[0] == '-' {
  0x439fe2		e91effffff		JMP 0x439f05		
		return 0, false
  0x439fe7		48c744241800000000	MOVQ $0x0, 0x18(SP)	
  0x439ff0		c644242000		MOVB $0x0, 0x20(SP)	
  0x439ff5		c3			RET			

TEXT runtime.findnull(SB) /usr/local/go/src/runtime/string.go
func findnull(s *byte) int {
  0x43a000		4883ec50		SUBQ $0x50, SP		
  0x43a004		48896c2448		MOVQ BP, 0x48(SP)	
  0x43a009		488d6c2448		LEAQ 0x48(SP), BP	
	if s == nil {
  0x43a00e		488b442458		MOVQ 0x58(SP), AX	
  0x43a013		4885c0			TESTQ AX, AX		
  0x43a016		0f848d000000		JE 0x43a0a9		
	safeLen := int(pageSize - uintptr(ptr)%pageSize)
  0x43a01c		4889c1			MOVQ AX, CX		
  0x43a01f		4825ff0f0000		ANDQ $0xfff, AX		
  0x43a025		480500f0ffff		ADDQ $-0x1000, AX	
  0x43a02b		48f7d8			NEGQ AX			
  0x43a02e		31d2			XORL DX, DX		
	for {
  0x43a030		eb1c			JMP 0x43a04e		
		ptr = unsafe.Pointer(uintptr(ptr) + uintptr(safeLen))
  0x43a032		488b5c2420		MOVQ 0x20(SP), BX	
  0x43a037		488b742430		MOVQ 0x30(SP), SI	
  0x43a03c		488d0c1e		LEAQ 0(SI)(BX*1), CX	
		offset += safeLen
  0x43a040		488b742428		MOVQ 0x28(SP), SI	
  0x43a045		488d141e		LEAQ 0(SI)(BX*1), DX	
  0x43a049		b800100000		MOVL $0x1000, AX	
			return offset + i
  0x43a04e		4889542428		MOVQ DX, 0x28(SP)	
		t := *(*string)(unsafe.Pointer(&stringStruct{ptr, safeLen}))
  0x43a053		4889442420		MOVQ AX, 0x20(SP)	
  0x43a058		48894c2430		MOVQ CX, 0x30(SP)	
  0x43a05d		0f57c0			XORPS X0, X0		
  0x43a060		0f11442438		MOVUPS X0, 0x38(SP)	
  0x43a065		48894c2438		MOVQ CX, 0x38(SP)	
  0x43a06a		4889442440		MOVQ AX, 0x40(SP)	
  0x43a06f		488b5c2438		MOVQ 0x38(SP), BX	
		if i := bytealg.IndexByteString(t, 0); i != -1 {
  0x43a074		48891c24		MOVQ BX, 0(SP)					
  0x43a078		4889442408		MOVQ AX, 0x8(SP)				
  0x43a07d		c644241000		MOVB $0x0, 0x10(SP)				
  0x43a082		e83983fcff		CALL internal/bytealg.IndexByteString(SB)	
  0x43a087		488b442418		MOVQ 0x18(SP), AX				
  0x43a08c		4883f8ff		CMPQ $-0x1, AX					
  0x43a090		74a0			JE 0x43a032					
			return offset + i
  0x43a092		488b4c2428		MOVQ 0x28(SP), CX	
  0x43a097		4801c8			ADDQ CX, AX		
  0x43a09a		4889442460		MOVQ AX, 0x60(SP)	
  0x43a09f		488b6c2448		MOVQ 0x48(SP), BP	
  0x43a0a4		4883c450		ADDQ $0x50, SP		
  0x43a0a8		c3			RET			
		return 0
  0x43a0a9		48c744246000000000	MOVQ $0x0, 0x60(SP)	
  0x43a0b2		488b6c2448		MOVQ 0x48(SP), BP	
  0x43a0b7		4883c450		ADDQ $0x50, SP		
  0x43a0bb		c3			RET			

TEXT runtime.badsystemstack(SB) /usr/local/go/src/runtime/stubs.go
func badsystemstack() {
  0x43a0c0		4883ec28		SUBQ $0x28, SP		
  0x43a0c4		48896c2420		MOVQ BP, 0x20(SP)	
  0x43a0c9		488d6c2420		LEAQ 0x20(SP), BP	
	sp := stringStructOf(&badsystemstackMsg)
  0x43a0ce		90			NOPL					
  0x43a0cf		488b058a5a0800		MOVQ runtime.badsystemstackMsg(SB), AX	
	write(2, sp.str, int32(sp.len))
  0x43a0d6		488b0d8b5a0800		MOVQ runtime.badsystemstackMsg+8(SB), CX	
  0x43a0dd		48c7042402000000	MOVQ $0x2, 0(SP)				
  0x43a0e5		4889442408		MOVQ AX, 0x8(SP)				
  0x43a0ea		894c2410		MOVL CX, 0x10(SP)				
  0x43a0ee		e8ad0d0100		CALL runtime.write(SB)				
}
  0x43a0f3		488b6c2420		MOVQ 0x20(SP), BP	
  0x43a0f8		4883c428		ADDQ $0x28, SP		
  0x43a0fc		c3			RET			

TEXT runtime.fastrand(SB) /usr/local/go/src/runtime/stubs.go
	mp := getg().m
  0x43a100		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43a109		488b4030		MOVQ 0x30(AX), AX	
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x43a10d		8b8820010000		MOVL 0x120(AX), CX	
  0x43a113		8b9024010000		MOVL 0x124(AX), DX	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x43a119		899020010000		MOVL DX, 0x120(AX)	
	s1 ^= s1 << 17
  0x43a11f		89cb			MOVL CX, BX		
  0x43a121		c1e111			SHLL $0x11, CX		
  0x43a124		31d9			XORL BX, CX		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x43a126		89d3			MOVL DX, BX		
  0x43a128		31ca			XORL CX, DX		
  0x43a12a		c1e907			SHRL $0x7, CX		
  0x43a12d		31d1			XORL DX, CX		
  0x43a12f		89da			MOVL BX, DX		
  0x43a131		c1eb10			SHRL $0x10, BX		
  0x43a134		31cb			XORL CX, BX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x43a136		899824010000		MOVL BX, 0x124(AX)	
	return s0 + s1
  0x43a13c		8d041a			LEAL 0(DX)(BX*1), AX	
  0x43a13f		89442408		MOVL AX, 0x8(SP)	
  0x43a143		c3			RET			

TEXT runtime.modulesinit(SB) /usr/local/go/src/runtime/symtab.go
func modulesinit() {
  0x43a150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a159		483b6110		CMPQ 0x10(CX), SP	
  0x43a15d		0f865a020000		JBE 0x43a3bd		
  0x43a163		4883ec58		SUBQ $0x58, SP		
  0x43a167		48896c2450		MOVQ BP, 0x50(SP)	
  0x43a16c		488d6c2450		LEAQ 0x50(SP), BP	
	modules := new([]*moduledata)
  0x43a171		488d0528f50100		LEAQ 0x1f528(IP), AX			
  0x43a178		48890424		MOVQ AX, 0(SP)				
  0x43a17c		e8cf05fdff		CALL runtime.newobject(SB)		
  0x43a181		488b442408		MOVQ 0x8(SP), AX			
  0x43a186		4889442440		MOVQ AX, 0x40(SP)			
  0x43a18b		488d0dae570800		LEAQ runtime.firstmoduledata(SB), CX	
	for md := &firstmoduledata; md != nil; md = md.next {
  0x43a192		eb07			JMP 0x43a19b		
  0x43a194		488b89c0010000		MOVQ 0x1c0(CX), CX	
  0x43a19b		4885c9			TESTQ CX, CX		
  0x43a19e		0f8482010000		JE 0x43a326		
		if md.bad {
  0x43a1a4		80b9b801000000		CMPB $0x0, 0x1b8(CX)	
  0x43a1ab		75e7			JNE 0x43a194		
	for md := &firstmoduledata; md != nil; md = md.next {
  0x43a1ad		48894c2448		MOVQ CX, 0x48(SP)	
		*modules = append(*modules, md)
  0x43a1b2		488b5008		MOVQ 0x8(AX), DX			
  0x43a1b6		488d5a01		LEAQ 0x1(DX), BX			
  0x43a1ba		488b7010		MOVQ 0x10(AX), SI			
  0x43a1be		4c8b00			MOVQ 0(AX), R8				
  0x43a1c1		4839f3			CMPQ SI, BX				
  0x43a1c4		0f87fa000000		JA 0x43a2c4				
  0x43a1ca		488d5a01		LEAQ 0x1(DX), BX			
  0x43a1ce		48895808		MOVQ BX, 0x8(AX)			
  0x43a1d2		498d3cd0		LEAQ 0(R8)(DX*8), DI			
  0x43a1d6		833d432c0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a1dd		0f85ce000000		JNE 0x43a2b1				
  0x43a1e3		49890cd0		MOVQ CX, 0(R8)(DX*8)			
		if md.gcdatamask == (bitvector{}) {
  0x43a1e7		83b99001000000		CMPL $0x0, 0x190(CX)	
  0x43a1ee		75a4			JNE 0x43a194		
  0x43a1f0		4883b99801000000	CMPQ $0x0, 0x198(CX)	
  0x43a1f8		759a			JNE 0x43a194		
			md.gcdatamask = progToPointerMask((*byte)(unsafe.Pointer(md.gcdata)), md.edata-md.data)
  0x43a1fa		488b81b8000000		MOVQ 0xb8(CX), AX			
  0x43a201		488b9188000000		MOVQ 0x88(CX), DX			
  0x43a208		482b9180000000		SUBQ 0x80(CX), DX			
  0x43a20f		48890424		MOVQ AX, 0(SP)				
  0x43a213		4889542408		MOVQ DX, 0x8(SP)			
  0x43a218		e8b35cfdff		CALL runtime.progToPointerMask(SB)	
  0x43a21d		488b442418		MOVQ 0x18(SP), AX			
  0x43a222		8b4c2410		MOVL 0x10(SP), CX			
  0x43a226		488b542448		MOVQ 0x48(SP), DX			
  0x43a22b		898a90010000		MOVL CX, 0x190(DX)			
  0x43a231		833de82b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a238		7569			JNE 0x43a2a3				
  0x43a23a		48898298010000		MOVQ AX, 0x198(DX)			
			md.gcbssmask = progToPointerMask((*byte)(unsafe.Pointer(md.gcbss)), md.ebss-md.bss)
  0x43a241		488b82c0000000		MOVQ 0xc0(DX), AX			
  0x43a248		488b8a98000000		MOVQ 0x98(DX), CX			
  0x43a24f		482b8a90000000		SUBQ 0x90(DX), CX			
  0x43a256		48890424		MOVQ AX, 0(SP)				
  0x43a25a		48894c2408		MOVQ CX, 0x8(SP)			
  0x43a25f		e86c5cfdff		CALL runtime.progToPointerMask(SB)	
  0x43a264		488b442418		MOVQ 0x18(SP), AX			
  0x43a269		8b4c2410		MOVL 0x10(SP), CX			
  0x43a26d		488b542448		MOVQ 0x48(SP), DX			
  0x43a272		898aa0010000		MOVL CX, 0x1a0(DX)			
  0x43a278		833da12b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a27f		7514			JNE 0x43a295				
  0x43a281		488982a8010000		MOVQ AX, 0x1a8(DX)			
		*modules = append(*modules, md)
  0x43a288		488b442440		MOVQ 0x40(SP), AX	
	for md := &firstmoduledata; md != nil; md = md.next {
  0x43a28d		4889d1			MOVQ DX, CX		
			md.gcbssmask = progToPointerMask((*byte)(unsafe.Pointer(md.gcbss)), md.ebss-md.bss)
  0x43a290		e9fffeffff		JMP 0x43a194			
  0x43a295		488dbaa8010000		LEAQ 0x1a8(DX), DI		
  0x43a29c		e8dff30000		CALL runtime.gcWriteBarrier(SB)	
  0x43a2a1		ebe5			JMP 0x43a288			
		if md.gcdatamask == (bitvector{}) {
  0x43a2a3		488dba98010000		LEAQ 0x198(DX), DI	
			md.gcdatamask = progToPointerMask((*byte)(unsafe.Pointer(md.gcdata)), md.edata-md.data)
  0x43a2aa		e8d1f30000		CALL runtime.gcWriteBarrier(SB)	
  0x43a2af		eb90			JMP 0x43a241			
	modules := new([]*moduledata)
  0x43a2b1		4889c2			MOVQ AX, DX		
		*modules = append(*modules, md)
  0x43a2b4		4889c8			MOVQ CX, AX				
  0x43a2b7		e8c4f30000		CALL runtime.gcWriteBarrier(SB)		
  0x43a2bc		4889d0			MOVQ DX, AX				
  0x43a2bf		e923ffffff		JMP 0x43a1e7				
  0x43a2c4		488d0535de0100		LEAQ 0x1de35(IP), AX			
  0x43a2cb		48890424		MOVQ AX, 0(SP)				
  0x43a2cf		4c89442408		MOVQ R8, 0x8(SP)			
  0x43a2d4		4889542410		MOVQ DX, 0x10(SP)			
  0x43a2d9		4889742418		MOVQ SI, 0x18(SP)			
  0x43a2de		48895c2420		MOVQ BX, 0x20(SP)			
  0x43a2e3		e898baffff		CALL runtime.growslice(SB)		
  0x43a2e8		488b442428		MOVQ 0x28(SP), AX			
  0x43a2ed		488b4c2430		MOVQ 0x30(SP), CX			
  0x43a2f2		488b542438		MOVQ 0x38(SP), DX			
  0x43a2f7		488b7c2440		MOVQ 0x40(SP), DI			
  0x43a2fc		48895710		MOVQ DX, 0x10(DI)			
  0x43a300		833d192b0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a307		7516			JNE 0x43a31f				
  0x43a309		488907			MOVQ AX, 0(DI)				
  0x43a30c		4889ca			MOVQ CX, DX				
  0x43a30f		4989c0			MOVQ AX, R8				
  0x43a312		4889f8			MOVQ DI, AX				
  0x43a315		488b4c2448		MOVQ 0x48(SP), CX			
  0x43a31a		e9abfeffff		JMP 0x43a1ca				
  0x43a31f		e85cf30000		CALL runtime.gcWriteBarrier(SB)		
  0x43a324		ebe6			JMP 0x43a30c				
	for i, md := range *modules {
  0x43a326		488b4808		MOVQ 0x8(AX), CX	
  0x43a32a		488b38			MOVQ 0(AX), DI		
  0x43a32d		31d2			XORL DX, DX		
  0x43a32f		eb03			JMP 0x43a334		
  0x43a331		48ffc2			INCQ DX			
  0x43a334		4839ca			CMPQ CX, DX		
  0x43a337		7d3a			JGE 0x43a373		
  0x43a339		488b1cd7		MOVQ 0(DI)(DX*8), BX	
		if md.hasmain != 0 {
  0x43a33d		80bb8801000000		CMPB $0x0, 0x188(BX)	
  0x43a344		74eb			JE 0x43a331		
			(*modules)[0] = md
  0x43a346		833dd32a0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a34d		7557			JNE 0x43a3a6				
  0x43a34f		48891f			MOVQ BX, 0(DI)				
			(*modules)[i] = &firstmoduledata
  0x43a352		488b08			MOVQ 0(AX), CX				
  0x43a355		48395008		CMPQ DX, 0x8(AX)			
  0x43a359		765b			JBE 0x43a3b6				
  0x43a35b		488d3cd1		LEAQ 0(CX)(DX*8), DI			
  0x43a35f		833dba2a0a0000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x43a366		752a			JNE 0x43a392				
  0x43a368		488d1dd1550800		LEAQ runtime.firstmoduledata(SB), BX	
  0x43a36f		48891cd1		MOVQ BX, 0(CX)(DX*8)			
	atomicstorep(unsafe.Pointer(&modulesSlice), unsafe.Pointer(modules))
  0x43a373		488d0dfe750800		LEAQ runtime.modulesSlice(SB), CX	
  0x43a37a		48890c24		MOVQ CX, 0(SP)				
  0x43a37e		4889442408		MOVQ AX, 0x8(SP)			
  0x43a383		e8a890fcff		CALL runtime.atomicstorep(SB)		
}
  0x43a388		488b6c2450		MOVQ 0x50(SP), BP	
  0x43a38d		4883c458		ADDQ $0x58, SP		
  0x43a391		c3			RET			
	modules := new([]*moduledata)
  0x43a392		4889c1			MOVQ AX, CX		
			(*modules)[i] = &firstmoduledata
  0x43a395		488d05a4550800		LEAQ runtime.firstmoduledata(SB), AX	
  0x43a39c		e8dff20000		CALL runtime.gcWriteBarrier(SB)		
	atomicstorep(unsafe.Pointer(&modulesSlice), unsafe.Pointer(modules))
  0x43a3a1		4889c8			MOVQ CX, AX		
			(*modules)[i] = &firstmoduledata
  0x43a3a4		ebcd			JMP 0x43a373		
	modules := new([]*moduledata)
  0x43a3a6		4889c1			MOVQ AX, CX		
			(*modules)[0] = md
  0x43a3a9		4889d8			MOVQ BX, AX			
  0x43a3ac		e8cff20000		CALL runtime.gcWriteBarrier(SB)	
			(*modules)[i] = &firstmoduledata
  0x43a3b1		4889c8			MOVQ CX, AX		
			(*modules)[0] = md
  0x43a3b4		eb9c			JMP 0x43a352		
			(*modules)[i] = &firstmoduledata
  0x43a3b6		e8657bfeff		CALL runtime.panicindex(SB)	
  0x43a3bb		0f0b			UD2				
func modulesinit() {
  0x43a3bd		e8bed40000		CALL runtime.morestack_noctxt(SB)	
  0x43a3c2		e989fdffff		JMP runtime.modulesinit(SB)		

TEXT runtime.moduledataverify(SB) /usr/local/go/src/runtime/symtab.go
func moduledataverify() {
  0x43a3d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x43a3d9		483b6110		CMPQ 0x10(CX), SP			
  0x43a3dd		7640			JBE 0x43a41f				
  0x43a3df		4883ec18		SUBQ $0x18, SP				
  0x43a3e3		48896c2410		MOVQ BP, 0x10(SP)			
  0x43a3e8		488d6c2410		LEAQ 0x10(SP), BP			
  0x43a3ed		488d054c550800		LEAQ runtime.firstmoduledata(SB), AX	
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x43a3f4		eb1a			JMP 0x43a410		
  0x43a3f6		4889442408		MOVQ AX, 0x8(SP)	
		moduledataverify1(datap)
  0x43a3fb		48890424		MOVQ AX, 0(SP)				
  0x43a3ff		e82c000000		CALL runtime.moduledataverify1(SB)	
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x43a404		488b442408		MOVQ 0x8(SP), AX	
  0x43a409		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x43a410		4885c0			TESTQ AX, AX		
  0x43a413		75e1			JNE 0x43a3f6		
  0x43a415		488b6c2410		MOVQ 0x10(SP), BP	
  0x43a41a		4883c418		ADDQ $0x18, SP		
  0x43a41e		c3			RET			
func moduledataverify() {
  0x43a41f		e85cd40000		CALL runtime.morestack_noctxt(SB)	
  0x43a424		ebaa			JMP runtime.moduledataverify(SB)	

TEXT runtime.moduledataverify1(SB) /usr/local/go/src/runtime/symtab.go
func moduledataverify1(datap *moduledata) {
  0x43a430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43a439		488d442480		LEAQ -0x80(SP), AX	
  0x43a43e		483b4110		CMPQ 0x10(CX), AX	
  0x43a442		0f866a060000		JBE 0x43aab2		
  0x43a448		4881ec00010000		SUBQ $0x100, SP		
  0x43a44f		4889ac24f8000000	MOVQ BP, 0xf8(SP)	
  0x43a457		488dac24f8000000	LEAQ 0xf8(SP), BP	
	pcln32 := *(**[2]uint32)(unsafe.Pointer(&datap.pclntable))
  0x43a45f		488b842408010000	MOVQ 0x108(SP), AX	
  0x43a467		488b08			MOVQ 0(AX), CX		
	pcln := *(**[8]byte)(unsafe.Pointer(&datap.pclntable))
  0x43a46a		488b10			MOVQ 0(AX), DX		
	if pcln32[0] != 0xfffffffb || pcln[4] != 0 || pcln[5] != 0 || pcln[6] != sys.PCQuantum || pcln[7] != sys.PtrSize {
  0x43a46d		8b09			MOVL 0(CX), CX		
  0x43a46f		894c2424		MOVL CX, 0x24(SP)	
  0x43a473		83f9fb			CMPL $-0x5, CX		
  0x43a476		0f8576050000		JNE 0x43a9f2		
  0x43a47c		807a0400		CMPB $0x0, 0x4(DX)	
  0x43a480		0f856c050000		JNE 0x43a9f2		
  0x43a486		807a0500		CMPB $0x0, 0x5(DX)	
  0x43a48a		0f8562050000		JNE 0x43a9f2		
  0x43a490		807a0601		CMPB $0x1, 0x6(DX)	
  0x43a494		0f8558050000		JNE 0x43a9f2		
  0x43a49a		807a0708		CMPB $0x8, 0x7(DX)	
  0x43a49e		0f854e050000		JNE 0x43a9f2		
	nftab := len(datap.ftab) - 1
  0x43a4a4		488b4818		MOVQ 0x18(AX), CX	
  0x43a4a8		488b5020		MOVQ 0x20(AX), DX	
  0x43a4ac		488d5aff		LEAQ -0x1(DX), BX	
  0x43a4b0		31f6			XORL SI, SI		
	for i := 0; i < nftab; i++ {
  0x43a4b2		eb03			JMP 0x43a4b7		
  0x43a4b4		4c89d6			MOVQ R10, SI		
  0x43a4b7		4839de			CMPQ BX, SI		
  0x43a4ba		0f8dda020000		JGE 0x43a79a		
		if datap.ftab[i].entry > datap.ftab[i+1].entry {
  0x43a4c0		4889f7			MOVQ SI, DI		
  0x43a4c3		48c1e604		SHLQ $0x4, SI		
  0x43a4c7		4c8b040e		MOVQ 0(SI)(CX*1), R8	
  0x43a4cb		4c8d4f01		LEAQ 0x1(DI), R9	
  0x43a4cf		4939d1			CMPQ DX, R9		
  0x43a4d2		0f8313050000		JAE 0x43a9eb		
  0x43a4d8		4d89ca			MOVQ R9, R10		
  0x43a4db		49c1e104		SHLQ $0x4, R9		
  0x43a4df		4d8b1c09		MOVQ 0(R9)(CX*1), R11	
  0x43a4e3		4d39d8			CMPQ R11, R8		
  0x43a4e6		76cc			JBE 0x43a4b4		
			f1 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])), datap}
  0x43a4e8		488b10			MOVQ 0(AX), DX		
  0x43a4eb		4c8b4008		MOVQ 0x8(AX), R8	
  0x43a4ef		4c8b5c0e08		MOVQ 0x8(SI)(CX*1), R11	
  0x43a4f4		4d39c3			CMPQ R8, R11		
  0x43a4f7		0f83e7040000		JAE 0x43a9e4		
  0x43a4fd		4901d3			ADDQ DX, R11		
			f2 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])), datap}
  0x43a500		498b4c0908		MOVQ 0x8(R9)(CX*1), CX	
  0x43a505		4c39c1			CMPQ R8, CX		
  0x43a508		0f83cf040000		JAE 0x43a9dd		
	for i := 0; i < nftab; i++ {
  0x43a50e		48897c2478		MOVQ DI, 0x78(SP)	
		if datap.ftab[i].entry > datap.ftab[i+1].entry {
  0x43a513		4c89542470		MOVQ R10, 0x70(SP)	
  0x43a518		4889742468		MOVQ SI, 0x68(SP)	
  0x43a51d		4c894c2460		MOVQ R9, 0x60(SP)	
			f2 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])), datap}
  0x43a522		4801d1			ADDQ DX, CX		
			if i+1 < nftab {
  0x43a525		4939da			CMPQ BX, R10		
  0x43a528		0f8c37020000		JL 0x43a765		
  0x43a52e		b903000000		MOVL $0x3, CX		
  0x43a533		488d15a64b0300		LEAQ 0x34ba6(IP), DX	
			println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i+1].entry), f2name)
  0x43a53a		48894c2428		MOVQ CX, 0x28(SP)		
  0x43a53f		4889942480000000	MOVQ DX, 0x80(SP)		
  0x43a547		4c891c24		MOVQ R11, 0(SP)			
  0x43a54b		4889442408		MOVQ AX, 0x8(SP)		
  0x43a550		e8eb0c0000		CALL runtime.funcname(SB)	
  0x43a555		488b842408010000	MOVQ 0x108(SP), AX		
  0x43a55d		488b4820		MOVQ 0x20(AX), CX		
  0x43a561		488b5018		MOVQ 0x18(AX), DX		
  0x43a565		488b5c2418		MOVQ 0x18(SP), BX		
  0x43a56a		488b742410		MOVQ 0x10(SP), SI		
  0x43a56f		488b7c2478		MOVQ 0x78(SP), DI		
  0x43a574		4839cf			CMPQ CX, DI			
  0x43a577		0f8359040000		JAE 0x43a9d6			
  0x43a57d		4c8b442468		MOVQ 0x68(SP), R8		
  0x43a582		4d8b0410		MOVQ 0(R8)(DX*1), R8		
  0x43a586		4c8b4c2470		MOVQ 0x70(SP), R9		
  0x43a58b		4939c9			CMPQ CX, R9			
  0x43a58e		0f8342040000		JAE 0x43a9d6			
  0x43a594		48895c2470		MOVQ BX, 0x70(SP)		
  0x43a599		4889b424a0000000	MOVQ SI, 0xa0(SP)		
  0x43a5a1		4c89442458		MOVQ R8, 0x58(SP)		
  0x43a5a6		488b442460		MOVQ 0x60(SP), AX		
  0x43a5ab		488b0410		MOVQ 0(AX)(DX*1), AX		
  0x43a5af		4889442450		MOVQ AX, 0x50(SP)		
  0x43a5b4		e80799feff		CALL runtime.printlock(SB)	
  0x43a5b9		488d05148d0300		LEAQ 0x38d14(IP), AX		
  0x43a5c0		48890424		MOVQ AX, 0(SP)			
  0x43a5c4		48c744240835000000	MOVQ $0x35, 0x8(SP)		
  0x43a5cd		e81ea2feff		CALL runtime.printstring(SB)	
  0x43a5d2		488b442458		MOVQ 0x58(SP), AX		
  0x43a5d7		48890424		MOVQ AX, 0(SP)			
  0x43a5db		e8d0a0feff		CALL runtime.printhex(SB)	
  0x43a5e0		e81b9bfeff		CALL runtime.printsp(SB)	
  0x43a5e5		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x43a5ed		48890424		MOVQ AX, 0(SP)			
  0x43a5f1		488b442470		MOVQ 0x70(SP), AX		
  0x43a5f6		4889442408		MOVQ AX, 0x8(SP)		
  0x43a5fb		e8f0a1feff		CALL runtime.printstring(SB)	
  0x43a600		488d05bb4a0300		LEAQ 0x34abb(IP), AX		
  0x43a607		48890424		MOVQ AX, 0(SP)			
  0x43a60b		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x43a614		e8d7a1feff		CALL runtime.printstring(SB)	
  0x43a619		488b442450		MOVQ 0x50(SP), AX		
  0x43a61e		48890424		MOVQ AX, 0(SP)			
  0x43a622		e889a0feff		CALL runtime.printhex(SB)	
  0x43a627		e8d49afeff		CALL runtime.printsp(SB)	
  0x43a62c		488b842480000000	MOVQ 0x80(SP), AX		
  0x43a634		48890424		MOVQ AX, 0(SP)			
  0x43a638		488b442428		MOVQ 0x28(SP), AX		
  0x43a63d		4889442408		MOVQ AX, 0x8(SP)		
  0x43a642		e8a9a1feff		CALL runtime.printstring(SB)	
  0x43a647		e8049bfeff		CALL runtime.printnl(SB)	
  0x43a64c		e8ef98feff		CALL runtime.printunlock(SB)	
			for j := 0; j <= i; j++ {
  0x43a651		488b442478		MOVQ 0x78(SP), AX	
  0x43a656		488b8c2408010000	MOVQ 0x108(SP), CX	
  0x43a65e		31d2			XORL DX, DX		
  0x43a660		e987000000		JMP 0x43a6ec		
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x43a665		48899424a0000000	MOVQ DX, 0xa0(SP)		
  0x43a66d		48895c2460		MOVQ BX, 0x60(SP)		
  0x43a672		488b442470		MOVQ 0x70(SP), AX		
  0x43a677		488b0408		MOVQ 0(AX)(CX*1), AX		
  0x43a67b		4889442458		MOVQ AX, 0x58(SP)		
  0x43a680		e83b98feff		CALL runtime.printlock(SB)	
  0x43a685		488d05024a0300		LEAQ 0x34a02(IP), AX		
  0x43a68c		48890424		MOVQ AX, 0(SP)			
  0x43a690		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43a699		e852a1feff		CALL runtime.printstring(SB)	
  0x43a69e		488b442458		MOVQ 0x58(SP), AX		
  0x43a6a3		48890424		MOVQ AX, 0(SP)			
  0x43a6a7		e804a0feff		CALL runtime.printhex(SB)	
  0x43a6ac		e84f9afeff		CALL runtime.printsp(SB)	
  0x43a6b1		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x43a6b9		48890424		MOVQ AX, 0(SP)			
  0x43a6bd		488b442460		MOVQ 0x60(SP), AX		
  0x43a6c2		4889442408		MOVQ AX, 0x8(SP)		
  0x43a6c7		e824a1feff		CALL runtime.printstring(SB)	
  0x43a6cc		e87f9afeff		CALL runtime.printnl(SB)	
  0x43a6d1		e86a98feff		CALL runtime.printunlock(SB)	
			for j := 0; j <= i; j++ {
  0x43a6d6		488b442468		MOVQ 0x68(SP), AX	
  0x43a6db		488d5001		LEAQ 0x1(AX), DX	
  0x43a6df		488b442478		MOVQ 0x78(SP), AX	
  0x43a6e4		488b8c2408010000	MOVQ 0x108(SP), CX	
  0x43a6ec		4839c2			CMPQ AX, DX		
  0x43a6ef		0f8fc6020000		JG 0x43a9bb		
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x43a6f5		488b5908		MOVQ 0x8(CX), BX	
  0x43a6f9		488b31			MOVQ 0(CX), SI		
  0x43a6fc		488b7918		MOVQ 0x18(CX), DI	
  0x43a700		48395120		CMPQ DX, 0x20(CX)	
  0x43a704		0f86aa020000		JBE 0x43a9b4		
  0x43a70a		4989d0			MOVQ DX, R8		
  0x43a70d		48c1e204		SHLQ $0x4, DX		
  0x43a711		488b7c3a08		MOVQ 0x8(DX)(DI*1), DI	
  0x43a716		4839df			CMPQ BX, DI		
  0x43a719		0f8395020000		JAE 0x43a9b4		
  0x43a71f		4889542470		MOVQ DX, 0x70(SP)	
			for j := 0; j <= i; j++ {
  0x43a724		4c89442468		MOVQ R8, 0x68(SP)	
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x43a729		488d0437		LEAQ 0(DI)(SI*1), AX		
  0x43a72d		48890424		MOVQ AX, 0(SP)			
  0x43a731		48894c2408		MOVQ CX, 0x8(SP)		
  0x43a736		e8050b0000		CALL runtime.funcname(SB)	
  0x43a73b		488b842408010000	MOVQ 0x108(SP), AX		
  0x43a743		488b4818		MOVQ 0x18(AX), CX		
  0x43a747		488b542410		MOVQ 0x10(SP), DX		
  0x43a74c		488b5c2418		MOVQ 0x18(SP), BX		
  0x43a751		488b742468		MOVQ 0x68(SP), SI		
  0x43a756		48397020		CMPQ SI, 0x20(AX)		
  0x43a75a		0f8705ffffff		JA 0x43a665			
  0x43a760		e94f020000		JMP 0x43a9b4			
			f1 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])), datap}
  0x43a765		4c899c2498000000	MOVQ R11, 0x98(SP)	
				f2name = funcname(f2)
  0x43a76d		48890c24		MOVQ CX, 0(SP)			
  0x43a771		4889442408		MOVQ AX, 0x8(SP)		
  0x43a776		e8c50a0000		CALL runtime.funcname(SB)	
  0x43a77b		488b4c2418		MOVQ 0x18(SP), CX		
  0x43a780		488b542410		MOVQ 0x10(SP), DX		
			println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i+1].entry), f2name)
  0x43a785		488b842408010000	MOVQ 0x108(SP), AX	
  0x43a78d		4c8b9c2498000000	MOVQ 0x98(SP), R11	
				f2name = funcname(f2)
  0x43a795		e9a0fdffff		JMP 0x43a53a		
	if datap.minpc != datap.ftab[0].entry ||
  0x43a79a		488b7050		MOVQ 0x50(AX), SI	
  0x43a79e		4885d2			TESTQ DX, DX		
  0x43a7a1		0f8606020000		JBE 0x43a9ad		
  0x43a7a7		483931			CMPQ SI, 0(CX)		
  0x43a7aa		0f85e2010000		JNE 0x43a992		
		datap.maxpc != datap.ftab[nftab].entry {
  0x43a7b0		48c1e304		SHLQ $0x4, BX		
  0x43a7b4		488b0c0b		MOVQ 0(BX)(CX*1), CX	
  0x43a7b8		48394858		CMPQ CX, 0x58(AX)	
	if datap.minpc != datap.ftab[0].entry ||
  0x43a7bc		0f85d0010000		JNE 0x43a992		
	for _, modulehash := range datap.modulehashes {
  0x43a7c2		488b8870010000		MOVQ 0x170(AX), CX	
  0x43a7c9		488b9078010000		MOVQ 0x178(AX), DX	
  0x43a7d0		4885d2			TESTQ DX, DX		
  0x43a7d3		0f8ed7000000		JLE 0x43a8b0		
  0x43a7d9		4889542478		MOVQ DX, 0x78(SP)	
  0x43a7de		31db			XORL BX, BX		
  0x43a7e0		eb1d			JMP 0x43a7ff		
  0x43a7e2		488bb42490000000	MOVQ 0x90(SP), SI	
  0x43a7ea		4883c628		ADDQ $0x28, SI		
  0x43a7ee		4889ca			MOVQ CX, DX		
  0x43a7f1		4889f1			MOVQ SI, CX		
  0x43a7f4		4889c3			MOVQ AX, BX		
			println("abi mismatch detected between", datap.modulename, "and", modulehash.modulename)
  0x43a7f7		488b842408010000	MOVQ 0x108(SP), AX	
	for _, modulehash := range datap.modulehashes {
  0x43a7ff		488b31			MOVQ 0(CX), SI		
  0x43a802		4889b424d0000000	MOVQ SI, 0xd0(SP)	
  0x43a80a		0f104108		MOVUPS 0x8(CX), X0	
  0x43a80e		0f118424d8000000	MOVUPS X0, 0xd8(SP)	
  0x43a816		0f104118		MOVUPS 0x18(CX), X0	
  0x43a81a		0f118424e8000000	MOVUPS X0, 0xe8(SP)	
  0x43a822		488bb424d0000000	MOVQ 0xd0(SP), SI	
  0x43a82a		4889b424a8000000	MOVQ SI, 0xa8(SP)	
  0x43a832		0f108424d8000000	MOVUPS 0xd8(SP), X0	
  0x43a83a		0f118424b0000000	MOVUPS X0, 0xb0(SP)	
  0x43a842		0f108424e8000000	MOVUPS 0xe8(SP), X0	
  0x43a84a		0f118424c0000000	MOVUPS X0, 0xc0(SP)	
		if modulehash.linktimehash != *modulehash.runtimehash {
  0x43a852		488bb424c8000000	MOVQ 0xc8(SP), SI	
  0x43a85a		488bbc24c0000000	MOVQ 0xc0(SP), DI	
  0x43a862		4c8b8424b8000000	MOVQ 0xb8(SP), R8	
  0x43a86a		4c8b0e			MOVQ 0(SI), R9		
  0x43a86d		48397e08		CMPQ DI, 0x8(SI)	
  0x43a871		7555			JNE 0x43a8c8		
	for _, modulehash := range datap.modulehashes {
  0x43a873		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x43a87b		48895c2470		MOVQ BX, 0x70(SP)	
		if modulehash.linktimehash != *modulehash.runtimehash {
  0x43a880		4c890424		MOVQ R8, 0(SP)			
  0x43a884		4c894c2408		MOVQ R9, 0x8(SP)		
  0x43a889		48897c2410		MOVQ DI, 0x10(SP)		
  0x43a88e		e88d79fcff		CALL runtime.memequal(SB)	
  0x43a893		807c241800		CMPB $0x0, 0x18(SP)		
  0x43a898		7426			JE 0x43a8c0			
	for _, modulehash := range datap.modulehashes {
  0x43a89a		488b442470		MOVQ 0x70(SP), AX	
  0x43a89f		48ffc0			INCQ AX			
  0x43a8a2		488b4c2478		MOVQ 0x78(SP), CX	
  0x43a8a7		4839c8			CMPQ CX, AX		
  0x43a8aa		0f8c32ffffff		JL 0x43a7e2		
  0x43a8b0		488bac24f8000000	MOVQ 0xf8(SP), BP	
  0x43a8b8		4881c400010000		ADDQ $0x100, SP		
  0x43a8bf		c3			RET			
			println("abi mismatch detected between", datap.modulename, "and", modulehash.modulename)
  0x43a8c0		488b842408010000	MOVQ 0x108(SP), AX		
  0x43a8c8		488b8860010000		MOVQ 0x160(AX), CX		
  0x43a8cf		48898c24a0000000	MOVQ CX, 0xa0(SP)		
  0x43a8d7		488b8068010000		MOVQ 0x168(AX), AX		
  0x43a8de		4889442478		MOVQ AX, 0x78(SP)		
  0x43a8e3		488b9424b0000000	MOVQ 0xb0(SP), DX		
  0x43a8eb		4889542470		MOVQ DX, 0x70(SP)		
  0x43a8f0		488b9c24a8000000	MOVQ 0xa8(SP), BX		
  0x43a8f8		48899c2488000000	MOVQ BX, 0x88(SP)		
  0x43a900		e8bb95feff		CALL runtime.printlock(SB)	
  0x43a905		488d052c720300		LEAQ 0x3722c(IP), AX		
  0x43a90c		48890424		MOVQ AX, 0(SP)			
  0x43a910		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x43a919		e8d29efeff		CALL runtime.printstring(SB)	
  0x43a91e		488b8424a0000000	MOVQ 0xa0(SP), AX		
  0x43a926		48890424		MOVQ AX, 0(SP)			
  0x43a92a		488b442478		MOVQ 0x78(SP), AX		
  0x43a92f		4889442408		MOVQ AX, 0x8(SP)		
  0x43a934		e8b79efeff		CALL runtime.printstring(SB)	
  0x43a939		488d0567480300		LEAQ 0x34867(IP), AX		
  0x43a940		48890424		MOVQ AX, 0(SP)			
  0x43a944		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43a94d		e89e9efeff		CALL runtime.printstring(SB)	
  0x43a952		488b842488000000	MOVQ 0x88(SP), AX		
  0x43a95a		48890424		MOVQ AX, 0(SP)			
  0x43a95e		488b442470		MOVQ 0x70(SP), AX		
  0x43a963		4889442408		MOVQ AX, 0x8(SP)		
  0x43a968		e8839efeff		CALL runtime.printstring(SB)	
  0x43a96d		e8de97feff		CALL runtime.printnl(SB)	
  0x43a972		e8c995feff		CALL runtime.printunlock(SB)	
			throw("abi mismatch")
  0x43a977		488d050b510300		LEAQ 0x3510b(IP), AX	
  0x43a97e		48890424		MOVQ AX, 0(SP)		
  0x43a982		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x43a98b		e8f08afeff		CALL runtime.throw(SB)	
  0x43a990		0f0b			UD2			
		throw("minpc or maxpc invalid")
  0x43a992		488d056e600300		LEAQ 0x3606e(IP), AX	
  0x43a999		48890424		MOVQ AX, 0(SP)		
  0x43a99d		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x43a9a6		e8d58afeff		CALL runtime.throw(SB)	
  0x43a9ab		0f0b			UD2			
	if datap.minpc != datap.ftab[0].entry ||
  0x43a9ad		e86e75feff		CALL runtime.panicindex(SB)	
  0x43a9b2		0f0b			UD2				
				print("\t", hex(datap.ftab[j].entry), " ", funcname(funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[j].funcoff])), datap}), "\n")
  0x43a9b4		e86775feff		CALL runtime.panicindex(SB)	
  0x43a9b9		0f0b			UD2				
			throw("invalid runtime symbol table")
  0x43a9bb		488d05106d0300		LEAQ 0x36d10(IP), AX	
  0x43a9c2		48890424		MOVQ AX, 0(SP)		
  0x43a9c6		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x43a9cf		e8ac8afeff		CALL runtime.throw(SB)	
  0x43a9d4		0f0b			UD2			
			println("function symbol table not sorted by program counter:", hex(datap.ftab[i].entry), funcname(f1), ">", hex(datap.ftab[i+1].entry), f2name)
  0x43a9d6		e84575feff		CALL runtime.panicindex(SB)	
  0x43a9db		0f0b			UD2				
			f2 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i+1].funcoff])), datap}
  0x43a9dd		e83e75feff		CALL runtime.panicindex(SB)	
  0x43a9e2		0f0b			UD2				
			f1 := funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[i].funcoff])), datap}
  0x43a9e4		e83775feff		CALL runtime.panicindex(SB)	
  0x43a9e9		0f0b			UD2				
		if datap.ftab[i].entry > datap.ftab[i+1].entry {
  0x43a9eb		e83075feff		CALL runtime.panicindex(SB)	
  0x43a9f0		0f0b			UD2				
		println("runtime: function symbol table header:", hex(pcln32[0]), hex(pcln[4]), hex(pcln[5]), hex(pcln[6]), hex(pcln[7]))
  0x43a9f2		0fb64204		MOVZX 0x4(DX), AX		
  0x43a9f6		4889442448		MOVQ AX, 0x48(SP)		
  0x43a9fb		0fb64a05		MOVZX 0x5(DX), CX		
  0x43a9ff		48894c2440		MOVQ CX, 0x40(SP)		
  0x43aa04		0fb65a06		MOVZX 0x6(DX), BX		
  0x43aa08		48895c2438		MOVQ BX, 0x38(SP)		
  0x43aa0d		0fb65207		MOVZX 0x7(DX), DX		
  0x43aa11		4889542430		MOVQ DX, 0x30(SP)		
  0x43aa16		e8a594feff		CALL runtime.printlock(SB)	
  0x43aa1b		488d058b7e0300		LEAQ 0x37e8b(IP), AX		
  0x43aa22		48890424		MOVQ AX, 0(SP)			
  0x43aa26		48c744240827000000	MOVQ $0x27, 0x8(SP)		
  0x43aa2f		e8bc9dfeff		CALL runtime.printstring(SB)	
  0x43aa34		8b442424		MOVL 0x24(SP), AX		
  0x43aa38		48890424		MOVQ AX, 0(SP)			
  0x43aa3c		e86f9cfeff		CALL runtime.printhex(SB)	
  0x43aa41		e8ba96feff		CALL runtime.printsp(SB)	
  0x43aa46		488b442448		MOVQ 0x48(SP), AX		
  0x43aa4b		48890424		MOVQ AX, 0(SP)			
  0x43aa4f		e85c9cfeff		CALL runtime.printhex(SB)	
  0x43aa54		e8a796feff		CALL runtime.printsp(SB)	
  0x43aa59		488b442440		MOVQ 0x40(SP), AX		
  0x43aa5e		48890424		MOVQ AX, 0(SP)			
  0x43aa62		e8499cfeff		CALL runtime.printhex(SB)	
  0x43aa67		e89496feff		CALL runtime.printsp(SB)	
  0x43aa6c		488b442438		MOVQ 0x38(SP), AX		
  0x43aa71		48890424		MOVQ AX, 0(SP)			
  0x43aa75		e8369cfeff		CALL runtime.printhex(SB)	
  0x43aa7a		e88196feff		CALL runtime.printsp(SB)	
  0x43aa7f		488b442430		MOVQ 0x30(SP), AX		
  0x43aa84		48890424		MOVQ AX, 0(SP)			
  0x43aa88		e8239cfeff		CALL runtime.printhex(SB)	
  0x43aa8d		e8be96feff		CALL runtime.printnl(SB)	
  0x43aa92		e8a994feff		CALL runtime.printunlock(SB)	
		throw("invalid function symbol table\n")
  0x43aa97		488d0530710300		LEAQ 0x37130(IP), AX	
  0x43aa9e		48890424		MOVQ AX, 0(SP)		
  0x43aaa2		48c74424081e000000	MOVQ $0x1e, 0x8(SP)	
  0x43aaab		e8d089feff		CALL runtime.throw(SB)	
  0x43aab0		0f0b			UD2			
func moduledataverify1(datap *moduledata) {
  0x43aab2		e8c9cd0000		CALL runtime.morestack_noctxt(SB)	
  0x43aab7		e974f9ffff		JMP runtime.moduledataverify1(SB)	

TEXT runtime.findmoduledatap(SB) /usr/local/go/src/runtime/symtab.go
	for datap := &firstmoduledata; datap != nil; datap = datap.next {
  0x43aac0		488b442408		MOVQ 0x8(SP), AX			
  0x43aac5		488d0d744e0800		LEAQ runtime.firstmoduledata(SB), CX	
  0x43aacc		eb07			JMP 0x43aad5				
  0x43aace		488b89c0010000		MOVQ 0x1c0(CX), CX			
  0x43aad5		4885c9			TESTQ CX, CX				
  0x43aad8		7412			JE 0x43aaec				
		if datap.minpc <= pc && pc < datap.maxpc {
  0x43aada		48394150		CMPQ AX, 0x50(CX)	
  0x43aade		77ee			JA 0x43aace		
  0x43aae0		48394158		CMPQ AX, 0x58(CX)	
  0x43aae4		76e8			JBE 0x43aace		
			return datap
  0x43aae6		48894c2410		MOVQ CX, 0x10(SP)	
  0x43aaeb		c3			RET			
	return nil
  0x43aaec		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x43aaf5		c3			RET			

TEXT runtime.findfunc(SB) /usr/local/go/src/runtime/symtab.go
func findfunc(pc uintptr) funcInfo {
  0x43ab00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ab09		483b6110		CMPQ 0x10(CX), SP	
  0x43ab0d		0f8657010000		JBE 0x43ac6a		
  0x43ab13		4883ec18		SUBQ $0x18, SP		
  0x43ab17		48896c2410		MOVQ BP, 0x10(SP)	
  0x43ab1c		488d6c2410		LEAQ 0x10(SP), BP	
	datap := findmoduledatap(pc)
  0x43ab21		488b442420		MOVQ 0x20(SP), AX			
  0x43ab26		48890424		MOVQ AX, 0(SP)				
  0x43ab2a		e891ffffff		CALL runtime.findmoduledatap(SB)	
  0x43ab2f		488b442408		MOVQ 0x8(SP), AX			
	if datap == nil {
  0x43ab34		4885c0			TESTQ AX, AX		
  0x43ab37		0f84dd000000		JE 0x43ac1a		
	x := pc - datap.minpc
  0x43ab3d		488b4850		MOVQ 0x50(AX), CX	
  0x43ab41		488b542420		MOVQ 0x20(SP), DX	
  0x43ab46		4889d3			MOVQ DX, BX		
  0x43ab49		4829ca			SUBQ CX, DX		
	b := x / pcbucketsize
  0x43ab4c		4889d1			MOVQ DX, CX		
  0x43ab4f		48c1ea0c		SHRQ $0xc, DX		
	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{})))
  0x43ab53		488d1492		LEAQ 0(DX)(DX*4), DX	
  0x43ab57		48c1e202		SHLQ $0x2, DX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43ab5b		48035048		ADDQ 0x48(AX), DX	
	i := x % pcbucketsize / (pcbucketsize / nsub)
  0x43ab5f		4881e1ff0f0000		ANDQ $0xfff, CX		
  0x43ab66		48c1e908		SHRQ $0x8, CX		
	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{})))
  0x43ab6a		90			NOPL			
	idx := ffb.idx + uint32(ffb.subbuckets[i])
  0x43ab6b		8b32			MOVL 0(DX), SI		
  0x43ab6d		4883f910		CMPQ $0x10, CX		
  0x43ab71		0f83ec000000		JAE 0x43ac63		
  0x43ab77		0fb64c0a04		MOVZX 0x4(DX)(CX*1), CX	
  0x43ab7c		01f1			ADDL SI, CX		
	if idx >= uint32(len(datap.ftab)) {
  0x43ab7e		488b5018		MOVQ 0x18(AX), DX	
  0x43ab82		488b7020		MOVQ 0x20(AX), SI	
  0x43ab86		39f1			CMPL SI, CX		
  0x43ab88		7204			JB 0x43ab8e		
		idx = uint32(len(datap.ftab) - 1)
  0x43ab8a		488d4eff		LEAQ -0x1(SI), CX	
	if pc < datap.ftab[idx].entry {
  0x43ab8e		89cf			MOVL CX, DI		
  0x43ab90		4839f7			CMPQ SI, DI		
  0x43ab93		0f83c3000000		JAE 0x43ac5c		
  0x43ab99		48c1e704		SHLQ $0x4, DI		
  0x43ab9d		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x43aba1		4839fb			CMPQ DI, BX		
  0x43aba4		7204			JB 0x43abaa		
  0x43aba6		eb58			JMP 0x43ac00		
			idx--
  0x43aba8		ffc9			DECL CX			
		for datap.ftab[idx].entry > pc && idx > 0 {
  0x43abaa		89cf			MOVL CX, DI		
  0x43abac		4839f7			CMPQ SI, DI		
  0x43abaf		0f83a0000000		JAE 0x43ac55		
  0x43abb5		48c1e704		SHLQ $0x4, DI		
  0x43abb9		488b3c17		MOVQ 0(DI)(DX*1), DI	
  0x43abbd		4839df			CMPQ BX, DI		
  0x43abc0		7604			JBE 0x43abc6		
  0x43abc2		85c9			TESTL CX, CX		
  0x43abc4		77e2			JA 0x43aba8		
		if idx == 0 {
  0x43abc6		85c9			TESTL CX, CX		
  0x43abc8		7470			JE 0x43ac3a		
	return funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff])), datap}
  0x43abca		488b5808		MOVQ 0x8(AX), BX	
  0x43abce		488b38			MOVQ 0(AX), DI		
  0x43abd1		89c9			MOVL CX, CX		
  0x43abd3		4839f1			CMPQ SI, CX		
  0x43abd6		7354			JAE 0x43ac2c		
  0x43abd8		48c1e104		SHLQ $0x4, CX		
  0x43abdc		488b4c0a08		MOVQ 0x8(DX)(CX*1), CX	
  0x43abe1		4839d9			CMPQ BX, CX		
  0x43abe4		7346			JAE 0x43ac2c		
  0x43abe6		4801f9			ADDQ DI, CX		
  0x43abe9		48894c2428		MOVQ CX, 0x28(SP)	
  0x43abee		4889442430		MOVQ AX, 0x30(SP)	
  0x43abf3		488b6c2410		MOVQ 0x10(SP), BP	
  0x43abf8		4883c418		ADDQ $0x18, SP		
  0x43abfc		c3			RET			
		for datap.ftab[idx+1].entry <= pc {
  0x43abfd		4489c1			MOVL R8, CX		
  0x43ac00		8d7901			LEAL 0x1(CX), DI	
  0x43ac03		4839f7			CMPQ SI, DI		
  0x43ac06		732b			JAE 0x43ac33		
  0x43ac08		4189f8			MOVL DI, R8		
  0x43ac0b		48c1e704		SHLQ $0x4, DI		
  0x43ac0f		488b3c3a		MOVQ 0(DX)(DI*1), DI	
  0x43ac13		4839df			CMPQ BX, DI		
  0x43ac16		76e5			JBE 0x43abfd		
  0x43ac18		ebb0			JMP 0x43abca		
		return funcInfo{}
  0x43ac1a		0f57c0			XORPS X0, X0		
  0x43ac1d		0f11442428		MOVUPS X0, 0x28(SP)	
  0x43ac22		488b6c2410		MOVQ 0x10(SP), BP	
  0x43ac27		4883c418		ADDQ $0x18, SP		
  0x43ac2b		c3			RET			
	return funcInfo{(*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff])), datap}
  0x43ac2c		e8ef72feff		CALL runtime.panicindex(SB)	
  0x43ac31		0f0b			UD2				
		for datap.ftab[idx+1].entry <= pc {
  0x43ac33		e8e872feff		CALL runtime.panicindex(SB)	
  0x43ac38		0f0b			UD2				
			throw("findfunc: bad findfunctab entry idx")
  0x43ac3a		488d05d5770300		LEAQ 0x377d5(IP), AX	
  0x43ac41		48890424		MOVQ AX, 0(SP)		
  0x43ac45		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x43ac4e		e82d88feff		CALL runtime.throw(SB)	
  0x43ac53		0f0b			UD2			
		for datap.ftab[idx].entry > pc && idx > 0 {
  0x43ac55		e8c672feff		CALL runtime.panicindex(SB)	
  0x43ac5a		0f0b			UD2				
	if pc < datap.ftab[idx].entry {
  0x43ac5c		e8bf72feff		CALL runtime.panicindex(SB)	
  0x43ac61		0f0b			UD2				
	idx := ffb.idx + uint32(ffb.subbuckets[i])
  0x43ac63		e8b872feff		CALL runtime.panicindex(SB)	
  0x43ac68		0f0b			UD2				
func findfunc(pc uintptr) funcInfo {
  0x43ac6a		e811cc0000		CALL runtime.morestack_noctxt(SB)	
  0x43ac6f		e98cfeffff		JMP runtime.findfunc(SB)		

TEXT runtime.pcvalue(SB) /usr/local/go/src/runtime/symtab.go
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43ac80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ac89		488d4424e0		LEAQ -0x20(SP), AX	
  0x43ac8e		483b4110		CMPQ 0x10(CX), AX	
  0x43ac92		0f8690050000		JBE 0x43b228		
  0x43ac98		4881eca0000000		SUBQ $0xa0, SP		
  0x43ac9f		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x43aca7		488dac2498000000	LEAQ 0x98(SP), BP	
	if off == 0 {
  0x43acaf		8b8424b8000000		MOVL 0xb8(SP), AX	
  0x43acb6		85c0			TESTL AX, AX		
  0x43acb8		0f84cd040000		JE 0x43b18b		
	if cache != nil {
  0x43acbe		488b8c24c8000000	MOVQ 0xc8(SP), CX	
  0x43acc6		4885c9			TESTQ CX, CX		
  0x43acc9		0f84af040000		JE 0x43b17e		
		x := pcvalueCacheKey(targetpc)
  0x43accf		90			NOPL			
	return (targetpc / sys.PtrSize) % uintptr(len(pcvalueCache{}.entries))
  0x43acd0		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x43acd8		4889d3			MOVQ DX, BX		
  0x43acdb		48c1ea03		SHRQ $0x3, DX		
  0x43acdf		4883e201		ANDQ $0x1, DX		
  0x43ace3		31f6			XORL SI, SI		
		for i := range cache.entries[x] {
  0x43ace5		eb07			JMP 0x43acee		
  0x43ace7		488d7701		LEAQ 0x1(DI), SI	
			ent := &cache.entries[x][i]
  0x43aceb		4c89c2			MOVQ R8, DX		
		for i := range cache.entries[x] {
  0x43acee		4883fe08		CMPQ $0x8, SI		
  0x43acf2		7d3f			JGE 0x43ad33		
			ent := &cache.entries[x][i]
  0x43acf4		4889f7			MOVQ SI, DI		
  0x43acf7		48c1e604		SHLQ $0x4, SI		
  0x43acfb		4989d0			MOVQ DX, R8		
  0x43acfe		48c1e207		SHLQ $0x7, DX		
  0x43ad02		4801ca			ADDQ CX, DX		
			if ent.off == off && ent.targetpc == targetpc {
  0x43ad05		448b4c3208		MOVL 0x8(DX)(SI*1), R9	
  0x43ad0a		4439c8			CMPL R9, AX		
  0x43ad0d		75d8			JNE 0x43ace7		
  0x43ad0f		4c8b0c32		MOVQ 0(DX)(SI*1), R9	
  0x43ad13		4c39cb			CMPQ R9, BX		
  0x43ad16		75cf			JNE 0x43ace7		
				return ent.val
  0x43ad18		8b44320c		MOVL 0xc(DX)(SI*1), AX	
  0x43ad1c		898424d8000000		MOVL AX, 0xd8(SP)	
  0x43ad23		488bac2498000000	MOVQ 0x98(SP), BP	
  0x43ad2b		4881c4a0000000		ADDQ $0xa0, SP		
  0x43ad32		c3			RET			
	if !f.valid() {
  0x43ad33		90			NOPL			
	return f._func != nil
  0x43ad34		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x43ad3c		4885d2			TESTQ DX, DX		
	if !f.valid() {
  0x43ad3f		0f8409040000		JE 0x43b14e		
	p := datap.pclntable[off:]
  0x43ad45		488bb424b0000000	MOVQ 0xb0(SP), SI	
  0x43ad4d		488b7e10		MOVQ 0x10(SI), DI	
  0x43ad51		4c8b4608		MOVQ 0x8(SI), R8	
  0x43ad55		4c8b0e			MOVQ 0(SI), R9		
  0x43ad58		4c63d0			MOVSXD AX, R10		
  0x43ad5b		4d39c2			CMPQ R8, R10		
  0x43ad5e		0f8764040000		JA 0x43b1c8		
  0x43ad64		4c89942480000000	MOVQ R10, 0x80(SP)	
	pc := f.entry
  0x43ad6c		4c8b1a			MOVQ 0(DX), R11		
  0x43ad6f		4c895c2458		MOVQ R11, 0x58(SP)	
	val := int32(-1)
  0x43ad74		c7442454ffffffff	MOVL $-0x1, 0x54(SP)	
	p := datap.pclntable[off:]
  0x43ad7c		4c29d7			SUBQ R10, DI		
  0x43ad7f		4989fb			MOVQ DI, R11		
  0x43ad82		48f7df			NEGQ DI			
  0x43ad85		48c1ff3f		SARQ $0x3f, DI		
  0x43ad89		4c21d7			ANDQ R10, DI		
  0x43ad8c		4c01cf			ADDQ R9, DI		
  0x43ad8f		4d29d0			SUBQ R10, R8		
	for {
  0x43ad92		eb11			JMP 0x43ada5		
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x43ad94		4989c3			MOVQ AX, R11		
  0x43ad97		4989c8			MOVQ CX, R8		
  0x43ad9a		4889d7			MOVQ DX, DI		
  0x43ad9d		488b9424a8000000	MOVQ 0xa8(SP), DX	
  0x43ada5		488b442458		MOVQ 0x58(SP), AX	
  0x43adaa		483902			CMPQ AX, 0(DX)		
  0x43adad		48893c24		MOVQ DI, 0(SP)		
  0x43adb1		4c89442408		MOVQ R8, 0x8(SP)	
  0x43adb6		4c895c2410		MOVQ R11, 0x10(SP)	
  0x43adbb		488d442458		LEAQ 0x58(SP), AX	
  0x43adc0		4889442418		MOVQ AX, 0x18(SP)	
  0x43adc5		488d4c2454		LEAQ 0x54(SP), CX	
  0x43adca		48894c2420		MOVQ CX, 0x20(SP)	
  0x43adcf		0f94442428		SETE 0x28(SP)		
  0x43add4		e8170b0000		CALL runtime.step(SB)	
  0x43add9		488b442440		MOVQ 0x40(SP), AX	
  0x43adde		488b4c2438		MOVQ 0x38(SP), CX	
  0x43ade3		488b542430		MOVQ 0x30(SP), DX	
  0x43ade8		807c244800		CMPB $0x0, 0x48(SP)	
		if !ok {
  0x43aded		0f84c6000000		JE 0x43aeb9		
		if targetpc < pc {
  0x43adf3		488b9c24c0000000	MOVQ 0xc0(SP), BX	
  0x43adfb		48395c2458		CMPQ BX, 0x58(SP)	
  0x43ae00		7692			JBE 0x43ad94		
	if cache != nil {
  0x43ae02		488b8424c8000000	MOVQ 0xc8(SP), AX	
  0x43ae0a		4885c0			TESTQ AX, AX		
			if cache != nil {
  0x43ae0d		0f848b000000		JE 0x43ae9e		
	mp := getg().m
  0x43ae13		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ae1c		488b4930		MOVQ 0x30(CX), CX	
				x := pcvalueCacheKey(targetpc)
  0x43ae20		90			NOPL			
				ci := fastrand() % uint32(len(cache.entries[x]))
  0x43ae21		90			NOPL			
	s1, s0 := mp.fastrand[0], mp.fastrand[1]
  0x43ae22		8b9120010000		MOVL 0x120(CX), DX	
  0x43ae28		8bb124010000		MOVL 0x124(CX), SI	
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x43ae2e		89b120010000		MOVL SI, 0x120(CX)	
	s1 ^= s1 << 17
  0x43ae34		89d7			MOVL DX, DI		
  0x43ae36		c1e211			SHLL $0x11, DX		
  0x43ae39		31d7			XORL DX, DI		
	s1 = s1 ^ s0 ^ s1>>7 ^ s0>>16
  0x43ae3b		89f2			MOVL SI, DX		
  0x43ae3d		31fe			XORL DI, SI		
  0x43ae3f		c1ef07			SHRL $0x7, DI		
  0x43ae42		31f7			XORL SI, DI		
  0x43ae44		89d6			MOVL DX, SI		
  0x43ae46		c1ea10			SHRL $0x10, DX		
  0x43ae49		31fa			XORL DI, DX		
	mp.fastrand[0], mp.fastrand[1] = s0, s1
  0x43ae4b		899124010000		MOVL DX, 0x124(CX)	
	return (targetpc / sys.PtrSize) % uintptr(len(pcvalueCache{}.entries))
  0x43ae51		4889d9			MOVQ BX, CX		
  0x43ae54		48c1eb03		SHRQ $0x3, BX		
  0x43ae58		4883e301		ANDQ $0x1, BX		
				e := &cache.entries[x]
  0x43ae5c		48c1e307		SHLQ $0x7, BX		
  0x43ae60		488d3c18		LEAQ 0(AX)(BX*1), DI	
	return s0 + s1
  0x43ae64		01f2			ADDL SI, DX		
				ci := fastrand() % uint32(len(cache.entries[x]))
  0x43ae66		83e207			ANDL $0x7, DX		
				e[ci] = e[0]
  0x43ae69		48c1e204		SHLQ $0x4, DX		
  0x43ae6d		8b74180c		MOVL 0xc(AX)(BX*1), SI	
  0x43ae71		448b441808		MOVL 0x8(AX)(BX*1), R8	
  0x43ae76		4c8b0c18		MOVQ 0(AX)(BX*1), R9	
  0x43ae7a		4c890c17		MOVQ R9, 0(DI)(DX*1)	
  0x43ae7e		4489441708		MOVL R8, 0x8(DI)(DX*1)	
  0x43ae83		8974170c		MOVL SI, 0xc(DI)(DX*1)	
				e[0] = pcvalueCacheEnt{
  0x43ae87		8b542454		MOVL 0x54(SP), DX	
  0x43ae8b		48890c18		MOVQ CX, 0(AX)(BX*1)	
  0x43ae8f		8b8c24b8000000		MOVL 0xb8(SP), CX	
  0x43ae96		894c1808		MOVL CX, 0x8(AX)(BX*1)	
  0x43ae9a		8954180c		MOVL DX, 0xc(AX)(BX*1)	
			return val
  0x43ae9e		8b442454		MOVL 0x54(SP), AX	
  0x43aea2		898424d8000000		MOVL AX, 0xd8(SP)	
  0x43aea9		488bac2498000000	MOVQ 0x98(SP), BP	
  0x43aeb1		4881c4a0000000		ADDQ $0xa0, SP		
  0x43aeb8		c3			RET			
	if panicking != 0 || !strict {
  0x43aeb9		833d341e0a0000		CMPL $0x0, runtime.panicking(SB)	
  0x43aec0		0f856d020000		JNE 0x43b133				
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43aec6		0fb69c24d0000000	MOVZX 0xd0(SP), BX	
  0x43aece		84db			TESTL BL, BL		
	if panicking != 0 || !strict {
  0x43aed0		0f845d020000		JE 0x43b133		
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x43aed6		4889442468		MOVQ AX, 0x68(SP)	
  0x43aedb		48894c2460		MOVQ CX, 0x60(SP)	
  0x43aee0		4889942488000000	MOVQ DX, 0x88(SP)	
	print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n")
  0x43aee8		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x43aef0		48890424		MOVQ AX, 0(SP)			
  0x43aef4		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x43aefc		48894c2408		MOVQ CX, 0x8(SP)		
  0x43af01		e83a030000		CALL runtime.funcname(SB)	
  0x43af06		488b442410		MOVQ 0x10(SP), AX		
  0x43af0b		4889842490000000	MOVQ AX, 0x90(SP)		
  0x43af13		488b4c2418		MOVQ 0x18(SP), CX		
  0x43af18		48894c2478		MOVQ CX, 0x78(SP)		
  0x43af1d		488b542458		MOVQ 0x58(SP), DX		
  0x43af22		4889542470		MOVQ DX, 0x70(SP)		
  0x43af27		e8948ffeff		CALL runtime.printlock(SB)	
  0x43af2c		488d0520760300		LEAQ 0x37620(IP), AX		
  0x43af33		48890424		MOVQ AX, 0(SP)			
  0x43af37		48c744240824000000	MOVQ $0x24, 0x8(SP)		
  0x43af40		e8ab98feff		CALL runtime.printstring(SB)	
  0x43af45		488b842490000000	MOVQ 0x90(SP), AX		
  0x43af4d		48890424		MOVQ AX, 0(SP)			
  0x43af51		488b442478		MOVQ 0x78(SP), AX		
  0x43af56		4889442408		MOVQ AX, 0x8(SP)		
  0x43af5b		e89098feff		CALL runtime.printstring(SB)	
  0x43af60		488d05a6410300		LEAQ 0x341a6(IP), AX		
  0x43af67		48890424		MOVQ AX, 0(SP)			
  0x43af6b		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43af74		e87798feff		CALL runtime.printstring(SB)	
  0x43af79		488b442470		MOVQ 0x70(SP), AX		
  0x43af7e		48890424		MOVQ AX, 0(SP)			
  0x43af82		e82997feff		CALL runtime.printhex(SB)	
  0x43af87		488d05e8470300		LEAQ 0x347e8(IP), AX		
  0x43af8e		48890424		MOVQ AX, 0(SP)			
  0x43af92		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43af9b		e85098feff		CALL runtime.printstring(SB)	
  0x43afa0		488b8424c0000000	MOVQ 0xc0(SP), AX		
  0x43afa8		48890424		MOVQ AX, 0(SP)			
  0x43afac		e8ff96feff		CALL runtime.printhex(SB)	
  0x43afb1		488d0517420300		LEAQ 0x34217(IP), AX		
  0x43afb8		48890424		MOVQ AX, 0(SP)			
  0x43afbc		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43afc5		e82698feff		CALL runtime.printstring(SB)	
  0x43afca		488b842488000000	MOVQ 0x88(SP), AX		
  0x43afd2		48890424		MOVQ AX, 0(SP)			
  0x43afd6		488b442460		MOVQ 0x60(SP), AX		
  0x43afdb		4889442408		MOVQ AX, 0x8(SP)		
  0x43afe0		488b442468		MOVQ 0x68(SP), AX		
  0x43afe5		4889442410		MOVQ AX, 0x10(SP)		
  0x43afea		e89198feff		CALL runtime.printslice(SB)	
  0x43afef		e85c91feff		CALL runtime.printnl(SB)	
  0x43aff4		e8478ffeff		CALL runtime.printunlock(SB)	
	p = datap.pclntable[off:]
  0x43aff9		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x43b001		488b4810		MOVQ 0x10(AX), CX	
  0x43b005		488b5008		MOVQ 0x8(AX), DX	
  0x43b009		488b00			MOVQ 0(AX), AX		
  0x43b00c		488b9c2480000000	MOVQ 0x80(SP), BX	
  0x43b014		4839d3			CMPQ DX, BX		
  0x43b017		0f87a4010000		JA 0x43b1c1		
	pc = f.entry
  0x43b01d		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43b025		488b3e			MOVQ 0(SI), DI		
  0x43b028		48897c2458		MOVQ DI, 0x58(SP)	
	val = -1
  0x43b02d		c7442454ffffffff	MOVL $-0x1, 0x54(SP)	
	p = datap.pclntable[off:]
  0x43b035		4829d9			SUBQ BX, CX		
  0x43b038		4889cf			MOVQ CX, DI		
  0x43b03b		48f7d9			NEGQ CX			
  0x43b03e		48c1f93f		SARQ $0x3f, CX		
  0x43b042		4821d9			ANDQ BX, CX		
  0x43b045		4801c8			ADDQ CX, AX		
  0x43b048		4829da			SUBQ BX, DX		
	for {
  0x43b04b		e993000000		JMP 0x43b0e3		
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x43b050		4889442468		MOVQ AX, 0x68(SP)	
  0x43b055		48898c2488000000	MOVQ CX, 0x88(SP)	
  0x43b05d		4889542460		MOVQ DX, 0x60(SP)	
		print("\tvalue=", val, " until pc=", hex(pc), "\n")
  0x43b062		488b442458		MOVQ 0x58(SP), AX		
  0x43b067		4889442470		MOVQ AX, 0x70(SP)		
  0x43b06c		e84f8efeff		CALL runtime.printlock(SB)	
  0x43b071		488d0595420300		LEAQ 0x34295(IP), AX		
  0x43b078		48890424		MOVQ AX, 0(SP)			
  0x43b07c		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43b085		e86697feff		CALL runtime.printstring(SB)	
  0x43b08a		4863442454		MOVSXD 0x54(SP), AX		
  0x43b08f		48890424		MOVQ AX, 0(SP)			
  0x43b093		e8a895feff		CALL runtime.printint(SB)	
  0x43b098		488d05eb460300		LEAQ 0x346eb(IP), AX		
  0x43b09f		48890424		MOVQ AX, 0(SP)			
  0x43b0a3		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43b0ac		e83f97feff		CALL runtime.printstring(SB)	
  0x43b0b1		488b442470		MOVQ 0x70(SP), AX		
  0x43b0b6		48890424		MOVQ AX, 0(SP)			
  0x43b0ba		e8f195feff		CALL runtime.printhex(SB)	
  0x43b0bf		e88c90feff		CALL runtime.printnl(SB)	
  0x43b0c4		e8778efeff		CALL runtime.printunlock(SB)	
		p, ok = step(p, &pc, &val, pc == f.entry)
  0x43b0c9		488bb424a8000000	MOVQ 0xa8(SP), SI	
  0x43b0d1		488b7c2468		MOVQ 0x68(SP), DI	
  0x43b0d6		488b542460		MOVQ 0x60(SP), DX	
  0x43b0db		488b842488000000	MOVQ 0x88(SP), AX	
  0x43b0e3		488b4c2458		MOVQ 0x58(SP), CX	
  0x43b0e8		48390e			CMPQ CX, 0(SI)		
  0x43b0eb		48890424		MOVQ AX, 0(SP)		
  0x43b0ef		4889542408		MOVQ DX, 0x8(SP)	
  0x43b0f4		48897c2410		MOVQ DI, 0x10(SP)	
  0x43b0f9		488d442458		LEAQ 0x58(SP), AX	
  0x43b0fe		4889442418		MOVQ AX, 0x18(SP)	
  0x43b103		488d4c2454		LEAQ 0x54(SP), CX	
  0x43b108		48894c2420		MOVQ CX, 0x20(SP)	
  0x43b10d		0f94442428		SETE 0x28(SP)		
  0x43b112		e8d9070000		CALL runtime.step(SB)	
  0x43b117		488b442440		MOVQ 0x40(SP), AX	
  0x43b11c		488b4c2430		MOVQ 0x30(SP), CX	
  0x43b121		488b542438		MOVQ 0x38(SP), DX	
  0x43b126		807c244800		CMPB $0x0, 0x48(SP)	
		if !ok {
  0x43b12b		0f851fffffff		JNE 0x43b050		
  0x43b131		eb73			JMP 0x43b1a6		
		return -1
  0x43b133		c78424d8000000ffffffff	MOVL $-0x1, 0xd8(SP)	
  0x43b13e		488bac2498000000	MOVQ 0x98(SP), BP	
  0x43b146		4881c4a0000000		ADDQ $0xa0, SP		
  0x43b14d		c3			RET			
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43b14e		0fb68424d0000000	MOVZX 0xd0(SP), AX	
  0x43b156		84c0			TESTL AL, AL		
		if strict && panicking == 0 {
  0x43b158		7409			JE 0x43b163				
  0x43b15a		833d931b0a0000		CMPL $0x0, runtime.panicking(SB)	
  0x43b161		746c			JE 0x43b1cf				
		return -1
  0x43b163		c78424d8000000ffffffff	MOVL $-0x1, 0xd8(SP)	
  0x43b16e		488bac2498000000	MOVQ 0x98(SP), BP	
  0x43b176		4881c4a0000000		ADDQ $0xa0, SP		
  0x43b17d		c3			RET			
		if targetpc < pc {
  0x43b17e		488b9c24c0000000	MOVQ 0xc0(SP), BX	
	if cache != nil {
  0x43b186		e9a8fbffff		JMP 0x43ad33		
		return -1
  0x43b18b		c78424d8000000ffffffff	MOVL $-0x1, 0xd8(SP)	
  0x43b196		488bac2498000000	MOVQ 0x98(SP), BP	
  0x43b19e		4881c4a0000000		ADDQ $0xa0, SP		
  0x43b1a5		c3			RET			
	throw("invalid runtime symbol table")
  0x43b1a6		488d0525650300		LEAQ 0x36525(IP), AX	
  0x43b1ad		48890424		MOVQ AX, 0(SP)		
  0x43b1b1		48c74424081c000000	MOVQ $0x1c, 0x8(SP)	
  0x43b1ba		e8c182feff		CALL runtime.throw(SB)	
  0x43b1bf		0f0b			UD2			
	p = datap.pclntable[off:]
  0x43b1c1		e88a6efeff		CALL runtime.panicslice(SB)	
  0x43b1c6		0f0b			UD2				
	p := datap.pclntable[off:]
  0x43b1c8		e8836efeff		CALL runtime.panicslice(SB)	
  0x43b1cd		0f0b			UD2				
			print("runtime: no module data for ", hex(f.entry), "\n")
  0x43b1cf		488b02			MOVQ 0(DX), AX			
  0x43b1d2		4889442470		MOVQ AX, 0x70(SP)		
  0x43b1d7		e8e48cfeff		CALL runtime.printlock(SB)	
  0x43b1dc		488d0523660300		LEAQ 0x36623(IP), AX		
  0x43b1e3		48890424		MOVQ AX, 0(SP)			
  0x43b1e7		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x43b1f0		e8fb95feff		CALL runtime.printstring(SB)	
  0x43b1f5		488b442470		MOVQ 0x70(SP), AX		
  0x43b1fa		48890424		MOVQ AX, 0(SP)			
  0x43b1fe		e8ad94feff		CALL runtime.printhex(SB)	
  0x43b203		e8488ffeff		CALL runtime.printnl(SB)	
  0x43b208		e8338dfeff		CALL runtime.printunlock(SB)	
			throw("no module data")
  0x43b20d		488d05c24b0300		LEAQ 0x34bc2(IP), AX	
  0x43b214		48890424		MOVQ AX, 0(SP)		
  0x43b218		48c74424080e000000	MOVQ $0xe, 0x8(SP)	
  0x43b221		e85a82feff		CALL runtime.throw(SB)	
  0x43b226		0f0b			UD2			
func pcvalue(f funcInfo, off int32, targetpc uintptr, cache *pcvalueCache, strict bool) int32 {
  0x43b228		e853c60000		CALL runtime.morestack_noctxt(SB)	
  0x43b22d		e94efaffff		JMP runtime.pcvalue(SB)			

TEXT runtime.funcname(SB) /usr/local/go/src/runtime/symtab.go
func funcname(f funcInfo) string {
  0x43b240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b249		483b6110		CMPQ 0x10(CX), SP	
  0x43b24d		0f8684000000		JBE 0x43b2d7		
  0x43b253		4883ec30		SUBQ $0x30, SP		
  0x43b257		48896c2428		MOVQ BP, 0x28(SP)	
  0x43b25c		488d6c2428		LEAQ 0x28(SP), BP	
	return gostringnocopy(cfuncname(f))
  0x43b261		90			NOPL			
	if !f.valid() || f.nameoff == 0 {
  0x43b262		90			NOPL			
	return gostringnocopy(cfuncname(f))
  0x43b263		488b442438		MOVQ 0x38(SP), AX	
	return f._func != nil
  0x43b268		4885c0			TESTQ AX, AX		
	if !f.valid() || f.nameoff == 0 {
  0x43b26b		7407			JE 0x43b274		
  0x43b26d		8b4008			MOVL 0x8(AX), AX	
  0x43b270		85c0			TESTL AX, AX		
  0x43b272		7546			JNE 0x43b2ba		
  0x43b274		31c0			XORL AX, AX		
	return gostringnocopy(cfuncname(f))
  0x43b276		4889442410		MOVQ AX, 0x10(SP)	
  0x43b27b		90			NOPL			
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x43b27c		48890424		MOVQ AX, 0(SP)			
  0x43b280		e87bedffff		CALL runtime.findnull(SB)	
  0x43b285		488b442408		MOVQ 0x8(SP), AX		
  0x43b28a		0f57c0			XORPS X0, X0			
  0x43b28d		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43b292		488b4c2410		MOVQ 0x10(SP), CX		
  0x43b297		48894c2418		MOVQ CX, 0x18(SP)		
  0x43b29c		4889442420		MOVQ AX, 0x20(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x43b2a1		488b4c2418		MOVQ 0x18(SP), CX	
	return gostringnocopy(cfuncname(f))
  0x43b2a6		48894c2448		MOVQ CX, 0x48(SP)	
  0x43b2ab		4889442450		MOVQ AX, 0x50(SP)	
  0x43b2b0		488b6c2428		MOVQ 0x28(SP), BP	
  0x43b2b5		4883c430		ADDQ $0x30, SP		
  0x43b2b9		c3			RET			
	return &f.datap.pclntable[f.nameoff]
  0x43b2ba		4863c0			MOVSXD AX, AX		
  0x43b2bd		488b4c2440		MOVQ 0x40(SP), CX	
  0x43b2c2		488b11			MOVQ 0(CX), DX		
  0x43b2c5		48394108		CMPQ AX, 0x8(CX)	
  0x43b2c9		7605			JBE 0x43b2d0		
  0x43b2cb		4801d0			ADDQ DX, AX		
	return gostringnocopy(cfuncname(f))
  0x43b2ce		eba6			JMP 0x43b276		
	return &f.datap.pclntable[f.nameoff]
  0x43b2d0		e84b6cfeff		CALL runtime.panicindex(SB)	
  0x43b2d5		0f0b			UD2				
func funcname(f funcInfo) string {
  0x43b2d7		e8a4c50000		CALL runtime.morestack_noctxt(SB)	
  0x43b2dc		e95fffffff		JMP runtime.funcname(SB)		

TEXT runtime.funcnameFromNameoff(SB) /usr/local/go/src/runtime/symtab.go
func funcnameFromNameoff(f funcInfo, nameoff int32) string {
  0x43b2f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b2f9		483b6110		CMPQ 0x10(CX), SP	
  0x43b2fd		0f868e000000		JBE 0x43b391		
  0x43b303		4883ec30		SUBQ $0x30, SP		
  0x43b307		48896c2428		MOVQ BP, 0x28(SP)	
  0x43b30c		488d6c2428		LEAQ 0x28(SP), BP	
	if !f.valid() {
  0x43b311		90			NOPL			
  0x43b312		488b442438		MOVQ 0x38(SP), AX	
	return f._func != nil
  0x43b317		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x43b31a		745c			JE 0x43b378		
	cstr := &datap.pclntable[nameoff]
  0x43b31c		8b442448		MOVL 0x48(SP), AX	
  0x43b320		4863c0			MOVSXD AX, AX		
  0x43b323		488b4c2440		MOVQ 0x40(SP), CX	
  0x43b328		488b11			MOVQ 0(CX), DX		
  0x43b32b		48394108		CMPQ AX, 0x8(CX)	
  0x43b32f		7659			JBE 0x43b38a		
  0x43b331		4801d0			ADDQ DX, AX		
  0x43b334		4889442410		MOVQ AX, 0x10(SP)	
	return gostringnocopy(cstr)
  0x43b339		90			NOPL			
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x43b33a		48890424		MOVQ AX, 0(SP)			
  0x43b33e		e8bdecffff		CALL runtime.findnull(SB)	
  0x43b343		488b442408		MOVQ 0x8(SP), AX		
  0x43b348		0f57c0			XORPS X0, X0			
  0x43b34b		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43b350		488b4c2410		MOVQ 0x10(SP), CX		
  0x43b355		48894c2418		MOVQ CX, 0x18(SP)		
  0x43b35a		4889442420		MOVQ AX, 0x20(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x43b35f		488b4c2418		MOVQ 0x18(SP), CX	
	return gostringnocopy(cstr)
  0x43b364		48894c2450		MOVQ CX, 0x50(SP)	
  0x43b369		4889442458		MOVQ AX, 0x58(SP)	
  0x43b36e		488b6c2428		MOVQ 0x28(SP), BP	
  0x43b373		4883c430		ADDQ $0x30, SP		
  0x43b377		c3			RET			
		return ""
  0x43b378		0f57c0			XORPS X0, X0		
  0x43b37b		0f11442450		MOVUPS X0, 0x50(SP)	
  0x43b380		488b6c2428		MOVQ 0x28(SP), BP	
  0x43b385		4883c430		ADDQ $0x30, SP		
  0x43b389		c3			RET			
	cstr := &datap.pclntable[nameoff]
  0x43b38a		e8916bfeff		CALL runtime.panicindex(SB)	
  0x43b38f		0f0b			UD2				
func funcnameFromNameoff(f funcInfo, nameoff int32) string {
  0x43b391		e8eac40000		CALL runtime.morestack_noctxt(SB)	
  0x43b396		e955ffffff		JMP runtime.funcnameFromNameoff(SB)	

TEXT runtime.funcline1(SB) /usr/local/go/src/runtime/symtab.go
func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32) {
  0x43b3a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b3a9		483b6110		CMPQ 0x10(CX), SP	
  0x43b3ad		0f86a7010000		JBE 0x43b55a		
  0x43b3b3		4883ec68		SUBQ $0x68, SP		
  0x43b3b7		48896c2460		MOVQ BP, 0x60(SP)	
  0x43b3bc		488d6c2460		LEAQ 0x60(SP), BP	
	if !f.valid() {
  0x43b3c1		90			NOPL			
  0x43b3c2		488b442470		MOVQ 0x70(SP), AX	
	return f._func != nil
  0x43b3c7		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x43b3ca		0f8453010000		JE 0x43b523		
	fileno := int(pcvalue(f, f.pcfile, targetpc, nil, strict))
  0x43b3d0		8b4818			MOVL 0x18(AX), CX		
  0x43b3d3		48890424		MOVQ AX, 0(SP)			
  0x43b3d7		488b542478		MOVQ 0x78(SP), DX		
  0x43b3dc		4889542408		MOVQ DX, 0x8(SP)		
  0x43b3e1		894c2410		MOVL CX, 0x10(SP)		
  0x43b3e5		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x43b3ed		48894c2418		MOVQ CX, 0x18(SP)		
  0x43b3f2		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43b3fb		0fb69c2488000000	MOVZX 0x88(SP), BX		
  0x43b403		885c2428		MOVB BL, 0x28(SP)		
  0x43b407		e874f8ffff		CALL runtime.pcvalue(SB)	
  0x43b40c		4863442430		MOVSXD 0x30(SP), AX		
  0x43b411		4889442440		MOVQ AX, 0x40(SP)		
	line = pcvalue(f, f.pcln, targetpc, nil, strict)
  0x43b416		488b4c2470		MOVQ 0x70(SP), CX		
  0x43b41b		8b511c			MOVL 0x1c(CX), DX		
  0x43b41e		48890c24		MOVQ CX, 0(SP)			
  0x43b422		488b4c2478		MOVQ 0x78(SP), CX		
  0x43b427		48894c2408		MOVQ CX, 0x8(SP)		
  0x43b42c		89542410		MOVL DX, 0x10(SP)		
  0x43b430		488b942480000000	MOVQ 0x80(SP), DX		
  0x43b438		4889542418		MOVQ DX, 0x18(SP)		
  0x43b43d		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43b446		0fb6942488000000	MOVZX 0x88(SP), DX		
  0x43b44e		88542428		MOVB DL, 0x28(SP)		
  0x43b452		e829f8ffff		CALL runtime.pcvalue(SB)	
  0x43b457		8b442430		MOVL 0x30(SP), AX		
	if fileno == -1 || line == -1 || fileno >= len(datap.filetab) {
  0x43b45b		488b4c2440		MOVQ 0x40(SP), CX	
  0x43b460		4883f9ff		CMPQ $-0x1, CX		
  0x43b464		7530			JNE 0x43b496		
		return "?", 0
  0x43b466		488d051e3c0300			LEAQ 0x33c1e(IP), AX	
  0x43b46d		4889842490000000		MOVQ AX, 0x90(SP)	
  0x43b475		48c784249800000001000000	MOVQ $0x1, 0x98(SP)	
  0x43b481		c78424a000000000000000		MOVL $0x0, 0xa0(SP)	
  0x43b48c		488b6c2460			MOVQ 0x60(SP), BP	
  0x43b491		4883c468			ADDQ $0x68, SP		
  0x43b495		c3				RET			
	if fileno == -1 || line == -1 || fileno >= len(datap.filetab) {
  0x43b496		83f8ff			CMPL $-0x1, AX		
  0x43b499		74cb			JE 0x43b466		
  0x43b49b		488b542478		MOVQ 0x78(SP), DX	
  0x43b4a0		488b5a38		MOVQ 0x38(DX), BX	
  0x43b4a4		488b7230		MOVQ 0x30(DX), SI	
  0x43b4a8		4839d9			CMPQ BX, CX		
  0x43b4ab		7db9			JGE 0x43b466		
	file = gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x43b4ad		488b5a08		MOVQ 0x8(DX), BX	
  0x43b4b1		488b12			MOVQ 0(DX), DX		
  0x43b4b4		0f8399000000		JAE 0x43b553		
  0x43b4ba		8b0c8e			MOVL 0(SI)(CX*4), CX	
  0x43b4bd		4839d9			CMPQ BX, CX		
  0x43b4c0		0f838d000000		JAE 0x43b553		
	line = pcvalue(f, f.pcln, targetpc, nil, strict)
  0x43b4c6		8944243c		MOVL AX, 0x3c(SP)	
	file = gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x43b4ca		90			NOPL			
  0x43b4cb		488d040a		LEAQ 0(DX)(CX*1), AX	
  0x43b4cf		4889442448		MOVQ AX, 0x48(SP)	
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x43b4d4		48890424		MOVQ AX, 0(SP)			
  0x43b4d8		e823ebffff		CALL runtime.findnull(SB)	
  0x43b4dd		488b442408		MOVQ 0x8(SP), AX		
  0x43b4e2		0f57c0			XORPS X0, X0			
  0x43b4e5		0f11442450		MOVUPS X0, 0x50(SP)		
  0x43b4ea		488b4c2448		MOVQ 0x48(SP), CX		
  0x43b4ef		48894c2450		MOVQ CX, 0x50(SP)		
  0x43b4f4		4889442458		MOVQ AX, 0x58(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x43b4f9		488b4c2450		MOVQ 0x50(SP), CX	
	return
  0x43b4fe		48898c2490000000	MOVQ CX, 0x90(SP)	
  0x43b506		4889842498000000	MOVQ AX, 0x98(SP)	
  0x43b50e		8b44243c		MOVL 0x3c(SP), AX	
  0x43b512		898424a0000000		MOVL AX, 0xa0(SP)	
  0x43b519		488b6c2460		MOVQ 0x60(SP), BP	
  0x43b51e		4883c468		ADDQ $0x68, SP		
  0x43b522		c3			RET			
		return "?", 0
  0x43b523		488d05613b0300			LEAQ 0x33b61(IP), AX	
  0x43b52a		4889842490000000		MOVQ AX, 0x90(SP)	
  0x43b532		48c784249800000001000000	MOVQ $0x1, 0x98(SP)	
  0x43b53e		c78424a000000000000000		MOVL $0x0, 0xa0(SP)	
  0x43b549		488b6c2460			MOVQ 0x60(SP), BP	
  0x43b54e		4883c468			ADDQ $0x68, SP		
  0x43b552		c3				RET			
	file = gostringnocopy(&datap.pclntable[datap.filetab[fileno]])
  0x43b553		e8c869feff		CALL runtime.panicindex(SB)	
  0x43b558		0f0b			UD2				
func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32) {
  0x43b55a		e821c30000		CALL runtime.morestack_noctxt(SB)	
  0x43b55f		e93cfeffff		JMP runtime.funcline1(SB)		

TEXT runtime.funcline(SB) /usr/local/go/src/runtime/symtab.go
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x43b570		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b579		483b6110		CMPQ 0x10(CX), SP	
  0x43b57d		765b			JBE 0x43b5da		
  0x43b57f		4883ec40		SUBQ $0x40, SP		
  0x43b583		48896c2438		MOVQ BP, 0x38(SP)	
  0x43b588		488d6c2438		LEAQ 0x38(SP), BP	
	return funcline1(f, targetpc, true)
  0x43b58d		488b442448		MOVQ 0x48(SP), AX		
  0x43b592		48890424		MOVQ AX, 0(SP)			
  0x43b596		488b442450		MOVQ 0x50(SP), AX		
  0x43b59b		4889442408		MOVQ AX, 0x8(SP)		
  0x43b5a0		488b442458		MOVQ 0x58(SP), AX		
  0x43b5a5		4889442410		MOVQ AX, 0x10(SP)		
  0x43b5aa		c644241801		MOVB $0x1, 0x18(SP)		
  0x43b5af		e8ecfdffff		CALL runtime.funcline1(SB)	
  0x43b5b4		488b442428		MOVQ 0x28(SP), AX		
  0x43b5b9		488b4c2420		MOVQ 0x20(SP), CX		
  0x43b5be		8b542430		MOVL 0x30(SP), DX		
  0x43b5c2		48894c2460		MOVQ CX, 0x60(SP)		
  0x43b5c7		4889442468		MOVQ AX, 0x68(SP)		
  0x43b5cc		89542470		MOVL DX, 0x70(SP)		
  0x43b5d0		488b6c2438		MOVQ 0x38(SP), BP		
  0x43b5d5		4883c440		ADDQ $0x40, SP			
  0x43b5d9		c3			RET				
func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {
  0x43b5da		e8a1c20000		CALL runtime.morestack_noctxt(SB)	
  0x43b5df		eb8f			JMP runtime.funcline(SB)		

TEXT runtime.funcspdelta(SB) /usr/local/go/src/runtime/symtab.go
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x43b5f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b5f9		483b6110		CMPQ 0x10(CX), SP	
  0x43b5fd		0f8648010000		JBE 0x43b74b		
  0x43b603		4883ec68		SUBQ $0x68, SP		
  0x43b607		48896c2460		MOVQ BP, 0x60(SP)	
  0x43b60c		488d6c2460		LEAQ 0x60(SP), BP	
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x43b611		488b442470		MOVQ 0x70(SP), AX		
  0x43b616		8b4814			MOVL 0x14(AX), CX		
  0x43b619		48890424		MOVQ AX, 0(SP)			
  0x43b61d		488b542478		MOVQ 0x78(SP), DX		
  0x43b622		4889542408		MOVQ DX, 0x8(SP)		
  0x43b627		894c2410		MOVL CX, 0x10(SP)		
  0x43b62b		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x43b633		48894c2418		MOVQ CX, 0x18(SP)		
  0x43b638		488b9c2488000000	MOVQ 0x88(SP), BX		
  0x43b640		48895c2420		MOVQ BX, 0x20(SP)		
  0x43b645		c644242801		MOVB $0x1, 0x28(SP)		
  0x43b64a		e831f6ffff		CALL runtime.pcvalue(SB)	
  0x43b64f		8b442430		MOVL 0x30(SP), AX		
	if x&(sys.PtrSize-1) != 0 {
  0x43b653		a907000000		TESTL $0x7, AX		
  0x43b658		7511			JNE 0x43b66b		
	return x
  0x43b65a		89842490000000		MOVL AX, 0x90(SP)	
  0x43b661		488b6c2460		MOVQ 0x60(SP), BP	
  0x43b666		4883c468		ADDQ $0x68, SP		
  0x43b66a		c3			RET			
	x := pcvalue(f, f.pcsp, targetpc, cache, true)
  0x43b66b		8944243c		MOVL AX, 0x3c(SP)	
		print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")
  0x43b66f		488b442470		MOVQ 0x70(SP), AX		
  0x43b674		48890424		MOVQ AX, 0(SP)			
  0x43b678		488b4c2478		MOVQ 0x78(SP), CX		
  0x43b67d		48894c2408		MOVQ CX, 0x8(SP)		
  0x43b682		e8b9fbffff		CALL runtime.funcname(SB)	
  0x43b687		488b442418		MOVQ 0x18(SP), AX		
  0x43b68c		4889442450		MOVQ AX, 0x50(SP)		
  0x43b691		488b4c2410		MOVQ 0x10(SP), CX		
  0x43b696		48894c2458		MOVQ CX, 0x58(SP)		
  0x43b69b		488b542470		MOVQ 0x70(SP), DX		
  0x43b6a0		488b1a			MOVQ 0(DX), BX			
  0x43b6a3		48895c2448		MOVQ BX, 0x48(SP)		
  0x43b6a8		48635214		MOVSXD 0x14(DX), DX		
  0x43b6ac		4889542440		MOVQ DX, 0x40(SP)		
  0x43b6b1		e80a88feff		CALL runtime.printlock(SB)	
  0x43b6b6		488d055a490300		LEAQ 0x3495a(IP), AX		
  0x43b6bd		48890424		MOVQ AX, 0(SP)			
  0x43b6c1		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x43b6ca		e82191feff		CALL runtime.printstring(SB)	
  0x43b6cf		488b442458		MOVQ 0x58(SP), AX		
  0x43b6d4		48890424		MOVQ AX, 0(SP)			
  0x43b6d8		488b442450		MOVQ 0x50(SP), AX		
  0x43b6dd		4889442408		MOVQ AX, 0x8(SP)		
  0x43b6e2		e80991feff		CALL runtime.printstring(SB)	
  0x43b6e7		e8148afeff		CALL runtime.printsp(SB)	
  0x43b6ec		488b442448		MOVQ 0x48(SP), AX		
  0x43b6f1		48890424		MOVQ AX, 0(SP)			
  0x43b6f5		e8b68ffeff		CALL runtime.printhex(SB)	
  0x43b6fa		e8018afeff		CALL runtime.printsp(SB)	
  0x43b6ff		488b842480000000	MOVQ 0x80(SP), AX		
  0x43b707		48890424		MOVQ AX, 0(SP)			
  0x43b70b		e8a08ffeff		CALL runtime.printhex(SB)	
  0x43b710		e8eb89feff		CALL runtime.printsp(SB)	
  0x43b715		488b442440		MOVQ 0x40(SP), AX		
  0x43b71a		48890424		MOVQ AX, 0(SP)			
  0x43b71e		e88d8ffeff		CALL runtime.printhex(SB)	
  0x43b723		e8d889feff		CALL runtime.printsp(SB)	
  0x43b728		8b44243c		MOVL 0x3c(SP), AX		
  0x43b72c		4863c8			MOVSXD AX, CX			
  0x43b72f		48890c24		MOVQ CX, 0(SP)			
  0x43b733		e8088ffeff		CALL runtime.printint(SB)	
  0x43b738		e8138afeff		CALL runtime.printnl(SB)	
  0x43b73d		e8fe87feff		CALL runtime.printunlock(SB)	
	return x
  0x43b742		8b44243c		MOVL 0x3c(SP), AX	
		print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")
  0x43b746		e90fffffff		JMP 0x43b65a		
func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32 {
  0x43b74b		e830c10000		CALL runtime.morestack_noctxt(SB)	
  0x43b750		e99bfeffff		JMP runtime.funcspdelta(SB)		

TEXT runtime.pcdatavalue(SB) /usr/local/go/src/runtime/symtab.go
func pcdatavalue(f funcInfo, table int32, targetpc uintptr, cache *pcvalueCache) int32 {
  0x43b760		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b769		483b6110		CMPQ 0x10(CX), SP	
  0x43b76d		0f8687000000		JBE 0x43b7fa		
  0x43b773		4883ec40		SUBQ $0x40, SP		
  0x43b777		48896c2438		MOVQ BP, 0x38(SP)	
  0x43b77c		488d6c2438		LEAQ 0x38(SP), BP	
	if table < 0 || table >= f.npcdata {
  0x43b781		8b442458		MOVL 0x58(SP), AX	
  0x43b785		85c0			TESTL AX, AX		
  0x43b787		7d12			JGE 0x43b79b		
		return -1
  0x43b789		c7442470ffffffff	MOVL $-0x1, 0x70(SP)	
  0x43b791		488b6c2438		MOVQ 0x38(SP), BP	
  0x43b796		4883c440		ADDQ $0x40, SP		
  0x43b79a		c3			RET			
	if table < 0 || table >= f.npcdata {
  0x43b79b		488b4c2448		MOVQ 0x48(SP), CX	
  0x43b7a0		394120			CMPL AX, 0x20(CX)	
  0x43b7a3		7ee4			JLE 0x43b789		
	return *(*int32)(add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))
  0x43b7a5		488d5127		LEAQ 0x27(CX), DX	
  0x43b7a9		4863c0			MOVSXD AX, AX		
	return unsafe.Pointer(uintptr(p) + x)
  0x43b7ac		488d0482		LEAQ 0(DX)(AX*4), AX	
  0x43b7b0		488d4001		LEAQ 0x1(AX), AX	
	return pcvalue(f, pcdatastart(f, table), targetpc, cache, true)
  0x43b7b4		90			NOPL			
	return *(*int32)(add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))
  0x43b7b5		8b00			MOVL 0(AX), AX		
  0x43b7b7		90			NOPL			
	return pcvalue(f, pcdatastart(f, table), targetpc, cache, true)
  0x43b7b8		48890c24		MOVQ CX, 0(SP)			
  0x43b7bc		488b4c2450		MOVQ 0x50(SP), CX		
  0x43b7c1		48894c2408		MOVQ CX, 0x8(SP)		
  0x43b7c6		89442410		MOVL AX, 0x10(SP)		
  0x43b7ca		488b442460		MOVQ 0x60(SP), AX		
  0x43b7cf		4889442418		MOVQ AX, 0x18(SP)		
  0x43b7d4		488b442468		MOVQ 0x68(SP), AX		
  0x43b7d9		4889442420		MOVQ AX, 0x20(SP)		
  0x43b7de		c644242801		MOVB $0x1, 0x28(SP)		
  0x43b7e3		e898f4ffff		CALL runtime.pcvalue(SB)	
  0x43b7e8		8b442430		MOVL 0x30(SP), AX		
  0x43b7ec		89442470		MOVL AX, 0x70(SP)		
  0x43b7f0		488b6c2438		MOVQ 0x38(SP), BP		
  0x43b7f5		4883c440		ADDQ $0x40, SP			
  0x43b7f9		c3			RET				
func pcdatavalue(f funcInfo, table int32, targetpc uintptr, cache *pcvalueCache) int32 {
  0x43b7fa		e881c00000		CALL runtime.morestack_noctxt(SB)	
  0x43b7ff		e95cffffff		JMP runtime.pcdatavalue(SB)		

TEXT runtime.funcdata(SB) /usr/local/go/src/runtime/symtab.go
func funcdata(f funcInfo, i uint8) unsafe.Pointer {
  0x43b810		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b819		483b6110		CMPQ 0x10(CX), SP	
  0x43b81d		0f86b9000000		JBE 0x43b8dc		
  0x43b823		4883ec20		SUBQ $0x20, SP		
  0x43b827		48896c2418		MOVQ BP, 0x18(SP)	
  0x43b82c		488d6c2418		LEAQ 0x18(SP), BP	
	if i < 0 || i >= f.nfuncdata {
  0x43b831		0fb6442438		MOVZX 0x38(SP), AX	
  0x43b836		84c0			TESTL AL, AL		
  0x43b838		7313			JAE 0x43b84d		
		return nil
  0x43b83a		48c744244000000000	MOVQ $0x0, 0x40(SP)	
  0x43b843		488b6c2418		MOVQ 0x18(SP), BP	
  0x43b848		4883c420		ADDQ $0x20, SP		
  0x43b84c		c3			RET			
	if i < 0 || i >= f.nfuncdata {
  0x43b84d		488b4c2428		MOVQ 0x28(SP), CX	
  0x43b852		384127			CMPB AL, 0x27(CX)	
  0x43b855		76e3			JBE 0x43b83a		
  0x43b857		488d5127		LEAQ 0x27(CX), DX	
	p := add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(f.npcdata)*4)
  0x43b85b		90			NOPL			
  0x43b85c		48635920		MOVSXD 0x20(CX), BX	
	return unsafe.Pointer(uintptr(p) + x)
  0x43b860		488d149a		LEAQ 0(DX)(BX*4), DX	
  0x43b864		488d5201		LEAQ 0x1(DX), DX	
  0x43b868		4889d3			MOVQ DX, BX		
	if sys.PtrSize == 8 && uintptr(p)&4 != 0 {
  0x43b86b		0fbae302		BTL $0x2, BX		
  0x43b86f		7366			JAE 0x43b8d7		
		if uintptr(unsafe.Pointer(f._func))&4 != 0 {
  0x43b871		0fbae102		BTL $0x2, CX		
  0x43b875		7219			JB 0x43b890		
		p = add(p, 4)
  0x43b877		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x43b878		488d4a04		LEAQ 0x4(DX), CX	
	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
  0x43b87c		488b04c1		MOVQ 0(CX)(AX*8), AX	
  0x43b880		90			NOPL			
  0x43b881		4889442440		MOVQ AX, 0x40(SP)	
  0x43b886		488b6c2418		MOVQ 0x18(SP), BP	
  0x43b88b		4883c420		ADDQ $0x20, SP		
  0x43b88f		c3			RET			
	return unsafe.Pointer(uintptr(p) + x)
  0x43b890		4889542410		MOVQ DX, 0x10(SP)	
			println("runtime: misaligned func", f._func)
  0x43b895		e82686feff		CALL runtime.printlock(SB)	
  0x43b89a		488d0540580300		LEAQ 0x35840(IP), AX		
  0x43b8a1		48890424		MOVQ AX, 0(SP)			
  0x43b8a5		48c744240819000000	MOVQ $0x19, 0x8(SP)		
  0x43b8ae		e83d8ffeff		CALL runtime.printstring(SB)	
  0x43b8b3		488b442428		MOVQ 0x28(SP), AX		
  0x43b8b8		48890424		MOVQ AX, 0(SP)			
  0x43b8bc		e8ef8efeff		CALL runtime.printpointer(SB)	
  0x43b8c1		e88a88feff		CALL runtime.printnl(SB)	
  0x43b8c6		e87586feff		CALL runtime.printunlock(SB)	
	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
  0x43b8cb		0fb6442438		MOVZX 0x38(SP), AX	
	return unsafe.Pointer(uintptr(p) + x)
  0x43b8d0		488b542410		MOVQ 0x10(SP), DX	
			println("runtime: misaligned func", f._func)
  0x43b8d5		eba0			JMP 0x43b877		
	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
  0x43b8d7		4889d1			MOVQ DX, CX		
	if sys.PtrSize == 8 && uintptr(p)&4 != 0 {
  0x43b8da		eba0			JMP 0x43b87c		
func funcdata(f funcInfo, i uint8) unsafe.Pointer {
  0x43b8dc		e89fbf0000		CALL runtime.morestack_noctxt(SB)	
  0x43b8e1		e92affffff		JMP runtime.funcdata(SB)		

TEXT runtime.step(SB) /usr/local/go/src/runtime/symtab.go
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x43b8f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43b8f9		483b6110		CMPQ 0x10(CX), SP	
  0x43b8fd		0f8687010000		JBE 0x43ba8a		
  0x43b903		4883ec30		SUBQ $0x30, SP		
  0x43b907		48896c2428		MOVQ BP, 0x28(SP)	
  0x43b90c		488d6c2428		LEAQ 0x28(SP), BP	
	uvdelta := uint32(p[0])
  0x43b911		488b442440		MOVQ 0x40(SP), AX	
  0x43b916		4885c0			TESTQ AX, AX		
  0x43b919		0f8664010000		JBE 0x43ba83		
  0x43b91f		488b4c2438		MOVQ 0x38(SP), CX	
  0x43b924		0fb611			MOVZX 0(CX), DX		
	if uvdelta == 0 && !first {
  0x43b927		85d2			TESTL DX, DX		
  0x43b929		750d			JNE 0x43b938		
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x43b92b		0fb65c2460		MOVZX 0x60(SP), BX	
  0x43b930		84db			TESTL BL, BL		
	if uvdelta == 0 && !first {
  0x43b932		0f8413010000		JE 0x43ba4b		
	if uvdelta&0x80 != 0 {
  0x43b938		0fbae207		BTL $0x7, DX		
  0x43b93c		0f82da000000		JB 0x43ba1c		
  0x43b942		bb01000000		MOVL $0x1, BX		
	*val += int32(-(uvdelta & 1) ^ (uvdelta >> 1))
  0x43b947		89d6			MOVL DX, SI		
  0x43b949		83e201			ANDL $0x1, DX		
  0x43b94c		f7da			NEGL DX			
  0x43b94e		d1ee			SHRL $0x1, SI		
  0x43b950		31f2			XORL SI, DX		
  0x43b952		488b742458		MOVQ 0x58(SP), SI	
  0x43b957		0116			ADDL DX, 0(SI)		
	p = p[n:]
  0x43b959		4839c3			CMPQ AX, BX		
  0x43b95c		0f871a010000		JA 0x43ba7c		
  0x43b962		4829d8			SUBQ BX, AX		
  0x43b965		488b542448		MOVQ 0x48(SP), DX	
  0x43b96a		4829da			SUBQ BX, DX		
  0x43b96d		4889d6			MOVQ DX, SI		
  0x43b970		48f7da			NEGQ DX			
  0x43b973		48c1fa3f		SARQ $0x3f, DX		
  0x43b977		4821d3			ANDQ DX, BX		
  0x43b97a		488d1419		LEAQ 0(CX)(BX*1), DX	
	pcdelta := uint32(p[0])
  0x43b97e		4885c0			TESTQ AX, AX		
  0x43b981		0f86ee000000		JBE 0x43ba75		
  0x43b987		0fb60c19		MOVZX 0(CX)(BX*1), CX	
	if pcdelta&0x80 != 0 {
  0x43b98b		0fbae107		BTL $0x7, CX		
  0x43b98f		724d			JB 0x43b9de		
  0x43b991		bb01000000		MOVL $0x1, BX		
	p = p[n:]
  0x43b996		4839c3			CMPQ AX, BX		
  0x43b999		0f87cf000000		JA 0x43ba6e		
	*pc += uintptr(pcdelta * sys.PCQuantum)
  0x43b99f		488b7c2450		MOVQ 0x50(SP), DI	
  0x43b9a4		48010f			ADDQ CX, 0(DI)		
	p = p[n:]
  0x43b9a7		4829de			SUBQ BX, SI		
  0x43b9aa		4889f1			MOVQ SI, CX		
  0x43b9ad		48f7de			NEGQ SI			
  0x43b9b0		48c1fe3f		SARQ $0x3f, SI		
  0x43b9b4		4821de			ANDQ BX, SI		
  0x43b9b7		4801f2			ADDQ SI, DX		
	return p, true
  0x43b9ba		4889542468		MOVQ DX, 0x68(SP)	
	p = p[n:]
  0x43b9bf		4829d8			SUBQ BX, AX		
	return p, true
  0x43b9c2		4889442470		MOVQ AX, 0x70(SP)	
  0x43b9c7		48894c2478		MOVQ CX, 0x78(SP)	
  0x43b9cc		c684248000000001	MOVB $0x1, 0x80(SP)	
  0x43b9d4		488b6c2428		MOVQ 0x28(SP), BP	
  0x43b9d9		4883c430		ADDQ $0x30, SP		
  0x43b9dd		c3			RET			
	p = p[n:]
  0x43b9de		4889442440		MOVQ AX, 0x40(SP)	
  0x43b9e3		4889742420		MOVQ SI, 0x20(SP)	
  0x43b9e8		4889542438		MOVQ DX, 0x38(SP)	
		n, pcdelta = readvarint(p)
  0x43b9ed		48891424		MOVQ DX, 0(SP)			
  0x43b9f1		4889442408		MOVQ AX, 0x8(SP)		
  0x43b9f6		4889742410		MOVQ SI, 0x10(SP)		
  0x43b9fb		e8a0000000		CALL runtime.readvarint(SB)	
  0x43ba00		8b5c2418		MOVL 0x18(SP), BX		
  0x43ba04		8b4c241c		MOVL 0x1c(SP), CX		
	p = p[n:]
  0x43ba08		488b442440		MOVQ 0x40(SP), AX	
  0x43ba0d		488b542438		MOVQ 0x38(SP), DX	
  0x43ba12		488b742420		MOVQ 0x20(SP), SI	
		n, pcdelta = readvarint(p)
  0x43ba17		e97affffff		JMP 0x43b996		
		n, uvdelta = readvarint(p)
  0x43ba1c		48890c24		MOVQ CX, 0(SP)			
  0x43ba20		4889442408		MOVQ AX, 0x8(SP)		
  0x43ba25		488b542448		MOVQ 0x48(SP), DX		
  0x43ba2a		4889542410		MOVQ DX, 0x10(SP)		
  0x43ba2f		e86c000000		CALL runtime.readvarint(SB)	
  0x43ba34		8b5c2418		MOVL 0x18(SP), BX		
  0x43ba38		8b54241c		MOVL 0x1c(SP), DX		
	p = p[n:]
  0x43ba3c		488b442440		MOVQ 0x40(SP), AX	
  0x43ba41		488b4c2438		MOVQ 0x38(SP), CX	
		n, uvdelta = readvarint(p)
  0x43ba46		e9fcfeffff		JMP 0x43b947		
		return nil, false
  0x43ba4b		48c744246800000000	MOVQ $0x0, 0x68(SP)	
  0x43ba54		0f57c0			XORPS X0, X0		
  0x43ba57		0f11442470		MOVUPS X0, 0x70(SP)	
  0x43ba5c		c684248000000000	MOVB $0x0, 0x80(SP)	
  0x43ba64		488b6c2428		MOVQ 0x28(SP), BP	
  0x43ba69		4883c430		ADDQ $0x30, SP		
  0x43ba6d		c3			RET			
	p = p[n:]
  0x43ba6e		e8dd65feff		CALL runtime.panicslice(SB)	
  0x43ba73		0f0b			UD2				
	pcdelta := uint32(p[0])
  0x43ba75		e8a664feff		CALL runtime.panicindex(SB)	
  0x43ba7a		0f0b			UD2				
	p = p[n:]
  0x43ba7c		e8cf65feff		CALL runtime.panicslice(SB)	
  0x43ba81		0f0b			UD2				
	uvdelta := uint32(p[0])
  0x43ba83		e89864feff		CALL runtime.panicindex(SB)	
  0x43ba88		0f0b			UD2				
func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
  0x43ba8a		e8f1bd0000		CALL runtime.morestack_noctxt(SB)	
  0x43ba8f		e95cfeffff		JMP runtime.step(SB)			

TEXT runtime.readvarint(SB) /usr/local/go/src/runtime/symtab.go
func readvarint(p []byte) (read uint32, val uint32) {
  0x43baa0		4883ec08		SUBQ $0x8, SP		
  0x43baa4		48892c24		MOVQ BP, 0(SP)		
  0x43baa8		488d2c24		LEAQ 0(SP), BP		
	for {
  0x43baac		488b442410		MOVQ 0x10(SP), AX	
  0x43bab1		488b542418		MOVQ 0x18(SP), DX	
  0x43bab6		31c9			XORL CX, CX		
  0x43bab8		31db			XORL BX, BX		
  0x43baba		31f6			XORL SI, SI		
  0x43babc		eb06			JMP 0x43bac4		
		shift += 7
  0x43babe		8d7107			LEAL 0x7(CX), SI	
		b := p[n]
  0x43bac1		4489c1			MOVL R8, CX		
  0x43bac4		4839d1			CMPQ DX, CX		
  0x43bac7		732c			JAE 0x43baf5		
  0x43bac9		0fb63c08		MOVZX 0(AX)(CX*1), DI	
		n++
  0x43bacd		448d4101		LEAL 0x1(CX), R8	
		v |= uint32(b&0x7F) << (shift & 31)
  0x43bad1		4189f9			MOVL DI, R9		
  0x43bad4		83e77f			ANDL $0x7f, DI		
  0x43bad7		89f1			MOVL SI, CX		
  0x43bad9		d3e7			SHLL CL, DI		
  0x43badb		09fb			ORL DI, BX		
		if b&0x80 == 0 {
  0x43badd		41f6c180		TESTL $0x80, R9		
  0x43bae1		75db			JNE 0x43babe		
	return n, v
  0x43bae3		4489442428		MOVL R8, 0x28(SP)	
  0x43bae8		895c242c		MOVL BX, 0x2c(SP)	
  0x43baec		488b2c24		MOVQ 0(SP), BP		
  0x43baf0		4883c408		ADDQ $0x8, SP		
  0x43baf4		c3			RET			
		b := p[n]
  0x43baf5		e82664feff		CALL runtime.panicindex(SB)	
  0x43bafa		0f0b			UD2				

TEXT runtime.timejump(SB) /usr/local/go/src/runtime/time.go
func timejump() *g {
  0x43bb00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bb09		483b6110		CMPQ 0x10(CX), SP	
  0x43bb0d		0f86b0000000		JBE 0x43bbc3		
  0x43bb13		4883ec28		SUBQ $0x28, SP		
  0x43bb17		48896c2420		MOVQ BP, 0x20(SP)	
  0x43bb1c		488d6c2420		LEAQ 0x20(SP), BP	
	if faketime == 0 {
  0x43bb21		48833d3f120a0000	CMPQ $0x0, runtime.faketime(SB)	
  0x43bb29		0f8481000000		JE 0x43bbb0			
  0x43bb2f		31c0			XORL AX, AX			
	for i := range timers {
  0x43bb31		eb25			JMP 0x43bb58		
  0x43bb33		4889442410		MOVQ AX, 0x10(SP)	
		lock(&timers[i].lock)
  0x43bb38		48c1e007		SHLQ $0x7, AX			
  0x43bb3c		488d15fd8a0800		LEAQ runtime.timers(SB), DX	
  0x43bb43		488d0410		LEAQ 0(AX)(DX*1), AX		
  0x43bb47		48890424		MOVQ AX, 0(SP)			
  0x43bb4b		e890cbfcff		CALL runtime.lock(SB)		
	for i := range timers {
  0x43bb50		488b442410		MOVQ 0x10(SP), AX	
  0x43bb55		48ffc0			INCQ AX			
  0x43bb58		4883f840		CMPQ $0x40, AX		
  0x43bb5c		7cd5			JL 0x43bb33		
	gp := timejumpLocked()
  0x43bb5e		e86d000000		CALL runtime.timejumpLocked(SB)	
  0x43bb63		488b0424		MOVQ 0(SP), AX			
  0x43bb67		4889442418		MOVQ AX, 0x18(SP)		
  0x43bb6c		31c9			XORL CX, CX			
	for i := range timers {
  0x43bb6e		eb2b			JMP 0x43bb9b		
  0x43bb70		48894c2408		MOVQ CX, 0x8(SP)	
		unlock(&timers[i].lock)
  0x43bb75		48c1e107		SHLQ $0x7, CX			
  0x43bb79		488d15c08a0800		LEAQ runtime.timers(SB), DX	
  0x43bb80		488d0c11		LEAQ 0(CX)(DX*1), CX		
  0x43bb84		48890c24		MOVQ CX, 0(SP)			
  0x43bb88		e803cdfcff		CALL runtime.unlock(SB)		
	for i := range timers {
  0x43bb8d		488b442408		MOVQ 0x8(SP), AX	
  0x43bb92		488d4801		LEAQ 0x1(AX), CX	
	return gp
  0x43bb96		488b442418		MOVQ 0x18(SP), AX	
	for i := range timers {
  0x43bb9b		4883f940		CMPQ $0x40, CX		
  0x43bb9f		7ccf			JL 0x43bb70		
	return gp
  0x43bba1		4889442430		MOVQ AX, 0x30(SP)	
  0x43bba6		488b6c2420		MOVQ 0x20(SP), BP	
  0x43bbab		4883c428		ADDQ $0x28, SP		
  0x43bbaf		c3			RET			
		return nil
  0x43bbb0		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x43bbb9		488b6c2420		MOVQ 0x20(SP), BP	
  0x43bbbe		4883c428		ADDQ $0x28, SP		
  0x43bbc2		c3			RET			
func timejump() *g {
  0x43bbc3		e8b8bc0000		CALL runtime.morestack_noctxt(SB)	
  0x43bbc8		e933ffffff		JMP runtime.timejump(SB)		

TEXT runtime.timejumpLocked(SB) /usr/local/go/src/runtime/time.go
func timejumpLocked() *g {
  0x43bbd0		31c0			XORL AX, AX		
  0x43bbd2		31c9			XORL CX, CX		
	for i := range timers {
  0x43bbd4		eb04			JMP 0x43bbda		
  0x43bbd6		488d4201		LEAQ 0x1(DX), AX	
  0x43bbda		4883f840		CMPQ $0x40, AX		
  0x43bbde		7d46			JGE 0x43bc26		
		tb := &timers[i]
  0x43bbe0		4889c2			MOVQ AX, DX		
  0x43bbe3		48c1e007		SHLQ $0x7, AX		
		if !tb.created || len(tb.t) == 0 {
  0x43bbe7		488d1d528a0800		LEAQ runtime.timers(SB), BX	
  0x43bbee		488d3403		LEAQ 0(BX)(AX*1), SI		
  0x43bbf2		488d7610		LEAQ 0x10(SI), SI		
  0x43bbf6		803e00			CMPB $0x0, 0(SI)		
  0x43bbf9		74db			JE 0x43bbd6			
  0x43bbfb		488b740328		MOVQ 0x28(BX)(AX*1), SI		
  0x43bc00		488b440330		MOVQ 0x30(BX)(AX*1), AX		
  0x43bc05		4885c0			TESTQ AX, AX			
  0x43bc08		74cc			JE 0x43bbd6			
		t := tb.t[0]
  0x43bc0a		488b06			MOVQ 0(SI), AX		
		if minT == nil || t.when < minT.when {
  0x43bc0d		4885c9			TESTQ CX, CX		
  0x43bc10		740a			JE 0x43bc1c		
  0x43bc12		488b7110		MOVQ 0x10(CX), SI	
  0x43bc16		48397010		CMPQ SI, 0x10(AX)	
  0x43bc1a		7d05			JGE 0x43bc21		
  0x43bc1c		4889c1			MOVQ AX, CX		
	for i := range timers {
  0x43bc1f		ebb5			JMP 0x43bbd6		
		if minT == nil || t.when < minT.when {
  0x43bc21		4889c8			MOVQ CX, AX		
	for i := range timers {
  0x43bc24		ebf6			JMP 0x43bc1c		
	if minT == nil || minT.when <= faketime {
  0x43bc26		4885c9			TESTQ CX, CX			
  0x43bc29		740d			JE 0x43bc38			
  0x43bc2b		488b4110		MOVQ 0x10(CX), AX		
  0x43bc2f		48390532110a00		CMPQ AX, runtime.faketime(SB)	
  0x43bc36		7c0a			JL 0x43bc42			
		return nil
  0x43bc38		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x43bc41		c3			RET			
	faketime = minT.when
  0x43bc42		4889051f110a00		MOVQ AX, runtime.faketime(SB)	
	tb := minT.tb
  0x43bc49		488b01			MOVQ 0(CX), AX		
	if !tb.rescheduling {
  0x43bc4c		80781200		CMPB $0x0, 0x12(AX)	
  0x43bc50		740e			JE 0x43bc60		
	tb.rescheduling = false
  0x43bc52		c6401200		MOVB $0x0, 0x12(AX)	
	return tb.gp
  0x43bc56		488b4008		MOVQ 0x8(AX), AX	
  0x43bc5a		4889442408		MOVQ AX, 0x8(SP)	
  0x43bc5f		c3			RET			
		return nil
  0x43bc60		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x43bc69		c3			RET			

TEXT time.now(SB) /usr/local/go/src/runtime/timestub.go
func time_now() (sec int64, nsec int32, mono int64) {
  0x43bc70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bc79		483b6110		CMPQ 0x10(CX), SP	
  0x43bc7d		764e			JBE 0x43bccd		
  0x43bc7f		4883ec28		SUBQ $0x28, SP		
  0x43bc83		48896c2420		MOVQ BP, 0x20(SP)	
  0x43bc88		488d6c2420		LEAQ 0x20(SP), BP	
	sec, nsec = walltime()
  0x43bc8d		e85ef30000		CALL runtime.walltime(SB)	
  0x43bc92		488b0424		MOVQ 0(SP), AX			
  0x43bc96		4889442418		MOVQ AX, 0x18(SP)		
  0x43bc9b		8b4c2408		MOVL 0x8(SP), CX		
  0x43bc9f		894c2414		MOVL CX, 0x14(SP)		
	return sec, nsec, nanotime()
  0x43bca3		e808f40000		CALL runtime.nanotime(SB)	
  0x43bca8		488b0424		MOVQ 0(SP), AX			
  0x43bcac		488b4c2418		MOVQ 0x18(SP), CX		
  0x43bcb1		48894c2430		MOVQ CX, 0x30(SP)		
  0x43bcb6		8b4c2414		MOVL 0x14(SP), CX		
  0x43bcba		894c2438		MOVL CX, 0x38(SP)		
  0x43bcbe		4889442440		MOVQ AX, 0x40(SP)		
  0x43bcc3		488b6c2420		MOVQ 0x20(SP), BP		
  0x43bcc8		4883c428		ADDQ $0x28, SP			
  0x43bccc		c3			RET				
func time_now() (sec int64, nsec int32, mono int64) {
  0x43bccd		e8aebb0000		CALL runtime.morestack_noctxt(SB)	
  0x43bcd2		eb9c			JMP time.now(SB)			

TEXT runtime.traceReader(SB) /usr/local/go/src/runtime/trace.go
func traceReader() *g {
  0x43bce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bce9		483b6110		CMPQ 0x10(CX), SP	
  0x43bced		0f86dd000000		JBE 0x43bdd0		
  0x43bcf3		4883ec18		SUBQ $0x18, SP		
  0x43bcf7		48896c2410		MOVQ BP, 0x10(SP)	
  0x43bcfc		488d6c2410		LEAQ 0x10(SP), BP	
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bd01		48833d1f0f090000	CMPQ $0x0, runtime.trace+104(SB)	
  0x43bd09		7513			JNE 0x43bd1e				
		return nil
  0x43bd0b		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x43bd14		488b6c2410		MOVQ 0x10(SP), BP	
  0x43bd19		4883c418		ADDQ $0x18, SP		
  0x43bd1d		c3			RET			
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bd1e		48833df20e090000	CMPQ $0x0, runtime.trace+88(SB)	
  0x43bd26		0f859d000000		JNE 0x43bdc9			
  0x43bd2c		0fb6059e0e0900		MOVZX runtime.trace+17(SB), AX	
  0x43bd33		83f001			XORL $0x1, AX			
  0x43bd36		84c0			TESTL AL, AL			
  0x43bd38		75d1			JNE 0x43bd0b			
	lock(&trace.lock)
  0x43bd3a		488d057f0e0900		LEAQ runtime.trace(SB), AX	
  0x43bd41		48890424		MOVQ AX, 0(SP)			
  0x43bd45		e896c9fcff		CALL runtime.lock(SB)		
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bd4a		488b05d70e0900		MOVQ runtime.trace+104(SB), AX	
  0x43bd51		4885c0			TESTQ AX, AX			
  0x43bd54		7523			JNE 0x43bd79			
		unlock(&trace.lock)
  0x43bd56		488d05630e0900		LEAQ runtime.trace(SB), AX	
  0x43bd5d		48890424		MOVQ AX, 0(SP)			
  0x43bd61		e82acbfcff		CALL runtime.unlock(SB)		
		return nil
  0x43bd66		48c744242000000000	MOVQ $0x0, 0x20(SP)	
  0x43bd6f		488b6c2410		MOVQ 0x10(SP), BP	
  0x43bd74		4883c418		ADDQ $0x18, SP		
  0x43bd78		c3			RET			
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bd79		48833d970e090000	CMPQ $0x0, runtime.trace+88(SB)	
  0x43bd81		7542			JNE 0x43bdc5			
  0x43bd83		0fb60d470e0900		MOVZX runtime.trace+17(SB), CX	
  0x43bd8a		83f101			XORL $0x1, CX			
  0x43bd8d		84c9			TESTL CL, CL			
  0x43bd8f		75c5			JNE 0x43bd56			
	gp := trace.reader.ptr()
  0x43bd91		90			NOPL			
	trace.reader.set(nil)
  0x43bd92		90			NOPL			
func (gp guintptr) ptr() *g { return (*g)(unsafe.Pointer(gp)) }
  0x43bd93		4889442408		MOVQ AX, 0x8(SP)	
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x43bd98		31c9			XORL CX, CX			
  0x43bd9a		48890d870e0900		MOVQ CX, runtime.trace+104(SB)	
	unlock(&trace.lock)
  0x43bda1		488d0d180e0900		LEAQ runtime.trace(SB), CX	
  0x43bda8		48890c24		MOVQ CX, 0(SP)			
  0x43bdac		e8dfcafcff		CALL runtime.unlock(SB)		
	return gp
  0x43bdb1		488b442408		MOVQ 0x8(SP), AX	
  0x43bdb6		4889442420		MOVQ AX, 0x20(SP)	
  0x43bdbb		488b6c2410		MOVQ 0x10(SP), BP	
  0x43bdc0		4883c418		ADDQ $0x18, SP		
  0x43bdc4		c3			RET			
  0x43bdc5		31c9			XORL CX, CX		
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bdc7		ebc4			JMP 0x43bd8d		
  0x43bdc9		31c0			XORL AX, AX		
	if trace.reader == 0 || (trace.fullHead == 0 && !trace.shutdown) {
  0x43bdcb		e966ffffff		JMP 0x43bd36		
func traceReader() *g {
  0x43bdd0		e8abba0000		CALL runtime.morestack_noctxt(SB)	
  0x43bdd5		e906ffffff		JMP runtime.traceReader(SB)		

TEXT runtime.traceProcFree(SB) /usr/local/go/src/runtime/trace.go
func traceProcFree(pp *p) {
  0x43bde0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bde9		483b6110		CMPQ 0x10(CX), SP	
  0x43bded		0f869b000000		JBE 0x43be8e		
  0x43bdf3		4883ec18		SUBQ $0x18, SP		
  0x43bdf7		48896c2410		MOVQ BP, 0x10(SP)	
  0x43bdfc		488d6c2410		LEAQ 0x10(SP), BP	
	buf := pp.tracebuf
  0x43be01		488b442420		MOVQ 0x20(SP), AX	
  0x43be06		8400			TESTB AL, 0(AX)		
  0x43be08		488b8818120000		MOVQ 0x1218(AX), CX	
	pp.tracebuf = 0
  0x43be0f		48c7801812000000000000	MOVQ $0x0, 0x1218(AX)	
	if buf == 0 {
  0x43be1a		4885c9			TESTQ CX, CX		
  0x43be1d		7465			JE 0x43be84		
	buf := pp.tracebuf
  0x43be1f		48894c2408		MOVQ CX, 0x8(SP)	
	lock(&trace.lock)
  0x43be24		488d05950d0900		LEAQ runtime.trace(SB), AX	
  0x43be2b		48890424		MOVQ AX, 0(SP)			
  0x43be2f		e8acc8fcff		CALL runtime.lock(SB)		
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43be34		488b442408		MOVQ 0x8(SP), AX	
  0x43be39		4889c1			MOVQ AX, CX		
	traceFullQueue(buf)
  0x43be3c		90			NOPL			
	buf.ptr().link = 0
  0x43be3d		90			NOPL			
  0x43be3e		48c70000000000		MOVQ $0x0, 0(AX)	
	if trace.fullHead == 0 {
  0x43be45		48833dcb0d090000	CMPQ $0x0, runtime.trace+88(SB)	
  0x43be4d		7528			JNE 0x43be77			
		trace.fullHead = buf
  0x43be4f		48890dc20d0900		MOVQ CX, runtime.trace+88(SB)	
	trace.fullTail = buf
  0x43be56		48890dc30d0900		MOVQ CX, runtime.trace+96(SB)	
	unlock(&trace.lock)
  0x43be5d		488d055c0d0900		LEAQ runtime.trace(SB), AX	
  0x43be64		48890424		MOVQ AX, 0(SP)			
  0x43be68		e823cafcff		CALL runtime.unlock(SB)		
}
  0x43be6d		488b6c2410		MOVQ 0x10(SP), BP	
  0x43be72		4883c418		ADDQ $0x18, SP		
  0x43be76		c3			RET			
		trace.fullTail.ptr().link = buf
  0x43be77		488b05a20d0900		MOVQ runtime.trace+96(SB), AX	
  0x43be7e		90			NOPL				
  0x43be7f		488908			MOVQ CX, 0(AX)			
  0x43be82		ebd2			JMP 0x43be56			
		return
  0x43be84		488b6c2410		MOVQ 0x10(SP), BP	
  0x43be89		4883c418		ADDQ $0x18, SP		
  0x43be8d		c3			RET			
func traceProcFree(pp *p) {
  0x43be8e		e8edb90000		CALL runtime.morestack_noctxt(SB)	
  0x43be93		e948ffffff		JMP runtime.traceProcFree(SB)		

TEXT runtime.traceEvent(SB) /usr/local/go/src/runtime/trace.go
func traceEvent(ev byte, skip int, args ...uint64) {
  0x43bea0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bea9		483b6110		CMPQ 0x10(CX), SP	
  0x43bead		0f86d2000000		JBE 0x43bf85		
  0x43beb3		4883ec58		SUBQ $0x58, SP		
  0x43beb7		48896c2450		MOVQ BP, 0x50(SP)	
  0x43bebc		488d6c2450		LEAQ 0x50(SP), BP	
	mp, pid, bufp := traceAcquireBuffer()
  0x43bec1		e8ca040000		CALL runtime.traceAcquireBuffer(SB)	
  0x43bec6		488b0424		MOVQ 0(SP), AX				
  0x43beca		8b4c2408		MOVL 0x8(SP), CX			
  0x43bece		488b542410		MOVQ 0x10(SP), DX			
	if !trace.enabled && !mp.startingtrace {
  0x43bed3		803df60c090000		CMPB $0x0, runtime.trace+16(SB)	
  0x43beda		0f8486000000		JE 0x43bf66			
	if skip > 0 {
  0x43bee0		488b5c2468		MOVQ 0x68(SP), BX	
  0x43bee5		4885db			TESTQ BX, BX		
  0x43bee8		7e18			JLE 0x43bf02		
		if getg() == mp.curg {
  0x43beea		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	
			skip++ // +1 because stack is captured in traceEventLocked.
  0x43bef3		488d7b01		LEAQ 0x1(BX), DI	
		if getg() == mp.curg {
  0x43bef7		4839b0c0000000		CMPQ SI, 0xc0(AX)	
	traceEventLocked(0, mp, pid, bufp, ev, skip, args...)
  0x43befe		480f44df		CMOVE DI, BX		
	mp, pid, bufp := traceAcquireBuffer()
  0x43bf02		894c244c		MOVL CX, 0x4c(SP)	
	traceEventLocked(0, mp, pid, bufp, ev, skip, args...)
  0x43bf06		48c7042400000000	MOVQ $0x0, 0(SP)			
  0x43bf0e		4889442408		MOVQ AX, 0x8(SP)			
  0x43bf13		894c2410		MOVL CX, 0x10(SP)			
  0x43bf17		4889542418		MOVQ DX, 0x18(SP)			
  0x43bf1c		0fb6442460		MOVZX 0x60(SP), AX			
  0x43bf21		88442420		MOVB AL, 0x20(SP)			
  0x43bf25		48895c2428		MOVQ BX, 0x28(SP)			
  0x43bf2a		488b442470		MOVQ 0x70(SP), AX			
  0x43bf2f		4889442430		MOVQ AX, 0x30(SP)			
  0x43bf34		488b442478		MOVQ 0x78(SP), AX			
  0x43bf39		4889442438		MOVQ AX, 0x38(SP)			
  0x43bf3e		488b842480000000	MOVQ 0x80(SP), AX			
  0x43bf46		4889442440		MOVQ AX, 0x40(SP)			
  0x43bf4b		e840000000		CALL runtime.traceEventLocked(SB)	
	traceReleaseBuffer(pid)
  0x43bf50		8b44244c		MOVL 0x4c(SP), AX			
  0x43bf54		890424			MOVL AX, 0(SP)				
  0x43bf57		e8e4040000		CALL runtime.traceReleaseBuffer(SB)	
}
  0x43bf5c		488b6c2450		MOVQ 0x50(SP), BP	
  0x43bf61		4883c458		ADDQ $0x58, SP		
  0x43bf65		c3			RET			
	if !trace.enabled && !mp.startingtrace {
  0x43bf66		80b8a002000000		CMPB $0x0, 0x2a0(AX)	
  0x43bf6d		0f856dffffff		JNE 0x43bee0		
		traceReleaseBuffer(pid)
  0x43bf73		890c24			MOVL CX, 0(SP)				
  0x43bf76		e8c5040000		CALL runtime.traceReleaseBuffer(SB)	
		return
  0x43bf7b		488b6c2450		MOVQ 0x50(SP), BP	
  0x43bf80		4883c458		ADDQ $0x58, SP		
  0x43bf84		c3			RET			
func traceEvent(ev byte, skip int, args ...uint64) {
  0x43bf85		e8f6b80000		CALL runtime.morestack_noctxt(SB)	
  0x43bf8a		e911ffffff		JMP runtime.traceEvent(SB)		

TEXT runtime.traceEventLocked(SB) /usr/local/go/src/runtime/trace.go
func traceEventLocked(extraBytes int, mp *m, pid int32, bufp *traceBufPtr, ev byte, skip int, args ...uint64) {
  0x43bf90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43bf99		483b6110		CMPQ 0x10(CX), SP	
  0x43bf9d		0f868b020000		JBE 0x43c22e		
  0x43bfa3		4883ec68		SUBQ $0x68, SP		
  0x43bfa7		48896c2460		MOVQ BP, 0x60(SP)	
  0x43bfac		488d6c2460		LEAQ 0x60(SP), BP	
	buf := bufp.ptr()
  0x43bfb1		488b842488000000	MOVQ 0x88(SP), AX	
  0x43bfb9		488b08			MOVQ 0(AX), CX		
  0x43bfbc		90			NOPL			
	maxSize := 2 + 5*traceBytesPerNumber + extraBytes // event type, length, sequence, timestamp, stack id and two add params
  0x43bfbd		488b542470		MOVQ 0x70(SP), DX	
  0x43bfc2		4883c234		ADDQ $0x34, DX		
  0x43bfc6		4889542440		MOVQ DX, 0x40(SP)	
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43bfcb		4889cb			MOVQ CX, BX		
	if buf == nil || len(buf.arr)-buf.pos < maxSize {
  0x43bfce		4885c9			TESTQ CX, CX		
  0x43bfd1		7417			JE 0x43bfea		
  0x43bfd3		488b7110		MOVQ 0x10(CX), SI	
  0x43bfd7		4881c61804ffff		ADDQ $-0xfbe8, SI	
  0x43bfde		48f7de			NEGQ SI			
  0x43bfe1		4839d6			CMPQ DX, SI		
  0x43bfe4		0f8d13020000		JGE 0x43c1fd		
		buf = traceFlush(traceBufPtrOf(buf), pid).ptr()
  0x43bfea		90			NOPL				
  0x43bfeb		48891c24		MOVQ BX, 0(SP)			
  0x43bfef		8b842480000000		MOVL 0x80(SP), AX		
  0x43bff6		89442408		MOVL AX, 0x8(SP)		
  0x43bffa		e8c1040000		CALL runtime.traceFlush(SB)	
  0x43bfff		488b442410		MOVQ 0x10(SP), AX		
  0x43c004		90			NOPL				
		bufp.set(buf)
  0x43c005		90			NOPL			
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43c006		4889c1			MOVQ AX, CX		
func (tp *traceBufPtr) set(b *traceBuf) { *tp = traceBufPtr(unsafe.Pointer(b)) }
  0x43c009		488b942488000000	MOVQ 0x88(SP), DX	
  0x43c011		48890a			MOVQ CX, 0(DX)		
	tickDiff := ticks - buf.lastTicks
  0x43c014		4889442458		MOVQ AX, 0x58(SP)	
	ticks := uint64(cputicks()) / traceTickDiv
  0x43c019		e8f2cf0000		CALL runtime.cputicks(SB)	
  0x43c01e		488b0424		MOVQ 0(SP), AX			
  0x43c022		48c1e806		SHRQ $0x6, AX			
	tickDiff := ticks - buf.lastTicks
  0x43c026		488b4c2458		MOVQ 0x58(SP), CX	
  0x43c02b		488b5108		MOVQ 0x8(CX), DX	
	buf.lastTicks = ticks
  0x43c02f		48894108		MOVQ AX, 0x8(CX)	
	tickDiff := ticks - buf.lastTicks
  0x43c033		4829d0			SUBQ DX, AX		
	if skip >= 0 {
  0x43c036		488b942498000000	MOVQ 0x98(SP), DX	
  0x43c03e		4885d2			TESTQ DX, DX		
  0x43c041		0f8ca6010000		JL 0x43c1ed		
		narg++
  0x43c047		488b9c24a8000000	MOVQ 0xa8(SP), BX	
  0x43c04f		8d7301			LEAL 0x1(BX), SI	
	if narg > 3 {
  0x43c052		4080fe03		CMPL $0x3, SI		
  0x43c056		7605			JBE 0x43c05d		
  0x43c058		be03000000		MOVL $0x3, SI		
	startPos := buf.pos
  0x43c05d		488b7910		MOVQ 0x10(CX), DI	
	buf.byte(ev | narg<<traceArgCountShift)
  0x43c061		90			NOPL			
  0x43c062		4189f0			MOVL SI, R8		
  0x43c065		c1e606			SHLL $0x6, SI		
  0x43c068		440fb68c2490000000	MOVZX 0x90(SP), R9	
  0x43c071		4109f1			ORL SI, R9		
	buf.arr[buf.pos] = v
  0x43c074		4881ffe8fb0000		CMPQ $0xfbe8, DI	
  0x43c07b		0f83a6010000		JAE 0x43c227		
	startPos := buf.pos
  0x43c081		48897c2438		MOVQ DI, 0x38(SP)	
	buf.arr[buf.pos] = v
  0x43c086		44888c3918040000	MOVB R9, 0x418(CX)(DI*1)	
	buf.pos++
  0x43c08e		48ff4110		INCQ 0x10(CX)		
	if narg == 3 {
  0x43c092		4180f803		CMPL $0x3, R8		
  0x43c096		0f840a010000		JE 0x43c1a6		
  0x43c09c		31f6			XORL SI, SI		
	if lenp != nil {
  0x43c09e		4889742450		MOVQ SI, 0x50(SP)	
	buf.varint(tickDiff)
  0x43c0a3		48890c24		MOVQ CX, 0(SP)				
  0x43c0a7		4889442408		MOVQ AX, 0x8(SP)			
  0x43c0ac		e8ef050000		CALL runtime.(*traceBuf).varint(SB)	
  0x43c0b1		31c0			XORL AX, AX				
	for _, a := range args {
  0x43c0b3		eb2c			JMP 0x43c0e1		
  0x43c0b5		4889442448		MOVQ AX, 0x48(SP)	
  0x43c0ba		488b8c24a0000000	MOVQ 0xa0(SP), CX	
  0x43c0c2		488b14c1		MOVQ 0(CX)(AX*8), DX	
		buf.varint(a)
  0x43c0c6		488b5c2458		MOVQ 0x58(SP), BX			
  0x43c0cb		48891c24		MOVQ BX, 0(SP)				
  0x43c0cf		4889542408		MOVQ DX, 0x8(SP)			
  0x43c0d4		e8c7050000		CALL runtime.(*traceBuf).varint(SB)	
	for _, a := range args {
  0x43c0d9		488b442448		MOVQ 0x48(SP), AX	
  0x43c0de		48ffc0			INCQ AX			
  0x43c0e1		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x43c0e9		4839c8			CMPQ CX, AX		
  0x43c0ec		7cc7			JL 0x43c0b5		
	if skip >= 0 {
  0x43c0ee		488b842498000000	MOVQ 0x98(SP), AX	
  0x43c0f6		4885c0			TESTQ AX, AX		
	if skip == 0 {
  0x43c0f9		0f848b000000		JE 0x43c18a		
	} else if skip > 0 {
  0x43c0ff		7f39			JG 0x43c13a		
	evSize := buf.pos - startPos
  0x43c101		488b442458		MOVQ 0x58(SP), AX	
  0x43c106		488b4010		MOVQ 0x10(AX), AX	
  0x43c10a		488b4c2438		MOVQ 0x38(SP), CX	
  0x43c10f		4829c8			SUBQ CX, AX		
	if evSize > maxSize {
  0x43c112		488b4c2440		MOVQ 0x40(SP), CX	
  0x43c117		4839c8			CMPQ CX, AX		
  0x43c11a		0f8fe5000000		JG 0x43c205		
	if lenp != nil {
  0x43c120		488b4c2450		MOVQ 0x50(SP), CX	
  0x43c125		4885c9			TESTQ CX, CX		
  0x43c128		7406			JE 0x43c130		
		*lenp = byte(evSize - 2)
  0x43c12a		4883c0fe		ADDQ $-0x2, AX		
  0x43c12e		8801			MOVB AL, 0(CX)		
  0x43c130		488b6c2460		MOVQ 0x60(SP), BP	
  0x43c135		4883c468		ADDQ $0x68, SP		
  0x43c139		c3			RET			
		buf.varint(traceStackID(mp, buf.stk[:], skip))
  0x43c13a		488b4c2478		MOVQ 0x78(SP), CX			
  0x43c13f		48890c24		MOVQ CX, 0(SP)				
  0x43c143		488b4c2458		MOVQ 0x58(SP), CX			
  0x43c148		488d5118		LEAQ 0x18(CX), DX			
  0x43c14c		4889542408		MOVQ DX, 0x8(SP)			
  0x43c151		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x43c15a		48c744241880000000	MOVQ $0x80, 0x18(SP)			
  0x43c163		4889442420		MOVQ AX, 0x20(SP)			
  0x43c168		e8d3000000		CALL runtime.traceStackID(SB)		
  0x43c16d		488b442428		MOVQ 0x28(SP), AX			
  0x43c172		488b4c2458		MOVQ 0x58(SP), CX			
  0x43c177		48890c24		MOVQ CX, 0(SP)				
  0x43c17b		4889442408		MOVQ AX, 0x8(SP)			
  0x43c180		e81b050000		CALL runtime.(*traceBuf).varint(SB)	
  0x43c185		e977ffffff		JMP 0x43c101				
		buf.varint(0)
  0x43c18a		488b442458		MOVQ 0x58(SP), AX			
  0x43c18f		48890424		MOVQ AX, 0(SP)				
  0x43c193		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x43c19c		e8ff040000		CALL runtime.(*traceBuf).varint(SB)	
  0x43c1a1		e95bffffff		JMP 0x43c101				
	tickDiff := ticks - buf.lastTicks
  0x43c1a6		4889442430		MOVQ AX, 0x30(SP)	
		buf.varint(0)
  0x43c1ab		48890c24		MOVQ CX, 0(SP)				
  0x43c1af		48c744240800000000	MOVQ $0x0, 0x8(SP)			
  0x43c1b8		e8e3040000		CALL runtime.(*traceBuf).varint(SB)	
		lenp = &buf.arr[buf.pos-1]
  0x43c1bd		488b442458		MOVQ 0x58(SP), AX	
  0x43c1c2		488b4810		MOVQ 0x10(AX), CX	
  0x43c1c6		488d51ff		LEAQ -0x1(CX), DX	
  0x43c1ca		4881fae8fb0000		CMPQ $0xfbe8, DX	
  0x43c1d1		734d			JAE 0x43c220		
  0x43c1d3		488d3401		LEAQ 0(CX)(AX*1), SI	
  0x43c1d7		488db617040000		LEAQ 0x417(SI), SI	
	buf.varint(tickDiff)
  0x43c1de		488b442430		MOVQ 0x30(SP), AX	
  0x43c1e3		488b4c2458		MOVQ 0x58(SP), CX	
		lenp = &buf.arr[buf.pos-1]
  0x43c1e8		e9b1feffff		JMP 0x43c09e		
	for _, a := range args {
  0x43c1ed		488b9c24a8000000	MOVQ 0xa8(SP), BX	
	if narg > 3 {
  0x43c1f5		4889de			MOVQ BX, SI		
	if skip >= 0 {
  0x43c1f8		e955feffff		JMP 0x43c052		
	tickDiff := ticks - buf.lastTicks
  0x43c1fd		4889c8			MOVQ CX, AX		
	ticks := uint64(cputicks()) / traceTickDiv
  0x43c200		e90ffeffff		JMP 0x43c014		
		throw("invalid length of trace event")
  0x43c205		488d05e0560300		LEAQ 0x356e0(IP), AX	
  0x43c20c		48890424		MOVQ AX, 0(SP)		
  0x43c210		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x43c219		e86272feff		CALL runtime.throw(SB)	
  0x43c21e		0f0b			UD2			
		lenp = &buf.arr[buf.pos-1]
  0x43c220		e8fb5cfeff		CALL runtime.panicindex(SB)	
  0x43c225		0f0b			UD2				
	buf.arr[buf.pos] = v
  0x43c227		e8f45cfeff		CALL runtime.panicindex(SB)	
  0x43c22c		0f0b			UD2				
func traceEventLocked(extraBytes int, mp *m, pid int32, bufp *traceBufPtr, ev byte, skip int, args ...uint64) {
  0x43c22e		e84db60000		CALL runtime.morestack_noctxt(SB)	
  0x43c233		e958fdffff		JMP runtime.traceEventLocked(SB)	

TEXT runtime.traceStackID(SB) /usr/local/go/src/runtime/trace.go
func traceStackID(mp *m, buf []uintptr, skip int) uint64 {
  0x43c240		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c249		483b6110		CMPQ 0x10(CX), SP	
  0x43c24d		0f8628010000		JBE 0x43c37b		
  0x43c253		4883ec40		SUBQ $0x40, SP		
  0x43c257		48896c2438		MOVQ BP, 0x38(SP)	
  0x43c25c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x43c261		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	gp := mp.curg
  0x43c26a		488b4c2448		MOVQ 0x48(SP), CX	
  0x43c26f		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x43c276		48894c2430		MOVQ CX, 0x30(SP)	
	if gp == _g_ {
  0x43c27b		4839c1			CMPQ AX, CX		
  0x43c27e		0f84b2000000		JE 0x43c336		
	} else if gp != nil {
  0x43c284		4885c9			TESTQ CX, CX		
  0x43c287		756d			JNE 0x43c2f6		
  0x43c289		31c0			XORL AX, AX		
		nstk-- // skip runtime.goexit
  0x43c28b		488d50ff		LEAQ -0x1(AX), DX	
	if nstk > 0 {
  0x43c28f		4885c0			TESTQ AX, AX		
	if nstk > 0 && gp.goid == 1 {
  0x43c292		480f4fc2		CMOVG DX, AX		
  0x43c296		4885c0			TESTQ AX, AX		
	if nstk > 0 {
  0x43c299		7e0d			JLE 0x43c2a8		
	if nstk > 0 && gp.goid == 1 {
  0x43c29b		4883b99800000001	CMPQ $0x1, 0x98(CX)	
  0x43c2a3		7503			JNE 0x43c2a8		
		nstk-- // skip runtime.main
  0x43c2a5		48ffc8			DECQ AX			
	id := trace.stackTab.put(buf[:nstk])
  0x43c2a8		4885c0			TESTQ AX, AX				
  0x43c2ab		0f8cc3000000		JL 0x43c374				
  0x43c2b1		488b4c2460		MOVQ 0x60(SP), CX			
  0x43c2b6		4839c8			CMPQ CX, AX				
  0x43c2b9		0f87b5000000		JA 0x43c374				
  0x43c2bf		488d156a090900		LEAQ runtime.trace+112(SB), DX		
  0x43c2c6		48891424		MOVQ DX, 0(SP)				
  0x43c2ca		488b542450		MOVQ 0x50(SP), DX			
  0x43c2cf		4889542408		MOVQ DX, 0x8(SP)			
  0x43c2d4		4889442410		MOVQ AX, 0x10(SP)			
  0x43c2d9		48894c2418		MOVQ CX, 0x18(SP)			
  0x43c2de		e83d040000		CALL runtime.(*traceStackTable).put(SB)	
  0x43c2e3		8b442420		MOVL 0x20(SP), AX			
	return uint64(id)
  0x43c2e7		4889442470		MOVQ AX, 0x70(SP)	
  0x43c2ec		488b6c2438		MOVQ 0x38(SP), BP	
  0x43c2f1		4883c440		ADDQ $0x40, SP		
  0x43c2f5		c3			RET			
		nstk = gcallers(gp, skip, buf)
  0x43c2f6		48890c24		MOVQ CX, 0(SP)			
  0x43c2fa		488b442468		MOVQ 0x68(SP), AX		
  0x43c2ff		4889442408		MOVQ AX, 0x8(SP)		
  0x43c304		488b442450		MOVQ 0x50(SP), AX		
  0x43c309		4889442410		MOVQ AX, 0x10(SP)		
  0x43c30e		488b542458		MOVQ 0x58(SP), DX		
  0x43c313		4889542418		MOVQ DX, 0x18(SP)		
  0x43c318		488b542460		MOVQ 0x60(SP), DX		
  0x43c31d		4889542420		MOVQ DX, 0x20(SP)		
  0x43c322		e8e9420000		CALL runtime.gcallers(SB)	
  0x43c327		488b442428		MOVQ 0x28(SP), AX		
	if nstk > 0 && gp.goid == 1 {
  0x43c32c		488b4c2430		MOVQ 0x30(SP), CX	
		nstk = gcallers(gp, skip, buf)
  0x43c331		e955ffffff		JMP 0x43c28b		
		nstk = callers(skip+1, buf)
  0x43c336		488b442468		MOVQ 0x68(SP), AX		
  0x43c33b		48ffc0			INCQ AX				
  0x43c33e		48890424		MOVQ AX, 0(SP)			
  0x43c342		488b442450		MOVQ 0x50(SP), AX		
  0x43c347		4889442408		MOVQ AX, 0x8(SP)		
  0x43c34c		488b4c2458		MOVQ 0x58(SP), CX		
  0x43c351		48894c2410		MOVQ CX, 0x10(SP)		
  0x43c356		488b4c2460		MOVQ 0x60(SP), CX		
  0x43c35b		48894c2418		MOVQ CX, 0x18(SP)		
  0x43c360		e8cb410000		CALL runtime.callers(SB)	
  0x43c365		488b442420		MOVQ 0x20(SP), AX		
	if nstk > 0 && gp.goid == 1 {
  0x43c36a		488b4c2430		MOVQ 0x30(SP), CX	
		nstk = callers(skip+1, buf)
  0x43c36f		e917ffffff		JMP 0x43c28b		
	id := trace.stackTab.put(buf[:nstk])
  0x43c374		e8d75cfeff		CALL runtime.panicslice(SB)	
  0x43c379		0f0b			UD2				
func traceStackID(mp *m, buf []uintptr, skip int) uint64 {
  0x43c37b		e800b50000		CALL runtime.morestack_noctxt(SB)	
  0x43c380		e9bbfeffff		JMP runtime.traceStackID(SB)		

TEXT runtime.traceAcquireBuffer(SB) /usr/local/go/src/runtime/trace.go
func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr) {
  0x43c390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c399		483b6110		CMPQ 0x10(CX), SP	
  0x43c39d		0f8693000000		JBE 0x43c436		
  0x43c3a3		4883ec18		SUBQ $0x18, SP		
  0x43c3a7		48896c2410		MOVQ BP, 0x10(SP)	
  0x43c3ac		488d6c2410		LEAQ 0x10(SP), BP	
	_g_ := getg()
  0x43c3b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x43c3ba		488b4830		MOVQ 0x30(AX), CX	
	mp = acquirem()
  0x43c3be		90			NOPL			
	_g_.m.locks++
  0x43c3bf		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x43c3c5		488b4830		MOVQ 0x30(AX), CX	
  0x43c3c9		8400			TESTB AL, 0(AX)		
	if p := mp.p.ptr(); p != nil {
  0x43c3cb		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x43c3d2		90			NOPL			
  0x43c3d3		4885c0			TESTQ AX, AX		
  0x43c3d6		7421			JE 0x43c3f9		
		return mp, p.id, &p.tracebuf
  0x43c3d8		8b5008			MOVL 0x8(AX), DX	
  0x43c3db		48894c2420		MOVQ CX, 0x20(SP)	
  0x43c3e0		89542428		MOVL DX, 0x28(SP)	
  0x43c3e4		480518120000		ADDQ $0x1218, AX	
  0x43c3ea		4889442430		MOVQ AX, 0x30(SP)	
  0x43c3ef		488b6c2410		MOVQ 0x10(SP), BP	
  0x43c3f4		4883c418		ADDQ $0x18, SP		
  0x43c3f8		c3			RET			
	return _g_.m
  0x43c3f9		48894c2408		MOVQ CX, 0x8(SP)	
	lock(&trace.bufLock)
  0x43c3fe		488d057b080a00		LEAQ runtime.trace+65728(SB), AX	
  0x43c405		48890424		MOVQ AX, 0(SP)				
  0x43c409		e8d2c2fcff		CALL runtime.lock(SB)			
	return mp, traceGlobProc, &trace.buf
  0x43c40e		488b442408		MOVQ 0x8(SP), AX			
  0x43c413		4889442420		MOVQ AX, 0x20(SP)			
  0x43c418		c7442428ffffffff	MOVL $-0x1, 0x28(SP)			
  0x43c420		488d0561080a00		LEAQ runtime.trace+65736(SB), AX	
  0x43c427		4889442430		MOVQ AX, 0x30(SP)			
  0x43c42c		488b6c2410		MOVQ 0x10(SP), BP			
  0x43c431		4883c418		ADDQ $0x18, SP				
  0x43c435		c3			RET					
func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr) {
  0x43c436		e845b40000		CALL runtime.morestack_noctxt(SB)	
  0x43c43b		e950ffffff		JMP runtime.traceAcquireBuffer(SB)	

TEXT runtime.traceReleaseBuffer(SB) /usr/local/go/src/runtime/trace.go
func traceReleaseBuffer(pid int32) {
  0x43c440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c449		483b6110		CMPQ 0x10(CX), SP	
  0x43c44d		7666			JBE 0x43c4b5		
  0x43c44f		4883ec10		SUBQ $0x10, SP		
  0x43c453		48896c2408		MOVQ BP, 0x8(SP)	
  0x43c458		488d6c2408		LEAQ 0x8(SP), BP	
	if pid == traceGlobProc {
  0x43c45d		8b442418		MOVL 0x18(SP), AX	
  0x43c461		83f8ff			CMPL $-0x1, AX		
  0x43c464		743d			JE 0x43c4a3		
	releasem(getg().m)
  0x43c466		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43c46f		488b4830		MOVQ 0x30(AX), CX	
  0x43c473		90			NOPL			
	mp.locks--
  0x43c474		8b9108010000		MOVL 0x108(CX), DX	
  0x43c47a		8d5aff			LEAL -0x1(DX), BX	
  0x43c47d		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x43c483		83fa01			CMPL $0x1, DX		
  0x43c486		7511			JNE 0x43c499		
  0x43c488		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x43c48f		7408			JE 0x43c499		
		_g_.stackguard0 = stackPreempt
  0x43c491		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43c499		488b6c2408		MOVQ 0x8(SP), BP	
  0x43c49e		4883c410		ADDQ $0x10, SP		
  0x43c4a2		c3			RET			
		unlock(&trace.bufLock)
  0x43c4a3		488d05d6070a00		LEAQ runtime.trace+65728(SB), AX	
  0x43c4aa		48890424		MOVQ AX, 0(SP)				
  0x43c4ae		e8ddc3fcff		CALL runtime.unlock(SB)			
  0x43c4b3		ebb1			JMP 0x43c466				
func traceReleaseBuffer(pid int32) {
  0x43c4b5		e8c6b30000		CALL runtime.morestack_noctxt(SB)	
  0x43c4ba		eb84			JMP runtime.traceReleaseBuffer(SB)	

TEXT runtime.traceFlush(SB) /usr/local/go/src/runtime/trace.go
func traceFlush(buf traceBufPtr, pid int32) traceBufPtr {
  0x43c4c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c4c9		483b6110		CMPQ 0x10(CX), SP	
  0x43c4cd		0f86c0010000		JBE 0x43c693		
  0x43c4d3		4883ec40		SUBQ $0x40, SP		
  0x43c4d7		48896c2438		MOVQ BP, 0x38(SP)	
  0x43c4dc		488d6c2438		LEAQ 0x38(SP), BP	
	owner := trace.lockOwner
  0x43c4e1		488b05e0060900		MOVQ runtime.trace+8(SB), AX	
	dolock := owner == nil || owner != getg().m.curg
  0x43c4e8		4885c0			TESTQ AX, AX		
  0x43c4eb		0f8476010000		JE 0x43c667		
  0x43c4f1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c4fa		488b4930		MOVQ 0x30(CX), CX	
  0x43c4fe		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x43c505		0f95c0			SETNE AL		
  0x43c508		8844241f		MOVB AL, 0x1f(SP)	
  0x43c50c		84c0			TESTL AL, AL		
	if dolock {
  0x43c50e		0f8539010000		JNE 0x43c64d		
	if buf != 0 {
  0x43c514		488b4c2448		MOVQ 0x48(SP), CX	
  0x43c519		4885c9			TESTQ CX, CX		
  0x43c51c		7428			JE 0x43c546		
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43c51e		4889ca			MOVQ CX, DX		
		traceFullQueue(buf)
  0x43c521		90			NOPL			
	buf.ptr().link = 0
  0x43c522		90			NOPL			
  0x43c523		48c70100000000		MOVQ $0x0, 0(CX)	
	if trace.fullHead == 0 {
  0x43c52a		48833de606090000	CMPQ $0x0, runtime.trace+88(SB)	
  0x43c532		0f8505010000		JNE 0x43c63d			
		trace.fullHead = buf
  0x43c538		488915d9060900		MOVQ DX, runtime.trace+88(SB)	
	trace.fullTail = buf
  0x43c53f		488915da060900		MOVQ DX, runtime.trace+96(SB)	
	if trace.empty != 0 {
  0x43c546		488b0dc3060900		MOVQ runtime.trace+80(SB), CX	
  0x43c54d		4885c9			TESTQ CX, CX			
  0x43c550		0f84bc000000		JE 0x43c612			
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43c556		4889ca			MOVQ CX, DX		
		trace.empty = buf.ptr().link
  0x43c559		90			NOPL				
  0x43c55a		488b09			MOVQ 0(CX), CX			
  0x43c55d		48890dac060900		MOVQ CX, runtime.trace+80(SB)	
	bufp := buf.ptr()
  0x43c564		4889542420		MOVQ DX, 0x20(SP)	
func (tp traceBufPtr) ptr() *traceBuf   { return (*traceBuf)(unsafe.Pointer(tp)) }
  0x43c569		4889542430		MOVQ DX, 0x30(SP)	
	bufp := buf.ptr()
  0x43c56e		90			NOPL			
	bufp.link.set(nil)
  0x43c56f		90			NOPL			
func (tp *traceBufPtr) set(b *traceBuf) { *tp = traceBufPtr(unsafe.Pointer(b)) }
  0x43c570		31c9			XORL CX, CX		
  0x43c572		48890a			MOVQ CX, 0(DX)		
	bufp.pos = 0
  0x43c575		48c7421000000000	MOVQ $0x0, 0x10(DX)	
	ticks := uint64(cputicks()) / traceTickDiv
  0x43c57d		e88eca0000		CALL runtime.cputicks(SB)	
  0x43c582		488b0424		MOVQ 0(SP), AX			
  0x43c586		48c1e806		SHRQ $0x6, AX			
	bufp.lastTicks = ticks
  0x43c58a		488b4c2430		MOVQ 0x30(SP), CX	
  0x43c58f		48894108		MOVQ AX, 0x8(CX)	
	bufp.byte(traceEvBatch | 1<<traceArgCountShift)
  0x43c593		90			NOPL			
	buf.arr[buf.pos] = v
  0x43c594		488b5110		MOVQ 0x10(CX), DX	
  0x43c598		4881fae8fb0000		CMPQ $0xfbe8, DX	
  0x43c59f		0f83cc000000		JAE 0x43c671		
	ticks := uint64(cputicks()) / traceTickDiv
  0x43c5a5		4889442428		MOVQ AX, 0x28(SP)	
	buf.arr[buf.pos] = v
  0x43c5aa		c684111804000041	MOVB $0x41, 0x418(CX)(DX*1)	
	buf.pos++
  0x43c5b2		48ff4110		INCQ 0x10(CX)		
	bufp.varint(uint64(pid))
  0x43c5b6		48890c24		MOVQ CX, 0(SP)				
  0x43c5ba		8b442450		MOVL 0x50(SP), AX			
  0x43c5be		4863c0			MOVSXD AX, AX				
  0x43c5c1		4889442408		MOVQ AX, 0x8(SP)			
  0x43c5c6		e8d5000000		CALL runtime.(*traceBuf).varint(SB)	
	bufp.varint(ticks)
  0x43c5cb		488b442430		MOVQ 0x30(SP), AX			
  0x43c5d0		48890424		MOVQ AX, 0(SP)				
  0x43c5d4		488b442428		MOVQ 0x28(SP), AX			
  0x43c5d9		4889442408		MOVQ AX, 0x8(SP)			
  0x43c5de		e8bd000000		CALL runtime.(*traceBuf).varint(SB)	
	dolock := owner == nil || owner != getg().m.curg
  0x43c5e3		0fb644241f		MOVZX 0x1f(SP), AX	
  0x43c5e8		84c0			TESTL AL, AL		
	if dolock {
  0x43c5ea		7514			JNE 0x43c600		
	return buf
  0x43c5ec		488b442420		MOVQ 0x20(SP), AX	
  0x43c5f1		4889442458		MOVQ AX, 0x58(SP)	
  0x43c5f6		488b6c2438		MOVQ 0x38(SP), BP	
  0x43c5fb		4883c440		ADDQ $0x40, SP		
  0x43c5ff		c3			RET			
		unlock(&trace.lock)
  0x43c600		488d05b9050900		LEAQ runtime.trace(SB), AX	
  0x43c607		48890424		MOVQ AX, 0(SP)			
  0x43c60b		e880c2fcff		CALL runtime.unlock(SB)		
  0x43c610		ebda			JMP 0x43c5ec			
		buf = traceBufPtr(sysAlloc(unsafe.Sizeof(traceBuf{}), &memstats.other_sys))
  0x43c612		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x43c61a		488d05df160a00		LEAQ runtime.memstats+160(SB), AX	
  0x43c621		4889442408		MOVQ AX, 0x8(SP)			
  0x43c626		e8d54dfdff		CALL runtime.sysAlloc(SB)		
  0x43c62b		488b442410		MOVQ 0x10(SP), AX			
		if buf == 0 {
  0x43c630		4885c0			TESTQ AX, AX		
  0x43c633		7443			JE 0x43c678		
	bufp := buf.ptr()
  0x43c635		4889c2			MOVQ AX, DX		
  0x43c638		e927ffffff		JMP 0x43c564		
		trace.fullTail.ptr().link = buf
  0x43c63d		488b0ddc050900		MOVQ runtime.trace+96(SB), CX	
  0x43c644		90			NOPL				
  0x43c645		488911			MOVQ DX, 0(CX)			
  0x43c648		e9f2feffff		JMP 0x43c53f			
		lock(&trace.lock)
  0x43c64d		488d056c050900		LEAQ runtime.trace(SB), AX	
  0x43c654		48890424		MOVQ AX, 0(SP)			
  0x43c658		e883c0fcff		CALL runtime.lock(SB)		
	dolock := owner == nil || owner != getg().m.curg
  0x43c65d		0fb644241f		MOVZX 0x1f(SP), AX	
		lock(&trace.lock)
  0x43c662		e9adfeffff		JMP 0x43c514		
  0x43c667		b801000000		MOVL $0x1, AX		
	dolock := owner == nil || owner != getg().m.curg
  0x43c66c		e997feffff		JMP 0x43c508		
	buf.arr[buf.pos] = v
  0x43c671		e8aa58feff		CALL runtime.panicindex(SB)	
  0x43c676		0f0b			UD2				
			throw("trace: out of memory")
  0x43c678		488d05f6400300		LEAQ 0x340f6(IP), AX	
  0x43c67f		48890424		MOVQ AX, 0(SP)		
  0x43c683		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x43c68c		e8ef6dfeff		CALL runtime.throw(SB)	
  0x43c691		0f0b			UD2			
func traceFlush(buf traceBufPtr, pid int32) traceBufPtr {
  0x43c693		e8e8b10000		CALL runtime.morestack_noctxt(SB)	
  0x43c698		e923feffff		JMP runtime.traceFlush(SB)		

TEXT runtime.(*traceBuf).varint(SB) /usr/local/go/src/runtime/trace.go
func (buf *traceBuf) varint(v uint64) {
  0x43c6a0		4883ec08		SUBQ $0x8, SP		
  0x43c6a4		48892c24		MOVQ BP, 0(SP)		
  0x43c6a8		488d2c24		LEAQ 0(SP), BP		
	pos := buf.pos
  0x43c6ac		488b442410		MOVQ 0x10(SP), AX	
  0x43c6b1		488b4810		MOVQ 0x10(AX), CX	
	for ; v >= 0x80; v >>= 7 {
  0x43c6b5		488b542418		MOVQ 0x18(SP), DX	
  0x43c6ba		eb17			JMP 0x43c6d3		
		buf.arr[pos] = 0x80 | byte(v)
  0x43c6bc		4889d3			MOVQ DX, BX			
  0x43c6bf		83ca80			ORL $-0x80, DX			
  0x43c6c2		88940818040000		MOVB DL, 0x418(AX)(CX*1)	
	for ; v >= 0x80; v >>= 7 {
  0x43c6c9		48c1eb07		SHRQ $0x7, BX		
		pos++
  0x43c6cd		48ffc1			INCQ CX			
	for ; v >= 0x80; v >>= 7 {
  0x43c6d0		4889da			MOVQ BX, DX		
  0x43c6d3		4881fa80000000		CMPQ $0x80, DX		
  0x43c6da		720b			JB 0x43c6e7		
		buf.arr[pos] = 0x80 | byte(v)
  0x43c6dc		4881f9e8fb0000		CMPQ $0xfbe8, CX	
  0x43c6e3		72d7			JB 0x43c6bc		
  0x43c6e5		eb27			JMP 0x43c70e		
	buf.arr[pos] = byte(v)
  0x43c6e7		4881f9e8fb0000		CMPQ $0xfbe8, CX		
  0x43c6ee		7317			JAE 0x43c707			
  0x43c6f0		88940818040000		MOVB DL, 0x418(AX)(CX*1)	
	pos++
  0x43c6f7		48ffc1			INCQ CX			
	buf.pos = pos
  0x43c6fa		48894810		MOVQ CX, 0x10(AX)	
}
  0x43c6fe		488b2c24		MOVQ 0(SP), BP		
  0x43c702		4883c408		ADDQ $0x8, SP		
  0x43c706		c3			RET			
	buf.arr[pos] = byte(v)
  0x43c707		e81458feff		CALL runtime.panicindex(SB)	
  0x43c70c		0f0b			UD2				
		buf.arr[pos] = 0x80 | byte(v)
  0x43c70e		e80d58feff		CALL runtime.panicindex(SB)	
  0x43c713		0f0b			UD2				

TEXT runtime.(*traceStackTable).put(SB) /usr/local/go/src/runtime/trace.go
func (tab *traceStackTable) put(pcs []uintptr) uint32 {
  0x43c720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c729		483b6110		CMPQ 0x10(CX), SP	
  0x43c72d		0f86d3010000		JBE 0x43c906		
  0x43c733		4883ec50		SUBQ $0x50, SP		
  0x43c737		48896c2448		MOVQ BP, 0x48(SP)	
  0x43c73c		488d6c2448		LEAQ 0x48(SP), BP	
	if len(pcs) == 0 {
  0x43c741		488b442468		MOVQ 0x68(SP), AX	
  0x43c746		4885c0			TESTQ AX, AX		
  0x43c749		0f849e010000		JE 0x43c8ed		
	hash := memhash(unsafe.Pointer(&pcs[0]), 0, uintptr(len(pcs))*unsafe.Sizeof(pcs[0]))
  0x43c74f		488b4c2460		MOVQ 0x60(SP), CX		
  0x43c754		48890c24		MOVQ CX, 0(SP)			
  0x43c758		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x43c761		48c1e003		SHLQ $0x3, AX			
  0x43c765		4889442410		MOVQ AX, 0x10(SP)		
  0x43c76a		e851abfcff		CALL runtime.memhash(SB)	
  0x43c76f		488b442418		MOVQ 0x18(SP), AX		
  0x43c774		4889442438		MOVQ AX, 0x38(SP)		
	if id := tab.find(pcs, hash); id != 0 {
  0x43c779		488b4c2458		MOVQ 0x58(SP), CX				
  0x43c77e		48890c24		MOVQ CX, 0(SP)					
  0x43c782		488b542460		MOVQ 0x60(SP), DX				
  0x43c787		4889542408		MOVQ DX, 0x8(SP)				
  0x43c78c		488b5c2468		MOVQ 0x68(SP), BX				
  0x43c791		48895c2410		MOVQ BX, 0x10(SP)				
  0x43c796		488b742470		MOVQ 0x70(SP), SI				
  0x43c79b		4889742418		MOVQ SI, 0x18(SP)				
  0x43c7a0		4889442420		MOVQ AX, 0x20(SP)				
  0x43c7a5		e866010000		CALL runtime.(*traceStackTable).find(SB)	
  0x43c7aa		8b442428		MOVL 0x28(SP), AX				
  0x43c7ae		85c0			TESTL AX, AX					
  0x43c7b0		0f8529010000		JNE 0x43c8df					
	lock(&tab.lock)
  0x43c7b6		488b442458		MOVQ 0x58(SP), AX	
  0x43c7bb		8400			TESTB AL, 0(AX)		
  0x43c7bd		48890424		MOVQ AX, 0(SP)		
  0x43c7c1		e81abffcff		CALL runtime.lock(SB)	
	if id := tab.find(pcs, hash); id != 0 {
  0x43c7c6		488b442458		MOVQ 0x58(SP), AX				
  0x43c7cb		48890424		MOVQ AX, 0(SP)					
  0x43c7cf		488b4c2460		MOVQ 0x60(SP), CX				
  0x43c7d4		48894c2408		MOVQ CX, 0x8(SP)				
  0x43c7d9		488b542468		MOVQ 0x68(SP), DX				
  0x43c7de		4889542410		MOVQ DX, 0x10(SP)				
  0x43c7e3		488b5c2470		MOVQ 0x70(SP), BX				
  0x43c7e8		48895c2418		MOVQ BX, 0x18(SP)				
  0x43c7ed		488b5c2438		MOVQ 0x38(SP), BX				
  0x43c7f2		48895c2420		MOVQ BX, 0x20(SP)				
  0x43c7f7		e814010000		CALL runtime.(*traceStackTable).find(SB)	
  0x43c7fc		8b442428		MOVL 0x28(SP), AX				
  0x43c800		85c0			TESTL AX, AX					
  0x43c802		0f85b3000000		JNE 0x43c8bb					
	tab.seq++
  0x43c808		488b442458		MOVQ 0x58(SP), AX	
  0x43c80d		ff4008			INCL 0x8(AX)		
	stk := tab.newStack(len(pcs))
  0x43c810		48890424		MOVQ AX, 0(SP)					
  0x43c814		488b4c2468		MOVQ 0x68(SP), CX				
  0x43c819		48894c2408		MOVQ CX, 0x8(SP)				
  0x43c81e		e89d010000		CALL runtime.(*traceStackTable).newStack(SB)	
  0x43c823		488b442410		MOVQ 0x10(SP), AX				
	stk.hash = hash
  0x43c828		488b4c2438		MOVQ 0x38(SP), CX	
  0x43c82d		48894808		MOVQ CX, 0x8(AX)	
	stk.id = tab.seq
  0x43c831		488b542458		MOVQ 0x58(SP), DX	
  0x43c836		8b5a08			MOVL 0x8(DX), BX	
  0x43c839		895810			MOVL BX, 0x10(AX)	
	stk.n = len(pcs)
  0x43c83c		488b5c2468		MOVQ 0x68(SP), BX	
  0x43c841		48895818		MOVQ BX, 0x18(AX)	
	stkpc := stk.stack()
  0x43c845		90			NOPL			
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43c846		4881fb80000000		CMPQ $0x80, BX		
  0x43c84d		0f87ac000000		JA 0x43c8ff		
	for i, pc := range pcs {
  0x43c853		488b742460		MOVQ 0x60(SP), SI	
  0x43c858		31ff			XORL DI, DI		
  0x43c85a		eb0c			JMP 0x43c868		
  0x43c85c		4c8b04fe		MOVQ 0(SI)(DI*8), R8	
		stkpc[i] = pc
  0x43c860		4c8944f820		MOVQ R8, 0x20(AX)(DI*8)	
	for i, pc := range pcs {
  0x43c865		48ffc7			INCQ DI			
  0x43c868		4839df			CMPQ BX, DI		
  0x43c86b		7cef			JL 0x43c85c		
	stk := tab.newStack(len(pcs))
  0x43c86d		4889442440		MOVQ AX, 0x40(SP)	
	part := int(hash % uintptr(len(tab.tab)))
  0x43c872		4881e1ff1f0000		ANDQ $0x1fff, CX	
	stk.link = tab.tab[part]
  0x43c879		488b5cca20		MOVQ 0x20(DX)(CX*8), BX	
  0x43c87e		488918			MOVQ BX, 0(AX)		
  0x43c881		488d0cca		LEAQ 0(DX)(CX*8), CX	
  0x43c885		488d4920		LEAQ 0x20(CX), CX	
	atomicstorep(unsafe.Pointer(&tab.tab[part]), unsafe.Pointer(stk))
  0x43c889		48890c24		MOVQ CX, 0(SP)			
  0x43c88d		4889442408		MOVQ AX, 0x8(SP)		
  0x43c892		e8996bfcff		CALL runtime.atomicstorep(SB)	
	unlock(&tab.lock)
  0x43c897		488b442458		MOVQ 0x58(SP), AX	
  0x43c89c		48890424		MOVQ AX, 0(SP)		
  0x43c8a0		e8ebbffcff		CALL runtime.unlock(SB)	
	return stk.id
  0x43c8a5		488b442440		MOVQ 0x40(SP), AX	
  0x43c8aa		8b4010			MOVL 0x10(AX), AX	
  0x43c8ad		89442478		MOVL AX, 0x78(SP)	
  0x43c8b1		488b6c2448		MOVQ 0x48(SP), BP	
  0x43c8b6		4883c450		ADDQ $0x50, SP		
  0x43c8ba		c3			RET			
	if id := tab.find(pcs, hash); id != 0 {
  0x43c8bb		89442434		MOVL AX, 0x34(SP)	
		unlock(&tab.lock)
  0x43c8bf		488b442458		MOVQ 0x58(SP), AX	
  0x43c8c4		48890424		MOVQ AX, 0(SP)		
  0x43c8c8		e8c3bffcff		CALL runtime.unlock(SB)	
		return id
  0x43c8cd		8b442434		MOVL 0x34(SP), AX	
  0x43c8d1		89442478		MOVL AX, 0x78(SP)	
  0x43c8d5		488b6c2448		MOVQ 0x48(SP), BP	
  0x43c8da		4883c450		ADDQ $0x50, SP		
  0x43c8de		c3			RET			
		return id
  0x43c8df		89442478		MOVL AX, 0x78(SP)	
  0x43c8e3		488b6c2448		MOVQ 0x48(SP), BP	
  0x43c8e8		4883c450		ADDQ $0x50, SP		
  0x43c8ec		c3			RET			
		return 0
  0x43c8ed		c744247800000000	MOVL $0x0, 0x78(SP)	
  0x43c8f5		488b6c2448		MOVQ 0x48(SP), BP	
  0x43c8fa		4883c450		ADDQ $0x50, SP		
  0x43c8fe		c3			RET			
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43c8ff		e84c57feff		CALL runtime.panicslice(SB)	
  0x43c904		0f0b			UD2				
func (tab *traceStackTable) put(pcs []uintptr) uint32 {
  0x43c906		e875af0000		CALL runtime.morestack_noctxt(SB)	
  0x43c90b		e910feffff		JMP runtime.(*traceStackTable).put(SB)	

TEXT runtime.(*traceStackTable).find(SB) /usr/local/go/src/runtime/trace.go
func (tab *traceStackTable) find(pcs []uintptr, hash uintptr) uint32 {
  0x43c910		4883ec08		SUBQ $0x8, SP		
  0x43c914		48892c24		MOVQ BP, 0(SP)		
  0x43c918		488d2c24		LEAQ 0(SP), BP		
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x43c91c		488b442410		MOVQ 0x10(SP), AX	
  0x43c921		8400			TESTB AL, 0(AX)		
	part := int(hash % uintptr(len(tab.tab)))
  0x43c923		488b4c2430		MOVQ 0x30(SP), CX	
  0x43c928		4889ca			MOVQ CX, DX		
  0x43c92b		4881e1ff1f0000		ANDQ $0x1fff, CX	
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x43c932		488b44c820		MOVQ 0x20(AX)(CX*8), AX	
  0x43c937		90			NOPL			
  0x43c938		488b4c2420		MOVQ 0x20(SP), CX	
  0x43c93d		488b5c2418		MOVQ 0x18(SP), BX	
  0x43c942		eb1f			JMP 0x43c963		
			for i, stkpc := range stk.stack() {
  0x43c944		48ffc7			INCQ DI			
  0x43c947		4839f7			CMPQ SI, DI		
  0x43c94a		7d39			JGE 0x43c985		
  0x43c94c		4c8b44f820		MOVQ 0x20(AX)(DI*8), R8	
				if stkpc != pcs[i] {
  0x43c951		4839cf			CMPQ CX, DI		
  0x43c954		7350			JAE 0x43c9a6		
  0x43c956		4c8b0cfb		MOVQ 0(BX)(DI*8), R9	
  0x43c95a		4d39c8			CMPQ R9, R8		
  0x43c95d		74e5			JE 0x43c944		
	for stk := tab.tab[part].ptr(); stk != nil; stk = stk.link.ptr() {
  0x43c95f		488b00			MOVQ 0(AX), AX		
  0x43c962		90			NOPL			
  0x43c963		4885c0			TESTQ AX, AX		
  0x43c966		742d			JE 0x43c995		
		if stk.hash == hash && stk.n == len(pcs) {
  0x43c968		48395008		CMPQ DX, 0x8(AX)	
  0x43c96c		75f1			JNE 0x43c95f		
  0x43c96e		488b7018		MOVQ 0x18(AX), SI	
  0x43c972		4839ce			CMPQ CX, SI		
  0x43c975		75e8			JNE 0x43c95f		
			for i, stkpc := range stk.stack() {
  0x43c977		90			NOPL			
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43c978		4881fe80000000		CMPQ $0x80, SI		
  0x43c97f		772c			JA 0x43c9ad		
  0x43c981		31ff			XORL DI, DI		
			for i, stkpc := range stk.stack() {
  0x43c983		ebc2			JMP 0x43c947		
			return stk.id
  0x43c985		8b4010			MOVL 0x10(AX), AX	
  0x43c988		89442438		MOVL AX, 0x38(SP)	
  0x43c98c		488b2c24		MOVQ 0(SP), BP		
  0x43c990		4883c408		ADDQ $0x8, SP		
  0x43c994		c3			RET			
	return 0
  0x43c995		c744243800000000	MOVL $0x0, 0x38(SP)	
  0x43c99d		488b2c24		MOVQ 0(SP), BP		
  0x43c9a1		4883c408		ADDQ $0x8, SP		
  0x43c9a5		c3			RET			
				if stkpc != pcs[i] {
  0x43c9a6		e87555feff		CALL runtime.panicindex(SB)	
  0x43c9ab		0f0b			UD2				
	return (*[traceStackSize]uintptr)(unsafe.Pointer(&ts.stk))[:ts.n]
  0x43c9ad		e89e56feff		CALL runtime.panicslice(SB)	
  0x43c9b2		0f0b			UD2				

TEXT runtime.(*traceStackTable).newStack(SB) /usr/local/go/src/runtime/trace.go
func (tab *traceStackTable) newStack(n int) *traceStack {
  0x43c9c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43c9c9		483b6110		CMPQ 0x10(CX), SP	
  0x43c9cd		7648			JBE 0x43ca17		
  0x43c9cf		4883ec20		SUBQ $0x20, SP		
  0x43c9d3		48896c2418		MOVQ BP, 0x18(SP)	
  0x43c9d8		488d6c2418		LEAQ 0x18(SP), BP	
	return (*traceStack)(tab.mem.alloc(unsafe.Sizeof(traceStack{}) + uintptr(n)*sys.PtrSize))
  0x43c9dd		488b442428		MOVQ 0x28(SP), AX			
  0x43c9e2		8400			TESTB AL, 0(AX)				
  0x43c9e4		4883c010		ADDQ $0x10, AX				
  0x43c9e8		48890424		MOVQ AX, 0(SP)				
  0x43c9ec		488b442430		MOVQ 0x30(SP), AX			
  0x43c9f1		48c1e003		SHLQ $0x3, AX				
  0x43c9f5		4883c028		ADDQ $0x28, AX				
  0x43c9f9		4889442408		MOVQ AX, 0x8(SP)			
  0x43c9fe		e81d000000		CALL runtime.(*traceAlloc).alloc(SB)	
  0x43ca03		488b442410		MOVQ 0x10(SP), AX			
  0x43ca08		4889442438		MOVQ AX, 0x38(SP)			
  0x43ca0d		488b6c2418		MOVQ 0x18(SP), BP			
  0x43ca12		4883c420		ADDQ $0x20, SP				
  0x43ca16		c3			RET					
func (tab *traceStackTable) newStack(n int) *traceStack {
  0x43ca17		e864ae0000		CALL runtime.morestack_noctxt(SB)		
  0x43ca1c		eba2			JMP runtime.(*traceStackTable).newStack(SB)	

TEXT runtime.(*traceAlloc).alloc(SB) /usr/local/go/src/runtime/trace.go
func (a *traceAlloc) alloc(n uintptr) unsafe.Pointer {
  0x43ca20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ca29		483b6110		CMPQ 0x10(CX), SP	
  0x43ca2d		0f86ff000000		JBE 0x43cb32		
  0x43ca33		4883ec28		SUBQ $0x28, SP		
  0x43ca37		48896c2420		MOVQ BP, 0x20(SP)	
  0x43ca3c		488d6c2420		LEAQ 0x20(SP), BP	
	n = round(n, sys.PtrSize)
  0x43ca41		90			NOPL			
  0x43ca42		488b442438		MOVQ 0x38(SP), AX	
	return (n + a - 1) &^ (a - 1)
  0x43ca47		4883c007		ADDQ $0x7, AX		
  0x43ca4b		4883e0f8		ANDQ $-0x8, AX		
  0x43ca4f		4889442418		MOVQ AX, 0x18(SP)	
	if a.head == 0 || a.off+n > uintptr(len(a.head.ptr().data)) {
  0x43ca54		488b4c2430		MOVQ 0x30(SP), CX	
  0x43ca59		48833900		CMPQ $0x0, 0(CX)	
  0x43ca5d		757f			JNE 0x43cade		
		if n > uintptr(len(a.head.ptr().data)) {
  0x43ca5f		90			NOPL			
  0x43ca60		483df8ff0000		CMPQ $0xfff8, AX	
  0x43ca66		0f87ab000000		JA 0x43cb17		
		block := (*traceAllocBlock)(sysAlloc(unsafe.Sizeof(traceAllocBlock{}), &memstats.other_sys))
  0x43ca6c		48c7042400000100	MOVQ $0x10000, 0(SP)			
  0x43ca74		488d0585120a00		LEAQ runtime.memstats+160(SB), AX	
  0x43ca7b		4889442408		MOVQ AX, 0x8(SP)			
  0x43ca80		e87b49fdff		CALL runtime.sysAlloc(SB)		
  0x43ca85		488b442410		MOVQ 0x10(SP), AX			
		if block == nil {
  0x43ca8a		4885c0			TESTQ AX, AX		
  0x43ca8d		746d			JE 0x43cafc		
		block.next.set(a.head.ptr())
  0x43ca8f		90			NOPL			
  0x43ca90		488b4c2430		MOVQ 0x30(SP), CX	
  0x43ca95		488b11			MOVQ 0(CX), DX		
  0x43ca98		90			NOPL			
func (p *traceAllocBlockPtr) set(x *traceAllocBlock) { *p = traceAllocBlockPtr(unsafe.Pointer(x)) }
  0x43ca99		488910			MOVQ DX, 0(AX)		
		a.head.set(block)
  0x43ca9c		90			NOPL			
func (p *traceAllocBlockPtr) set(x *traceAllocBlock) { *p = traceAllocBlockPtr(unsafe.Pointer(x)) }
  0x43ca9d		488901			MOVQ AX, 0(CX)		
		a.off = 0
  0x43caa0		48c7410800000000	MOVQ $0x0, 0x8(CX)	
	p := &a.head.ptr().data[a.off]
  0x43caa8		488b01			MOVQ 0(CX), AX		
  0x43caab		8400			TESTB AL, 0(AX)		
  0x43caad		90			NOPL			
  0x43caae		488b5108		MOVQ 0x8(CX), DX	
  0x43cab2		4881faf8ff0000		CMPQ $0xfff8, DX	
  0x43cab9		733a			JAE 0x43caf5		
	a.off += n
  0x43cabb		488b5c2418		MOVQ 0x18(SP), BX	
  0x43cac0		4801d3			ADDQ DX, BX		
  0x43cac3		48895908		MOVQ BX, 0x8(CX)	
	p := &a.head.ptr().data[a.off]
  0x43cac7		488d0410		LEAQ 0(AX)(DX*1), AX	
  0x43cacb		488d4008		LEAQ 0x8(AX), AX	
	return unsafe.Pointer(p)
  0x43cacf		4889442440		MOVQ AX, 0x40(SP)	
  0x43cad4		488b6c2420		MOVQ 0x20(SP), BP	
  0x43cad9		4883c428		ADDQ $0x28, SP		
  0x43cadd		c3			RET			
	if a.head == 0 || a.off+n > uintptr(len(a.head.ptr().data)) {
  0x43cade		488b5108		MOVQ 0x8(CX), DX	
  0x43cae2		4801c2			ADDQ AX, DX		
  0x43cae5		90			NOPL			
  0x43cae6		4881faf8ff0000		CMPQ $0xfff8, DX	
  0x43caed		0f876cffffff		JA 0x43ca5f		
  0x43caf3		ebb3			JMP 0x43caa8		
	p := &a.head.ptr().data[a.off]
  0x43caf5		e82654feff		CALL runtime.panicindex(SB)	
  0x43cafa		0f0b			UD2				
			throw("trace: out of memory")
  0x43cafc		488d05723c0300		LEAQ 0x33c72(IP), AX	
  0x43cb03		48890424		MOVQ AX, 0(SP)		
  0x43cb07		48c744240814000000	MOVQ $0x14, 0x8(SP)	
  0x43cb10		e86b69feff		CALL runtime.throw(SB)	
  0x43cb15		0f0b			UD2			
			throw("trace: alloc too large")
  0x43cb17		488d051d400300		LEAQ 0x3401d(IP), AX	
  0x43cb1e		48890424		MOVQ AX, 0(SP)		
  0x43cb22		48c744240816000000	MOVQ $0x16, 0x8(SP)	
  0x43cb2b		e85069feff		CALL runtime.throw(SB)	
  0x43cb30		0f0b			UD2			
func (a *traceAlloc) alloc(n uintptr) unsafe.Pointer {
  0x43cb32		e849ad0000		CALL runtime.morestack_noctxt(SB)	
  0x43cb37		e9e4feffff		JMP runtime.(*traceAlloc).alloc(SB)	

TEXT runtime.traceProcStart(SB) /usr/local/go/src/runtime/trace.go
func traceProcStart() {
  0x43cb40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cb49		483b6110		CMPQ 0x10(CX), SP	
  0x43cb4d		7668			JBE 0x43cbb7		
  0x43cb4f		4883ec38		SUBQ $0x38, SP		
  0x43cb53		48896c2430		MOVQ BP, 0x30(SP)	
  0x43cb58		488d6c2430		LEAQ 0x30(SP), BP	
	traceEvent(traceEvProcStart, -1, uint64(getg().m.id))
  0x43cb5d		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43cb66		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX		
  0x43cb6f		488b4030		MOVQ 0x30(AX), AX		
  0x43cb73		488b80e8000000		MOVQ 0xe8(AX), AX		
  0x43cb7a		4889442428		MOVQ AX, 0x28(SP)		
  0x43cb7f		c6042405		MOVB $0x5, 0(SP)		
  0x43cb83		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43cb8c		488d442428		LEAQ 0x28(SP), AX		
  0x43cb91		4889442410		MOVQ AX, 0x10(SP)		
  0x43cb96		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43cb9f		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43cba8		e8f3f2ffff		CALL runtime.traceEvent(SB)	
}
  0x43cbad		488b6c2430		MOVQ 0x30(SP), BP	
  0x43cbb2		4883c438		ADDQ $0x38, SP		
  0x43cbb6		c3			RET			
func traceProcStart() {
  0x43cbb7		e8c4ac0000		CALL runtime.morestack_noctxt(SB)	
  0x43cbbc		eb82			JMP runtime.traceProcStart(SB)		

TEXT runtime.traceProcStop(SB) /usr/local/go/src/runtime/trace.go
func traceProcStop(pp *p) {
  0x43cbc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cbc9		483b6110		CMPQ 0x10(CX), SP	
  0x43cbcd		0f86b3000000		JBE 0x43cc86		
  0x43cbd3		4883ec40		SUBQ $0x40, SP		
  0x43cbd7		48896c2438		MOVQ BP, 0x38(SP)	
  0x43cbdc		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x43cbe1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x43cbea		488b4830		MOVQ 0x30(AX), CX	
	mp := acquirem()
  0x43cbee		90			NOPL			
	_g_.m.locks++
  0x43cbef		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x43cbf5		488b4830		MOVQ 0x30(AX), CX	
  0x43cbf9		48894c2430		MOVQ CX, 0x30(SP)	
  0x43cbfe		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43cc00		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x43cc07		4889442428		MOVQ AX, 0x28(SP)	
	mp.p.set(pp)
  0x43cc0c		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43cc0d		488b542448		MOVQ 0x48(SP), DX	
  0x43cc12		488991d0000000		MOVQ DX, 0xd0(CX)	
	traceEvent(traceEvProcStop, -1)
  0x43cc19		c6042406		MOVB $0x6, 0(SP)		
  0x43cc1d		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43cc26		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43cc2f		0f57c0			XORPS X0, X0			
  0x43cc32		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43cc37		e864f2ffff		CALL runtime.traceEvent(SB)	
	mp.p = oldp
  0x43cc3c		488b442428		MOVQ 0x28(SP), AX	
  0x43cc41		488b4c2430		MOVQ 0x30(SP), CX	
  0x43cc46		488981d0000000		MOVQ AX, 0xd0(CX)	
	releasem(mp)
  0x43cc4d		90			NOPL			
	_g_ := getg()
  0x43cc4e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x43cc57		8b9108010000		MOVL 0x108(CX), DX	
  0x43cc5d		8d5aff			LEAL -0x1(DX), BX	
  0x43cc60		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x43cc66		83fa01			CMPL $0x1, DX		
  0x43cc69		7511			JNE 0x43cc7c		
  0x43cc6b		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x43cc72		7408			JE 0x43cc7c		
		_g_.stackguard0 = stackPreempt
  0x43cc74		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43cc7c		488b6c2438		MOVQ 0x38(SP), BP	
  0x43cc81		4883c440		ADDQ $0x40, SP		
  0x43cc85		c3			RET			
func traceProcStop(pp *p) {
  0x43cc86		e8f5ab0000		CALL runtime.morestack_noctxt(SB)	
  0x43cc8b		e930ffffff		JMP runtime.traceProcStop(SB)		

TEXT runtime.traceGCSweepStart(SB) /usr/local/go/src/runtime/trace.go
func traceGCSweepStart() {
  0x43cc90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cc99		483b6110		CMPQ 0x10(CX), SP	
  0x43cc9d		7664			JBE 0x43cd03		
  0x43cc9f		4883ec18		SUBQ $0x18, SP		
  0x43cca3		48896c2410		MOVQ BP, 0x10(SP)	
  0x43cca8		488d6c2410		LEAQ 0x10(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43ccad		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43ccb6		488b4030		MOVQ 0x30(AX), AX	
  0x43ccba		488b80d0000000		MOVQ 0xd0(AX), AX	
	if _p_.traceSweep {
  0x43ccc1		8400			TESTB AL, 0(AX)		
	_p_ := getg().m.p.ptr()
  0x43ccc3		90			NOPL			
	if _p_.traceSweep {
  0x43ccc4		80b82012000000		CMPB $0x0, 0x1220(AX)	
  0x43cccb		751b			JNE 0x43cce8		
	_p_.traceSweep, _p_.traceSwept, _p_.traceReclaimed = true, 0, 0
  0x43cccd		c6802012000001		MOVB $0x1, 0x1220(AX)	
  0x43ccd4		0f57c0			XORPS X0, X0		
  0x43ccd7		0f118028120000		MOVUPS X0, 0x1228(AX)	
}
  0x43ccde		488b6c2410		MOVQ 0x10(SP), BP	
  0x43cce3		4883c418		ADDQ $0x18, SP		
  0x43cce7		c3			RET			
		throw("double traceGCSweepStart")
  0x43cce8		488d058b410300		LEAQ 0x3418b(IP), AX	
  0x43ccef		48890424		MOVQ AX, 0(SP)		
  0x43ccf3		48c744240818000000	MOVQ $0x18, 0x8(SP)	
  0x43ccfc		e87f67feff		CALL runtime.throw(SB)	
  0x43cd01		0f0b			UD2			
func traceGCSweepStart() {
  0x43cd03		e878ab0000		CALL runtime.morestack_noctxt(SB)	
  0x43cd08		eb86			JMP runtime.traceGCSweepStart(SB)	

TEXT runtime.traceGCSweepSpan(SB) /usr/local/go/src/runtime/trace.go
func traceGCSweepSpan(bytesSwept uintptr) {
  0x43cd10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cd19		483b6110		CMPQ 0x10(CX), SP	
  0x43cd1d		767d			JBE 0x43cd9c		
  0x43cd1f		4883ec38		SUBQ $0x38, SP		
  0x43cd23		48896c2430		MOVQ BP, 0x30(SP)	
  0x43cd28		488d6c2430		LEAQ 0x30(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43cd2d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43cd36		488b4030		MOVQ 0x30(AX), AX	
  0x43cd3a		488b80d0000000		MOVQ 0xd0(AX), AX	
	if _p_.traceSweep {
  0x43cd41		8400			TESTB AL, 0(AX)		
	_p_ := getg().m.p.ptr()
  0x43cd43		90			NOPL			
	if _p_.traceSweep {
  0x43cd44		80b82012000000		CMPB $0x0, 0x1220(AX)	
  0x43cd4b		7416			JE 0x43cd63		
		if _p_.traceSwept == 0 {
  0x43cd4d		4883b82812000000	CMPQ $0x0, 0x1228(AX)	
  0x43cd55		7416			JE 0x43cd6d		
		_p_.traceSwept += bytesSwept
  0x43cd57		488b4c2440		MOVQ 0x40(SP), CX	
  0x43cd5c		48018828120000		ADDQ CX, 0x1228(AX)	
  0x43cd63		488b6c2430		MOVQ 0x30(SP), BP	
  0x43cd68		4883c438		ADDQ $0x38, SP		
  0x43cd6c		c3			RET			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x43cd6d		4889442428		MOVQ AX, 0x28(SP)	
			traceEvent(traceEvGCSweepStart, 1)
  0x43cd72		c604240b		MOVB $0xb, 0(SP)		
  0x43cd76		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43cd7f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43cd88		0f57c0			XORPS X0, X0			
  0x43cd8b		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43cd90		e80bf1ffff		CALL runtime.traceEvent(SB)	
		_p_.traceSwept += bytesSwept
  0x43cd95		488b442428		MOVQ 0x28(SP), AX	
			traceEvent(traceEvGCSweepStart, 1)
  0x43cd9a		ebbb			JMP 0x43cd57		
func traceGCSweepSpan(bytesSwept uintptr) {
  0x43cd9c		e8dfaa0000		CALL runtime.morestack_noctxt(SB)	
  0x43cda1		e96affffff		JMP runtime.traceGCSweepSpan(SB)	

TEXT runtime.traceGCSweepDone(SB) /usr/local/go/src/runtime/trace.go
func traceGCSweepDone() {
  0x43cdb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cdb9		483b6110		CMPQ 0x10(CX), SP	
  0x43cdbd		0f86be000000		JBE 0x43ce81		
  0x43cdc3		4883ec48		SUBQ $0x48, SP		
  0x43cdc7		48896c2440		MOVQ BP, 0x40(SP)	
  0x43cdcc		488d6c2440		LEAQ 0x40(SP), BP	
	_p_ := getg().m.p.ptr()
  0x43cdd1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43cdda		488b4030		MOVQ 0x30(AX), AX	
  0x43cdde		488b80d0000000		MOVQ 0xd0(AX), AX	
	if !_p_.traceSweep {
  0x43cde5		8400			TESTB AL, 0(AX)		
	_p_ := getg().m.p.ptr()
  0x43cde7		90			NOPL			
	if !_p_.traceSweep {
  0x43cde8		80b82012000000		CMPB $0x0, 0x1220(AX)	
  0x43cdef		7475			JE 0x43ce66		
	if _p_.traceSwept != 0 {
  0x43cdf1		4883b82812000000	CMPQ $0x0, 0x1228(AX)	
  0x43cdf9		7511			JNE 0x43ce0c		
	_p_.traceSweep = false
  0x43cdfb		c6802012000000		MOVB $0x0, 0x1220(AX)	
}
  0x43ce02		488b6c2440		MOVQ 0x40(SP), BP	
  0x43ce07		4883c448		ADDQ $0x48, SP		
  0x43ce0b		c3			RET			
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x43ce0c		4889442438		MOVQ AX, 0x38(SP)	
		traceEvent(traceEvGCSweepDone, -1, uint64(_p_.traceSwept), uint64(_p_.traceReclaimed))
  0x43ce11		0f57c0			XORPS X0, X0			
  0x43ce14		0f11442428		MOVUPS X0, 0x28(SP)		
  0x43ce19		488b8828120000		MOVQ 0x1228(AX), CX		
  0x43ce20		48894c2428		MOVQ CX, 0x28(SP)		
  0x43ce25		488b8830120000		MOVQ 0x1230(AX), CX		
  0x43ce2c		48894c2430		MOVQ CX, 0x30(SP)		
  0x43ce31		c604240c		MOVB $0xc, 0(SP)		
  0x43ce35		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43ce3e		488d4c2428		LEAQ 0x28(SP), CX		
  0x43ce43		48894c2410		MOVQ CX, 0x10(SP)		
  0x43ce48		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43ce51		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43ce5a		e841f0ffff		CALL runtime.traceEvent(SB)	
	_p_.traceSweep = false
  0x43ce5f		488b442438		MOVQ 0x38(SP), AX	
		traceEvent(traceEvGCSweepDone, -1, uint64(_p_.traceSwept), uint64(_p_.traceReclaimed))
  0x43ce64		eb95			JMP 0x43cdfb		
		throw("missing traceGCSweepStart")
  0x43ce66		488d05f7410300		LEAQ 0x341f7(IP), AX	
  0x43ce6d		48890424		MOVQ AX, 0(SP)		
  0x43ce71		48c744240819000000	MOVQ $0x19, 0x8(SP)	
  0x43ce7a		e80166feff		CALL runtime.throw(SB)	
  0x43ce7f		0f0b			UD2			
func traceGCSweepDone() {
  0x43ce81		e8faa90000		CALL runtime.morestack_noctxt(SB)	
  0x43ce86		e925ffffff		JMP runtime.traceGCSweepDone(SB)	

TEXT runtime.traceGoCreate(SB) /usr/local/go/src/runtime/trace.go
func traceGoCreate(newg *g, pc uintptr) {
  0x43ce90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ce99		483b6110		CMPQ 0x10(CX), SP	
  0x43ce9d		0f86da000000		JBE 0x43cf7d		
  0x43cea3		4883ec40		SUBQ $0x40, SP		
  0x43cea7		48896c2438		MOVQ BP, 0x38(SP)	
  0x43ceac		488d6c2438		LEAQ 0x38(SP), BP	
	newg.traceseq = 0
  0x43ceb1		488b442448		MOVQ 0x48(SP), AX	
  0x43ceb6		48c780c800000000000000	MOVQ $0x0, 0xc8(AX)	
	newg.tracelastp = getg().m.p
  0x43cec1		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43ceca		488b4930		MOVQ 0x30(CX), CX	
  0x43cece		488b89d0000000		MOVQ 0xd0(CX), CX	
  0x43ced5		488988d0000000		MOVQ CX, 0xd0(AX)	
	id := trace.stackTab.put([]uintptr{pc + sys.PCQuantum})
  0x43cedc		488d0d1def0100		LEAQ 0x1ef1d(IP), CX			
  0x43cee3		48890c24		MOVQ CX, 0(SP)				
  0x43cee7		e864d8fcff		CALL runtime.newobject(SB)		
  0x43ceec		488b442408		MOVQ 0x8(SP), AX			
  0x43cef1		488b4c2450		MOVQ 0x50(SP), CX			
  0x43cef6		48ffc1			INCQ CX					
  0x43cef9		488908			MOVQ CX, 0(AX)				
  0x43cefc		488d0d2dfd0800		LEAQ runtime.trace+112(SB), CX		
  0x43cf03		48890c24		MOVQ CX, 0(SP)				
  0x43cf07		4889442408		MOVQ AX, 0x8(SP)			
  0x43cf0c		48c744241001000000	MOVQ $0x1, 0x10(SP)			
  0x43cf15		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43cf1e		e8fdf7ffff		CALL runtime.(*traceStackTable).put(SB)	
  0x43cf23		8b442420		MOVL 0x20(SP), AX			
	traceEvent(traceEvGoCreate, 2, uint64(newg.goid), uint64(id))
  0x43cf27		0f57c0			XORPS X0, X0			
  0x43cf2a		0f11442428		MOVUPS X0, 0x28(SP)		
  0x43cf2f		488b4c2448		MOVQ 0x48(SP), CX		
  0x43cf34		488b8998000000		MOVQ 0x98(CX), CX		
  0x43cf3b		48894c2428		MOVQ CX, 0x28(SP)		
  0x43cf40		4889442430		MOVQ AX, 0x30(SP)		
  0x43cf45		c604240d		MOVB $0xd, 0(SP)		
  0x43cf49		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43cf52		488d442428		LEAQ 0x28(SP), AX		
  0x43cf57		4889442410		MOVQ AX, 0x10(SP)		
  0x43cf5c		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43cf65		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43cf6e		e82defffff		CALL runtime.traceEvent(SB)	
}
  0x43cf73		488b6c2438		MOVQ 0x38(SP), BP	
  0x43cf78		4883c440		ADDQ $0x40, SP		
  0x43cf7c		c3			RET			
func traceGoCreate(newg *g, pc uintptr) {
  0x43cf7d		e8fea80000		CALL runtime.morestack_noctxt(SB)	
  0x43cf82		e909ffffff		JMP runtime.traceGoCreate(SB)		

TEXT runtime.traceGoStart(SB) /usr/local/go/src/runtime/trace.go
func traceGoStart() {
  0x43cf90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43cf99		483b6110		CMPQ 0x10(CX), SP	
  0x43cf9d		0f867d010000		JBE 0x43d120		
  0x43cfa3		4883ec60		SUBQ $0x60, SP		
  0x43cfa7		48896c2458		MOVQ BP, 0x58(SP)	
  0x43cfac		488d6c2458		LEAQ 0x58(SP), BP	
	_g_ := getg().m.curg
  0x43cfb1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43cfba		488b4030		MOVQ 0x30(AX), AX	
  0x43cfbe		488b80c0000000		MOVQ 0xc0(AX), AX	
	_p_ := _g_.m.p
  0x43cfc5		488b4830		MOVQ 0x30(AX), CX	
  0x43cfc9		488b89d0000000		MOVQ 0xd0(CX), CX	
	_g_.traceseq++
  0x43cfd0		48ff80c8000000		INCQ 0xc8(AX)		
func (pp puintptr) ptr() *p { return (*p)(unsafe.Pointer(pp)) }
  0x43cfd7		4889ca			MOVQ CX, DX		
	if _g_ == _p_.ptr().gcBgMarkWorker.ptr() {
  0x43cfda		8401			TESTB AL, 0(CX)		
  0x43cfdc		90			NOPL			
  0x43cfdd		488b9958120000		MOVQ 0x1258(CX), BX	
  0x43cfe4		90			NOPL			
  0x43cfe5		4839d8			CMPQ BX, AX		
  0x43cfe8		0f8583000000		JNE 0x43d071		
		traceEvent(traceEvGoStartLabel, -1, uint64(_g_.goid), _g_.traceseq, trace.markWorkerLabels[_p_.ptr().gcMarkWorkerMode])
  0x43cfee		90			NOPL					
  0x43cfef		48c744244000000000	MOVQ $0x0, 0x40(SP)			
  0x43cff8		0f57c0			XORPS X0, X0				
  0x43cffb		0f11442448		MOVUPS X0, 0x48(SP)			
  0x43d000		488b9098000000		MOVQ 0x98(AX), DX			
  0x43d007		4889542440		MOVQ DX, 0x40(SP)			
  0x43d00c		488b80c8000000		MOVQ 0xc8(AX), AX			
  0x43d013		4889442448		MOVQ AX, 0x48(SP)			
  0x43d018		488b8160120000		MOVQ 0x1260(CX), AX			
  0x43d01f		4883f803		CMPQ $0x3, AX				
  0x43d023		0f83f0000000		JAE 0x43d119				
  0x43d029		488d0d38fc0900		LEAQ runtime.trace+65704(SB), CX	
  0x43d030		488b04c1		MOVQ 0(CX)(AX*8), AX			
  0x43d034		4889442450		MOVQ AX, 0x50(SP)			
  0x43d039		c6042429		MOVB $0x29, 0(SP)			
  0x43d03d		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43d046		488d442440		LEAQ 0x40(SP), AX			
  0x43d04b		4889442410		MOVQ AX, 0x10(SP)			
  0x43d050		48c744241803000000	MOVQ $0x3, 0x18(SP)			
  0x43d059		48c744242003000000	MOVQ $0x3, 0x20(SP)			
  0x43d062		e839eeffff		CALL runtime.traceEvent(SB)		
  0x43d067		488b6c2458		MOVQ 0x58(SP), BP			
  0x43d06c		4883c460		ADDQ $0x60, SP				
  0x43d070		c3			RET					
	} else if _g_.tracelastp == _p_ {
  0x43d071		483990d0000000		CMPQ DX, 0xd0(AX)	
  0x43d078		7545			JNE 0x43d0bf		
		traceEvent(traceEvGoStartLocal, -1, uint64(_g_.goid))
  0x43d07a		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43d083		488b8098000000		MOVQ 0x98(AX), AX		
  0x43d08a		4889442428		MOVQ AX, 0x28(SP)		
  0x43d08f		c6042426		MOVB $0x26, 0(SP)		
  0x43d093		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43d09c		488d442428		LEAQ 0x28(SP), AX		
  0x43d0a1		4889442410		MOVQ AX, 0x10(SP)		
  0x43d0a6		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43d0af		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43d0b8		e8e3edffff		CALL runtime.traceEvent(SB)	
  0x43d0bd		eba8			JMP 0x43d067			
		_g_.tracelastp = _p_
  0x43d0bf		488990d0000000		MOVQ DX, 0xd0(AX)	
		traceEvent(traceEvGoStart, -1, uint64(_g_.goid), _g_.traceseq)
  0x43d0c6		0f57c0			XORPS X0, X0			
  0x43d0c9		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43d0ce		488b8898000000		MOVQ 0x98(AX), CX		
  0x43d0d5		48894c2430		MOVQ CX, 0x30(SP)		
  0x43d0da		488b80c8000000		MOVQ 0xc8(AX), AX		
  0x43d0e1		4889442438		MOVQ AX, 0x38(SP)		
  0x43d0e6		c604240e		MOVB $0xe, 0(SP)		
  0x43d0ea		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43d0f3		488d442430		LEAQ 0x30(SP), AX		
  0x43d0f8		4889442410		MOVQ AX, 0x10(SP)		
  0x43d0fd		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43d106		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43d10f		e88cedffff		CALL runtime.traceEvent(SB)	
  0x43d114		e94effffff		JMP 0x43d067			
		traceEvent(traceEvGoStartLabel, -1, uint64(_g_.goid), _g_.traceseq, trace.markWorkerLabels[_p_.ptr().gcMarkWorkerMode])
  0x43d119		e8024efeff		CALL runtime.panicindex(SB)	
  0x43d11e		0f0b			UD2				
func traceGoStart() {
  0x43d120		e85ba70000		CALL runtime.morestack_noctxt(SB)	
  0x43d125		e966feffff		JMP runtime.traceGoStart(SB)		

TEXT runtime.traceGoPark(SB) /usr/local/go/src/runtime/trace.go
func traceGoPark(traceEv byte, skip int) {
  0x43d130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d139		483b6110		CMPQ 0x10(CX), SP	
  0x43d13d		7672			JBE 0x43d1b1		
  0x43d13f		4883ec30		SUBQ $0x30, SP		
  0x43d143		48896c2428		MOVQ BP, 0x28(SP)	
  0x43d148		488d6c2428		LEAQ 0x28(SP), BP	
	if traceEv&traceFutileWakeup != 0 {
  0x43d14d		0fb6442438		MOVZX 0x38(SP), AX	
  0x43d152		f6c080			TESTL $0x80, AL		
  0x43d155		7530			JNE 0x43d187		
	traceEvent(traceEv & ^traceFutileWakeup, skip)
  0x43d157		83e07f			ANDL $0x7f, AX			
  0x43d15a		880424			MOVB AL, 0(SP)			
  0x43d15d		488b442440		MOVQ 0x40(SP), AX		
  0x43d162		4889442408		MOVQ AX, 0x8(SP)		
  0x43d167		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43d170		0f57c0			XORPS X0, X0			
  0x43d173		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43d178		e823edffff		CALL runtime.traceEvent(SB)	
}
  0x43d17d		488b6c2428		MOVQ 0x28(SP), BP	
  0x43d182		4883c430		ADDQ $0x30, SP		
  0x43d186		c3			RET			
		traceEvent(traceEvFutileWakeup, -1)
  0x43d187		c6042424		MOVB $0x24, 0(SP)		
  0x43d18b		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43d194		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43d19d		0f57c0			XORPS X0, X0			
  0x43d1a0		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43d1a5		e8f6ecffff		CALL runtime.traceEvent(SB)	
	traceEvent(traceEv & ^traceFutileWakeup, skip)
  0x43d1aa		0fb6442438		MOVZX 0x38(SP), AX	
		traceEvent(traceEvFutileWakeup, -1)
  0x43d1af		eba6			JMP 0x43d157		
func traceGoPark(traceEv byte, skip int) {
  0x43d1b1		e8caa60000		CALL runtime.morestack_noctxt(SB)	
  0x43d1b6		e975ffffff		JMP runtime.traceGoPark(SB)		

TEXT runtime.traceGoUnpark(SB) /usr/local/go/src/runtime/trace.go
func traceGoUnpark(gp *g, skip int) {
  0x43d1c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d1c9		483b6110		CMPQ 0x10(CX), SP	
  0x43d1cd		0f86dd000000		JBE 0x43d2b0		
  0x43d1d3		4883ec48		SUBQ $0x48, SP		
  0x43d1d7		48896c2440		MOVQ BP, 0x40(SP)	
  0x43d1dc		488d6c2440		LEAQ 0x40(SP), BP	
	_p_ := getg().m.p
  0x43d1e1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x43d1ea		488b4030		MOVQ 0x30(AX), AX	
  0x43d1ee		488b80d0000000		MOVQ 0xd0(AX), AX	
	gp.traceseq++
  0x43d1f5		488b4c2450		MOVQ 0x50(SP), CX	
  0x43d1fa		48ff81c8000000		INCQ 0xc8(CX)		
	if gp.tracelastp == _p_ {
  0x43d201		483981d0000000		CMPQ AX, 0xd0(CX)	
  0x43d208		754e			JNE 0x43d258		
		traceEvent(traceEvGoUnblockLocal, skip, uint64(gp.goid))
  0x43d20a		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43d213		488b8198000000		MOVQ 0x98(CX), AX		
  0x43d21a		4889442428		MOVQ AX, 0x28(SP)		
  0x43d21f		c6042427		MOVB $0x27, 0(SP)		
  0x43d223		488b442458		MOVQ 0x58(SP), AX		
  0x43d228		4889442408		MOVQ AX, 0x8(SP)		
  0x43d22d		488d442428		LEAQ 0x28(SP), AX		
  0x43d232		4889442410		MOVQ AX, 0x10(SP)		
  0x43d237		48c744241801000000	MOVQ $0x1, 0x18(SP)		
  0x43d240		48c744242001000000	MOVQ $0x1, 0x20(SP)		
  0x43d249		e852ecffff		CALL runtime.traceEvent(SB)	
  0x43d24e		488b6c2440		MOVQ 0x40(SP), BP		
  0x43d253		4883c448		ADDQ $0x48, SP			
  0x43d257		c3			RET				
		gp.tracelastp = _p_
  0x43d258		488981d0000000		MOVQ AX, 0xd0(CX)	
		traceEvent(traceEvGoUnblock, skip, uint64(gp.goid), gp.traceseq)
  0x43d25f		0f57c0			XORPS X0, X0			
  0x43d262		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43d267		488b8198000000		MOVQ 0x98(CX), AX		
  0x43d26e		4889442430		MOVQ AX, 0x30(SP)		
  0x43d273		488b81c8000000		MOVQ 0xc8(CX), AX		
  0x43d27a		4889442438		MOVQ AX, 0x38(SP)		
  0x43d27f		c6042415		MOVB $0x15, 0(SP)		
  0x43d283		488b442458		MOVQ 0x58(SP), AX		
  0x43d288		4889442408		MOVQ AX, 0x8(SP)		
  0x43d28d		488d442430		LEAQ 0x30(SP), AX		
  0x43d292		4889442410		MOVQ AX, 0x10(SP)		
  0x43d297		48c744241802000000	MOVQ $0x2, 0x18(SP)		
  0x43d2a0		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43d2a9		e8f2ebffff		CALL runtime.traceEvent(SB)	
  0x43d2ae		eb9e			JMP 0x43d24e			
func traceGoUnpark(gp *g, skip int) {
  0x43d2b0		e8cba50000		CALL runtime.morestack_noctxt(SB)	
  0x43d2b5		e906ffffff		JMP runtime.traceGoUnpark(SB)		

TEXT runtime.traceGoSysCall(SB) /usr/local/go/src/runtime/trace.go
func traceGoSysCall() {
  0x43d2c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d2c9		483b6110		CMPQ 0x10(CX), SP	
  0x43d2cd		763b			JBE 0x43d30a		
  0x43d2cf		4883ec30		SUBQ $0x30, SP		
  0x43d2d3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43d2d8		488d6c2428		LEAQ 0x28(SP), BP	
	traceEvent(traceEvGoSysCall, 1)
  0x43d2dd		c604241c		MOVB $0x1c, 0(SP)		
  0x43d2e1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43d2ea		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43d2f3		0f57c0			XORPS X0, X0			
  0x43d2f6		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43d2fb		e8a0ebffff		CALL runtime.traceEvent(SB)	
}
  0x43d300		488b6c2428		MOVQ 0x28(SP), BP	
  0x43d305		4883c430		ADDQ $0x30, SP		
  0x43d309		c3			RET			
func traceGoSysCall() {
  0x43d30a		e871a50000		CALL runtime.morestack_noctxt(SB)	
  0x43d30f		ebaf			JMP runtime.traceGoSysCall(SB)		

TEXT runtime.traceGoSysExit(SB) /usr/local/go/src/runtime/trace.go
func traceGoSysExit(ts int64) {
  0x43d320		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d329		483b6110		CMPQ 0x10(CX), SP	
  0x43d32d		0f86ba000000		JBE 0x43d3ed		
  0x43d333		4883ec48		SUBQ $0x48, SP		
  0x43d337		48896c2440		MOVQ BP, 0x40(SP)	
  0x43d33c		488d6c2440		LEAQ 0x40(SP), BP	
	if ts != 0 && ts < trace.ticksStart {
  0x43d341		488b442450		MOVQ 0x50(SP), AX		
  0x43d346		4885c0			TESTQ AX, AX			
  0x43d349		740b			JE 0x43d356			
  0x43d34b		4839058ef80800		CMPQ AX, runtime.trace+32(SB)	
  0x43d352		7e02			JLE 0x43d356			
  0x43d354		31c0			XORL AX, AX			
	_g_ := getg().m.curg
  0x43d356		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d35f		488b4930		MOVQ 0x30(CX), CX	
  0x43d363		488b89c0000000		MOVQ 0xc0(CX), CX	
	_g_.traceseq++
  0x43d36a		48ff81c8000000		INCQ 0xc8(CX)		
	_g_.tracelastp = _g_.m.p
  0x43d371		488b5130		MOVQ 0x30(CX), DX	
  0x43d375		488b92d0000000		MOVQ 0xd0(DX), DX	
  0x43d37c		488991d0000000		MOVQ DX, 0xd0(CX)	
	traceEvent(traceEvGoSysExit, -1, uint64(_g_.goid), _g_.traceseq, uint64(ts)/traceTickDiv)
  0x43d383		48c744242800000000	MOVQ $0x0, 0x28(SP)		
  0x43d38c		0f57c0			XORPS X0, X0			
  0x43d38f		0f11442430		MOVUPS X0, 0x30(SP)		
  0x43d394		488b9198000000		MOVQ 0x98(CX), DX		
  0x43d39b		4889542428		MOVQ DX, 0x28(SP)		
  0x43d3a0		488b89c8000000		MOVQ 0xc8(CX), CX		
  0x43d3a7		48894c2430		MOVQ CX, 0x30(SP)		
  0x43d3ac		48c1e806		SHRQ $0x6, AX			
  0x43d3b0		4889442438		MOVQ AX, 0x38(SP)		
  0x43d3b5		c604241d		MOVB $0x1d, 0(SP)		
  0x43d3b9		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43d3c2		488d442428		LEAQ 0x28(SP), AX		
  0x43d3c7		4889442410		MOVQ AX, 0x10(SP)		
  0x43d3cc		48c744241803000000	MOVQ $0x3, 0x18(SP)		
  0x43d3d5		48c744242003000000	MOVQ $0x3, 0x20(SP)		
  0x43d3de		e8bdeaffff		CALL runtime.traceEvent(SB)	
}
  0x43d3e3		488b6c2440		MOVQ 0x40(SP), BP	
  0x43d3e8		4883c448		ADDQ $0x48, SP		
  0x43d3ec		c3			RET			
func traceGoSysExit(ts int64) {
  0x43d3ed		e88ea40000		CALL runtime.morestack_noctxt(SB)	
  0x43d3f2		e929ffffff		JMP runtime.traceGoSysExit(SB)		

TEXT runtime.traceGoSysBlock(SB) /usr/local/go/src/runtime/trace.go
func traceGoSysBlock(pp *p) {
  0x43d400		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d409		483b6110		CMPQ 0x10(CX), SP	
  0x43d40d		0f86b3000000		JBE 0x43d4c6		
  0x43d413		4883ec40		SUBQ $0x40, SP		
  0x43d417		48896c2438		MOVQ BP, 0x38(SP)	
  0x43d41c		488d6c2438		LEAQ 0x38(SP), BP	
	_g_ := getg()
  0x43d421		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	_g_.m.locks++
  0x43d42a		488b4830		MOVQ 0x30(AX), CX	
	mp := acquirem()
  0x43d42e		90			NOPL			
	_g_.m.locks++
  0x43d42f		ff8108010000		INCL 0x108(CX)		
	return _g_.m
  0x43d435		488b4830		MOVQ 0x30(AX), CX	
  0x43d439		48894c2430		MOVQ CX, 0x30(SP)	
  0x43d43e		8400			TESTB AL, 0(AX)		
	oldp := mp.p
  0x43d440		488b81d0000000		MOVQ 0xd0(CX), AX	
  0x43d447		4889442428		MOVQ AX, 0x28(SP)	
	mp.p.set(pp)
  0x43d44c		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x43d44d		488b542448		MOVQ 0x48(SP), DX	
  0x43d452		488991d0000000		MOVQ DX, 0xd0(CX)	
	traceEvent(traceEvGoSysBlock, -1)
  0x43d459		c604241e		MOVB $0x1e, 0(SP)		
  0x43d45d		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x43d466		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43d46f		0f57c0			XORPS X0, X0			
  0x43d472		0f11442418		MOVUPS X0, 0x18(SP)		
  0x43d477		e824eaffff		CALL runtime.traceEvent(SB)	
	mp.p = oldp
  0x43d47c		488b442428		MOVQ 0x28(SP), AX	
  0x43d481		488b4c2430		MOVQ 0x30(SP), CX	
  0x43d486		488981d0000000		MOVQ AX, 0xd0(CX)	
	releasem(mp)
  0x43d48d		90			NOPL			
	_g_ := getg()
  0x43d48e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	mp.locks--
  0x43d497		8b9108010000		MOVL 0x108(CX), DX	
  0x43d49d		8d5aff			LEAL -0x1(DX), BX	
  0x43d4a0		899908010000		MOVL BX, 0x108(CX)	
	if mp.locks == 0 && _g_.preempt {
  0x43d4a6		83fa01			CMPL $0x1, DX		
  0x43d4a9		7511			JNE 0x43d4bc		
  0x43d4ab		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x43d4b2		7408			JE 0x43d4bc		
		_g_.stackguard0 = stackPreempt
  0x43d4b4		48c74010defaffff	MOVQ $-0x522, 0x10(AX)	
  0x43d4bc		488b6c2438		MOVQ 0x38(SP), BP	
  0x43d4c1		4883c440		ADDQ $0x40, SP		
  0x43d4c5		c3			RET			
func traceGoSysBlock(pp *p) {
  0x43d4c6		e8b5a30000		CALL runtime.morestack_noctxt(SB)	
  0x43d4cb		e930ffffff		JMP runtime.traceGoSysBlock(SB)		

TEXT runtime.traceNextGC(SB) /usr/local/go/src/runtime/trace.go
func traceNextGC() {
  0x43d4d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d4d9		483b6110		CMPQ 0x10(CX), SP	
  0x43d4dd		0f86a1000000		JBE 0x43d584		
  0x43d4e3		4883ec38		SUBQ $0x38, SP		
  0x43d4e7		48896c2430		MOVQ BP, 0x30(SP)	
  0x43d4ec		488d6c2430		LEAQ 0x30(SP), BP	
	if memstats.next_gc == ^uint64(0) {
  0x43d4f1		48833d0f080a00ff	CMPQ $-0x1, runtime.memstats+168(SB)	
  0x43d4f9		7544			JNE 0x43d53f				
		traceEvent(traceEvNextGC, -1, 0)
  0x43d4fb		488b0546f80300		MOVQ runtime.statictmp_44(SB), AX	
  0x43d502		4889442428		MOVQ AX, 0x28(SP)			
  0x43d507		c6042422		MOVB $0x22, 0(SP)			
  0x43d50b		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43d514		488d442428		LEAQ 0x28(SP), AX			
  0x43d519		4889442410		MOVQ AX, 0x10(SP)			
  0x43d51e		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43d527		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x43d530		e86be9ffff		CALL runtime.traceEvent(SB)		
  0x43d535		488b6c2430		MOVQ 0x30(SP), BP			
  0x43d53a		4883c438		ADDQ $0x38, SP				
  0x43d53e		c3			RET					
		traceEvent(traceEvNextGC, -1, memstats.next_gc)
  0x43d53f		48c744242800000000	MOVQ $0x0, 0x28(SP)			
  0x43d548		488b05b9070a00		MOVQ runtime.memstats+168(SB), AX	
  0x43d54f		4889442428		MOVQ AX, 0x28(SP)			
  0x43d554		c6042422		MOVB $0x22, 0(SP)			
  0x43d558		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)			
  0x43d561		488d442428		LEAQ 0x28(SP), AX			
  0x43d566		4889442410		MOVQ AX, 0x10(SP)			
  0x43d56b		48c744241801000000	MOVQ $0x1, 0x18(SP)			
  0x43d574		48c744242001000000	MOVQ $0x1, 0x20(SP)			
  0x43d57d		e81ee9ffff		CALL runtime.traceEvent(SB)		
  0x43d582		ebb1			JMP 0x43d535				
func traceNextGC() {
  0x43d584		e8f7a20000		CALL runtime.morestack_noctxt(SB)	
  0x43d589		e942ffffff		JMP runtime.traceNextGC(SB)		

TEXT runtime.tracebackdefers(SB) /usr/local/go/src/runtime/traceback.go
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer) {
  0x43d590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d599		488d4424d0		LEAQ -0x30(SP), AX	
  0x43d59e		483b4110		CMPQ 0x10(CX), AX	
  0x43d5a2		0f8607020000		JBE 0x43d7af		
  0x43d5a8		4881ecb0000000		SUBQ $0xb0, SP		
  0x43d5af		4889ac24a8000000	MOVQ BP, 0xa8(SP)	
  0x43d5b7		488dac24a8000000	LEAQ 0xa8(SP), BP	
	var frame stkframe
  0x43d5bf		48c744245000000000	MOVQ $0x0, 0x50(SP)	
  0x43d5c8		488d7c2458		LEAQ 0x58(SP), DI	
  0x43d5cd		0f57c0			XORPS X0, X0		
  0x43d5d0		488d7fd0		LEAQ -0x30(DI), DI	
  0x43d5d4		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43d5d9		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43d5de		e822cb0000		CALL 0x44a105		
  0x43d5e3		488b6d00		MOVQ 0(BP), BP		
	for d := gp._defer; d != nil; d = d.link {
  0x43d5e7		488b8424b8000000	MOVQ 0xb8(SP), AX	
  0x43d5ef		488b4028		MOVQ 0x28(AX), AX	
  0x43d5f3		eb0c			JMP 0x43d601		
  0x43d5f5		488b4c2448		MOVQ 0x48(SP), CX	
  0x43d5fa		488b4128		MOVQ 0x28(CX), AX	
	var frame stkframe
  0x43d5fe		0f57c0			XORPS X0, X0		
	for d := gp._defer; d != nil; d = d.link {
  0x43d601		4885c0			TESTQ AX, AX		
  0x43d604		0f843a010000		JE 0x43d744		
  0x43d60a		4889442448		MOVQ AX, 0x48(SP)	
		fn := d.fn
  0x43d60f		488b4818		MOVQ 0x18(AX), CX	
		if fn == nil {
  0x43d613		4885c9			TESTQ CX, CX		
  0x43d616		7567			JNE 0x43d67f		
			frame.pc = 0
  0x43d618		48c744246000000000	MOVQ $0x0, 0x60(SP)	
			frame.fn = funcInfo{}
  0x43d621		0f11442450		MOVUPS X0, 0x50(SP)	
			frame.arglen = 0
  0x43d626		0f11842490000000	MOVUPS X0, 0x90(SP)	
			frame.argmap = nil
  0x43d62e		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
		frame.continpc = frame.pc
  0x43d63a		488b442460		MOVQ 0x60(SP), AX	
  0x43d63f		4889442468		MOVQ AX, 0x68(SP)	
		if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
  0x43d644		90			NOPL			
  0x43d645		488d442450		LEAQ 0x50(SP), AX	
  0x43d64a		48890424		MOVQ AX, 0(SP)		
  0x43d64e		488b8c24c8000000	MOVQ 0xc8(SP), CX	
  0x43d656		48894c2408		MOVQ CX, 0x8(SP)	
  0x43d65b		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x43d663		488b1a			MOVQ 0(DX), BX		
  0x43d666		ffd3			CALL BX			
  0x43d668		807c241000		CMPB $0x0, 0x10(SP)	
  0x43d66d		7586			JNE 0x43d5f5		
			return
  0x43d66f		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x43d677		4881c4b0000000		ADDQ $0xb0, SP		
  0x43d67e		c3			RET			
		fn := d.fn
  0x43d67f		48894c2440		MOVQ CX, 0x40(SP)	
			frame.pc = fn.fn
  0x43d684		488b01			MOVQ 0(CX), AX		
  0x43d687		4889442460		MOVQ AX, 0x60(SP)	
			f := findfunc(frame.pc)
  0x43d68c		48890424		MOVQ AX, 0(SP)			
  0x43d690		e86bd4ffff		CALL runtime.findfunc(SB)	
  0x43d695		488b442410		MOVQ 0x10(SP), AX		
  0x43d69a		488b4c2408		MOVQ 0x8(SP), CX		
			if !f.valid() {
  0x43d69f		90			NOPL			
	return f._func != nil
  0x43d6a0		4885c9			TESTQ CX, CX		
			if !f.valid() {
  0x43d6a3		0f84ab000000		JE 0x43d754		
			frame.fn = f
  0x43d6a9		48894c2450		MOVQ CX, 0x50(SP)	
  0x43d6ae		4889442458		MOVQ AX, 0x58(SP)	
			frame.argp = uintptr(deferArgs(d))
  0x43d6b3		90			NOPL			
	if d.siz == 0 {
  0x43d6b4		488b5c2448		MOVQ 0x48(SP), BX	
  0x43d6b9		833b00			CMPL $0x0, 0(BX)	
  0x43d6bc		757c			JNE 0x43d73a		
  0x43d6be		31d2			XORL DX, DX		
			frame.argp = uintptr(deferArgs(d))
  0x43d6c0		4889942490000000	MOVQ DX, 0x90(SP)	
			frame.arglen, frame.argmap, ok = getArgInfoFast(f, true)
  0x43d6c8		90			NOPL			
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43d6c9		8b710c			MOVL 0xc(CX), SI	
  0x43d6cc		4863fe			MOVSXD SI, DI		
			frame.arglen, frame.argmap, ok = getArgInfoFast(f, true)
  0x43d6cf		4889bc2498000000		MOVQ DI, 0x98(SP)	
  0x43d6d7		48c78424a000000000000000	MOVQ $0x0, 0xa0(SP)	
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43d6e3		81fe00000080		CMPL $-0x80000000, SI	
			if !ok {
  0x43d6e9		0f854bffffff		JNE 0x43d63a		
				frame.arglen, frame.argmap = getArgInfo(&frame, f, true, fn)
  0x43d6ef		488d542450		LEAQ 0x50(SP), DX		
  0x43d6f4		48891424		MOVQ DX, 0(SP)			
  0x43d6f8		48894c2408		MOVQ CX, 0x8(SP)		
  0x43d6fd		4889442410		MOVQ AX, 0x10(SP)		
  0x43d702		c644241801		MOVB $0x1, 0x18(SP)		
  0x43d707		488b442440		MOVQ 0x40(SP), AX		
  0x43d70c		4889442420		MOVQ AX, 0x20(SP)		
  0x43d711		e8da1d0000		CALL runtime.getArgInfo(SB)	
  0x43d716		488b442428		MOVQ 0x28(SP), AX		
  0x43d71b		488b4c2430		MOVQ 0x30(SP), CX		
  0x43d720		4889842498000000	MOVQ AX, 0x98(SP)		
  0x43d728		48898c24a0000000	MOVQ CX, 0xa0(SP)		
	for d := gp._defer; d != nil; d = d.link {
  0x43d730		488b5c2448		MOVQ 0x48(SP), BX	
				frame.arglen, frame.argmap = getArgInfo(&frame, f, true, fn)
  0x43d735		e900ffffff		JMP 0x43d63a		
	return add(unsafe.Pointer(d), unsafe.Sizeof(*d))
  0x43d73a		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x43d73b		488d5330		LEAQ 0x30(BX), DX	
			frame.argp = uintptr(deferArgs(d))
  0x43d73f		e97cffffff		JMP 0x43d6c0		
  0x43d744		488bac24a8000000	MOVQ 0xa8(SP), BP	
  0x43d74c		4881c4b0000000		ADDQ $0xb0, SP		
  0x43d753		c3			RET			
				print("runtime: unknown pc in defer ", hex(frame.pc), "\n")
  0x43d754		488b442460		MOVQ 0x60(SP), AX		
  0x43d759		4889442438		MOVQ AX, 0x38(SP)		
  0x43d75e		e85d67feff		CALL runtime.printlock(SB)	
  0x43d763		488d056a420300		LEAQ 0x3426a(IP), AX		
  0x43d76a		48890424		MOVQ AX, 0(SP)			
  0x43d76e		48c74424081d000000	MOVQ $0x1d, 0x8(SP)		
  0x43d777		e87470feff		CALL runtime.printstring(SB)	
  0x43d77c		488b442438		MOVQ 0x38(SP), AX		
  0x43d781		48890424		MOVQ AX, 0(SP)			
  0x43d785		e8266ffeff		CALL runtime.printhex(SB)	
  0x43d78a		e8c169feff		CALL runtime.printnl(SB)	
  0x43d78f		e8ac67feff		CALL runtime.printunlock(SB)	
				throw("unknown pc")
  0x43d794		488d0571200300		LEAQ 0x32071(IP), AX	
  0x43d79b		48890424		MOVQ AX, 0(SP)		
  0x43d79f		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x43d7a8		e8d35cfeff		CALL runtime.throw(SB)	
  0x43d7ad		0f0b			UD2			
func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer) {
  0x43d7af		e8cca00000		CALL runtime.morestack_noctxt(SB)	
  0x43d7b4		e9d7fdffff		JMP runtime.tracebackdefers(SB)		

TEXT runtime.gentraceback(SB) /usr/local/go/src/runtime/traceback.go
func gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int {
  0x43d7c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43d7c9		488d8424b0fdffff	LEAQ 0xfffffdb0(SP), AX	
  0x43d7d1		483b4110		CMPQ 0x10(CX), AX	
  0x43d7d5		0f86091d0000		JBE 0x43f4e4		
  0x43d7db		4881ecd0020000		SUBQ $0x2d0, SP		
  0x43d7e2		4889ac24c8020000	MOVQ BP, 0x2c8(SP)	
  0x43d7ea		488dac24c8020000	LEAQ 0x2c8(SP), BP	
	if skip > 0 && callback != nil {
  0x43d7f2		488b8424f8020000	MOVQ 0x2f8(SP), AX	
  0x43d7fa		4885c0			TESTQ AX, AX		
  0x43d7fd		0f8e841a0000		JLE 0x43f287		
  0x43d803		488b8c2410030000	MOVQ 0x310(SP), CX	
  0x43d80b		4885c9			TESTQ CX, CX		
  0x43d80e		0f85b51c0000		JNE 0x43f4c9		
	if ourg := getg(); ourg == gp && ourg == ourg.m.curg {
  0x43d814		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x43d81d		488b9c24f0020000	MOVQ 0x2f0(SP), BX	
  0x43d825		4839d3			CMPQ DX, BX		
  0x43d828		7511			JNE 0x43d83b		
  0x43d82a		488b7230		MOVQ 0x30(DX), SI	
  0x43d82e		483996c0000000		CMPQ DX, 0xc0(SI)	
  0x43d835		0f84731c0000		JE 0x43f4ae		
	level, _, _ := gotraceback()
  0x43d83b		90			NOPL			
	t := atomic.Load(&traceback_cache)
  0x43d83c		8b35ca170800		MOVL runtime.traceback_cache(SB), SI	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x43d842		488b5230		MOVQ 0x30(DX), DX	
	if _g_.m.traceback != 0 {
  0x43d846		0fb69229010000		MOVZX 0x129(DX), DX	
		level = int32(t >> tracebackShift)
  0x43d84d		c1ee02			SHRL $0x2, SI		
	if _g_.m.traceback != 0 {
  0x43d850		84d2			TESTL DL, DL		
	level, _, _ := gotraceback()
  0x43d852		0f45f2			CMOVNE DX, SI		
	if pc0 == ^uintptr(0) && sp0 == ^uintptr(0) { // Signal to fetch saved values from gp.
  0x43d855		488b9424d8020000	MOVQ 0x2d8(SP), DX	
  0x43d85d		4883faff		CMPQ $-0x1, DX		
	if _g_.m.traceback != 0 {
  0x43d861		0f85161a0000		JNE 0x43f27d		
	if pc0 == ^uintptr(0) && sp0 == ^uintptr(0) { // Signal to fetch saved values from gp.
  0x43d867		4c8b8424e0020000	MOVQ 0x2e0(SP), R8	
  0x43d86f		4983f8ff		CMPQ $-0x1, R8		
  0x43d873		0f85f4190000		JNE 0x43f26d		
		if gp.syscallsp != 0 {
  0x43d879		488b5370		MOVQ 0x70(BX), DX	
  0x43d87d		4885d2			TESTQ DX, DX		
  0x43d880		0f84da190000		JE 0x43f260		
			pc0 = gp.syscallpc
  0x43d886		4c8b4378		MOVQ 0x78(BX), R8	
	var frame stkframe
  0x43d88a		48c784247002000000000000	MOVQ $0x0, 0x270(SP)	
  0x43d896		488dbc2478020000		LEAQ 0x278(SP), DI	
  0x43d89e		0f57c0				XORPS X0, X0		
  0x43d8a1		488d7fd0			LEAQ -0x30(DI), DI	
  0x43d8a5		48896c24f0			MOVQ BP, -0x10(SP)	
  0x43d8aa		488d6c24f0			LEAQ -0x10(SP), BP	
  0x43d8af		e851c80000			CALL 0x44a105		
  0x43d8b4		488b6d00			MOVQ 0(BP), BP		
	frame.pc = pc0
  0x43d8b8		4c89842480020000	MOVQ R8, 0x280(SP)	
	frame.sp = sp0
  0x43d8c0		4889942498020000	MOVQ DX, 0x298(SP)	
	cgoCtxt := gp.cgoCtxt
  0x43d8c8		4c8b8b48010000		MOVQ 0x148(BX), R9	
  0x43d8cf		4c8b9340010000		MOVQ 0x140(BX), R10	
	printing := pcbuf == nil && callback == nil
  0x43d8d6		4c8b9c2400030000	MOVQ 0x300(SP), R11	
  0x43d8de		4d85db			TESTQ R11, R11		
  0x43d8e1		0f846d190000		JE 0x43f254		
  0x43d8e7		31ff			XORL DI, DI		
	_defer := gp._defer
  0x43d8e9		4c8b6328		MOVQ 0x28(BX), R12	
	for _defer != nil && _defer.sp == _NoArgs {
  0x43d8ed		eb05			JMP 0x43d8f4		
		_defer = _defer.link
  0x43d8ef		4d8b642428		MOVQ 0x28(R12), R12	
	for _defer != nil && _defer.sp == _NoArgs {
  0x43d8f4		4d85e4			TESTQ R12, R12		
  0x43d8f7		7408			JE 0x43d901		
  0x43d8f9		49837c2408ff		CMPQ $-0x1, 0x8(R12)	
  0x43d8ff		74ee			JE 0x43d8ef		
	printing := pcbuf == nil && callback == nil
  0x43d901		40887c243d		MOVB DI, 0x3d(SP)	
	for _defer != nil && _defer.sp == _NoArgs {
  0x43d906		4c89a42448020000	MOVQ R12, 0x248(SP)	
	cgoCtxt := gp.cgoCtxt
  0x43d90e		4c898c24a0000000	MOVQ R9, 0xa0(SP)	
  0x43d916		4c89942440020000	MOVQ R10, 0x240(SP)	
	level, _, _ := gotraceback()
  0x43d91e		89742440		MOVL SI, 0x40(SP)	
	if frame.pc == 0 {
  0x43d922		4d85c0			TESTQ R8, R8		
  0x43d925		751a			JNE 0x43d941		
			frame.pc = uintptr(*(*sys.Uintreg)(unsafe.Pointer(frame.sp)))
  0x43d927		4989d0			MOVQ DX, R8		
  0x43d92a		488b12			MOVQ 0(DX), DX		
  0x43d92d		4889942480020000	MOVQ DX, 0x280(SP)	
			frame.sp += sys.RegSize
  0x43d935		498d5008		LEAQ 0x8(R8), DX	
  0x43d939		4889942498020000	MOVQ DX, 0x298(SP)	
	f := findfunc(frame.pc)
  0x43d941		488b842480020000	MOVQ 0x280(SP), AX		
  0x43d949		48890424		MOVQ AX, 0(SP)			
  0x43d94d		e8aed1ffff		CALL runtime.findfunc(SB)	
  0x43d952		488b442410		MOVQ 0x10(SP), AX		
  0x43d957		488b4c2408		MOVQ 0x8(SP), CX		
	if !f.valid() {
  0x43d95c		90			NOPL			
	return f._func != nil
  0x43d95d		4885c9			TESTQ CX, CX		
	if !f.valid() {
  0x43d960		0f8422180000		JE 0x43f188		
	frame.fn = f
  0x43d966		48898c2470020000	MOVQ CX, 0x270(SP)	
  0x43d96e		4889842478020000	MOVQ AX, 0x278(SP)	
	var cache pcvalueCache
  0x43d976		488dbc24e0000000	LEAQ 0xe0(SP), DI	
  0x43d97e		0f57c0			XORPS X0, X0		
  0x43d981		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43d986		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43d98b		e844c70000		CALL 0x44a0d4		
  0x43d990		488b6d00		MOVQ 0(BP), BP		
	for n < max {
  0x43d994		488b8424f0020000	MOVQ 0x2f0(SP), AX	
  0x43d99c		488b8c2408030000	MOVQ 0x308(SP), CX	
  0x43d9a4		488b9c2448020000	MOVQ 0x248(SP), BX	
  0x43d9ac		488bb424f8020000	MOVQ 0x2f8(SP), SI	
  0x43d9b4		4c8b842440020000	MOVQ 0x240(SP), R8	
  0x43d9bc		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
  0x43d9c4		31d2			XORL DX, DX		
  0x43d9c6		31ff			XORL DI, DI		
  0x43d9c8		4531d2			XORL R10, R10		
  0x43d9cb		4531db			XORL R11, R11		
  0x43d9ce		e92d010000		JMP 0x43db00		
			_defer = _defer.link
  0x43d9d3		488b5b28		MOVQ 0x28(BX), BX	
		for _defer != nil && ((_defer.sp == frame.sp && frame.sp != frame.fp) || _defer.sp == _NoArgs) {
  0x43d9d7		4885db			TESTQ BX, BX		
  0x43d9da		0f8411120000		JE 0x43ebf1		
  0x43d9e0		488b4b08		MOVQ 0x8(BX), CX	
  0x43d9e4		4c8bb42498020000	MOVQ 0x298(SP), R14	
  0x43d9ec		4c39f1			CMPQ R14, CX		
  0x43d9ef		0f85f0110000		JNE 0x43ebe5		
  0x43d9f5		4c39b424a0020000	CMPQ R14, 0x2a0(SP)	
  0x43d9fd		0f84e2110000		JE 0x43ebe5		
  0x43da03		b901000000		MOVL $0x1, CX		
  0x43da08		84c9			TESTL CL, CL		
  0x43da0a		75c7			JNE 0x43d9d3		
		if callback != nil || printing {
  0x43da0c		4885c0			TESTQ AX, AX		
		for _defer != nil && ((_defer.sp == frame.sp && frame.sp != frame.fp) || _defer.sp == _NoArgs) {
  0x43da0f		48899c2448020000	MOVQ BX, 0x248(SP)	
		if callback != nil {
  0x43da17		0f851d110000		JNE 0x43eb3a		
	printing := pcbuf == nil && callback == nil
  0x43da1d		488b8c2400030000	MOVQ 0x300(SP), CX	
  0x43da25		4885c9			TESTQ CX, CX		
		if pcbuf != nil {
  0x43da28		0f85f10d0000		JNE 0x43e81f		
			if skip == 0 && callback == nil {
  0x43da2e		4889b424f8020000	MOVQ SI, 0x2f8(SP)	
	printing := pcbuf == nil && callback == nil
  0x43da36		440fb674243d		MOVZX 0x3d(SP), R14	
  0x43da3c		4584f6			TESTL R14, R14		
		if printing {
  0x43da3f		0f851e050000		JNE 0x43df63		
		n++
  0x43da45		488d7a01		LEAQ 0x1(DX), DI	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43da49		41807c24240e		CMPB $0xe, 0x24(R12)	
  0x43da4f		751b			JNE 0x43da6c		
  0x43da51		4d85c9			TESTQ R9, R9		
  0x43da54		7e16			JLE 0x43da6c		
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43da56		4f8b6cc8f8		MOVQ -0x8(R8)(R9*8), R13	
			if skip == 0 && callback == nil {
  0x43da5b		4885f6			TESTQ SI, SI		
  0x43da5e		7509			JNE 0x43da69		
		if callback != nil || printing {
  0x43da60		4885c0			TESTQ AX, AX		
			if skip == 0 && callback == nil {
  0x43da63		0f846a040000		JE 0x43ded3		
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43da69		49ffc9			DECQ R9			
		if !flr.valid() {
  0x43da6c		90			NOPL			
		waspanic = f.funcID == funcID_sigpanic
  0x43da6d		450fb6642424		MOVZX 0x24(R12), R12	
  0x43da73		4180fc09		CMPL $0x9, R12		
	return f._func != nil
  0x43da77		4d85ff			TESTQ R15, R15		
		if !flr.valid() {
  0x43da7a		0f8440020000		JE 0x43dcc0		
		frame.fn = flr
  0x43da80		4c89bc2470020000	MOVQ R15, 0x270(SP)	
  0x43da88		4c8bac2418020000	MOVQ 0x218(SP), R13	
  0x43da90		4c89ac2478020000	MOVQ R13, 0x278(SP)	
		frame.pc = frame.lr
  0x43da98		4c8bac2490020000	MOVQ 0x290(SP), R13	
  0x43daa0		4c89ac2480020000	MOVQ R13, 0x280(SP)	
		frame.lr = 0
  0x43daa8		48c784249002000000000000	MOVQ $0x0, 0x290(SP)	
		frame.sp = frame.fp
  0x43dab4		4c8bac24a0020000	MOVQ 0x2a0(SP), R13	
  0x43dabc		4c89ac2498020000	MOVQ R13, 0x298(SP)	
		frame.fp = 0
  0x43dac4		48c78424a002000000000000	MOVQ $0x0, 0x2a0(SP)	
		frame.argmap = nil
  0x43dad0		48c78424c002000000000000	MOVQ $0x0, 0x2c0(SP)	
		waspanic = f.funcID == funcID_sigpanic
  0x43dadc		4180fc09		CMPL $0x9, R12		
  0x43dae0		410f94c4		SETE R12		
	for n < max {
  0x43dae4		4c8bac24f0020000	MOVQ 0x2f0(SP), R13	
  0x43daec		4c8bbc2408030000	MOVQ 0x308(SP), R15	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43daf4		4c89e8			MOVQ R13, AX		
	for n < max {
  0x43daf7		4c89f9			MOVQ R15, CX		
  0x43dafa		4889fa			MOVQ DI, DX		
		if waspanic {
  0x43dafd		4489e7			MOVL R12, DI		
	for n < max {
  0x43db00		4839ca			CMPQ CX, DX		
  0x43db03		0f8d69160000		JGE 0x43f172		
		f = frame.fn
  0x43db09		4c8ba42470020000	MOVQ 0x270(SP), R12	
  0x43db11		4c8bac2478020000	MOVQ 0x278(SP), R13	
		if f.pcsp == 0 {
  0x43db19		41837c241400		CMPL $0x0, 0x14(R12)	
  0x43db1f		0f8437160000		JE 0x43f15c		
	for n < max {
  0x43db25		4889542478		MOVQ DX, 0x78(SP)	
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43db2a		48899c2468020000	MOVQ BX, 0x268(SP)	
		n = nprint
  0x43db32		4c895c2460		MOVQ R11, 0x60(SP)	
			if skip == 0 && callback == nil {
  0x43db37		4889b424f8020000	MOVQ SI, 0x2f8(SP)	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43db3f		448854243b		MOVB R10, 0x3b(SP)	
		if waspanic {
  0x43db44		40887c243a		MOVB DI, 0x3a(SP)	
		if frame.fp == 0 {
  0x43db49		4883bc24a002000000	CMPQ $0x0, 0x2a0(SP)	
  0x43db52		0f8449140000		JE 0x43efa1		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43db58		4c8b7030		MOVQ 0x30(AX), R14	
  0x43db5c		4d85f6			TESTQ R14, R14		
  0x43db5f		0f8434140000		JE 0x43ef99		
  0x43db65		493906			CMPQ AX, 0(R14)		
  0x43db68		410f94c6		SETE R14		
  0x43db6c		90			NOPL			
	return f.funcID == funcID_goexit ||
  0x43db6d		450fb67c2424		MOVZX 0x24(R12), R15	
  0x43db73		4180ff02		CMPL $0x2, R15		
  0x43db77		0f85ad130000		JNE 0x43ef2a		
  0x43db7d		41be01000000		MOVL $0x1, R14		
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43db83		4c898c24a0000000	MOVQ R9, 0xa0(SP)	
  0x43db8b		4c89842460020000	MOVQ R8, 0x260(SP)	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43db93		4c89ac2410020000	MOVQ R13, 0x210(SP)	
  0x43db9b		4c89a42430020000	MOVQ R12, 0x230(SP)	
  0x43dba3		4584f6			TESTL R14, R14		
  0x43dba6		0f841c110000		JE 0x43ecc8		
			frame.lr = 0
  0x43dbac		48c784249002000000000000	MOVQ $0x0, 0x290(SP)	
  0x43dbb8		4531f6				XORL R14, R14		
  0x43dbbb		4531ff				XORL R15, R15		
		frame.varp = frame.fp
  0x43dbbe		488b8424a0020000	MOVQ 0x2a0(SP), AX	
  0x43dbc6		48898424a8020000	MOVQ AX, 0x2a8(SP)	
			frame.varp -= sys.RegSize
  0x43dbce		488d48f8		LEAQ -0x8(AX), CX	
  0x43dbd2		48898c24a8020000	MOVQ CX, 0x2a8(SP)	
		if frame.varp > frame.sp && (framepointer_enabled && GOARCH == "amd64" || GOARCH == "arm64") {
  0x43dbda		48398c2498020000	CMPQ CX, 0x298(SP)	
  0x43dbe2		7315			JAE 0x43dbf9		
  0x43dbe4		803d351f080000		CMPB $0x0, 0x81f35(IP)	
  0x43dbeb		740c			JE 0x43dbf9		
			frame.varp -= sys.RegSize
  0x43dbed		4883c0f0		ADDQ $-0x10, AX		
  0x43dbf1		48898424a8020000	MOVQ AX, 0x2a8(SP)	
		if !flr.valid() {
  0x43dbf9		4c89b42418020000	MOVQ R14, 0x218(SP)	
  0x43dc01		4c89bc2438020000	MOVQ R15, 0x238(SP)	
		if callback != nil || printing {
  0x43dc09		488b842410030000	MOVQ 0x310(SP), AX	
  0x43dc11		4885c0			TESTQ AX, AX		
  0x43dc14		0f8499100000		JE 0x43ecb3		
			frame.argp = frame.fp + sys.MinFrameSize
  0x43dc1a		488b8c24a0020000	MOVQ 0x2a0(SP), CX	
  0x43dc22		48898c24b0020000	MOVQ CX, 0x2b0(SP)	
			frame.arglen, frame.argmap, ok = getArgInfoFast(f, callback != nil)
  0x43dc2a		90			NOPL			
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43dc2b		0f847b100000		JE 0x43ecac			
  0x43dc31		41817c240c00000080	CMPL $-0x80000000, 0xc(R12)	
  0x43dc3a		0f94c1			SETE CL				
  0x43dc3d		4d6374240c		MOVSXD 0xc(R12), R14		
			frame.arglen, frame.argmap, ok = getArgInfoFast(f, callback != nil)
  0x43dc42		4c89b424b8020000		MOVQ R14, 0x2b8(SP)	
  0x43dc4a		48c78424c002000000000000	MOVQ $0x0, 0x2c0(SP)	
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43dc56		84c9			TESTL CL, CL		
			if !ok {
  0x43dc58		0f85ac0f0000		JNE 0x43ec0a		
		frame.continpc = frame.pc
  0x43dc5e		488b8c2480020000	MOVQ 0x280(SP), CX	
  0x43dc66		48898c2488020000	MOVQ CX, 0x288(SP)	
		if waspanic {
  0x43dc6e		4084ff			TESTL DI, DI		
  0x43dc71		0f8460fdffff		JE 0x43d9d7		
			if _defer != nil && _defer.sp == frame.sp && frame.sp != frame.fp {
  0x43dc77		4885db			TESTQ BX, BX		
  0x43dc7a		0f84790f0000		JE 0x43ebf9		
  0x43dc80		488b8c2498020000	MOVQ 0x298(SP), CX	
  0x43dc88		48394b08		CMPQ CX, 0x8(BX)	
  0x43dc8c		0f85670f0000		JNE 0x43ebf9		
  0x43dc92		48398c24a0020000	CMPQ CX, 0x2a0(SP)	
  0x43dc9a		0f84590f0000		JE 0x43ebf9		
				frame.continpc = frame.fn.entry + uintptr(frame.fn.deferreturn) + 1
  0x43dca0		488b8c2470020000	MOVQ 0x270(SP), CX	
  0x43dca8		448b7110		MOVL 0x10(CX), R14	
  0x43dcac		4c0331			ADDQ 0(CX), R14		
  0x43dcaf		498d4e01		LEAQ 0x1(R14), CX	
  0x43dcb3		48898c2488020000	MOVQ CX, 0x288(SP)	
  0x43dcbb		e917fdffff		JMP 0x43d9d7		
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43dcc0		410fb6ce		MOVZX R14, CX		
  0x43dcc4		4885c9			TESTQ CX, CX		
  0x43dcc7		490f45fb		CMOVNE R11, DI		
	if callback != nil && n < max && _defer != nil {
  0x43dccb		4885c0			TESTQ AX, AX		
	if printing {
  0x43dcce		0f84f5010000		JE 0x43dec9		
	if callback != nil && n < max && _defer != nil {
  0x43dcd4		488b8c2408030000	MOVQ 0x308(SP), CX	
  0x43dcdc		4839cf			CMPQ CX, DI		
  0x43dcdf		0f8ddf010000		JGE 0x43dec4		
  0x43dce5		4885db			TESTQ BX, BX		
  0x43dce8		0f8494010000		JE 0x43de82		
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43dcee		488b8424f0020000	MOVQ 0x2f0(SP), AX		
  0x43dcf6		488b8898000000		MOVQ 0x98(AX), CX		
  0x43dcfd		48898c24d8000000	MOVQ CX, 0xd8(SP)		
  0x43dd05		488b5308		MOVQ 0x8(BX), DX		
  0x43dd09		48899424d0000000	MOVQ DX, 0xd0(SP)		
  0x43dd11		488b5b10		MOVQ 0x10(BX), BX		
  0x43dd15		48899c24c8000000	MOVQ BX, 0xc8(SP)		
  0x43dd1d		e89e61feff		CALL runtime.printlock(SB)	
  0x43dd22		488d05b11a0300		LEAQ 0x31ab1(IP), AX		
  0x43dd29		48890424		MOVQ AX, 0(SP)			
  0x43dd2d		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43dd36		e8b56afeff		CALL runtime.printstring(SB)	
  0x43dd3b		488b8424d8000000	MOVQ 0xd8(SP), AX		
  0x43dd43		48890424		MOVQ AX, 0(SP)			
  0x43dd47		e8f468feff		CALL runtime.printint(SB)	
  0x43dd4c		488d051a280300		LEAQ 0x3281a(IP), AX		
  0x43dd53		48890424		MOVQ AX, 0(SP)			
  0x43dd57		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x43dd60		e88b6afeff		CALL runtime.printstring(SB)	
  0x43dd65		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43dd6d		48890424		MOVQ AX, 0(SP)			
  0x43dd71		e83a69feff		CALL runtime.printhex(SB)	
  0x43dd76		488d0590130300		LEAQ 0x31390(IP), AX		
  0x43dd7d		48890424		MOVQ AX, 0(SP)			
  0x43dd81		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43dd8a		e8616afeff		CALL runtime.printstring(SB)	
  0x43dd8f		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43dd97		48890424		MOVQ AX, 0(SP)			
  0x43dd9b		e81069feff		CALL runtime.printhex(SB)	
  0x43dda0		e8ab63feff		CALL runtime.printnl(SB)	
  0x43dda5		e89661feff		CALL runtime.printunlock(SB)	
		for _defer = gp._defer; _defer != nil; _defer = _defer.link {
  0x43ddaa		488b8424f0020000	MOVQ 0x2f0(SP), AX	
  0x43ddb2		488b4028		MOVQ 0x28(AX), AX	
  0x43ddb6		e9b9000000		JMP 0x43de74		
  0x43ddbb		4889842448020000	MOVQ AX, 0x248(SP)	
			print("\tdefer ", _defer, " sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43ddc3		488b4808		MOVQ 0x8(AX), CX		
  0x43ddc7		48898c24d0000000	MOVQ CX, 0xd0(SP)		
  0x43ddcf		488b5010		MOVQ 0x10(AX), DX		
  0x43ddd3		48899424c8000000	MOVQ DX, 0xc8(SP)		
  0x43dddb		e8e060feff		CALL runtime.printlock(SB)	
  0x43dde0		488d0518150300		LEAQ 0x31518(IP), AX		
  0x43dde7		48890424		MOVQ AX, 0(SP)			
  0x43ddeb		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x43ddf4		e8f769feff		CALL runtime.printstring(SB)	
  0x43ddf9		488b842448020000	MOVQ 0x248(SP), AX		
  0x43de01		48890424		MOVQ AX, 0(SP)			
  0x43de05		e8a669feff		CALL runtime.printpointer(SB)	
  0x43de0a		488d0504130300		LEAQ 0x31304(IP), AX		
  0x43de11		48890424		MOVQ AX, 0(SP)			
  0x43de15		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43de1e		e8cd69feff		CALL runtime.printstring(SB)	
  0x43de23		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43de2b		48890424		MOVQ AX, 0(SP)			
  0x43de2f		e87c68feff		CALL runtime.printhex(SB)	
  0x43de34		488d05d2120300		LEAQ 0x312d2(IP), AX		
  0x43de3b		48890424		MOVQ AX, 0(SP)			
  0x43de3f		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43de48		e8a369feff		CALL runtime.printstring(SB)	
  0x43de4d		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43de55		48890424		MOVQ AX, 0(SP)			
  0x43de59		e85268feff		CALL runtime.printhex(SB)	
  0x43de5e		e8ed62feff		CALL runtime.printnl(SB)	
  0x43de63		e8d860feff		CALL runtime.printunlock(SB)	
		for _defer = gp._defer; _defer != nil; _defer = _defer.link {
  0x43de68		488b842448020000	MOVQ 0x248(SP), AX	
  0x43de70		488b4028		MOVQ 0x28(AX), AX	
  0x43de74		4885c0			TESTQ AX, AX		
  0x43de77		0f853effffff		JNE 0x43ddbb		
  0x43de7d		e9b1150000		JMP 0x43f433		
	if callback != nil && n < max && _defer != nil {
  0x43de82		4885c0			TESTQ AX, AX		
	if callback != nil && n < max && frame.sp != gp.stktopsp {
  0x43de85		7425			JE 0x43deac		
  0x43de87		4839cf			CMPQ CX, DI		
  0x43de8a		7d20			JGE 0x43deac		
  0x43de8c		488b842498020000	MOVQ 0x298(SP), AX	
  0x43de94		488b9424f0020000	MOVQ 0x2f0(SP), DX	
  0x43de9c		488b9a80000000		MOVQ 0x80(DX), BX	
  0x43dea3		4839d8			CMPQ BX, AX		
  0x43dea6		0f85e8130000		JNE 0x43f294		
	return n
  0x43deac		4889bc2428030000	MOVQ DI, 0x328(SP)	
  0x43deb4		488bac24c8020000	MOVQ 0x2c8(SP), BP	
  0x43debc		4881c4d0020000		ADDQ $0x2d0, SP		
  0x43dec3		c3			RET			
	if callback != nil && n < max && _defer != nil {
  0x43dec4		4885c0			TESTQ AX, AX		
  0x43dec7		ebbc			JMP 0x43de85		
	if callback != nil && n < max && frame.sp != gp.stktopsp {
  0x43dec9		488b8c2408030000	MOVQ 0x308(SP), CX	
	if printing {
  0x43ded1		ebb2			JMP 0x43de85		
		n = nprint
  0x43ded3		4c899c24c0000000	MOVQ R11, 0xc0(SP)	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43dedb		448854243f		MOVB R10, 0x3f(SP)	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43dee0		48890c24		MOVQ CX, 0(SP)				
  0x43dee4		4488742408		MOVB R14, 0x8(SP)			
  0x43dee9		4c896c2410		MOVQ R13, 0x10(SP)			
  0x43deee		48897c2418		MOVQ DI, 0x18(SP)			
  0x43def3		488b842408030000	MOVQ 0x308(SP), AX			
  0x43defb		4889442420		MOVQ AX, 0x20(SP)			
  0x43df00		e8bb170000		CALL runtime.tracebackCgoContext(SB)	
  0x43df05		488b7c2428		MOVQ 0x28(SP), DI			
	if callback != nil && n < max && _defer != nil {
  0x43df0a		488b842410030000	MOVQ 0x310(SP), AX	
	printing := pcbuf == nil && callback == nil
  0x43df12		488b8c2400030000	MOVQ 0x300(SP), CX	
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43df1a		488b9c2448020000	MOVQ 0x248(SP), BX	
			if skip == 0 && callback == nil {
  0x43df22		488bb424f8020000	MOVQ 0x2f8(SP), SI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43df2a		4c8b842460020000	MOVQ 0x260(SP), R8	
  0x43df32		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43df3a		440fb654243f		MOVZX 0x3f(SP), R10	
		n = nprint
  0x43df40		4c8b9c24c0000000	MOVQ 0xc0(SP), R11	
		waspanic = f.funcID == funcID_sigpanic
  0x43df48		4c8ba42430020000	MOVQ 0x230(SP), R12	
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43df50		440fb674243d		MOVZX 0x3d(SP), R14	
	return f._func != nil
  0x43df56		4c8bbc2438020000	MOVQ 0x238(SP), R15	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43df5e		e906fbffff		JMP 0x43da69		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43df63		448854243e		MOVB R10, 0x3e(SP)	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43df68		48899424b8000000	MOVQ DX, 0xb8(SP)	
			tracepc := frame.pc
  0x43df70		4c8bb42480020000	MOVQ 0x280(SP), R14	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43df78		4885d2			TESTQ DX, DX		
  0x43df7b		0f8e76080000		JLE 0x43e7f7		
  0x43df81		4d393424		CMPQ R14, 0(R12)	
  0x43df85		7309			JAE 0x43df90		
		if waspanic {
  0x43df87		4084ff			TESTL DI, DI		
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43df8a		0f845f080000		JE 0x43e7ef		
				file, line := funcline(f, tracepc)
  0x43df90		4c89742450		MOVQ R14, 0x50(SP)	
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43df95		4c892424		MOVQ R12, 0(SP)			
  0x43df99		4c896c2408		MOVQ R13, 0x8(SP)		
  0x43df9e		c644241002		MOVB $0x2, 0x10(SP)		
  0x43dfa3		e868d8ffff		CALL runtime.funcdata(SB)	
  0x43dfa8		488b442418		MOVQ 0x18(SP), AX		
  0x43dfad		4885c0			TESTQ AX, AX			
  0x43dfb0		0f8553050000		JNE 0x43e509			
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43dfb6		0fb644243e		MOVZX 0x3e(SP), AX	
				file, line := funcline(f, tracepc)
  0x43dfbb		488b4c2450		MOVQ 0x50(SP), CX	
		n = nprint
  0x43dfc0		488b542460		MOVQ 0x60(SP), DX	
  0x43dfc5		48899424b0000000	MOVQ DX, 0xb0(SP)	
				file, line := funcline(f, tracepc)
  0x43dfcd		48894c2450		MOVQ CX, 0x50(SP)	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43dfd2		488b9c2420030000	MOVQ 0x320(SP), BX	
  0x43dfda		0fbae300		BTL $0x0, BX		
  0x43dfde		0f83c7040000		JAE 0x43e4ab		
  0x43dfe4		b801000000		MOVL $0x1, AX		
  0x43dfe9		84c0			TESTL AL, AL		
  0x43dfeb		755c			JNE 0x43e049		
			lastFuncID = f.funcID
  0x43dfed		4c8ba42430020000	MOVQ 0x230(SP), R12	
  0x43dff5		450fb6542424		MOVZX 0x24(R12), R10	
		if callback != nil || printing {
  0x43dffb		488b842410030000	MOVQ 0x310(SP), AX	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e003		488b8c2400030000	MOVQ 0x300(SP), CX	
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43e00b		488b9c2448020000	MOVQ 0x248(SP), BX	
			if skip == 0 && callback == nil {
  0x43e013		488bb424f8020000	MOVQ 0x2f8(SP), SI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43e01b		4c8b842460020000	MOVQ 0x260(SP), R8	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43e023		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e02b		440fb674243d		MOVZX 0x3d(SP), R14	
	return f._func != nil
  0x43e031		4c8bbc2438020000	MOVQ 0x238(SP), R15	
		n = nprint
  0x43e039		4989d3			MOVQ DX, R11		
		n++
  0x43e03c		488b9424b8000000	MOVQ 0xb8(SP), DX	
			lastFuncID = f.funcID
  0x43e044		e9fcf9ffff		JMP 0x43da45		
				name := funcname(f)
  0x43e049		488b842430020000	MOVQ 0x230(SP), AX		
  0x43e051		48890424		MOVQ AX, 0(SP)			
  0x43e055		488b8c2410020000	MOVQ 0x210(SP), CX		
  0x43e05d		48894c2408		MOVQ CX, 0x8(SP)		
  0x43e062		e8d9d1ffff		CALL runtime.funcname(SB)	
  0x43e067		488b442418		MOVQ 0x18(SP), AX		
  0x43e06c		4889442470		MOVQ AX, 0x70(SP)		
  0x43e071		488b4c2410		MOVQ 0x10(SP), CX		
  0x43e076		48898c24e8010000	MOVQ CX, 0x1e8(SP)		
				file, line := funcline(f, tracepc)
  0x43e07e		488b942430020000	MOVQ 0x230(SP), DX		
  0x43e086		48891424		MOVQ DX, 0(SP)			
  0x43e08a		488b9c2410020000	MOVQ 0x210(SP), BX		
  0x43e092		48895c2408		MOVQ BX, 0x8(SP)		
  0x43e097		488b5c2450		MOVQ 0x50(SP), BX		
  0x43e09c		48895c2410		MOVQ BX, 0x10(SP)		
  0x43e0a1		e8cad4ffff		CALL runtime.funcline(SB)	
  0x43e0a6		4863442428		MOVSXD 0x28(SP), AX		
  0x43e0ab		48898424d8000000	MOVQ AX, 0xd8(SP)		
  0x43e0b3		488b4c2418		MOVQ 0x18(SP), CX		
  0x43e0b8		48898c2408020000	MOVQ CX, 0x208(SP)		
  0x43e0c0		488b542420		MOVQ 0x20(SP), DX		
  0x43e0c5		4889942490000000	MOVQ DX, 0x90(SP)		
				if name == "runtime.gopanic" {
  0x43e0cd		488b5c2470		MOVQ 0x70(SP), BX		
  0x43e0d2		4883fb0f		CMPQ $0xf, BX			
  0x43e0d6		0f85bd030000		JNE 0x43e499			
  0x43e0dc		48be72756e74696d652e	MOVQ $0x2e656d69746e7572, SI	
  0x43e0e6		488bbc24e8010000	MOVQ 0x1e8(SP), DI		
  0x43e0ee		483937			CMPQ SI, 0(DI)			
  0x43e0f1		0f8595030000		JNE 0x43e48c			
  0x43e0f7		817f08676f7061		CMPL $0x61706f67, 0x8(DI)	
  0x43e0fe		0f857b030000		JNE 0x43e47f			
  0x43e104		66817f0c6e69		CMPW $0x696e, 0xc(DI)		
  0x43e10a		0f8562030000		JNE 0x43e472			
  0x43e110		807f0e63		CMPB $0x63, 0xe(DI)		
  0x43e114		0f854b030000		JNE 0x43e465			
  0x43e11a		488d1de0100300		LEAQ 0x310e0(IP), BX		
  0x43e121		bf05000000		MOVL $0x5, DI			
				print(name, "(")
  0x43e126		48899c24e8010000	MOVQ BX, 0x1e8(SP)		
  0x43e12e		48897c2470		MOVQ DI, 0x70(SP)		
  0x43e133		e8885dfeff		CALL runtime.printlock(SB)	
  0x43e138		488b8424e8010000	MOVQ 0x1e8(SP), AX		
  0x43e140		48890424		MOVQ AX, 0(SP)			
  0x43e144		488b442470		MOVQ 0x70(SP), AX		
  0x43e149		4889442408		MOVQ AX, 0x8(SP)		
  0x43e14e		e89d66feff		CALL runtime.printstring(SB)	
  0x43e153		488d05270f0300		LEAQ 0x30f27(IP), AX		
  0x43e15a		48890424		MOVQ AX, 0(SP)			
  0x43e15e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e167		e88466feff		CALL runtime.printstring(SB)	
  0x43e16c		e8cf5dfeff		CALL runtime.printunlock(SB)	
				argp := (*[100]uintptr)(unsafe.Pointer(frame.argp))
  0x43e171		488b8424b0020000	MOVQ 0x2b0(SP), AX	
  0x43e179		4889842458020000	MOVQ AX, 0x258(SP)	
  0x43e181		31c9			XORL CX, CX		
				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
  0x43e183		eb3d			JMP 0x43e1c2		
					print(hex(argp[i]))
  0x43e185		8400			TESTB AL, 0(AX)			
  0x43e187		488b14c8		MOVQ 0(AX)(CX*8), DX		
  0x43e18b		48899424d0000000	MOVQ DX, 0xd0(SP)		
  0x43e193		e8285dfeff		CALL runtime.printlock(SB)	
  0x43e198		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43e1a0		48890424		MOVQ AX, 0(SP)			
  0x43e1a4		e80765feff		CALL runtime.printhex(SB)	
  0x43e1a9		e8925dfeff		CALL runtime.printunlock(SB)	
				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
  0x43e1ae		488b842488000000	MOVQ 0x88(SP), AX	
  0x43e1b6		488d4801		LEAQ 0x1(AX), CX	
  0x43e1ba		488b842458020000	MOVQ 0x258(SP), AX	
  0x43e1c2		488b9424b8020000	MOVQ 0x2b8(SP), DX	
  0x43e1ca		48c1ea03		SHRQ $0x3, DX		
  0x43e1ce		4839d1			CMPQ DX, CX		
  0x43e1d1		736e			JAE 0x43e241		
					if i >= 10 {
  0x43e1d3		4883f90a		CMPQ $0xa, CX		
  0x43e1d7		7345			JAE 0x43e21e		
				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
  0x43e1d9		48898c2488000000	MOVQ CX, 0x88(SP)	
					if i != 0 {
  0x43e1e1		4885c9			TESTQ CX, CX		
  0x43e1e4		749f			JE 0x43e185		
						print(", ")
  0x43e1e6		e8d55cfeff		CALL runtime.printlock(SB)	
  0x43e1eb		488d05aa0e0300		LEAQ 0x30eaa(IP), AX		
  0x43e1f2		48890424		MOVQ AX, 0(SP)			
  0x43e1f6		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43e1ff		e8ec65feff		CALL runtime.printstring(SB)	
  0x43e204		e8375dfeff		CALL runtime.printunlock(SB)	
					print(hex(argp[i]))
  0x43e209		488b842458020000	MOVQ 0x258(SP), AX	
  0x43e211		488b8c2488000000	MOVQ 0x88(SP), CX	
						print(", ")
  0x43e219		e967ffffff		JMP 0x43e185		
						print(", ...")
  0x43e21e		e89d5cfeff		CALL runtime.printlock(SB)	
  0x43e223		488d05b90f0300		LEAQ 0x30fb9(IP), AX		
  0x43e22a		48890424		MOVQ AX, 0(SP)			
  0x43e22e		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43e237		e8b465feff		CALL runtime.printstring(SB)	
  0x43e23c		e8ff5cfeff		CALL runtime.printunlock(SB)	
				print(")\n")
  0x43e241		e87a5cfeff		CALL runtime.printlock(SB)	
  0x43e246		488d054d0e0300		LEAQ 0x30e4d(IP), AX		
  0x43e24d		48890424		MOVQ AX, 0(SP)			
  0x43e251		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43e25a		e89165feff		CALL runtime.printstring(SB)	
  0x43e25f		e8dc5cfeff		CALL runtime.printunlock(SB)	
				print("\t", file, ":", line)
  0x43e264		e8575cfeff		CALL runtime.printlock(SB)	
  0x43e269		488d051e0e0300		LEAQ 0x30e1e(IP), AX		
  0x43e270		48890424		MOVQ AX, 0(SP)			
  0x43e274		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e27d		e86e65feff		CALL runtime.printstring(SB)	
  0x43e282		488b842408020000	MOVQ 0x208(SP), AX		
  0x43e28a		48890424		MOVQ AX, 0(SP)			
  0x43e28e		488b842490000000	MOVQ 0x90(SP), AX		
  0x43e296		4889442408		MOVQ AX, 0x8(SP)		
  0x43e29b		e85065feff		CALL runtime.printstring(SB)	
  0x43e2a0		488d05e10d0300		LEAQ 0x30de1(IP), AX		
  0x43e2a7		48890424		MOVQ AX, 0(SP)			
  0x43e2ab		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e2b4		e83765feff		CALL runtime.printstring(SB)	
  0x43e2b9		488b8424d8000000	MOVQ 0xd8(SP), AX		
  0x43e2c1		48890424		MOVQ AX, 0(SP)			
  0x43e2c5		e87663feff		CALL runtime.printint(SB)	
  0x43e2ca		e8715cfeff		CALL runtime.printunlock(SB)	
				if frame.pc > f.entry {
  0x43e2cf		488b842480020000	MOVQ 0x280(SP), AX	
  0x43e2d7		488b8c2430020000	MOVQ 0x230(SP), CX	
  0x43e2df		488b11			MOVQ 0(CX), DX		
  0x43e2e2		4839d0			CMPQ DX, AX		
  0x43e2e5		0f871e010000		JA 0x43e409		
				if gp.m != nil && gp.m.throwing > 0 && gp == gp.m.curg || level >= 2 {
  0x43e2eb		488b8424f0020000	MOVQ 0x2f0(SP), AX	
  0x43e2f3		488b5030		MOVQ 0x30(AX), DX	
  0x43e2f7		4885d2			TESTQ DX, DX		
  0x43e2fa		0f84fa000000		JE 0x43e3fa		
  0x43e300		83baf400000000		CMPL $0x0, 0xf4(DX)	
  0x43e307		0f8eed000000		JLE 0x43e3fa		
  0x43e30d		483982c0000000		CMPQ AX, 0xc0(DX)	
  0x43e314		0f85e0000000		JNE 0x43e3fa		
					print(" fp=", hex(frame.fp), " sp=", hex(frame.sp), " pc=", hex(frame.pc))
  0x43e31a		488b8424a0020000	MOVQ 0x2a0(SP), AX		
  0x43e322		48898424d0000000	MOVQ AX, 0xd0(SP)		
  0x43e32a		488b8c2498020000	MOVQ 0x298(SP), CX		
  0x43e332		48898c24c8000000	MOVQ CX, 0xc8(SP)		
  0x43e33a		488b942480020000	MOVQ 0x280(SP), DX		
  0x43e342		48899424a8000000	MOVQ DX, 0xa8(SP)		
  0x43e34a		e8715bfeff		CALL runtime.printlock(SB)	
  0x43e34f		488d05a70d0300		LEAQ 0x30da7(IP), AX		
  0x43e356		48890424		MOVQ AX, 0(SP)			
  0x43e35a		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43e363		e88864feff		CALL runtime.printstring(SB)	
  0x43e368		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43e370		48890424		MOVQ AX, 0(SP)			
  0x43e374		e83763feff		CALL runtime.printhex(SB)	
  0x43e379		488d05950d0300		LEAQ 0x30d95(IP), AX		
  0x43e380		48890424		MOVQ AX, 0(SP)			
  0x43e384		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43e38d		e85e64feff		CALL runtime.printstring(SB)	
  0x43e392		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43e39a		48890424		MOVQ AX, 0(SP)			
  0x43e39e		e80d63feff		CALL runtime.printhex(SB)	
  0x43e3a3		488d05630d0300		LEAQ 0x30d63(IP), AX		
  0x43e3aa		48890424		MOVQ AX, 0(SP)			
  0x43e3ae		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43e3b7		e83464feff		CALL runtime.printstring(SB)	
  0x43e3bc		488b8424a8000000	MOVQ 0xa8(SP), AX		
  0x43e3c4		48890424		MOVQ AX, 0(SP)			
  0x43e3c8		e8e362feff		CALL runtime.printhex(SB)	
  0x43e3cd		e86e5bfeff		CALL runtime.printunlock(SB)	
				print("\n")
  0x43e3d2		e8e95afeff		CALL runtime.printlock(SB)	
  0x43e3d7		e8745dfeff		CALL runtime.printnl(SB)	
  0x43e3dc		e85f5bfeff		CALL runtime.printunlock(SB)	
				nprint++
  0x43e3e1		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x43e3e9		488d5001		LEAQ 0x1(AX), DX	
			if flags&_TraceJumpStack != 0 && gp == gp.m.g0 && gp.m.curg != nil {
  0x43e3ed		488b9c2420030000	MOVQ 0x320(SP), BX	
				nprint++
  0x43e3f5		e9f3fbffff		JMP 0x43dfed		
				if gp.m != nil && gp.m.throwing > 0 && gp == gp.m.curg || level >= 2 {
  0x43e3fa		8b542440		MOVL 0x40(SP), DX	
  0x43e3fe		83fa02			CMPL $0x2, DX		
  0x43e401		0f8d13ffffff		JGE 0x43e31a		
  0x43e407		ebc9			JMP 0x43e3d2		
				if frame.pc > f.entry {
  0x43e409		48898424d0000000	MOVQ AX, 0xd0(SP)	
  0x43e411		48899424c8000000	MOVQ DX, 0xc8(SP)	
					print(" +", hex(frame.pc-f.entry))
  0x43e419		e8a25afeff		CALL runtime.printlock(SB)	
  0x43e41e		488d056b0c0300		LEAQ 0x30c6b(IP), AX		
  0x43e425		48890424		MOVQ AX, 0(SP)			
  0x43e429		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43e432		e8b963feff		CALL runtime.printstring(SB)	
  0x43e437		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43e43f		488b8c24c8000000	MOVQ 0xc8(SP), CX		
  0x43e447		4829c8			SUBQ CX, AX			
  0x43e44a		48890424		MOVQ AX, 0(SP)			
  0x43e44e		e85d62feff		CALL runtime.printhex(SB)	
  0x43e453		e8e85afeff		CALL runtime.printunlock(SB)	
			lastFuncID = f.funcID
  0x43e458		488b8c2430020000	MOVQ 0x230(SP), CX	
					print(" +", hex(frame.pc-f.entry))
  0x43e460		e986feffff		JMP 0x43e2eb		
				print(name, "(")
  0x43e465		4889fb			MOVQ DI, BX		
  0x43e468		488b7c2470		MOVQ 0x70(SP), DI	
				if name == "runtime.gopanic" {
  0x43e46d		e9b4fcffff		JMP 0x43e126		
				print(name, "(")
  0x43e472		4889fb			MOVQ DI, BX		
  0x43e475		488b7c2470		MOVQ 0x70(SP), DI	
				if name == "runtime.gopanic" {
  0x43e47a		e9a7fcffff		JMP 0x43e126		
				print(name, "(")
  0x43e47f		4889fb			MOVQ DI, BX		
  0x43e482		488b7c2470		MOVQ 0x70(SP), DI	
				if name == "runtime.gopanic" {
  0x43e487		e99afcffff		JMP 0x43e126		
				print(name, "(")
  0x43e48c		4889fb			MOVQ DI, BX		
  0x43e48f		488b7c2470		MOVQ 0x70(SP), DI	
				if name == "runtime.gopanic" {
  0x43e494		e98dfcffff		JMP 0x43e126		
				print(name, "(")
  0x43e499		488b9c24e8010000	MOVQ 0x1e8(SP), BX	
  0x43e4a1		488b7c2470		MOVQ 0x70(SP), DI	
				if name == "runtime.gopanic" {
  0x43e4a6		e97bfcffff		JMP 0x43e126		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e4ab		488b8c2430020000	MOVQ 0x230(SP), CX		
  0x43e4b3		0fb65924		MOVZX 0x24(CX), BX		
  0x43e4b7		48890c24		MOVQ CX, 0(SP)			
  0x43e4bb		488bb42410020000	MOVQ 0x210(SP), SI		
  0x43e4c3		4889742408		MOVQ SI, 0x8(SP)		
  0x43e4c8		488bbc24f0020000	MOVQ 0x2f0(SP), DI		
  0x43e4d0		48897c2410		MOVQ DI, 0x10(SP)		
  0x43e4d5		4885d2			TESTQ DX, DX			
  0x43e4d8		0f94442418		SETE 0x18(SP)			
  0x43e4dd		885c2419		MOVB BL, 0x19(SP)		
  0x43e4e1		8844241a		MOVB AL, 0x1a(SP)		
  0x43e4e5		e8d6210000		CALL runtime.showframe(SB)	
  0x43e4ea		0fb6442420		MOVZX 0x20(SP), AX		
				file, line := funcline(f, tracepc)
  0x43e4ef		488b4c2450		MOVQ 0x50(SP), CX	
		n = nprint
  0x43e4f4		488b9424b0000000	MOVQ 0xb0(SP), DX	
			if flags&_TraceJumpStack != 0 && gp == gp.m.g0 && gp.m.curg != nil {
  0x43e4fc		488b9c2420030000	MOVQ 0x320(SP), BX	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e504		e9e0faffff		JMP 0x43dfe9		
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43e509		4889842458020000	MOVQ AX, 0x258(SP)	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil)
  0x43e511		488b4c2450		MOVQ 0x50(SP), CX	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e516		0fb654243e		MOVZX 0x3e(SP), DX	
		n = nprint
  0x43e51b		488b5c2460		MOVQ 0x60(SP), BX	
				for {
  0x43e520		eb34			JMP 0x43e556		
					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc)
  0x43e522		488bb42470020000	MOVQ 0x270(SP), SI	
					lastFuncID = inltree[ix].funcID
  0x43e52a		488d0480		LEAQ 0(AX)(AX*4), AX	
  0x43e52e		4889c7			MOVQ AX, DI		
  0x43e531		48c1e002		SHLQ $0x2, AX		
  0x43e535		4c8b842458020000	MOVQ 0x258(SP), R8	
  0x43e53d		420fb6440002		MOVZX 0x2(AX)(R8*1), AX	
					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc)
  0x43e543		418b7cb810		MOVL 0x10(R8)(DI*4), DI	
  0x43e548		4863ff			MOVSXD DI, DI		
  0x43e54b		48033e			ADDQ 0(SI), DI		
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil)
  0x43e54e		4889f9			MOVQ DI, CX		
		n = nprint
  0x43e551		4889d3			MOVQ DX, BX		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e554		89c2			MOVL AX, DX		
		n = nprint
  0x43e556		48899c24b0000000	MOVQ BX, 0xb0(SP)	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e55e		8854243b		MOVB DL, 0x3b(SP)	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil)
  0x43e562		48894c2450		MOVQ CX, 0x50(SP)		
  0x43e567		488b842430020000	MOVQ 0x230(SP), AX		
  0x43e56f		48890424		MOVQ AX, 0(SP)			
  0x43e573		488bb42410020000	MOVQ 0x210(SP), SI		
  0x43e57b		4889742408		MOVQ SI, 0x8(SP)		
  0x43e580		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x43e588		48894c2418		MOVQ CX, 0x18(SP)		
  0x43e58d		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43e596		e8c5d1ffff		CALL runtime.pcdatavalue(SB)	
  0x43e59b		8b442428		MOVL 0x28(SP), AX		
					if ix < 0 {
  0x43e59f		85c0			TESTL AX, AX		
  0x43e5a1		0f8c31020000		JL 0x43e7d8		
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, nil)
  0x43e5a7		89442444		MOVL AX, 0x44(SP)	
					if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) {
  0x43e5ab		488b8c2420030000	MOVQ 0x320(SP), CX	
  0x43e5b3		0fbae100		BTL $0x0, CX		
  0x43e5b7		0f8398010000		JAE 0x43e755		
  0x43e5bd		ba01000000		MOVL $0x1, DX		
  0x43e5c2		84d2			TESTL DL, DL		
  0x43e5c4		751c			JNE 0x43e5e2		
		n = nprint
  0x43e5c6		488b9424b0000000	MOVQ 0xb0(SP), DX	
					lastFuncID = inltree[ix].funcID
  0x43e5ce		4863c0			MOVSXD AX, AX		
  0x43e5d1		483d00001000		CMPQ $0x100000, AX	
  0x43e5d7		0f8245ffffff		JB 0x43e522		
  0x43e5dd		e96c0e0000		JMP 0x43f44e		
						name := funcnameFromNameoff(f, inltree[ix].func_)
  0x43e5e2		4863d0			MOVSXD AX, DX				
  0x43e5e5		4881fa00001000		CMPQ $0x100000, DX			
  0x43e5ec		0f83630e0000		JAE 0x43f455				
  0x43e5f2		488d0492		LEAQ 0(DX)(DX*4), AX			
  0x43e5f6		488b8c2458020000	MOVQ 0x258(SP), CX			
  0x43e5fe		8b44810c		MOVL 0xc(CX)(AX*4), AX			
  0x43e602		488b942430020000	MOVQ 0x230(SP), DX			
  0x43e60a		48891424		MOVQ DX, 0(SP)				
  0x43e60e		488b9c2410020000	MOVQ 0x210(SP), BX			
  0x43e616		48895c2408		MOVQ BX, 0x8(SP)			
  0x43e61b		89442410		MOVL AX, 0x10(SP)			
  0x43e61f		e8ccccffff		CALL runtime.funcnameFromNameoff(SB)	
  0x43e624		488b442420		MOVQ 0x20(SP), AX			
  0x43e629		4889442468		MOVQ AX, 0x68(SP)			
  0x43e62e		488b4c2418		MOVQ 0x18(SP), CX			
  0x43e633		48898c24e0010000	MOVQ CX, 0x1e0(SP)			
						file, line := funcline(f, tracepc)
  0x43e63b		488b942430020000	MOVQ 0x230(SP), DX		
  0x43e643		48891424		MOVQ DX, 0(SP)			
  0x43e647		488b9c2410020000	MOVQ 0x210(SP), BX		
  0x43e64f		48895c2408		MOVQ BX, 0x8(SP)		
  0x43e654		488b742450		MOVQ 0x50(SP), SI		
  0x43e659		4889742410		MOVQ SI, 0x10(SP)		
  0x43e65e		e80dcfffff		CALL runtime.funcline(SB)	
  0x43e663		4863442428		MOVSXD 0x28(SP), AX		
  0x43e668		48898424d8000000	MOVQ AX, 0xd8(SP)		
  0x43e670		488b4c2420		MOVQ 0x20(SP), CX		
  0x43e675		48898c2498000000	MOVQ CX, 0x98(SP)		
  0x43e67d		488b542418		MOVQ 0x18(SP), DX		
  0x43e682		4889942400020000	MOVQ DX, 0x200(SP)		
						print(name, "(...)\n")
  0x43e68a		e83158feff		CALL runtime.printlock(SB)	
  0x43e68f		488b8424e0010000	MOVQ 0x1e0(SP), AX		
  0x43e697		48890424		MOVQ AX, 0(SP)			
  0x43e69b		488b442468		MOVQ 0x68(SP), AX		
  0x43e6a0		4889442408		MOVQ AX, 0x8(SP)		
  0x43e6a5		e84661feff		CALL runtime.printstring(SB)	
  0x43e6aa		488d05c30b0300		LEAQ 0x30bc3(IP), AX		
  0x43e6b1		48890424		MOVQ AX, 0(SP)			
  0x43e6b5		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x43e6be		e82d61feff		CALL runtime.printstring(SB)	
  0x43e6c3		e87858feff		CALL runtime.printunlock(SB)	
						print("\t", file, ":", line, "\n")
  0x43e6c8		e8f357feff		CALL runtime.printlock(SB)	
  0x43e6cd		488d05ba090300		LEAQ 0x309ba(IP), AX		
  0x43e6d4		48890424		MOVQ AX, 0(SP)			
  0x43e6d8		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e6e1		e80a61feff		CALL runtime.printstring(SB)	
  0x43e6e6		488b842400020000	MOVQ 0x200(SP), AX		
  0x43e6ee		48890424		MOVQ AX, 0(SP)			
  0x43e6f2		488b842498000000	MOVQ 0x98(SP), AX		
  0x43e6fa		4889442408		MOVQ AX, 0x8(SP)		
  0x43e6ff		e8ec60feff		CALL runtime.printstring(SB)	
  0x43e704		488d057d090300		LEAQ 0x3097d(IP), AX		
  0x43e70b		48890424		MOVQ AX, 0(SP)			
  0x43e70f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43e718		e8d360feff		CALL runtime.printstring(SB)	
  0x43e71d		488b8424d8000000	MOVQ 0xd8(SP), AX		
  0x43e725		48890424		MOVQ AX, 0(SP)			
  0x43e729		e8125ffeff		CALL runtime.printint(SB)	
  0x43e72e		e81d5afeff		CALL runtime.printnl(SB)	
  0x43e733		e80858feff		CALL runtime.printunlock(SB)	
						nprint++
  0x43e738		488b8424b0000000	MOVQ 0xb0(SP), AX	
  0x43e740		488d5001		LEAQ 0x1(AX), DX	
					lastFuncID = inltree[ix].funcID
  0x43e744		8b442444		MOVL 0x44(SP), AX	
					if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) {
  0x43e748		488b8c2420030000	MOVQ 0x320(SP), CX	
						nprint++
  0x43e750		e979feffff		JMP 0x43e5ce		
					if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) {
  0x43e755		4863d0			MOVSXD AX, DX			
  0x43e758		4881fa00001000		CMPQ $0x100000, DX		
  0x43e75f		0f83f70c0000		JAE 0x43f45c			
  0x43e765		488d0492		LEAQ 0(DX)(DX*4), AX		
  0x43e769		48c1e002		SHLQ $0x2, AX			
  0x43e76d		488b8c2458020000	MOVQ 0x258(SP), CX		
  0x43e775		0fb6440802		MOVZX 0x2(AX)(CX*1), AX		
  0x43e77a		488b942430020000	MOVQ 0x230(SP), DX		
  0x43e782		48891424		MOVQ DX, 0(SP)			
  0x43e786		488b9c2410020000	MOVQ 0x210(SP), BX		
  0x43e78e		48895c2408		MOVQ BX, 0x8(SP)		
  0x43e793		488bb424f0020000	MOVQ 0x2f0(SP), SI		
  0x43e79b		4889742410		MOVQ SI, 0x10(SP)		
  0x43e7a0		488bbc24b0000000	MOVQ 0xb0(SP), DI		
  0x43e7a8		4885ff			TESTQ DI, DI			
  0x43e7ab		0f94442418		SETE 0x18(SP)			
  0x43e7b0		88442419		MOVB AL, 0x19(SP)		
  0x43e7b4		0fb644243b		MOVZX 0x3b(SP), AX		
  0x43e7b9		8844241a		MOVB AL, 0x1a(SP)		
  0x43e7bd		e8fe1e0000		CALL runtime.showframe(SB)	
  0x43e7c2		0fb6542420		MOVZX 0x20(SP), DX		
					lastFuncID = inltree[ix].funcID
  0x43e7c7		8b442444		MOVL 0x44(SP), AX	
					if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) {
  0x43e7cb		488b8c2420030000	MOVQ 0x320(SP), CX	
  0x43e7d3		e9eafdffff		JMP 0x43e5c2		
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e7d8		0fb644243b		MOVZX 0x3b(SP), AX	
				file, line := funcline(f, tracepc)
  0x43e7dd		488b4c2450		MOVQ 0x50(SP), CX	
		n = nprint
  0x43e7e2		488b9424b0000000	MOVQ 0xb0(SP), DX	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43e7ea		e9d6f7ffff		JMP 0x43dfc5		
				tracepc--
  0x43e7ef		49ffce			DECQ R14		
  0x43e7f2		e999f7ffff		JMP 0x43df90		
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43e7f7		488b8c2420030000	MOVQ 0x320(SP), CX	
  0x43e7ff		0fbae101		BTL $0x1, CX		
  0x43e803		720d			JB 0x43e812		
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e805		488b8c2400030000	MOVQ 0x300(SP), CX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43e80d		e96ff7ffff		JMP 0x43df81		
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e812		488b8c2400030000	MOVQ 0x300(SP), CX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43e81a		e971f7ffff		JMP 0x43df90		
			pc := frame.pc
  0x43e81f		4c8bb42480020000	MOVQ 0x280(SP), R14	
  0x43e827		4c89742448		MOVQ R14, 0x48(SP)	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43e82c		4885d2			TESTQ DX, DX		
  0x43e82f		0f8edd020000		JLE 0x43eb12		
  0x43e835		4d393424		CMPQ R14, 0(R12)	
  0x43e839		7309			JAE 0x43e844		
		if waspanic {
  0x43e83b		4084ff			TESTL DI, DI		
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43e83e		0f84c2020000		JE 0x43eb06		
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &cache)
  0x43e844		4c89b424d0000000	MOVQ R14, 0xd0(SP)	
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43e84c		4c892424		MOVQ R12, 0(SP)			
  0x43e850		4c896c2408		MOVQ R13, 0x8(SP)		
  0x43e855		c644241002		MOVB $0x2, 0x10(SP)		
  0x43e85a		e8b1cfffff		CALL runtime.funcdata(SB)	
  0x43e85f		488b442418		MOVQ 0x18(SP), AX		
  0x43e864		4885c0			TESTQ AX, AX			
  0x43e867		0f85f5000000		JNE 0x43e962			
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e86d		0fb644243b		MOVZX 0x3b(SP), AX	
			} else if n < max {
  0x43e872		488b4c2478		MOVQ 0x78(SP), CX	
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43e877		488b542448		MOVQ 0x48(SP), DX	
			if skip == 0 && callback == nil {
  0x43e87c		488b9c24f8020000	MOVQ 0x2f8(SP), BX	
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e884		488bb42430020000	MOVQ 0x230(SP), SI	
  0x43e88c		807e2414		CMPB $0x14, 0x24(SI)	
  0x43e890		7516			JNE 0x43e8a8		
  0x43e892		90			NOPL			
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x43e893		3c12			CMPL $0x12, AL		
  0x43e895		0f85af000000		JNE 0x43e94a		
  0x43e89b		b801000000		MOVL $0x1, AX		
  0x43e8a0		84c0			TESTL AL, AL		
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e8a2		0f849a000000		JE 0x43e942		
			} else if skip > 0 {
  0x43e8a8		4885db			TESTQ BX, BX		
  0x43e8ab		7e5a			JLE 0x43e907		
				skip--
  0x43e8ad		488d43ff		LEAQ -0x1(BX), AX	
			lastFuncID = f.funcID
  0x43e8b1		440fb65624		MOVZX 0x24(SI), R10	
			n-- // offset n++ below
  0x43e8b6		488d51ff		LEAQ -0x1(CX), DX	
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e8ba		488b8c2400030000	MOVQ 0x300(SP), CX	
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43e8c2		488b9c2448020000	MOVQ 0x248(SP), BX	
		if waspanic {
  0x43e8ca		0fb67c243a		MOVZX 0x3a(SP), DI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43e8cf		4c8b842460020000	MOVQ 0x260(SP), R8	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43e8d7		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
		n = nprint
  0x43e8df		4c8b5c2460		MOVQ 0x60(SP), R11	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43e8e4		4989f4			MOVQ SI, R12		
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43e8e7		4c8bac2410020000	MOVQ 0x210(SP), R13	
	return f._func != nil
  0x43e8ef		4c8bbc2438020000	MOVQ 0x238(SP), R15	
			if skip == 0 && callback == nil {
  0x43e8f7		4889c6			MOVQ AX, SI		
		if callback != nil || printing {
  0x43e8fa		488b842410030000	MOVQ 0x310(SP), AX	
			n-- // offset n++ below
  0x43e902		e927f1ffff		JMP 0x43da2e		
			} else if n < max {
  0x43e907		488b842408030000	MOVQ 0x308(SP), AX	
  0x43e90f		4839c1			CMPQ AX, CX		
  0x43e912		7d24			JGE 0x43e938		
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43e914		4881f900001000		CMPQ $0x100000, CX	
  0x43e91b		0f83420b0000		JAE 0x43f463		
  0x43e921		488bbc2400030000	MOVQ 0x300(SP), DI	
  0x43e929		488914cf		MOVQ DX, 0(DI)(CX*8)	
				n++
  0x43e92d		48ffc1			INCQ CX			
			if skip == 0 && callback == nil {
  0x43e930		4889d8			MOVQ BX, AX		
			lastFuncID = f.funcID
  0x43e933		e979ffffff		JMP 0x43e8b1		
				n = tracebackCgoContext(pcbuf, printing, ctxt, n, max)
  0x43e938		488bbc2400030000	MOVQ 0x300(SP), DI	
			} else if n < max {
  0x43e940		ebee			JMP 0x43e930		
			if skip == 0 && callback == nil {
  0x43e942		4889d8			MOVQ BX, AX		
			lastFuncID = f.funcID
  0x43e945		e967ffffff		JMP 0x43e8b1		
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x43e94a		3c09			CMPL $0x9, AL		
  0x43e94c		750a			JNE 0x43e958		
  0x43e94e		b801000000		MOVL $0x1, AX		
  0x43e953		e948ffffff		JMP 0x43e8a0		
  0x43e958		3c13			CMPL $0x13, AL		
  0x43e95a		0f94c0			SETE AL			
  0x43e95d		e93effffff		JMP 0x43e8a0		
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43e962		4889842458020000	MOVQ AX, 0x258(SP)	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &cache)
  0x43e96a		488b8c24d0000000	MOVQ 0xd0(SP), CX	
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e972		0fb654243b		MOVZX 0x3b(SP), DX	
			} else if n < max {
  0x43e977		488b5c2478		MOVQ 0x78(SP), BX	
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43e97c		488b742448		MOVQ 0x48(SP), SI	
			if skip == 0 && callback == nil {
  0x43e981		488bbc24f8020000	MOVQ 0x2f8(SP), DI	
				for {
  0x43e989		eb27			JMP 0x43e9b2		
					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc)
  0x43e98b		4c8b842470020000	MOVQ 0x270(SP), R8	
					lastFuncID = inltree[ix].funcID
  0x43e993		0fb6441002		MOVZX 0x2(AX)(DX*1), AX	
					tracepc = frame.fn.entry + uintptr(inltree[ix].parentPc)
  0x43e998		448b4c8a10		MOVL 0x10(DX)(CX*4), R9	
  0x43e99d		4963c9			MOVSXD R9, CX		
  0x43e9a0		490308			ADDQ 0(R8), CX		
					pc = tracepc + 1
  0x43e9a3		4c8d4101		LEAQ 0x1(CX), R8	
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e9a7		89c2			MOVL AX, DX		
			if skip == 0 && callback == nil {
  0x43e9a9		4889df			MOVQ BX, DI		
			} else if n < max {
  0x43e9ac		4889f3			MOVQ SI, BX		
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43e9af		4c89c6			MOVQ R8, SI		
			if skip == 0 && callback == nil {
  0x43e9b2		4889bc24f8020000	MOVQ DI, 0x2f8(SP)	
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43e9ba		4889742458		MOVQ SI, 0x58(SP)	
			} else if n < max {
  0x43e9bf		48899c24b8000000	MOVQ BX, 0xb8(SP)	
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43e9c7		8854243c		MOVB DL, 0x3c(SP)	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &cache)
  0x43e9cb		488b842430020000	MOVQ 0x230(SP), AX		
  0x43e9d3		48890424		MOVQ AX, 0(SP)			
  0x43e9d7		4c8b842410020000	MOVQ 0x210(SP), R8		
  0x43e9df		4c89442408		MOVQ R8, 0x8(SP)		
  0x43e9e4		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x43e9ec		48894c2418		MOVQ CX, 0x18(SP)		
  0x43e9f1		488d8c24e0000000	LEAQ 0xe0(SP), CX		
  0x43e9f9		48894c2420		MOVQ CX, 0x20(SP)		
  0x43e9fe		e85dcdffff		CALL runtime.pcdatavalue(SB)	
  0x43ea03		8b442428		MOVL 0x28(SP), AX		
					if ix < 0 {
  0x43ea07		85c0			TESTL AX, AX		
  0x43ea09		0f8cd8000000		JL 0x43eae7		
					if inltree[ix].funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43ea0f		4863c0			MOVSXD AX, AX		
  0x43ea12		483d00001000		CMPQ $0x100000, AX	
  0x43ea18		0f83530a0000		JAE 0x43f471		
  0x43ea1e		488d0480		LEAQ 0(AX)(AX*4), AX	
  0x43ea22		4889c1			MOVQ AX, CX		
  0x43ea25		48c1e002		SHLQ $0x2, AX		
  0x43ea29		488b942458020000	MOVQ 0x258(SP), DX	
  0x43ea31		0fb65c1002		MOVZX 0x2(AX)(DX*1), BX	
  0x43ea36		80fb14			CMPL $0x14, BL		
  0x43ea39		7518			JNE 0x43ea53		
  0x43ea3b		90			NOPL			
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x43ea3c		0fb65c243c		MOVZX 0x3c(SP), BX	
  0x43ea41		80fb12			CMPL $0x12, BL		
  0x43ea44		0f8583000000		JNE 0x43eacd		
  0x43ea4a		bb01000000		MOVL $0x1, BX		
  0x43ea4f		84db			TESTL BL, BL		
					if inltree[ix].funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43ea51		7465			JE 0x43eab8		
					} else if skip > 0 {
  0x43ea53		488b9c24f8020000	MOVQ 0x2f8(SP), BX	
  0x43ea5b		4885db			TESTQ BX, BX		
  0x43ea5e		7e10			JLE 0x43ea70		
						skip--
  0x43ea60		48ffcb			DECQ BX			
			} else if n < max {
  0x43ea63		488bb424b8000000	MOVQ 0xb8(SP), SI	
						skip--
  0x43ea6b		e91bffffff		JMP 0x43e98b		
					} else if n < max {
  0x43ea70		488bb424b8000000	MOVQ 0xb8(SP), SI	
  0x43ea78		488bbc2408030000	MOVQ 0x308(SP), DI	
  0x43ea80		4839fe			CMPQ DI, SI		
  0x43ea83		7d26			JGE 0x43eaab		
						(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43ea85		4881fe00001000		CMPQ $0x100000, SI	
  0x43ea8c		0f83d8090000		JAE 0x43f46a		
  0x43ea92		4c8b442458		MOVQ 0x58(SP), R8	
  0x43ea97		4c8b8c2400030000	MOVQ 0x300(SP), R9	
  0x43ea9f		4d8904f1		MOVQ R8, 0(R9)(SI*8)	
						n++
  0x43eaa3		48ffc6			INCQ SI			
  0x43eaa6		e9e0feffff		JMP 0x43e98b		
						(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43eaab		4c8b8c2400030000	MOVQ 0x300(SP), R9	
					} else if n < max {
  0x43eab3		e9d3feffff		JMP 0x43e98b		
			} else if n < max {
  0x43eab8		488bb424b8000000	MOVQ 0xb8(SP), SI	
			if skip == 0 && callback == nil {
  0x43eac0		488b9c24f8020000	MOVQ 0x2f8(SP), BX	
					lastFuncID = inltree[ix].funcID
  0x43eac8		e9befeffff		JMP 0x43e98b		
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x43eacd		80fb09			CMPL $0x9, BL		
  0x43ead0		750a			JNE 0x43eadc		
  0x43ead2		bb01000000		MOVL $0x1, BX		
  0x43ead7		e973ffffff		JMP 0x43ea4f		
  0x43eadc		80fb13			CMPL $0x13, BL		
  0x43eadf		0f94c3			SETE BL			
  0x43eae2		e968ffffff		JMP 0x43ea4f		
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43eae7		0fb644243c		MOVZX 0x3c(SP), AX	
			} else if n < max {
  0x43eaec		488b8c24b8000000	MOVQ 0xb8(SP), CX	
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43eaf4		488b542458		MOVQ 0x58(SP), DX	
			if skip == 0 && callback == nil {
  0x43eaf9		488b9c24f8020000	MOVQ 0x2f8(SP), BX	
			if f.funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43eb01		e97efdffff		JMP 0x43e884		
				tracepc--
  0x43eb06		498d7eff		LEAQ -0x1(R14), DI	
					ix := pcdatavalue(f, _PCDATA_InlTreeIndex, tracepc, &cache)
  0x43eb0a		4989fe			MOVQ DI, R14		
				tracepc--
  0x43eb0d		e932fdffff		JMP 0x43e844		
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43eb12		488b9c2420030000	MOVQ 0x320(SP), BX	
  0x43eb1a		0fbae301		BTL $0x1, BX		
  0x43eb1e		720d			JB 0x43eb2d		
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43eb20		488b9c2448020000	MOVQ 0x248(SP), BX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43eb28		e908fdffff		JMP 0x43e835		
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43eb2d		488b9c2448020000	MOVQ 0x248(SP), BX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43eb35		e90afdffff		JMP 0x43e844		
			if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
  0x43eb3a		90			NOPL			
  0x43eb3b		488d8c2470020000	LEAQ 0x270(SP), CX	
  0x43eb43		48890c24		MOVQ CX, 0(SP)		
  0x43eb47		488b9c2418030000	MOVQ 0x318(SP), BX	
  0x43eb4f		48895c2408		MOVQ BX, 0x8(SP)	
  0x43eb54		488b30			MOVQ 0(AX), SI		
  0x43eb57		4889c2			MOVQ AX, DX		
  0x43eb5a		ffd6			CALL SI			
  0x43eb5c		807c241000		CMPB $0x0, 0x10(SP)	
  0x43eb61		7465			JE 0x43ebc8		
	printing := pcbuf == nil && callback == nil
  0x43eb63		488b8c2400030000	MOVQ 0x300(SP), CX	
  0x43eb6b		4885c9			TESTQ CX, CX		
		if callback != nil || printing {
  0x43eb6e		488b842410030000	MOVQ 0x310(SP), AX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43eb76		488b542478		MOVQ 0x78(SP), DX	
		print("runtime: g", gp.goid, ": leftover defer sp=", hex(_defer.sp), " pc=", hex(_defer.pc), "\n")
  0x43eb7b		488b9c2448020000	MOVQ 0x248(SP), BX	
			if skip == 0 && callback == nil {
  0x43eb83		488bb424f8020000	MOVQ 0x2f8(SP), SI	
		if waspanic {
  0x43eb8b		0fb67c243a		MOVZX 0x3a(SP), DI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43eb90		4c8b842460020000	MOVQ 0x260(SP), R8	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43eb98		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43eba0		440fb654243b		MOVZX 0x3b(SP), R10	
		n = nprint
  0x43eba6		4c8b5c2460		MOVQ 0x60(SP), R11	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43ebab		4c8ba42430020000	MOVQ 0x230(SP), R12	
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43ebb3		4c8bac2410020000	MOVQ 0x210(SP), R13	
	return f._func != nil
  0x43ebbb		4c8bbc2438020000	MOVQ 0x238(SP), R15	
		if pcbuf != nil {
  0x43ebc3		e960eeffff		JMP 0x43da28		
				return n
  0x43ebc8		488b442478		MOVQ 0x78(SP), AX	
  0x43ebcd		4889842428030000	MOVQ AX, 0x328(SP)	
  0x43ebd5		488bac24c8020000	MOVQ 0x2c8(SP), BP	
  0x43ebdd		4881c4d0020000		ADDQ $0x2d0, SP		
  0x43ebe4		c3			RET			
		for _defer != nil && ((_defer.sp == frame.sp && frame.sp != frame.fp) || _defer.sp == _NoArgs) {
  0x43ebe5		4883f9ff		CMPQ $-0x1, CX		
  0x43ebe9		0f94c1			SETE CL			
  0x43ebec		e917eeffff		JMP 0x43da08		
		if callback != nil || printing {
  0x43ebf1		4885c0			TESTQ AX, AX		
		for _defer != nil && ((_defer.sp == frame.sp && frame.sp != frame.fp) || _defer.sp == _NoArgs) {
  0x43ebf4		e916eeffff		JMP 0x43da0f		
				frame.continpc = 0
  0x43ebf9		48c784248802000000000000	MOVQ $0x0, 0x288(SP)	
  0x43ec05		e9cdedffff			JMP 0x43d9d7		
				frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil, nil)
  0x43ec0a		488d8c2470020000	LEAQ 0x270(SP), CX	
  0x43ec12		48890c24		MOVQ CX, 0(SP)		
  0x43ec16		4c89642408		MOVQ R12, 0x8(SP)	
  0x43ec1b		4c896c2410		MOVQ R13, 0x10(SP)	
		if callback != nil || printing {
  0x43ec20		4885c0			TESTQ AX, AX		
  0x43ec23		0f95c2			SETNE DL		
				frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil, nil)
  0x43ec26		88542418		MOVB DL, 0x18(SP)		
  0x43ec2a		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43ec33		e8b8080000		CALL runtime.getArgInfo(SB)	
  0x43ec38		488b442428		MOVQ 0x28(SP), AX		
  0x43ec3d		488b4c2430		MOVQ 0x30(SP), CX		
  0x43ec42		48898424b8020000	MOVQ AX, 0x2b8(SP)		
  0x43ec4a		48898c24c0020000	MOVQ CX, 0x2c0(SP)		
		if callback != nil || printing {
  0x43ec52		488b842410030000	MOVQ 0x310(SP), AX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43ec5a		488b542478		MOVQ 0x78(SP), DX	
			if _defer != nil && _defer.sp == frame.sp && frame.sp != frame.fp {
  0x43ec5f		488b9c2468020000	MOVQ 0x268(SP), BX	
			if skip == 0 && callback == nil {
  0x43ec67		488bb424f8020000	MOVQ 0x2f8(SP), SI	
		if waspanic {
  0x43ec6f		0fb67c243a		MOVZX 0x3a(SP), DI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43ec74		4c8b842460020000	MOVQ 0x260(SP), R8	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43ec7c		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43ec84		440fb654243b		MOVZX 0x3b(SP), R10	
		n = nprint
  0x43ec8a		4c8b5c2460		MOVQ 0x60(SP), R11	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43ec8f		4c8ba42430020000	MOVQ 0x230(SP), R12	
			if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x43ec97		4c8bac2410020000	MOVQ 0x210(SP), R13	
	return f._func != nil
  0x43ec9f		4c8bbc2438020000	MOVQ 0x238(SP), R15	
				frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil, nil)
  0x43eca7		e9b2efffff		JMP 0x43dc5e		
  0x43ecac		31c9			XORL CX, CX		
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43ecae		e98aefffff		JMP 0x43dc3d		
	printing := pcbuf == nil && callback == nil
  0x43ecb3		0fb64c243d		MOVZX 0x3d(SP), CX	
  0x43ecb8		84c9			TESTL CL, CL		
		if callback != nil || printing {
  0x43ecba		0f849eefffff		JE 0x43dc5e		
  0x43ecc0		4885c0			TESTQ AX, AX		
  0x43ecc3		e952efffff		JMP 0x43dc1a		
				if frame.lr == 0 {
  0x43ecc8		4883bc249002000000	CMPQ $0x0, 0x290(SP)	
  0x43ecd1		0f854b020000		JNE 0x43ef22		
					lrPtr = frame.fp - sys.RegSize
  0x43ecd7		4c8bb424a0020000	MOVQ 0x2a0(SP), R14	
  0x43ecdf		4983c6f8		ADDQ $-0x8, R14		
					frame.lr = uintptr(*(*sys.Uintreg)(unsafe.Pointer(lrPtr)))
  0x43ece3		4d89f7			MOVQ R14, R15		
  0x43ece6		4d8b36			MOVQ 0(R14), R14	
  0x43ece9		4c89b42490020000	MOVQ R14, 0x290(SP)	
					tracebackHexdump(gp.stack, &frame, lrPtr)
  0x43ecf1		4c89bc2480000000	MOVQ R15, 0x80(SP)	
			flr = findfunc(frame.lr)
  0x43ecf9		488b842490020000	MOVQ 0x290(SP), AX		
  0x43ed01		48890424		MOVQ AX, 0(SP)			
  0x43ed05		e8f6bdffff		CALL runtime.findfunc(SB)	
  0x43ed0a		488b442408		MOVQ 0x8(SP), AX		
  0x43ed0f		488b4c2410		MOVQ 0x10(SP), CX		
			if !flr.valid() {
  0x43ed14		90			NOPL			
	return f._func != nil
  0x43ed15		4885c0			TESTQ AX, AX		
			if !flr.valid() {
  0x43ed18		7460			JE 0x43ed7a		
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43ed1a		488b542478		MOVQ 0x78(SP), DX	
			if _defer != nil && _defer.sp == frame.sp && frame.sp != frame.fp {
  0x43ed1f		488b9c2468020000	MOVQ 0x268(SP), BX	
			if skip == 0 && callback == nil {
  0x43ed27		488bb424f8020000	MOVQ 0x2f8(SP), SI	
		if waspanic {
  0x43ed2f		0fb67c243a		MOVZX 0x3a(SP), DI	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43ed34		4c8b842460020000	MOVQ 0x260(SP), R8	
		if f.funcID == funcID_cgocallback_gofunc && len(cgoCtxt) > 0 {
  0x43ed3c		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43ed44		440fb654243b		MOVZX 0x3b(SP), R10	
		n = nprint
  0x43ed4a		4c8b5c2460		MOVQ 0x60(SP), R11	
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43ed4f		4c8ba42430020000	MOVQ 0x230(SP), R12	
				frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil, nil)
  0x43ed57		4c8bac2410020000	MOVQ 0x210(SP), R13	
		if !flr.valid() {
  0x43ed5f		4989ce			MOVQ CX, R14		
  0x43ed62		4989c7			MOVQ AX, R15		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ed65		488b8424f0020000	MOVQ 0x2f0(SP), AX	
	for n < max {
  0x43ed6d		488b8c2408030000	MOVQ 0x308(SP), CX	
		frame.varp = frame.fp
  0x43ed75		e944eeffff		JMP 0x43dbbe		
	printing := pcbuf == nil && callback == nil
  0x43ed7a		0fb65c243d		MOVZX 0x3d(SP), BX	
  0x43ed7f		84db			TESTL BL, BL		
				if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
  0x43ed81		0f8489010000		JE 0x43ef10		
  0x43ed87		488bb424f0020000	MOVQ 0x2f0(SP), SI	
  0x43ed8f		488b7e30		MOVQ 0x30(SI), DI	
  0x43ed93		80bf1901000000		CMPB $0x0, 0x119(DI)	
  0x43ed9a		0f8466010000		JE 0x43ef06		
  0x43eda0		488bbc2430020000	MOVQ 0x230(SP), DI	
  0x43eda8		807f2409		CMPB $0x9, 0x24(DI)	
  0x43edac		0f854d010000		JNE 0x43eeff		
  0x43edb2		31d2			XORL DX, DX		
			flr = findfunc(frame.lr)
  0x43edb4		48898424f8010000	MOVQ AX, 0x1f8(SP)	
  0x43edbc		48898c24f0010000	MOVQ CX, 0x1f0(SP)	
				if callback != nil || doPrint {
  0x43edc4		4c8b842410030000	MOVQ 0x310(SP), R8	
  0x43edcc		4d85c0			TESTQ R8, R8		
  0x43edcf		7512			JNE 0x43ede3		
  0x43edd1		84d2			TESTL DL, DL		
  0x43edd3		750e			JNE 0x43ede3		
  0x43edd5		4d85c0			TESTQ R8, R8		
				if callback != nil {
  0x43edd8		0f843cffffff		JE 0x43ed1a		
  0x43edde		e995060000		JMP 0x43f478		
					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n")
  0x43ede3		48893c24		MOVQ DI, 0(SP)			
  0x43ede7		488b842410020000	MOVQ 0x210(SP), AX		
  0x43edef		4889442408		MOVQ AX, 0x8(SP)		
  0x43edf4		e847c4ffff		CALL runtime.funcname(SB)	
  0x43edf9		488b442410		MOVQ 0x10(SP), AX		
  0x43edfe		4889842450020000	MOVQ AX, 0x250(SP)		
  0x43ee06		488b4c2418		MOVQ 0x18(SP), CX		
  0x43ee0b		48898c24b8000000	MOVQ CX, 0xb8(SP)		
  0x43ee13		488b942490020000	MOVQ 0x290(SP), DX		
  0x43ee1b		48899424d0000000	MOVQ DX, 0xd0(SP)		
  0x43ee23		e89850feff		CALL runtime.printlock(SB)	
  0x43ee28		488d0581350300		LEAQ 0x33581(IP), AX		
  0x43ee2f		48890424		MOVQ AX, 0(SP)			
  0x43ee33		48c744240822000000	MOVQ $0x22, 0x8(SP)		
  0x43ee3c		e8af59feff		CALL runtime.printstring(SB)	
  0x43ee41		488b842450020000	MOVQ 0x250(SP), AX		
  0x43ee49		48890424		MOVQ AX, 0(SP)			
  0x43ee4d		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x43ee55		4889442408		MOVQ AX, 0x8(SP)		
  0x43ee5a		e89159feff		CALL runtime.printstring(SB)	
  0x43ee5f		488d050a0d0300		LEAQ 0x30d0a(IP), AX		
  0x43ee66		48890424		MOVQ AX, 0(SP)			
  0x43ee6a		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x43ee73		e87859feff		CALL runtime.printstring(SB)	
  0x43ee78		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43ee80		48890424		MOVQ AX, 0(SP)			
  0x43ee84		e82758feff		CALL runtime.printhex(SB)	
  0x43ee89		e8c252feff		CALL runtime.printnl(SB)	
  0x43ee8e		e8ad50feff		CALL runtime.printunlock(SB)	
					tracebackHexdump(gp.stack, &frame, lrPtr)
  0x43ee93		488b8424f0020000	MOVQ 0x2f0(SP), AX			
  0x43ee9b		488b4808		MOVQ 0x8(AX), CX			
  0x43ee9f		488b10			MOVQ 0(AX), DX				
  0x43eea2		48891424		MOVQ DX, 0(SP)				
  0x43eea6		48894c2408		MOVQ CX, 0x8(SP)			
  0x43eeab		488d8c2470020000	LEAQ 0x270(SP), CX			
  0x43eeb3		48894c2410		MOVQ CX, 0x10(SP)			
  0x43eeb8		488b942480000000	MOVQ 0x80(SP), DX			
  0x43eec0		4889542418		MOVQ DX, 0x18(SP)			
  0x43eec5		e856200000		CALL runtime.tracebackHexdump(SB)	
				if callback != nil || doPrint {
  0x43eeca		4c8b842410030000	MOVQ 0x310(SP), R8	
  0x43eed2		4d85c0			TESTQ R8, R8		
		if !flr.valid() {
  0x43eed5		488b8424f8010000	MOVQ 0x1f8(SP), AX	
  0x43eedd		488b8c24f0010000	MOVQ 0x1f0(SP), CX	
	printing := pcbuf == nil && callback == nil
  0x43eee5		0fb65c243d		MOVZX 0x3d(SP), BX	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43eeea		488bb424f0020000	MOVQ 0x2f0(SP), SI	
	return uintptr(f.args), nil, !(needArgMap && f.args == _ArgsSizeUnknown)
  0x43eef2		488bbc2430020000	MOVQ 0x230(SP), DI	
					tracebackHexdump(gp.stack, &frame, lrPtr)
  0x43eefa		e9d9feffff		JMP 0x43edd8		
				if callback != nil || doPrint {
  0x43eeff		89da			MOVL BX, DX		
  0x43ef01		e9aefeffff		JMP 0x43edb4		
					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n")
  0x43ef06		488bbc2430020000	MOVQ 0x230(SP), DI	
				if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
  0x43ef0e		ebef			JMP 0x43eeff		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ef10		488bb424f0020000	MOVQ 0x2f0(SP), SI	
					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n")
  0x43ef18		488bbc2430020000	MOVQ 0x230(SP), DI	
				if doPrint && gp.m.incgo && f.funcID == funcID_sigpanic {
  0x43ef20		ebdd			JMP 0x43eeff		
  0x43ef22		4531ff			XORL R15, R15		
				if frame.lr == 0 {
  0x43ef25		e9c7fdffff		JMP 0x43ecf1		
		f.funcID == funcID_mstart ||
  0x43ef2a		4180ff06		CMPL $0x6, R15		
  0x43ef2e		750b			JNE 0x43ef3b		
  0x43ef30		41be01000000		MOVL $0x1, R14		
  0x43ef36		e948ecffff		JMP 0x43db83		
		f.funcID == funcID_mcall ||
  0x43ef3b		4180ff04		CMPL $0x4, R15		
  0x43ef3f		750b			JNE 0x43ef4c		
  0x43ef41		41be01000000		MOVL $0x1, R14		
  0x43ef47		e937ecffff		JMP 0x43db83		
		f.funcID == funcID_morestack ||
  0x43ef4c		4180ff05		CMPL $0x5, R15		
  0x43ef50		750b			JNE 0x43ef5d		
  0x43ef52		41be01000000		MOVL $0x1, R14		
  0x43ef58		e926ecffff		JMP 0x43db83		
		f.funcID == funcID_rt0_go ||
  0x43ef5d		4180ff07		CMPL $0x7, R15		
  0x43ef61		750b			JNE 0x43ef6e		
  0x43ef63		41be01000000		MOVL $0x1, R14		
  0x43ef69		e915ecffff		JMP 0x43db83		
		f.funcID == funcID_externalthreadhandler ||
  0x43ef6e		4180ff10		CMPL $0x10, R15		
  0x43ef72		750b			JNE 0x43ef7f		
  0x43ef74		41be01000000		MOVL $0x1, R14		
  0x43ef7a		e904ecffff		JMP 0x43db83		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ef7f		4584f6			TESTL R14, R14		
		(g0 && f.funcID == funcID_asmcgocall)
  0x43ef82		740d			JE 0x43ef91		
  0x43ef84		4180ff08		CMPL $0x8, R15		
  0x43ef88		410f94c6		SETE R14		
  0x43ef8c		e9f2ebffff		JMP 0x43db83		
  0x43ef91		4531f6			XORL R14, R14		
  0x43ef94		e9eaebffff		JMP 0x43db83		
  0x43ef99		4531f6			XORL R14, R14		
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43ef9c		e9cbebffff		JMP 0x43db6c		
			if flags&_TraceJumpStack != 0 && gp == gp.m.g0 && gp.m.curg != nil {
  0x43efa1		4c8bb42420030000	MOVQ 0x320(SP), R14	
  0x43efa9		410fbae602		BTL $0x2, R14		
  0x43efae		7350			JAE 0x43f000		
  0x43efb0		4c8b7830		MOVQ 0x30(AX), R15	
  0x43efb4		493907			CMPQ AX, 0(R15)		
  0x43efb7		7547			JNE 0x43f000		
  0x43efb9		4d8bbfc0000000		MOVQ 0xc0(R15), R15	
  0x43efc0		4d85ff			TESTQ R15, R15		
  0x43efc3		743b			JE 0x43f000		
				switch f.funcID {
  0x43efc5		450fb6742424		MOVZX 0x24(R12), R14	
				case funcID_morestack:
  0x43efcb		4180fe05		CMPL $0x5, R14		
  0x43efcf		0f84ee000000		JE 0x43f0c3		
				case funcID_systemstack:
  0x43efd5		4180fe0d		CMPL $0xd, R14		
  0x43efd9		7525			JNE 0x43f000		
					frame.sp = gp.m.curg.sched.sp
  0x43efdb		4d8b4738		MOVQ 0x38(R15), R8	
  0x43efdf		4c89842498020000	MOVQ R8, 0x298(SP)	
					cgoCtxt = gp.m.curg.cgoCtxt
  0x43efe7		4c8b4030		MOVQ 0x30(AX), R8	
  0x43efeb		4d8b80c0000000		MOVQ 0xc0(R8), R8	
  0x43eff2		4d8b8848010000		MOVQ 0x148(R8), R9	
  0x43eff9		4d8b8040010000		MOVQ 0x140(R8), R8	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43f000		4c898c24a0000000	MOVQ R9, 0xa0(SP)	
  0x43f008		4c89842460020000	MOVQ R8, 0x260(SP)	
			frame.fp = frame.sp + uintptr(funcspdelta(f, frame.pc, &cache))
  0x43f010		4c89ac2420020000	MOVQ R13, 0x220(SP)		
  0x43f018		4c89a42428020000	MOVQ R12, 0x228(SP)		
  0x43f020		4c892424		MOVQ R12, 0(SP)			
  0x43f024		4c896c2408		MOVQ R13, 0x8(SP)		
  0x43f029		488b842480020000	MOVQ 0x280(SP), AX		
  0x43f031		4889442410		MOVQ AX, 0x10(SP)		
  0x43f036		488d8424e0000000	LEAQ 0xe0(SP), AX		
  0x43f03e		4889442418		MOVQ AX, 0x18(SP)		
  0x43f043		e8a8c5ffff		CALL runtime.funcspdelta(SB)	
  0x43f048		4863442420		MOVSXD 0x20(SP), AX		
  0x43f04d		4803842498020000	ADDQ 0x298(SP), AX		
  0x43f055		48898424a0020000	MOVQ AX, 0x2a0(SP)		
				frame.fp += sys.RegSize
  0x43f05d		4883c008		ADDQ $0x8, AX		
  0x43f061		48898424a0020000	MOVQ AX, 0x2a0(SP)	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43f069		488b8424f0020000	MOVQ 0x2f0(SP), AX	
	for n < max {
  0x43f071		488b8c2408030000	MOVQ 0x308(SP), CX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43f079		488b542478		MOVQ 0x78(SP), DX	
			if _defer != nil && _defer.sp == frame.sp && frame.sp != frame.fp {
  0x43f07e		488b9c2468020000	MOVQ 0x268(SP), BX	
			if skip == 0 && callback == nil {
  0x43f086		488bb424f8020000	MOVQ 0x2f8(SP), SI	
		if waspanic {
  0x43f08e		0fb67c243a		MOVZX 0x3a(SP), DI	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43f093		440fb654243b		MOVZX 0x3b(SP), R10	
		n = nprint
  0x43f099		4c8b5c2460		MOVQ 0x60(SP), R11	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43f09e		4c8bac2420020000	MOVQ 0x220(SP), R13	
  0x43f0a6		4c8ba42428020000	MOVQ 0x228(SP), R12	
			ctxt := cgoCtxt[len(cgoCtxt)-1]
  0x43f0ae		4c8b8c24a0000000	MOVQ 0xa0(SP), R9	
  0x43f0b6		4c8b842460020000	MOVQ 0x260(SP), R8	
		if topofstack(f, gp.m != nil && gp == gp.m.g0) {
  0x43f0be		e995eaffff		JMP 0x43db58		
					frame.pc = gp.m.curg.sched.pc
  0x43f0c3		498b4740		MOVQ 0x40(R15), AX	
  0x43f0c7		4889842480020000	MOVQ AX, 0x280(SP)	
					frame.fn = findfunc(frame.pc)
  0x43f0cf		48890424		MOVQ AX, 0(SP)			
  0x43f0d3		e828baffff		CALL runtime.findfunc(SB)	
  0x43f0d8		4c8b642408		MOVQ 0x8(SP), R12		
  0x43f0dd		4c8b6c2410		MOVQ 0x10(SP), R13		
  0x43f0e2		4c89a42470020000	MOVQ R12, 0x270(SP)		
  0x43f0ea		4c89ac2478020000	MOVQ R13, 0x278(SP)		
					frame.sp = gp.m.curg.sched.sp
  0x43f0f2		488b8424f0020000	MOVQ 0x2f0(SP), AX	
  0x43f0fa		488b4830		MOVQ 0x30(AX), CX	
  0x43f0fe		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x43f105		488b4938		MOVQ 0x38(CX), CX	
  0x43f109		48898c2498020000	MOVQ CX, 0x298(SP)	
					cgoCtxt = gp.m.curg.cgoCtxt
  0x43f111		488b4830		MOVQ 0x30(AX), CX	
  0x43f115		488b89c0000000		MOVQ 0xc0(CX), CX	
  0x43f11c		4c8b8948010000		MOVQ 0x148(CX), R9	
  0x43f123		4c8b8140010000		MOVQ 0x140(CX), R8	
	for n < max {
  0x43f12a		488b8c2408030000	MOVQ 0x308(SP), CX	
			if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
  0x43f132		488b542478		MOVQ 0x78(SP), DX	
			if _defer != nil && _defer.sp == frame.sp && frame.sp != frame.fp {
  0x43f137		488b9c2468020000	MOVQ 0x268(SP), BX	
			if skip == 0 && callback == nil {
  0x43f13f		488bb424f8020000	MOVQ 0x2f8(SP), SI	
		if waspanic {
  0x43f147		0fb67c243a		MOVZX 0x3a(SP), DI	
			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, f.funcID, lastFuncID) {
  0x43f14c		440fb654243b		MOVZX 0x3b(SP), R10	
		n = nprint
  0x43f152		4c8b5c2460		MOVQ 0x60(SP), R11	
				switch f.funcID {
  0x43f157		e9a4feffff		JMP 0x43f000		
	if callback != nil && n < max && _defer != nil {
  0x43f15c		488b842410030000	MOVQ 0x310(SP), AX	
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43f164		440fb674243d		MOVZX 0x3d(SP), R14	
  0x43f16a		4889d7			MOVQ DX, DI		
			break
  0x43f16d		e94eebffff		JMP 0x43dcc0		
	if callback != nil && n < max && _defer != nil {
  0x43f172		488b842410030000	MOVQ 0x310(SP), AX	
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43f17a		440fb674243d		MOVZX 0x3d(SP), R14	
  0x43f180		4889d7			MOVQ DX, DI		
	for n < max {
  0x43f183		e938ebffff		JMP 0x43dcc0		
		if callback != nil || printing {
  0x43f188		488b842410030000	MOVQ 0x310(SP), AX	
  0x43f190		4885c0			TESTQ AX, AX		
  0x43f193		0f84a9000000		JE 0x43f242		
			print("runtime: unknown pc ", hex(frame.pc), "\n")
  0x43f199		488b842480020000	MOVQ 0x280(SP), AX		
  0x43f1a1		48898424d0000000	MOVQ AX, 0xd0(SP)		
  0x43f1a9		e8124dfeff		CALL runtime.printlock(SB)	
  0x43f1ae		488d0598150300		LEAQ 0x31598(IP), AX		
  0x43f1b5		48890424		MOVQ AX, 0(SP)			
  0x43f1b9		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x43f1c2		e82956feff		CALL runtime.printstring(SB)	
  0x43f1c7		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43f1cf		48890424		MOVQ AX, 0(SP)			
  0x43f1d3		e8d854feff		CALL runtime.printhex(SB)	
  0x43f1d8		e8734ffeff		CALL runtime.printnl(SB)	
  0x43f1dd		e85e4dfeff		CALL runtime.printunlock(SB)	
			tracebackHexdump(gp.stack, &frame, 0)
  0x43f1e2		488b8424f0020000	MOVQ 0x2f0(SP), AX			
  0x43f1ea		488b4808		MOVQ 0x8(AX), CX			
  0x43f1ee		488b00			MOVQ 0(AX), AX				
  0x43f1f1		48890424		MOVQ AX, 0(SP)				
  0x43f1f5		48894c2408		MOVQ CX, 0x8(SP)			
  0x43f1fa		488d842470020000	LEAQ 0x270(SP), AX			
  0x43f202		4889442410		MOVQ AX, 0x10(SP)			
  0x43f207		48c744241800000000	MOVQ $0x0, 0x18(SP)			
  0x43f210		e80b1d0000		CALL runtime.tracebackHexdump(SB)	
		if callback != nil || printing {
  0x43f215		488b842410030000	MOVQ 0x310(SP), AX	
  0x43f21d		4885c0			TESTQ AX, AX		
		if callback != nil {
  0x43f220		0f856d020000		JNE 0x43f493		
		return 0
  0x43f226		48c784242803000000000000	MOVQ $0x0, 0x328(SP)	
  0x43f232		488bac24c8020000		MOVQ 0x2c8(SP), BP	
  0x43f23a		4881c4d0020000			ADDQ $0x2d0, SP		
  0x43f241		c3				RET			
	printing := pcbuf == nil && callback == nil
  0x43f242		0fb64c243d		MOVZX 0x3d(SP), CX	
  0x43f247		84c9			TESTL CL, CL		
		if callback != nil || printing {
  0x43f249		0f854affffff		JNE 0x43f199		
  0x43f24f		4885c0			TESTQ AX, AX		
		if callback != nil {
  0x43f252		ebcc			JMP 0x43f220		
	printing := pcbuf == nil && callback == nil
  0x43f254		4885c9			TESTQ CX, CX		
  0x43f257		400f94c7		SETE DI			
  0x43f25b		e989e6ffff		JMP 0x43d8e9		
			pc0 = gp.sched.pc
  0x43f260		4c8b4340		MOVQ 0x40(BX), R8	
			sp0 = gp.sched.sp
  0x43f264		488b5338		MOVQ 0x38(BX), DX	
	var frame stkframe
  0x43f268		e91de6ffff		JMP 0x43d88a		
	frame.pc = pc0
  0x43f26d		4989d0			MOVQ DX, R8		
	frame.sp = sp0
  0x43f270		488b9424e0020000	MOVQ 0x2e0(SP), DX	
	var frame stkframe
  0x43f278		e90de6ffff		JMP 0x43d88a		
	frame.sp = sp0
  0x43f27d		4c8b8424e0020000	MOVQ 0x2e0(SP), R8	
	if _g_.m.traceback != 0 {
  0x43f285		ebe6			JMP 0x43f26d		
	printing := pcbuf == nil && callback == nil
  0x43f287		488b8c2410030000	MOVQ 0x310(SP), CX	
	if skip > 0 && callback != nil {
  0x43f28f		e980e5ffff		JMP 0x43d814		
	if callback != nil && n < max && frame.sp != gp.stktopsp {
  0x43f294		48898424d0000000	MOVQ AX, 0xd0(SP)	
  0x43f29c		48899c24c8000000	MOVQ BX, 0xc8(SP)	
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43f2a4		48897c2478		MOVQ DI, 0x78(SP)	
		print("runtime: g", gp.goid, ": frame.sp=", hex(frame.sp), " top=", hex(gp.stktopsp), "\n")
  0x43f2a9		488b8298000000		MOVQ 0x98(DX), AX		
  0x43f2b0		48898424d8000000	MOVQ AX, 0xd8(SP)		
  0x43f2b8		e8034cfeff		CALL runtime.printlock(SB)	
  0x43f2bd		488d0516050300		LEAQ 0x30516(IP), AX		
  0x43f2c4		48890424		MOVQ AX, 0(SP)			
  0x43f2c8		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x43f2d1		e81a55feff		CALL runtime.printstring(SB)	
  0x43f2d6		488b8424d8000000	MOVQ 0xd8(SP), AX		
  0x43f2de		48890424		MOVQ AX, 0(SP)			
  0x43f2e2		e85953feff		CALL runtime.printint(SB)	
  0x43f2e7		488d05d8050300		LEAQ 0x305d8(IP), AX		
  0x43f2ee		48890424		MOVQ AX, 0(SP)			
  0x43f2f2		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x43f2fb		e8f054feff		CALL runtime.printstring(SB)	
  0x43f300		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43f308		48890424		MOVQ AX, 0(SP)			
  0x43f30c		e89f53feff		CALL runtime.printhex(SB)	
  0x43f311		488d05bcfe0200		LEAQ 0x2febc(IP), AX		
  0x43f318		48890424		MOVQ AX, 0(SP)			
  0x43f31c		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43f325		e8c654feff		CALL runtime.printstring(SB)	
  0x43f32a		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43f332		48890424		MOVQ AX, 0(SP)			
  0x43f336		e87553feff		CALL runtime.printhex(SB)	
  0x43f33b		e8104efeff		CALL runtime.printnl(SB)	
  0x43f340		e8fb4bfeff		CALL runtime.printunlock(SB)	
		print("\tstack=[", hex(gp.stack.lo), "-", hex(gp.stack.hi), "] n=", n, " max=", max, "\n")
  0x43f345		488b8424f0020000	MOVQ 0x2f0(SP), AX		
  0x43f34d		488b08			MOVQ 0(AX), CX			
  0x43f350		48898c24d0000000	MOVQ CX, 0xd0(SP)		
  0x43f358		488b4008		MOVQ 0x8(AX), AX		
  0x43f35c		48898424c8000000	MOVQ AX, 0xc8(SP)		
  0x43f364		e8574bfeff		CALL runtime.printlock(SB)	
  0x43f369		488d05e8000300		LEAQ 0x300e8(IP), AX		
  0x43f370		48890424		MOVQ AX, 0(SP)			
  0x43f374		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x43f37d		e86e54feff		CALL runtime.printstring(SB)	
  0x43f382		488b8424d0000000	MOVQ 0xd0(SP), AX		
  0x43f38a		48890424		MOVQ AX, 0(SP)			
  0x43f38e		e81d53feff		CALL runtime.printhex(SB)	
  0x43f393		488d05ebfc0200		LEAQ 0x2fceb(IP), AX		
  0x43f39a		48890424		MOVQ AX, 0(SP)			
  0x43f39e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43f3a7		e84454feff		CALL runtime.printstring(SB)	
  0x43f3ac		488b8424c8000000	MOVQ 0xc8(SP), AX		
  0x43f3b4		48890424		MOVQ AX, 0(SP)			
  0x43f3b8		e8f352feff		CALL runtime.printhex(SB)	
  0x43f3bd		488d0575fd0200		LEAQ 0x2fd75(IP), AX		
  0x43f3c4		48890424		MOVQ AX, 0(SP)			
  0x43f3c8		48c744240804000000	MOVQ $0x4, 0x8(SP)		
  0x43f3d1		e81a54feff		CALL runtime.printstring(SB)	
  0x43f3d6		488b442478		MOVQ 0x78(SP), AX		
  0x43f3db		48890424		MOVQ AX, 0(SP)			
  0x43f3df		e85c52feff		CALL runtime.printint(SB)	
  0x43f3e4		488d05d5fd0200		LEAQ 0x2fdd5(IP), AX		
  0x43f3eb		48890424		MOVQ AX, 0(SP)			
  0x43f3ef		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x43f3f8		e8f353feff		CALL runtime.printstring(SB)	
  0x43f3fd		488b842408030000	MOVQ 0x308(SP), AX		
  0x43f405		48890424		MOVQ AX, 0(SP)			
  0x43f409		e83252feff		CALL runtime.printint(SB)	
  0x43f40e		e83d4dfeff		CALL runtime.printnl(SB)	
  0x43f413		e8284bfeff		CALL runtime.printunlock(SB)	
		throw("traceback did not unwind completely")
  0x43f418		488d05c9300300		LEAQ 0x330c9(IP), AX	
  0x43f41f		48890424		MOVQ AX, 0(SP)		
  0x43f423		48c744240823000000	MOVQ $0x23, 0x8(SP)	
  0x43f42c		e84f40feff		CALL runtime.throw(SB)	
  0x43f431		0f0b			UD2			
		throw("traceback has leftover defers")
  0x43f433		488d05f1250300		LEAQ 0x325f1(IP), AX	
  0x43f43a		48890424		MOVQ AX, 0(SP)		
  0x43f43e		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x43f447		e83440feff		CALL runtime.throw(SB)	
  0x43f44c		0f0b			UD2			
					lastFuncID = inltree[ix].funcID
  0x43f44e		e8cd2afeff		CALL runtime.panicindex(SB)	
  0x43f453		0f0b			UD2				
						name := funcnameFromNameoff(f, inltree[ix].func_)
  0x43f455		e8c62afeff		CALL runtime.panicindex(SB)	
  0x43f45a		0f0b			UD2				
					if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp, nprint == 0, inltree[ix].funcID, lastFuncID) {
  0x43f45c		e8bf2afeff		CALL runtime.panicindex(SB)	
  0x43f461		0f0b			UD2				
				(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43f463		e8b82afeff		CALL runtime.panicindex(SB)	
  0x43f468		0f0b			UD2				
						(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43f46a		e8b12afeff		CALL runtime.panicindex(SB)	
  0x43f46f		0f0b			UD2				
					if inltree[ix].funcID == funcID_wrapper && elideWrapperCalling(lastFuncID) {
  0x43f471		e8aa2afeff		CALL runtime.panicindex(SB)	
  0x43f476		0f0b			UD2				
					throw("unknown caller pc")
  0x43f478		488d05ef0d0300		LEAQ 0x30def(IP), AX	
  0x43f47f		48890424		MOVQ AX, 0(SP)		
  0x43f483		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x43f48c		e8ef3ffeff		CALL runtime.throw(SB)	
  0x43f491		0f0b			UD2			
			throw("unknown pc")
  0x43f493		488d0572030300		LEAQ 0x30372(IP), AX	
  0x43f49a		48890424		MOVQ AX, 0(SP)		
  0x43f49e		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x43f4a7		e8d43ffeff		CALL runtime.throw(SB)	
  0x43f4ac		0f0b			UD2			
		throw("gentraceback cannot trace user goroutine on its own stack")
  0x43f4ae		488d05d33f0300		LEAQ 0x33fd3(IP), AX	
  0x43f4b5		48890424		MOVQ AX, 0(SP)		
  0x43f4b9		48c744240839000000	MOVQ $0x39, 0x8(SP)	
  0x43f4c2		e8b93ffeff		CALL runtime.throw(SB)	
  0x43f4c7		0f0b			UD2			
		throw("gentraceback callback cannot be used with non-zero skip")
  0x43f4c9		488d05123f0300		LEAQ 0x33f12(IP), AX	
  0x43f4d0		48890424		MOVQ AX, 0(SP)		
  0x43f4d4		48c744240837000000	MOVQ $0x37, 0x8(SP)	
  0x43f4dd		e89e3ffeff		CALL runtime.throw(SB)	
  0x43f4e2		0f0b			UD2			
func gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int {
  0x43f4e4		e897830000		CALL runtime.morestack_noctxt(SB)	
  0x43f4e9		e9d2e2ffff		JMP runtime.gentraceback(SB)		

TEXT runtime.getArgInfo(SB) /usr/local/go/src/runtime/traceback.go
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43f4f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f4f9		483b6110		CMPQ 0x10(CX), SP	
  0x43f4fd		0f86ae010000		JBE 0x43f6b1		
  0x43f503		4883ec40		SUBQ $0x40, SP		
  0x43f507		48896c2438		MOVQ BP, 0x38(SP)	
  0x43f50c		488d6c2438		LEAQ 0x38(SP), BP	
	arglen = uintptr(f.args)
  0x43f511		488b442450		MOVQ 0x50(SP), AX	
  0x43f516		8b480c			MOVL 0xc(AX), CX	
  0x43f519		4863d1			MOVSXD CX, DX		
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43f51c		0fb65c2460		MOVZX 0x60(SP), BX	
  0x43f521		84db			TESTL BL, BL		
	if needArgMap && f.args == _ArgsSizeUnknown {
  0x43f523		7408			JE 0x43f52d		
  0x43f525		81f900000080		CMPL $-0x80000000, CX	
  0x43f52b		7416			JE 0x43f543		
  0x43f52d		31c0			XORL AX, AX		
	return
  0x43f52f		4889542470		MOVQ DX, 0x70(SP)	
  0x43f534		4889442478		MOVQ AX, 0x78(SP)	
  0x43f539		488b6c2438		MOVQ 0x38(SP), BP	
  0x43f53e		4883c440		ADDQ $0x40, SP		
  0x43f542		c3			RET			
	arglen = uintptr(f.args)
  0x43f543		4889542428		MOVQ DX, 0x28(SP)	
		switch funcname(f) {
  0x43f548		48890424		MOVQ AX, 0(SP)			
  0x43f54c		488b4c2458		MOVQ 0x58(SP), CX		
  0x43f551		48894c2408		MOVQ CX, 0x8(SP)		
  0x43f556		e8e5bcffff		CALL runtime.funcname(SB)	
  0x43f55b		488b442418		MOVQ 0x18(SP), AX		
  0x43f560		488b4c2410		MOVQ 0x10(SP), CX		
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43f565		4883f814		CMPQ $0x14, AX		
  0x43f569		0f8486000000		JE 0x43f5f5		
  0x43f56f		4883f817		CMPQ $0x17, AX		
  0x43f573		740c			JE 0x43f581		
	return
  0x43f575		31c0			XORL AX, AX		
  0x43f577		488b4c2428		MOVQ 0x28(SP), CX	
  0x43f57c		4889ca			MOVQ CX, DX		
  0x43f57f		ebae			JMP 0x43f52f		
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43f581		48890c24		MOVQ CX, 0(SP)			
  0x43f585		488d0d62170300		LEAQ 0x31762(IP), CX		
  0x43f58c		48894c2408		MOVQ CX, 0x8(SP)		
  0x43f591		4889442410		MOVQ AX, 0x10(SP)		
  0x43f596		e8852cfcff		CALL runtime.memequal(SB)	
  0x43f59b		807c241800		CMPB $0x0, 0x18(SP)		
  0x43f5a0		74d3			JE 0x43f575			
			if ctxt != nil {
  0x43f5a2		488b442468		MOVQ 0x68(SP), AX	
  0x43f5a7		4885c0			TESTQ AX, AX		
  0x43f5aa		7431			JE 0x43f5dd		
  0x43f5ac		31c9			XORL CX, CX		
			if mv.fn != f.entry {
  0x43f5ae		488b542450		MOVQ 0x50(SP), DX	
  0x43f5b3		488b1a			MOVQ 0(DX), BX		
  0x43f5b6		483918			CMPQ BX, 0(AX)		
  0x43f5b9		7574			JNE 0x43f62f		
			bv := mv.stack
  0x43f5bb		488b5008		MOVQ 0x8(AX), DX	
			arglen = uintptr(bv.n * sys.PtrSize)
  0x43f5bf		8b1a			MOVL 0(DX), BX		
  0x43f5c1		c1e303			SHLL $0x3, BX		
  0x43f5c4		4863db			MOVSXD BX, BX		
			if !retValid {
  0x43f5c7		84c9			TESTL CL, CL		
  0x43f5c9		7408			JE 0x43f5d3		
	return
  0x43f5cb		4889d0			MOVQ DX, AX		
  0x43f5ce		4889d9			MOVQ BX, CX		
		switch funcname(f) {
  0x43f5d1		eba9			JMP 0x43f57c		
				arglen = uintptr(mv.argLen) &^ (sys.PtrSize - 1)
  0x43f5d3		488b5810		MOVQ 0x10(AX), BX	
  0x43f5d7		4883e3f8		ANDQ $-0x8, BX		
  0x43f5db		ebee			JMP 0x43f5cb		
				arg0 := frame.sp + sys.MinFrameSize
  0x43f5dd		488b542448		MOVQ 0x48(SP), DX	
  0x43f5e2		488b5228		MOVQ 0x28(DX), DX	
				mv = *(**reflectMethodValue)(unsafe.Pointer(arg0))
  0x43f5e6		4889d3			MOVQ DX, BX		
				retValid = *(*bool)(unsafe.Pointer(arg0 + 3*sys.PtrSize))
  0x43f5e9		4883c318		ADDQ $0x18, BX		
				mv = *(**reflectMethodValue)(unsafe.Pointer(arg0))
  0x43f5ed		488b02			MOVQ 0(DX), AX		
				retValid = *(*bool)(unsafe.Pointer(arg0 + 3*sys.PtrSize))
  0x43f5f0		0fb60b			MOVZX 0(BX), CX		
  0x43f5f3		ebb9			JMP 0x43f5ae		
		switch funcname(f) {
  0x43f5f5		4889442420		MOVQ AX, 0x20(SP)	
  0x43f5fa		48894c2430		MOVQ CX, 0x30(SP)	
		case "reflect.makeFuncStub", "reflect.methodValueCall":
  0x43f5ff		48890c24		MOVQ CX, 0(SP)			
  0x43f603		488d151b110300		LEAQ 0x3111b(IP), DX		
  0x43f60a		4889542408		MOVQ DX, 0x8(SP)		
  0x43f60f		4889442410		MOVQ AX, 0x10(SP)		
  0x43f614		e8072cfcff		CALL runtime.memequal(SB)	
  0x43f619		807c241800		CMPB $0x0, 0x18(SP)		
  0x43f61e		7582			JNE 0x43f5a2			
  0x43f620		488b442420		MOVQ 0x20(SP), AX		
  0x43f625		488b4c2430		MOVQ 0x30(SP), CX		
  0x43f62a		e940ffffff		JMP 0x43f56f			
				print("runtime: confused by ", funcname(f), "\n")
  0x43f62f		48891424		MOVQ DX, 0(SP)			
  0x43f633		488b442458		MOVQ 0x58(SP), AX		
  0x43f638		4889442408		MOVQ AX, 0x8(SP)		
  0x43f63d		e8febbffff		CALL runtime.funcname(SB)	
  0x43f642		488b442410		MOVQ 0x10(SP), AX		
  0x43f647		4889442430		MOVQ AX, 0x30(SP)		
  0x43f64c		488b4c2418		MOVQ 0x18(SP), CX		
  0x43f651		48894c2420		MOVQ CX, 0x20(SP)		
  0x43f656		e86548feff		CALL runtime.printlock(SB)	
  0x43f65b		488d0520120300		LEAQ 0x31220(IP), AX		
  0x43f662		48890424		MOVQ AX, 0(SP)			
  0x43f666		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x43f66f		e87c51feff		CALL runtime.printstring(SB)	
  0x43f674		488b442430		MOVQ 0x30(SP), AX		
  0x43f679		48890424		MOVQ AX, 0(SP)			
  0x43f67d		488b442420		MOVQ 0x20(SP), AX		
  0x43f682		4889442408		MOVQ AX, 0x8(SP)		
  0x43f687		e86451feff		CALL runtime.printstring(SB)	
  0x43f68c		e8bf4afeff		CALL runtime.printnl(SB)	
  0x43f691		e8aa48feff		CALL runtime.printunlock(SB)	
				throw("reflect mismatch")
  0x43f696		488d05da090300		LEAQ 0x309da(IP), AX	
  0x43f69d		48890424		MOVQ AX, 0(SP)		
  0x43f6a1		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x43f6aa		e8d13dfeff		CALL runtime.throw(SB)	
  0x43f6af		0f0b			UD2			
func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector) {
  0x43f6b1		e8ca810000		CALL runtime.morestack_noctxt(SB)	
  0x43f6b6		e935feffff		JMP runtime.getArgInfo(SB)		

TEXT runtime.tracebackCgoContext(SB) /usr/local/go/src/runtime/traceback.go
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43f6c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f6c9		488d842400feffff	LEAQ 0xfffffe00(SP), AX	
  0x43f6d1		483b4110		CMPQ 0x10(CX), AX	
  0x43f6d5		0f863b020000		JBE 0x43f916		
  0x43f6db		4881ec80020000		SUBQ $0x280, SP		
  0x43f6e2		4889ac2478020000	MOVQ BP, 0x278(SP)	
  0x43f6ea		488dac2478020000	LEAQ 0x278(SP), BP	
	var cgoPCs [32]uintptr
  0x43f6f2		488d7c2440		LEAQ 0x40(SP), DI	
  0x43f6f7		0f57c0			XORPS X0, X0		
  0x43f6fa		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43f6ff		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43f704		e8cba90000		CALL 0x44a0d4		
  0x43f709		488b6d00		MOVQ 0(BP), BP		
	cgoContextPCs(ctxt, cgoPCs[:])
  0x43f70d		488b842498020000	MOVQ 0x298(SP), AX		
  0x43f715		48890424		MOVQ AX, 0(SP)			
  0x43f719		488d442440		LEAQ 0x40(SP), AX		
  0x43f71e		4889442408		MOVQ AX, 0x8(SP)		
  0x43f723		48c744241020000000	MOVQ $0x20, 0x10(SP)		
  0x43f72c		48c744241820000000	MOVQ $0x20, 0x18(SP)		
  0x43f735		e8d61e0000		CALL runtime.cgoContextPCs(SB)	
	var arg cgoSymbolizerArg
  0x43f73a		48c784244002000000000000	MOVQ $0x0, 0x240(SP)	
  0x43f746		0f57c9				XORPS X1, X1		
  0x43f749		0f118c2448020000		MOVUPS X1, 0x248(SP)	
  0x43f751		0f118c2458020000		MOVUPS X1, 0x258(SP)	
  0x43f759		0f118c2468020000		MOVUPS X1, 0x268(SP)	
	for _, pc := range cgoPCs {
  0x43f761		488dbc2440010000	LEAQ 0x140(SP), DI	
  0x43f769		488d742440		LEAQ 0x40(SP), SI	
  0x43f76e		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43f773		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43f778		e853ac0000		CALL 0x44a3d0		
  0x43f77d		488b6d00		MOVQ 0(BP), BP		
  0x43f781		0fb6842490020000	MOVZX 0x290(SP), AX	
  0x43f789		488b8c2488020000	MOVQ 0x288(SP), CX	
  0x43f791		488b9424a8020000	MOVQ 0x2a8(SP), DX	
  0x43f799		488b9c24a0020000	MOVQ 0x2a0(SP), BX	
  0x43f7a1		31f6			XORL SI, SI		
  0x43f7a3		31ff			XORL DI, DI		
  0x43f7a5		eb06			JMP 0x43f7ad		
  0x43f7a7		48ffc6			INCQ SI			
		n++
  0x43f7aa		48ffc3			INCQ BX			
	return n
  0x43f7ad		48899c24a0020000	MOVQ BX, 0x2a0(SP)	
	for _, pc := range cgoPCs {
  0x43f7b5		4883fe20		CMPQ $0x20, SI			
  0x43f7b9		0f8d0c010000		JGE 0x43f8cb			
  0x43f7bf		4c8b84f440010000	MOVQ 0x140(SP)(SI*8), R8	
		if pc == 0 || n >= max {
  0x43f7c7		4d85c0			TESTQ R8, R8		
  0x43f7ca		0f84fb000000		JE 0x43f8cb		
  0x43f7d0		4839d3			CMPQ DX, BX		
  0x43f7d3		0f8df2000000		JGE 0x43f8cb		
		if pcbuf != nil {
  0x43f7d9		4885c9			TESTQ CX, CX		
  0x43f7dc		7411			JE 0x43f7ef		
			(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43f7de		4881fb00001000		CMPQ $0x100000, BX	
  0x43f7e5		0f8324010000		JAE 0x43f90f		
  0x43f7eb		4c8904d9		MOVQ R8, 0(CX)(BX*8)	
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43f7ef		84c0			TESTL AL, AL		
		if printing {
  0x43f7f1		74b4			JE 0x43f7a7		
	for _, pc := range cgoPCs {
  0x43f7f3		4889742438		MOVQ SI, 0x38(SP)	
	if anySymbolized {
  0x43f7f8		40887c2427		MOVB DI, 0x27(SP)	
			if cgoSymbolizer == nil {
  0x43f7fd		4c8b0d34210800		MOVQ runtime.cgoSymbolizer(SB), R9	
  0x43f804		4c894c2430		MOVQ R9, 0x30(SP)			
  0x43f809		4983f900		CMPQ $0x0, R9				
  0x43f80d		746e			JE 0x43f87d				
				c := printOneCgoTraceback(pc, max-n, &arg)
  0x43f80f		4c890424		MOVQ R8, 0(SP)				
  0x43f813		4829da			SUBQ BX, DX				
  0x43f816		4889542408		MOVQ DX, 0x8(SP)			
  0x43f81b		488d8c2440020000	LEAQ 0x240(SP), CX			
  0x43f823		48894c2410		MOVQ CX, 0x10(SP)			
  0x43f828		e8231b0000		CALL runtime.printOneCgoTraceback(SB)	
  0x43f82d		488b442418		MOVQ 0x18(SP), AX			
				n += c - 1 // +1 a few lines down
  0x43f832		488b8c24a0020000	MOVQ 0x2a0(SP), CX	
  0x43f83a		488d0408		LEAQ 0(AX)(CX*1), AX	
  0x43f83e		488d40ff		LEAQ -0x1(AX), AX	
			if cgoSymbolizer == nil {
  0x43f842		488b4c2430		MOVQ 0x30(SP), CX	
  0x43f847		4883f900		CMPQ $0x0, CX		
  0x43f84b		400f95c7		SETNE DI		
	if anySymbolized {
  0x43f84f		440fb6442427		MOVZX 0x27(SP), R8	
  0x43f855		4409c7			ORL R8, DI		
		if pcbuf != nil {
  0x43f858		488b8c2488020000	MOVQ 0x288(SP), CX	
		if pc == 0 || n >= max {
  0x43f860		488b9424a8020000	MOVQ 0x2a8(SP), DX	
	for _, pc := range cgoPCs {
  0x43f868		488b742438		MOVQ 0x38(SP), SI	
		n++
  0x43f86d		4889c3			MOVQ AX, BX		
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43f870		0fb6842490020000	MOVZX 0x290(SP), AX	
		n++
  0x43f878		e92affffff		JMP 0x43f7a7		
	for _, pc := range cgoPCs {
  0x43f87d		4c89442428		MOVQ R8, 0x28(SP)	
				print("non-Go function at pc=", hex(pc), "\n")
  0x43f882		e83946feff		CALL runtime.printlock(SB)	
  0x43f887		488d058f110300		LEAQ 0x3118f(IP), AX		
  0x43f88e		48890424		MOVQ AX, 0(SP)			
  0x43f892		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x43f89b		e8504ffeff		CALL runtime.printstring(SB)	
  0x43f8a0		488b442428		MOVQ 0x28(SP), AX		
  0x43f8a5		48890424		MOVQ AX, 0(SP)			
  0x43f8a9		e8024efeff		CALL runtime.printhex(SB)	
  0x43f8ae		e89d48feff		CALL runtime.printnl(SB)	
  0x43f8b3		e88846feff		CALL runtime.printunlock(SB)	
			if cgoSymbolizer == nil {
  0x43f8b8		488b442430		MOVQ 0x30(SP), AX	
  0x43f8bd		4883f800		CMPQ $0x0, AX		
		n++
  0x43f8c1		488b8424a0020000	MOVQ 0x2a0(SP), AX	
				print("non-Go function at pc=", hex(pc), "\n")
  0x43f8c9		eb80			JMP 0x43f84b		
	if anySymbolized {
  0x43f8cb		4084ff			TESTL DI, DI		
  0x43f8ce		7518			JNE 0x43f8e8		
	return n
  0x43f8d0		48899c24b0020000	MOVQ BX, 0x2b0(SP)	
  0x43f8d8		488bac2478020000	MOVQ 0x278(SP), BP	
  0x43f8e0		4881c480020000		ADDQ $0x280, SP		
  0x43f8e7		c3			RET			
		arg.pc = 0
  0x43f8e8		48c784244002000000000000	MOVQ $0x0, 0x240(SP)	
		callCgoSymbolizer(&arg)
  0x43f8f4		488d842440020000	LEAQ 0x240(SP), AX			
  0x43f8fc		48890424		MOVQ AX, 0(SP)				
  0x43f900		e88b1c0000		CALL runtime.callCgoSymbolizer(SB)	
	return n
  0x43f905		488b9c24a0020000	MOVQ 0x2a0(SP), BX	
		callCgoSymbolizer(&arg)
  0x43f90d		ebc1			JMP 0x43f8d0		
			(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = pc
  0x43f90f		e80c26feff		CALL runtime.panicindex(SB)	
  0x43f914		0f0b			UD2				
func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int {
  0x43f916		e8657f0000		CALL runtime.morestack_noctxt(SB)	
  0x43f91b		e9a0fdffff		JMP runtime.tracebackCgoContext(SB)	

TEXT runtime.printcreatedby(SB) /usr/local/go/src/runtime/traceback.go
func printcreatedby(gp *g) {
  0x43f920		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f929		483b6110		CMPQ 0x10(CX), SP	
  0x43f92d		0f86b0000000		JBE 0x43f9e3		
  0x43f933		4883ec48		SUBQ $0x48, SP		
  0x43f937		48896c2440		MOVQ BP, 0x40(SP)	
  0x43f93c		488d6c2440		LEAQ 0x40(SP), BP	
	pc := gp.gopc
  0x43f941		488b442450		MOVQ 0x50(SP), AX	
  0x43f946		488b8818010000		MOVQ 0x118(AX), CX	
  0x43f94d		48894c2428		MOVQ CX, 0x28(SP)	
	f := findfunc(pc)
  0x43f952		48890c24		MOVQ CX, 0(SP)			
  0x43f956		e8a5b1ffff		CALL runtime.findfunc(SB)	
  0x43f95b		488b442410		MOVQ 0x10(SP), AX		
  0x43f960		488b4c2408		MOVQ 0x8(SP), CX		
	if f.valid() && showframe(f, gp, false, funcID_normal, funcID_normal) && gp.goid != 1 {
  0x43f965		90			NOPL			
	return f._func != nil
  0x43f966		4885c9			TESTQ CX, CX		
	if f.valid() && showframe(f, gp, false, funcID_normal, funcID_normal) && gp.goid != 1 {
  0x43f969		7539			JNE 0x43f9a4		
  0x43f96b		31d2			XORL DX, DX		
  0x43f96d		84d2			TESTL DL, DL		
  0x43f96f		740f			JE 0x43f980		
  0x43f971		488b542450		MOVQ 0x50(SP), DX	
  0x43f976		4883ba9800000001	CMPQ $0x1, 0x98(DX)	
  0x43f97e		750a			JNE 0x43f98a		
  0x43f980		488b6c2440		MOVQ 0x40(SP), BP	
  0x43f985		4883c448		ADDQ $0x48, SP		
  0x43f989		c3			RET			
		printcreatedby1(f, pc)
  0x43f98a		48890c24		MOVQ CX, 0(SP)				
  0x43f98e		4889442408		MOVQ AX, 0x8(SP)			
  0x43f993		488b442428		MOVQ 0x28(SP), AX			
  0x43f998		4889442410		MOVQ AX, 0x10(SP)			
  0x43f99d		e84e000000		CALL runtime.printcreatedby1(SB)	
  0x43f9a2		ebdc			JMP 0x43f980				
	f := findfunc(pc)
  0x43f9a4		4889442438		MOVQ AX, 0x38(SP)	
  0x43f9a9		48894c2430		MOVQ CX, 0x30(SP)	
	if f.valid() && showframe(f, gp, false, funcID_normal, funcID_normal) && gp.goid != 1 {
  0x43f9ae		48890c24		MOVQ CX, 0(SP)			
  0x43f9b2		4889442408		MOVQ AX, 0x8(SP)		
  0x43f9b7		488b542450		MOVQ 0x50(SP), DX		
  0x43f9bc		4889542410		MOVQ DX, 0x10(SP)		
  0x43f9c1		66c74424180000		MOVW $0x0, 0x18(SP)		
  0x43f9c8		c644241a00		MOVB $0x0, 0x1a(SP)		
  0x43f9cd		e8ee0c0000		CALL runtime.showframe(SB)	
  0x43f9d2		0fb6542420		MOVZX 0x20(SP), DX		
		printcreatedby1(f, pc)
  0x43f9d7		488b442438		MOVQ 0x38(SP), AX	
  0x43f9dc		488b4c2430		MOVQ 0x30(SP), CX	
	if f.valid() && showframe(f, gp, false, funcID_normal, funcID_normal) && gp.goid != 1 {
  0x43f9e1		eb8a			JMP 0x43f96d		
func printcreatedby(gp *g) {
  0x43f9e3		e8987e0000		CALL runtime.morestack_noctxt(SB)	
  0x43f9e8		e933ffffff		JMP runtime.printcreatedby(SB)		

TEXT runtime.printcreatedby1(SB) /usr/local/go/src/runtime/traceback.go
func printcreatedby1(f funcInfo, pc uintptr) {
  0x43f9f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43f9f9		483b6110		CMPQ 0x10(CX), SP	
  0x43f9fd		0f86a1010000		JBE 0x43fba4		
  0x43fa03		4883ec68		SUBQ $0x68, SP		
  0x43fa07		48896c2460		MOVQ BP, 0x60(SP)	
  0x43fa0c		488d6c2460		LEAQ 0x60(SP), BP	
	print("created by ", funcname(f), "\n")
  0x43fa11		488b442470		MOVQ 0x70(SP), AX		
  0x43fa16		48890424		MOVQ AX, 0(SP)			
  0x43fa1a		488b4c2478		MOVQ 0x78(SP), CX		
  0x43fa1f		48894c2408		MOVQ CX, 0x8(SP)		
  0x43fa24		e817b8ffff		CALL runtime.funcname(SB)	
  0x43fa29		488b442418		MOVQ 0x18(SP), AX		
  0x43fa2e		4889442448		MOVQ AX, 0x48(SP)		
  0x43fa33		488b4c2410		MOVQ 0x10(SP), CX		
  0x43fa38		48894c2458		MOVQ CX, 0x58(SP)		
  0x43fa3d		e87e44feff		CALL runtime.printlock(SB)	
  0x43fa42		488d05b4fe0200		LEAQ 0x2feb4(IP), AX		
  0x43fa49		48890424		MOVQ AX, 0(SP)			
  0x43fa4d		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x43fa56		e8954dfeff		CALL runtime.printstring(SB)	
  0x43fa5b		488b442458		MOVQ 0x58(SP), AX		
  0x43fa60		48890424		MOVQ AX, 0(SP)			
  0x43fa64		488b442448		MOVQ 0x48(SP), AX		
  0x43fa69		4889442408		MOVQ AX, 0x8(SP)		
  0x43fa6e		e87d4dfeff		CALL runtime.printstring(SB)	
  0x43fa73		e8d846feff		CALL runtime.printnl(SB)	
  0x43fa78		e8c344feff		CALL runtime.printunlock(SB)	
	if pc > f.entry {
  0x43fa7d		488b442470		MOVQ 0x70(SP), AX	
  0x43fa82		488b08			MOVQ 0(AX), CX		
  0x43fa85		488b942480000000	MOVQ 0x80(SP), DX	
  0x43fa8d		4839d1			CMPQ DX, CX		
	file, line := funcline(f, tracepc)
  0x43fa90		48890424		MOVQ AX, 0(SP)		
  0x43fa94		488b5c2478		MOVQ 0x78(SP), BX	
  0x43fa99		48895c2408		MOVQ BX, 0x8(SP)	
		tracepc -= sys.PCQuantum
  0x43fa9e		488d5aff		LEAQ -0x1(DX), BX	
	if pc > f.entry {
  0x43faa2		4839d1			CMPQ DX, CX		
	file, line := funcline(f, tracepc)
  0x43faa5		480f42d3		CMOVB BX, DX			
  0x43faa9		4889542410		MOVQ DX, 0x10(SP)		
  0x43faae		e8bdbaffff		CALL runtime.funcline(SB)	
  0x43fab3		488b442420		MOVQ 0x20(SP), AX		
  0x43fab8		4889442430		MOVQ AX, 0x30(SP)		
  0x43fabd		488b4c2418		MOVQ 0x18(SP), CX		
  0x43fac2		48894c2450		MOVQ CX, 0x50(SP)		
  0x43fac7		4863542428		MOVSXD 0x28(SP), DX		
  0x43facc		4889542440		MOVQ DX, 0x40(SP)		
	print("\t", file, ":", line)
  0x43fad1		e8ea43feff		CALL runtime.printlock(SB)	
  0x43fad6		488d05b1f50200		LEAQ 0x2f5b1(IP), AX		
  0x43fadd		48890424		MOVQ AX, 0(SP)			
  0x43fae1		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43faea		e8014dfeff		CALL runtime.printstring(SB)	
  0x43faef		488b442450		MOVQ 0x50(SP), AX		
  0x43faf4		48890424		MOVQ AX, 0(SP)			
  0x43faf8		488b442430		MOVQ 0x30(SP), AX		
  0x43fafd		4889442408		MOVQ AX, 0x8(SP)		
  0x43fb02		e8e94cfeff		CALL runtime.printstring(SB)	
  0x43fb07		488d057af50200		LEAQ 0x2f57a(IP), AX		
  0x43fb0e		48890424		MOVQ AX, 0(SP)			
  0x43fb12		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x43fb1b		e8d04cfeff		CALL runtime.printstring(SB)	
  0x43fb20		488b442440		MOVQ 0x40(SP), AX		
  0x43fb25		48890424		MOVQ AX, 0(SP)			
  0x43fb29		e8124bfeff		CALL runtime.printint(SB)	
  0x43fb2e		e80d44feff		CALL runtime.printunlock(SB)	
	if pc > f.entry {
  0x43fb33		488b442470		MOVQ 0x70(SP), AX	
  0x43fb38		488b00			MOVQ 0(AX), AX		
  0x43fb3b		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x43fb43		4839c1			CMPQ AX, CX		
	if pc > f.entry {
  0x43fb46		7719			JA 0x43fb61		
	print("\n")
  0x43fb48		e87343feff		CALL runtime.printlock(SB)	
  0x43fb4d		e8fe45feff		CALL runtime.printnl(SB)	
  0x43fb52		e8e943feff		CALL runtime.printunlock(SB)	
}
  0x43fb57		488b6c2460		MOVQ 0x60(SP), BP	
  0x43fb5c		4883c468		ADDQ $0x68, SP		
  0x43fb60		c3			RET			
	if pc > f.entry {
  0x43fb61		4889442438		MOVQ AX, 0x38(SP)	
		print(" +", hex(pc-f.entry))
  0x43fb66		e85543feff		CALL runtime.printlock(SB)	
  0x43fb6b		488d051ef50200		LEAQ 0x2f51e(IP), AX		
  0x43fb72		48890424		MOVQ AX, 0(SP)			
  0x43fb76		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x43fb7f		e86c4cfeff		CALL runtime.printstring(SB)	
  0x43fb84		488b842480000000	MOVQ 0x80(SP), AX		
  0x43fb8c		488b4c2438		MOVQ 0x38(SP), CX		
  0x43fb91		4829c8			SUBQ CX, AX			
  0x43fb94		48890424		MOVQ AX, 0(SP)			
  0x43fb98		e8134bfeff		CALL runtime.printhex(SB)	
  0x43fb9d		e89e43feff		CALL runtime.printunlock(SB)	
  0x43fba2		eba4			JMP 0x43fb48			
func printcreatedby1(f funcInfo, pc uintptr) {
  0x43fba4		e8d77c0000		CALL runtime.morestack_noctxt(SB)	
  0x43fba9		e942feffff		JMP runtime.printcreatedby1(SB)		

TEXT runtime.traceback(SB) /usr/local/go/src/runtime/traceback.go
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43fbb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43fbb9		483b6110		CMPQ 0x10(CX), SP	
  0x43fbbd		764d			JBE 0x43fc0c		
  0x43fbbf		4883ec30		SUBQ $0x30, SP		
  0x43fbc3		48896c2428		MOVQ BP, 0x28(SP)	
  0x43fbc8		488d6c2428		LEAQ 0x28(SP), BP	
	traceback1(pc, sp, lr, gp, 0)
  0x43fbcd		488b442438		MOVQ 0x38(SP), AX		
  0x43fbd2		48890424		MOVQ AX, 0(SP)			
  0x43fbd6		488b442440		MOVQ 0x40(SP), AX		
  0x43fbdb		4889442408		MOVQ AX, 0x8(SP)		
  0x43fbe0		488b442448		MOVQ 0x48(SP), AX		
  0x43fbe5		4889442410		MOVQ AX, 0x10(SP)		
  0x43fbea		488b442450		MOVQ 0x50(SP), AX		
  0x43fbef		4889442418		MOVQ AX, 0x18(SP)		
  0x43fbf4		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43fbfd		e8de000000		CALL runtime.traceback1(SB)	
}
  0x43fc02		488b6c2428		MOVQ 0x28(SP), BP	
  0x43fc07		4883c430		ADDQ $0x30, SP		
  0x43fc0b		c3			RET			
func traceback(pc, sp, lr uintptr, gp *g) {
  0x43fc0c		e86f7c0000		CALL runtime.morestack_noctxt(SB)	
  0x43fc11		eb9d			JMP runtime.traceback(SB)		

TEXT runtime.tracebacktrap(SB) /usr/local/go/src/runtime/traceback.go
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43fc20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43fc29		483b6110		CMPQ 0x10(CX), SP	
  0x43fc2d		0f869b000000		JBE 0x43fcce		
  0x43fc33		4883ec30		SUBQ $0x30, SP		
  0x43fc37		48896c2428		MOVQ BP, 0x28(SP)	
  0x43fc3c		488d6c2428		LEAQ 0x28(SP), BP	
	if gp.m.libcallsp != 0 {
  0x43fc41		488b442450		MOVQ 0x50(SP), AX	
  0x43fc46		488b4830		MOVQ 0x30(AX), CX	
  0x43fc4a		488b91f0020000		MOVQ 0x2f0(CX), DX	
  0x43fc51		4885d2			TESTQ DX, DX		
  0x43fc54		743e			JE 0x43fc94		
		traceback1(gp.m.libcallpc, gp.m.libcallsp, 0, gp.m.libcallg.ptr(), 0)
  0x43fc56		488b81e8020000		MOVQ 0x2e8(CX), AX		
  0x43fc5d		488b89f8020000		MOVQ 0x2f8(CX), CX		
  0x43fc64		90			NOPL				
  0x43fc65		48890424		MOVQ AX, 0(SP)			
  0x43fc69		4889542408		MOVQ DX, 0x8(SP)		
  0x43fc6e		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x43fc77		48894c2418		MOVQ CX, 0x18(SP)		
  0x43fc7c		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x43fc85		e856000000		CALL runtime.traceback1(SB)	
		return
  0x43fc8a		488b6c2428		MOVQ 0x28(SP), BP	
  0x43fc8f		4883c430		ADDQ $0x30, SP		
  0x43fc93		c3			RET			
	traceback1(pc, sp, lr, gp, _TraceTrap)
  0x43fc94		488b4c2438		MOVQ 0x38(SP), CX		
  0x43fc99		48890c24		MOVQ CX, 0(SP)			
  0x43fc9d		488b4c2440		MOVQ 0x40(SP), CX		
  0x43fca2		48894c2408		MOVQ CX, 0x8(SP)		
  0x43fca7		488b4c2448		MOVQ 0x48(SP), CX		
  0x43fcac		48894c2410		MOVQ CX, 0x10(SP)		
  0x43fcb1		4889442418		MOVQ AX, 0x18(SP)		
  0x43fcb6		48c744242002000000	MOVQ $0x2, 0x20(SP)		
  0x43fcbf		e81c000000		CALL runtime.traceback1(SB)	
}
  0x43fcc4		488b6c2428		MOVQ 0x28(SP), BP	
  0x43fcc9		4883c430		ADDQ $0x30, SP		
  0x43fccd		c3			RET			
func tracebacktrap(pc, sp, lr uintptr, gp *g) {
  0x43fcce		e8ad7b0000		CALL runtime.morestack_noctxt(SB)	
  0x43fcd3		e948ffffff		JMP runtime.tracebacktrap(SB)		

TEXT runtime.traceback1(SB) /usr/local/go/src/runtime/traceback.go
func traceback1(pc, sp, lr uintptr, gp *g, flags uint) {
  0x43fce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x43fce9		488d8424e0feffff	LEAQ 0xfffffee0(SP), AX	
  0x43fcf1		483b4110		CMPQ 0x10(CX), AX	
  0x43fcf5		0f86f9020000		JBE 0x43fff4		
  0x43fcfb		4881eca0010000		SUBQ $0x1a0, SP		
  0x43fd02		4889ac2498010000	MOVQ BP, 0x198(SP)	
  0x43fd0a		488dac2498010000	LEAQ 0x198(SP), BP	
	if iscgo && gp.m != nil && gp.m.ncgo > 0 && gp.syscallsp != 0 && gp.m.cgoCallers != nil && gp.m.cgoCallers[0] != 0 {
  0x43fd12		803d95cf090000		CMPB $0x0, runtime.iscgo(SB)	
  0x43fd19		0f84c8020000		JE 0x43ffe7			
  0x43fd1f		488b8424c0010000	MOVQ 0x1c0(SP), AX		
  0x43fd27		488b4830		MOVQ 0x30(AX), CX		
  0x43fd2b		4885c9			TESTQ CX, CX			
  0x43fd2e		7426			JE 0x43fd56			
  0x43fd30		83b93801000000		CMPL $0x0, 0x138(CX)		
  0x43fd37		7e1d			JLE 0x43fd56			
  0x43fd39		4883787000		CMPQ $0x0, 0x70(AX)		
  0x43fd3e		7416			JE 0x43fd56			
  0x43fd40		488b9140010000		MOVQ 0x140(CX), DX		
  0x43fd47		4885d2			TESTQ DX, DX			
  0x43fd4a		740a			JE 0x43fd56			
  0x43fd4c		48833a00		CMPQ $0x0, 0(DX)		
  0x43fd50		0f8528020000		JNE 0x43ff7e			
	if readgstatus(gp)&^_Gscan == _Gsyscall {
  0x43fd56		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x43fd57		8b8890000000		MOVL 0x90(AX), CX	
	if readgstatus(gp)&^_Gscan == _Gsyscall {
  0x43fd5d		0fbaf10c		BTRL $0xc, CX		
  0x43fd61		83f903			CMPL $0x3, CX		
  0x43fd64		0f85f7010000		JNE 0x43ff61		
		pc = gp.syscallpc
  0x43fd6a		488b4878		MOVQ 0x78(AX), CX	
		sp = gp.syscallsp
  0x43fd6e		488b5070		MOVQ 0x70(AX), DX	
		flags &^= _TraceTrap
  0x43fd72		488b9c24c8010000	MOVQ 0x1c8(SP), BX	
  0x43fd7a		4883e3fd		ANDQ $-0x3, BX		
	n = gentraceback(pc, sp, lr, gp, 0, nil, _TracebackMaxFrames, nil, nil, flags)
  0x43fd7e		48898c24a8010000	MOVQ CX, 0x1a8(SP)		
  0x43fd86		48899424b0010000	MOVQ DX, 0x1b0(SP)		
  0x43fd8e		48899c24c8010000	MOVQ BX, 0x1c8(SP)		
  0x43fd96		48890c24		MOVQ CX, 0(SP)			
  0x43fd9a		4889542408		MOVQ DX, 0x8(SP)		
  0x43fd9f		488bb424b8010000	MOVQ 0x1b8(SP), SI		
  0x43fda7		4889742410		MOVQ SI, 0x10(SP)		
  0x43fdac		4889442418		MOVQ AX, 0x18(SP)		
  0x43fdb1		0f57c0			XORPS X0, X0			
  0x43fdb4		0f11442420		MOVUPS X0, 0x20(SP)		
  0x43fdb9		48c744243064000000	MOVQ $0x64, 0x30(SP)		
  0x43fdc2		0f11442438		MOVUPS X0, 0x38(SP)		
  0x43fdc7		48895c2448		MOVQ BX, 0x48(SP)		
  0x43fdcc		e8efd9ffff		CALL runtime.gentraceback(SB)	
  0x43fdd1		488b442450		MOVQ 0x50(SP), AX		
	if n == 0 && (flags&_TraceRuntimeFrames) == 0 {
  0x43fdd6		4885c0			TESTQ AX, AX		
  0x43fdd9		7512			JNE 0x43fded		
  0x43fddb		488b8c24c8010000	MOVQ 0x1c8(SP), CX	
  0x43fde3		0fbae100		BTL $0x0, CX		
  0x43fde7		0f8313010000		JAE 0x43ff00		
	if n == _TracebackMaxFrames {
  0x43fded		4883f864		CMPQ $0x64, AX		
  0x43fdf1		0f84e1000000		JE 0x43fed8		
	printcreatedby(gp)
  0x43fdf7		488b8424c0010000	MOVQ 0x1c0(SP), AX		
  0x43fdff		48890424		MOVQ AX, 0(SP)			
  0x43fe03		e818fbffff		CALL runtime.printcreatedby(SB)	
	if gp.ancestors == nil {
  0x43fe08		488b8424c0010000	MOVQ 0x1c0(SP), AX	
  0x43fe10		488b8020010000		MOVQ 0x120(AX), AX	
  0x43fe17		4885c0			TESTQ AX, AX		
  0x43fe1a		0f84a8000000		JE 0x43fec8		
	for _, ancestor := range *gp.ancestors {
  0x43fe20		488b08			MOVQ 0(AX), CX		
  0x43fe23		488b4008		MOVQ 0x8(AX), AX	
  0x43fe27		4885c0			TESTQ AX, AX		
  0x43fe2a		0f8e88000000		JLE 0x43feb8		
  0x43fe30		4889442460		MOVQ AX, 0x60(SP)	
  0x43fe35		31d2			XORL DX, DX		
  0x43fe37		eb12			JMP 0x43fe4b		
  0x43fe39		488b9c2468010000	MOVQ 0x168(SP), BX	
  0x43fe41		4883c328		ADDQ $0x28, BX		
  0x43fe45		4889d9			MOVQ BX, CX		
  0x43fe48		4889c2			MOVQ AX, DX		
  0x43fe4b		48898c2468010000	MOVQ CX, 0x168(SP)	
  0x43fe53		4889542458		MOVQ DX, 0x58(SP)	
  0x43fe58		488b01			MOVQ 0(CX), AX		
  0x43fe5b		4889842470010000	MOVQ AX, 0x170(SP)	
  0x43fe63		0f104108		MOVUPS 0x8(CX), X0	
  0x43fe67		0f11842478010000	MOVUPS X0, 0x178(SP)	
  0x43fe6f		0f104118		MOVUPS 0x18(CX), X0	
  0x43fe73		0f11842488010000	MOVUPS X0, 0x188(SP)	
		printAncestorTraceback(ancestor)
  0x43fe7b		488b842470010000	MOVQ 0x170(SP), AX			
  0x43fe83		48890424		MOVQ AX, 0(SP)				
  0x43fe87		0f10842478010000	MOVUPS 0x178(SP), X0			
  0x43fe8f		0f11442408		MOVUPS X0, 0x8(SP)			
  0x43fe94		0f10842488010000	MOVUPS 0x188(SP), X0			
  0x43fe9c		0f11442418		MOVUPS X0, 0x18(SP)			
  0x43fea1		e85a010000		CALL runtime.printAncestorTraceback(SB)	
	for _, ancestor := range *gp.ancestors {
  0x43fea6		488b442458		MOVQ 0x58(SP), AX	
  0x43feab		48ffc0			INCQ AX			
  0x43feae		488b4c2460		MOVQ 0x60(SP), CX	
  0x43feb3		4839c8			CMPQ CX, AX		
  0x43feb6		7c81			JL 0x43fe39		
  0x43feb8		488bac2498010000	MOVQ 0x198(SP), BP	
  0x43fec0		4881c4a0010000		ADDQ $0x1a0, SP		
  0x43fec7		c3			RET			
		return
  0x43fec8		488bac2498010000	MOVQ 0x198(SP), BP	
  0x43fed0		4881c4a0010000		ADDQ $0x1a0, SP		
  0x43fed7		c3			RET			
		print("...additional frames elided...\n")
  0x43fed8		e8e33ffeff		CALL runtime.printlock(SB)	
  0x43fedd		488d05db1d0300		LEAQ 0x31ddb(IP), AX		
  0x43fee4		48890424		MOVQ AX, 0(SP)			
  0x43fee8		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x43fef1		e8fa48feff		CALL runtime.printstring(SB)	
  0x43fef6		e84540feff		CALL runtime.printunlock(SB)	
  0x43fefb		e9f7feffff		JMP 0x43fdf7			
		n = gentraceback(pc, sp, lr, gp, 0, nil, _TracebackMaxFrames, nil, nil, flags|_TraceRuntimeFrames)
  0x43ff00		488b8424a8010000	MOVQ 0x1a8(SP), AX		
  0x43ff08		48890424		MOVQ AX, 0(SP)			
  0x43ff0c		488b8424b0010000	MOVQ 0x1b0(SP), AX		
  0x43ff14		4889442408		MOVQ AX, 0x8(SP)		
  0x43ff19		488b8424b8010000	MOVQ 0x1b8(SP), AX		
  0x43ff21		4889442410		MOVQ AX, 0x10(SP)		
  0x43ff26		488b8424c0010000	MOVQ 0x1c0(SP), AX		
  0x43ff2e		4889442418		MOVQ AX, 0x18(SP)		
  0x43ff33		0f57c0			XORPS X0, X0			
  0x43ff36		0f11442420		MOVUPS X0, 0x20(SP)		
  0x43ff3b		48c744243064000000	MOVQ $0x64, 0x30(SP)		
  0x43ff44		0f11442438		MOVUPS X0, 0x38(SP)		
  0x43ff49		4883c901		ORQ $0x1, CX			
  0x43ff4d		48894c2448		MOVQ CX, 0x48(SP)		
  0x43ff52		e869d8ffff		CALL runtime.gentraceback(SB)	
  0x43ff57		488b442450		MOVQ 0x50(SP), AX		
  0x43ff5c		e98cfeffff		JMP 0x43fded			
	n = gentraceback(pc, sp, lr, gp, 0, nil, _TracebackMaxFrames, nil, nil, flags)
  0x43ff61		488b8c24a8010000	MOVQ 0x1a8(SP), CX	
  0x43ff69		488b9424b0010000	MOVQ 0x1b0(SP), DX	
  0x43ff71		488b9c24c8010000	MOVQ 0x1c8(SP), BX	
	if readgstatus(gp)&^_Gscan == _Gsyscall {
  0x43ff79		e900feffff		JMP 0x43fd7e		
		atomic.Store(&gp.m.cgoCallersUse, 1)
  0x43ff7e		ba01000000		MOVL $0x1, DX		
  0x43ff83		87913c010000		XCHGL DX, 0x13c(CX)	
		cgoCallers := *gp.m.cgoCallers
  0x43ff89		488b4830		MOVQ 0x30(AX), CX	
  0x43ff8d		488bb140010000		MOVQ 0x140(CX), SI	
  0x43ff94		8401			TESTB AL, 0(CX)		
  0x43ff96		488d7c2468		LEAQ 0x68(SP), DI	
  0x43ff9b		48896c24f0		MOVQ BP, -0x10(SP)	
  0x43ffa0		488d6c24f0		LEAQ -0x10(SP), BP	
  0x43ffa5		e826a40000		CALL 0x44a3d0		
  0x43ffaa		488b6d00		MOVQ 0(BP), BP		
		gp.m.cgoCallers[0] = 0
  0x43ffae		488b4830		MOVQ 0x30(AX), CX	
  0x43ffb2		488b8940010000		MOVQ 0x140(CX), CX	
  0x43ffb9		48c70100000000		MOVQ $0x0, 0(CX)	
		atomic.Store(&gp.m.cgoCallersUse, 0)
  0x43ffc0		488b4830		MOVQ 0x30(AX), CX	
  0x43ffc4		31d2			XORL DX, DX		
  0x43ffc6		87913c010000		XCHGL DX, 0x13c(CX)	
		printCgoTraceback(&cgoCallers)
  0x43ffcc		488d4c2468		LEAQ 0x68(SP), CX			
  0x43ffd1		48890c24		MOVQ CX, 0(SP)				
  0x43ffd5		e846120000		CALL runtime.printCgoTraceback(SB)	
	return atomic.Load(&gp.atomicstatus)
  0x43ffda		488b8424c0010000	MOVQ 0x1c0(SP), AX	
		printCgoTraceback(&cgoCallers)
  0x43ffe2		e96ffdffff		JMP 0x43fd56		
	return atomic.Load(&gp.atomicstatus)
  0x43ffe7		488b8424c0010000	MOVQ 0x1c0(SP), AX	
	if iscgo && gp.m != nil && gp.m.ncgo > 0 && gp.syscallsp != 0 && gp.m.cgoCallers != nil && gp.m.cgoCallers[0] != 0 {
  0x43ffef		e962fdffff		JMP 0x43fd56		
func traceback1(pc, sp, lr uintptr, gp *g, flags uint) {
  0x43fff4		e887780000		CALL runtime.morestack_noctxt(SB)	
  0x43fff9		e9e2fcffff		JMP runtime.traceback1(SB)		

TEXT runtime.printAncestorTraceback(SB) /usr/local/go/src/runtime/traceback.go
func printAncestorTraceback(ancestor ancestorInfo) {
  0x440000		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440009		483b6110		CMPQ 0x10(CX), SP	
  0x44000d		0f86d2010000		JBE 0x4401e5		
  0x440013		4883ec60		SUBQ $0x60, SP		
  0x440017		48896c2458		MOVQ BP, 0x58(SP)	
  0x44001c		488d6c2458		LEAQ 0x58(SP), BP	
	print("[originating from goroutine ", ancestor.goid, "]:\n")
  0x440021		488b842480000000	MOVQ 0x80(SP), AX		
  0x440029		4889442438		MOVQ AX, 0x38(SP)		
  0x44002e		e88d3efeff		CALL runtime.printlock(SB)	
  0x440033		488d05f0150300		LEAQ 0x315f0(IP), AX		
  0x44003a		48890424		MOVQ AX, 0(SP)			
  0x44003e		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x440047		e8a447feff		CALL runtime.printstring(SB)	
  0x44004c		488b442438		MOVQ 0x38(SP), AX		
  0x440051		48890424		MOVQ AX, 0(SP)			
  0x440055		e8e645feff		CALL runtime.printint(SB)	
  0x44005a		488d0573f00200		LEAQ 0x2f073(IP), AX		
  0x440061		48890424		MOVQ AX, 0(SP)			
  0x440065		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x44006e		e87d47feff		CALL runtime.printstring(SB)	
  0x440073		e8c83efeff		CALL runtime.printunlock(SB)	
	for fidx, pc := range ancestor.pcs {
  0x440078		488b442468		MOVQ 0x68(SP), AX	
  0x44007d		4889442450		MOVQ AX, 0x50(SP)	
  0x440082		488b4c2470		MOVQ 0x70(SP), CX	
  0x440087		48894c2430		MOVQ CX, 0x30(SP)	
  0x44008c		31d2			XORL DX, DX		
  0x44008e		eb13			JMP 0x4400a3		
  0x440090		488b5c2428		MOVQ 0x28(SP), BX	
  0x440095		488d5301		LEAQ 0x1(BX), DX	
  0x440099		488b442450		MOVQ 0x50(SP), AX	
  0x44009e		488b4c2430		MOVQ 0x30(SP), CX	
  0x4400a3		4839ca			CMPQ CX, DX		
  0x4400a6		7d7b			JGE 0x440123		
  0x4400a8		4889542428		MOVQ DX, 0x28(SP)	
  0x4400ad		488b0cd0		MOVQ 0(AX)(DX*8), CX	
  0x4400b1		48894c2420		MOVQ CX, 0x20(SP)	
		f := findfunc(pc) // f previously validated
  0x4400b6		48890c24		MOVQ CX, 0(SP)			
  0x4400ba		e841aaffff		CALL runtime.findfunc(SB)	
  0x4400bf		488b442410		MOVQ 0x10(SP), AX		
  0x4400c4		4889442448		MOVQ AX, 0x48(SP)		
  0x4400c9		488b4c2408		MOVQ 0x8(SP), CX		
  0x4400ce		48894c2440		MOVQ CX, 0x40(SP)		
		if showfuncinfo(f, fidx == 0, funcID_normal, funcID_normal) {
  0x4400d3		48890c24		MOVQ CX, 0(SP)			
  0x4400d7		4889442408		MOVQ AX, 0x8(SP)		
  0x4400dc		488b542428		MOVQ 0x28(SP), DX		
  0x4400e1		4885d2			TESTQ DX, DX			
  0x4400e4		0f94442410		SETE 0x10(SP)			
  0x4400e9		66c74424110000		MOVW $0x0, 0x11(SP)		
  0x4400f0		e89b060000		CALL runtime.showfuncinfo(SB)	
  0x4400f5		807c241800		CMPB $0x0, 0x18(SP)		
  0x4400fa		7494			JE 0x440090			
			printAncestorTracebackFuncInfo(f, pc)
  0x4400fc		488b442440		MOVQ 0x40(SP), AX				
  0x440101		48890424		MOVQ AX, 0(SP)					
  0x440105		488b442448		MOVQ 0x48(SP), AX				
  0x44010a		4889442408		MOVQ AX, 0x8(SP)				
  0x44010f		488b442420		MOVQ 0x20(SP), AX				
  0x440114		4889442410		MOVQ AX, 0x10(SP)				
  0x440119		e8d2000000		CALL runtime.printAncestorTracebackFuncInfo(SB)	
  0x44011e		e96dffffff		JMP 0x440090					
	if len(ancestor.pcs) == _TracebackMaxFrames {
  0x440123		48837c247064		CMPQ $0x64, 0x70(SP)	
  0x440129		0f848e000000		JE 0x4401bd		
	f := findfunc(ancestor.gopc)
  0x44012f		488b842488000000	MOVQ 0x88(SP), AX		
  0x440137		48890424		MOVQ AX, 0(SP)			
  0x44013b		e8c0a9ffff		CALL runtime.findfunc(SB)	
  0x440140		488b442410		MOVQ 0x10(SP), AX		
  0x440145		488b4c2408		MOVQ 0x8(SP), CX		
	if f.valid() && showfuncinfo(f, false, funcID_normal, funcID_normal) && ancestor.goid != 1 {
  0x44014a		90			NOPL			
	return f._func != nil
  0x44014b		4885c9			TESTQ CX, CX		
	if f.valid() && showfuncinfo(f, false, funcID_normal, funcID_normal) && ancestor.goid != 1 {
  0x44014e		7538			JNE 0x440188		
  0x440150		31d2			XORL DX, DX		
  0x440152		84d2			TESTL DL, DL		
  0x440154		740b			JE 0x440161		
  0x440156		4883bc248000000001	CMPQ $0x1, 0x80(SP)	
  0x44015f		750a			JNE 0x44016b		
  0x440161		488b6c2458		MOVQ 0x58(SP), BP	
  0x440166		4883c460		ADDQ $0x60, SP		
  0x44016a		c3			RET			
		printcreatedby1(f, ancestor.gopc)
  0x44016b		48890c24		MOVQ CX, 0(SP)				
  0x44016f		4889442408		MOVQ AX, 0x8(SP)			
  0x440174		488b842488000000	MOVQ 0x88(SP), AX			
  0x44017c		4889442410		MOVQ AX, 0x10(SP)			
  0x440181		e86af8ffff		CALL runtime.printcreatedby1(SB)	
  0x440186		ebd9			JMP 0x440161				
	f := findfunc(ancestor.gopc)
  0x440188		4889442448		MOVQ AX, 0x48(SP)	
  0x44018d		48894c2440		MOVQ CX, 0x40(SP)	
	if f.valid() && showfuncinfo(f, false, funcID_normal, funcID_normal) && ancestor.goid != 1 {
  0x440192		48890c24		MOVQ CX, 0(SP)			
  0x440196		4889442408		MOVQ AX, 0x8(SP)		
  0x44019b		66c74424100000		MOVW $0x0, 0x10(SP)		
  0x4401a2		c644241200		MOVB $0x0, 0x12(SP)		
  0x4401a7		e8e4050000		CALL runtime.showfuncinfo(SB)	
  0x4401ac		0fb6542418		MOVZX 0x18(SP), DX		
		printcreatedby1(f, ancestor.gopc)
  0x4401b1		488b442448		MOVQ 0x48(SP), AX	
  0x4401b6		488b4c2440		MOVQ 0x40(SP), CX	
	if f.valid() && showfuncinfo(f, false, funcID_normal, funcID_normal) && ancestor.goid != 1 {
  0x4401bb		eb95			JMP 0x440152		
		print("...additional frames elided...\n")
  0x4401bd		e8fe3cfeff		CALL runtime.printlock(SB)	
  0x4401c2		488d05f61a0300		LEAQ 0x31af6(IP), AX		
  0x4401c9		48890424		MOVQ AX, 0(SP)			
  0x4401cd		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x4401d6		e81546feff		CALL runtime.printstring(SB)	
  0x4401db		e8603dfeff		CALL runtime.printunlock(SB)	
  0x4401e0		e94affffff		JMP 0x44012f			
func printAncestorTraceback(ancestor ancestorInfo) {
  0x4401e5		e896760000		CALL runtime.morestack_noctxt(SB)	
  0x4401ea		e911feffff		JMP runtime.printAncestorTraceback(SB)	

TEXT runtime.printAncestorTracebackFuncInfo(SB) /usr/local/go/src/runtime/traceback.go
func printAncestorTracebackFuncInfo(f funcInfo, pc uintptr) {
  0x4401f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4401f9		483b6110		CMPQ 0x10(CX), SP	
  0x4401fd		0f861e030000		JBE 0x440521		
  0x440203		4883ec70		SUBQ $0x70, SP		
  0x440207		48896c2468		MOVQ BP, 0x68(SP)	
  0x44020c		488d6c2468		LEAQ 0x68(SP), BP	
	name := funcname(f)
  0x440211		488b442478		MOVQ 0x78(SP), AX		
  0x440216		48890424		MOVQ AX, 0(SP)			
  0x44021a		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x440222		48894c2408		MOVQ CX, 0x8(SP)		
  0x440227		e814b0ffff		CALL runtime.funcname(SB)	
  0x44022c		488b442418		MOVQ 0x18(SP), AX		
  0x440231		4889442430		MOVQ AX, 0x30(SP)		
  0x440236		488b4c2410		MOVQ 0x10(SP), CX		
  0x44023b		48894c2450		MOVQ CX, 0x50(SP)		
	if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x440240		488b542478		MOVQ 0x78(SP), DX		
  0x440245		48891424		MOVQ DX, 0(SP)			
  0x440249		488b9c2480000000	MOVQ 0x80(SP), BX		
  0x440251		48895c2408		MOVQ BX, 0x8(SP)		
  0x440256		c644241002		MOVB $0x2, 0x10(SP)		
  0x44025b		e8b0b5ffff		CALL runtime.funcdata(SB)	
  0x440260		488b442418		MOVQ 0x18(SP), AX		
  0x440265		4885c0			TESTQ AX, AX			
  0x440268		0f850b020000		JNE 0x440479			
	if name == "runtime.gopanic" {
  0x44026e		488b442450		MOVQ 0x50(SP), AX	
  0x440273		488b4c2430		MOVQ 0x30(SP), CX	
  0x440278		4889442450		MOVQ AX, 0x50(SP)	
  0x44027d		48894c2430		MOVQ CX, 0x30(SP)	
	file, line := funcline(f, pc)
  0x440282		488b542478		MOVQ 0x78(SP), DX		
  0x440287		48891424		MOVQ DX, 0(SP)			
  0x44028b		488b9c2480000000	MOVQ 0x80(SP), BX		
  0x440293		48895c2408		MOVQ BX, 0x8(SP)		
  0x440298		488b9c2488000000	MOVQ 0x88(SP), BX		
  0x4402a0		48895c2410		MOVQ BX, 0x10(SP)		
  0x4402a5		e8c6b2ffff		CALL runtime.funcline(SB)	
  0x4402aa		488b442420		MOVQ 0x20(SP), AX		
  0x4402af		4889442438		MOVQ AX, 0x38(SP)		
  0x4402b4		488b4c2418		MOVQ 0x18(SP), CX		
  0x4402b9		48894c2458		MOVQ CX, 0x58(SP)		
  0x4402be		4863542428		MOVSXD 0x28(SP), DX		
  0x4402c3		4889542448		MOVQ DX, 0x48(SP)		
	if name == "runtime.gopanic" {
  0x4402c8		488b5c2430		MOVQ 0x30(SP), BX		
  0x4402cd		4883fb0f		CMPQ $0xf, BX			
  0x4402d1		0f8593010000		JNE 0x44046a			
  0x4402d7		48be72756e74696d652e	MOVQ $0x2e656d69746e7572, SI	
  0x4402e1		488b7c2450		MOVQ 0x50(SP), DI		
  0x4402e6		483937			CMPQ SI, 0(DI)			
  0x4402e9		0f856e010000		JNE 0x44045d			
  0x4402ef		817f08676f7061		CMPL $0x61706f67, 0x8(DI)	
  0x4402f6		0f8554010000		JNE 0x440450			
  0x4402fc		66817f0c6e69		CMPW $0x696e, 0xc(DI)		
  0x440302		0f853b010000		JNE 0x440443			
  0x440308		807f0e63		CMPB $0x63, 0xe(DI)		
  0x44030c		0f8524010000		JNE 0x440436			
  0x440312		488d1de8ee0200		LEAQ 0x2eee8(IP), BX		
  0x440319		be05000000		MOVL $0x5, SI			
	print(name, "(...)\n")
  0x44031e		48895c2450		MOVQ BX, 0x50(SP)		
  0x440323		4889742430		MOVQ SI, 0x30(SP)		
  0x440328		e8933bfeff		CALL runtime.printlock(SB)	
  0x44032d		488b442450		MOVQ 0x50(SP), AX		
  0x440332		48890424		MOVQ AX, 0(SP)			
  0x440336		488b442430		MOVQ 0x30(SP), AX		
  0x44033b		4889442408		MOVQ AX, 0x8(SP)		
  0x440340		e8ab44feff		CALL runtime.printstring(SB)	
  0x440345		488d0528ef0200		LEAQ 0x2ef28(IP), AX		
  0x44034c		48890424		MOVQ AX, 0(SP)			
  0x440350		48c744240806000000	MOVQ $0x6, 0x8(SP)		
  0x440359		e89244feff		CALL runtime.printstring(SB)	
  0x44035e		e8dd3bfeff		CALL runtime.printunlock(SB)	
	print("\t", file, ":", line)
  0x440363		e8583bfeff		CALL runtime.printlock(SB)	
  0x440368		488d051fed0200		LEAQ 0x2ed1f(IP), AX		
  0x44036f		48890424		MOVQ AX, 0(SP)			
  0x440373		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x44037c		e86f44feff		CALL runtime.printstring(SB)	
  0x440381		488b442458		MOVQ 0x58(SP), AX		
  0x440386		48890424		MOVQ AX, 0(SP)			
  0x44038a		488b442438		MOVQ 0x38(SP), AX		
  0x44038f		4889442408		MOVQ AX, 0x8(SP)		
  0x440394		e85744feff		CALL runtime.printstring(SB)	
  0x440399		488d05e8ec0200		LEAQ 0x2ece8(IP), AX		
  0x4403a0		48890424		MOVQ AX, 0(SP)			
  0x4403a4		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x4403ad		e83e44feff		CALL runtime.printstring(SB)	
  0x4403b2		488b442448		MOVQ 0x48(SP), AX		
  0x4403b7		48890424		MOVQ AX, 0(SP)			
  0x4403bb		e88042feff		CALL runtime.printint(SB)	
  0x4403c0		e87b3bfeff		CALL runtime.printunlock(SB)	
	if pc > f.entry {
  0x4403c5		488b442478		MOVQ 0x78(SP), AX	
  0x4403ca		488b00			MOVQ 0(AX), AX		
  0x4403cd		488b8c2488000000	MOVQ 0x88(SP), CX	
  0x4403d5		4839c1			CMPQ AX, CX		
  0x4403d8		7719			JA 0x4403f3		
	print("\n")
  0x4403da		e8e13afeff		CALL runtime.printlock(SB)	
  0x4403df		e86c3dfeff		CALL runtime.printnl(SB)	
  0x4403e4		e8573bfeff		CALL runtime.printunlock(SB)	
}
  0x4403e9		488b6c2468		MOVQ 0x68(SP), BP	
  0x4403ee		4883c470		ADDQ $0x70, SP		
  0x4403f2		c3			RET			
	if pc > f.entry {
  0x4403f3		4889442440		MOVQ AX, 0x40(SP)	
		print(" +", hex(pc-f.entry))
  0x4403f8		e8c33afeff		CALL runtime.printlock(SB)	
  0x4403fd		488d058cec0200		LEAQ 0x2ec8c(IP), AX		
  0x440404		48890424		MOVQ AX, 0(SP)			
  0x440408		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x440411		e8da43feff		CALL runtime.printstring(SB)	
  0x440416		488b842488000000	MOVQ 0x88(SP), AX		
  0x44041e		488b4c2440		MOVQ 0x40(SP), CX		
  0x440423		4829c8			SUBQ CX, AX			
  0x440426		48890424		MOVQ AX, 0(SP)			
  0x44042a		e88142feff		CALL runtime.printhex(SB)	
  0x44042f		e80c3bfeff		CALL runtime.printunlock(SB)	
  0x440434		eba4			JMP 0x4403da			
	print(name, "(...)\n")
  0x440436		4889fb			MOVQ DI, BX		
  0x440439		488b742430		MOVQ 0x30(SP), SI	
	if name == "runtime.gopanic" {
  0x44043e		e9dbfeffff		JMP 0x44031e		
	print(name, "(...)\n")
  0x440443		4889fb			MOVQ DI, BX		
  0x440446		488b742430		MOVQ 0x30(SP), SI	
	if name == "runtime.gopanic" {
  0x44044b		e9cefeffff		JMP 0x44031e		
	print(name, "(...)\n")
  0x440450		4889fb			MOVQ DI, BX		
  0x440453		488b742430		MOVQ 0x30(SP), SI	
	if name == "runtime.gopanic" {
  0x440458		e9c1feffff		JMP 0x44031e		
	print(name, "(...)\n")
  0x44045d		4889fb			MOVQ DI, BX		
  0x440460		488b742430		MOVQ 0x30(SP), SI	
	if name == "runtime.gopanic" {
  0x440465		e9b4feffff		JMP 0x44031e		
	print(name, "(...)\n")
  0x44046a		488b5c2450		MOVQ 0x50(SP), BX	
  0x44046f		488b742430		MOVQ 0x30(SP), SI	
	if name == "runtime.gopanic" {
  0x440474		e9a5feffff		JMP 0x44031e		
	if inldata := funcdata(f, _FUNCDATA_InlTree); inldata != nil {
  0x440479		4889442460		MOVQ AX, 0x60(SP)	
		ix := pcdatavalue(f, _PCDATA_InlTreeIndex, pc, nil)
  0x44047e		488b442478		MOVQ 0x78(SP), AX		
  0x440483		48890424		MOVQ AX, 0(SP)			
  0x440487		488b8c2480000000	MOVQ 0x80(SP), CX		
  0x44048f		48894c2408		MOVQ CX, 0x8(SP)		
  0x440494		c744241001000000	MOVL $0x1, 0x10(SP)		
  0x44049c		488b942488000000	MOVQ 0x88(SP), DX		
  0x4404a4		4889542418		MOVQ DX, 0x18(SP)		
  0x4404a9		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x4404b2		e8a9b2ffff		CALL runtime.pcdatavalue(SB)	
  0x4404b7		8b442428		MOVL 0x28(SP), AX		
		if ix >= 0 {
  0x4404bb		85c0			TESTL AX, AX		
  0x4404bd		7c4f			JL 0x44050e		
			name = funcnameFromNameoff(f, inltree[ix].func_)
  0x4404bf		4863c0			MOVSXD AX, AX				
  0x4404c2		483d00001000		CMPQ $0x100000, AX			
  0x4404c8		7350			JAE 0x44051a				
  0x4404ca		488d0480		LEAQ 0(AX)(AX*4), AX			
  0x4404ce		488b4c2460		MOVQ 0x60(SP), CX			
  0x4404d3		8b44810c		MOVL 0xc(CX)(AX*4), AX			
  0x4404d7		488b4c2478		MOVQ 0x78(SP), CX			
  0x4404dc		48890c24		MOVQ CX, 0(SP)				
  0x4404e0		488b942480000000	MOVQ 0x80(SP), DX			
  0x4404e8		4889542408		MOVQ DX, 0x8(SP)			
  0x4404ed		89442410		MOVL AX, 0x10(SP)			
  0x4404f1		e8faadffff		CALL runtime.funcnameFromNameoff(SB)	
  0x4404f6		488b442420		MOVQ 0x20(SP), AX			
  0x4404fb		488b4c2418		MOVQ 0x18(SP), CX			
	if name == "runtime.gopanic" {
  0x440500		4889c2			MOVQ AX, DX		
  0x440503		4889c8			MOVQ CX, AX		
  0x440506		4889d1			MOVQ DX, CX		
	file, line := funcline(f, pc)
  0x440509		e96afdffff		JMP 0x440278		
	if name == "runtime.gopanic" {
  0x44050e		488b4c2450		MOVQ 0x50(SP), CX	
  0x440513		488b442430		MOVQ 0x30(SP), AX	
		if ix >= 0 {
  0x440518		ebe6			JMP 0x440500		
			name = funcnameFromNameoff(f, inltree[ix].func_)
  0x44051a		e8011afeff		CALL runtime.panicindex(SB)	
  0x44051f		0f0b			UD2				
func printAncestorTracebackFuncInfo(f funcInfo, pc uintptr) {
  0x440521		e85a730000		CALL runtime.morestack_noctxt(SB)		
  0x440526		e9c5fcffff		JMP runtime.printAncestorTracebackFuncInfo(SB)	

TEXT runtime.callers(SB) /usr/local/go/src/runtime/traceback.go
func callers(skip int, pcbuf []uintptr) int {
  0x440530		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440539		483b6110		CMPQ 0x10(CX), SP	
  0x44053d		0f86bf000000		JBE 0x440602		
  0x440543		4883ec60		SUBQ $0x60, SP		
  0x440547		48896c2458		MOVQ BP, 0x58(SP)	
  0x44054c		488d6c2458		LEAQ 0x58(SP), BP	
	gp := getg()
  0x440551		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	var n int
  0x44055a		48c744240800000000	MOVQ $0x0, 0x8(SP)	
	systemstack(func() {
  0x440563		48c744241000000000	MOVQ $0x0, 0x10(SP)			
  0x44056c		0f57c0			XORPS X0, X0				
  0x44056f		0f11442418		MOVUPS X0, 0x18(SP)			
  0x440574		0f11442428		MOVUPS X0, 0x28(SP)			
  0x440579		0f11442438		MOVUPS X0, 0x38(SP)			
  0x44057e		0f11442448		MOVUPS X0, 0x48(SP)			
  0x440583		488d0dc6690000		LEAQ runtime.callers.func1(SB), CX	
  0x44058a		48894c2410		MOVQ CX, 0x10(SP)			
  0x44058f		488b4c2460		MOVQ 0x60(SP), CX			
  0x440594		48894c2418		MOVQ CX, 0x18(SP)			
  0x440599		488d4c2468		LEAQ 0x68(SP), CX			
  0x44059e		48894c2420		MOVQ CX, 0x20(SP)			
  0x4405a3		4889442428		MOVQ AX, 0x28(SP)			
  0x4405a8		488b442468		MOVQ 0x68(SP), AX			
  0x4405ad		4889442430		MOVQ AX, 0x30(SP)			
  0x4405b2		488b442470		MOVQ 0x70(SP), AX			
  0x4405b7		4889442438		MOVQ AX, 0x38(SP)			
  0x4405bc		488b442478		MOVQ 0x78(SP), AX			
  0x4405c1		4889442440		MOVQ AX, 0x40(SP)			
  0x4405c6		488b842480000000	MOVQ 0x80(SP), AX			
  0x4405ce		4889442448		MOVQ AX, 0x48(SP)			
  0x4405d3		488d442408		LEAQ 0x8(SP), AX			
  0x4405d8		4889442450		MOVQ AX, 0x50(SP)			
  0x4405dd		488d442410		LEAQ 0x10(SP), AX			
  0x4405e2		48890424		MOVQ AX, 0(SP)				
  0x4405e6		e845710000		CALL runtime.systemstack(SB)		
	return n
  0x4405eb		488b442408		MOVQ 0x8(SP), AX	
  0x4405f0		4889842488000000	MOVQ AX, 0x88(SP)	
  0x4405f8		488b6c2458		MOVQ 0x58(SP), BP	
  0x4405fd		4883c460		ADDQ $0x60, SP		
  0x440601		c3			RET			
func callers(skip int, pcbuf []uintptr) int {
  0x440602		e879720000		CALL runtime.morestack_noctxt(SB)	
  0x440607		e924ffffff		JMP runtime.callers(SB)			

TEXT runtime.gcallers(SB) /usr/local/go/src/runtime/traceback.go
func gcallers(gp *g, skip int, pcbuf []uintptr) int {
  0x440610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440619		483b6110		CMPQ 0x10(CX), SP	
  0x44061d		0f868c000000		JBE 0x4406af		
  0x440623		4883ec60		SUBQ $0x60, SP		
  0x440627		48896c2458		MOVQ BP, 0x58(SP)	
  0x44062c		488d6c2458		LEAQ 0x58(SP), BP	
	return gentraceback(^uintptr(0), ^uintptr(0), 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x440631		488b842480000000	MOVQ 0x80(SP), AX		
  0x440639		4885c0			TESTQ AX, AX			
  0x44063c		766a			JBE 0x4406a8			
  0x44063e		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x440646		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x44064f		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x440658		488b4c2468		MOVQ 0x68(SP), CX		
  0x44065d		48894c2418		MOVQ CX, 0x18(SP)		
  0x440662		488b4c2470		MOVQ 0x70(SP), CX		
  0x440667		48894c2420		MOVQ CX, 0x20(SP)		
  0x44066c		488b4c2478		MOVQ 0x78(SP), CX		
  0x440671		48894c2428		MOVQ CX, 0x28(SP)		
  0x440676		4889442430		MOVQ AX, 0x30(SP)		
  0x44067b		0f57c0			XORPS X0, X0			
  0x44067e		0f11442438		MOVUPS X0, 0x38(SP)		
  0x440683		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x44068c		e82fd1ffff		CALL runtime.gentraceback(SB)	
  0x440691		488b442450		MOVQ 0x50(SP), AX		
  0x440696		4889842490000000	MOVQ AX, 0x90(SP)		
  0x44069e		488b6c2458		MOVQ 0x58(SP), BP		
  0x4406a3		4883c460		ADDQ $0x60, SP			
  0x4406a7		c3			RET				
  0x4406a8		e87318feff		CALL runtime.panicindex(SB)	
  0x4406ad		0f0b			UD2				
func gcallers(gp *g, skip int, pcbuf []uintptr) int {
  0x4406af		e8cc710000		CALL runtime.morestack_noctxt(SB)	
  0x4406b4		e957ffffff		JMP runtime.gcallers(SB)		

TEXT runtime.showframe(SB) /usr/local/go/src/runtime/traceback.go
func showframe(f funcInfo, gp *g, firstFrame bool, funcID, childID funcID) bool {
  0x4406c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4406c9		483b6110		CMPQ 0x10(CX), SP	
  0x4406cd		0f86a5000000		JBE 0x440778		
  0x4406d3		4883ec28		SUBQ $0x28, SP		
  0x4406d7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4406dc		488d6c2420		LEAQ 0x20(SP), BP	
	g := getg()
  0x4406e1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	if g.m.throwing > 0 && gp != nil && (gp == g.m.curg || gp == g.m.caughtsig.ptr()) {
  0x4406ea		488b4030		MOVQ 0x30(AX), AX	
  0x4406ee		83b8f400000000		CMPL $0x0, 0xf4(AX)	
  0x4406f5		7e1c			JLE 0x440713		
  0x4406f7		488b4c2440		MOVQ 0x40(SP), CX	
  0x4406fc		4885c9			TESTQ CX, CX		
  0x4406ff		7412			JE 0x440713		
  0x440701		483988c0000000		CMPQ CX, 0xc0(AX)	
  0x440708		755e			JNE 0x440768		
  0x44070a		b801000000		MOVL $0x1, AX		
  0x44070f		84c0			TESTL AL, AL		
  0x440711		7546			JNE 0x440759		
	return showfuncinfo(f, firstFrame, funcID, childID)
  0x440713		488b442430		MOVQ 0x30(SP), AX		
  0x440718		48890424		MOVQ AX, 0(SP)			
  0x44071c		488b442438		MOVQ 0x38(SP), AX		
  0x440721		4889442408		MOVQ AX, 0x8(SP)		
  0x440726		0fb6442448		MOVZX 0x48(SP), AX		
  0x44072b		88442410		MOVB AL, 0x10(SP)		
  0x44072f		0fb6442449		MOVZX 0x49(SP), AX		
  0x440734		88442411		MOVB AL, 0x11(SP)		
  0x440738		0fb644244a		MOVZX 0x4a(SP), AX		
  0x44073d		88442412		MOVB AL, 0x12(SP)		
  0x440741		e84a000000		CALL runtime.showfuncinfo(SB)	
  0x440746		0fb6442418		MOVZX 0x18(SP), AX		
  0x44074b		88442450		MOVB AL, 0x50(SP)		
  0x44074f		488b6c2420		MOVQ 0x20(SP), BP		
  0x440754		4883c428		ADDQ $0x28, SP			
  0x440758		c3			RET				
		return true
  0x440759		c644245001		MOVB $0x1, 0x50(SP)	
  0x44075e		488b6c2420		MOVQ 0x20(SP), BP	
  0x440763		4883c428		ADDQ $0x28, SP		
  0x440767		c3			RET			
	if g.m.throwing > 0 && gp != nil && (gp == g.m.curg || gp == g.m.caughtsig.ptr()) {
  0x440768		488b90c8000000		MOVQ 0xc8(AX), DX	
  0x44076f		4839ca			CMPQ CX, DX		
  0x440772		0f94c0			SETE AL			
  0x440775		90			NOPL			
  0x440776		eb97			JMP 0x44070f		
func showframe(f funcInfo, gp *g, firstFrame bool, funcID, childID funcID) bool {
  0x440778		e803710000		CALL runtime.morestack_noctxt(SB)	
  0x44077d		e93effffff		JMP runtime.showframe(SB)		

TEXT runtime.showfuncinfo(SB) /usr/local/go/src/runtime/traceback.go
func showfuncinfo(f funcInfo, firstFrame bool, funcID, childID funcID) bool {
  0x440790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440799		483b6110		CMPQ 0x10(CX), SP	
  0x44079d		0f86e3010000		JBE 0x440986		
  0x4407a3		4883ec40		SUBQ $0x40, SP		
  0x4407a7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4407ac		488d6c2438		LEAQ 0x38(SP), BP	
	level, _, _ := gotraceback()
  0x4407b1		90			NOPL			
  0x4407b2		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x4407bb		8b0d4be80700		MOVL runtime.traceback_cache(SB), CX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x4407c1		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x4407c5		0fb68029010000		MOVZX 0x129(AX), AX	
		level = int32(t >> tracebackShift)
  0x4407cc		c1e902			SHRL $0x2, CX		
	if _g_.m.traceback != 0 {
  0x4407cf		84c0			TESTL AL, AL		
	level, _, _ := gotraceback()
  0x4407d1		0f45c8			CMOVNE AX, CX		
	if level > 1 {
  0x4407d4		83f901			CMPL $0x1, CX		
	if _g_.m.traceback != 0 {
  0x4407d7		0f8f9a010000		JG 0x440977		
	if !f.valid() {
  0x4407dd		90			NOPL			
	return f._func != nil
  0x4407de		488b442448		MOVQ 0x48(SP), AX	
  0x4407e3		4885c0			TESTQ AX, AX		
	if !f.valid() {
  0x4407e6		0f847c010000		JE 0x440968		
	if funcID == funcID_wrapper && elideWrapperCalling(childID) {
  0x4407ec		0fb64c2459		MOVZX 0x59(SP), CX	
  0x4407f1		80f914			CMPL $0x14, CL		
  0x4407f4		751c			JNE 0x440812		
  0x4407f6		90			NOPL			
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x4407f7		0fb64c245a		MOVZX 0x5a(SP), CX	
  0x4407fc		80f912			CMPL $0x12, CL		
  0x4407ff		0f8549010000		JNE 0x44094e		
  0x440805		b901000000		MOVL $0x1, CX		
  0x44080a		84c9			TESTL CL, CL		
	if funcID == funcID_wrapper && elideWrapperCalling(childID) {
  0x44080c		0f842d010000		JE 0x44093f		
	name := funcname(f)
  0x440812		48890424		MOVQ AX, 0(SP)			
  0x440816		488b442450		MOVQ 0x50(SP), AX		
  0x44081b		4889442408		MOVQ AX, 0x8(SP)		
  0x440820		e81baaffff		CALL runtime.funcname(SB)	
  0x440825		488b442418		MOVQ 0x18(SP), AX		
  0x44082a		488b4c2410		MOVQ 0x10(SP), CX		
	if name == "runtime.gopanic" && !firstFrame {
  0x44082f		4883f80f		CMPQ $0xf, AX			
  0x440833		7533			JNE 0x440868			
  0x440835		48ba72756e74696d652e	MOVQ $0x2e656d69746e7572, DX	
  0x44083f		483911			CMPQ DX, 0(CX)			
  0x440842		7524			JNE 0x440868			
  0x440844		817908676f7061		CMPL $0x61706f67, 0x8(CX)	
  0x44084b		751b			JNE 0x440868			
  0x44084d		6681790c6e69		CMPW $0x696e, 0xc(CX)		
  0x440853		7513			JNE 0x440868			
  0x440855		80790e63		CMPB $0x63, 0xe(CX)		
  0x440859		750d			JNE 0x440868			
func showfuncinfo(f funcInfo, firstFrame bool, funcID, childID funcID) bool {
  0x44085b		0fb65c2458		MOVZX 0x58(SP), BX	
  0x440860		84db			TESTL BL, BL		
	if name == "runtime.gopanic" && !firstFrame {
  0x440862		0f84c8000000		JE 0x440930		
	name := funcname(f)
  0x440868		4889442428		MOVQ AX, 0x28(SP)	
  0x44086d		48894c2430		MOVQ CX, 0x30(SP)	
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x440872		90			NOPL			
	return index(s, t) >= 0
  0x440873		48890c24		MOVQ CX, 0(SP)		
  0x440877		4889442408		MOVQ AX, 0x8(SP)	
  0x44087c		488d1503e80200		LEAQ 0x2e803(IP), DX	
  0x440883		4889542410		MOVQ DX, 0x10(SP)	
  0x440888		48c744241801000000	MOVQ $0x1, 0x18(SP)	
  0x440891		e83a95ffff		CALL runtime.index(SB)	
  0x440896		48837c242000		CMPQ $0x0, 0x20(SP)	
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x44089c		0f8c8a000000		JL 0x44092c		
  0x4408a2		90			NOPL			
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4408a3		488b442428		MOVQ 0x28(SP), AX	
  0x4408a8		4883f808		CMPQ $0x8, AX		
  0x4408ac		7d4f			JGE 0x4408fd		
  0x4408ae		31c9			XORL CX, CX		
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x4408b0		84c9			TESTL CL, CL		
  0x4408b2		7442			JE 0x4408f6		
  0x4408b4		90			NOPL			
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4408b5		4883f808		CMPQ $0x8, AX		
	return len(name) > n && name[:n] == "runtime." && 'A' <= name[n] && name[n] <= 'Z'
  0x4408b9		7e37			JLE 0x4408f2			
  0x4408bb		48b872756e74696d652e	MOVQ $0x2e656d69746e7572, AX	
  0x4408c5		488b4c2430		MOVQ 0x30(SP), CX		
  0x4408ca		483901			CMPQ AX, 0(CX)			
  0x4408cd		751f			JNE 0x4408ee			
  0x4408cf		0fb64108		MOVZX 0x8(CX), AX		
  0x4408d3		3c41			CMPL $0x41, AL			
  0x4408d5		7213			JB 0x4408ea			
  0x4408d7		3c5a			CMPL $0x5a, AL			
  0x4408d9		0f96c0			SETBE AL			
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x4408dc		88442460		MOVB AL, 0x60(SP)	
  0x4408e0		488b6c2438		MOVQ 0x38(SP), BP	
  0x4408e5		4883c440		ADDQ $0x40, SP		
  0x4408e9		c3			RET			
  0x4408ea		31c0			XORL AX, AX		
	return len(name) > n && name[:n] == "runtime." && 'A' <= name[n] && name[n] <= 'Z'
  0x4408ec		ebee			JMP 0x4408dc		
  0x4408ee		31c0			XORL AX, AX		
  0x4408f0		ebea			JMP 0x4408dc		
  0x4408f2		31c0			XORL AX, AX		
  0x4408f4		ebe6			JMP 0x4408dc		
  0x4408f6		b801000000		MOVL $0x1, AX		
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x4408fb		ebdf			JMP 0x4408dc		
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4408fd		488b442430		MOVQ 0x30(SP), AX		
  0x440902		48890424		MOVQ AX, 0(SP)			
  0x440906		488d0d6beb0200		LEAQ 0x2eb6b(IP), CX		
  0x44090d		48894c2408		MOVQ CX, 0x8(SP)		
  0x440912		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x44091b		e80019fcff		CALL runtime.memequal(SB)	
  0x440920		0fb64c2418		MOVZX 0x18(SP), CX		
  0x440925		488b442428		MOVQ 0x28(SP), AX		
  0x44092a		eb84			JMP 0x4408b0			
  0x44092c		31c0			XORL AX, AX			
	return contains(name, ".") && (!hasPrefix(name, "runtime.") || isExportedRuntime(name))
  0x44092e		ebac			JMP 0x4408dc		
		return true
  0x440930		c644246001		MOVB $0x1, 0x60(SP)	
  0x440935		488b6c2438		MOVQ 0x38(SP), BP	
  0x44093a		4883c440		ADDQ $0x40, SP		
  0x44093e		c3			RET			
		return false
  0x44093f		c644246000		MOVB $0x0, 0x60(SP)	
  0x440944		488b6c2438		MOVQ 0x38(SP), BP	
  0x440949		4883c440		ADDQ $0x40, SP		
  0x44094d		c3			RET			
	return !(id == funcID_gopanic || id == funcID_sigpanic || id == funcID_panicwrap)
  0x44094e		80f909			CMPL $0x9, CL		
  0x440951		750a			JNE 0x44095d		
  0x440953		b901000000		MOVL $0x1, CX		
  0x440958		e9adfeffff		JMP 0x44080a		
  0x44095d		80f913			CMPL $0x13, CL		
  0x440960		0f94c1			SETE CL			
  0x440963		e9a2feffff		JMP 0x44080a		
		return false
  0x440968		c644246000		MOVB $0x0, 0x60(SP)	
  0x44096d		488b6c2438		MOVQ 0x38(SP), BP	
  0x440972		4883c440		ADDQ $0x40, SP		
  0x440976		c3			RET			
		return true
  0x440977		c644246001		MOVB $0x1, 0x60(SP)	
  0x44097c		488b6c2438		MOVQ 0x38(SP), BP	
  0x440981		4883c440		ADDQ $0x40, SP		
  0x440985		c3			RET			
func showfuncinfo(f funcInfo, firstFrame bool, funcID, childID funcID) bool {
  0x440986		e8f56e0000		CALL runtime.morestack_noctxt(SB)	
  0x44098b		e900feffff		JMP runtime.showfuncinfo(SB)		

TEXT runtime.goroutineheader(SB) /usr/local/go/src/runtime/traceback.go
func goroutineheader(gp *g) {
  0x440990		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440999		483b6110		CMPQ 0x10(CX), SP	
  0x44099d		0f86b4020000		JBE 0x440c57		
  0x4409a3		4883ec40		SUBQ $0x40, SP		
  0x4409a7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4409ac		488d6c2438		LEAQ 0x38(SP), BP	
	gpstatus := readgstatus(gp)
  0x4409b1		90			NOPL			
  0x4409b2		488b442448		MOVQ 0x48(SP), AX	
	return atomic.Load(&gp.atomicstatus)
  0x4409b7		8b8890000000		MOVL 0x90(AX), CX	
	gpstatus &^= _Gscan // drop the scan bit
  0x4409bd		89ca			MOVL CX, DX		
  0x4409bf		0fbaf10c		BTRL $0xc, CX		
	if 0 <= gpstatus && gpstatus < uint32(len(gStatusStrings)) {
  0x4409c3		85c9			TESTL CX, CX		
  0x4409c5		0f826d020000		JB 0x440c38		
  0x4409cb		83f909			CMPL $0x9, CX		
  0x4409ce		0f8364020000		JAE 0x440c38		
		status = gStatusStrings[gpstatus]
  0x4409d4		89cb			MOVL CX, BX				
  0x4409d6		4883fb09		CMPQ $0x9, BX				
  0x4409da		0f8370020000		JAE 0x440c50				
  0x4409e0		48c1e304		SHLQ $0x4, BX				
  0x4409e4		488d3515f40700		LEAQ runtime.gStatusStrings(SB), SI	
  0x4409eb		488b3c33		MOVQ 0(BX)(SI*1), DI			
  0x4409ef		488b5c3308		MOVQ 0x8(BX)(SI*1), BX			
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x4409f4		83f904			CMPL $0x4, CX		
  0x4409f7		0f8530020000		JNE 0x440c2d		
  0x4409fd		0fb6b0b0000000		MOVZX 0xb0(AX), SI	
  0x440a04		4084f6			TESTL SI, SI		
  0x440a07		0f841d020000		JE 0x440c2a		
		status = gp.waitreason.String()
  0x440a0d		90			NOPL			
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440a0e		4084f6			TESTL SI, SI		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x440a11		0f83e3010000		JAE 0x440bfa		
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440a17		83f904			CMPL $0x4, CX		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x440a1a		488d1d11fb0200		LEAQ 0x2fb11(IP), BX	
  0x440a21		be13000000		MOVL $0x13, SI		
	return atomic.Load(&gp.atomicstatus)
  0x440a26		89542414		MOVL DX, 0x14(SP)	
	print("goroutine ", gp.goid, " [", status)
  0x440a2a		4889742420		MOVQ SI, 0x20(SP)	
  0x440a2f		48895c2430		MOVQ BX, 0x30(SP)	
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp.waitsince != 0 {
  0x440a34		0f85b2010000		JNE 0x440bec		
  0x440a3a		4883b8a800000000	CMPQ $0x0, 0xa8(AX)	
  0x440a42		0f8566010000		JNE 0x440bae		
  0x440a48		31c9			XORL CX, CX		
	if waitfor >= 1 {
  0x440a4a		48894c2418		MOVQ CX, 0x18(SP)	
	print("goroutine ", gp.goid, " [", status)
  0x440a4f		488b9098000000		MOVQ 0x98(AX), DX		
  0x440a56		4889542428		MOVQ DX, 0x28(SP)		
  0x440a5b		e86034feff		CALL runtime.printlock(SB)	
  0x440a60		488d0555ed0200		LEAQ 0x2ed55(IP), AX		
  0x440a67		48890424		MOVQ AX, 0(SP)			
  0x440a6b		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x440a74		e8773dfeff		CALL runtime.printstring(SB)	
  0x440a79		488b442428		MOVQ 0x28(SP), AX		
  0x440a7e		48890424		MOVQ AX, 0(SP)			
  0x440a82		e8b93bfeff		CALL runtime.printint(SB)	
  0x440a87		488d0508e60200		LEAQ 0x2e608(IP), AX		
  0x440a8e		48890424		MOVQ AX, 0(SP)			
  0x440a92		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x440a9b		e8503dfeff		CALL runtime.printstring(SB)	
  0x440aa0		488b442430		MOVQ 0x30(SP), AX		
  0x440aa5		48890424		MOVQ AX, 0(SP)			
  0x440aa9		488b442420		MOVQ 0x20(SP), AX		
  0x440aae		4889442408		MOVQ AX, 0x8(SP)		
  0x440ab3		e8383dfeff		CALL runtime.printstring(SB)	
  0x440ab8		e88334feff		CALL runtime.printunlock(SB)	
	isScan := gpstatus&_Gscan != 0
  0x440abd		8b442414		MOVL 0x14(SP), AX	
  0x440ac1		0fbae00c		BTL $0xc, AX		
	if isScan {
  0x440ac5		0f82bb000000		JB 0x440b86		
	if waitfor >= 1 {
  0x440acb		488b442418		MOVQ 0x18(SP), AX	
  0x440ad0		4883f801		CMPQ $0x1, AX		
  0x440ad4		7d61			JGE 0x440b37		
	if gp.lockedm != 0 {
  0x440ad6		488b442448		MOVQ 0x48(SP), AX	
  0x440adb		4883b8d800000000	CMPQ $0x0, 0xd8(AX)	
  0x440ae3		752d			JNE 0x440b12		
	print("]:\n")
  0x440ae5		e8d633feff		CALL runtime.printlock(SB)	
  0x440aea		488d05e3e50200		LEAQ 0x2e5e3(IP), AX		
  0x440af1		48890424		MOVQ AX, 0(SP)			
  0x440af5		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x440afe		e8ed3cfeff		CALL runtime.printstring(SB)	
  0x440b03		e83834feff		CALL runtime.printunlock(SB)	
}
  0x440b08		488b6c2438		MOVQ 0x38(SP), BP	
  0x440b0d		4883c440		ADDQ $0x40, SP		
  0x440b11		c3			RET			
		print(", locked to thread")
  0x440b12		e8a933feff		CALL runtime.printlock(SB)	
  0x440b17		488d0596f70200		LEAQ 0x2f796(IP), AX		
  0x440b1e		48890424		MOVQ AX, 0(SP)			
  0x440b22		48c744240812000000	MOVQ $0x12, 0x8(SP)		
  0x440b2b		e8c03cfeff		CALL runtime.printstring(SB)	
  0x440b30		e80b34feff		CALL runtime.printunlock(SB)	
  0x440b35		ebae			JMP 0x440ae5			
		print(", ", waitfor, " minutes")
  0x440b37		e88433feff		CALL runtime.printlock(SB)	
  0x440b3c		488d0559e50200		LEAQ 0x2e559(IP), AX		
  0x440b43		48890424		MOVQ AX, 0(SP)			
  0x440b47		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x440b50		e89b3cfeff		CALL runtime.printstring(SB)	
  0x440b55		488b442418		MOVQ 0x18(SP), AX		
  0x440b5a		48890424		MOVQ AX, 0(SP)			
  0x440b5e		e8dd3afeff		CALL runtime.printint(SB)	
  0x440b63		488d058ee80200		LEAQ 0x2e88e(IP), AX		
  0x440b6a		48890424		MOVQ AX, 0(SP)			
  0x440b6e		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x440b77		e8743cfeff		CALL runtime.printstring(SB)	
  0x440b7c		e8bf33feff		CALL runtime.printunlock(SB)	
  0x440b81		e950ffffff		JMP 0x440ad6			
		print(" (scan)")
  0x440b86		e83533feff		CALL runtime.printlock(SB)	
  0x440b8b		488d0519e70200		LEAQ 0x2e719(IP), AX		
  0x440b92		48890424		MOVQ AX, 0(SP)			
  0x440b96		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x440b9f		e84c3cfeff		CALL runtime.printstring(SB)	
  0x440ba4		e89733feff		CALL runtime.printunlock(SB)	
  0x440ba9		e91dffffff		JMP 0x440acb			
		waitfor = (nanotime() - gp.waitsince) / 60e9
  0x440bae		e8fda40000		CALL runtime.nanotime(SB)	
  0x440bb3		488b0424		MOVQ 0(SP), AX			
  0x440bb7		488b4c2448		MOVQ 0x48(SP), CX		
  0x440bbc		482b81a8000000		SUBQ 0xa8(CX), AX		
  0x440bc3		4889c2			MOVQ AX, DX			
  0x440bc6		48b840474f3f9aff4c49	MOVQ $0x494cff9a3f4f4740, AX	
  0x440bd0		4889d3			MOVQ DX, BX			
  0x440bd3		48f7ea			IMULQ DX			
  0x440bd6		48c1fa22		SARQ $0x22, DX			
  0x440bda		48c1fb3f		SARQ $0x3f, BX			
  0x440bde		4829da			SUBQ BX, DX			
	print("goroutine ", gp.goid, " [", status)
  0x440be1		4889c8			MOVQ CX, AX		
	if waitfor >= 1 {
  0x440be4		4889d1			MOVQ DX, CX		
		waitfor = (nanotime() - gp.waitsince) / 60e9
  0x440be7		e95efeffff		JMP 0x440a4a		
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp.waitsince != 0 {
  0x440bec		83f903			CMPL $0x3, CX		
  0x440bef		0f8445feffff		JE 0x440a3a		
  0x440bf5		e94efeffff		JMP 0x440a48		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x440bfa		4080fe18		CMPL $0x18, SI		
  0x440bfe		7208			JB 0x440c08		
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440c00		83f904			CMPL $0x4, CX		
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x440c03		e912feffff		JMP 0x440a1a		
	return waitReasonStrings[w]
  0x440c08		4883fe18		CMPQ $0x18, SI				
  0x440c0c		733b			JAE 0x440c49				
  0x440c0e		48c1e604		SHLQ $0x4, SI				
  0x440c12		488d3de7f40700		LEAQ runtime.waitReasonStrings(SB), DI	
  0x440c19		488b1c3e		MOVQ 0(SI)(DI*1), BX			
  0x440c1d		488b743e08		MOVQ 0x8(SI)(DI*1), SI			
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440c22		83f904			CMPL $0x4, CX		
		status = gp.waitreason.String()
  0x440c25		e9fcfdffff		JMP 0x440a26		
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440c2a		83f904			CMPL $0x4, CX		
	print("goroutine ", gp.goid, " [", status)
  0x440c2d		4889de			MOVQ BX, SI		
  0x440c30		4889fb			MOVQ DI, BX		
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) && gp.waitsince != 0 {
  0x440c33		e9eefdffff		JMP 0x440a26		
  0x440c38		bb03000000		MOVL $0x3, BX		
  0x440c3d		488d3d87e40200		LEAQ 0x2e487(IP), DI	
	if gpstatus == _Gwaiting && gp.waitreason != waitReasonZero {
  0x440c44		e9abfdffff		JMP 0x4409f4		
	return waitReasonStrings[w]
  0x440c49		e8d212feff		CALL runtime.panicindex(SB)	
  0x440c4e		0f0b			UD2				
		status = gStatusStrings[gpstatus]
  0x440c50		e8cb12feff		CALL runtime.panicindex(SB)	
  0x440c55		0f0b			UD2				
func goroutineheader(gp *g) {
  0x440c57		e8246c0000		CALL runtime.morestack_noctxt(SB)	
  0x440c5c		e92ffdffff		JMP runtime.goroutineheader(SB)		

TEXT runtime.tracebackothers(SB) /usr/local/go/src/runtime/traceback.go
func tracebackothers(me *g) {
  0x440c70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440c79		483b6110		CMPQ 0x10(CX), SP	
  0x440c7d		0f8689020000		JBE 0x440f0c		
  0x440c83		4883ec60		SUBQ $0x60, SP		
  0x440c87		48896c2458		MOVQ BP, 0x58(SP)	
  0x440c8c		488d6c2458		LEAQ 0x58(SP), BP	
	level, _, _ := gotraceback()
  0x440c91		90			NOPL			
  0x440c92		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
	t := atomic.Load(&traceback_cache)
  0x440c9b		8b0d6be30700		MOVL runtime.traceback_cache(SB), CX	
	g := getg()
  0x440ca1		64488b1425f8ffffff	MOVQ FS:0xfffffff8, DX	
  0x440caa		4889542448		MOVQ DX, 0x48(SP)	
	gp := g.m.curg
  0x440caf		488b5a30		MOVQ 0x30(DX), BX	
	all = _g_.m.throwing > 0 || t&tracebackAll != 0
  0x440cb3		488b4030		MOVQ 0x30(AX), AX	
	if _g_.m.traceback != 0 {
  0x440cb7		0fb68029010000		MOVZX 0x129(AX), AX	
		level = int32(t >> tracebackShift)
  0x440cbe		c1e902			SHRL $0x2, CX		
	if _g_.m.traceback != 0 {
  0x440cc1		84c0			TESTL AL, AL		
	level, _, _ := gotraceback()
  0x440cc3		0f45c8			CMOVNE AX, CX		
  0x440cc6		894c2424		MOVL CX, 0x24(SP)	
	gp := g.m.curg
  0x440cca		488b83c0000000		MOVQ 0xc0(BX), AX	
	if gp != nil && gp != me {
  0x440cd1		4885c0			TESTQ AX, AX		
	if _g_.m.traceback != 0 {
  0x440cd4		0f8428020000		JE 0x440f02		
	if gp != nil && gp != me {
  0x440cda		488b5c2468		MOVQ 0x68(SP), BX	
  0x440cdf		4839c3			CMPQ AX, BX		
  0x440ce2		0f85ca010000		JNE 0x440eb2		
	lock(&allglock)
  0x440ce8		488d0531c00900		LEAQ runtime.allglock(SB), AX	
  0x440cef		48890424		MOVQ AX, 0(SP)			
  0x440cf3		e8e879fcff		CALL runtime.lock(SB)		
	for _, gp := range allgs {
  0x440cf8		488b05090d0800		MOVQ runtime.allgs+8(SB), AX	
  0x440cff		4889442430		MOVQ AX, 0x30(SP)		
  0x440d04		488b0df50c0800		MOVQ runtime.allgs(SB), CX	
  0x440d0b		48894c2450		MOVQ CX, 0x50(SP)		
  0x440d10		488b542468		MOVQ 0x68(SP), DX		
  0x440d15		488b5c2448		MOVQ 0x48(SP), BX		
  0x440d1a		31f6			XORL SI, SI			
  0x440d1c		eb03			JMP 0x440d21			
  0x440d1e		48ffc6			INCQ SI				
  0x440d21		4839c6			CMPQ AX, SI			
  0x440d24		0f8d6e010000		JGE 0x440e98			
  0x440d2a		488b3cf1		MOVQ 0(CX)(SI*8), DI		
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440d2e		4839fa			CMPQ DI, DX		
  0x440d31		0f8534010000		JNE 0x440e6b		
  0x440d37		41b801000000		MOVL $0x1, R8		
	for _, gp := range allgs {
  0x440d3d		4889742428		MOVQ SI, 0x28(SP)	
  0x440d42		48897c2440		MOVQ DI, 0x40(SP)	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440d47		4584c0			TESTL R8, R8		
  0x440d4a		0f84ce000000		JE 0x440e1e		
  0x440d50		41b801000000		MOVL $0x1, R8		
  0x440d56		4584c0			TESTL R8, R8		
  0x440d59		75c3			JNE 0x440d1e		
		print("\n")
  0x440d5b		e86031feff		CALL runtime.printlock(SB)	
  0x440d60		e8eb33feff		CALL runtime.printnl(SB)	
  0x440d65		e8d631feff		CALL runtime.printunlock(SB)	
		goroutineheader(gp)
  0x440d6a		488b442440		MOVQ 0x40(SP), AX			
  0x440d6f		48890424		MOVQ AX, 0(SP)				
  0x440d73		e818fcffff		CALL runtime.goroutineheader(SB)	
		if gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {
  0x440d78		488b442448		MOVQ 0x48(SP), AX	
  0x440d7d		488b4830		MOVQ 0x30(AX), CX	
  0x440d81		488b542440		MOVQ 0x40(SP), DX	
  0x440d86		48394a30		CMPQ CX, 0x30(DX)	
  0x440d8a		0f848a000000		JE 0x440e1a		
  0x440d90		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x440d91		8b8a90000000		MOVL 0x90(DX), CX	
		if gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {
  0x440d97		0fbaf10c		BTRL $0xc, CX		
  0x440d9b		83f902			CMPL $0x2, CX		
  0x440d9e		0f94c1			SETE CL			
  0x440da1		84c9			TESTL CL, CL		
  0x440da3		744f			JE 0x440df4		
			print("\tgoroutine running on other thread; stack unavailable\n")
  0x440da5		e81631feff		CALL runtime.printlock(SB)	
  0x440daa		488d0558250300		LEAQ 0x32558(IP), AX		
  0x440db1		48890424		MOVQ AX, 0(SP)			
  0x440db5		48c744240836000000	MOVQ $0x36, 0x8(SP)		
  0x440dbe		e82d3afeff		CALL runtime.printstring(SB)	
  0x440dc3		e87831feff		CALL runtime.printunlock(SB)	
			printcreatedby(gp)
  0x440dc8		488b442440		MOVQ 0x40(SP), AX		
  0x440dcd		48890424		MOVQ AX, 0(SP)			
  0x440dd1		e84aebffff		CALL runtime.printcreatedby(SB)	
	for _, gp := range allgs {
  0x440dd6		488b442430		MOVQ 0x30(SP), AX	
  0x440ddb		488b4c2450		MOVQ 0x50(SP), CX	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440de0		488b542468		MOVQ 0x68(SP), DX	
  0x440de5		488b5c2448		MOVQ 0x48(SP), BX	
	for _, gp := range allgs {
  0x440dea		488b742428		MOVQ 0x28(SP), SI	
  0x440def		e92affffff		JMP 0x440d1e		
			traceback(^uintptr(0), ^uintptr(0), 0, gp)
  0x440df4		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x440dfc		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x440e05		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x440e0e		4889542418		MOVQ DX, 0x18(SP)		
  0x440e13		e898edffff		CALL runtime.traceback(SB)	
  0x440e18		ebbc			JMP 0x440dd6			
  0x440e1a		31c9			XORL CX, CX			
		if gp.m != g.m && readgstatus(gp)&^_Gscan == _Grunning {
  0x440e1c		eb83			JMP 0x440da1		
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440e1e		48893c24		MOVQ DI, 0(SP)				
  0x440e22		c644240800		MOVB $0x0, 0x8(SP)			
  0x440e27		e8e4020000		CALL runtime.isSystemGoroutine(SB)	
  0x440e2c		807c241000		CMPB $0x0, 0x10(SP)			
  0x440e31		7430			JE 0x440e63				
  0x440e33		8b442424		MOVL 0x24(SP), AX			
  0x440e37		83f802			CMPL $0x2, AX				
  0x440e3a		0f9cc1			SETL CL					
	for _, gp := range allgs {
  0x440e3d		488b442430		MOVQ 0x30(SP), AX	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440e42		488b542468		MOVQ 0x68(SP), DX	
  0x440e47		488b5c2448		MOVQ 0x48(SP), BX	
	for _, gp := range allgs {
  0x440e4c		488b742428		MOVQ 0x28(SP), SI	
		goroutineheader(gp)
  0x440e51		488b7c2440		MOVQ 0x40(SP), DI	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440e56		4189c8			MOVL CX, R8		
	for _, gp := range allgs {
  0x440e59		488b4c2450		MOVQ 0x50(SP), CX	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440e5e		e9f3feffff		JMP 0x440d56		
  0x440e63		8b442424		MOVL 0x24(SP), AX	
  0x440e67		31c9			XORL CX, CX		
  0x440e69		ebd2			JMP 0x440e3d		
  0x440e6b		4c8b4330		MOVQ 0x30(BX), R8	
  0x440e6f		4939b8c0000000		CMPQ DI, 0xc0(R8)	
  0x440e76		750b			JNE 0x440e83		
  0x440e78		41b801000000		MOVL $0x1, R8		
  0x440e7e		e9bafeffff		JMP 0x440d3d		
  0x440e83		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x440e84		448b8f90000000		MOVL 0x90(DI), R9	
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440e8b		4183f906		CMPL $0x6, R9		
  0x440e8f		410f94c0		SETE R8			
  0x440e93		e9a5feffff		JMP 0x440d3d		
	unlock(&allglock)
  0x440e98		488d0581be0900		LEAQ runtime.allglock(SB), AX	
  0x440e9f		48890424		MOVQ AX, 0(SP)			
  0x440ea3		e8e879fcff		CALL runtime.unlock(SB)		
}
  0x440ea8		488b6c2458		MOVQ 0x58(SP), BP	
  0x440ead		4883c460		ADDQ $0x60, SP		
  0x440eb1		c3			RET			
	gp := g.m.curg
  0x440eb2		4889442438		MOVQ AX, 0x38(SP)	
		print("\n")
  0x440eb7		e80430feff		CALL runtime.printlock(SB)	
  0x440ebc		e88f32feff		CALL runtime.printnl(SB)	
  0x440ec1		e87a30feff		CALL runtime.printunlock(SB)	
		goroutineheader(gp)
  0x440ec6		488b442438		MOVQ 0x38(SP), AX			
  0x440ecb		48890424		MOVQ AX, 0(SP)				
  0x440ecf		e8bcfaffff		CALL runtime.goroutineheader(SB)	
		traceback(^uintptr(0), ^uintptr(0), 0, gp)
  0x440ed4		48c70424ffffffff	MOVQ $-0x1, 0(SP)		
  0x440edc		48c7442408ffffffff	MOVQ $-0x1, 0x8(SP)		
  0x440ee5		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x440eee		488b442438		MOVQ 0x38(SP), AX		
  0x440ef3		4889442418		MOVQ AX, 0x18(SP)		
  0x440ef8		e8b3ecffff		CALL runtime.traceback(SB)	
  0x440efd		e9e6fdffff		JMP 0x440ce8			
		if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) && level < 2 {
  0x440f02		488b5c2468		MOVQ 0x68(SP), BX	
	if _g_.m.traceback != 0 {
  0x440f07		e9dcfdffff		JMP 0x440ce8		
func tracebackothers(me *g) {
  0x440f0c		e86f690000		CALL runtime.morestack_noctxt(SB)	
  0x440f11		e95afdffff		JMP runtime.tracebackothers(SB)		

TEXT runtime.tracebackHexdump(SB) /usr/local/go/src/runtime/traceback.go
func tracebackHexdump(stk stack, frame *stkframe, bad uintptr) {
  0x440f20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x440f29		483b6110		CMPQ 0x10(CX), SP	
  0x440f2d		0f86cd010000		JBE 0x441100		
  0x440f33		4883ec58		SUBQ $0x58, SP		
  0x440f37		48896c2450		MOVQ BP, 0x50(SP)	
  0x440f3c		488d6c2450		LEAQ 0x50(SP), BP	
	lo, hi := frame.sp, frame.sp
  0x440f41		488b442470		MOVQ 0x70(SP), AX	
  0x440f46		488b4828		MOVQ 0x28(AX), CX	
	if frame.fp != 0 && frame.fp < lo {
  0x440f4a		488b5030		MOVQ 0x30(AX), DX	
  0x440f4e		4885d2			TESTQ DX, DX		
  0x440f51		0f849e010000		JE 0x4410f5		
  0x440f57		4839ca			CMPQ CX, DX		
  0x440f5a		0f8392010000		JAE 0x4410f2		
  0x440f60		4885d2			TESTQ DX, DX		
  0x440f63		4889d3			MOVQ DX, BX		
	lo, hi := frame.sp, frame.sp
  0x440f66		48894c2420		MOVQ CX, 0x20(SP)	
	if frame.fp != 0 && frame.fp < lo {
  0x440f6b		48895c2430		MOVQ BX, 0x30(SP)	
	lo, hi = lo-expand, hi+expand
  0x440f70		4889542418		MOVQ DX, 0x18(SP)	
	if frame.fp != 0 && frame.fp > hi {
  0x440f75		0f846f010000		JE 0x4410ea		
  0x440f7b		4839cb			CMPQ CX, BX		
  0x440f7e		0f8666010000		JBE 0x4410ea		
	lo, hi = lo-expand, hi+expand
  0x440f84		48895c2428		MOVQ BX, 0x28(SP)	
	print("stack: frame={sp:", hex(frame.sp), ", fp:", hex(frame.fp), "} stack=[", hex(stk.lo), ",", hex(stk.hi), ")\n")
  0x440f89		e8322ffeff		CALL runtime.printlock(SB)	
  0x440f8e		488d05b7f20200		LEAQ 0x2f2b7(IP), AX		
  0x440f95		48890424		MOVQ AX, 0(SP)			
  0x440f99		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x440fa2		e84938feff		CALL runtime.printstring(SB)	
  0x440fa7		488b442420		MOVQ 0x20(SP), AX		
  0x440fac		48890424		MOVQ AX, 0(SP)			
  0x440fb0		e8fb36feff		CALL runtime.printhex(SB)	
  0x440fb5		488d052ce20200		LEAQ 0x2e22c(IP), AX		
  0x440fbc		48890424		MOVQ AX, 0(SP)			
  0x440fc0		48c744240805000000	MOVQ $0x5, 0x8(SP)		
  0x440fc9		e82238feff		CALL runtime.printstring(SB)	
  0x440fce		488b442430		MOVQ 0x30(SP), AX		
  0x440fd3		48890424		MOVQ AX, 0(SP)			
  0x440fd7		e8d436feff		CALL runtime.printhex(SB)	
  0x440fdc		488d0508e70200		LEAQ 0x2e708(IP), AX		
  0x440fe3		48890424		MOVQ AX, 0(SP)			
  0x440fe7		48c744240809000000	MOVQ $0x9, 0x8(SP)		
  0x440ff0		e8fb37feff		CALL runtime.printstring(SB)	
  0x440ff5		488b442460		MOVQ 0x60(SP), AX		
  0x440ffa		48890424		MOVQ AX, 0(SP)			
  0x440ffe		e8ad36feff		CALL runtime.printhex(SB)	
  0x441003		488d057ae00200		LEAQ 0x2e07a(IP), AX		
  0x44100a		48890424		MOVQ AX, 0(SP)			
  0x44100e		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x441017		e8d437feff		CALL runtime.printstring(SB)	
  0x44101c		488b442468		MOVQ 0x68(SP), AX		
  0x441021		48890424		MOVQ AX, 0(SP)			
  0x441025		e88636feff		CALL runtime.printhex(SB)	
  0x44102a		488d0569e00200		LEAQ 0x2e069(IP), AX		
  0x441031		48890424		MOVQ AX, 0(SP)			
  0x441035		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x44103e		e8ad37feff		CALL runtime.printstring(SB)	
  0x441043		e8f82efeff		CALL runtime.printunlock(SB)	
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x441048		0f57c0			XORPS X0, X0					
  0x44104b		0f11442438		MOVUPS X0, 0x38(SP)				
  0x441050		48c744244800000000	MOVQ $0x0, 0x48(SP)				
  0x441059		488d05a05f0000		LEAQ runtime.tracebackHexdump.func1(SB), AX	
  0x441060		4889442438		MOVQ AX, 0x38(SP)				
  0x441065		488b442470		MOVQ 0x70(SP), AX				
  0x44106a		4889442440		MOVQ AX, 0x40(SP)				
  0x44106f		488b442478		MOVQ 0x78(SP), AX				
  0x441074		4889442448		MOVQ AX, 0x48(SP)				
	lo, hi = lo-expand, hi+expand
  0x441079		488b442418		MOVQ 0x18(SP), AX	
  0x44107e		480500ffffff		ADDQ $-0x100, AX	
	if lo < frame.sp-maxExpand {
  0x441084		488b4c2420		MOVQ 0x20(SP), CX	
  0x441089		488d9100f8ffff		LEAQ 0xfffff800(CX), DX	
  0x441090		4839d0			CMPQ DX, AX		
	if lo < stk.lo {
  0x441093		480f42c2		CMOVB DX, AX		
  0x441097		488b542460		MOVQ 0x60(SP), DX	
  0x44109c		4839d0			CMPQ DX, AX		
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x44109f		480f42c2		CMOVB DX, AX		
  0x4410a3		48890424		MOVQ AX, 0(SP)		
	lo, hi = lo-expand, hi+expand
  0x4410a7		488b442428		MOVQ 0x28(SP), AX	
  0x4410ac		480500010000		ADDQ $0x100, AX		
	if hi > frame.sp+maxExpand {
  0x4410b2		4881c100080000		ADDQ $0x800, CX		
  0x4410b9		4839c8			CMPQ CX, AX		
	if hi > stk.hi {
  0x4410bc		480f47c1		CMOVA CX, AX		
  0x4410c0		488b4c2468		MOVQ 0x68(SP), CX	
  0x4410c5		4839c8			CMPQ CX, AX		
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x4410c8		480f47c1		CMOVA CX, AX			
  0x4410cc		4889442408		MOVQ AX, 0x8(SP)		
  0x4410d1		488d442438		LEAQ 0x38(SP), AX		
  0x4410d6		4889442410		MOVQ AX, 0x10(SP)		
  0x4410db		e82039feff		CALL runtime.hexdumpWords(SB)	
	if lo < frame.sp-maxExpand {
  0x4410e0		488b6c2450		MOVQ 0x50(SP), BP	
  0x4410e5		4883c458		ADDQ $0x58, SP		
  0x4410e9		c3			RET			
	lo, hi = lo-expand, hi+expand
  0x4410ea		4889cb			MOVQ CX, BX		
  0x4410ed		e992feffff		JMP 0x440f84		
	if frame.fp != 0 && frame.fp < lo {
  0x4410f2		4885d2			TESTQ DX, DX		
	if frame.fp != 0 && frame.fp > hi {
  0x4410f5		4889d3			MOVQ DX, BX		
	lo, hi = lo-expand, hi+expand
  0x4410f8		4889ca			MOVQ CX, DX		
	if frame.fp != 0 && frame.fp > hi {
  0x4410fb		e966feffff		JMP 0x440f66		
func tracebackHexdump(stk stack, frame *stkframe, bad uintptr) {
  0x441100		e87b670000		CALL runtime.morestack_noctxt(SB)	
  0x441105		e916feffff		JMP runtime.tracebackHexdump(SB)	

TEXT runtime.isSystemGoroutine(SB) /usr/local/go/src/runtime/traceback.go
func isSystemGoroutine(gp *g, fixed bool) bool {
  0x441110		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441119		483b6110		CMPQ 0x10(CX), SP	
  0x44111d		0f86e8000000		JBE 0x44120b		
  0x441123		4883ec28		SUBQ $0x28, SP		
  0x441127		48896c2420		MOVQ BP, 0x20(SP)	
  0x44112c		488d6c2420		LEAQ 0x20(SP), BP	
	f := findfunc(gp.startpc)
  0x441131		488b442430		MOVQ 0x30(SP), AX		
  0x441136		488b8028010000		MOVQ 0x128(AX), AX		
  0x44113d		48890424		MOVQ AX, 0(SP)			
  0x441141		e8ba99ffff		CALL runtime.findfunc(SB)	
  0x441146		488b442410		MOVQ 0x10(SP), AX		
  0x44114b		488b4c2408		MOVQ 0x8(SP), CX		
	if !f.valid() {
  0x441150		90			NOPL			
	return f._func != nil
  0x441151		4885c9			TESTQ CX, CX		
	if !f.valid() {
  0x441154		0f84a2000000		JE 0x4411fc		
	if f.funcID == funcID_runtime_main {
  0x44115a		0fb65124		MOVZX 0x24(CX), DX	
  0x44115e		80fa01			CMPL $0x1, DL		
  0x441161		0f8486000000		JE 0x4411ed		
	if f.funcID == funcID_runfinq {
  0x441167		80fa0a			CMPL $0xa, DL		
  0x44116a		7530			JNE 0x44119c		
func isSystemGoroutine(gp *g, fixed bool) bool {
  0x44116c		0fb6442438		MOVZX 0x38(SP), AX	
  0x441171		84c0			TESTL AL, AL		
		if fixed {
  0x441173		740f			JE 0x441184		
			return false
  0x441175		c644244000		MOVB $0x0, 0x40(SP)	
  0x44117a		488b6c2420		MOVQ 0x20(SP), BP	
  0x44117f		4883c428		ADDQ $0x28, SP		
  0x441183		c3			RET			
		return !fingRunning
  0x441184		0fb6051cbb0900		MOVZX runtime.fingRunning(SB), AX	
  0x44118b		83f001			XORL $0x1, AX				
  0x44118e		88442440		MOVB AL, 0x40(SP)			
  0x441192		488b6c2420		MOVQ 0x20(SP), BP			
  0x441197		4883c428		ADDQ $0x28, SP				
  0x44119b		c3			RET					
	return hasPrefix(funcname(f), "runtime.")
  0x44119c		48890c24		MOVQ CX, 0(SP)			
  0x4411a0		4889442408		MOVQ AX, 0x8(SP)		
  0x4411a5		e896a0ffff		CALL runtime.funcname(SB)	
  0x4411aa		90			NOPL				
  0x4411ab		488b442410		MOVQ 0x10(SP), AX		
  0x4411b0		48837c241808		CMPQ $0x8, 0x18(SP)		
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4411b6		7d10			JGE 0x4411c8		
  0x4411b8		31c0			XORL AX, AX		
	return hasPrefix(funcname(f), "runtime.")
  0x4411ba		88442440		MOVB AL, 0x40(SP)	
  0x4411be		488b6c2420		MOVQ 0x20(SP), BP	
  0x4411c3		4883c428		ADDQ $0x28, SP		
  0x4411c7		c3			RET			
	return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  0x4411c8		48890424		MOVQ AX, 0(SP)			
  0x4411cc		488d05a5e20200		LEAQ 0x2e2a5(IP), AX		
  0x4411d3		4889442408		MOVQ AX, 0x8(SP)		
  0x4411d8		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x4411e1		e83a10fcff		CALL runtime.memequal(SB)	
  0x4411e6		0fb6442418		MOVZX 0x18(SP), AX		
  0x4411eb		ebcd			JMP 0x4411ba			
		return false
  0x4411ed		c644244000		MOVB $0x0, 0x40(SP)	
  0x4411f2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4411f7		4883c428		ADDQ $0x28, SP		
  0x4411fb		c3			RET			
		return false
  0x4411fc		c644244000		MOVB $0x0, 0x40(SP)	
  0x441201		488b6c2420		MOVQ 0x20(SP), BP	
  0x441206		4883c428		ADDQ $0x28, SP		
  0x44120a		c3			RET			
func isSystemGoroutine(gp *g, fixed bool) bool {
  0x44120b		e870660000		CALL runtime.morestack_noctxt(SB)	
  0x441210		e9fbfeffff		JMP runtime.isSystemGoroutine(SB)	

TEXT runtime.printCgoTraceback(SB) /usr/local/go/src/runtime/traceback.go
func printCgoTraceback(callers *cgoCallers) {
  0x441220		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441229		483b6110		CMPQ 0x10(CX), SP	
  0x44122d		0f8613010000		JBE 0x441346		
  0x441233		4883ec70		SUBQ $0x70, SP		
  0x441237		48896c2468		MOVQ BP, 0x68(SP)	
  0x44123c		488d6c2468		LEAQ 0x68(SP), BP	
	if cgoSymbolizer == nil {
  0x441241		48833def06080000	CMPQ $0x0, runtime.cgoSymbolizer(SB)	
  0x441249		0f8485000000		JE 0x4412d4				
	var arg cgoSymbolizerArg
  0x44124f		48c744243000000000	MOVQ $0x0, 0x30(SP)	
  0x441258		0f57c0			XORPS X0, X0		
  0x44125b		0f11442438		MOVUPS X0, 0x38(SP)	
  0x441260		0f11442448		MOVUPS X0, 0x48(SP)	
  0x441265		0f11442458		MOVUPS X0, 0x58(SP)	
	for _, c := range callers {
  0x44126a		488b442478		MOVQ 0x78(SP), AX	
  0x44126f		31c9			XORL CX, CX		
  0x441271		eb2f			JMP 0x4412a2		
  0x441273		48894c2428		MOVQ CX, 0x28(SP)	
		printOneCgoTraceback(c, 0x7fffffff, &arg)
  0x441278		48891424		MOVQ DX, 0(SP)				
  0x44127c		48c7442408ffffff7f	MOVQ $0x7fffffff, 0x8(SP)		
  0x441285		488d442430		LEAQ 0x30(SP), AX			
  0x44128a		4889442410		MOVQ AX, 0x10(SP)			
  0x44128f		e8bc000000		CALL runtime.printOneCgoTraceback(SB)	
	for _, c := range callers {
  0x441294		488b442428		MOVQ 0x28(SP), AX	
  0x441299		488d4801		LEAQ 0x1(AX), CX	
  0x44129d		488b442478		MOVQ 0x78(SP), AX	
  0x4412a2		4883f920		CMPQ $0x20, CX		
  0x4412a6		7d0b			JGE 0x4412b3		
  0x4412a8		8400			TESTB AL, 0(AX)		
  0x4412aa		488b14c8		MOVQ 0(AX)(CX*8), DX	
		if c == 0 {
  0x4412ae		4885d2			TESTQ DX, DX		
  0x4412b1		75c0			JNE 0x441273		
	arg.pc = 0
  0x4412b3		48c744243000000000	MOVQ $0x0, 0x30(SP)	
	callCgoSymbolizer(&arg)
  0x4412bc		488d442430		LEAQ 0x30(SP), AX			
  0x4412c1		48890424		MOVQ AX, 0(SP)				
  0x4412c5		e8c6020000		CALL runtime.callCgoSymbolizer(SB)	
}
  0x4412ca		488b6c2468		MOVQ 0x68(SP), BP	
  0x4412cf		4883c470		ADDQ $0x70, SP		
  0x4412d3		c3			RET			
		for _, c := range callers {
  0x4412d4		488b442478		MOVQ 0x78(SP), AX	
  0x4412d9		31c9			XORL CX, CX		
  0x4412db		eb4e			JMP 0x44132b		
  0x4412dd		48894c2428		MOVQ CX, 0x28(SP)	
  0x4412e2		4889542420		MOVQ DX, 0x20(SP)	
			print("non-Go function at pc=", hex(c), "\n")
  0x4412e7		e8d42bfeff		CALL runtime.printlock(SB)	
  0x4412ec		488d052af70200		LEAQ 0x2f72a(IP), AX		
  0x4412f3		48890424		MOVQ AX, 0(SP)			
  0x4412f7		48c744240816000000	MOVQ $0x16, 0x8(SP)		
  0x441300		e8eb34feff		CALL runtime.printstring(SB)	
  0x441305		488b442420		MOVQ 0x20(SP), AX		
  0x44130a		48890424		MOVQ AX, 0(SP)			
  0x44130e		e89d33feff		CALL runtime.printhex(SB)	
  0x441313		e8382efeff		CALL runtime.printnl(SB)	
  0x441318		e8232cfeff		CALL runtime.printunlock(SB)	
		for _, c := range callers {
  0x44131d		488b442428		MOVQ 0x28(SP), AX	
  0x441322		488d4801		LEAQ 0x1(AX), CX	
  0x441326		488b442478		MOVQ 0x78(SP), AX	
  0x44132b		4883f920		CMPQ $0x20, CX		
  0x44132f		7d0b			JGE 0x44133c		
  0x441331		8400			TESTB AL, 0(AX)		
  0x441333		488b14c8		MOVQ 0(AX)(CX*8), DX	
			if c == 0 {
  0x441337		4885d2			TESTQ DX, DX		
  0x44133a		75a1			JNE 0x4412dd		
		return
  0x44133c		488b6c2468		MOVQ 0x68(SP), BP	
  0x441341		4883c470		ADDQ $0x70, SP		
  0x441345		c3			RET			
func printCgoTraceback(callers *cgoCallers) {
  0x441346		e835650000		CALL runtime.morestack_noctxt(SB)	
  0x44134b		e9d0feffff		JMP runtime.printCgoTraceback(SB)	

TEXT runtime.printOneCgoTraceback(SB) /usr/local/go/src/runtime/traceback.go
func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int {
  0x441350		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441359		483b6110		CMPQ 0x10(CX), SP	
  0x44135d		0f8621020000		JBE 0x441584		
  0x441363		4883ec68		SUBQ $0x68, SP		
  0x441367		48896c2460		MOVQ BP, 0x60(SP)	
  0x44136c		488d6c2460		LEAQ 0x60(SP), BP	
	arg.pc = pc
  0x441371		488b442470		MOVQ 0x70(SP), AX	
  0x441376		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x44137e		488901			MOVQ AX, 0(CX)		
  0x441381		31d2			XORL DX, DX		
	for {
  0x441383		eb08			JMP 0x44138d		
		if c > max {
  0x441385		4889c2			MOVQ AX, DX		
		print("pc=", hex(pc), "\n")
  0x441388		488b442470		MOVQ 0x70(SP), AX	
		if c > max {
  0x44138d		488b5c2478		MOVQ 0x78(SP), BX	
  0x441392		4839da			CMPQ BX, DX		
  0x441395		0f8fe1010000		JG 0x44157c		
  0x44139b		4889542410		MOVQ DX, 0x10(SP)	
		callCgoSymbolizer(arg)
  0x4413a0		48890c24		MOVQ CX, 0(SP)				
  0x4413a4		e8e7010000		CALL runtime.callCgoSymbolizer(SB)	
		if arg.funcName != nil {
  0x4413a9		488b842480000000	MOVQ 0x80(SP), AX	
  0x4413b1		488b4818		MOVQ 0x18(AX), CX	
  0x4413b5		4885c9			TESTQ CX, CX		
  0x4413b8		0f8496010000		JE 0x441554		
  0x4413be		48894c2438		MOVQ CX, 0x38(SP)	
			println(gostringnocopy(arg.funcName))
  0x4413c3		90			NOPL			
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x4413c4		48890c24		MOVQ CX, 0(SP)			
  0x4413c8		e8338cffff		CALL runtime.findnull(SB)	
  0x4413cd		488b442408		MOVQ 0x8(SP), AX		
  0x4413d2		4889442420		MOVQ AX, 0x20(SP)		
  0x4413d7		0f57c0			XORPS X0, X0			
  0x4413da		0f11442440		MOVUPS X0, 0x40(SP)		
  0x4413df		488b4c2438		MOVQ 0x38(SP), CX		
  0x4413e4		48894c2440		MOVQ CX, 0x40(SP)		
  0x4413e9		4889442448		MOVQ AX, 0x48(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x4413ee		488b4c2440		MOVQ 0x40(SP), CX	
  0x4413f3		48894c2428		MOVQ CX, 0x28(SP)	
			println(gostringnocopy(arg.funcName))
  0x4413f8		e8c32afeff		CALL runtime.printlock(SB)	
  0x4413fd		488b442428		MOVQ 0x28(SP), AX		
  0x441402		48890424		MOVQ AX, 0(SP)			
  0x441406		488b442420		MOVQ 0x20(SP), AX		
  0x44140b		4889442408		MOVQ AX, 0x8(SP)		
  0x441410		e8db33feff		CALL runtime.printstring(SB)	
  0x441415		e8362dfeff		CALL runtime.printnl(SB)	
  0x44141a		e8212bfeff		CALL runtime.printunlock(SB)	
		print("\t")
  0x44141f		e89c2afeff		CALL runtime.printlock(SB)	
  0x441424		488d0563dc0200		LEAQ 0x2dc63(IP), AX		
  0x44142b		48890424		MOVQ AX, 0(SP)			
  0x44142f		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x441438		e8b333feff		CALL runtime.printstring(SB)	
  0x44143d		e8fe2afeff		CALL runtime.printunlock(SB)	
		if arg.file != nil {
  0x441442		488b842480000000	MOVQ 0x80(SP), AX	
  0x44144a		488b4808		MOVQ 0x8(AX), CX	
  0x44144e		4885c9			TESTQ CX, CX		
  0x441451		7563			JNE 0x4414b6		
		print("pc=", hex(pc), "\n")
  0x441453		e8682afeff		CALL runtime.printlock(SB)	
  0x441458		488d0593dc0200		LEAQ 0x2dc93(IP), AX		
  0x44145f		48890424		MOVQ AX, 0(SP)			
  0x441463		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x44146c		e87f33feff		CALL runtime.printstring(SB)	
  0x441471		488b442470		MOVQ 0x70(SP), AX		
  0x441476		48890424		MOVQ AX, 0(SP)			
  0x44147a		e83132feff		CALL runtime.printhex(SB)	
  0x44147f		e8cc2cfeff		CALL runtime.printnl(SB)	
  0x441484		e8b72afeff		CALL runtime.printunlock(SB)	
		c++
  0x441489		488b442410		MOVQ 0x10(SP), AX	
  0x44148e		48ffc0			INCQ AX			
		if arg.more == 0 {
  0x441491		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x441499		4883792800		CMPQ $0x0, 0x28(CX)	
  0x44149e		0f85e1feffff		JNE 0x441385		
	return c
  0x4414a4		4889842488000000	MOVQ AX, 0x88(SP)	
  0x4414ac		488b6c2460		MOVQ 0x60(SP), BP	
  0x4414b1		4883c468		ADDQ $0x68, SP		
  0x4414b5		c3			RET			
		if arg.file != nil {
  0x4414b6		48894c2438		MOVQ CX, 0x38(SP)	
			print(gostringnocopy(arg.file), ":", arg.lineno, " ")
  0x4414bb		90			NOPL			
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x4414bc		48890c24		MOVQ CX, 0(SP)			
  0x4414c0		e83b8bffff		CALL runtime.findnull(SB)	
  0x4414c5		488b442408		MOVQ 0x8(SP), AX		
  0x4414ca		4889442420		MOVQ AX, 0x20(SP)		
  0x4414cf		0f57c0			XORPS X0, X0			
  0x4414d2		0f11442450		MOVUPS X0, 0x50(SP)		
  0x4414d7		488b4c2438		MOVQ 0x38(SP), CX		
  0x4414dc		48894c2450		MOVQ CX, 0x50(SP)		
  0x4414e1		4889442458		MOVQ AX, 0x58(SP)		
			print(gostringnocopy(arg.file), ":", arg.lineno, " ")
  0x4414e6		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x4414ee		488b5110		MOVQ 0x10(CX), DX	
  0x4414f2		4889542418		MOVQ DX, 0x18(SP)	
	s := *(*string)(unsafe.Pointer(&ss))
  0x4414f7		488b5c2450		MOVQ 0x50(SP), BX	
  0x4414fc		48895c2430		MOVQ BX, 0x30(SP)	
			print(gostringnocopy(arg.file), ":", arg.lineno, " ")
  0x441501		e8ba29feff		CALL runtime.printlock(SB)	
  0x441506		488b442430		MOVQ 0x30(SP), AX		
  0x44150b		48890424		MOVQ AX, 0(SP)			
  0x44150f		488b442420		MOVQ 0x20(SP), AX		
  0x441514		4889442408		MOVQ AX, 0x8(SP)		
  0x441519		e8d232feff		CALL runtime.printstring(SB)	
  0x44151e		488d0563db0200		LEAQ 0x2db63(IP), AX		
  0x441525		48890424		MOVQ AX, 0(SP)			
  0x441529		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x441532		e8b932feff		CALL runtime.printstring(SB)	
  0x441537		488b442418		MOVQ 0x18(SP), AX		
  0x44153c		48890424		MOVQ AX, 0(SP)			
  0x441540		e8fb2ffeff		CALL runtime.printuint(SB)	
  0x441545		e8b62bfeff		CALL runtime.printsp(SB)	
  0x44154a		e8f129feff		CALL runtime.printunlock(SB)	
  0x44154f		e9fffeffff		JMP 0x441453			
			println("non-Go function")
  0x441554		e86729feff		CALL runtime.printlock(SB)	
  0x441559		488d05f7ea0200		LEAQ 0x2eaf7(IP), AX		
  0x441560		48890424		MOVQ AX, 0(SP)			
  0x441564		48c744240810000000	MOVQ $0x10, 0x8(SP)		
  0x44156d		e87e32feff		CALL runtime.printstring(SB)	
  0x441572		e8c929feff		CALL runtime.printunlock(SB)	
  0x441577		e9a3feffff		JMP 0x44141f			
	return c
  0x44157c		4889d0			MOVQ DX, AX		
			break
  0x44157f		e920ffffff		JMP 0x4414a4		
func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int {
  0x441584		e8f7620000		CALL runtime.morestack_noctxt(SB)	
  0x441589		e9c2fdffff		JMP runtime.printOneCgoTraceback(SB)	

TEXT runtime.callCgoSymbolizer(SB) /usr/local/go/src/runtime/traceback.go
func callCgoSymbolizer(arg *cgoSymbolizerArg) {
  0x441590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441599		483b6110		CMPQ 0x10(CX), SP	
  0x44159d		7665			JBE 0x441604		
  0x44159f		4883ec20		SUBQ $0x20, SP		
  0x4415a3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4415a8		488d6c2418		LEAQ 0x18(SP), BP	
	if panicking > 0 || getg().m.curg != getg() {
  0x4415ad		833d40b7090000		CMPL $0x0, runtime.panicking(SB)	
  0x4415b4		762f			JBE 0x4415e5				
  0x4415b6		488d0583210300		LEAQ 0x32183(IP), AX			
	call(cgoSymbolizer, noescape(unsafe.Pointer(arg)))
  0x4415bd		488b0d74030800		MOVQ runtime.cgoSymbolizer(SB), CX	
  0x4415c4		90			NOPL					
  0x4415c5		48890c24		MOVQ CX, 0(SP)				
  0x4415c9		488b4c2428		MOVQ 0x28(SP), CX			
  0x4415ce		48894c2408		MOVQ CX, 0x8(SP)			
  0x4415d3		488b08			MOVQ 0(AX), CX				
  0x4415d6		4889c2			MOVQ AX, DX				
  0x4415d9		ffd1			CALL CX					
}
  0x4415db		488b6c2418		MOVQ 0x18(SP), BP	
  0x4415e0		4883c420		ADDQ $0x20, SP		
  0x4415e4		c3			RET			
	if panicking > 0 || getg().m.curg != getg() {
  0x4415e5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4415ee		488b4830		MOVQ 0x30(AX), CX	
  0x4415f2		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x4415f9		75bb			JNE 0x4415b6		
  0x4415fb		488d057e210300		LEAQ 0x3217e(IP), AX	
  0x441602		ebb9			JMP 0x4415bd		
func callCgoSymbolizer(arg *cgoSymbolizerArg) {
  0x441604		e877620000		CALL runtime.morestack_noctxt(SB)	
  0x441609		eb85			JMP runtime.callCgoSymbolizer(SB)	

TEXT runtime.cgoContextPCs(SB) /usr/local/go/src/runtime/traceback.go
func cgoContextPCs(ctxt uintptr, buf []uintptr) {
  0x441610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441619		483b6110		CMPQ 0x10(CX), SP	
  0x44161d		0f86b5000000		JBE 0x4416d8		
  0x441623		4883ec40		SUBQ $0x40, SP		
  0x441627		48896c2438		MOVQ BP, 0x38(SP)	
  0x44162c		488d6c2438		LEAQ 0x38(SP), BP	
	if cgoTraceback == nil {
  0x441631		48833d0703080000	CMPQ $0x0, runtime.cgoTraceback(SB)	
  0x441639		0f8488000000		JE 0x4416c7				
	if panicking > 0 || getg().m.curg != getg() {
  0x44163f		833daeb6090000		CMPL $0x0, runtime.panicking(SB)	
  0x441646		7660			JBE 0x4416a8				
  0x441648		488d05f1200300		LEAQ 0x320f1(IP), AX			
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x44164f		488b4c2458		MOVQ 0x58(SP), CX	
  0x441654		4885c9			TESTQ CX, CX		
  0x441657		7678			JBE 0x4416d1		
  0x441659		90			NOPL			
	arg := cgoTracebackArg{
  0x44165a		0f57c0			XORPS X0, X0		
  0x44165d		0f11442418		MOVUPS X0, 0x18(SP)	
  0x441662		0f11442428		MOVUPS X0, 0x28(SP)	
  0x441667		488b5c2448		MOVQ 0x48(SP), BX	
  0x44166c		48895c2418		MOVQ BX, 0x18(SP)	
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x441671		488b5c2450		MOVQ 0x50(SP), BX	
  0x441676		48895c2428		MOVQ BX, 0x28(SP)	
		max:     uintptr(len(buf)),
  0x44167b		48894c2430		MOVQ CX, 0x30(SP)	
	call(cgoTraceback, noescape(unsafe.Pointer(&arg)))
  0x441680		488b0db9020800		MOVQ runtime.cgoTraceback(SB), CX	
  0x441687		90			NOPL					
  0x441688		48890c24		MOVQ CX, 0(SP)				
  0x44168c		488d4c2418		LEAQ 0x18(SP), CX			
  0x441691		48894c2408		MOVQ CX, 0x8(SP)			
  0x441696		488b08			MOVQ 0(AX), CX				
  0x441699		4889c2			MOVQ AX, DX				
  0x44169c		ffd1			CALL CX					
}
  0x44169e		488b6c2438		MOVQ 0x38(SP), BP	
  0x4416a3		4883c440		ADDQ $0x40, SP		
  0x4416a7		c3			RET			
	if panicking > 0 || getg().m.curg != getg() {
  0x4416a8		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4416b1		488b4830		MOVQ 0x30(AX), CX	
  0x4416b5		483981c0000000		CMPQ AX, 0xc0(CX)	
  0x4416bc		758a			JNE 0x441648		
  0x4416be		488d05bb200300		LEAQ 0x320bb(IP), AX	
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x4416c5		eb88			JMP 0x44164f		
		return
  0x4416c7		488b6c2438		MOVQ 0x38(SP), BP	
  0x4416cc		4883c440		ADDQ $0x40, SP		
  0x4416d0		c3			RET			
		buf:     (*uintptr)(noescape(unsafe.Pointer(&buf[0]))),
  0x4416d1		e84a08feff		CALL runtime.panicindex(SB)	
  0x4416d6		0f0b			UD2				
func cgoContextPCs(ctxt uintptr, buf []uintptr) {
  0x4416d8		e8a3610000		CALL runtime.morestack_noctxt(SB)	
  0x4416dd		e92effffff		JMP runtime.cgoContextPCs(SB)		

TEXT runtime.(*_type).string(SB) /usr/local/go/src/runtime/type.go
func (t *_type) string() string {
  0x4416f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4416f9		483b6110		CMPQ 0x10(CX), SP	
  0x4416fd		0f8693000000		JBE 0x441796		
  0x441703		4883ec20		SUBQ $0x20, SP		
  0x441707		48896c2418		MOVQ BP, 0x18(SP)	
  0x44170c		488d6c2418		LEAQ 0x18(SP), BP	
	s := t.nameOff(t.str).name()
  0x441711		90			NOPL			
  0x441712		488b442428		MOVQ 0x28(SP), AX	
  0x441717		8b4828			MOVL 0x28(AX), CX	
	return resolveNameOff(unsafe.Pointer(t), off)
  0x44171a		48890424		MOVQ AX, 0(SP)			
  0x44171e		894c2408		MOVL CX, 0x8(SP)		
  0x441722		e839020000		CALL runtime.resolveNameOff(SB)	
  0x441727		488b442410		MOVQ 0x10(SP), AX		
	s := t.nameOff(t.str).name()
  0x44172c		48890424		MOVQ AX, 0(SP)			
  0x441730		e81b0c0000		CALL runtime.name.name(SB)	
  0x441735		488b442410		MOVQ 0x10(SP), AX		
  0x44173a		488b4c2408		MOVQ 0x8(SP), CX		
	if t.tflag&tflagExtraStar != 0 {
  0x44173f		488b542428		MOVQ 0x28(SP), DX	
  0x441744		0fb65214		MOVZX 0x14(DX), DX	
  0x441748		f6c202			TESTL $0x2, DL		
  0x44174b		742e			JE 0x44177b		
		return s[1:]
  0x44174d		4883f801		CMPQ $0x1, AX		
  0x441751		723c			JB 0x44178f		
  0x441753		48ffc8			DECQ AX			
  0x441756		4889c2			MOVQ AX, DX		
  0x441759		48f7d8			NEGQ AX			
  0x44175c		48c1f83f		SARQ $0x3f, AX		
  0x441760		4883e001		ANDQ $0x1, AX		
  0x441764		4801c8			ADDQ CX, AX		
  0x441767		4889442430		MOVQ AX, 0x30(SP)	
  0x44176c		4889542438		MOVQ DX, 0x38(SP)	
  0x441771		488b6c2418		MOVQ 0x18(SP), BP	
  0x441776		4883c420		ADDQ $0x20, SP		
  0x44177a		c3			RET			
	return s
  0x44177b		48894c2430		MOVQ CX, 0x30(SP)	
  0x441780		4889442438		MOVQ AX, 0x38(SP)	
  0x441785		488b6c2418		MOVQ 0x18(SP), BP	
  0x44178a		4883c420		ADDQ $0x20, SP		
  0x44178e		c3			RET			
		return s[1:]
  0x44178f		e8bc08feff		CALL runtime.panicslice(SB)	
  0x441794		0f0b			UD2				
func (t *_type) string() string {
  0x441796		e8e5600000		CALL runtime.morestack_noctxt(SB)	
  0x44179b		e950ffffff		JMP runtime.(*_type).string(SB)		

TEXT runtime.(*_type).uncommon(SB) /usr/local/go/src/runtime/type.go
	if t.tflag&tflagUncommon == 0 {
  0x4417a0		488b442408		MOVQ 0x8(SP), AX	
  0x4417a5		0fb64814		MOVZX 0x14(AX), CX	
  0x4417a9		f6c101			TESTL $0x1, CL		
  0x4417ac		0f848e000000		JE 0x441840		
	switch t.kind & kindMask {
  0x4417b2		0fb64817		MOVZX 0x17(AX), CX	
  0x4417b6		83e11f			ANDL $0x1f, CX		
  0x4417b9		80f914			CMPL $0x14, CL		
  0x4417bc		7746			JA 0x441804		
  0x4417be		80f912			CMPL $0x12, CL		
  0x4417c1		7728			JA 0x4417eb		
	case kindArray:
  0x4417c3		80f911			CMPL $0x11, CL		
  0x4417c6		7419			JE 0x4417e1		
	switch t.kind & kindMask {
  0x4417c8		80f912			CMPL $0x12, CL		
	case kindChan:
  0x4417cb		740a			JE 0x4417d7		
		return &(*u)(unsafe.Pointer(t)).u
  0x4417cd		4883c030		ADDQ $0x30, AX		
  0x4417d1		4889442410		MOVQ AX, 0x10(SP)	
  0x4417d6		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x4417d7		4883c040		ADDQ $0x40, AX		
  0x4417db		4889442410		MOVQ AX, 0x10(SP)	
  0x4417e0		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x4417e1		4883c048		ADDQ $0x48, AX		
  0x4417e5		4889442410		MOVQ AX, 0x10(SP)	
  0x4417ea		c3			RET			
	case kindFunc:
  0x4417eb		80f913			CMPL $0x13, CL		
  0x4417ee		750a			JNE 0x4417fa		
		return &(*u)(unsafe.Pointer(t)).u
  0x4417f0		4883c038		ADDQ $0x38, AX		
  0x4417f4		4889442410		MOVQ AX, 0x10(SP)	
  0x4417f9		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x4417fa		4883c050		ADDQ $0x50, AX		
  0x4417fe		4889442410		MOVQ AX, 0x10(SP)	
  0x441803		c3			RET			
	switch t.kind & kindMask {
  0x441804		80f916			CMPL $0x16, CL		
  0x441807		7719			JA 0x441822		
	case kindMap:
  0x441809		80f915			CMPL $0x15, CL		
  0x44180c		750a			JNE 0x441818		
		return &(*u)(unsafe.Pointer(t)).u
  0x44180e		4883c050		ADDQ $0x50, AX		
  0x441812		4889442410		MOVQ AX, 0x10(SP)	
  0x441817		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x441818		4883c038		ADDQ $0x38, AX		
  0x44181c		4889442410		MOVQ AX, 0x10(SP)	
  0x441821		c3			RET			
	case kindSlice:
  0x441822		80f917			CMPL $0x17, CL		
  0x441825		740f			JE 0x441836		
	case kindStruct:
  0x441827		80f919			CMPL $0x19, CL		
  0x44182a		75a1			JNE 0x4417cd		
		return &(*u)(unsafe.Pointer(t)).u
  0x44182c		4883c050		ADDQ $0x50, AX		
  0x441830		4889442410		MOVQ AX, 0x10(SP)	
  0x441835		c3			RET			
		return &(*u)(unsafe.Pointer(t)).u
  0x441836		4883c038		ADDQ $0x38, AX		
  0x44183a		4889442410		MOVQ AX, 0x10(SP)	
  0x44183f		c3			RET			
		return nil
  0x441840		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x441849		c3			RET			

TEXT runtime.(*_type).pkgpath(SB) /usr/local/go/src/runtime/type.go
func (t *_type) pkgpath() string {
  0x441850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441859		483b6110		CMPQ 0x10(CX), SP	
  0x44185d		0f86e5000000		JBE 0x441948		
  0x441863		4883ec20		SUBQ $0x20, SP		
  0x441867		48896c2418		MOVQ BP, 0x18(SP)	
  0x44186c		488d6c2418		LEAQ 0x18(SP), BP	
	if u := t.uncommon(); u != nil {
  0x441871		488b442428		MOVQ 0x28(SP), AX			
  0x441876		48890424		MOVQ AX, 0(SP)				
  0x44187a		e821ffffff		CALL runtime.(*_type).uncommon(SB)	
  0x44187f		488b442408		MOVQ 0x8(SP), AX			
  0x441884		4885c0			TESTQ AX, AX				
  0x441887		757e			JNE 0x441907				
	switch t.kind & kindMask {
  0x441889		488b442428		MOVQ 0x28(SP), AX	
  0x44188e		0fb64817		MOVZX 0x17(AX), CX	
  0x441892		83e11f			ANDL $0x1f, CX		
	case kindInterface:
  0x441895		80f914			CMPL $0x14, CL		
  0x441898		7442			JE 0x4418dc		
	case kindStruct:
  0x44189a		80f919			CMPL $0x19, CL		
  0x44189d		752b			JNE 0x4418ca		
		return st.pkgPath.name()
  0x44189f		488b4030		MOVQ 0x30(AX), AX		
  0x4418a3		48890424		MOVQ AX, 0(SP)			
  0x4418a7		e8a40a0000		CALL runtime.name.name(SB)	
  0x4418ac		488b442410		MOVQ 0x10(SP), AX		
  0x4418b1		488b4c2408		MOVQ 0x8(SP), CX		
  0x4418b6		48894c2430		MOVQ CX, 0x30(SP)		
  0x4418bb		4889442438		MOVQ AX, 0x38(SP)		
  0x4418c0		488b6c2418		MOVQ 0x18(SP), BP		
  0x4418c5		4883c420		ADDQ $0x20, SP			
  0x4418c9		c3			RET				
	return ""
  0x4418ca		0f57c0			XORPS X0, X0		
  0x4418cd		0f11442430		MOVUPS X0, 0x30(SP)	
  0x4418d2		488b6c2418		MOVQ 0x18(SP), BP	
  0x4418d7		4883c420		ADDQ $0x20, SP		
  0x4418db		c3			RET			
		return it.pkgpath.name()
  0x4418dc		488b4030		MOVQ 0x30(AX), AX		
  0x4418e0		48890424		MOVQ AX, 0(SP)			
  0x4418e4		e8670a0000		CALL runtime.name.name(SB)	
  0x4418e9		488b442408		MOVQ 0x8(SP), AX		
  0x4418ee		488b4c2410		MOVQ 0x10(SP), CX		
  0x4418f3		4889442430		MOVQ AX, 0x30(SP)		
  0x4418f8		48894c2438		MOVQ CX, 0x38(SP)		
  0x4418fd		488b6c2418		MOVQ 0x18(SP), BP		
  0x441902		4883c420		ADDQ $0x20, SP			
  0x441906		c3			RET				
		return t.nameOff(u.pkgpath).name()
  0x441907		90			NOPL			
  0x441908		8b00			MOVL 0(AX), AX		
	return resolveNameOff(unsafe.Pointer(t), off)
  0x44190a		488b4c2428		MOVQ 0x28(SP), CX		
  0x44190f		48890c24		MOVQ CX, 0(SP)			
  0x441913		89442408		MOVL AX, 0x8(SP)		
  0x441917		e844000000		CALL runtime.resolveNameOff(SB)	
  0x44191c		488b442410		MOVQ 0x10(SP), AX		
		return t.nameOff(u.pkgpath).name()
  0x441921		48890424		MOVQ AX, 0(SP)			
  0x441925		e8260a0000		CALL runtime.name.name(SB)	
  0x44192a		488b442408		MOVQ 0x8(SP), AX		
  0x44192f		488b4c2410		MOVQ 0x10(SP), CX		
  0x441934		4889442430		MOVQ AX, 0x30(SP)		
  0x441939		48894c2438		MOVQ CX, 0x38(SP)		
  0x44193e		488b6c2418		MOVQ 0x18(SP), BP		
  0x441943		4883c420		ADDQ $0x20, SP			
  0x441947		c3			RET				
func (t *_type) pkgpath() string {
  0x441948		e8335f0000		CALL runtime.morestack_noctxt(SB)	
  0x44194d		e9fefeffff		JMP runtime.(*_type).pkgpath(SB)	

TEXT runtime.resolveNameOff(SB) /usr/local/go/src/runtime/type.go
func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {
  0x441960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441969		483b6110		CMPQ 0x10(CX), SP	
  0x44196d		0f86d8020000		JBE 0x441c4b		
  0x441973		4883ec60		SUBQ $0x60, SP		
  0x441977		48896c2458		MOVQ BP, 0x58(SP)	
  0x44197c		488d6c2458		LEAQ 0x58(SP), BP	
	if off == 0 {
  0x441981		8b442470		MOVL 0x70(SP), AX	
  0x441985		85c0			TESTL AX, AX		
  0x441987		0f84e5010000		JE 0x441b72		
	base := uintptr(ptrInModule)
  0x44198d		488b4c2468		MOVQ 0x68(SP), CX			
  0x441992		488d15a7df0700		LEAQ runtime.firstmoduledata(SB), DX	
	for md := &firstmoduledata; md != nil; md = md.next {
  0x441999		eb07			JMP 0x4419a2		
  0x44199b		488b92c0010000		MOVQ 0x1c0(DX), DX	
  0x4419a2		4885d2			TESTQ DX, DX		
  0x4419a5		7436			JE 0x4419dd		
		if base >= md.types && base < md.etypes {
  0x4419a7		488b9ac8000000		MOVQ 0xc8(DX), BX	
  0x4419ae		4839d9			CMPQ BX, CX		
  0x4419b1		72e8			JB 0x44199b		
  0x4419b3		488bb2d0000000		MOVQ 0xd0(DX), SI	
  0x4419ba		4839f1			CMPQ SI, CX		
  0x4419bd		73dc			JAE 0x44199b		
			res := md.types + uintptr(off)
  0x4419bf		4863c8			MOVSXD AX, CX		
  0x4419c2		4801d9			ADDQ BX, CX		
			if res > md.etypes {
  0x4419c5		4839f1			CMPQ SI, CX		
  0x4419c8		0f87d2010000		JA 0x441ba0		
			return name{(*byte)(unsafe.Pointer(res))}
  0x4419ce		48894c2478		MOVQ CX, 0x78(SP)	
  0x4419d3		488b6c2458		MOVQ 0x58(SP), BP	
  0x4419d8		4883c460		ADDQ $0x60, SP		
  0x4419dc		c3			RET			
	base := uintptr(ptrInModule)
  0x4419dd		48894c2430		MOVQ CX, 0x30(SP)	
	reflectOffsLock()
  0x4419e2		90			NOPL			
	lock(&reflectOffs.lock)
  0x4419e3		488d0536010800		LEAQ runtime.reflectOffs(SB), AX	
  0x4419ea		48890424		MOVQ AX, 0(SP)				
  0x4419ee		e8ed6cfcff		CALL runtime.lock(SB)			
	res, found := reflectOffs.m[int32(off)]
  0x4419f3		488d05a6c60100		LEAQ 0x1c6a6(IP), AX			
  0x4419fa		48890424		MOVQ AX, 0(SP)				
  0x4419fe		488b052b010800		MOVQ runtime.reflectOffs+16(SB), AX	
  0x441a05		4889442408		MOVQ AX, 0x8(SP)			
  0x441a0a		8b442470		MOVL 0x70(SP), AX			
  0x441a0e		89442410		MOVL AX, 0x10(SP)			
  0x441a12		e839b1fcff		CALL runtime.mapaccess2_fast32(SB)	
  0x441a17		488b442418		MOVQ 0x18(SP), AX			
  0x441a1c		488b00			MOVQ 0(AX), AX				
  0x441a1f		4889442448		MOVQ AX, 0x48(SP)			
	reflectOffsUnlock()
  0x441a24		90			NOPL			
	res, found := reflectOffs.m[int32(off)]
  0x441a25		0fb64c2420		MOVZX 0x20(SP), CX	
  0x441a2a		884c242f		MOVB CL, 0x2f(SP)	
  0x441a2e		80f900			CMPL $0x0, CL		
	unlock(&reflectOffs.lock)
  0x441a31		488d15e8000800		LEAQ runtime.reflectOffs(SB), DX	
  0x441a38		48891424		MOVQ DX, 0(SP)				
  0x441a3c		e84f6efcff		CALL runtime.unlock(SB)			
	res, found := reflectOffs.m[int32(off)]
  0x441a41		0fb644242f		MOVZX 0x2f(SP), AX	
  0x441a46		3c00			CMPL $0x0, AL		
	if !found {
  0x441a48		0f8510010000		JNE 0x441b5e		
		println("runtime: nameOff", hex(off), "base", hex(base), "not in ranges:")
  0x441a4e		e86d24feff		CALL runtime.printlock(SB)		
  0x441a53		488d057be70200		LEAQ 0x2e77b(IP), AX			
  0x441a5a		48890424		MOVQ AX, 0(SP)				
  0x441a5e		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x441a67		e8842dfeff		CALL runtime.printstring(SB)		
  0x441a6c		8b442470		MOVL 0x70(SP), AX			
  0x441a70		4863c0			MOVSXD AX, AX				
  0x441a73		48890424		MOVQ AX, 0(SP)				
  0x441a77		e8342cfeff		CALL runtime.printhex(SB)		
  0x441a7c		488d05a3d70200		LEAQ 0x2d7a3(IP), AX			
  0x441a83		48890424		MOVQ AX, 0(SP)				
  0x441a87		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x441a90		e85b2dfeff		CALL runtime.printstring(SB)		
  0x441a95		488b442430		MOVQ 0x30(SP), AX			
  0x441a9a		48890424		MOVQ AX, 0(SP)				
  0x441a9e		e80d2cfeff		CALL runtime.printhex(SB)		
  0x441aa3		488d058de40200		LEAQ 0x2e48d(IP), AX			
  0x441aaa		48890424		MOVQ AX, 0(SP)				
  0x441aae		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x441ab7		e8342dfeff		CALL runtime.printstring(SB)		
  0x441abc		e87f24feff		CALL runtime.printunlock(SB)		
  0x441ac1		488d0578de0700		LEAQ runtime.firstmoduledata(SB), AX	
		for next := &firstmoduledata; next != nil; next = next.next {
  0x441ac8		e986000000		JMP 0x441b53		
  0x441acd		4889442450		MOVQ AX, 0x50(SP)	
			println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x441ad2		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x441ad9		48894c2440		MOVQ CX, 0x40(SP)		
  0x441ade		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x441ae5		4889542438		MOVQ DX, 0x38(SP)		
  0x441aea		e8d123feff		CALL runtime.printlock(SB)	
  0x441aef		488d0510d80200		LEAQ 0x2d810(IP), AX		
  0x441af6		48890424		MOVQ AX, 0(SP)			
  0x441afa		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x441b03		e8e82cfeff		CALL runtime.printstring(SB)	
  0x441b08		488b442440		MOVQ 0x40(SP), AX		
  0x441b0d		48890424		MOVQ AX, 0(SP)			
  0x441b11		e89a2bfeff		CALL runtime.printhex(SB)	
  0x441b16		488d05bbd80200		LEAQ 0x2d8bb(IP), AX		
  0x441b1d		48890424		MOVQ AX, 0(SP)			
  0x441b21		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x441b2a		e8c12cfeff		CALL runtime.printstring(SB)	
  0x441b2f		488b442438		MOVQ 0x38(SP), AX		
  0x441b34		48890424		MOVQ AX, 0(SP)			
  0x441b38		e8732bfeff		CALL runtime.printhex(SB)	
  0x441b3d		e80e26feff		CALL runtime.printnl(SB)	
  0x441b42		e8f923feff		CALL runtime.printunlock(SB)	
		for next := &firstmoduledata; next != nil; next = next.next {
  0x441b47		488b442450		MOVQ 0x50(SP), AX	
  0x441b4c		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x441b53		4885c0			TESTQ AX, AX		
  0x441b56		0f8571ffffff		JNE 0x441acd		
  0x441b5c		eb27			JMP 0x441b85		
	return name{(*byte)(res)}
  0x441b5e		488b442448		MOVQ 0x48(SP), AX	
  0x441b63		4889442478		MOVQ AX, 0x78(SP)	
  0x441b68		488b6c2458		MOVQ 0x58(SP), BP	
  0x441b6d		4883c460		ADDQ $0x60, SP		
  0x441b71		c3			RET			
		return name{}
  0x441b72		48c744247800000000	MOVQ $0x0, 0x78(SP)	
  0x441b7b		488b6c2458		MOVQ 0x58(SP), BP	
  0x441b80		4883c460		ADDQ $0x60, SP		
  0x441b84		c3			RET			
		throw("runtime: name offset base pointer out of range")
  0x441b85		488d050e140300		LEAQ 0x3140e(IP), AX	
  0x441b8c		48890424		MOVQ AX, 0(SP)		
  0x441b90		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x441b99		e8e218feff		CALL runtime.throw(SB)	
  0x441b9e		0f0b			UD2			
		if base >= md.types && base < md.etypes {
  0x441ba0		48895c2440		MOVQ BX, 0x40(SP)	
  0x441ba5		4889742438		MOVQ SI, 0x38(SP)	
				println("runtime: nameOff", hex(off), "out of range", hex(md.types), "-", hex(md.etypes))
  0x441baa		e81123feff		CALL runtime.printlock(SB)	
  0x441baf		488d051fe60200		LEAQ 0x2e61f(IP), AX		
  0x441bb6		48890424		MOVQ AX, 0(SP)			
  0x441bba		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x441bc3		e8282cfeff		CALL runtime.printstring(SB)	
  0x441bc8		8b442470		MOVL 0x70(SP), AX		
  0x441bcc		4863c0			MOVSXD AX, AX			
  0x441bcf		48890424		MOVQ AX, 0(SP)			
  0x441bd3		e8d82afeff		CALL runtime.printhex(SB)	
  0x441bd8		488d0533e10200		LEAQ 0x2e133(IP), AX		
  0x441bdf		48890424		MOVQ AX, 0(SP)			
  0x441be3		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x441bec		e8ff2bfeff		CALL runtime.printstring(SB)	
  0x441bf1		488b442440		MOVQ 0x40(SP), AX		
  0x441bf6		48890424		MOVQ AX, 0(SP)			
  0x441bfa		e8b12afeff		CALL runtime.printhex(SB)	
  0x441bff		488d05b6d40200		LEAQ 0x2d4b6(IP), AX		
  0x441c06		48890424		MOVQ AX, 0(SP)			
  0x441c0a		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x441c13		e8d82bfeff		CALL runtime.printstring(SB)	
  0x441c18		488b442438		MOVQ 0x38(SP), AX		
  0x441c1d		48890424		MOVQ AX, 0(SP)			
  0x441c21		e88a2afeff		CALL runtime.printhex(SB)	
  0x441c26		e82525feff		CALL runtime.printnl(SB)	
  0x441c2b		e81023feff		CALL runtime.printunlock(SB)	
				throw("runtime: name offset out of range")
  0x441c30		488d05e8050300		LEAQ 0x305e8(IP), AX	
  0x441c37		48890424		MOVQ AX, 0(SP)		
  0x441c3b		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x441c44		e83718feff		CALL runtime.throw(SB)	
  0x441c49		0f0b			UD2			
func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {
  0x441c4b		e8305c0000		CALL runtime.morestack_noctxt(SB)	
  0x441c50		e90bfdffff		JMP runtime.resolveNameOff(SB)		

TEXT runtime.resolveTypeOff(SB) /usr/local/go/src/runtime/type.go
func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {
  0x441c60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441c69		483b6110		CMPQ 0x10(CX), SP	
  0x441c6d		0f862d030000		JBE 0x441fa0		
  0x441c73		4883ec58		SUBQ $0x58, SP		
  0x441c77		48896c2450		MOVQ BP, 0x50(SP)	
  0x441c7c		488d6c2450		LEAQ 0x50(SP), BP	
	if off == 0 {
  0x441c81		8b442468		MOVL 0x68(SP), AX	
  0x441c85		85c0			TESTL AX, AX		
  0x441c87		0f843a020000		JE 0x441ec7		
	base := uintptr(ptrInModule)
  0x441c8d		488b4c2460		MOVQ 0x60(SP), CX			
  0x441c92		488d15a7dc0700		LEAQ runtime.firstmoduledata(SB), DX	
	for next := &firstmoduledata; next != nil; next = next.next {
  0x441c99		eb07			JMP 0x441ca2		
  0x441c9b		488b92c0010000		MOVQ 0x1c0(DX), DX	
  0x441ca2		4885d2			TESTQ DX, DX		
  0x441ca5		0f8415020000		JE 0x441ec0		
		if base >= next.types && base < next.etypes {
  0x441cab		48398ac8000000		CMPQ CX, 0xc8(DX)	
  0x441cb2		77e7			JA 0x441c9b		
  0x441cb4		48398ad0000000		CMPQ CX, 0xd0(DX)	
  0x441cbb		76de			JBE 0x441c9b		
	if md == nil {
  0x441cbd		4885d2			TESTQ DX, DX		
  0x441cc0		7476			JE 0x441d38		
  0x441cc2		4889542448		MOVQ DX, 0x48(SP)	
	if t := md.typemap[off]; t != nil {
  0x441cc7		488b8ab0010000		MOVQ 0x1b0(DX), CX			
  0x441cce		488d1d8bc40100		LEAQ 0x1c48b(IP), BX			
  0x441cd5		48891c24		MOVQ BX, 0(SP)				
  0x441cd9		48894c2408		MOVQ CX, 0x8(SP)			
  0x441cde		89442410		MOVL AX, 0x10(SP)			
  0x441ce2		e8a9acfcff		CALL runtime.mapaccess1_fast32(SB)	
  0x441ce7		488b442418		MOVQ 0x18(SP), AX			
  0x441cec		488b00			MOVQ 0(AX), AX				
  0x441cef		4885c0			TESTQ AX, AX				
  0x441cf2		7535			JNE 0x441d29				
	res := md.types + uintptr(off)
  0x441cf4		488b442448		MOVQ 0x48(SP), AX	
  0x441cf9		488b88c8000000		MOVQ 0xc8(AX), CX	
  0x441d00		8b542468		MOVL 0x68(SP), DX	
  0x441d04		4863da			MOVSXD DX, BX		
  0x441d07		4801cb			ADDQ CX, BX		
	if res > md.etypes {
  0x441d0a		488b80d0000000		MOVQ 0xd0(AX), AX	
  0x441d11		4839c3			CMPQ AX, BX		
  0x441d14		0f87c0010000		JA 0x441eda		
	return (*_type)(unsafe.Pointer(res))
  0x441d1a		48895c2470		MOVQ BX, 0x70(SP)	
  0x441d1f		488b6c2450		MOVQ 0x50(SP), BP	
  0x441d24		4883c458		ADDQ $0x58, SP		
  0x441d28		c3			RET			
		return t
  0x441d29		4889442470		MOVQ AX, 0x70(SP)	
  0x441d2e		488b6c2450		MOVQ 0x50(SP), BP	
  0x441d33		4883c458		ADDQ $0x58, SP		
  0x441d37		c3			RET			
	base := uintptr(ptrInModule)
  0x441d38		48894c2420		MOVQ CX, 0x20(SP)	
		reflectOffsLock()
  0x441d3d		90			NOPL			
	lock(&reflectOffs.lock)
  0x441d3e		488d05dbfd0700		LEAQ runtime.reflectOffs(SB), AX	
  0x441d45		48890424		MOVQ AX, 0(SP)				
  0x441d49		e89269fcff		CALL runtime.lock(SB)			
		res := reflectOffs.m[int32(off)]
  0x441d4e		488d054bc30100		LEAQ 0x1c34b(IP), AX			
  0x441d55		48890424		MOVQ AX, 0(SP)				
  0x441d59		488b05d0fd0700		MOVQ runtime.reflectOffs+16(SB), AX	
  0x441d60		4889442408		MOVQ AX, 0x8(SP)			
  0x441d65		8b442468		MOVL 0x68(SP), AX			
  0x441d69		89442410		MOVL AX, 0x10(SP)			
  0x441d6d		e81eacfcff		CALL runtime.mapaccess1_fast32(SB)	
  0x441d72		488b442418		MOVQ 0x18(SP), AX			
  0x441d77		488b00			MOVQ 0(AX), AX				
  0x441d7a		4889442438		MOVQ AX, 0x38(SP)			
		reflectOffsUnlock()
  0x441d7f		90			NOPL			
	unlock(&reflectOffs.lock)
  0x441d80		488d0d99fd0700		LEAQ runtime.reflectOffs(SB), CX	
  0x441d87		48890c24		MOVQ CX, 0(SP)				
  0x441d8b		e8006bfcff		CALL runtime.unlock(SB)			
		if res == nil {
  0x441d90		488b442438		MOVQ 0x38(SP), AX	
  0x441d95		4885c0			TESTQ AX, AX		
  0x441d98		0f8513010000		JNE 0x441eb1		
			println("runtime: typeOff", hex(off), "base", hex(base), "not in ranges:")
  0x441d9e		e81d21feff		CALL runtime.printlock(SB)		
  0x441da3		488d056fe40200		LEAQ 0x2e46f(IP), AX			
  0x441daa		48890424		MOVQ AX, 0(SP)				
  0x441dae		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x441db7		e8342afeff		CALL runtime.printstring(SB)		
  0x441dbc		8b442468		MOVL 0x68(SP), AX			
  0x441dc0		4863c0			MOVSXD AX, AX				
  0x441dc3		48890424		MOVQ AX, 0(SP)				
  0x441dc7		e8e428feff		CALL runtime.printhex(SB)		
  0x441dcc		488d0553d40200		LEAQ 0x2d453(IP), AX			
  0x441dd3		48890424		MOVQ AX, 0(SP)				
  0x441dd7		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x441de0		e80b2afeff		CALL runtime.printstring(SB)		
  0x441de5		488b442420		MOVQ 0x20(SP), AX			
  0x441dea		48890424		MOVQ AX, 0(SP)				
  0x441dee		e8bd28feff		CALL runtime.printhex(SB)		
  0x441df3		488d053de10200		LEAQ 0x2e13d(IP), AX			
  0x441dfa		48890424		MOVQ AX, 0(SP)				
  0x441dfe		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x441e07		e8e429feff		CALL runtime.printstring(SB)		
  0x441e0c		e82f21feff		CALL runtime.printunlock(SB)		
  0x441e11		488d0528db0700		LEAQ runtime.firstmoduledata(SB), AX	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x441e18		e986000000		JMP 0x441ea3		
  0x441e1d		4889442440		MOVQ AX, 0x40(SP)	
				println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x441e22		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x441e29		48894c2430		MOVQ CX, 0x30(SP)		
  0x441e2e		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x441e35		4889542428		MOVQ DX, 0x28(SP)		
  0x441e3a		e88120feff		CALL runtime.printlock(SB)	
  0x441e3f		488d05c0d40200		LEAQ 0x2d4c0(IP), AX		
  0x441e46		48890424		MOVQ AX, 0(SP)			
  0x441e4a		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x441e53		e89829feff		CALL runtime.printstring(SB)	
  0x441e58		488b442430		MOVQ 0x30(SP), AX		
  0x441e5d		48890424		MOVQ AX, 0(SP)			
  0x441e61		e84a28feff		CALL runtime.printhex(SB)	
  0x441e66		488d056bd50200		LEAQ 0x2d56b(IP), AX		
  0x441e6d		48890424		MOVQ AX, 0(SP)			
  0x441e71		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x441e7a		e87129feff		CALL runtime.printstring(SB)	
  0x441e7f		488b442428		MOVQ 0x28(SP), AX		
  0x441e84		48890424		MOVQ AX, 0(SP)			
  0x441e88		e82328feff		CALL runtime.printhex(SB)	
  0x441e8d		e8be22feff		CALL runtime.printnl(SB)	
  0x441e92		e8a920feff		CALL runtime.printunlock(SB)	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x441e97		488b442440		MOVQ 0x40(SP), AX	
  0x441e9c		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x441ea3		4885c0			TESTQ AX, AX		
  0x441ea6		0f8571ffffff		JNE 0x441e1d		
  0x441eac		e9d4000000		JMP 0x441f85		
		return (*_type)(res)
  0x441eb1		4889442470		MOVQ AX, 0x70(SP)	
  0x441eb6		488b6c2450		MOVQ 0x50(SP), BP	
  0x441ebb		4883c458		ADDQ $0x58, SP		
  0x441ebf		c3			RET			
  0x441ec0		31d2			XORL DX, DX		
	for next := &firstmoduledata; next != nil; next = next.next {
  0x441ec2		e9f6fdffff		JMP 0x441cbd		
		return nil
  0x441ec7		48c744247000000000	MOVQ $0x0, 0x70(SP)	
  0x441ed0		488b6c2450		MOVQ 0x50(SP), BP	
  0x441ed5		4883c458		ADDQ $0x58, SP		
  0x441ed9		c3			RET			
	res := md.types + uintptr(off)
  0x441eda		48894c2430		MOVQ CX, 0x30(SP)	
	if res > md.etypes {
  0x441edf		4889442428		MOVQ AX, 0x28(SP)	
		println("runtime: typeOff", hex(off), "out of range", hex(md.types), "-", hex(md.etypes))
  0x441ee4		e8d71ffeff		CALL runtime.printlock(SB)	
  0x441ee9		488d0529e30200		LEAQ 0x2e329(IP), AX		
  0x441ef0		48890424		MOVQ AX, 0(SP)			
  0x441ef4		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x441efd		e8ee28feff		CALL runtime.printstring(SB)	
  0x441f02		8b442468		MOVL 0x68(SP), AX		
  0x441f06		4863c0			MOVSXD AX, AX			
  0x441f09		48890424		MOVQ AX, 0(SP)			
  0x441f0d		e89e27feff		CALL runtime.printhex(SB)	
  0x441f12		488d05f9dd0200		LEAQ 0x2ddf9(IP), AX		
  0x441f19		48890424		MOVQ AX, 0(SP)			
  0x441f1d		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x441f26		e8c528feff		CALL runtime.printstring(SB)	
  0x441f2b		488b442430		MOVQ 0x30(SP), AX		
  0x441f30		48890424		MOVQ AX, 0(SP)			
  0x441f34		e87727feff		CALL runtime.printhex(SB)	
  0x441f39		488d057cd10200		LEAQ 0x2d17c(IP), AX		
  0x441f40		48890424		MOVQ AX, 0(SP)			
  0x441f44		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x441f4d		e89e28feff		CALL runtime.printstring(SB)	
  0x441f52		488b442428		MOVQ 0x28(SP), AX		
  0x441f57		48890424		MOVQ AX, 0(SP)			
  0x441f5b		e85027feff		CALL runtime.printhex(SB)	
  0x441f60		e8eb21feff		CALL runtime.printnl(SB)	
  0x441f65		e8d61ffeff		CALL runtime.printunlock(SB)	
		throw("runtime: type offset out of range")
  0x441f6a		488d05f0020300		LEAQ 0x302f0(IP), AX	
  0x441f71		48890424		MOVQ AX, 0(SP)		
  0x441f75		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x441f7e		e8fd14feff		CALL runtime.throw(SB)	
  0x441f83		0f0b			UD2			
			throw("runtime: type offset base pointer out of range")
  0x441f85		488d0598100300		LEAQ 0x31098(IP), AX	
  0x441f8c		48890424		MOVQ AX, 0(SP)		
  0x441f90		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x441f99		e8e214feff		CALL runtime.throw(SB)	
  0x441f9e		0f0b			UD2			
func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {
  0x441fa0		e8db580000		CALL runtime.morestack_noctxt(SB)	
  0x441fa5		e9b6fcffff		JMP runtime.resolveTypeOff(SB)		

TEXT runtime.(*_type).textOff(SB) /usr/local/go/src/runtime/type.go
func (t *_type) textOff(off textOff) unsafe.Pointer {
  0x441fb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x441fb9		483b6110		CMPQ 0x10(CX), SP	
  0x441fbd		0f8615030000		JBE 0x4422d8		
  0x441fc3		4883ec50		SUBQ $0x50, SP		
  0x441fc7		48896c2448		MOVQ BP, 0x48(SP)	
  0x441fcc		488d6c2448		LEAQ 0x48(SP), BP	
	base := uintptr(unsafe.Pointer(t))
  0x441fd1		488b442458		MOVQ 0x58(SP), AX			
  0x441fd6		488d0d63d90700		LEAQ runtime.firstmoduledata(SB), CX	
	for next := &firstmoduledata; next != nil; next = next.next {
  0x441fdd		eb07			JMP 0x441fe6		
  0x441fdf		488b89c0010000		MOVQ 0x1c0(CX), CX	
  0x441fe6		4885c9			TESTQ CX, CX		
  0x441fe9		0f8418020000		JE 0x442207		
		if base >= next.types && base < next.etypes {
  0x441fef		483981c8000000		CMPQ AX, 0xc8(CX)	
  0x441ff6		77e7			JA 0x441fdf		
  0x441ff8		483981d0000000		CMPQ AX, 0xd0(CX)	
  0x441fff		76de			JBE 0x441fdf		
	if md == nil {
  0x442001		4885c9			TESTQ CX, CX		
  0x442004		7479			JE 0x44207f		
	if len(md.textsectmap) > 1 {
  0x442006		488b81d8000000		MOVQ 0xd8(CX), AX	
  0x44200d		488b91e0000000		MOVQ 0xe0(CX), DX	
  0x442014		4883fa01		CMPQ $0x1, DX		
  0x442018		7e58			JLE 0x442072		
		for i := range md.textsectmap {
  0x44201a		8b5c2460		MOVL 0x60(SP), BX	
  0x44201e		31f6			XORL SI, SI		
  0x442020		eb03			JMP 0x442025		
  0x442022		48ffc6			INCQ SI			
  0x442025		4839d6			CMPQ DX, SI		
  0x442028		7d44			JGE 0x44206e		
			sectaddr := md.textsectmap[i].vaddr
  0x44202a		488d3c76		LEAQ 0(SI)(SI*2), DI	
  0x44202e		4c8b04f8		MOVQ 0(AX)(DI*8), R8	
			sectlen := md.textsectmap[i].length
  0x442032		4c8b4cf808		MOVQ 0x8(AX)(DI*8), R9	
			if uintptr(off) >= sectaddr && uintptr(off) <= sectaddr+sectlen {
  0x442037		4c63d3			MOVSXD BX, R10		
  0x44203a		4d39c2			CMPQ R8, R10		
  0x44203d		72e3			JB 0x442022		
  0x44203f		4d01c1			ADDQ R8, R9		
  0x442042		4d39ca			CMPQ R9, R10		
  0x442045		77db			JA 0x442022		
				res = md.textsectmap[i].baseaddr + uintptr(off) - uintptr(md.textsectmap[i].vaddr)
  0x442047		488b44f810		MOVQ 0x10(AX)(DI*8), AX	
  0x44204c		4c01d0			ADDQ R10, AX		
  0x44204f		4c29c0			SUBQ R8, AX		
	if res > md.etext && GOARCH != "wasm" { // on wasm, functions do not live in the same address space as the linear memory
  0x442052		488b5168		MOVQ 0x68(CX), DX	
  0x442056		4839d0			CMPQ DX, AX		
  0x442059		0f87af010000		JA 0x44220e		
	return unsafe.Pointer(res)
  0x44205f		4889442468		MOVQ AX, 0x68(SP)	
  0x442064		488b6c2448		MOVQ 0x48(SP), BP	
  0x442069		4883c450		ADDQ $0x50, SP		
  0x44206d		c3			RET			
  0x44206e		31c0			XORL AX, AX		
		for i := range md.textsectmap {
  0x442070		ebe0			JMP 0x442052		
		res = md.text + uintptr(off)
  0x442072		8b5c2460		MOVL 0x60(SP), BX	
  0x442076		4863c3			MOVSXD BX, AX		
  0x442079		48034160		ADDQ 0x60(CX), AX	
  0x44207d		ebd3			JMP 0x442052		
	base := uintptr(unsafe.Pointer(t))
  0x44207f		4889442420		MOVQ AX, 0x20(SP)	
		reflectOffsLock()
  0x442084		90			NOPL			
	lock(&reflectOffs.lock)
  0x442085		488d0594fa0700		LEAQ runtime.reflectOffs(SB), AX	
  0x44208c		48890424		MOVQ AX, 0(SP)				
  0x442090		e84b66fcff		CALL runtime.lock(SB)			
		res := reflectOffs.m[int32(off)]
  0x442095		488d0504c00100		LEAQ 0x1c004(IP), AX			
  0x44209c		48890424		MOVQ AX, 0(SP)				
  0x4420a0		488b0589fa0700		MOVQ runtime.reflectOffs+16(SB), AX	
  0x4420a7		4889442408		MOVQ AX, 0x8(SP)			
  0x4420ac		8b442460		MOVL 0x60(SP), AX			
  0x4420b0		89442410		MOVL AX, 0x10(SP)			
  0x4420b4		e8d7a8fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x4420b9		488b442418		MOVQ 0x18(SP), AX			
  0x4420be		488b00			MOVQ 0(AX), AX				
  0x4420c1		4889442438		MOVQ AX, 0x38(SP)			
		reflectOffsUnlock()
  0x4420c6		90			NOPL			
	unlock(&reflectOffs.lock)
  0x4420c7		488d0d52fa0700		LEAQ runtime.reflectOffs(SB), CX	
  0x4420ce		48890c24		MOVQ CX, 0(SP)				
  0x4420d2		e8b967fcff		CALL runtime.unlock(SB)			
		if res == nil {
  0x4420d7		488b442438		MOVQ 0x38(SP), AX	
  0x4420dc		4885c0			TESTQ AX, AX		
  0x4420df		0f8513010000		JNE 0x4421f8		
			println("runtime: textOff", hex(off), "base", hex(base), "not in ranges:")
  0x4420e5		e8d61dfeff		CALL runtime.printlock(SB)		
  0x4420ea		488d0517e10200		LEAQ 0x2e117(IP), AX			
  0x4420f1		48890424		MOVQ AX, 0(SP)				
  0x4420f5		48c744240811000000	MOVQ $0x11, 0x8(SP)			
  0x4420fe		e8ed26feff		CALL runtime.printstring(SB)		
  0x442103		8b442460		MOVL 0x60(SP), AX			
  0x442107		4863c0			MOVSXD AX, AX				
  0x44210a		48890424		MOVQ AX, 0(SP)				
  0x44210e		e89d25feff		CALL runtime.printhex(SB)		
  0x442113		488d050cd10200		LEAQ 0x2d10c(IP), AX			
  0x44211a		48890424		MOVQ AX, 0(SP)				
  0x44211e		48c744240806000000	MOVQ $0x6, 0x8(SP)			
  0x442127		e8c426feff		CALL runtime.printstring(SB)		
  0x44212c		488b442420		MOVQ 0x20(SP), AX			
  0x442131		48890424		MOVQ AX, 0(SP)				
  0x442135		e87625feff		CALL runtime.printhex(SB)		
  0x44213a		488d05f6dd0200		LEAQ 0x2ddf6(IP), AX			
  0x442141		48890424		MOVQ AX, 0(SP)				
  0x442145		48c744240810000000	MOVQ $0x10, 0x8(SP)			
  0x44214e		e89d26feff		CALL runtime.printstring(SB)		
  0x442153		e8e81dfeff		CALL runtime.printunlock(SB)		
  0x442158		488d05e1d70700		LEAQ runtime.firstmoduledata(SB), AX	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x44215f		e986000000		JMP 0x4421ea		
  0x442164		4889442440		MOVQ AX, 0x40(SP)	
				println("\ttypes", hex(next.types), "etypes", hex(next.etypes))
  0x442169		488b88c8000000		MOVQ 0xc8(AX), CX		
  0x442170		48894c2430		MOVQ CX, 0x30(SP)		
  0x442175		488b90d0000000		MOVQ 0xd0(AX), DX		
  0x44217c		4889542428		MOVQ DX, 0x28(SP)		
  0x442181		e83a1dfeff		CALL runtime.printlock(SB)	
  0x442186		488d0579d10200		LEAQ 0x2d179(IP), AX		
  0x44218d		48890424		MOVQ AX, 0(SP)			
  0x442191		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x44219a		e85126feff		CALL runtime.printstring(SB)	
  0x44219f		488b442430		MOVQ 0x30(SP), AX		
  0x4421a4		48890424		MOVQ AX, 0(SP)			
  0x4421a8		e80325feff		CALL runtime.printhex(SB)	
  0x4421ad		488d0524d20200		LEAQ 0x2d224(IP), AX		
  0x4421b4		48890424		MOVQ AX, 0(SP)			
  0x4421b8		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x4421c1		e82a26feff		CALL runtime.printstring(SB)	
  0x4421c6		488b442428		MOVQ 0x28(SP), AX		
  0x4421cb		48890424		MOVQ AX, 0(SP)			
  0x4421cf		e8dc24feff		CALL runtime.printhex(SB)	
  0x4421d4		e8771ffeff		CALL runtime.printnl(SB)	
  0x4421d9		e8621dfeff		CALL runtime.printunlock(SB)	
			for next := &firstmoduledata; next != nil; next = next.next {
  0x4421de		488b442440		MOVQ 0x40(SP), AX	
  0x4421e3		488b80c0010000		MOVQ 0x1c0(AX), AX	
  0x4421ea		4885c0			TESTQ AX, AX		
  0x4421ed		0f8571ffffff		JNE 0x442164		
  0x4421f3		e9c5000000		JMP 0x4422bd		
		return res
  0x4421f8		4889442468		MOVQ AX, 0x68(SP)	
  0x4421fd		488b6c2448		MOVQ 0x48(SP), BP	
  0x442202		4883c450		ADDQ $0x50, SP		
  0x442206		c3			RET			
  0x442207		31c9			XORL CX, CX		
	for next := &firstmoduledata; next != nil; next = next.next {
  0x442209		e9f3fdffff		JMP 0x442001		
	if res > md.etext && GOARCH != "wasm" { // on wasm, functions do not live in the same address space as the linear memory
  0x44220e		4889542430		MOVQ DX, 0x30(SP)	
		println("runtime: textOff", hex(off), "out of range", hex(md.text), "-", hex(md.etext))
  0x442213		488b4160		MOVQ 0x60(CX), AX		
  0x442217		4889442428		MOVQ AX, 0x28(SP)		
  0x44221c		e89f1cfeff		CALL runtime.printlock(SB)	
  0x442221		488d05e0df0200		LEAQ 0x2dfe0(IP), AX		
  0x442228		48890424		MOVQ AX, 0(SP)			
  0x44222c		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x442235		e8b625feff		CALL runtime.printstring(SB)	
  0x44223a		8b442460		MOVL 0x60(SP), AX		
  0x44223e		4863c0			MOVSXD AX, AX			
  0x442241		48890424		MOVQ AX, 0(SP)			
  0x442245		e86624feff		CALL runtime.printhex(SB)	
  0x44224a		488d05c1da0200		LEAQ 0x2dac1(IP), AX		
  0x442251		48890424		MOVQ AX, 0(SP)			
  0x442255		48c74424080e000000	MOVQ $0xe, 0x8(SP)		
  0x44225e		e88d25feff		CALL runtime.printstring(SB)	
  0x442263		488b442428		MOVQ 0x28(SP), AX		
  0x442268		48890424		MOVQ AX, 0(SP)			
  0x44226c		e83f24feff		CALL runtime.printhex(SB)	
  0x442271		488d0544ce0200		LEAQ 0x2ce44(IP), AX		
  0x442278		48890424		MOVQ AX, 0(SP)			
  0x44227c		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x442285		e86625feff		CALL runtime.printstring(SB)	
  0x44228a		488b442430		MOVQ 0x30(SP), AX		
  0x44228f		48890424		MOVQ AX, 0(SP)			
  0x442293		e81824feff		CALL runtime.printhex(SB)	
  0x442298		e8b31efeff		CALL runtime.printnl(SB)	
  0x44229d		e89e1cfeff		CALL runtime.printunlock(SB)	
		throw("runtime: text offset out of range")
  0x4422a2		488d0597ff0200		LEAQ 0x2ff97(IP), AX	
  0x4422a9		48890424		MOVQ AX, 0(SP)		
  0x4422ad		48c744240821000000	MOVQ $0x21, 0x8(SP)	
  0x4422b6		e8c511feff		CALL runtime.throw(SB)	
  0x4422bb		0f0b			UD2			
			throw("runtime: text offset base pointer out of range")
  0x4422bd		488d05320d0300		LEAQ 0x30d32(IP), AX	
  0x4422c4		48890424		MOVQ AX, 0(SP)		
  0x4422c8		48c74424082e000000	MOVQ $0x2e, 0x8(SP)	
  0x4422d1		e8aa11feff		CALL runtime.throw(SB)	
  0x4422d6		0f0b			UD2			
func (t *_type) textOff(off textOff) unsafe.Pointer {
  0x4422d8		e8a3550000		CALL runtime.morestack_noctxt(SB)	
  0x4422dd		e9cefcffff		JMP runtime.(*_type).textOff(SB)	

TEXT runtime.name.tagLen(SB) /usr/local/go/src/runtime/type.go
	if *n.data(0)&(1<<1) == 0 {
  0x4422f0		488b442408		MOVQ 0x8(SP), AX	
  0x4422f5		0fb608			MOVZX 0(AX), CX		
  0x4422f8		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x4422f9		90			NOPL			
	if *n.data(0)&(1<<1) == 0 {
  0x4422fa		f6c102			TESTL $0x2, CL		
  0x4422fd		750a			JNE 0x442309		
		return 0
  0x4422ff		48c744241000000000	MOVQ $0x0, 0x10(SP)	
  0x442308		c3			RET			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x442309		0fb74801		MOVZX 0x1(AX), CX	
  0x44230d		66c1c108		ROLW $0x8, CX		
  0x442311		0fb7c9			MOVZX CX, CX		
	return unsafe.Pointer(uintptr(p) + x)
  0x442314		488d1401		LEAQ 0(CX)(AX*1), DX	
  0x442318		488d5203		LEAQ 0x3(DX), DX	
  0x44231c		488d0401		LEAQ 0(CX)(AX*1), AX	
  0x442320		488d4004		LEAQ 0x4(AX), AX	
	off := 3 + n.nameLen()
  0x442324		90			NOPL			
	return int(uint16(*n.data(off))<<8 | uint16(*n.data(off + 1)))
  0x442325		0fb60a			MOVZX 0(DX), CX		
  0x442328		90			NOPL			
  0x442329		0fb600			MOVZX 0(AX), AX		
  0x44232c		90			NOPL			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x44232d		90			NOPL			
  0x44232e		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x44232f		90			NOPL			
  0x442330		90			NOPL			
  0x442331		90			NOPL			
  0x442332		90			NOPL			
	return int(uint16(*n.data(off))<<8 | uint16(*n.data(off + 1)))
  0x442333		c1e108			SHLL $0x8, CX		
  0x442336		09c8			ORL CX, AX		
  0x442338		0fb7c0			MOVZX AX, AX		
  0x44233b		4889442410		MOVQ AX, 0x10(SP)	
  0x442340		c3			RET			

TEXT runtime.name.name(SB) /usr/local/go/src/runtime/type.go
func (n name) name() (s string) {
  0x442350		0f57c0			XORPS X0, X0		
  0x442353		0f11442410		MOVUPS X0, 0x10(SP)	
	if n.bytes == nil {
  0x442358		488b442408		MOVQ 0x8(SP), AX	
  0x44235d		4885c0			TESTQ AX, AX		
  0x442360		742c			JE 0x44238e		
	nl := n.nameLen()
  0x442362		90			NOPL			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x442363		0fb74801		MOVZX 0x1(AX), CX	
  0x442367		66c1c108		ROLW $0x8, CX		
  0x44236b		0fb7c9			MOVZX CX, CX		
  0x44236e		90			NOPL			
  0x44236f		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x442370		90			NOPL			
  0x442371		90			NOPL			
	if nl == 0 {
  0x442372		4885c9			TESTQ CX, CX		
  0x442375		7506			JNE 0x44237d		
		return ""
  0x442377		0f11442410		MOVUPS X0, 0x10(SP)	
  0x44237c		c3			RET			
	hdr.str = unsafe.Pointer(n.data(3))
  0x44237d		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x44237e		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x44237f		4883c003		ADDQ $0x3, AX		
	hdr.str = unsafe.Pointer(n.data(3))
  0x442383		4889442410		MOVQ AX, 0x10(SP)	
	hdr.len = nl
  0x442388		48894c2418		MOVQ CX, 0x18(SP)	
	return s
  0x44238d		c3			RET			
		return ""
  0x44238e		0f11442410		MOVUPS X0, 0x10(SP)	
  0x442393		c3			RET			

TEXT runtime.name.tag(SB) /usr/local/go/src/runtime/type.go
func (n name) tag() (s string) {
  0x4423a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4423a9		483b6110		CMPQ 0x10(CX), SP	
  0x4423ad		7673			JBE 0x442422		
  0x4423af		4883ec18		SUBQ $0x18, SP		
  0x4423b3		48896c2410		MOVQ BP, 0x10(SP)	
  0x4423b8		488d6c2410		LEAQ 0x10(SP), BP	
  0x4423bd		0f57c0			XORPS X0, X0		
  0x4423c0		0f11442428		MOVUPS X0, 0x28(SP)	
	tl := n.tagLen()
  0x4423c5		488b442420		MOVQ 0x20(SP), AX		
  0x4423ca		48890424		MOVQ AX, 0(SP)			
  0x4423ce		e81dffffff		CALL runtime.name.tagLen(SB)	
  0x4423d3		488b442408		MOVQ 0x8(SP), AX		
	if tl == 0 {
  0x4423d8		4885c0			TESTQ AX, AX		
  0x4423db		7512			JNE 0x4423ef		
		return ""
  0x4423dd		0f57c0			XORPS X0, X0		
  0x4423e0		0f11442428		MOVUPS X0, 0x28(SP)	
  0x4423e5		488b6c2410		MOVQ 0x10(SP), BP	
  0x4423ea		4883c418		ADDQ $0x18, SP		
  0x4423ee		c3			RET			
	nl := n.nameLen()
  0x4423ef		90			NOPL			
	hdr.str = unsafe.Pointer(n.data(3 + nl + 2))
  0x4423f0		90			NOPL			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x4423f1		488b4c2420		MOVQ 0x20(SP), CX	
  0x4423f6		0fb75101		MOVZX 0x1(CX), DX	
  0x4423fa		66c1c208		ROLW $0x8, DX		
  0x4423fe		0fb7d2			MOVZX DX, DX		
  0x442401		90			NOPL			
  0x442402		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x442403		90			NOPL			
  0x442404		90			NOPL			
  0x442405		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x442406		488d0c0a		LEAQ 0(DX)(CX*1), CX	
  0x44240a		488d4905		LEAQ 0x5(CX), CX	
	hdr.str = unsafe.Pointer(n.data(3 + nl + 2))
  0x44240e		48894c2428		MOVQ CX, 0x28(SP)	
	hdr.len = tl
  0x442413		4889442430		MOVQ AX, 0x30(SP)	
	return s
  0x442418		488b6c2410		MOVQ 0x10(SP), BP	
  0x44241d		4883c418		ADDQ $0x18, SP		
  0x442421		c3			RET			
func (n name) tag() (s string) {
  0x442422		e859540000		CALL runtime.morestack_noctxt(SB)	
  0x442427		e974ffffff		JMP runtime.name.tag(SB)		

TEXT runtime.name.pkgPath(SB) /usr/local/go/src/runtime/type.go
func (n name) pkgPath() string {
  0x442430		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442439		483b6110		CMPQ 0x10(CX), SP	
  0x44243d		0f86d3000000		JBE 0x442516		
  0x442443		4883ec28		SUBQ $0x28, SP		
  0x442447		48896c2420		MOVQ BP, 0x20(SP)	
  0x44244c		488d6c2420		LEAQ 0x20(SP), BP	
	if n.bytes == nil || *n.data(0)&(1<<2) == 0 {
  0x442451		488b442430		MOVQ 0x30(SP), AX	
  0x442456		4885c0			TESTQ AX, AX		
  0x442459		740a			JE 0x442465		
  0x44245b		0fb608			MOVZX 0(AX), CX		
  0x44245e		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x44245f		90			NOPL			
	if n.bytes == nil || *n.data(0)&(1<<2) == 0 {
  0x442460		f6c104			TESTL $0x4, CL		
  0x442463		7512			JNE 0x442477		
		return ""
  0x442465		0f57c0			XORPS X0, X0		
  0x442468		0f11442438		MOVUPS X0, 0x38(SP)	
  0x44246d		488b6c2420		MOVQ 0x20(SP), BP	
  0x442472		4883c428		ADDQ $0x28, SP		
  0x442476		c3			RET			
	off := 3 + n.nameLen()
  0x442477		90			NOPL			
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x442478		90			NOPL			
  0x442479		0fb74801		MOVZX 0x1(AX), CX	
  0x44247d		66894c241a		MOVW CX, 0x1a(SP)	
  0x442482		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x442483		90			NOPL			
  0x442484		90			NOPL			
	if tl := n.tagLen(); tl > 0 {
  0x442485		48890424		MOVQ AX, 0(SP)			
  0x442489		e862feffff		CALL runtime.name.tagLen(SB)	
	return int(uint16(*n.data(1))<<8 | uint16(*n.data(2)))
  0x44248e		0fb744241a		MOVZX 0x1a(SP), AX	
  0x442493		66c1c008		ROLW $0x8, AX		
  0x442497		0fb7c0			MOVZX AX, AX		
	off := 3 + n.nameLen()
  0x44249a		488d4803		LEAQ 0x3(AX), CX	
	if tl := n.tagLen(); tl > 0 {
  0x44249e		488b542408		MOVQ 0x8(SP), DX	
  0x4424a3		4885d2			TESTQ DX, DX		
  0x4424a6		7e69			JLE 0x442511		
		off += 2 + tl
  0x4424a8		488d0402		LEAQ 0(DX)(AX*1), AX	
  0x4424ac		488d4005		LEAQ 0x5(AX), AX	
	var nameOff nameOff
  0x4424b0		c744241c00000000	MOVL $0x0, 0x1c(SP)	
	copy((*[4]byte)(unsafe.Pointer(&nameOff))[:], (*[4]byte)(unsafe.Pointer(n.data(off)))[:])
  0x4424b8		90			NOPL			
	return (*byte)(add(unsafe.Pointer(n.bytes), uintptr(off)))
  0x4424b9		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x4424ba		488b4c2430		MOVQ 0x30(SP), CX	
  0x4424bf		488d1408		LEAQ 0(AX)(CX*1), DX	
	copy((*[4]byte)(unsafe.Pointer(&nameOff))[:], (*[4]byte)(unsafe.Pointer(n.data(off)))[:])
  0x4424c3		488d5c241c		LEAQ 0x1c(SP), BX	
  0x4424c8		4839d3			CMPQ DX, BX		
  0x4424cb		7407			JE 0x4424d4		
  0x4424cd		8b0408			MOVL 0(AX)(CX*1), AX	
  0x4424d0		8944241c		MOVL AX, 0x1c(SP)	
	pkgPathName := resolveNameOff(unsafe.Pointer(n.bytes), nameOff)
  0x4424d4		48890c24		MOVQ CX, 0(SP)			
  0x4424d8		8b44241c		MOVL 0x1c(SP), AX		
  0x4424dc		89442408		MOVL AX, 0x8(SP)		
  0x4424e0		e87bf4ffff		CALL runtime.resolveNameOff(SB)	
  0x4424e5		488b442410		MOVQ 0x10(SP), AX		
	return pkgPathName.name()
  0x4424ea		48890424		MOVQ AX, 0(SP)			
  0x4424ee		e85dfeffff		CALL runtime.name.name(SB)	
  0x4424f3		488b442410		MOVQ 0x10(SP), AX		
  0x4424f8		488b4c2408		MOVQ 0x8(SP), CX		
  0x4424fd		48894c2438		MOVQ CX, 0x38(SP)		
  0x442502		4889442440		MOVQ AX, 0x40(SP)		
  0x442507		488b6c2420		MOVQ 0x20(SP), BP		
  0x44250c		4883c428		ADDQ $0x28, SP			
  0x442510		c3			RET				
	copy((*[4]byte)(unsafe.Pointer(&nameOff))[:], (*[4]byte)(unsafe.Pointer(n.data(off)))[:])
  0x442511		4889c8			MOVQ CX, AX		
	if tl := n.tagLen(); tl > 0 {
  0x442514		eb9a			JMP 0x4424b0		
func (n name) pkgPath() string {
  0x442516		e865530000		CALL runtime.morestack_noctxt(SB)	
  0x44251b		e910ffffff		JMP runtime.name.pkgPath(SB)		

TEXT runtime.typelinksinit(SB) /usr/local/go/src/runtime/type.go
func typelinksinit() {
  0x442520		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442529		488d8424c0fdffff	LEAQ 0xfffffdc0(SP), AX	
  0x442531		483b4110		CMPQ 0x10(CX), AX	
  0x442535		0f8672060000		JBE 0x442bad		
  0x44253b		4881ecc0020000		SUBQ $0x2c0, SP		
  0x442542		4889ac24b8020000	MOVQ BP, 0x2b8(SP)	
  0x44254a		488dac24b8020000	LEAQ 0x2b8(SP), BP	
	if firstmoduledata.next == nil {
  0x442552		48833da6d5070000	CMPQ $0x0, runtime.firstmoduledata+448(SB)	
  0x44255a		0f8436060000		JE 0x442b96					
	typehash := make(map[uint32][]*_type, len(firstmoduledata.typelinks))
  0x442560		488b05d1d40700		MOVQ runtime.firstmoduledata+248(SB), AX	
  0x442567		0f57c0			XORPS X0, X0					
  0x44256a		0f11842408010000	MOVUPS X0, 0x108(SP)				
  0x442572		0f11842418010000	MOVUPS X0, 0x118(SP)				
  0x44257a		0f11842428010000	MOVUPS X0, 0x128(SP)				
  0x442582		488dbc24c8010000	LEAQ 0x1c8(SP), DI				
  0x44258a		488d7ff0		LEAQ -0x10(DI), DI				
  0x44258e		48896c24f0		MOVQ BP, -0x10(SP)				
  0x442593		488d6c24f0		LEAQ -0x10(SP), BP				
  0x442598		e83a7b0000		CALL 0x44a0d7					
  0x44259d		488b6d00		MOVQ 0(BP), BP					
  0x4425a1		488d8c24c8010000	LEAQ 0x1c8(SP), CX				
  0x4425a9		48898c2418010000	MOVQ CX, 0x118(SP)				
  0x4425b1		488d0d68bc0100		LEAQ 0x1bc68(IP), CX				
  0x4425b8		48890c24		MOVQ CX, 0(SP)					
  0x4425bc		4889442408		MOVQ AX, 0x8(SP)				
  0x4425c1		488d842408010000	LEAQ 0x108(SP), AX				
  0x4425c9		4889442410		MOVQ AX, 0x10(SP)				
  0x4425ce		e8ed8cfcff		CALL runtime.makemap(SB)			
  0x4425d3		488b442418		MOVQ 0x18(SP), AX				
	modules := activeModules()
  0x4425d8		90			NOPL			
	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&modulesSlice)))
  0x4425d9		488b0d98f30700		MOVQ runtime.modulesSlice(SB), CX	
	if p == nil {
  0x4425e0		4885c9			TESTQ CX, CX		
  0x4425e3		0f84a2050000		JE 0x442b8b		
	return *p
  0x4425e9		488b5108		MOVQ 0x8(CX), DX	
  0x4425ed		488b5910		MOVQ 0x10(CX), BX	
  0x4425f1		488b09			MOVQ 0(CX), CX		
	prev := modules[0]
  0x4425f4		4885d2			TESTQ DX, DX		
  0x4425f7		0f86a9050000		JBE 0x442ba6		
	typehash := make(map[uint32][]*_type, len(firstmoduledata.typelinks))
  0x4425fd		4889842480000000	MOVQ AX, 0x80(SP)	
	prev := modules[0]
  0x442605		488b31			MOVQ 0(CX), SI		
	for _, md := range modules[1:] {
  0x442608		48ffcb			DECQ BX			
  0x44260b		48f7db			NEGQ BX			
  0x44260e		48c1fb3f		SARQ $0x3f, BX		
  0x442612		4883e308		ANDQ $0x8, BX		
  0x442616		4801d9			ADDQ BX, CX		
  0x442619		48898c24d0000000	MOVQ CX, 0xd0(SP)	
  0x442621		48ffca			DECQ DX			
  0x442624		4889542478		MOVQ DX, 0x78(SP)	
  0x442629		31db			XORL BX, BX		
  0x44262b		e9f2010000		JMP 0x442822		
			for _, tcur := range tlist {
  0x442630		48ffc6			INCQ SI			
  0x442633		4839c6			CMPQ AX, SI		
  0x442636		0f8db9000000		JGE 0x4426f5		
  0x44263c		4c8b04f2		MOVQ 0(DX)(SI*8), R8	
				if tcur == t {
  0x442640		4939d8			CMPQ BX, R8		
  0x442643		75eb			JNE 0x442630		
		for _, tl := range prev.typelinks {
  0x442645		4c8b5c2460		MOVQ 0x60(SP), R11	
  0x44264a		4d8d5301		LEAQ 0x1(R11), R10	
			tlist := typehash[t.hash]
  0x44264e		488b842480000000	MOVQ 0x80(SP), AX	
	for _, md := range modules[1:] {
  0x442656		488b8c24d0000000	MOVQ 0xd0(SP), CX	
  0x44265e		488b542478		MOVQ 0x78(SP), DX	
  0x442663		488b5c2470		MOVQ 0x70(SP), BX	
			if prev.typemap == nil {
  0x442668		488bb424a0000000	MOVQ 0xa0(SP), SI	
		if md.typemap == nil {
  0x442670		488bbc24a8000000	MOVQ 0xa8(SP), DI	
		for _, tl := range prev.typelinks {
  0x442678		4c8b8424c8000000	MOVQ 0xc8(SP), R8	
  0x442680		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x442685		4d39ca			CMPQ R9, R10		
  0x442688		0f8d84010000		JGE 0x442812		
  0x44268e		4c89542460		MOVQ R10, 0x60(SP)	
  0x442693		478b1c90		MOVL 0(R8)(R10*4), R11	
			if prev.typemap == nil {
  0x442697		4c8ba6b0010000		MOVQ 0x1b0(SI), R12	
  0x44269e		4d85e4			TESTQ R12, R12		
  0x4426a1		0f853c010000		JNE 0x4427e3		
				t = (*_type)(unsafe.Pointer(prev.types + uintptr(tl)))
  0x4426a7		4d63db			MOVSXD R11, R11		
  0x4426aa		4c039ec8000000		ADDQ 0xc8(SI), R11	
			tlist := typehash[t.hash]
  0x4426b1		4c899c2490000000	MOVQ R11, 0x90(SP)			
  0x4426b9		418b4b10		MOVL 0x10(R11), CX			
  0x4426bd		488d155cbb0100		LEAQ 0x1bb5c(IP), DX			
  0x4426c4		48891424		MOVQ DX, 0(SP)				
  0x4426c8		4889442408		MOVQ AX, 0x8(SP)			
  0x4426cd		894c2410		MOVL CX, 0x10(SP)			
  0x4426d1		e8baa2fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x4426d6		488b442418		MOVQ 0x18(SP), AX			
  0x4426db		488b4810		MOVQ 0x10(AX), CX			
  0x4426df		488b10			MOVQ 0(AX), DX				
  0x4426e2		488b4008		MOVQ 0x8(AX), AX			
			for _, tcur := range tlist {
  0x4426e6		488b9c2490000000	MOVQ 0x90(SP), BX	
  0x4426ee		31f6			XORL SI, SI		
  0x4426f0		e93effffff		JMP 0x442633		
			typehash[t.hash] = append(tlist, t)
  0x4426f5		488d7001		LEAQ 0x1(AX), SI			
  0x4426f9		4839ce			CMPQ CX, SI				
  0x4426fc		0f8793000000		JA 0x442795				
  0x442702		48899424c0000000	MOVQ DX, 0xc0(SP)			
  0x44270a		4889742458		MOVQ SI, 0x58(SP)			
  0x44270f		48894c2450		MOVQ CX, 0x50(SP)			
  0x442714		488d3cc2		LEAQ 0(DX)(AX*8), DI			
  0x442718		833d01a7090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44271f		756a			JNE 0x44278b				
  0x442721		48891cc2		MOVQ BX, 0(DX)(AX*8)			
  0x442725		8b4310			MOVL 0x10(BX), AX			
  0x442728		488d0df1ba0100		LEAQ 0x1baf1(IP), CX			
  0x44272f		48890c24		MOVQ CX, 0(SP)				
  0x442733		488b942480000000	MOVQ 0x80(SP), DX			
  0x44273b		4889542408		MOVQ DX, 0x8(SP)			
  0x442740		89442410		MOVL AX, 0x10(SP)			
  0x442744		e8d7a5fcff		CALL runtime.mapassign_fast32(SB)	
  0x442749		488b7c2418		MOVQ 0x18(SP), DI			
  0x44274e		488b442458		MOVQ 0x58(SP), AX			
  0x442753		48894708		MOVQ AX, 0x8(DI)			
  0x442757		488b442450		MOVQ 0x50(SP), AX			
  0x44275c		48894710		MOVQ AX, 0x10(DI)			
  0x442760		833db9a6090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x442767		7510			JNE 0x442779				
  0x442769		488b8424c0000000	MOVQ 0xc0(SP), AX			
  0x442771		488907			MOVQ AX, 0(DI)				
  0x442774		e9ccfeffff		JMP 0x442645				
  0x442779		488b8424c0000000	MOVQ 0xc0(SP), AX			
  0x442781		e8fa6e0000		CALL runtime.gcWriteBarrier(SB)		
  0x442786		e9bafeffff		JMP 0x442645				
  0x44278b		4889d8			MOVQ BX, AX				
  0x44278e		e8ed6e0000		CALL runtime.gcWriteBarrier(SB)		
  0x442793		eb90			JMP 0x442725				
			tlist := typehash[t.hash]
  0x442795		4889442448		MOVQ AX, 0x48(SP)	
			typehash[t.hash] = append(tlist, t)
  0x44279a		488d1ddf380200		LEAQ 0x238df(IP), BX		
  0x4427a1		48891c24		MOVQ BX, 0(SP)			
  0x4427a5		4889542408		MOVQ DX, 0x8(SP)		
  0x4427aa		4889442410		MOVQ AX, 0x10(SP)		
  0x4427af		48894c2418		MOVQ CX, 0x18(SP)		
  0x4427b4		4889742420		MOVQ SI, 0x20(SP)		
  0x4427b9		e8c235ffff		CALL runtime.growslice(SB)	
  0x4427be		488b542428		MOVQ 0x28(SP), DX		
  0x4427c3		488b442430		MOVQ 0x30(SP), AX		
  0x4427c8		488b4c2438		MOVQ 0x38(SP), CX		
  0x4427cd		488d7001		LEAQ 0x1(AX), SI		
  0x4427d1		488b442448		MOVQ 0x48(SP), AX		
  0x4427d6		488b9c2490000000	MOVQ 0x90(SP), BX		
  0x4427de		e91fffffff		JMP 0x442702			
				t = prev.typemap[typeOff(tl)]
  0x4427e3		488d0576b90100		LEAQ 0x1b976(IP), AX			
  0x4427ea		48890424		MOVQ AX, 0(SP)				
  0x4427ee		4c89642408		MOVQ R12, 0x8(SP)			
  0x4427f3		44895c2410		MOVL R11, 0x10(SP)			
  0x4427f8		e893a1fcff		CALL runtime.mapaccess1_fast32(SB)	
  0x4427fd		488b442418		MOVQ 0x18(SP), AX			
  0x442802		4c8b18			MOVQ 0(AX), R11				
			tlist := typehash[t.hash]
  0x442805		488b842480000000	MOVQ 0x80(SP), AX	
				t = prev.typemap[typeOff(tl)]
  0x44280d		e99ffeffff		JMP 0x4426b1		
		if md.typemap == nil {
  0x442812		4883bfb001000000	CMPQ $0x0, 0x1b0(DI)	
  0x44281a		744b			JE 0x442867		
	for _, md := range modules[1:] {
  0x44281c		48ffc3			INCQ BX			
		for _, tl := range prev.typelinks {
  0x44281f		4889fe			MOVQ DI, SI		
	for _, md := range modules[1:] {
  0x442822		4839d3			CMPQ DX, BX		
  0x442825		0f8d50030000		JGE 0x442b7b		
  0x44282b		48895c2470		MOVQ BX, 0x70(SP)	
		for _, tl := range prev.typelinks {
  0x442830		4889b424a0000000	MOVQ SI, 0xa0(SP)	
	for _, md := range modules[1:] {
  0x442838		488b3cd9		MOVQ 0(CX)(BX*8), DI	
  0x44283c		4889bc24a8000000	MOVQ DI, 0xa8(SP)	
		for _, tl := range prev.typelinks {
  0x442844		4c8b86f0000000		MOVQ 0xf0(SI), R8	
  0x44284b		4c898424c8000000	MOVQ R8, 0xc8(SP)	
  0x442853		4c8b8ef8000000		MOVQ 0xf8(SI), R9	
  0x44285a		4c894c2468		MOVQ R9, 0x68(SP)	
  0x44285f		4531d2			XORL R10, R10		
  0x442862		e91efeffff		JMP 0x442685		
			tm := make(map[typeOff]*_type, len(md.typelinks))
  0x442867		488b87f8000000		MOVQ 0xf8(DI), AX		
  0x44286e		488d0debb80100		LEAQ 0x1b8eb(IP), CX		
  0x442875		48890c24		MOVQ CX, 0(SP)			
  0x442879		4889442408		MOVQ AX, 0x8(SP)		
  0x44287e		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x442887		e8348afcff		CALL runtime.makemap(SB)	
  0x44288c		488b442418		MOVQ 0x18(SP), AX		
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x442891		488b0d30f20700		MOVQ runtime.pinnedTypemaps+8(SB), CX	
  0x442898		488d5101		LEAQ 0x1(CX), DX			
  0x44289c		488b1d1df20700		MOVQ runtime.pinnedTypemaps(SB), BX	
  0x4428a3		488b3526f20700		MOVQ runtime.pinnedTypemaps+16(SB), SI	
  0x4428aa		4839f2			CMPQ SI, DX				
  0x4428ad		0f8758020000		JA 0x442b0b				
  0x4428b3		488d5101		LEAQ 0x1(CX), DX			
  0x4428b7		4889150af20700		MOVQ DX, runtime.pinnedTypemaps+8(SB)	
  0x4428be		488d3ccb		LEAQ 0(BX)(CX*8), DI			
  0x4428c2		833d57a5090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4428c9		0f851e020000		JNE 0x442aed				
  0x4428cf		488904cb		MOVQ AX, 0(BX)(CX*8)			
			md.typemap = tm
  0x4428d3		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x4428db		488981b0010000		MOVQ AX, 0x1b0(CX)	
			for _, tl := range md.typelinks {
  0x4428e2		488b81f8000000		MOVQ 0xf8(CX), AX	
  0x4428e9		4889442468		MOVQ AX, 0x68(SP)	
  0x4428ee		488b91f0000000		MOVQ 0xf0(CX), DX	
  0x4428f5		48899424c8000000	MOVQ DX, 0xc8(SP)	
  0x4428fd		31db			XORL BX, BX		
  0x4428ff		e938010000		JMP 0x442a3c		
				for _, candidate := range typehash[t.hash] {
  0x442904		488b5c2450		MOVQ 0x50(SP), BX	
  0x442909		488d5301		LEAQ 0x1(BX), DX	
  0x44290d		488b8424c0000000	MOVQ 0xc0(SP), AX	
  0x442915		488b4c2458		MOVQ 0x58(SP), CX	
  0x44291a		4839ca			CMPQ CX, DX		
  0x44291d		0f8d96010000		JGE 0x442ab9		
  0x442923		4889542450		MOVQ DX, 0x50(SP)	
  0x442928		488b0cd0		MOVQ 0(AX)(DX*8), CX	
  0x44292c		48898c24b0000000	MOVQ CX, 0xb0(SP)	
					seen := map[_typePair]struct{}{}
  0x442934		0f57c0			XORPS X0, X0			
  0x442937		0f118424d8000000	MOVUPS X0, 0xd8(SP)		
  0x44293f		0f118424e8000000	MOVUPS X0, 0xe8(SP)		
  0x442947		0f118424f8000000	MOVUPS X0, 0xf8(SP)		
  0x44294f		488dbc2438010000	LEAQ 0x138(SP), DI		
  0x442957		488d7fd0		LEAQ -0x30(DI), DI		
  0x44295b		48896c24f0		MOVQ BP, -0x10(SP)		
  0x442960		488d6c24f0		LEAQ -0x10(SP), BP		
  0x442965		e888770000		CALL 0x44a0f2			
  0x44296a		488b6d00		MOVQ 0(BP), BP			
  0x44296e		488d9c2438010000	LEAQ 0x138(SP), BX		
  0x442976		48899c24e8000000	MOVQ BX, 0xe8(SP)		
  0x44297e		e87d77ffff		CALL runtime.fastrand(SB)	
  0x442983		8b0424			MOVL 0(SP), AX			
  0x442986		898424e4000000		MOVL AX, 0xe4(SP)		
					if typesEqual(t, candidate, seen) {
  0x44298d		488b8424b8000000	MOVQ 0xb8(SP), AX		
  0x442995		48890424		MOVQ AX, 0(SP)			
  0x442999		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x4429a1		48894c2408		MOVQ CX, 0x8(SP)		
  0x4429a6		488d9424d8000000	LEAQ 0xd8(SP), DX		
  0x4429ae		4889542410		MOVQ DX, 0x10(SP)		
  0x4429b3		e808020000		CALL runtime.typesEqual(SB)	
  0x4429b8		807c241800		CMPB $0x0, 0x18(SP)		
  0x4429bd		0f8441ffffff		JE 0x442904			
				md.typemap[typeOff(tl)] = t
  0x4429c3		488b8424b0000000	MOVQ 0xb0(SP), AX			
  0x4429cb		4889842498000000	MOVQ AX, 0x98(SP)			
  0x4429d3		488b8c24a8000000	MOVQ 0xa8(SP), CX			
  0x4429db		488b91b0010000		MOVQ 0x1b0(CX), DX			
  0x4429e2		488d1d77b70100		LEAQ 0x1b777(IP), BX			
  0x4429e9		48891c24		MOVQ BX, 0(SP)				
  0x4429ed		4889542408		MOVQ DX, 0x8(SP)			
  0x4429f2		8b542444		MOVL 0x44(SP), DX			
  0x4429f6		89542410		MOVL DX, 0x10(SP)			
  0x4429fa		e821a3fcff		CALL runtime.mapassign_fast32(SB)	
  0x4429ff		488b7c2418		MOVQ 0x18(SP), DI			
  0x442a04		8407			TESTB AL, 0(DI)				
  0x442a06		833d13a4090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x442a0d		0f8594000000		JNE 0x442aa7				
  0x442a13		488b842498000000	MOVQ 0x98(SP), AX			
  0x442a1b		488907			MOVQ AX, 0(DI)				
			for _, tl := range md.typelinks {
  0x442a1e		488b742460		MOVQ 0x60(SP), SI	
  0x442a23		488d5e01		LEAQ 0x1(SI), BX	
  0x442a27		488b442468		MOVQ 0x68(SP), AX	
				t := (*_type)(unsafe.Pointer(md.types + uintptr(tl)))
  0x442a2c		488b8c24a8000000	MOVQ 0xa8(SP), CX	
			for _, tl := range md.typelinks {
  0x442a34		488b9424c8000000	MOVQ 0xc8(SP), DX	
  0x442a3c		4839c3			CMPQ AX, BX		
  0x442a3f		0f8d81000000		JGE 0x442ac6		
  0x442a45		48895c2460		MOVQ BX, 0x60(SP)	
  0x442a4a		8b049a			MOVL 0(DX)(BX*4), AX	
  0x442a4d		89442444		MOVL AX, 0x44(SP)	
				t := (*_type)(unsafe.Pointer(md.types + uintptr(tl)))
  0x442a51		4863f0			MOVSXD AX, SI		
  0x442a54		4803b1c8000000		ADDQ 0xc8(CX), SI	
  0x442a5b		4889b424b8000000	MOVQ SI, 0xb8(SP)	
				for _, candidate := range typehash[t.hash] {
  0x442a63		8b7e10			MOVL 0x10(SI), DI			
  0x442a66		4c8d05b3b70100		LEAQ 0x1b7b3(IP), R8			
  0x442a6d		4c890424		MOVQ R8, 0(SP)				
  0x442a71		4c8b8c2480000000	MOVQ 0x80(SP), R9			
  0x442a79		4c894c2408		MOVQ R9, 0x8(SP)			
  0x442a7e		897c2410		MOVL DI, 0x10(SP)			
  0x442a82		e8099ffcff		CALL runtime.mapaccess1_fast32(SB)	
  0x442a87		488b442418		MOVQ 0x18(SP), AX			
  0x442a8c		488b4808		MOVQ 0x8(AX), CX			
  0x442a90		48894c2458		MOVQ CX, 0x58(SP)			
  0x442a95		488b00			MOVQ 0(AX), AX				
  0x442a98		48898424c0000000	MOVQ AX, 0xc0(SP)			
  0x442aa0		31d2			XORL DX, DX				
  0x442aa2		e973feffff		JMP 0x44291a				
				md.typemap[typeOff(tl)] = t
  0x442aa7		488b842498000000	MOVQ 0x98(SP), AX		
  0x442aaf		e8cc6b0000		CALL runtime.gcWriteBarrier(SB)	
  0x442ab4		e965ffffff		JMP 0x442a1e			
  0x442ab9		488b8424b8000000	MOVQ 0xb8(SP), AX		
				for _, candidate := range typehash[t.hash] {
  0x442ac1		e905ffffff		JMP 0x4429cb		
			tlist := typehash[t.hash]
  0x442ac6		488b842480000000	MOVQ 0x80(SP), AX	
	for _, md := range modules[1:] {
  0x442ace		488b8c24d0000000	MOVQ 0xd0(SP), CX	
  0x442ad6		488b542478		MOVQ 0x78(SP), DX	
  0x442adb		488b5c2470		MOVQ 0x70(SP), BX	
		for _, tl := range prev.typelinks {
  0x442ae0		488bbc24a8000000	MOVQ 0xa8(SP), DI	
		prev = md
  0x442ae8		e92ffdffff		JMP 0x44281c		
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x442aed		e88e6b0000		CALL runtime.gcWriteBarrier(SB)	
		if md.typemap == nil {
  0x442af2		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x442afa		488db9b0010000		LEAQ 0x1b0(CX), DI	
			md.typemap = tm
  0x442b01		e87a6b0000		CALL runtime.gcWriteBarrier(SB)	
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x442b06		e9d7fdffff		JMP 0x4428e2		
			tm := make(map[typeOff]*_type, len(md.typelinks))
  0x442b0b		4889842488000000	MOVQ AX, 0x88(SP)	
			pinnedTypemaps = append(pinnedTypemaps, tm)
  0x442b13		488d0546b60100		LEAQ 0x1b646(IP), AX			
  0x442b1a		48890424		MOVQ AX, 0(SP)				
  0x442b1e		48895c2408		MOVQ BX, 0x8(SP)			
  0x442b23		48894c2410		MOVQ CX, 0x10(SP)			
  0x442b28		4889742418		MOVQ SI, 0x18(SP)			
  0x442b2d		4889542420		MOVQ DX, 0x20(SP)			
  0x442b32		e84932ffff		CALL runtime.growslice(SB)		
  0x442b37		488b442428		MOVQ 0x28(SP), AX			
  0x442b3c		488b4c2430		MOVQ 0x30(SP), CX			
  0x442b41		488b542438		MOVQ 0x38(SP), DX			
  0x442b46		48891583ef0700		MOVQ DX, runtime.pinnedTypemaps+16(SB)	
  0x442b4d		833dcca2090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x442b54		7517			JNE 0x442b6d				
  0x442b56		48890563ef0700		MOVQ AX, runtime.pinnedTypemaps(SB)	
  0x442b5d		4889c3			MOVQ AX, BX				
  0x442b60		488b842488000000	MOVQ 0x88(SP), AX			
  0x442b68		e946fdffff		JMP 0x4428b3				
  0x442b6d		488d3d4cef0700		LEAQ runtime.pinnedTypemaps(SB), DI	
  0x442b74		e8076b0000		CALL runtime.gcWriteBarrier(SB)		
  0x442b79		ebe2			JMP 0x442b5d				
  0x442b7b		488bac24b8020000	MOVQ 0x2b8(SP), BP			
  0x442b83		4881c4c0020000		ADDQ $0x2c0, SP				
  0x442b8a		c3			RET					
  0x442b8b		31db			XORL BX, BX				
  0x442b8d		31d2			XORL DX, DX				
  0x442b8f		31c9			XORL CX, CX				
	modules := activeModules()
  0x442b91		e95efaffff		JMP 0x4425f4		
		return
  0x442b96		488bac24b8020000	MOVQ 0x2b8(SP), BP	
  0x442b9e		4881c4c0020000		ADDQ $0x2c0, SP		
  0x442ba5		c3			RET			
	prev := modules[0]
  0x442ba6		e875f3fdff		CALL runtime.panicindex(SB)	
  0x442bab		0f0b			UD2				
func typelinksinit() {
  0x442bad		e8ce4c0000		CALL runtime.morestack_noctxt(SB)	
  0x442bb2		e969f9ffff		JMP runtime.typelinksinit(SB)		

TEXT runtime.typesEqual(SB) /usr/local/go/src/runtime/type.go
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x442bc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x442bc9		488d842458ffffff	LEAQ 0xffffff58(SP), AX	
  0x442bd1		483b4110		CMPQ 0x10(CX), AX	
  0x442bd5		0f86330f0000		JBE 0x443b0e		
  0x442bdb		4881ec28010000		SUBQ $0x128, SP		
  0x442be2		4889ac2420010000	MOVQ BP, 0x120(SP)	
  0x442bea		488dac2420010000	LEAQ 0x120(SP), BP	
	if _, ok := seen[tp]; ok {
  0x442bf2		488b842430010000	MOVQ 0x130(SP), AX		
  0x442bfa		4889842410010000	MOVQ AX, 0x110(SP)		
  0x442c02		488b8c2438010000	MOVQ 0x138(SP), CX		
  0x442c0a		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x442c12		488d15e7b40100		LEAQ 0x1b4e7(IP), DX		
  0x442c19		48891424		MOVQ DX, 0(SP)			
  0x442c1d		488b9c2440010000	MOVQ 0x140(SP), BX		
  0x442c25		48895c2408		MOVQ BX, 0x8(SP)		
  0x442c2a		488db42410010000	LEAQ 0x110(SP), SI		
  0x442c32		4889742410		MOVQ SI, 0x10(SP)		
  0x442c37		e8a48afcff		CALL runtime.mapaccess2(SB)	
  0x442c3c		807c242000		CMPB $0x0, 0x20(SP)		
  0x442c41		0f85150e0000		JNE 0x443a5c			
	seen[tp] = struct{}{}
  0x442c47		488b842430010000	MOVQ 0x130(SP), AX		
  0x442c4f		4889842410010000	MOVQ AX, 0x110(SP)		
  0x442c57		488b8c2438010000	MOVQ 0x138(SP), CX		
  0x442c5f		48898c2418010000	MOVQ CX, 0x118(SP)		
  0x442c67		488d1592b40100		LEAQ 0x1b492(IP), DX		
  0x442c6e		48891424		MOVQ DX, 0(SP)			
  0x442c72		488b942440010000	MOVQ 0x140(SP), DX		
  0x442c7a		4889542408		MOVQ DX, 0x8(SP)		
  0x442c7f		488d9c2410010000	LEAQ 0x110(SP), BX		
  0x442c87		48895c2410		MOVQ BX, 0x10(SP)		
  0x442c8c		e8df8cfcff		CALL runtime.mapassign(SB)	
  0x442c91		488b442418		MOVQ 0x18(SP), AX		
  0x442c96		8400			TESTB AL, 0(AX)			
	if t == v {
  0x442c98		488b842430010000	MOVQ 0x130(SP), AX	
  0x442ca0		488b8c2438010000	MOVQ 0x138(SP), CX	
  0x442ca8		4839c8			CMPQ CX, AX		
  0x442cab		0f84930d0000		JE 0x443a44		
	kind := t.kind & kindMask
  0x442cb1		0fb65017		MOVZX 0x17(AX), DX	
  0x442cb5		89d3			MOVL DX, BX		
  0x442cb7		83e21f			ANDL $0x1f, DX		
	if kind != v.kind&kindMask {
  0x442cba		0fb67117		MOVZX 0x17(CX), SI	
  0x442cbe		83e61f			ANDL $0x1f, SI		
  0x442cc1		4038f2			CMPL SI, DL		
  0x442cc4		0f85620d0000		JNE 0x443a2c		
	kind := t.kind & kindMask
  0x442cca		885c242b		MOVB BL, 0x2b(SP)	
  0x442cce		8854242a		MOVB DL, 0x2a(SP)	
	if t.string() != v.string() {
  0x442cd2		48890424		MOVQ AX, 0(SP)				
  0x442cd6		e815eaffff		CALL runtime.(*_type).string(SB)	
  0x442cdb		488b442410		MOVQ 0x10(SP), AX			
  0x442ce0		4889442478		MOVQ AX, 0x78(SP)			
  0x442ce5		488b4c2408		MOVQ 0x8(SP), CX			
  0x442cea		48898c2408010000	MOVQ CX, 0x108(SP)			
  0x442cf2		488b942438010000	MOVQ 0x138(SP), DX			
  0x442cfa		48891424		MOVQ DX, 0(SP)				
  0x442cfe		e8ede9ffff		CALL runtime.(*_type).string(SB)	
  0x442d03		488b442478		MOVQ 0x78(SP), AX			
  0x442d08		4839442410		CMPQ AX, 0x10(SP)			
  0x442d0d		7418			JE 0x442d27				
		return false
  0x442d0f		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x442d17		488bac2420010000	MOVQ 0x120(SP), BP	
  0x442d1f		4881c428010000		ADDQ $0x128, SP		
  0x442d26		c3			RET			
	if t.string() != v.string() {
  0x442d27		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x442d2f		48890c24		MOVQ CX, 0(SP)			
  0x442d33		4889442410		MOVQ AX, 0x10(SP)		
  0x442d38		e8e3f4fbff		CALL runtime.memequal(SB)	
  0x442d3d		807c241800		CMPB $0x0, 0x18(SP)		
  0x442d42		74cb			JE 0x442d0f			
	ut := t.uncommon()
  0x442d44		488b842430010000	MOVQ 0x130(SP), AX			
  0x442d4c		48890424		MOVQ AX, 0(SP)				
  0x442d50		e84beaffff		CALL runtime.(*_type).uncommon(SB)	
  0x442d55		488b442408		MOVQ 0x8(SP), AX			
  0x442d5a		4889842498000000	MOVQ AX, 0x98(SP)			
	uv := v.uncommon()
  0x442d62		488b8c2438010000	MOVQ 0x138(SP), CX			
  0x442d6a		48890c24		MOVQ CX, 0(SP)				
  0x442d6e		e82deaffff		CALL runtime.(*_type).uncommon(SB)	
  0x442d73		488b442408		MOVQ 0x8(SP), AX			
	if ut != nil || uv != nil {
  0x442d78		488b8c2498000000	MOVQ 0x98(SP), CX	
  0x442d80		4885c9			TESTQ CX, CX		
  0x442d83		0f85cc0b0000		JNE 0x443955		
  0x442d89		4885c0			TESTQ AX, AX		
  0x442d8c		0f85c00b0000		JNE 0x443952		
	if kindBool <= kind && kind <= kindComplex128 {
  0x442d92		0fb644242a		MOVZX 0x2a(SP), AX	
  0x442d97		3c01			CMPL $0x1, AL		
  0x442d99		7208			JB 0x442da3		
  0x442d9b		3c10			CMPL $0x10, AL		
  0x442d9d		0f86970b0000		JBE 0x44393a		
	switch kind {
  0x442da3		3c15			CMPL $0x15, AL		
  0x442da5		0f87b5070000		JA 0x443560		
  0x442dab		3c12			CMPL $0x12, AL		
  0x442dad		0f86d4060000		JBE 0x443487		
	case kindFunc:
  0x442db3		3c13			CMPL $0x13, AL		
  0x442db5		0f85f6020000		JNE 0x4430b1		
		if ft.outCount != fv.outCount || ft.inCount != fv.inCount {
  0x442dbb		488b842438010000	MOVQ 0x138(SP), AX	
  0x442dc3		0fb74832		MOVZX 0x32(AX), CX	
  0x442dc7		488b942430010000	MOVQ 0x130(SP), DX	
  0x442dcf		66394a32		CMPW CX, 0x32(DX)	
  0x442dd3		0f85c0020000		JNE 0x443099		
  0x442dd9		0fb74a30		MOVZX 0x30(DX), CX	
  0x442ddd		0fb75830		MOVZX 0x30(AX), BX	
  0x442de1		6639cb			CMPW CX, BX		
  0x442de4		0f85af020000		JNE 0x443099		
		tin, vin := ft.in(), fv.in()
  0x442dea		90			NOPL			
	if t.typ.tflag&tflagUncommon != 0 {
  0x442deb		0fb67214		MOVZX 0x14(DX), SI	
  0x442def		40f6c601		TESTL $0x1, SI		
  0x442df3		0f8496020000		JE 0x44308f		
		uadd += unsafe.Sizeof(uncommontype{})
  0x442df9		be48000000		MOVL $0x48, SI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x442dfe		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x442dff		4801d6			ADDQ DX, SI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x442e02		4885c9			TESTQ CX, CX		
  0x442e05		0f8ca80c0000		JL 0x443ab3		
  0x442e0b		4881f900001000		CMPQ $0x100000, CX	
  0x442e12		0f879b0c0000		JA 0x443ab3		
		tin, vin := ft.in(), fv.in()
  0x442e18		90			NOPL			
	if t.typ.tflag&tflagUncommon != 0 {
  0x442e19		0fb67814		MOVZX 0x14(AX), DI	
  0x442e1d		40f6c701		TESTL $0x1, DI		
  0x442e21		0f845e020000		JE 0x443085		
		uadd += unsafe.Sizeof(uncommontype{})
  0x442e27		bf48000000		MOVL $0x48, DI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x442e2c		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x442e2d		4801c7			ADDQ AX, DI		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x442e30		4885db			TESTQ BX, BX		
  0x442e33		0f8c730c0000		JL 0x443aac		
  0x442e39		4881fb00001000		CMPQ $0x100000, BX	
  0x442e40		0f87660c0000		JA 0x443aac		
		if ft.outCount != fv.outCount || ft.inCount != fv.inCount {
  0x442e46		66894c242e		MOVW CX, 0x2e(SP)	
  0x442e4b		66895c242c		MOVW BX, 0x2c(SP)	
	return unsafe.Pointer(uintptr(p) + x)
  0x442e50		4889b42400010000	MOVQ SI, 0x100(SP)	
  0x442e58		4889bc24f8000000	MOVQ DI, 0xf8(SP)	
		for i := 0; i < len(tin); i++ {
  0x442e60		4c8b842440010000	MOVQ 0x140(SP), R8	
  0x442e68		4531c9			XORL R9, R9		
  0x442e6b		eb4c			JMP 0x442eb9		
  0x442e6d		4c8b542460		MOVQ 0x60(SP), R10	
  0x442e72		4d8d4a01		LEAQ 0x1(R10), R9	
  0x442e76		440fb754242e		MOVZX 0x2e(SP), R10	
  0x442e7c		4c8b9c2440010000	MOVQ 0x140(SP), R11	
  0x442e84		440fb764242c		MOVZX 0x2c(SP), R12	
  0x442e8a		4c8bac24f8000000	MOVQ 0xf8(SP), R13	
  0x442e92		4c8bb42400010000	MOVQ 0x100(SP), R14	
	if t.typ.tflag&tflagUncommon != 0 {
  0x442e9a		488b842438010000	MOVQ 0x138(SP), AX	
		for i := 0; i < len(tin); i++ {
  0x442ea2		4489d1			MOVL R10, CX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x442ea5		488b942430010000	MOVQ 0x130(SP), DX	
			if !typesEqual(tin[i], vin[i], seen) {
  0x442ead		4489e3			MOVL R12, BX		
  0x442eb0		4c89f6			MOVQ R14, SI		
  0x442eb3		4c89ef			MOVQ R13, DI		
  0x442eb6		4d89d8			MOVQ R11, R8		
		for i := 0; i < len(tin); i++ {
  0x442eb9		4939c9			CMPQ CX, R9		
  0x442ebc		7d4c			JGE 0x442f0a		
			if !typesEqual(tin[i], vin[i], seen) {
  0x442ebe		4e8b14ce		MOVQ 0(SI)(R9*8), R10	
  0x442ec2		4939d9			CMPQ BX, R9		
  0x442ec5		0f83da0b0000		JAE 0x443aa5		
		for i := 0; i < len(tin); i++ {
  0x442ecb		4c894c2460		MOVQ R9, 0x60(SP)	
			if !typesEqual(tin[i], vin[i], seen) {
  0x442ed0		4a8b04cf		MOVQ 0(DI)(R9*8), AX		
  0x442ed4		4c891424		MOVQ R10, 0(SP)			
  0x442ed8		4889442408		MOVQ AX, 0x8(SP)		
  0x442edd		4c89442410		MOVQ R8, 0x10(SP)		
  0x442ee2		e8d9fcffff		CALL runtime.typesEqual(SB)	
  0x442ee7		807c241800		CMPB $0x0, 0x18(SP)		
  0x442eec		0f857bffffff		JNE 0x442e6d			
				return false
  0x442ef2		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x442efa		488bac2420010000	MOVQ 0x120(SP), BP	
  0x442f02		4881c428010000		ADDQ $0x128, SP		
  0x442f09		c3			RET			
		tout, vout := ft.out(), fv.out()
  0x442f0a		90			NOPL			
	if t.typ.tflag&tflagUncommon != 0 {
  0x442f0b		0fb64a14		MOVZX 0x14(DX), CX	
  0x442f0f		f6c101			TESTL $0x1, CL		
  0x442f12		0f8463010000		JE 0x44307b		
		uadd += unsafe.Sizeof(uncommontype{})
  0x442f18		b948000000		MOVL $0x48, CX		
	outCount := t.outCount & (1<<15 - 1)
  0x442f1d		0fb75a32		MOVZX 0x32(DX), BX	
  0x442f21		81e3ff7f0000		ANDL $0x7fff, BX	
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x442f27		90			NOPL			
  0x442f28		0fb77230		MOVZX 0x30(DX), SI	
  0x442f2c		01f3			ADDL SI, BX		
  0x442f2e		0fb7db			MOVZX BX, BX		
	return unsafe.Pointer(uintptr(p) + x)
  0x442f31		4801d1			ADDQ DX, CX		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x442f34		4885db			TESTQ BX, BX		
  0x442f37		0f8c610b0000		JL 0x443a9e		
  0x442f3d		4839de			CMPQ BX, SI		
  0x442f40		0f87580b0000		JA 0x443a9e		
		tout, vout := ft.out(), fv.out()
  0x442f46		90			NOPL			
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x442f47		4829f3			SUBQ SI, BX		
  0x442f4a		89f2			MOVL SI, DX		
  0x442f4c		48c1e603		SHLQ $0x3, SI		
  0x442f50		4881c20000f0ff		ADDQ $-0x100000, DX	
  0x442f57		48c1fa3f		SARQ $0x3f, DX		
  0x442f5b		4821f2			ANDQ SI, DX		
  0x442f5e		4801d1			ADDQ DX, CX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x442f61		0fb65014		MOVZX 0x14(AX), DX	
  0x442f65		f6c201			TESTL $0x1, DL		
  0x442f68		0f8403010000		JE 0x443071		
		uadd += unsafe.Sizeof(uncommontype{})
  0x442f6e		ba48000000		MOVL $0x48, DX		
	outCount := t.outCount & (1<<15 - 1)
  0x442f73		0fb77032		MOVZX 0x32(AX), SI	
  0x442f77		81e6ff7f0000		ANDL $0x7fff, SI	
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x442f7d		90			NOPL			
  0x442f7e		0fb77830		MOVZX 0x30(AX), DI	
  0x442f82		01fe			ADDL DI, SI		
  0x442f84		0fb7f6			MOVZX SI, SI		
	return unsafe.Pointer(uintptr(p) + x)
  0x442f87		4801d0			ADDQ DX, AX		
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x442f8a		4885f6			TESTQ SI, SI		
  0x442f8d		0f8c040b0000		JL 0x443a97		
  0x442f93		4839f7			CMPQ SI, DI		
  0x442f96		0f87fb0a0000		JA 0x443a97		
  0x442f9c		48895c2438		MOVQ BX, 0x38(SP)	
  0x442fa1		48898c24a0000000	MOVQ CX, 0xa0(SP)	
  0x442fa9		4829fe			SUBQ DI, SI		
  0x442fac		4889742430		MOVQ SI, 0x30(SP)	
  0x442fb1		488d970000f0ff		LEAQ 0xfff00000(DI), DX	
  0x442fb8		48c1fa3f		SARQ $0x3f, DX		
  0x442fbc		48c1e703		SHLQ $0x3, DI		
  0x442fc0		4821d7			ANDQ DX, DI		
  0x442fc3		4801f8			ADDQ DI, AX		
  0x442fc6		4889842480000000	MOVQ AX, 0x80(SP)	
  0x442fce		31d2			XORL DX, DX		
		for i := 0; i < len(tout); i++ {
  0x442fd0		eb3a			JMP 0x44300c		
  0x442fd2		488b7c2450		MOVQ 0x50(SP), DI	
  0x442fd7		488d5701		LEAQ 0x1(DI), DX	
  0x442fdb		488b7c2438		MOVQ 0x38(SP), DI	
  0x442fe0		4c8b8c2440010000	MOVQ 0x140(SP), R9	
  0x442fe8		4c8b542430		MOVQ 0x30(SP), R10	
  0x442fed		4c8b9c2480000000	MOVQ 0x80(SP), R11	
  0x442ff5		4c8ba424a0000000	MOVQ 0xa0(SP), R12	
			if !typesEqual(tout[i], vout[i], seen) {
  0x442ffd		4c89d8			MOVQ R11, AX		
  0x443000		4c89e1			MOVQ R12, CX		
		for i := 0; i < len(tout); i++ {
  0x443003		4889fb			MOVQ DI, BX		
			if !typesEqual(tout[i], vout[i], seen) {
  0x443006		4c89d6			MOVQ R10, SI		
  0x443009		4d89c8			MOVQ R9, R8		
		for i := 0; i < len(tout); i++ {
  0x44300c		4839da			CMPQ BX, DX		
  0x44300f		7d48			JGE 0x443059		
			if !typesEqual(tout[i], vout[i], seen) {
  0x443011		488b3cd1		MOVQ 0(CX)(DX*8), DI	
  0x443015		4839f2			CMPQ SI, DX		
  0x443018		0f83720a0000		JAE 0x443a90		
		for i := 0; i < len(tout); i++ {
  0x44301e		4889542450		MOVQ DX, 0x50(SP)	
			if !typesEqual(tout[i], vout[i], seen) {
  0x443023		488b0cd0		MOVQ 0(AX)(DX*8), CX		
  0x443027		48893c24		MOVQ DI, 0(SP)			
  0x44302b		48894c2408		MOVQ CX, 0x8(SP)		
  0x443030		4c89442410		MOVQ R8, 0x10(SP)		
  0x443035		e886fbffff		CALL runtime.typesEqual(SB)	
  0x44303a		807c241800		CMPB $0x0, 0x18(SP)		
  0x44303f		7591			JNE 0x442fd2			
				return false
  0x443041		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x443049		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443051		4881c428010000		ADDQ $0x128, SP		
  0x443058		c3			RET			
		return true
  0x443059		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443061		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443069		4881c428010000		ADDQ $0x128, SP		
  0x443070		c3			RET			
  0x443071		ba38000000		MOVL $0x38, DX		
	if t.typ.tflag&tflagUncommon != 0 {
  0x443076		e9f8feffff		JMP 0x442f73		
  0x44307b		b938000000		MOVL $0x38, CX		
  0x443080		e998feffff		JMP 0x442f1d		
  0x443085		bf38000000		MOVL $0x38, DI		
	if t.typ.tflag&tflagUncommon != 0 {
  0x44308a		e99dfdffff		JMP 0x442e2c		
  0x44308f		be38000000		MOVL $0x38, SI		
  0x443094		e965fdffff		JMP 0x442dfe		
			return false
  0x443099		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4430a1		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4430a9		4881c428010000		ADDQ $0x128, SP		
  0x4430b0		c3			RET			
	case kindInterface:
  0x4430b1		3c14			CMPL $0x14, AL		
  0x4430b3		0f8541030000		JNE 0x4433fa		
		if it.pkgpath.name() != iv.pkgpath.name() {
  0x4430b9		488b842430010000	MOVQ 0x130(SP), AX		
  0x4430c1		488b4830		MOVQ 0x30(AX), CX		
  0x4430c5		48890c24		MOVQ CX, 0(SP)			
  0x4430c9		e882f2ffff		CALL runtime.name.name(SB)	
  0x4430ce		488b442410		MOVQ 0x10(SP), AX		
  0x4430d3		4889442478		MOVQ AX, 0x78(SP)		
  0x4430d8		488b4c2408		MOVQ 0x8(SP), CX		
  0x4430dd		48898c2408010000	MOVQ CX, 0x108(SP)		
  0x4430e5		488b942438010000	MOVQ 0x138(SP), DX		
  0x4430ed		488b5a30		MOVQ 0x30(DX), BX		
  0x4430f1		48891c24		MOVQ BX, 0(SP)			
  0x4430f5		e856f2ffff		CALL runtime.name.name(SB)	
  0x4430fa		488b442478		MOVQ 0x78(SP), AX		
  0x4430ff		4839442410		CMPQ AX, 0x10(SP)		
  0x443104		7418			JE 0x44311e			
			return false
  0x443106		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x44310e		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443116		4881c428010000		ADDQ $0x128, SP		
  0x44311d		c3			RET			
		if it.pkgpath.name() != iv.pkgpath.name() {
  0x44311e		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x443126		48890c24		MOVQ CX, 0(SP)			
  0x44312a		4889442410		MOVQ AX, 0x10(SP)		
  0x44312f		e8ecf0fbff		CALL runtime.memequal(SB)	
  0x443134		807c241800		CMPB $0x0, 0x18(SP)		
  0x443139		74cb			JE 0x443106			
		if len(it.mhdr) != len(iv.mhdr) {
  0x44313b		488b842430010000	MOVQ 0x130(SP), AX	
  0x443143		488b4840		MOVQ 0x40(AX), CX	
  0x443147		488b942438010000	MOVQ 0x138(SP), DX	
  0x44314f		48394a40		CMPQ CX, 0x40(DX)	
  0x443153		0f8589020000		JNE 0x4433e2		
  0x443159		48894c2478		MOVQ CX, 0x78(SP)	
  0x44315e		31db			XORL BX, BX		
		for i := range it.mhdr {
  0x443160		eb27			JMP 0x443189		
  0x443162		488b742458		MOVQ 0x58(SP), SI	
  0x443167		488d5e01		LEAQ 0x1(SI), BX	
  0x44316b		488b742478		MOVQ 0x78(SP), SI	
  0x443170		488bbc2438010000	MOVQ 0x138(SP), DI	
  0x443178		4c8b842430010000	MOVQ 0x130(SP), R8	
			tm := &it.mhdr[i]
  0x443180		4c89c0			MOVQ R8, AX		
		for i := range it.mhdr {
  0x443183		4889f1			MOVQ SI, CX		
			vm := &iv.mhdr[i]
  0x443186		4889fa			MOVQ DI, DX		
		for i := range it.mhdr {
  0x443189		4839cb			CMPQ CX, BX		
  0x44318c		0f8d38020000		JGE 0x4433ca		
			tm := &it.mhdr[i]
  0x443192		488b7038		MOVQ 0x38(AX), SI	
  0x443196		48395840		CMPQ BX, 0x40(AX)	
  0x44319a		0f86e9080000		JBE 0x443a89		
  0x4431a0		488d3cde		LEAQ 0(SI)(BX*8), DI	
			vm := &iv.mhdr[i]
  0x4431a4		4c8b4238		MOVQ 0x38(DX), R8	
  0x4431a8		48395a40		CMPQ BX, 0x40(DX)	
  0x4431ac		0f86d0080000		JBE 0x443a82		
			tm := &it.mhdr[i]
  0x4431b2		4889b424f0000000	MOVQ SI, 0xf0(SP)	
		for i := range it.mhdr {
  0x4431ba		48895c2458		MOVQ BX, 0x58(SP)	
			tm := &it.mhdr[i]
  0x4431bf		4889bc24a8000000	MOVQ DI, 0xa8(SP)	
			vm := &iv.mhdr[i]
  0x4431c7		4c898424e8000000	MOVQ R8, 0xe8(SP)	
			tname := resolveNameOff(unsafe.Pointer(tm), tm.name)
  0x4431cf		8b04de			MOVL 0(SI)(BX*8), AX		
  0x4431d2		48893c24		MOVQ DI, 0(SP)			
  0x4431d6		89442408		MOVL AX, 0x8(SP)		
  0x4431da		e881e7ffff		CALL runtime.resolveNameOff(SB)	
			vm := &iv.mhdr[i]
  0x4431df		488b442458		MOVQ 0x58(SP), AX	
  0x4431e4		488b8c24e8000000	MOVQ 0xe8(SP), CX	
  0x4431ec		488d14c1		LEAQ 0(CX)(AX*8), DX	
  0x4431f0		4889942488000000	MOVQ DX, 0x88(SP)	
			tname := resolveNameOff(unsafe.Pointer(tm), tm.name)
  0x4431f8		488b5c2410		MOVQ 0x10(SP), BX	
  0x4431fd		48899c24e0000000	MOVQ BX, 0xe0(SP)	
			vname := resolveNameOff(unsafe.Pointer(vm), vm.name)
  0x443205		8b34c1			MOVL 0(CX)(AX*8), SI		
  0x443208		48891424		MOVQ DX, 0(SP)			
  0x44320c		89742408		MOVL SI, 0x8(SP)		
  0x443210		e84be7ffff		CALL runtime.resolveNameOff(SB)	
  0x443215		488b442410		MOVQ 0x10(SP), AX		
  0x44321a		48898424d8000000	MOVQ AX, 0xd8(SP)		
			if tname.name() != vname.name() {
  0x443222		488b8c24e0000000	MOVQ 0xe0(SP), CX		
  0x44322a		48890c24		MOVQ CX, 0(SP)			
  0x44322e		e81df1ffff		CALL runtime.name.name(SB)	
  0x443233		488b442410		MOVQ 0x10(SP), AX		
  0x443238		4889442470		MOVQ AX, 0x70(SP)		
  0x44323d		488b4c2408		MOVQ 0x8(SP), CX		
  0x443242		48898c24d0000000	MOVQ CX, 0xd0(SP)		
  0x44324a		488b9424d8000000	MOVQ 0xd8(SP), DX		
  0x443252		48891424		MOVQ DX, 0(SP)			
  0x443256		e8f5f0ffff		CALL runtime.name.name(SB)	
  0x44325b		488b442470		MOVQ 0x70(SP), AX		
  0x443260		4839442410		CMPQ AX, 0x10(SP)		
  0x443265		0f8547010000		JNE 0x4433b2			
  0x44326b		488b8c24d0000000	MOVQ 0xd0(SP), CX		
  0x443273		48890c24		MOVQ CX, 0(SP)			
  0x443277		4889442410		MOVQ AX, 0x10(SP)		
  0x44327c		e89feffbff		CALL runtime.memequal(SB)	
  0x443281		807c241800		CMPB $0x0, 0x18(SP)		
  0x443286		0f8426010000		JE 0x4433b2			
			if tname.pkgPath() != vname.pkgPath() {
  0x44328c		488b8424e0000000	MOVQ 0xe0(SP), AX		
  0x443294		48890424		MOVQ AX, 0(SP)			
  0x443298		e893f1ffff		CALL runtime.name.pkgPath(SB)	
  0x44329d		488b442408		MOVQ 0x8(SP), AX		
  0x4432a2		4889842408010000	MOVQ AX, 0x108(SP)		
  0x4432aa		488b4c2410		MOVQ 0x10(SP), CX		
  0x4432af		48894c2470		MOVQ CX, 0x70(SP)		
  0x4432b4		488b9424d8000000	MOVQ 0xd8(SP), DX		
  0x4432bc		48891424		MOVQ DX, 0(SP)			
  0x4432c0		e86bf1ffff		CALL runtime.name.pkgPath(SB)	
  0x4432c5		488b442470		MOVQ 0x70(SP), AX		
  0x4432ca		4839442410		CMPQ AX, 0x10(SP)		
  0x4432cf		0f85c5000000		JNE 0x44339a			
  0x4432d5		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x4432dd		48890c24		MOVQ CX, 0(SP)			
  0x4432e1		4889442410		MOVQ AX, 0x10(SP)		
  0x4432e6		e835effbff		CALL runtime.memequal(SB)	
  0x4432eb		807c241800		CMPB $0x0, 0x18(SP)		
  0x4432f0		0f84a4000000		JE 0x44339a			
			tityp := resolveTypeOff(unsafe.Pointer(tm), tm.ityp)
  0x4432f6		488b442458		MOVQ 0x58(SP), AX		
  0x4432fb		488b8c24f0000000	MOVQ 0xf0(SP), CX		
  0x443303		8b4cc104		MOVL 0x4(CX)(AX*8), CX		
  0x443307		488b9424a8000000	MOVQ 0xa8(SP), DX		
  0x44330f		48891424		MOVQ DX, 0(SP)			
  0x443313		894c2408		MOVL CX, 0x8(SP)		
  0x443317		e844e9ffff		CALL runtime.resolveTypeOff(SB)	
  0x44331c		488b442410		MOVQ 0x10(SP), AX		
  0x443321		48898424b0000000	MOVQ AX, 0xb0(SP)		
			vityp := resolveTypeOff(unsafe.Pointer(vm), vm.ityp)
  0x443329		488b4c2458		MOVQ 0x58(SP), CX		
  0x44332e		488b9424e8000000	MOVQ 0xe8(SP), DX		
  0x443336		8b54ca04		MOVL 0x4(DX)(CX*8), DX		
  0x44333a		488b9c2488000000	MOVQ 0x88(SP), BX		
  0x443342		48891c24		MOVQ BX, 0(SP)			
  0x443346		89542408		MOVL DX, 0x8(SP)		
  0x44334a		e811e9ffff		CALL runtime.resolveTypeOff(SB)	
  0x44334f		488b442410		MOVQ 0x10(SP), AX		
			if !typesEqual(tityp, vityp, seen) {
  0x443354		488b8c24b0000000	MOVQ 0xb0(SP), CX		
  0x44335c		48890c24		MOVQ CX, 0(SP)			
  0x443360		4889442408		MOVQ AX, 0x8(SP)		
  0x443365		488b842440010000	MOVQ 0x140(SP), AX		
  0x44336d		4889442410		MOVQ AX, 0x10(SP)		
  0x443372		e849f8ffff		CALL runtime.typesEqual(SB)	
  0x443377		807c241800		CMPB $0x0, 0x18(SP)		
  0x44337c		0f85e0fdffff		JNE 0x443162			
				return false
  0x443382		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x44338a		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443392		4881c428010000		ADDQ $0x128, SP		
  0x443399		c3			RET			
				return false
  0x44339a		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4433a2		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4433aa		4881c428010000		ADDQ $0x128, SP		
  0x4433b1		c3			RET			
				return false
  0x4433b2		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4433ba		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4433c2		4881c428010000		ADDQ $0x128, SP		
  0x4433c9		c3			RET			
		return true
  0x4433ca		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x4433d2		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4433da		4881c428010000		ADDQ $0x128, SP		
  0x4433e1		c3			RET			
			return false
  0x4433e2		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4433ea		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4433f2		4881c428010000		ADDQ $0x128, SP		
  0x4433f9		c3			RET			
		return typesEqual(mt.key, mv.key, seen) && typesEqual(mt.elem, mv.elem, seen)
  0x4433fa		488b842430010000	MOVQ 0x130(SP), AX		
  0x443402		488b4830		MOVQ 0x30(AX), CX		
  0x443406		488b942438010000	MOVQ 0x138(SP), DX		
  0x44340e		488b5a30		MOVQ 0x30(DX), BX		
  0x443412		48890c24		MOVQ CX, 0(SP)			
  0x443416		48895c2408		MOVQ BX, 0x8(SP)		
  0x44341b		488b8c2440010000	MOVQ 0x140(SP), CX		
  0x443423		48894c2410		MOVQ CX, 0x10(SP)		
  0x443428		e893f7ffff		CALL runtime.typesEqual(SB)	
  0x44342d		807c241800		CMPB $0x0, 0x18(SP)		
  0x443432		7519			JNE 0x44344d			
  0x443434		31c0			XORL AX, AX			
  0x443436		88842448010000		MOVB AL, 0x148(SP)		
  0x44343d		488bac2420010000	MOVQ 0x120(SP), BP		
  0x443445		4881c428010000		ADDQ $0x128, SP			
  0x44344c		c3			RET				
  0x44344d		488b842430010000	MOVQ 0x130(SP), AX		
  0x443455		488b4038		MOVQ 0x38(AX), AX		
  0x443459		488b8c2438010000	MOVQ 0x138(SP), CX		
  0x443461		488b4938		MOVQ 0x38(CX), CX		
  0x443465		48890424		MOVQ AX, 0(SP)			
  0x443469		48894c2408		MOVQ CX, 0x8(SP)		
  0x44346e		488b842440010000	MOVQ 0x140(SP), AX		
  0x443476		4889442410		MOVQ AX, 0x10(SP)		
  0x44347b		e840f7ffff		CALL runtime.typesEqual(SB)	
  0x443480		0fb6442418		MOVZX 0x18(SP), AX		
  0x443485		ebaf			JMP 0x443436			
	case kindArray:
  0x443487		3c11			CMPL $0x11, AL		
  0x443489		7465			JE 0x4434f0		
	switch kind {
  0x44348b		3c12			CMPL $0x12, AL		
	case kindChan:
  0x44348d		0f8527060000		JNE 0x443aba		
		return ct.dir == cv.dir && typesEqual(ct.elem, cv.elem, seen)
  0x443493		488b842438010000	MOVQ 0x138(SP), AX		
  0x44349b		488b4838		MOVQ 0x38(AX), CX		
  0x44349f		488b942430010000	MOVQ 0x130(SP), DX		
  0x4434a7		48394a38		CMPQ CX, 0x38(DX)		
  0x4434ab		7419			JE 0x4434c6			
  0x4434ad		31c0			XORL AX, AX			
  0x4434af		88842448010000		MOVB AL, 0x148(SP)		
  0x4434b6		488bac2420010000	MOVQ 0x120(SP), BP		
  0x4434be		4881c428010000		ADDQ $0x128, SP			
  0x4434c5		c3			RET				
  0x4434c6		488b4a30		MOVQ 0x30(DX), CX		
  0x4434ca		488b4030		MOVQ 0x30(AX), AX		
  0x4434ce		48890c24		MOVQ CX, 0(SP)			
  0x4434d2		4889442408		MOVQ AX, 0x8(SP)		
  0x4434d7		488b842440010000	MOVQ 0x140(SP), AX		
  0x4434df		4889442410		MOVQ AX, 0x10(SP)		
  0x4434e4		e8d7f6ffff		CALL runtime.typesEqual(SB)	
  0x4434e9		0fb6442418		MOVZX 0x18(SP), AX		
  0x4434ee		ebbf			JMP 0x4434af			
		return typesEqual(at.elem, av.elem, seen) && at.len == av.len
  0x4434f0		488b842430010000	MOVQ 0x130(SP), AX		
  0x4434f8		488b4830		MOVQ 0x30(AX), CX		
  0x4434fc		488b942438010000	MOVQ 0x138(SP), DX		
  0x443504		488b5a30		MOVQ 0x30(DX), BX		
  0x443508		48890c24		MOVQ CX, 0(SP)			
  0x44350c		48895c2408		MOVQ BX, 0x8(SP)		
  0x443511		488b8c2440010000	MOVQ 0x140(SP), CX		
  0x443519		48894c2410		MOVQ CX, 0x10(SP)		
  0x44351e		e89df6ffff		CALL runtime.typesEqual(SB)	
  0x443523		807c241800		CMPB $0x0, 0x18(SP)		
  0x443528		7432			JE 0x44355c			
  0x44352a		488b842438010000	MOVQ 0x138(SP), AX		
  0x443532		488b4040		MOVQ 0x40(AX), AX		
  0x443536		488b8c2430010000	MOVQ 0x130(SP), CX		
  0x44353e		48394140		CMPQ AX, 0x40(CX)		
  0x443542		0f94c0			SETE AL				
  0x443545		88842448010000		MOVB AL, 0x148(SP)		
  0x44354c		488bac2420010000	MOVQ 0x120(SP), BP		
  0x443554		4881c428010000		ADDQ $0x128, SP			
  0x44355b		c3			RET				
  0x44355c		31c0			XORL AX, AX			
  0x44355e		ebe5			JMP 0x443545			
	switch kind {
  0x443560		3c17			CMPL $0x17, AL		
  0x443562		0f87a2000000		JA 0x44360a		
	case kindPtr:
  0x443568		3c16			CMPL $0x16, AL		
  0x44356a		754f			JNE 0x4435bb		
		return typesEqual(pt.elem, pv.elem, seen)
  0x44356c		488b842430010000	MOVQ 0x130(SP), AX		
  0x443574		488b4030		MOVQ 0x30(AX), AX		
  0x443578		488b8c2438010000	MOVQ 0x138(SP), CX		
  0x443580		488b4930		MOVQ 0x30(CX), CX		
  0x443584		48890424		MOVQ AX, 0(SP)			
  0x443588		48894c2408		MOVQ CX, 0x8(SP)		
  0x44358d		488b842440010000	MOVQ 0x140(SP), AX		
  0x443595		4889442410		MOVQ AX, 0x10(SP)		
  0x44359a		e821f6ffff		CALL runtime.typesEqual(SB)	
  0x44359f		0fb6442418		MOVZX 0x18(SP), AX		
  0x4435a4		88842448010000		MOVB AL, 0x148(SP)		
  0x4435ab		488bac2420010000	MOVQ 0x120(SP), BP		
  0x4435b3		4881c428010000		ADDQ $0x128, SP			
  0x4435ba		c3			RET				
		return typesEqual(st.elem, sv.elem, seen)
  0x4435bb		488b842430010000	MOVQ 0x130(SP), AX		
  0x4435c3		488b4030		MOVQ 0x30(AX), AX		
  0x4435c7		488b8c2438010000	MOVQ 0x138(SP), CX		
  0x4435cf		488b4930		MOVQ 0x30(CX), CX		
  0x4435d3		48890424		MOVQ AX, 0(SP)			
  0x4435d7		48894c2408		MOVQ CX, 0x8(SP)		
  0x4435dc		488b842440010000	MOVQ 0x140(SP), AX		
  0x4435e4		4889442410		MOVQ AX, 0x10(SP)		
  0x4435e9		e8d2f5ffff		CALL runtime.typesEqual(SB)	
  0x4435ee		0fb6442418		MOVZX 0x18(SP), AX		
  0x4435f3		88842448010000		MOVB AL, 0x148(SP)		
  0x4435fa		488bac2420010000	MOVQ 0x120(SP), BP		
  0x443602		4881c428010000		ADDQ $0x128, SP			
  0x443609		c3			RET				
	case kindString, kindUnsafePointer:
  0x44360a		3c18			CMPL $0x18, AL		
  0x44360c		7518			JNE 0x443626		
		return true
  0x44360e		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443616		488bac2420010000	MOVQ 0x120(SP), BP	
  0x44361e		4881c428010000		ADDQ $0x128, SP		
  0x443625		c3			RET			
	case kindStruct:
  0x443626		3c19			CMPL $0x19, AL		
  0x443628		0f85ff020000		JNE 0x44392d		
		if len(st.fields) != len(sv.fields) {
  0x44362e		488b842438010000	MOVQ 0x138(SP), AX	
  0x443636		488b4840		MOVQ 0x40(AX), CX	
  0x44363a		488b942430010000	MOVQ 0x130(SP), DX	
  0x443642		48394a40		CMPQ CX, 0x40(DX)	
  0x443646		0f85c9020000		JNE 0x443915		
		if st.pkgPath.name() != sv.pkgPath.name() {
  0x44364c		488b4230		MOVQ 0x30(DX), AX		
  0x443650		48890424		MOVQ AX, 0(SP)			
  0x443654		e8f7ecffff		CALL runtime.name.name(SB)	
  0x443659		488b442410		MOVQ 0x10(SP), AX		
  0x44365e		4889442478		MOVQ AX, 0x78(SP)		
  0x443663		488b4c2408		MOVQ 0x8(SP), CX		
  0x443668		48898c2408010000	MOVQ CX, 0x108(SP)		
  0x443670		488b942438010000	MOVQ 0x138(SP), DX		
  0x443678		488b5a30		MOVQ 0x30(DX), BX		
  0x44367c		48891c24		MOVQ BX, 0(SP)			
  0x443680		e8cbecffff		CALL runtime.name.name(SB)	
  0x443685		488b442478		MOVQ 0x78(SP), AX		
  0x44368a		4839442410		CMPQ AX, 0x10(SP)		
  0x44368f		7418			JE 0x4436a9			
			return false
  0x443691		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x443699		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4436a1		4881c428010000		ADDQ $0x128, SP		
  0x4436a8		c3			RET			
		if st.pkgPath.name() != sv.pkgPath.name() {
  0x4436a9		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x4436b1		48890c24		MOVQ CX, 0(SP)			
  0x4436b5		4889442410		MOVQ AX, 0x10(SP)		
  0x4436ba		e861ebfbff		CALL runtime.memequal(SB)	
  0x4436bf		807c241800		CMPB $0x0, 0x18(SP)		
  0x4436c4		74cb			JE 0x443691			
		for i := range st.fields {
  0x4436c6		488b842430010000	MOVQ 0x130(SP), AX	
  0x4436ce		488b4840		MOVQ 0x40(AX), CX	
  0x4436d2		48894c2478		MOVQ CX, 0x78(SP)	
  0x4436d7		488b942438010000	MOVQ 0x138(SP), DX	
  0x4436df		31db			XORL BX, BX		
  0x4436e1		eb27			JMP 0x44370a		
  0x4436e3		488b742448		MOVQ 0x48(SP), SI	
  0x4436e8		488d5e01		LEAQ 0x1(SI), BX	
  0x4436ec		488b742478		MOVQ 0x78(SP), SI	
  0x4436f1		488bbc2438010000	MOVQ 0x138(SP), DI	
  0x4436f9		4c8b842430010000	MOVQ 0x130(SP), R8	
			tf := &st.fields[i]
  0x443701		4c89c0			MOVQ R8, AX		
		for i := range st.fields {
  0x443704		4889f1			MOVQ SI, CX		
			vf := &sv.fields[i]
  0x443707		4889fa			MOVQ DI, DX		
		for i := range st.fields {
  0x44370a		4839cb			CMPQ CX, BX		
  0x44370d		0f8dea010000		JGE 0x4438fd		
			tf := &st.fields[i]
  0x443713		488b7038		MOVQ 0x38(AX), SI	
  0x443717		48395840		CMPQ BX, 0x40(AX)	
  0x44371b		0f865a030000		JBE 0x443a7b		
  0x443721		488d3c5b		LEAQ 0(BX)(BX*2), DI	
			vf := &sv.fields[i]
  0x443725		4c8b4238		MOVQ 0x38(DX), R8	
  0x443729		48395a40		CMPQ BX, 0x40(DX)	
  0x44372d		0f8641030000		JBE 0x443a74		
			tf := &st.fields[i]
  0x443733		4889b424c8000000	MOVQ SI, 0xc8(SP)	
			vf := &sv.fields[i]
  0x44373b		4c898424c0000000	MOVQ R8, 0xc0(SP)	
			tf := &st.fields[i]
  0x443743		48897c2470		MOVQ DI, 0x70(SP)	
		for i := range st.fields {
  0x443748		48895c2448		MOVQ BX, 0x48(SP)	
			if tf.name.name() != vf.name.name() {
  0x44374d		488b04fe		MOVQ 0(SI)(DI*8), AX		
  0x443751		48890424		MOVQ AX, 0(SP)			
  0x443755		e8f6ebffff		CALL runtime.name.name(SB)	
  0x44375a		488b442408		MOVQ 0x8(SP), AX		
  0x44375f		4889842408010000	MOVQ AX, 0x108(SP)		
  0x443767		488b4c2410		MOVQ 0x10(SP), CX		
  0x44376c		48894c2468		MOVQ CX, 0x68(SP)		
  0x443771		488b542470		MOVQ 0x70(SP), DX		
  0x443776		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x44377e		488b34d3		MOVQ 0(BX)(DX*8), SI		
  0x443782		48893424		MOVQ SI, 0(SP)			
  0x443786		e8c5ebffff		CALL runtime.name.name(SB)	
  0x44378b		488b442468		MOVQ 0x68(SP), AX		
  0x443790		4839442410		CMPQ AX, 0x10(SP)		
  0x443795		0f854a010000		JNE 0x4438e5			
  0x44379b		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x4437a3		48890c24		MOVQ CX, 0(SP)			
  0x4437a7		4889442410		MOVQ AX, 0x10(SP)		
  0x4437ac		e86feafbff		CALL runtime.memequal(SB)	
  0x4437b1		807c241800		CMPB $0x0, 0x18(SP)		
  0x4437b6		0f8429010000		JE 0x4438e5			
			if !typesEqual(tf.typ, vf.typ, seen) {
  0x4437bc		488b442470		MOVQ 0x70(SP), AX		
  0x4437c1		488b8c24c8000000	MOVQ 0xc8(SP), CX		
  0x4437c9		488b54c108		MOVQ 0x8(CX)(AX*8), DX		
  0x4437ce		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x4437d6		488b74c308		MOVQ 0x8(BX)(AX*8), SI		
  0x4437db		48891424		MOVQ DX, 0(SP)			
  0x4437df		4889742408		MOVQ SI, 0x8(SP)		
  0x4437e4		488b942440010000	MOVQ 0x140(SP), DX		
  0x4437ec		4889542410		MOVQ DX, 0x10(SP)		
  0x4437f1		e8caf3ffff		CALL runtime.typesEqual(SB)	
  0x4437f6		807c241800		CMPB $0x0, 0x18(SP)		
  0x4437fb		0f84cc000000		JE 0x4438cd			
			if tf.name.tag() != vf.name.tag() {
  0x443801		488b442470		MOVQ 0x70(SP), AX		
  0x443806		488b8c24c8000000	MOVQ 0xc8(SP), CX		
  0x44380e		488b14c1		MOVQ 0(CX)(AX*8), DX		
  0x443812		48891424		MOVQ DX, 0(SP)			
  0x443816		e885ebffff		CALL runtime.name.tag(SB)	
  0x44381b		488b442410		MOVQ 0x10(SP), AX		
  0x443820		4889442468		MOVQ AX, 0x68(SP)		
  0x443825		488b4c2408		MOVQ 0x8(SP), CX		
  0x44382a		48898c2408010000	MOVQ CX, 0x108(SP)		
  0x443832		488b542470		MOVQ 0x70(SP), DX		
  0x443837		488b9c24c0000000	MOVQ 0xc0(SP), BX		
  0x44383f		488b34d3		MOVQ 0(BX)(DX*8), SI		
  0x443843		48893424		MOVQ SI, 0(SP)			
  0x443847		e854ebffff		CALL runtime.name.tag(SB)	
  0x44384c		488b442468		MOVQ 0x68(SP), AX		
  0x443851		4839442410		CMPQ AX, 0x10(SP)		
  0x443856		755d			JNE 0x4438b5			
  0x443858		488b8c2408010000	MOVQ 0x108(SP), CX		
  0x443860		48890c24		MOVQ CX, 0(SP)			
  0x443864		4889442410		MOVQ AX, 0x10(SP)		
  0x443869		e8b2e9fbff		CALL runtime.memequal(SB)	
  0x44386e		807c241800		CMPB $0x0, 0x18(SP)		
  0x443873		7440			JE 0x4438b5			
			if tf.offsetAnon != vf.offsetAnon {
  0x443875		488b442470		MOVQ 0x70(SP), AX	
  0x44387a		488b8c24c8000000	MOVQ 0xc8(SP), CX	
  0x443882		488b4cc110		MOVQ 0x10(CX)(AX*8), CX	
  0x443887		488b9424c0000000	MOVQ 0xc0(SP), DX	
  0x44388f		488b44c210		MOVQ 0x10(DX)(AX*8), AX	
  0x443894		4839c1			CMPQ AX, CX		
  0x443897		0f8446feffff		JE 0x4436e3		
				return false
  0x44389d		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4438a5		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4438ad		4881c428010000		ADDQ $0x128, SP		
  0x4438b4		c3			RET			
				return false
  0x4438b5		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4438bd		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4438c5		4881c428010000		ADDQ $0x128, SP		
  0x4438cc		c3			RET			
				return false
  0x4438cd		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4438d5		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4438dd		4881c428010000		ADDQ $0x128, SP		
  0x4438e4		c3			RET			
				return false
  0x4438e5		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x4438ed		488bac2420010000	MOVQ 0x120(SP), BP	
  0x4438f5		4881c428010000		ADDQ $0x128, SP		
  0x4438fc		c3			RET			
		return true
  0x4438fd		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443905		488bac2420010000	MOVQ 0x120(SP), BP	
  0x44390d		4881c428010000		ADDQ $0x128, SP		
  0x443914		c3			RET			
			return false
  0x443915		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x44391d		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443925		4881c428010000		ADDQ $0x128, SP		
  0x44392c		c3			RET			
	case kindString, kindUnsafePointer:
  0x44392d		3c1a			CMPL $0x1a, AL		
  0x44392f		0f84d9fcffff		JE 0x44360e		
  0x443935		e980010000		JMP 0x443aba		
		return true
  0x44393a		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443942		488bac2420010000	MOVQ 0x120(SP), BP	
  0x44394a		4881c428010000		ADDQ $0x128, SP		
  0x443951		c3			RET			
	if ut != nil || uv != nil {
  0x443952		4885c9			TESTQ CX, CX		
		if ut == nil || uv == nil {
  0x443955		7405			JE 0x44395c		
  0x443957		4885c0			TESTQ AX, AX		
  0x44395a		7518			JNE 0x443974		
			return false
  0x44395c		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x443964		488bac2420010000	MOVQ 0x120(SP), BP	
  0x44396c		4881c428010000		ADDQ $0x128, SP		
  0x443973		c3			RET			
	uv := v.uncommon()
  0x443974		4889842490000000	MOVQ AX, 0x90(SP)	
		pkgpatht := t.nameOff(ut.pkgpath).name()
  0x44397c		90			NOPL			
  0x44397d		8b01			MOVL 0(CX), AX		
	return resolveNameOff(unsafe.Pointer(t), off)
  0x44397f		488b8c2430010000	MOVQ 0x130(SP), CX		
  0x443987		48890c24		MOVQ CX, 0(SP)			
  0x44398b		89442408		MOVL AX, 0x8(SP)		
  0x44398f		e8ccdfffff		CALL runtime.resolveNameOff(SB)	
  0x443994		488b442410		MOVQ 0x10(SP), AX		
		pkgpatht := t.nameOff(ut.pkgpath).name()
  0x443999		48890424		MOVQ AX, 0(SP)			
  0x44399d		e8aee9ffff		CALL runtime.name.name(SB)	
  0x4439a2		488b442410		MOVQ 0x10(SP), AX		
  0x4439a7		4889442440		MOVQ AX, 0x40(SP)		
  0x4439ac		488b4c2408		MOVQ 0x8(SP), CX		
  0x4439b1		48898c24b8000000	MOVQ CX, 0xb8(SP)		
		pkgpathv := v.nameOff(uv.pkgpath).name()
  0x4439b9		90			NOPL			
  0x4439ba		488b942490000000	MOVQ 0x90(SP), DX	
  0x4439c2		8b12			MOVL 0(DX), DX		
	return resolveNameOff(unsafe.Pointer(t), off)
  0x4439c4		488b9c2438010000	MOVQ 0x138(SP), BX		
  0x4439cc		48891c24		MOVQ BX, 0(SP)			
  0x4439d0		89542408		MOVL DX, 0x8(SP)		
  0x4439d4		e887dfffff		CALL runtime.resolveNameOff(SB)	
  0x4439d9		488b442410		MOVQ 0x10(SP), AX		
		pkgpathv := v.nameOff(uv.pkgpath).name()
  0x4439de		48890424		MOVQ AX, 0(SP)			
  0x4439e2		e869e9ffff		CALL runtime.name.name(SB)	
		if pkgpatht != pkgpathv {
  0x4439e7		488b442440		MOVQ 0x40(SP), AX		
  0x4439ec		4839442410		CMPQ AX, 0x10(SP)		
  0x4439f1		7521			JNE 0x443a14			
  0x4439f3		488b8c24b8000000	MOVQ 0xb8(SP), CX		
  0x4439fb		48890c24		MOVQ CX, 0(SP)			
  0x4439ff		4889442410		MOVQ AX, 0x10(SP)		
  0x443a04		e817e8fbff		CALL runtime.memequal(SB)	
  0x443a09		807c241800		CMPB $0x0, 0x18(SP)		
  0x443a0e		0f857ef3ffff		JNE 0x442d92			
			return false
  0x443a14		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x443a1c		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443a24		4881c428010000		ADDQ $0x128, SP		
  0x443a2b		c3			RET			
		return false
  0x443a2c		c684244801000000	MOVB $0x0, 0x148(SP)	
  0x443a34		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443a3c		4881c428010000		ADDQ $0x128, SP		
  0x443a43		c3			RET			
		return true
  0x443a44		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443a4c		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443a54		4881c428010000		ADDQ $0x128, SP		
  0x443a5b		c3			RET			
		return true
  0x443a5c		c684244801000001	MOVB $0x1, 0x148(SP)	
  0x443a64		488bac2420010000	MOVQ 0x120(SP), BP	
  0x443a6c		4881c428010000		ADDQ $0x128, SP		
  0x443a73		c3			RET			
			vf := &sv.fields[i]
  0x443a74		e8a7e4fdff		CALL runtime.panicindex(SB)	
  0x443a79		0f0b			UD2				
			tf := &st.fields[i]
  0x443a7b		e8a0e4fdff		CALL runtime.panicindex(SB)	
  0x443a80		0f0b			UD2				
			vm := &iv.mhdr[i]
  0x443a82		e899e4fdff		CALL runtime.panicindex(SB)	
  0x443a87		0f0b			UD2				
			tm := &it.mhdr[i]
  0x443a89		e892e4fdff		CALL runtime.panicindex(SB)	
  0x443a8e		0f0b			UD2				
			if !typesEqual(tout[i], vout[i], seen) {
  0x443a90		e88be4fdff		CALL runtime.panicindex(SB)	
  0x443a95		0f0b			UD2				
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[t.inCount : t.inCount+outCount]
  0x443a97		e8b4e5fdff		CALL runtime.panicslice(SB)	
  0x443a9c		0f0b			UD2				
  0x443a9e		e8ade5fdff		CALL runtime.panicslice(SB)	
  0x443aa3		0f0b			UD2				
			if !typesEqual(tin[i], vin[i], seen) {
  0x443aa5		e876e4fdff		CALL runtime.panicindex(SB)	
  0x443aaa		0f0b			UD2				
	return (*[1 << 20]*_type)(add(unsafe.Pointer(t), uadd))[:t.inCount]
  0x443aac		e89fe5fdff		CALL runtime.panicslice(SB)	
  0x443ab1		0f0b			UD2				
  0x443ab3		e898e5fdff		CALL runtime.panicslice(SB)	
  0x443ab8		0f0b			UD2				
		println("runtime: impossible type kind", kind)
  0x443aba		e80104feff		CALL runtime.printlock(SB)	
  0x443abf		488d05bce10200		LEAQ 0x2e1bc(IP), AX		
  0x443ac6		48890424		MOVQ AX, 0(SP)			
  0x443aca		48c74424081e000000	MOVQ $0x1e, 0x8(SP)		
  0x443ad3		e8180dfeff		CALL runtime.printstring(SB)	
  0x443ad8		0fb644242b		MOVZX 0x2b(SP), AX		
  0x443add		83e01f			ANDL $0x1f, AX			
  0x443ae0		48890424		MOVQ AX, 0(SP)			
  0x443ae4		e8570afeff		CALL runtime.printuint(SB)	
  0x443ae9		e86206feff		CALL runtime.printnl(SB)	
  0x443aee		e84d04feff		CALL runtime.printunlock(SB)	
		throw("runtime: impossible type kind")
  0x443af3		488d050fde0200		LEAQ 0x2de0f(IP), AX	
  0x443afa		48890424		MOVQ AX, 0(SP)		
  0x443afe		48c74424081d000000	MOVQ $0x1d, 0x8(SP)	
  0x443b07		e874f9fdff		CALL runtime.throw(SB)	
  0x443b0c		0f0b			UD2			
func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool {
  0x443b0e		e86d3d0000		CALL runtime.morestack_noctxt(SB)	
  0x443b13		e9a8f0ffff		JMP runtime.typesEqual(SB)		

TEXT runtime.vdsoInitFromSysinfoEhdr(SB) /usr/local/go/src/runtime/vdso_linux.go
func vdsoInitFromSysinfoEhdr(info *vdsoInfo, hdr *elfEhdr) {
  0x443b20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443b29		483b6110		CMPQ 0x10(CX), SP	
  0x443b2d		0f8641040000		JBE 0x443f74		
  0x443b33		4883ec08		SUBQ $0x8, SP		
  0x443b37		48892c24		MOVQ BP, 0(SP)		
  0x443b3b		488d2c24		LEAQ 0(SP), BP		
	info.valid = false
  0x443b3f		488b4c2410		MOVQ 0x10(SP), CX	
  0x443b44		c60100			MOVB $0x0, 0(CX)	
	info.loadAddr = uintptr(unsafe.Pointer(hdr))
  0x443b47		488b542418		MOVQ 0x18(SP), DX	
  0x443b4c		4889d3			MOVQ DX, BX		
  0x443b4f		48895108		MOVQ DX, 0x8(CX)	
	pt := unsafe.Pointer(info.loadAddr + uintptr(hdr.e_phoff))
  0x443b53		488b7320		MOVQ 0x20(BX), SI	
  0x443b57		4801f2			ADDQ SI, DX		
  0x443b5a		31c0			XORL AX, AX		
  0x443b5c		31f6			XORL SI, SI		
  0x443b5e		31ff			XORL DI, DI		
	for i := uint16(0); i < hdr.e_phnum; i++ {
  0x443b60		eb02			JMP 0x443b64		
  0x443b62		ffc0			INCL AX			
  0x443b64		66394338		CMPW AX, 0x38(BX)	
  0x443b68		7647			JBE 0x443bb1		
		pt := (*elfPhdr)(add(pt, uintptr(i)*unsafe.Sizeof(elfPhdr{})))
  0x443b6a		90			NOPL			
  0x443b6b		440fb7c0		MOVZX AX, R8		
  0x443b6f		4d6bc038		IMULQ $0x38, R8, R8	
		switch pt.p_type {
  0x443b73		468b0c02		MOVL 0(DX)(R8*1), R9	
		case _PT_LOAD:
  0x443b77		4183f901		CMPL $0x1, R9		
  0x443b7b		7523			JNE 0x443ba0		
			if !foundVaddr {
  0x443b7d		4084f6			TESTL SI, SI		
  0x443b80		7407			JE 0x443b89		
	for i := uint16(0); i < hdr.e_phnum; i++ {
  0x443b82		be01000000		MOVL $0x1, SI		
		switch pt.p_type {
  0x443b87		ebd9			JMP 0x443b62		
				info.loadOffset = info.loadAddr + uintptr(pt.p_offset-pt.p_vaddr)
  0x443b89		498b741008		MOVQ 0x8(R8)(DX*1), SI	
  0x443b8e		4e8b440210		MOVQ 0x10(DX)(R8*1), R8	
  0x443b93		4c29c6			SUBQ R8, SI		
  0x443b96		48037108		ADDQ 0x8(CX), SI	
  0x443b9a		48897110		MOVQ SI, 0x10(CX)	
  0x443b9e		ebe2			JMP 0x443b82		
		case _PT_DYNAMIC:
  0x443ba0		4183f902		CMPL $0x2, R9		
  0x443ba4		75bc			JNE 0x443b62		
			dyn = (*[vdsoDynSize]elfDyn)(unsafe.Pointer(info.loadAddr + uintptr(pt.p_offset)))
  0x443ba6		498b7c1008		MOVQ 0x8(R8)(DX*1), DI	
  0x443bab		48037908		ADDQ 0x8(CX), DI	
		switch pt.p_type {
  0x443baf		ebb1			JMP 0x443b62		
			if !foundVaddr {
  0x443bb1		4084f6			TESTL SI, SI		
	if !foundVaddr || dyn == nil {
  0x443bb4		0f848e030000		JE 0x443f48		
  0x443bba		4885ff			TESTQ DI, DI		
  0x443bbd		0f8485030000		JE 0x443f48		
	info.symstrings = nil
  0x443bc3		488d5120		LEAQ 0x20(CX), DX	
	info.symtab = nil
  0x443bc7		488d5918		LEAQ 0x18(CX), BX	
	info.versym = nil
  0x443bcb		488d7160		LEAQ 0x60(CX), SI	
	info.verdef = nil
  0x443bcf		4c8d4168		LEAQ 0x68(CX), R8	
	info.symstrings = nil
  0x443bd3		833d4692090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443bda		0f8532030000		JNE 0x443f12				
  0x443be0		48c7412000000000	MOVQ $0x0, 0x20(CX)			
	info.symtab = nil
  0x443be8		48c7411800000000	MOVQ $0x0, 0x18(CX)	
	info.verdef = nil
  0x443bf0		0f57c0			XORPS X0, X0		
  0x443bf3		0f114160		MOVUPS X0, 0x60(CX)	
  0x443bf7		31c0			XORL AX, AX		
  0x443bf9		4531c9			XORL R9, R9		
  0x443bfc		4531d2			XORL R10, R10		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443bff		eb09			JMP 0x443c0a		
  0x443c01		49ffc4			INCQ R12		
		nbucket := hash[0]
  0x443c04		4989c2			MOVQ AX, R10		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443c07		4c89e0			MOVQ R12, AX			
  0x443c0a		49bbffffffffff3f0000	MOVQ $0x3fffffffffff, R11	
  0x443c14		4c39d8			CMPQ R11, AX			
  0x443c17		0f8350030000		JAE 0x443f6d			
  0x443c1d		4989c4			MOVQ AX, R12			
  0x443c20		48c1e004		SHLQ $0x4, AX			
  0x443c24		4c8b2c07		MOVQ 0(DI)(AX*1), R13		
  0x443c28		4d85ed			TESTQ R13, R13			
  0x443c2b		0f84e2000000		JE 0x443d13			
		p := info.loadOffset + uintptr(dt.d_val)
  0x443c31		488b440708		MOVQ 0x8(DI)(AX*1), AX	
  0x443c36		48034110		ADDQ 0x10(CX), AX	
		switch dt.d_tag {
  0x443c3a		4983fd06		CMPQ $0x6, R13		
  0x443c3e		7f63			JG 0x443ca3		
		case _DT_HASH:
  0x443c40		4983fd04		CMPQ $0x4, R13		
  0x443c44		7502			JNE 0x443c48		
		switch dt.d_tag {
  0x443c46		ebb9			JMP 0x443c01		
		case _DT_STRTAB:
  0x443c48		4983fd05		CMPQ $0x5, R13		
  0x443c4c		7522			JNE 0x443c70		
			info.symstrings = (*[vdsoSymStringsSize]byte)(unsafe.Pointer(p))
  0x443c4e		833dcb91090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443c55		7509			JNE 0x443c60				
  0x443c57		48894120		MOVQ AX, 0x20(CX)			
		nbucket := hash[0]
  0x443c5b		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443c5e		eba1			JMP 0x443c01		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443c60		4989fd			MOVQ DI, R13		
			info.symstrings = (*[vdsoSymStringsSize]byte)(unsafe.Pointer(p))
  0x443c63		4889d7			MOVQ DX, DI			
  0x443c66		e8155a0000		CALL runtime.gcWriteBarrier(SB)	
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443c6b		4c89ef			MOVQ R13, DI		
			info.symstrings = (*[vdsoSymStringsSize]byte)(unsafe.Pointer(p))
  0x443c6e		ebeb			JMP 0x443c5b		
		switch dt.d_tag {
  0x443c70		4983fd06		CMPQ $0x6, R13		
		case _DT_SYMTAB:
  0x443c74		7525			JNE 0x443c9b		
			info.symtab = (*[vdsoSymTabSize]elfSym)(unsafe.Pointer(p))
  0x443c76		833da391090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443c7d		750c			JNE 0x443c8b				
  0x443c7f		48894118		MOVQ AX, 0x18(CX)			
		nbucket := hash[0]
  0x443c83		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443c86		e976ffffff		JMP 0x443c01		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443c8b		4989fd			MOVQ DI, R13		
			info.symtab = (*[vdsoSymTabSize]elfSym)(unsafe.Pointer(p))
  0x443c8e		4889df			MOVQ BX, DI			
  0x443c91		e8ea590000		CALL runtime.gcWriteBarrier(SB)	
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443c96		4c89ef			MOVQ R13, DI		
			info.symtab = (*[vdsoSymTabSize]elfSym)(unsafe.Pointer(p))
  0x443c99		ebe8			JMP 0x443c83		
		nbucket := hash[0]
  0x443c9b		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443c9e		e95effffff		JMP 0x443c01		
		case _DT_GNU_HASH:
  0x443ca3		4981fdf5feff6f		CMPQ $0x6ffffef5, R13	
  0x443caa		750b			JNE 0x443cb7		
	if gnuhash != nil {
  0x443cac		4989c1			MOVQ AX, R9		
		nbucket := hash[0]
  0x443caf		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443cb2		e94affffff		JMP 0x443c01		
		case _DT_VERSYM:
  0x443cb7		4981fdf0ffff6f		CMPQ $0x6ffffff0, R13	
  0x443cbe		7525			JNE 0x443ce5		
			info.versym = (*[vdsoVerSymSize]uint16)(unsafe.Pointer(p))
  0x443cc0		833d5991090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443cc7		750c			JNE 0x443cd5				
  0x443cc9		48894160		MOVQ AX, 0x60(CX)			
		nbucket := hash[0]
  0x443ccd		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443cd0		e92cffffff		JMP 0x443c01		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443cd5		4989fd			MOVQ DI, R13		
			info.versym = (*[vdsoVerSymSize]uint16)(unsafe.Pointer(p))
  0x443cd8		4889f7			MOVQ SI, DI			
  0x443cdb		e8a0590000		CALL runtime.gcWriteBarrier(SB)	
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443ce0		4c89ef			MOVQ R13, DI		
			info.versym = (*[vdsoVerSymSize]uint16)(unsafe.Pointer(p))
  0x443ce3		ebe8			JMP 0x443ccd		
		case _DT_VERDEF:
  0x443ce5		4981fdfcffff6f		CMPQ $0x6ffffffc, R13	
  0x443cec		75ad			JNE 0x443c9b		
			info.verdef = (*elfVerdef)(unsafe.Pointer(p))
  0x443cee		833d2b91090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443cf5		750c			JNE 0x443d03				
  0x443cf7		48894168		MOVQ AX, 0x68(CX)			
		nbucket := hash[0]
  0x443cfb		4c89d0			MOVQ R10, AX		
		switch dt.d_tag {
  0x443cfe		e9fefeffff		JMP 0x443c01		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443d03		4989fd			MOVQ DI, R13		
			info.verdef = (*elfVerdef)(unsafe.Pointer(p))
  0x443d06		4c89c7			MOVQ R8, DI			
  0x443d09		e872590000		CALL runtime.gcWriteBarrier(SB)	
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443d0e		4c89ef			MOVQ R13, DI		
			info.verdef = (*elfVerdef)(unsafe.Pointer(p))
  0x443d11		ebe8			JMP 0x443cfb		
	if info.symstrings == nil || info.symtab == nil || (hash == nil && gnuhash == nil) {
  0x443d13		4883792000		CMPQ $0x0, 0x20(CX)	
  0x443d18		7416			JE 0x443d30		
  0x443d1a		4883791800		CMPQ $0x0, 0x18(CX)	
  0x443d1f		740f			JE 0x443d30		
  0x443d21		4d85d2			TESTQ R10, R10		
  0x443d24		0f84dd010000		JE 0x443f07		
  0x443d2a		31c0			XORL AX, AX		
  0x443d2c		84c0			TESTL AL, AL		
  0x443d2e		7409			JE 0x443d39		
		return // Failed
  0x443d30		488b2c24		MOVQ 0(SP), BP		
  0x443d34		4883c408		ADDQ $0x8, SP		
  0x443d38		c3			RET			
	if info.verdef == nil {
  0x443d39		4883796800		CMPQ $0x0, 0x68(CX)	
  0x443d3e		0f849e010000		JE 0x443ee2		
	if gnuhash != nil {
  0x443d44		4d85c9			TESTQ R9, R9		
  0x443d47		0f84d2000000		JE 0x443e1f		
		nbucket := gnuhash[0]
  0x443d4d		418b11			MOVL 0(R9), DX		
		info.symOff = gnuhash[1]
  0x443d50		418b5904		MOVL 0x4(R9), BX	
  0x443d54		895958			MOVL BX, 0x58(CX)	
		bloomSize := gnuhash[2]
  0x443d57		418b5908		MOVL 0x8(R9), BX	
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x443d5b		8d341b			LEAL 0(BX)(BX*1), SI		
  0x443d5e		8d7604			LEAL 0x4(SI), SI		
  0x443d61		49b8ffffffffffff0000	MOVQ $0xffffffffffff, R8	
  0x443d6b		4c39c6			CMPQ R8, SI			
  0x443d6e		0f87f2010000		JA 0x443f66			
  0x443d74		4189f2			MOVL SI, R10			
  0x443d77		48c1e602		SHLQ $0x2, SI			
  0x443d7b		4d29d0			SUBQ R10, R8			
  0x443d7e		4d89c2			MOVQ R8, R10			
  0x443d81		49f7d8			NEGQ R8				
  0x443d84		49c1f83f		SARQ $0x3f, R8			
  0x443d88		4c21c6			ANDQ R8, SI			
  0x443d8b		498d0431		LEAQ 0(R9)(SI*1), AX		
  0x443d8f		4885d2			TESTQ DX, DX			
  0x443d92		0f8cce010000		JL 0x443f66			
  0x443d98		4c39d2			CMPQ R10, DX			
  0x443d9b		0f87c5010000		JA 0x443f66			
  0x443da1		48895148		MOVQ DX, 0x48(CX)		
  0x443da5		4c895150		MOVQ R10, 0x50(CX)		
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x443da9		8d145a			LEAL 0(DX)(BX*2), DX	
  0x443dac		8d5204			LEAL 0x4(DX), DX	
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x443daf		833d6a90090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443db6		755c			JNE 0x443e14				
  0x443db8		48894140		MOVQ AX, 0x40(CX)			
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x443dbc		48bbffffffffffff0000	MOVQ $0xffffffffffff, BX		
  0x443dc6		4839da			CMPQ BX, DX				
  0x443dc9		0f8790010000		JA 0x443f5f				
  0x443dcf		4829d3			SUBQ DX, BX				
  0x443dd2		48895930		MOVQ BX, 0x30(CX)			
  0x443dd6		48895938		MOVQ BX, 0x38(CX)			
  0x443dda		48f7db			NEGQ BX					
  0x443ddd		48c1e202		SHLQ $0x2, DX				
  0x443de1		48c1fb3f		SARQ $0x3f, BX				
  0x443de5		4821da			ANDQ BX, DX				
  0x443de8		498d0411		LEAQ 0(R9)(DX*1), AX			
  0x443dec		833d2d90090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443df3		7514			JNE 0x443e09				
  0x443df5		48894128		MOVQ AX, 0x28(CX)			
		info.isGNUHash = true
  0x443df9		c6415c01		MOVB $0x1, 0x5c(CX)	
	info.valid = true
  0x443dfd		c60101			MOVB $0x1, 0(CX)	
}
  0x443e00		488b2c24		MOVQ 0(SP), BP		
  0x443e04		4883c408		ADDQ $0x8, SP		
  0x443e08		c3			RET			
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x443e09		488d7928		LEAQ 0x28(CX), DI		
  0x443e0d		e86e580000		CALL runtime.gcWriteBarrier(SB)	
  0x443e12		ebe5			JMP 0x443df9			
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x443e14		488d7940		LEAQ 0x40(CX), DI		
  0x443e18		e863580000		CALL runtime.gcWriteBarrier(SB)	
  0x443e1d		eb9d			JMP 0x443dbc			
		nbucket := hash[0]
  0x443e1f		418b12			MOVL 0(R10), DX		
		nchain := hash[1]
  0x443e22		418b5a04		MOVL 0x4(R10), BX	
		info.bucket = hash[2 : 2+nbucket]
  0x443e26		8d7202			LEAL 0x2(DX), SI		
  0x443e29		4885f6			TESTQ SI, SI			
  0x443e2c		0f8c26010000		JL 0x443f58			
  0x443e32		4883fe02		CMPQ $0x2, SI			
  0x443e36		0f821c010000		JB 0x443f58			
  0x443e3c		49b8ffffffffffff0000	MOVQ $0xffffffffffff, R8	
  0x443e46		4c39c6			CMPQ R8, SI			
  0x443e49		0f8709010000		JA 0x443f58			
  0x443e4f		4c8d4efe		LEAQ -0x2(SI), R9		
  0x443e53		4c894948		MOVQ R9, 0x48(CX)		
  0x443e57		49b9fdffffffffff0000	MOVQ $0xfffffffffffd, R9	
  0x443e61		4c894950		MOVQ R9, 0x50(CX)		
  0x443e65		498d4208		LEAQ 0x8(R10), AX		
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x443e69		8d141a			LEAL 0(DX)(BX*1), DX	
  0x443e6c		8d5202			LEAL 0x2(DX), DX	
		info.bucket = hash[2 : 2+nbucket]
  0x443e6f		833daa8f090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443e76		755f			JNE 0x443ed7				
  0x443e78		48894140		MOVQ AX, 0x40(CX)			
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x443e7c		4885d2			TESTQ DX, DX				
  0x443e7f		0f8ccc000000		JL 0x443f51				
  0x443e85		4839d6			CMPQ DX, SI				
  0x443e88		0f87c3000000		JA 0x443f51				
  0x443e8e		4c39c2			CMPQ R8, DX				
  0x443e91		0f87ba000000		JA 0x443f51				
  0x443e97		4829f2			SUBQ SI, DX				
  0x443e9a		48895130		MOVQ DX, 0x30(CX)			
  0x443e9e		4929f0			SUBQ SI, R8				
  0x443ea1		4c894138		MOVQ R8, 0x38(CX)			
  0x443ea5		48c1e602		SHLQ $0x2, SI				
  0x443ea9		49f7d8			NEGQ R8					
  0x443eac		49c1f83f		SARQ $0x3f, R8				
  0x443eb0		4c21c6			ANDQ R8, SI				
  0x443eb3		498d0432		LEAQ 0(R10)(SI*1), AX			
  0x443eb7		833d628f090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443ebe		7509			JNE 0x443ec9				
  0x443ec0		48894128		MOVQ AX, 0x28(CX)			
  0x443ec4		e934ffffff		JMP 0x443dfd				
  0x443ec9		488d7928		LEAQ 0x28(CX), DI			
  0x443ecd		e8ae570000		CALL runtime.gcWriteBarrier(SB)		
  0x443ed2		e926ffffff		JMP 0x443dfd				
		info.bucket = hash[2 : 2+nbucket]
  0x443ed7		488d7940		LEAQ 0x40(CX), DI		
  0x443edb		e8a0570000		CALL runtime.gcWriteBarrier(SB)	
  0x443ee0		eb9a			JMP 0x443e7c			
		info.versym = nil
  0x443ee2		833d378f090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x443ee9		750d			JNE 0x443ef8				
  0x443eeb		48c7416000000000	MOVQ $0x0, 0x60(CX)			
  0x443ef3		e94cfeffff		JMP 0x443d44				
  0x443ef8		4889f7			MOVQ SI, DI				
  0x443efb		31c0			XORL AX, AX				
  0x443efd		e87e570000		CALL runtime.gcWriteBarrier(SB)		
  0x443f02		e93dfeffff		JMP 0x443d44				
	if info.symstrings == nil || info.symtab == nil || (hash == nil && gnuhash == nil) {
  0x443f07		4d85c9			TESTQ R9, R9		
  0x443f0a		0f94c0			SETE AL			
  0x443f0d		e91afeffff		JMP 0x443d2c		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443f12		4889f8			MOVQ DI, AX		
	info.symstrings = nil
  0x443f15		4889d7			MOVQ DX, DI		
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443f18		4989c1			MOVQ AX, R9		
	info.symstrings = nil
  0x443f1b		31c0			XORL AX, AX			
  0x443f1d		e85e570000		CALL runtime.gcWriteBarrier(SB)	
	info.symtab = nil
  0x443f22		4889df			MOVQ BX, DI			
  0x443f25		31c0			XORL AX, AX			
  0x443f27		e854570000		CALL runtime.gcWriteBarrier(SB)	
	info.versym = nil
  0x443f2c		4889f7			MOVQ SI, DI			
  0x443f2f		31c0			XORL AX, AX			
  0x443f31		e84a570000		CALL runtime.gcWriteBarrier(SB)	
	info.verdef = nil
  0x443f36		4c89c7			MOVQ R8, DI			
  0x443f39		31c0			XORL AX, AX			
  0x443f3b		e840570000		CALL runtime.gcWriteBarrier(SB)	
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443f40		4c89cf			MOVQ R9, DI		
	info.symstrings = nil
  0x443f43		e9affcffff		JMP 0x443bf7		
		return // Failed
  0x443f48		488b2c24		MOVQ 0(SP), BP		
  0x443f4c		4883c408		ADDQ $0x8, SP		
  0x443f50		c3			RET			
		info.chain = hash[2+nbucket : 2+nbucket+nchain]
  0x443f51		e8fae0fdff		CALL runtime.panicslice(SB)	
  0x443f56		0f0b			UD2				
		info.bucket = hash[2 : 2+nbucket]
  0x443f58		e8f3e0fdff		CALL runtime.panicslice(SB)	
  0x443f5d		0f0b			UD2				
		info.chain = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale)+nbucket:]
  0x443f5f		e8ece0fdff		CALL runtime.panicslice(SB)	
  0x443f64		0f0b			UD2				
		info.bucket = gnuhash[4+bloomSize*uint32(vdsoBloomSizeScale):][:nbucket]
  0x443f66		e8e5e0fdff		CALL runtime.panicslice(SB)	
  0x443f6b		0f0b			UD2				
	for i := 0; dyn[i].d_tag != _DT_NULL; i++ {
  0x443f6d		e8aedffdff		CALL runtime.panicindex(SB)	
  0x443f72		0f0b			UD2				
func vdsoInitFromSysinfoEhdr(info *vdsoInfo, hdr *elfEhdr) {
  0x443f74		e807390000		CALL runtime.morestack_noctxt(SB)	
  0x443f79		e9a2fbffff		JMP runtime.vdsoInitFromSysinfoEhdr(SB)	

TEXT runtime.vdsoFindVersion(SB) /usr/local/go/src/runtime/vdso_linux.go
func vdsoFindVersion(info *vdsoInfo, ver *vdsoVersionKey) int32 {
  0x443f80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x443f89		483b6110		CMPQ 0x10(CX), SP	
  0x443f8d		0f8613010000		JBE 0x4440a6		
  0x443f93		4883ec48		SUBQ $0x48, SP		
  0x443f97		48896c2440		MOVQ BP, 0x40(SP)	
  0x443f9c		488d6c2440		LEAQ 0x40(SP), BP	
	if !info.valid {
  0x443fa1		488b442450		MOVQ 0x50(SP), AX	
  0x443fa6		803800			CMPB $0x0, 0(AX)	
  0x443fa9		0f84e5000000		JE 0x444094		
	def := info.verdef
  0x443faf		488b4868		MOVQ 0x68(AX), CX	
	for {
  0x443fb3		488b542458		MOVQ 0x58(SP), DX	
  0x443fb8		eb04			JMP 0x443fbe		
		def = (*elfVerdef)(add(unsafe.Pointer(def), uintptr(def.vd_next)))
  0x443fba		90			NOPL			
	return unsafe.Pointer(uintptr(p) + x)
  0x443fbb		4801d9			ADDQ BX, CX		
		if def.vd_flags&_VER_FLG_BASE == 0 {
  0x443fbe		0fb75902		MOVZX 0x2(CX), BX	
  0x443fc2		66f7c30100		TESTW $0x1, BX		
  0x443fc7		7512			JNE 0x443fdb		
			aux := (*elfVerdaux)(add(unsafe.Pointer(def), uintptr(def.vd_aux)))
  0x443fc9		90			NOPL			
  0x443fca		8b590c			MOVL 0xc(CX), BX	
			if def.vd_hash == ver.verHash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x443fcd		8b7210			MOVL 0x10(DX), SI	
  0x443fd0		397108			CMPL SI, 0x8(CX)	
  0x443fd3		7436			JE 0x44400b		
  0x443fd5		31db			XORL BX, BX		
  0x443fd7		84db			TESTL BL, BL		
  0x443fd9		7519			JNE 0x443ff4		
		if def.vd_next == 0 {
  0x443fdb		8b5910			MOVL 0x10(CX), BX	
  0x443fde		85db			TESTL BX, BX		
  0x443fe0		75d8			JNE 0x443fba		
	return -1 // cannot match any version
  0x443fe2		c7442460ffffffff	MOVL $-0x1, 0x60(SP)	
  0x443fea		488b6c2440		MOVQ 0x40(SP), BP	
  0x443fef		4883c448		ADDQ $0x48, SP		
  0x443ff3		c3			RET			
				return int32(def.vd_ndx & 0x7fff)
  0x443ff4		0fb74104		MOVZX 0x4(CX), AX	
  0x443ff8		25ff7f0000		ANDL $0x7fff, AX	
  0x443ffd		89442460		MOVL AX, 0x60(SP)	
  0x444001		488b6c2440		MOVQ 0x40(SP), BP	
  0x444006		4883c448		ADDQ $0x48, SP		
  0x44400a		c3			RET			
		if def.vd_flags&_VER_FLG_BASE == 0 {
  0x44400b		48894c2428		MOVQ CX, 0x28(SP)	
			if def.vd_hash == ver.verHash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x444010		488b5020		MOVQ 0x20(AX), DX	
  0x444014		8402			TESTB AL, 0(DX)		
  0x444016		90			NOPL			
  0x444017		8b1c19			MOVL 0(CX)(BX*1), BX	
  0x44401a		4801da			ADDQ BX, DX		
  0x44401d		4889542420		MOVQ DX, 0x20(SP)	
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x444022		48891424		MOVQ DX, 0(SP)			
  0x444026		e8d55fffff		CALL runtime.findnull(SB)	
  0x44402b		488b442408		MOVQ 0x8(SP), AX		
  0x444030		0f57c0			XORPS X0, X0			
  0x444033		0f11442430		MOVUPS X0, 0x30(SP)		
  0x444038		488b4c2420		MOVQ 0x20(SP), CX		
  0x44403d		48894c2430		MOVQ CX, 0x30(SP)		
  0x444042		4889442438		MOVQ AX, 0x38(SP)		
			if def.vd_hash == ver.verHash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x444047		488b4c2458		MOVQ 0x58(SP), CX	
  0x44404c		488b5108		MOVQ 0x8(CX), DX	
  0x444050		488b19			MOVQ 0(CX), BX		
	s := *(*string)(unsafe.Pointer(&ss))
  0x444053		488b742430		MOVQ 0x30(SP), SI	
			if def.vd_hash == ver.verHash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x444058		4839c2			CMPQ AX, DX		
  0x44405b		7418			JE 0x444075		
  0x44405d		31c0			XORL AX, AX		
		if def.vd_next == 0 {
  0x44405f		488b4c2428		MOVQ 0x28(SP), CX	
			if def.vd_hash == ver.verHash && ver.version == gostringnocopy(&info.symstrings[aux.vda_name]) {
  0x444064		488b542458		MOVQ 0x58(SP), DX		
  0x444069		89c3			MOVL AX, BX			
  0x44406b		488b442450		MOVQ 0x50(SP), AX		
  0x444070		e962ffffff		JMP 0x443fd7			
  0x444075		48891c24		MOVQ BX, 0(SP)			
  0x444079		4889742408		MOVQ SI, 0x8(SP)		
  0x44407e		4889542410		MOVQ DX, 0x10(SP)		
  0x444083		e898e1fbff		CALL runtime.memequal(SB)	
  0x444088		0fb6442418		MOVZX 0x18(SP), AX		
  0x44408d		488b4c2458		MOVQ 0x58(SP), CX		
  0x444092		ebcb			JMP 0x44405f			
		return 0
  0x444094		c744246000000000	MOVL $0x0, 0x60(SP)	
  0x44409c		488b6c2440		MOVQ 0x40(SP), BP	
  0x4440a1		4883c448		ADDQ $0x48, SP		
  0x4440a5		c3			RET			
func vdsoFindVersion(info *vdsoInfo, ver *vdsoVersionKey) int32 {
  0x4440a6		e8d5370000		CALL runtime.morestack_noctxt(SB)	
  0x4440ab		e9d0feffff		JMP runtime.vdsoFindVersion(SB)		

TEXT runtime.vdsoParseSymbols(SB) /usr/local/go/src/runtime/vdso_linux.go
func vdsoParseSymbols(info *vdsoInfo, version int32) {
  0x4440b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4440b9		488d4424e0		LEAQ -0x20(SP), AX	
  0x4440be		483b4110		CMPQ 0x10(CX), AX	
  0x4440c2		0f866b030000		JBE 0x444433		
  0x4440c8		4881eca0000000		SUBQ $0xa0, SP		
  0x4440cf		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x4440d7		488dac2498000000	LEAQ 0x98(SP), BP	
	if !info.valid {
  0x4440df		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x4440e7		803900			CMPB $0x0, 0(CX)	
  0x4440ea		0f8410030000		JE 0x444400		
	apply := func(symIndex uint32, k vdsoSymbolKey) bool {
  0x4440f0		0f57c0			XORPS X0, X0					
  0x4440f3		0f11842480000000	MOVUPS X0, 0x80(SP)				
  0x4440fb		c784249000000000000000	MOVL $0x0, 0x90(SP)				
  0x444106		488d1d332f0000		LEAQ runtime.vdsoParseSymbols.func1(SB), BX	
  0x44410d		48899c2480000000	MOVQ BX, 0x80(SP)				
  0x444115		48898c2488000000	MOVQ CX, 0x88(SP)				
  0x44411d		8b9c24b0000000		MOVL 0xb0(SP), BX				
  0x444124		899c2490000000		MOVL BX, 0x90(SP)				
	if !info.isGNUHash {
  0x44412b		80795c00		CMPB $0x0, 0x5c(CX)	
  0x44412f		0f8481010000		JE 0x4442b6		
	for _, k := range vdsoSymbolKeys {
  0x444135		488b1d1cbc0700		MOVQ runtime.vdsoSymbolKeys+8(SB), BX	
  0x44413c		488b350dbc0700		MOVQ runtime.vdsoSymbolKeys(SB), SI	
  0x444143		4885db			TESTQ BX, BX				
  0x444146		7e61			JLE 0x4441a9				
  0x444148		48895c2458		MOVQ BX, 0x58(SP)			
  0x44414d		31c0			XORL AX, AX				
  0x44414f		eb07			JMP 0x444158				
  0x444151		4883c620		ADDQ $0x20, SI				
  0x444155		4889f8			MOVQ DI, AX				
  0x444158		488b7e08		MOVQ 0x8(SI), DI			
  0x44415c		4c8b06			MOVQ 0(SI), R8				
  0x44415f		4c8b4e18		MOVQ 0x18(SI), R9			
  0x444163		448b5614		MOVL 0x14(SI), R10			
  0x444167		448b5e10		MOVL 0x10(SI), R11			
		symIndex := info.bucket[k.gnuHash%uint32(len(info.bucket))]
  0x44416b		4c8b6140		MOVQ 0x40(CX), R12	
  0x44416f		4c8b6948		MOVQ 0x48(CX), R13	
  0x444173		4585ed			TESTL R13, R13		
  0x444176		0f84a2020000		JE 0x44441e		
	for _, k := range vdsoSymbolKeys {
  0x44417c		4889c2			MOVQ AX, DX		
		symIndex := info.bucket[k.gnuHash%uint32(len(info.bucket))]
  0x44417f		4489d0			MOVL R10, AX		
	for _, k := range vdsoSymbolKeys {
  0x444182		4989d6			MOVQ DX, R14		
		symIndex := info.bucket[k.gnuHash%uint32(len(info.bucket))]
  0x444185		31d2			XORL DX, DX		
  0x444187		41f7f5			DIVL R13		
  0x44418a		4189d7			MOVL DX, R15		
  0x44418d		4d39ef			CMPQ R13, R15		
  0x444190		0f8381020000		JAE 0x444417		
  0x444196		478b24bc		MOVL 0(R12)(R15*4), R12	
		if symIndex < info.symOff {
  0x44419a		44396158		CMPL R12, 0x58(CX)	
  0x44419e		7619			JBE 0x4441b9		
	for _, k := range vdsoSymbolKeys {
  0x4441a0		498d7e01		LEAQ 0x1(R14), DI	
  0x4441a4		4839df			CMPQ BX, DI		
  0x4441a7		7ca8			JL 0x444151		
  0x4441a9		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4441b1		4881c4a0000000		ADDQ $0xa0, SP		
  0x4441b8		c3			RET			
  0x4441b9		48897c2450		MOVQ DI, 0x50(SP)	
  0x4441be		4c89442478		MOVQ R8, 0x78(SP)	
  0x4441c3		4889742470		MOVQ SI, 0x70(SP)	
  0x4441c8		4c89742448		MOVQ R14, 0x48(SP)	
  0x4441cd		4c894c2468		MOVQ R9, 0x68(SP)	
  0x4441d2		4489542444		MOVL R10, 0x44(SP)	
  0x4441d7		44895c2440		MOVL R11, 0x40(SP)	
			hash := info.chain[symIndex-info.symOff]
  0x4441dc		eb07			JMP 0x4441e5		
		for ; ; symIndex++ {
  0x4441de		448d6001		LEAL 0x1(AX), R12	
			if hash|1 == k.gnuHash|1 {
  0x4441e2		4589fa			MOVL R15, R10		
			hash := info.chain[symIndex-info.symOff]
  0x4441e5		4c8b6928		MOVQ 0x28(CX), R13	
  0x4441e9		448b7958		MOVL 0x58(CX), R15	
  0x4441ed		4489e0			MOVL R12, AX		
  0x4441f0		4529fc			SUBL R15, R12		
  0x4441f3		4c396130		CMPQ R12, 0x30(CX)	
  0x4441f7		0f8613020000		JBE 0x444410		
  0x4441fd		478b64a500		MOVL 0(R13)(R12*4), R12	
			if hash|1 == k.gnuHash|1 {
  0x444202		4589e5			MOVL R12, R13		
  0x444205		4183cc01		ORL $0x1, R12		
  0x444209		4589d7			MOVL R10, R15		
  0x44420c		4183ca01		ORL $0x1, R10		
  0x444210		4539d4			CMPL R10, R12		
  0x444213		7409			JE 0x44421e		
			if hash&1 != 0 {
  0x444215		410fbae500		BTL $0x0, R13		
  0x44421a		73c2			JAE 0x4441de		
  0x44421c		eb82			JMP 0x4441a0		
			hash := info.chain[symIndex-info.symOff]
  0x44421e		44896c243c		MOVL R13, 0x3c(SP)	
  0x444223		89442438		MOVL AX, 0x38(SP)	
				if apply(symIndex, k) {
  0x444227		890424			MOVL AX, 0(SP)		
  0x44422a		4c89442408		MOVQ R8, 0x8(SP)	
  0x44422f		48897c2410		MOVQ DI, 0x10(SP)	
  0x444234		44895c2418		MOVL R11, 0x18(SP)	
  0x444239		44897c241c		MOVL R15, 0x1c(SP)	
  0x44423e		4c894c2420		MOVQ R9, 0x20(SP)	
  0x444243		488b8c2480000000	MOVQ 0x80(SP), CX	
  0x44424b		488d942480000000	LEAQ 0x80(SP), DX	
  0x444253		ffd1			CALL CX			
  0x444255		807c242800		CMPB $0x0, 0x28(SP)	
  0x44425a		753e			JNE 0x44429a		
		for ; ; symIndex++ {
  0x44425c		8b442438		MOVL 0x38(SP), AX	
			hash := info.chain[symIndex-info.symOff]
  0x444260		488b8c24a8000000	MOVQ 0xa8(SP), CX	
	for _, k := range vdsoSymbolKeys {
  0x444268		488b5c2458		MOVQ 0x58(SP), BX	
  0x44426d		488b742470		MOVQ 0x70(SP), SI	
				if apply(symIndex, k) {
  0x444272		488b7c2450		MOVQ 0x50(SP), DI	
  0x444277		4c8b442478		MOVQ 0x78(SP), R8	
  0x44427c		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x444281		448b5c2440		MOVL 0x40(SP), R11	
			if hash&1 != 0 {
  0x444286		448b6c243c		MOVL 0x3c(SP), R13	
	for _, k := range vdsoSymbolKeys {
  0x44428b		4c8b742448		MOVQ 0x48(SP), R14	
			if hash|1 == k.gnuHash|1 {
  0x444290		448b7c2444		MOVL 0x44(SP), R15	
			if hash&1 != 0 {
  0x444295		e97bffffff		JMP 0x444215		
		symIndex := info.bucket[k.gnuHash%uint32(len(info.bucket))]
  0x44429a		488b8c24a8000000	MOVQ 0xa8(SP), CX	
	for _, k := range vdsoSymbolKeys {
  0x4442a2		488b5c2458		MOVQ 0x58(SP), BX	
  0x4442a7		488b742470		MOVQ 0x70(SP), SI	
  0x4442ac		4c8b742448		MOVQ 0x48(SP), R14	
					break
  0x4442b1		e9eafeffff		JMP 0x4441a0		
		for _, k := range vdsoSymbolKeys {
  0x4442b6		488b1d9bba0700		MOVQ runtime.vdsoSymbolKeys+8(SB), BX	
  0x4442bd		488b358cba0700		MOVQ runtime.vdsoSymbolKeys(SB), SI	
  0x4442c4		4885db			TESTQ BX, BX				
  0x4442c7		0f8e23010000		JLE 0x4443f0				
  0x4442cd		48895c2458		MOVQ BX, 0x58(SP)			
  0x4442d2		31c0			XORL AX, AX				
  0x4442d4		e9b4000000		JMP 0x44438d				
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4442d9		448b24b3		MOVL 0(BX)(SI*4), R12	
		for _, k := range vdsoSymbolKeys {
  0x4442dd		488b5c2458		MOVQ 0x58(SP), BX	
  0x4442e2		488b742460		MOVQ 0x60(SP), SI	
				if apply(chain, k) {
  0x4442e7		488b7c2450		MOVQ 0x50(SP), DI	
  0x4442ec		448b442444		MOVL 0x44(SP), R8	
  0x4442f1		4c8b4c2468		MOVQ 0x68(SP), R9	
  0x4442f6		448b542440		MOVL 0x40(SP), R10	
  0x4442fb		4c8b5c2478		MOVQ 0x78(SP), R11	
		for _, k := range vdsoSymbolKeys {
  0x444300		4c8b742448		MOVQ 0x48(SP), R14	
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x444305		4585e4			TESTL R12, R12		
  0x444308		745a			JE 0x444364		
  0x44430a		4489642434		MOVL R12, 0x34(SP)	
				if apply(chain, k) {
  0x44430f		44892424		MOVL R12, 0(SP)		
  0x444313		4c895c2408		MOVQ R11, 0x8(SP)	
  0x444318		48897c2410		MOVQ DI, 0x10(SP)	
  0x44431d		4489542418		MOVL R10, 0x18(SP)	
  0x444322		448944241c		MOVL R8, 0x1c(SP)	
  0x444327		4c894c2420		MOVQ R9, 0x20(SP)	
  0x44432c		488b842480000000	MOVQ 0x80(SP), AX	
  0x444334		488d942480000000	LEAQ 0x80(SP), DX	
  0x44433c		ffd0			CALL AX			
  0x44433e		807c242800		CMPB $0x0, 0x28(SP)	
  0x444343		751f			JNE 0x444364		
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x444345		488b8c24a8000000	MOVQ 0xa8(SP), CX	
  0x44434d		488b5928		MOVQ 0x28(CX), BX	
  0x444351		8b742434		MOVL 0x34(SP), SI	
  0x444355		48397130		CMPQ SI, 0x30(CX)	
  0x444359		0f877affffff		JA 0x4442d9		
  0x44435f		e9c1000000		JMP 0x444425		
		for _, k := range vdsoSymbolKeys {
  0x444364		488b4c2448		MOVQ 0x48(SP), CX	
  0x444369		48ffc1			INCQ CX			
  0x44436c		488b5c2458		MOVQ 0x58(SP), BX	
  0x444371		4839d9			CMPQ BX, CX		
  0x444374		7d7a			JGE 0x4443f0		
  0x444376		488b7c2460		MOVQ 0x60(SP), DI	
  0x44437b		488d7720		LEAQ 0x20(DI), SI	
  0x44437f		488bbc24a8000000	MOVQ 0xa8(SP), DI	
  0x444387		4889c8			MOVQ CX, AX		
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x44438a		4889f9			MOVQ DI, CX		
		for _, k := range vdsoSymbolKeys {
  0x44438d		488b7e08		MOVQ 0x8(SI), DI	
  0x444391		448b4614		MOVL 0x14(SI), R8	
  0x444395		4c8b4e18		MOVQ 0x18(SI), R9	
  0x444399		448b5610		MOVL 0x10(SI), R10	
  0x44439d		4c8b1e			MOVQ 0(SI), R11		
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4443a0		4c8b6148		MOVQ 0x48(CX), R12	
  0x4443a4		4c8b6940		MOVQ 0x40(CX), R13	
  0x4443a8		4585e4			TESTL R12, R12		
  0x4443ab		747f			JE 0x44442c		
		for _, k := range vdsoSymbolKeys {
  0x4443ad		4889c2			MOVQ AX, DX		
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4443b0		4489d0			MOVL R10, AX		
		for _, k := range vdsoSymbolKeys {
  0x4443b3		4989d6			MOVQ DX, R14		
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4443b6		31d2			XORL DX, DX		
  0x4443b8		41f7f4			DIVL R12		
  0x4443bb		4189d7			MOVL DX, R15		
  0x4443be		4d39e7			CMPQ R12, R15		
  0x4443c1		7362			JAE 0x444425		
		for _, k := range vdsoSymbolKeys {
  0x4443c3		4889742460		MOVQ SI, 0x60(SP)	
  0x4443c8		48897c2450		MOVQ DI, 0x50(SP)	
  0x4443cd		4c89742448		MOVQ R14, 0x48(SP)	
  0x4443d2		4489442444		MOVL R8, 0x44(SP)	
  0x4443d7		4c894c2468		MOVQ R9, 0x68(SP)	
  0x4443dc		4489542440		MOVL R10, 0x40(SP)	
  0x4443e1		4c895c2478		MOVQ R11, 0x78(SP)	
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x4443e6		478b64bd00		MOVL 0(R13)(R15*4), R12	
  0x4443eb		e915ffffff		JMP 0x444305		
		return
  0x4443f0		488bac2498000000	MOVQ 0x98(SP), BP	
  0x4443f8		4881c4a0000000		ADDQ $0xa0, SP		
  0x4443ff		c3			RET			
		return
  0x444400		488bac2498000000	MOVQ 0x98(SP), BP	
  0x444408		4881c4a0000000		ADDQ $0xa0, SP		
  0x44440f		c3			RET			
			hash := info.chain[symIndex-info.symOff]
  0x444410		e80bdbfdff		CALL runtime.panicindex(SB)	
  0x444415		0f0b			UD2				
		symIndex := info.bucket[k.gnuHash%uint32(len(info.bucket))]
  0x444417		e804dbfdff		CALL runtime.panicindex(SB)	
  0x44441c		0f0b			UD2				
  0x44441e		e85dddfdff		CALL runtime.panicdivide(SB)	
  0x444423		0f0b			UD2				
			for chain := info.bucket[k.symHash%uint32(len(info.bucket))]; chain != 0; chain = info.chain[chain] {
  0x444425		e8f6dafdff		CALL runtime.panicindex(SB)	
  0x44442a		0f0b			UD2				
  0x44442c		e84fddfdff		CALL runtime.panicdivide(SB)	
  0x444431		0f0b			UD2				
func vdsoParseSymbols(info *vdsoInfo, version int32) {
  0x444433		e848340000		CALL runtime.morestack_noctxt(SB)	
  0x444438		e973fcffff		JMP runtime.vdsoParseSymbols(SB)	

TEXT runtime.vdsoauxv(SB) /usr/local/go/src/runtime/vdso_linux.go
func vdsoauxv(tag, val uintptr) {
  0x444440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444449		488d4424f0		LEAQ -0x10(SP), AX	
  0x44444e		483b4110		CMPQ 0x10(CX), AX	
  0x444452		0f86b5000000		JBE 0x44450d		
  0x444458		4881ec90000000		SUBQ $0x90, SP		
  0x44445f		4889ac2488000000	MOVQ BP, 0x88(SP)	
  0x444467		488dac2488000000	LEAQ 0x88(SP), BP	
	case _AT_SYSINFO_EHDR:
  0x44446f		488b842498000000	MOVQ 0x98(SP), AX	
  0x444477		4883f821		CMPQ $0x21, AX		
  0x44447b		7570			JNE 0x4444ed		
		if val == 0 {
  0x44447d		488b8424a0000000	MOVQ 0xa0(SP), AX	
  0x444485		4885c0			TESTQ AX, AX		
  0x444488		7473			JE 0x4444fd		
		var info vdsoInfo
  0x44448a		488d7c2418		LEAQ 0x18(SP), DI	
  0x44448f		0f57c0			XORPS X0, X0		
  0x444492		488d7ff0		LEAQ -0x10(DI), DI	
  0x444496		48896c24f0		MOVQ BP, -0x10(SP)	
  0x44449b		488d6c24f0		LEAQ -0x10(SP), BP	
  0x4444a0		e8585c0000		CALL 0x44a0fd		
  0x4444a5		488b6d00		MOVQ 0(BP), BP		
		info1 := (*vdsoInfo)(noescape(unsafe.Pointer(&info)))
  0x4444a9		90			NOPL			
		vdsoInitFromSysinfoEhdr(info1, (*elfEhdr)(unsafe.Pointer(val)))
  0x4444aa		488d4c2418		LEAQ 0x18(SP), CX				
  0x4444af		48890c24		MOVQ CX, 0(SP)					
  0x4444b3		4889442408		MOVQ AX, 0x8(SP)				
  0x4444b8		e863f6ffff		CALL runtime.vdsoInitFromSysinfoEhdr(SB)	
		vdsoParseSymbols(info1, vdsoFindVersion(info1, &vdsoLinuxVersion))
  0x4444bd		488d442418		LEAQ 0x18(SP), AX			
  0x4444c2		48890424		MOVQ AX, 0(SP)				
  0x4444c6		488d0d63b80700		LEAQ runtime.vdsoLinuxVersion(SB), CX	
  0x4444cd		48894c2408		MOVQ CX, 0x8(SP)			
  0x4444d2		e8a9faffff		CALL runtime.vdsoFindVersion(SB)	
  0x4444d7		8b442410		MOVL 0x10(SP), AX			
  0x4444db		488d4c2418		LEAQ 0x18(SP), CX			
  0x4444e0		48890c24		MOVQ CX, 0(SP)				
  0x4444e4		89442408		MOVL AX, 0x8(SP)			
  0x4444e8		e8c3fbffff		CALL runtime.vdsoParseSymbols(SB)	
  0x4444ed		488bac2488000000	MOVQ 0x88(SP), BP			
  0x4444f5		4881c490000000		ADDQ $0x90, SP				
  0x4444fc		c3			RET					
			return
  0x4444fd		488bac2488000000	MOVQ 0x88(SP), BP	
  0x444505		4881c490000000		ADDQ $0x90, SP		
  0x44450c		c3			RET			
func vdsoauxv(tag, val uintptr) {
  0x44450d		e86e330000		CALL runtime.morestack_noctxt(SB)	
  0x444512		e929ffffff		JMP runtime.vdsoauxv(SB)		

TEXT runtime.inVDSOPage(SB) /usr/local/go/src/runtime/vdso_linux.go
	for _, k := range vdsoSymbolKeys {
  0x444520		488b0529b80700		MOVQ runtime.vdsoSymbolKeys(SB), AX	
  0x444527		488b0d2ab80700		MOVQ runtime.vdsoSymbolKeys+8(SB), CX	
  0x44452e		4885c9			TESTQ CX, CX				
  0x444531		7e1c			JLE 0x44454f				
  0x444533		31d2			XORL DX, DX				
  0x444535		eb04			JMP 0x44453b				
  0x444537		4883c020		ADDQ $0x20, AX				
  0x44453b		488b5818		MOVQ 0x18(AX), BX			
		if *k.ptr != 0 {
  0x44453f		488b1b			MOVQ 0(BX), BX		
  0x444542		4885db			TESTQ BX, BX		
  0x444545		750e			JNE 0x444555		
	for _, k := range vdsoSymbolKeys {
  0x444547		48ffc2			INCQ DX			
  0x44454a		4839ca			CMPQ CX, DX		
  0x44454d		7ce8			JL 0x444537		
	return false
  0x44454f		c644241000		MOVB $0x0, 0x10(SP)	
  0x444554		c3			RET			
			page := *k.ptr &^ (physPageSize - 1)
  0x444555		488b054c880900		MOVQ runtime.physPageSize(SB), AX	
  0x44455c		488d48ff		LEAQ -0x1(AX), CX			
  0x444560		48f7d1			NOTQ CX					
  0x444563		4821cb			ANDQ CX, BX				
			return pc >= page && pc < page+physPageSize
  0x444566		488b4c2408		MOVQ 0x8(SP), CX	
  0x44456b		4839d9			CMPQ BX, CX		
  0x44456e		720e			JB 0x44457e		
  0x444570		4801d8			ADDQ BX, AX		
  0x444573		4839c1			CMPQ AX, CX		
  0x444576		0f92c0			SETB AL			
  0x444579		88442410		MOVB AL, 0x10(SP)	
  0x44457d		c3			RET			
  0x44457e		31c0			XORL AX, AX		
  0x444580		ebf7			JMP 0x444579		

TEXT runtime.mmap.func1(SB) /usr/local/go/src/runtime/cgo_mmap.go
		systemstack(func() {
  0x444590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444599		483b6110		CMPQ 0x10(CX), SP	
  0x44459d		7660			JBE 0x4445ff		
  0x44459f		4883ec38		SUBQ $0x38, SP		
  0x4445a3		48896c2430		MOVQ BP, 0x30(SP)	
  0x4445a8		488d6c2430		LEAQ 0x30(SP), BP	
  0x4445ad		488b4210		MOVQ 0x10(DX), AX	
  0x4445b1		8b4a18			MOVL 0x18(DX), CX	
  0x4445b4		8b5a1c			MOVL 0x1c(DX), BX	
  0x4445b7		8b7220			MOVL 0x20(DX), SI	
  0x4445ba		8b7a24			MOVL 0x24(DX), DI	
  0x4445bd		4c8b4228		MOVQ 0x28(DX), R8	
  0x4445c1		4c89442428		MOVQ R8, 0x28(SP)	
  0x4445c6		488b5208		MOVQ 0x8(DX), DX	
			ret = callCgoMmap(addr, n, prot, flags, fd, off)
  0x4445ca		48891424		MOVQ DX, 0(SP)			
  0x4445ce		4889442408		MOVQ AX, 0x8(SP)		
  0x4445d3		894c2410		MOVL CX, 0x10(SP)		
  0x4445d7		895c2414		MOVL BX, 0x14(SP)		
  0x4445db		89742418		MOVL SI, 0x18(SP)		
  0x4445df		897c241c		MOVL DI, 0x1c(SP)		
  0x4445e3		e8d86d0000		CALL runtime.callCgoMmap(SB)	
  0x4445e8		488b442420		MOVQ 0x20(SP), AX		
  0x4445ed		488b4c2428		MOVQ 0x28(SP), CX		
  0x4445f2		488901			MOVQ AX, 0(CX)			
		})
  0x4445f5		488b6c2430		MOVQ 0x30(SP), BP	
  0x4445fa		4883c438		ADDQ $0x38, SP		
  0x4445fe		c3			RET			
		systemstack(func() {
  0x4445ff		e8dc310000		CALL runtime.morestack(SB)	
  0x444604		eb8a			JMP runtime.mmap.func1(SB)	

TEXT runtime.munmap.func1(SB) /usr/local/go/src/runtime/cgo_mmap.go
		systemstack(func() { callCgoMunmap(addr, n) })
  0x444610		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x444619		483b6110		CMPQ 0x10(CX), SP		
  0x44461d		762e			JBE 0x44464d			
  0x44461f		4883ec18		SUBQ $0x18, SP			
  0x444623		48896c2410		MOVQ BP, 0x10(SP)		
  0x444628		488d6c2410		LEAQ 0x10(SP), BP		
  0x44462d		488b4210		MOVQ 0x10(DX), AX		
  0x444631		488b4a08		MOVQ 0x8(DX), CX		
  0x444635		48890c24		MOVQ CX, 0(SP)			
  0x444639		4889442408		MOVQ AX, 0x8(SP)		
  0x44463e		e80d6e0000		CALL runtime.callCgoMunmap(SB)	
  0x444643		488b6c2410		MOVQ 0x10(SP), BP		
  0x444648		4883c418		ADDQ $0x18, SP			
  0x44464c		c3			RET				
  0x44464d		e88e310000		CALL runtime.morestack(SB)	
  0x444652		ebbc			JMP runtime.munmap.func1(SB)	

TEXT runtime.sigaction.func1(SB) /usr/local/go/src/runtime/cgo_sigaction.go
			systemstack(func() {
  0x444660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444669		483b6110		CMPQ 0x10(CX), SP	
  0x44466d		764d			JBE 0x4446bc		
  0x44466f		4883ec30		SUBQ $0x30, SP		
  0x444673		48896c2428		MOVQ BP, 0x28(SP)	
  0x444678		488d6c2428		LEAQ 0x28(SP), BP	
  0x44467d		488b4210		MOVQ 0x10(DX), AX	
  0x444681		488b4a18		MOVQ 0x18(DX), CX	
  0x444685		488b5a20		MOVQ 0x20(DX), BX	
  0x444689		48895c2420		MOVQ BX, 0x20(SP)	
  0x44468e		488b5208		MOVQ 0x8(DX), DX	
				ret = callCgoSigaction(uintptr(sig), new, old)
  0x444692		8b12			MOVL 0(DX), DX				
  0x444694		48891424		MOVQ DX, 0(SP)				
  0x444698		4889442408		MOVQ AX, 0x8(SP)			
  0x44469d		48894c2410		MOVQ CX, 0x10(SP)			
  0x4446a2		e8196b0000		CALL runtime.callCgoSigaction(SB)	
  0x4446a7		8b442418		MOVL 0x18(SP), AX			
  0x4446ab		488b4c2420		MOVQ 0x20(SP), CX			
  0x4446b0		8901			MOVL AX, 0(CX)				
			})
  0x4446b2		488b6c2428		MOVQ 0x28(SP), BP	
  0x4446b7		4883c430		ADDQ $0x30, SP		
  0x4446bb		c3			RET			
			systemstack(func() {
  0x4446bc		e81f310000		CALL runtime.morestack(SB)	
  0x4446c1		eb9d			JMP runtime.sigaction.func1(SB)	

TEXT runtime.cgoCheckWriteBarrier.func1(SB) /usr/local/go/src/runtime/cgocheck.go
	systemstack(func() {
  0x4446d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4446d9		483b6110		CMPQ 0x10(CX), SP	
  0x4446dd		0f8698000000		JBE 0x44477b		
  0x4446e3		4883ec28		SUBQ $0x28, SP		
  0x4446e7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4446ec		488d6c2420		LEAQ 0x20(SP), BP	
  0x4446f1		488b4210		MOVQ 0x10(DX), AX	
  0x4446f5		488b4a08		MOVQ 0x8(DX), CX	
  0x4446f9		48894c2410		MOVQ CX, 0x10(SP)	
		println("write of Go pointer", hex(src), "to non-Go memory", hex(uintptr(unsafe.Pointer(dst))))
  0x4446fe		4889442418		MOVQ AX, 0x18(SP)		
  0x444703		e8b8f7fdff		CALL runtime.printlock(SB)	
  0x444708		488d05a2c00200		LEAQ 0x2c0a2(IP), AX		
  0x44470f		48890424		MOVQ AX, 0(SP)			
  0x444713		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x44471c		e8cf00feff		CALL runtime.printstring(SB)	
  0x444721		488b442410		MOVQ 0x10(SP), AX		
  0x444726		48890424		MOVQ AX, 0(SP)			
  0x44472a		e881fffdff		CALL runtime.printhex(SB)	
  0x44472f		488d056cbb0200		LEAQ 0x2bb6c(IP), AX		
  0x444736		48890424		MOVQ AX, 0(SP)			
  0x44473a		48c744240812000000	MOVQ $0x12, 0x8(SP)		
  0x444743		e8a800feff		CALL runtime.printstring(SB)	
  0x444748		488b442418		MOVQ 0x18(SP), AX		
  0x44474d		48890424		MOVQ AX, 0(SP)			
  0x444751		e85afffdff		CALL runtime.printhex(SB)	
  0x444756		e8f5f9fdff		CALL runtime.printnl(SB)	
  0x44475b		e8e0f7fdff		CALL runtime.printunlock(SB)	
		throw(cgoWriteBarrierFail)
  0x444760		488d05a4dd0200		LEAQ 0x2dda4(IP), AX	
  0x444767		48890424		MOVQ AX, 0(SP)		
  0x44476b		48c744240824000000	MOVQ $0x24, 0x8(SP)	
  0x444774		e807edfdff		CALL runtime.throw(SB)	
  0x444779		0f0b			UD2			
	systemstack(func() {
  0x44477b		e860300000		CALL runtime.morestack(SB)			
  0x444780		e94bffffff		JMP runtime.cgoCheckWriteBarrier.func1(SB)	

TEXT runtime.cgoCheckTypedBlock.func1(SB) /usr/local/go/src/runtime/cgocheck.go
		systemstack(func() {
  0x444790		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444799		483b6110		CMPQ 0x10(CX), SP	
  0x44479d		7640			JBE 0x4447df		
  0x44479f		4883ec28		SUBQ $0x28, SP		
  0x4447a3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4447a8		488d6c2420		LEAQ 0x20(SP), BP	
  0x4447ad		488b4210		MOVQ 0x10(DX), AX	
  0x4447b1		488b4a18		MOVQ 0x18(DX), CX	
  0x4447b5		488b5a20		MOVQ 0x20(DX), BX	
  0x4447b9		488b5208		MOVQ 0x8(DX), DX	
			cgoCheckUsingType(typ, src, off, size)
  0x4447bd		48891424		MOVQ DX, 0(SP)				
  0x4447c1		4889442408		MOVQ AX, 0x8(SP)			
  0x4447c6		48894c2410		MOVQ CX, 0x10(SP)			
  0x4447cb		48895c2418		MOVQ BX, 0x18(SP)			
  0x4447d0		e8fbf8fbff		CALL runtime.cgoCheckUsingType(SB)	
		})
  0x4447d5		488b6c2420		MOVQ 0x20(SP), BP	
  0x4447da		4883c428		ADDQ $0x28, SP		
  0x4447de		c3			RET			
		systemstack(func() {
  0x4447df		e8fc2f0000		CALL runtime.morestack(SB)			
  0x4447e4		ebaa			JMP runtime.cgoCheckTypedBlock.func1(SB)	

TEXT runtime.chansend.func1(SB) /usr/local/go/src/runtime/chan.go
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x4447f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x4447f9		483b6110		CMPQ 0x10(CX), SP		
  0x4447fd		762b			JBE 0x44482a			
  0x4447ff		4883ec10		SUBQ $0x10, SP			
  0x444803		48896c2408		MOVQ BP, 0x8(SP)		
  0x444808		488d6c2408		LEAQ 0x8(SP), BP		
  0x44480d		488b4208		MOVQ 0x8(DX), AX		
  0x444811		8400			TESTB AL, 0(AX)			
  0x444813		4883c058		ADDQ $0x58, AX			
  0x444817		48890424		MOVQ AX, 0(SP)			
  0x44481b		e87040fcff		CALL runtime.unlock(SB)		
  0x444820		488b6c2408		MOVQ 0x8(SP), BP		
  0x444825		4883c410		ADDQ $0x10, SP			
  0x444829		c3			RET				
  0x44482a		e8b12f0000		CALL runtime.morestack(SB)	
  0x44482f		ebbf			JMP runtime.chansend.func1(SB)	

TEXT runtime.chanrecv.func1(SB) /usr/local/go/src/runtime/chan.go
		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
  0x444840		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x444849		483b6110		CMPQ 0x10(CX), SP		
  0x44484d		762b			JBE 0x44487a			
  0x44484f		4883ec10		SUBQ $0x10, SP			
  0x444853		48896c2408		MOVQ BP, 0x8(SP)		
  0x444858		488d6c2408		LEAQ 0x8(SP), BP		
  0x44485d		488b4208		MOVQ 0x8(DX), AX		
  0x444861		8400			TESTB AL, 0(AX)			
  0x444863		4883c058		ADDQ $0x58, AX			
  0x444867		48890424		MOVQ AX, 0(SP)			
  0x44486b		e82040fcff		CALL runtime.unlock(SB)		
  0x444870		488b6c2408		MOVQ 0x8(SP), BP		
  0x444875		4883c410		ADDQ $0x10, SP			
  0x444879		c3			RET				
  0x44487a		e8612f0000		CALL runtime.morestack(SB)	
  0x44487f		ebbf			JMP runtime.chanrecv.func1(SB)	

TEXT runtime.debugCallCheck.func1(SB) /usr/local/go/src/runtime/debugcall.go
	systemstack(func() {
  0x444890		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444899		483b6110		CMPQ 0x10(CX), SP	
  0x44489d		0f86dc010000		JBE 0x444a7f		
  0x4448a3		4883ec60		SUBQ $0x60, SP		
  0x4448a7		48896c2458		MOVQ BP, 0x58(SP)	
  0x4448ac		488d6c2458		LEAQ 0x58(SP), BP	
  0x4448b1		488b4210		MOVQ 0x10(DX), AX	
  0x4448b5		4889442448		MOVQ AX, 0x48(SP)	
  0x4448ba		488b4a08		MOVQ 0x8(DX), CX	
  0x4448be		48894c2450		MOVQ CX, 0x50(SP)	
		f := findfunc(pc)
  0x4448c3		488b11			MOVQ 0(CX), DX			
  0x4448c6		48891424		MOVQ DX, 0(SP)			
  0x4448ca		e83162ffff		CALL runtime.findfunc(SB)	
  0x4448cf		488b442408		MOVQ 0x8(SP), AX		
  0x4448d4		488b4c2410		MOVQ 0x10(SP), CX		
		if !f.valid() {
  0x4448d9		90			NOPL			
	return f._func != nil
  0x4448da		4885c0			TESTQ AX, AX		
		if !f.valid() {
  0x4448dd		7538			JNE 0x444917		
			ret = debugCallUnknownFunc
  0x4448df		488b7c2448		MOVQ 0x48(SP), DI			
  0x4448e4		48c747081a000000	MOVQ $0x1a, 0x8(DI)			
  0x4448ec		833d2d85090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4448f3		7514			JNE 0x444909				
  0x4448f5		488d05c8c80200		LEAQ 0x2c8c8(IP), AX			
  0x4448fc		488907			MOVQ AX, 0(DI)				
			return
  0x4448ff		488b6c2458		MOVQ 0x58(SP), BP	
  0x444904		4883c460		ADDQ $0x60, SP		
  0x444908		c3			RET			
			ret = debugCallUnknownFunc
  0x444909		488d05b4c80200		LEAQ 0x2c8b4(IP), AX		
  0x444910		e86b4d0000		CALL runtime.gcWriteBarrier(SB)	
  0x444915		ebe8			JMP 0x4448ff			
		f := findfunc(pc)
  0x444917		4889442440		MOVQ AX, 0x40(SP)	
  0x44491c		48894c2438		MOVQ CX, 0x38(SP)	
		if name, pfx := funcname(f), "runtime."; len(name) > len(pfx) && name[:len(pfx)] == pfx {
  0x444921		48890424		MOVQ AX, 0(SP)			
  0x444925		48894c2408		MOVQ CX, 0x8(SP)		
  0x44492a		e81169ffff		CALL runtime.funcname(SB)	
  0x44492f		488b442410		MOVQ 0x10(SP), AX		
  0x444934		48837c241808		CMPQ $0x8, 0x18(SP)		
  0x44493a		0f8f17010000		JG 0x444a57			
  0x444940		31c0			XORL AX, AX			
  0x444942		84c0			TESTL AL, AL			
  0x444944		7438			JE 0x44497e			
			ret = debugCallRuntime
  0x444946		488b7c2448		MOVQ 0x48(SP), DI			
  0x44494b		48c747081f000000	MOVQ $0x1f, 0x8(DI)			
  0x444953		833dc684090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44495a		7514			JNE 0x444970				
  0x44495c		488d05b9d30200		LEAQ 0x2d3b9(IP), AX			
  0x444963		488907			MOVQ AX, 0(DI)				
			return
  0x444966		488b6c2458		MOVQ 0x58(SP), BP	
  0x44496b		4883c460		ADDQ $0x60, SP		
  0x44496f		c3			RET			
			ret = debugCallRuntime
  0x444970		488d05a5d30200		LEAQ 0x2d3a5(IP), AX		
  0x444977		e8044d0000		CALL runtime.gcWriteBarrier(SB)	
  0x44497c		ebe8			JMP 0x444966			
		if pc != f.entry {
  0x44497e		488b442450		MOVQ 0x50(SP), AX	
  0x444983		488b08			MOVQ 0(AX), CX		
  0x444986		488b542440		MOVQ 0x40(SP), DX	
  0x44498b		48390a			CMPQ CX, 0(DX)		
  0x44498e		0f8586000000		JNE 0x444a1a		
  0x444994		b8ffffffff		MOVL $-0x1, AX		
		if pcdata == -1 {
  0x444999		89442434		MOVL AX, 0x34(SP)	
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_RegPointerMaps))
  0x44499d		48891424		MOVQ DX, 0(SP)			
  0x4449a1		488b4c2438		MOVQ 0x38(SP), CX		
  0x4449a6		48894c2408		MOVQ CX, 0x8(SP)		
  0x4449ab		c644241003		MOVB $0x3, 0x10(SP)		
  0x4449b0		e85b6effff		CALL runtime.funcdata(SB)	
		if pcdata == -1 {
  0x4449b5		8b442434		MOVL 0x34(SP), AX	
  0x4449b9		83f8ff			CMPL $-0x1, AX		
		if pcdata == -2 || stkmap == nil {
  0x4449bc		b900000000		MOVL $0x0, CX		
  0x4449c1		0f44c1			CMOVE CX, AX		
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_RegPointerMaps))
  0x4449c4		488b4c2418		MOVQ 0x18(SP), CX	
  0x4449c9		4883f900		CMPQ $0x0, CX		
		if pcdata == -2 || stkmap == nil {
  0x4449cd		83f8fe			CMPL $-0x2, AX		
		if pcdata == -1 {
  0x4449d0		7538			JNE 0x444a0a		
			ret = debugCallUnsafePoint
  0x4449d2		488b7c2448		MOVQ 0x48(SP), DI			
  0x4449d7		48c7470816000000	MOVQ $0x16, 0x8(DI)			
  0x4449df		833d3a84090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4449e6		7514			JNE 0x4449fc				
  0x4449e8		488d05aabf0200		LEAQ 0x2bfaa(IP), AX			
  0x4449ef		488907			MOVQ AX, 0(DI)				
			return
  0x4449f2		488b6c2458		MOVQ 0x58(SP), BP	
  0x4449f7		4883c460		ADDQ $0x60, SP		
  0x4449fb		c3			RET			
			ret = debugCallUnsafePoint
  0x4449fc		488d0596bf0200		LEAQ 0x2bf96(IP), AX		
  0x444a03		e8784c0000		CALL runtime.gcWriteBarrier(SB)	
  0x444a08		ebe8			JMP 0x4449f2			
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_RegPointerMaps))
  0x444a0a		4883f900		CMPQ $0x0, CX		
		if pcdata == -2 || stkmap == nil {
  0x444a0e		74c2			JE 0x4449d2		
  0x444a10		488b6c2458		MOVQ 0x58(SP), BP	
  0x444a15		4883c460		ADDQ $0x60, SP		
  0x444a19		c3			RET			
			pc--
  0x444a1a		48ffc9			DECQ CX			
  0x444a1d		488908			MOVQ CX, 0(AX)		
			pcdata = pcdatavalue(f, _PCDATA_RegMapIndex, pc, nil)
  0x444a20		48891424		MOVQ DX, 0(SP)			
  0x444a24		488b442438		MOVQ 0x38(SP), AX		
  0x444a29		4889442408		MOVQ AX, 0x8(SP)		
  0x444a2e		c744241002000000	MOVL $0x2, 0x10(SP)		
  0x444a36		48894c2418		MOVQ CX, 0x18(SP)		
  0x444a3b		48c744242000000000	MOVQ $0x0, 0x20(SP)		
  0x444a44		e8176dffff		CALL runtime.pcdatavalue(SB)	
  0x444a49		8b442428		MOVL 0x28(SP), AX		
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_RegPointerMaps))
  0x444a4d		488b542440		MOVQ 0x40(SP), DX	
			pcdata = pcdatavalue(f, _PCDATA_RegMapIndex, pc, nil)
  0x444a52		e942ffffff		JMP 0x444999		
		if name, pfx := funcname(f), "runtime."; len(name) > len(pfx) && name[:len(pfx)] == pfx {
  0x444a57		48890424		MOVQ AX, 0(SP)			
  0x444a5b		488d0516aa0200		LEAQ 0x2aa16(IP), AX		
  0x444a62		4889442408		MOVQ AX, 0x8(SP)		
  0x444a67		48c744241008000000	MOVQ $0x8, 0x10(SP)		
  0x444a70		e8abd7fbff		CALL runtime.memequal(SB)	
  0x444a75		0fb6442418		MOVZX 0x18(SP), AX		
  0x444a7a		e9c3feffff		JMP 0x444942			
	systemstack(func() {
  0x444a7f		e85c2d0000		CALL runtime.morestack(SB)		
  0x444a84		e907feffff		JMP runtime.debugCallCheck.func1(SB)	

TEXT runtime.debugCallWrap.func1(SB) /usr/local/go/src/runtime/debugcall.go
	defer func() {
  0x444a90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444a99		483b6110		CMPQ 0x10(CX), SP	
  0x444a9d		764a			JBE 0x444ae9		
  0x444a9f		4883ec20		SUBQ $0x20, SP		
  0x444aa3		48896c2418		MOVQ BP, 0x18(SP)	
  0x444aa8		488d6c2418		LEAQ 0x18(SP), BP	
		if !ok {
  0x444aad		488b442428		MOVQ 0x28(SP), AX	
  0x444ab2		803800			CMPB $0x0, 0(AX)	
  0x444ab5		740a			JE 0x444ac1		
  0x444ab7		488b6c2418		MOVQ 0x18(SP), BP	
  0x444abc		4883c420		ADDQ $0x20, SP		
  0x444ac0		c3			RET			
			err := recover()
  0x444ac1		488d442428		LEAQ 0x28(SP), AX		
  0x444ac6		48890424		MOVQ AX, 0(SP)			
  0x444aca		e861e9fdff		CALL runtime.gorecover(SB)	
  0x444acf		488b442410		MOVQ 0x10(SP), AX		
  0x444ad4		488b4c2408		MOVQ 0x8(SP), CX		
			debugCallPanicked(err)
  0x444ad9		48890c24		MOVQ CX, 0(SP)				
  0x444add		4889442408		MOVQ AX, 0x8(SP)			
  0x444ae2		e8c9540000		CALL runtime.debugCallPanicked(SB)	
  0x444ae7		ebce			JMP 0x444ab7				
	defer func() {
  0x444ae9		e8922d0000		CALL runtime.morestack_noctxt(SB)	
  0x444aee		eba0			JMP runtime.debugCallWrap.func1(SB)	

TEXT runtime.mallocgc.func1(SB) /usr/local/go/src/runtime/malloc.go
		systemstack(func() {
  0x444af0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444af9		483b6110		CMPQ 0x10(CX), SP	
  0x444afd		764e			JBE 0x444b4d		
  0x444aff		4883ec28		SUBQ $0x28, SP		
  0x444b03		48896c2420		MOVQ BP, 0x20(SP)	
  0x444b08		488d6c2420		LEAQ 0x20(SP), BP	
  0x444b0d		0fb64210		MOVZX 0x10(DX), AX	
  0x444b11		0fb64a11		MOVZX 0x11(DX), CX	
  0x444b15		488b5a18		MOVQ 0x18(DX), BX	
  0x444b19		48895c2418		MOVQ BX, 0x18(SP)	
  0x444b1e		488b5208		MOVQ 0x8(DX), DX	
			s = largeAlloc(size, needzero, noscan)
  0x444b22		488b12			MOVQ 0(DX), DX			
  0x444b25		48891424		MOVQ DX, 0(SP)			
  0x444b29		88442408		MOVB AL, 0x8(SP)		
  0x444b2d		884c2409		MOVB CL, 0x9(SP)		
  0x444b31		e87a5afcff		CALL runtime.largeAlloc(SB)	
  0x444b36		488b442410		MOVQ 0x10(SP), AX		
  0x444b3b		488b4c2418		MOVQ 0x18(SP), CX		
  0x444b40		488901			MOVQ AX, 0(CX)			
		})
  0x444b43		488b6c2420		MOVQ 0x20(SP), BP	
  0x444b48		4883c428		ADDQ $0x28, SP		
  0x444b4c		c3			RET			
		systemstack(func() {
  0x444b4d		e88e2c0000		CALL runtime.morestack(SB)	
  0x444b52		eb9c			JMP runtime.mallocgc.func1(SB)	

TEXT runtime.persistentalloc.func1(SB) /usr/local/go/src/runtime/malloc.go
	systemstack(func() {
  0x444b60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444b69		483b6110		CMPQ 0x10(CX), SP	
  0x444b6d		764d			JBE 0x444bbc		
  0x444b6f		4883ec30		SUBQ $0x30, SP		
  0x444b73		48896c2428		MOVQ BP, 0x28(SP)	
  0x444b78		488d6c2428		LEAQ 0x28(SP), BP	
  0x444b7d		488b4210		MOVQ 0x10(DX), AX	
  0x444b81		488b4a18		MOVQ 0x18(DX), CX	
  0x444b85		488b5a20		MOVQ 0x20(DX), BX	
  0x444b89		48895c2420		MOVQ BX, 0x20(SP)	
  0x444b8e		488b5208		MOVQ 0x8(DX), DX	
		p = persistentalloc1(size, align, sysStat)
  0x444b92		48891424		MOVQ DX, 0(SP)				
  0x444b96		4889442408		MOVQ AX, 0x8(SP)			
  0x444b9b		48894c2410		MOVQ CX, 0x10(SP)			
  0x444ba0		e86b5ffcff		CALL runtime.persistentalloc1(SB)	
  0x444ba5		488b442418		MOVQ 0x18(SP), AX			
  0x444baa		488b4c2420		MOVQ 0x20(SP), CX			
  0x444baf		488901			MOVQ AX, 0(CX)				
	})
  0x444bb2		488b6c2428		MOVQ 0x28(SP), BP	
  0x444bb7		4883c430		ADDQ $0x30, SP		
  0x444bbb		c3			RET			
	systemstack(func() {
  0x444bbc		e81f2c0000		CALL runtime.morestack(SB)		
  0x444bc1		eb9d			JMP runtime.persistentalloc.func1(SB)	

TEXT runtime.freemcache.func1(SB) /usr/local/go/src/runtime/mcache.go
	systemstack(func() {
  0x444bd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444bd9		483b6110		CMPQ 0x10(CX), SP	
  0x444bdd		0f8692000000		JBE 0x444c75		
  0x444be3		4883ec18		SUBQ $0x18, SP		
  0x444be7		48896c2410		MOVQ BP, 0x10(SP)	
  0x444bec		488d6c2410		LEAQ 0x10(SP), BP	
  0x444bf1		488b4208		MOVQ 0x8(DX), AX	
  0x444bf5		4889442408		MOVQ AX, 0x8(SP)	
		c.releaseAll()
  0x444bfa		48890424		MOVQ AX, 0(SP)				
  0x444bfe		e86dbdfcff		CALL runtime.(*mcache).releaseAll(SB)	
		stackcache_clear(c)
  0x444c03		488b442408		MOVQ 0x8(SP), AX			
  0x444c08		48890424		MOVQ AX, 0(SP)				
  0x444c0c		e8af1dffff		CALL runtime.stackcache_clear(SB)	
		lock(&mheap_.lock)
  0x444c11		488d05281a0800		LEAQ runtime.mheap_(SB), AX	
  0x444c18		48890424		MOVQ AX, 0(SP)			
  0x444c1c		e8bf3afcff		CALL runtime.lock(SB)		
		purgecachedstats(c)
  0x444c21		488b442408		MOVQ 0x8(SP), AX			
  0x444c26		48890424		MOVQ AX, 0(SP)				
  0x444c2a		e821bdfdff		CALL runtime.purgecachedstats(SB)	
		mheap_.cachealloc.free(unsafe.Pointer(c))
  0x444c2f		90			NOPL			
	f.inuse -= f.size
  0x444c30		488b05813f0800		MOVQ runtime.mheap_+9592(SB), AX	
  0x444c37		482b054a3f0800		SUBQ runtime.mheap_+9544(SB), AX	
  0x444c3e		488905733f0800		MOVQ AX, runtime.mheap_+9592(SB)	
	v.next = f.list
  0x444c45		488b05543f0800		MOVQ runtime.mheap_+9568(SB), AX	
  0x444c4c		488b4c2408		MOVQ 0x8(SP), CX			
  0x444c51		488901			MOVQ AX, 0(CX)				
	f.list = v
  0x444c54		48890d453f0800		MOVQ CX, runtime.mheap_+9568(SB)	
		unlock(&mheap_.lock)
  0x444c5b		488d05de190800		LEAQ runtime.mheap_(SB), AX	
  0x444c62		48890424		MOVQ AX, 0(SP)			
  0x444c66		e8253cfcff		CALL runtime.unlock(SB)		
	})
  0x444c6b		488b6c2410		MOVQ 0x10(SP), BP	
  0x444c70		4883c418		ADDQ $0x18, SP		
  0x444c74		c3			RET			
	systemstack(func() {
  0x444c75		e8662b0000		CALL runtime.morestack(SB)		
  0x444c7a		e951ffffff		JMP runtime.freemcache.func1(SB)	

TEXT runtime.gcStart.func1(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x444c80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444c89		483b6110		CMPQ 0x10(CX), SP	
  0x444c8d		761a			JBE 0x444ca9		
  0x444c8f		4883ec08		SUBQ $0x8, SP		
  0x444c93		48892c24		MOVQ BP, 0(SP)		
  0x444c97		488d2c24		LEAQ 0(SP), BP		
		finishsweep_m()
  0x444c9b		e8c053fdff		CALL runtime.finishsweep_m(SB)	
	})
  0x444ca0		488b2c24		MOVQ 0(SP), BP		
  0x444ca4		4883c408		ADDQ $0x8, SP		
  0x444ca8		c3			RET			
	systemstack(func() {
  0x444ca9		e8d22b0000		CALL runtime.morestack_noctxt(SB)	
  0x444cae		ebd0			JMP runtime.gcStart.func1(SB)		

TEXT runtime.gcStart.func2(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x444cb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444cb9		483b6110		CMPQ 0x10(CX), SP	
  0x444cbd		7658			JBE 0x444d17		
  0x444cbf		4883ec20		SUBQ $0x20, SP		
  0x444cc3		48896c2418		MOVQ BP, 0x18(SP)	
  0x444cc8		488d6c2418		LEAQ 0x18(SP), BP	
  0x444ccd		488b4208		MOVQ 0x8(DX), AX	
  0x444cd1		4889442410		MOVQ AX, 0x10(SP)	
		now = startTheWorldWithSema(trace.enabled)
  0x444cd6		0fb60df37e0800		MOVZX runtime.trace+16(SB), CX		
  0x444cdd		880c24			MOVB CL, 0(SP)				
  0x444ce0		e8eb29feff		CALL runtime.startTheWorldWithSema(SB)	
  0x444ce5		488b442408		MOVQ 0x8(SP), AX			
  0x444cea		488b4c2410		MOVQ 0x10(SP), CX			
  0x444cef		488901			MOVQ AX, 0(CX)				
		work.pauseNS += now - work.pauseStart
  0x444cf2		488b15efd30700		MOVQ runtime.work+360(SB), DX	
  0x444cf9		4829d0			SUBQ DX, AX			
  0x444cfc		480105ddd30700		ADDQ AX, runtime.work+352(SB)	
		work.tMark = now
  0x444d03		488b01			MOVQ 0(CX), AX			
  0x444d06		488905bbd30700		MOVQ AX, runtime.work+328(SB)	
	})
  0x444d0d		488b6c2418		MOVQ 0x18(SP), BP	
  0x444d12		4883c420		ADDQ $0x20, SP		
  0x444d16		c3			RET			
	systemstack(func() {
  0x444d17		e8c42a0000		CALL runtime.morestack(SB)	
  0x444d1c		eb92			JMP runtime.gcStart.func2(SB)	

TEXT runtime.gcMarkDone.func1.1(SB) /usr/local/go/src/runtime/mgc.go
		forEachP(func(_p_ *p) {
  0x444d20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444d29		483b6110		CMPQ 0x10(CX), SP	
  0x444d2d		7662			JBE 0x444d91		
  0x444d2f		4883ec10		SUBQ $0x10, SP		
  0x444d33		48896c2408		MOVQ BP, 0x8(SP)	
  0x444d38		488d6c2408		LEAQ 0x8(SP), BP	
			wbBufFlush1(_p_)
  0x444d3d		488b442418		MOVQ 0x18(SP), AX		
  0x444d42		48890424		MOVQ AX, 0(SP)			
  0x444d46		e8a5bffdff		CALL runtime.wbBufFlush1(SB)	
			_p_.gcw.dispose()
  0x444d4b		488b442418		MOVQ 0x18(SP), AX			
  0x444d50		8400			TESTB AL, 0(AX)				
  0x444d52		488d8870120000		LEAQ 0x1270(AX), CX			
  0x444d59		48890c24		MOVQ CX, 0(SP)				
  0x444d5d		e8ce6bfdff		CALL runtime.(*gcWork).dispose(SB)	
			if _p_.gcw.flushedWork {
  0x444d62		488b442418		MOVQ 0x18(SP), AX	
  0x444d67		80b89012000000		CMPB $0x0, 0x1290(AX)	
  0x444d6e		7417			JE 0x444d87		
				atomic.Xadd(&gcMarkDoneFlushed, 1)
  0x444d70		b901000000		MOVL $0x1, CX				
  0x444d75		488d15587f0900		LEAQ runtime.gcMarkDoneFlushed(SB), DX	
  0x444d7c		f00fc10a		LOCK XADDL CX, 0(DX)			
				_p_.gcw.flushedWork = false
  0x444d80		c6809012000000		MOVB $0x0, 0x1290(AX)	
  0x444d87		488b6c2408		MOVQ 0x8(SP), BP	
  0x444d8c		4883c410		ADDQ $0x10, SP		
  0x444d90		c3			RET			
		forEachP(func(_p_ *p) {
  0x444d91		e8ea2a0000		CALL runtime.morestack_noctxt(SB)	
  0x444d96		eb88			JMP runtime.gcMarkDone.func1.1(SB)	

TEXT runtime.gcMarkDone.func1(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x444da0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444da9		483b6110		CMPQ 0x10(CX), SP	
  0x444dad		7676			JBE 0x444e25		
  0x444daf		4883ec20		SUBQ $0x20, SP		
  0x444db3		48896c2418		MOVQ BP, 0x18(SP)	
  0x444db8		488d6c2418		LEAQ 0x18(SP), BP	
		gp := getg().m.curg
  0x444dbd		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x444dc6		488b4030		MOVQ 0x30(AX), AX	
  0x444dca		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x444dd1		4889442410		MOVQ AX, 0x10(SP)	
		casgstatus(gp, _Grunning, _Gwaiting)
  0x444dd6		48890424		MOVQ AX, 0(SP)			
  0x444dda		48b90200000004000000	MOVQ $0x400000002, CX		
  0x444de4		48894c2408		MOVQ CX, 0x8(SP)		
  0x444de9		e8b21efeff		CALL runtime.casgstatus(SB)	
		forEachP(func(_p_ *p) {
  0x444dee		488d0513ea0200		LEAQ 0x2ea13(IP), AX		
  0x444df5		48890424		MOVQ AX, 0(SP)			
  0x444df9		e8b22ffeff		CALL runtime.forEachP(SB)	
		casgstatus(gp, _Gwaiting, _Grunning)
  0x444dfe		488b442410		MOVQ 0x10(SP), AX		
  0x444e03		48890424		MOVQ AX, 0(SP)			
  0x444e07		48b80400000002000000	MOVQ $0x200000004, AX		
  0x444e11		4889442408		MOVQ AX, 0x8(SP)		
  0x444e16		e8851efeff		CALL runtime.casgstatus(SB)	
	})
  0x444e1b		488b6c2418		MOVQ 0x18(SP), BP	
  0x444e20		4883c420		ADDQ $0x20, SP		
  0x444e24		c3			RET			
	systemstack(func() {
  0x444e25		e8562a0000		CALL runtime.morestack_noctxt(SB)	
  0x444e2a		e971ffffff		JMP runtime.gcMarkDone.func1(SB)	

TEXT runtime.gcMarkDone.func2(SB) /usr/local/go/src/runtime/mgc.go
		systemstack(func() {
  0x444e30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444e39		483b6110		CMPQ 0x10(CX), SP	
  0x444e3d		0f86b2000000		JBE 0x444ef5		
  0x444e43		4883ec38		SUBQ $0x38, SP		
  0x444e47		48896c2430		MOVQ BP, 0x30(SP)	
  0x444e4c		488d6c2430		LEAQ 0x30(SP), BP	
  0x444e51		488b4208		MOVQ 0x8(DX), AX	
  0x444e55		4889442428		MOVQ AX, 0x28(SP)	
			for _, p := range allp {
  0x444e5a		488b0dc7cb0700		MOVQ runtime.allp+8(SB), CX	
  0x444e61		48894c2410		MOVQ CX, 0x10(SP)		
  0x444e66		488b15b3cb0700		MOVQ runtime.allp(SB), DX	
  0x444e6d		4889542420		MOVQ DX, 0x20(SP)		
  0x444e72		31db			XORL BX, BX			
  0x444e74		eb18			JMP 0x444e8e			
  0x444e76		488b742408		MOVQ 0x8(SP), SI		
  0x444e7b		488d5e01		LEAQ 0x1(SI), BX		
					restart = true
  0x444e7f		488b442428		MOVQ 0x28(SP), AX	
			for _, p := range allp {
  0x444e84		488b4c2410		MOVQ 0x10(SP), CX	
  0x444e89		488b542420		MOVQ 0x20(SP), DX	
  0x444e8e		4839cb			CMPQ CX, BX		
  0x444e91		7d4d			JGE 0x444ee0		
  0x444e93		48895c2408		MOVQ BX, 0x8(SP)	
  0x444e98		488b04da		MOVQ 0(DX)(BX*8), AX	
  0x444e9c		4889442418		MOVQ AX, 0x18(SP)	
				wbBufFlush1(p)
  0x444ea1		48890424		MOVQ AX, 0(SP)			
  0x444ea5		e846befdff		CALL runtime.wbBufFlush1(SB)	
				if !p.gcw.empty() {
  0x444eaa		488b442418		MOVQ 0x18(SP), AX	
  0x444eaf		8400			TESTB AL, 0(AX)		
  0x444eb1		90			NOPL			
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x444eb2		488b8870120000		MOVQ 0x1270(AX), CX	
  0x444eb9		4885c9			TESTQ CX, CX		
  0x444ebc		7430			JE 0x444eee		
  0x444ebe		4883791000		CMPQ $0x0, 0x10(CX)	
  0x444ec3		7525			JNE 0x444eea		
  0x444ec5		488b8078120000		MOVQ 0x1278(AX), AX	
  0x444ecc		4883781000		CMPQ $0x0, 0x10(AX)	
  0x444ed1		0f94c0			SETE AL			
				if !p.gcw.empty() {
  0x444ed4		84c0			TESTL AL, AL		
  0x444ed6		759e			JNE 0x444e76		
					restart = true
  0x444ed8		488b442428		MOVQ 0x28(SP), AX	
  0x444edd		c60001			MOVB $0x1, 0(AX)	
  0x444ee0		488b6c2430		MOVQ 0x30(SP), BP	
  0x444ee5		4883c438		ADDQ $0x38, SP		
  0x444ee9		c3			RET			
  0x444eea		31c0			XORL AX, AX		
	return w.wbuf1 == nil || (w.wbuf1.nobj == 0 && w.wbuf2.nobj == 0)
  0x444eec		ebe6			JMP 0x444ed4		
  0x444eee		b801000000		MOVL $0x1, AX		
  0x444ef3		ebdf			JMP 0x444ed4		
		systemstack(func() {
  0x444ef5		e8e6280000		CALL runtime.morestack(SB)		
  0x444efa		e931ffffff		JMP runtime.gcMarkDone.func2(SB)	

TEXT runtime.gcMarkDone.func3(SB) /usr/local/go/src/runtime/mgc.go
			systemstack(func() {
  0x444f00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444f09		483b6110		CMPQ 0x10(CX), SP	
  0x444f0d		7634			JBE 0x444f43		
  0x444f0f		4883ec18		SUBQ $0x18, SP		
  0x444f13		48896c2410		MOVQ BP, 0x10(SP)	
  0x444f18		488d6c2410		LEAQ 0x10(SP), BP	
				now := startTheWorldWithSema(true)
  0x444f1d		c6042401		MOVB $0x1, 0(SP)			
  0x444f21		e8aa27feff		CALL runtime.startTheWorldWithSema(SB)	
  0x444f26		488b442408		MOVQ 0x8(SP), AX			
				work.pauseNS += now - work.pauseStart
  0x444f2b		482b05b6d10700		SUBQ runtime.work+360(SB), AX	
  0x444f32		480105a7d10700		ADDQ AX, runtime.work+352(SB)	
			})
  0x444f39		488b6c2410		MOVQ 0x10(SP), BP	
  0x444f3e		4883c418		ADDQ $0x18, SP		
  0x444f42		c3			RET			
			systemstack(func() {
  0x444f43		e838290000		CALL runtime.morestack_noctxt(SB)	
  0x444f48		ebb6			JMP runtime.gcMarkDone.func3(SB)	

TEXT runtime.gcMarkTermination.func1(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x444f50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444f59		483b6110		CMPQ 0x10(CX), SP	
  0x444f5d		7625			JBE 0x444f84		
  0x444f5f		4883ec10		SUBQ $0x10, SP		
  0x444f63		48896c2408		MOVQ BP, 0x8(SP)	
  0x444f68		488d6c2408		LEAQ 0x8(SP), BP	
  0x444f6d		488b4208		MOVQ 0x8(DX), AX	
		gcMark(startTime)
  0x444f71		48890424		MOVQ AX, 0(SP)		
  0x444f75		e866fdfcff		CALL runtime.gcMark(SB)	
	})
  0x444f7a		488b6c2408		MOVQ 0x8(SP), BP	
  0x444f7f		4883c410		ADDQ $0x10, SP		
  0x444f83		c3			RET			
	systemstack(func() {
  0x444f84		e857280000		CALL runtime.morestack(SB)		
  0x444f89		ebc5			JMP runtime.gcMarkTermination.func1(SB)	

TEXT runtime.gcMarkTermination.func2(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x444f90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x444f99		483b6110		CMPQ 0x10(CX), SP	
  0x444f9d		0f86f8000000		JBE 0x44509b		
  0x444fa3		4883ec20		SUBQ $0x20, SP		
  0x444fa7		48896c2418		MOVQ BP, 0x18(SP)	
  0x444fac		488d6c2418		LEAQ 0x18(SP), BP	
		work.heap2 = work.bytesMarked
  0x444fb1		488b0548d00700		MOVQ runtime.work+128(SB), AX	
  0x444fb8		48890541d10700		MOVQ AX, runtime.work+384(SB)	
		if debug.gccheckmark > 0 {
  0x444fbf		833d2a7f090000		CMPL $0x0, runtime.debug+16(SB)	
  0x444fc6		7f5c			JG 0x445024			
		setGCPhase(_GCoff)
  0x444fc8		90			NOPL			
	atomic.Store(&gcphase, x)
  0x444fc9		31c0			XORL AX, AX			
  0x444fcb		488d0d0a7d0900		LEAQ runtime.gcphase(SB), CX	
  0x444fd2		8701			XCHGL AX, 0(CX)			
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x444fd4		8b05027d0900		MOVL runtime.gcphase(SB), AX		
  0x444fda		83f801			CMPL $0x1, AX				
  0x444fdd		753d			JNE 0x44501c				
  0x444fdf		b801000000		MOVL $0x1, AX				
  0x444fe4		88053a7e0900		MOVB AL, runtime.writeBarrier+4(SB)	
  0x444fea		84c0			TESTL AL, AL				
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x444fec		7425			JE 0x445013				
  0x444fee		b801000000		MOVL $0x1, AX				
  0x444ff3		8805277e0900		MOVB AL, runtime.writeBarrier(SB)	
		gcSweep(work.mode)
  0x444ff9		488b0568d00700		MOVQ runtime.work+232(SB), AX	
  0x445000		48890424		MOVQ AX, 0(SP)			
  0x445004		e85702fdff		CALL runtime.gcSweep(SB)	
	})
  0x445009		488b6c2418		MOVQ 0x18(SP), BP	
  0x44500e		4883c420		ADDQ $0x20, SP		
  0x445012		c3			RET			
	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo
  0x445013		0fb6050b7e0900		MOVZX runtime.writeBarrier+5(SB), AX	
  0x44501a		ebd7			JMP 0x444ff3				
	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination
  0x44501c		83f802			CMPL $0x2, AX		
  0x44501f		0f94c0			SETE AL			
  0x445022		ebc0			JMP 0x444fe4		
			gcResetMarkState()
  0x445024		e82704fdff		CALL runtime.gcResetMarkState(SB)	
			initCheckmarks()
  0x445029		e87248fdff		CALL runtime.initCheckmarks(SB)	
			gcw := &getg().m.p.ptr().gcw
  0x44502e		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x445037		488b4030		MOVQ 0x30(AX), AX	
  0x44503b		488b88d0000000		MOVQ 0xd0(AX), CX	
  0x445042		8401			TESTB AL, 0(CX)		
  0x445044		8400			TESTB AL, 0(AX)		
  0x445046		488d8170120000		LEAQ 0x1270(CX), AX	
  0x44504d		4889442410		MOVQ AX, 0x10(SP)	
  0x445052		90			NOPL			
			gcDrain(gcw, 0)
  0x445053		48890424		MOVQ AX, 0(SP)			
  0x445057		48c744240800000000	MOVQ $0x0, 0x8(SP)		
  0x445060		e81b30fdff		CALL runtime.gcDrain(SB)	
			wbBufFlush1(getg().m.p.ptr())
  0x445065		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX		
  0x44506e		488b4030		MOVQ 0x30(AX), AX		
  0x445072		488b80d0000000		MOVQ 0xd0(AX), AX		
  0x445079		90			NOPL				
  0x44507a		48890424		MOVQ AX, 0(SP)			
  0x44507e		e86dbcfdff		CALL runtime.wbBufFlush1(SB)	
			gcw.dispose()
  0x445083		488b442410		MOVQ 0x10(SP), AX			
  0x445088		48890424		MOVQ AX, 0(SP)				
  0x44508c		e89f68fdff		CALL runtime.(*gcWork).dispose(SB)	
			clearCheckmarks()
  0x445091		e84a49fdff		CALL runtime.clearCheckmarks(SB)	
  0x445096		e92dffffff		JMP 0x444fc8				
	systemstack(func() {
  0x44509b		e8e0270000		CALL runtime.morestack_noctxt(SB)	
  0x4450a0		e9ebfeffff		JMP runtime.gcMarkTermination.func2(SB)	

TEXT runtime.gcMarkTermination.func3(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() { startTheWorldWithSema(true) })
  0x4450b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4450b9		483b6110		CMPQ 0x10(CX), SP			
  0x4450bd		7621			JBE 0x4450e0				
  0x4450bf		4883ec18		SUBQ $0x18, SP				
  0x4450c3		48896c2410		MOVQ BP, 0x10(SP)			
  0x4450c8		488d6c2410		LEAQ 0x10(SP), BP			
  0x4450cd		c6042401		MOVB $0x1, 0(SP)			
  0x4450d1		e8fa25feff		CALL runtime.startTheWorldWithSema(SB)	
  0x4450d6		488b6c2410		MOVQ 0x10(SP), BP			
  0x4450db		4883c418		ADDQ $0x18, SP				
  0x4450df		c3			RET					
  0x4450e0		e89b270000		CALL runtime.morestack_noctxt(SB)	
  0x4450e5		ebc9			JMP runtime.gcMarkTermination.func3(SB)	

TEXT runtime.gcMarkTermination.func4.1(SB) /usr/local/go/src/runtime/mgc.go
		forEachP(func(_p_ *p) {
  0x4450f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4450f9		483b6110		CMPQ 0x10(CX), SP	
  0x4450fd		762a			JBE 0x445129		
  0x4450ff		4883ec10		SUBQ $0x10, SP		
  0x445103		48896c2408		MOVQ BP, 0x8(SP)	
  0x445108		488d6c2408		LEAQ 0x8(SP), BP	
			_p_.mcache.prepareForSweep()
  0x44510d		488b442418		MOVQ 0x18(SP), AX				
  0x445112		488b4048		MOVQ 0x48(AX), AX				
  0x445116		48890424		MOVQ AX, 0(SP)					
  0x44511a		e8f1b8fcff		CALL runtime.(*mcache).prepareForSweep(SB)	
		})
  0x44511f		488b6c2408		MOVQ 0x8(SP), BP	
  0x445124		4883c410		ADDQ $0x10, SP		
  0x445128		c3			RET			
		forEachP(func(_p_ *p) {
  0x445129		e852270000		CALL runtime.morestack_noctxt(SB)		
  0x44512e		ebc0			JMP runtime.gcMarkTermination.func4.1(SB)	

TEXT runtime.gcMarkTermination.func4(SB) /usr/local/go/src/runtime/mgc.go
	systemstack(func() {
  0x445130		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445139		483b6110		CMPQ 0x10(CX), SP	
  0x44513d		7628			JBE 0x445167		
  0x44513f		4883ec10		SUBQ $0x10, SP		
  0x445143		48896c2408		MOVQ BP, 0x8(SP)	
  0x445148		488d6c2408		LEAQ 0x8(SP), BP	
		forEachP(func(_p_ *p) {
  0x44514d		488d05dce60200		LEAQ 0x2e6dc(IP), AX		
  0x445154		48890424		MOVQ AX, 0(SP)			
  0x445158		e8532cfeff		CALL runtime.forEachP(SB)	
	})
  0x44515d		488b6c2408		MOVQ 0x8(SP), BP	
  0x445162		4883c410		ADDQ $0x10, SP		
  0x445166		c3			RET			
	systemstack(func() {
  0x445167		e814270000		CALL runtime.morestack_noctxt(SB)	
  0x44516c		ebc2			JMP runtime.gcMarkTermination.func4(SB)	

TEXT runtime.gcBgMarkWorker.func1(SB) /usr/local/go/src/runtime/mgc.go
			releasem(park.m.ptr())
  0x445170		488b4c2410		MOVQ 0x10(SP), CX	
  0x445175		488b11			MOVQ 0(CX), DX		
  0x445178		90			NOPL			
  0x445179		90			NOPL			
	_g_ := getg()
  0x44517a		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
	mp.locks--
  0x445183		8bb208010000		MOVL 0x108(DX), SI	
  0x445189		8d7eff			LEAL -0x1(SI), DI	
  0x44518c		89ba08010000		MOVL DI, 0x108(DX)	
	if mp.locks == 0 && _g_.preempt {
  0x445192		83fe01			CMPL $0x1, SI		
  0x445195		7511			JNE 0x4451a8		
  0x445197		80bbb100000000		CMPB $0x0, 0xb1(BX)	
  0x44519e		7408			JE 0x4451a8		
		_g_.stackguard0 = stackPreempt
  0x4451a0		48c74310defaffff	MOVQ $-0x522, 0x10(BX)	
			if park.attach != 0 {
  0x4451a8		488b5108		MOVQ 0x8(CX), DX	
  0x4451ac		4885d2			TESTQ DX, DX		
  0x4451af		7422			JE 0x4451d3		
				p := park.attach.ptr()
  0x4451b1		90			NOPL			
				park.attach.set(nil)
  0x4451b2		90			NOPL			
func (pp *puintptr) set(p *p) { *pp = puintptr(unsafe.Pointer(p)) }
  0x4451b3		31db			XORL BX, BX		
  0x4451b5		48895908		MOVQ BX, 0x8(CX)	
				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
  0x4451b9		8402			TESTB AL, 0(DX)		
  0x4451bb		90			NOPL			
  0x4451bc		488b4c2408		MOVQ 0x8(SP), CX	
	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
  0x4451c1		31c0			XORL AX, AX			
  0x4451c3		f0480fb18a58120000	LOCK CMPXCHGQ CX, 0x1258(DX)	
  0x4451cc		0f94c1			SETE CL				
  0x4451cf		84c9			TESTL CL, CL			
				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
  0x4451d1		7406			JE 0x4451d9		
			return true
  0x4451d3		c644241801		MOVB $0x1, 0x18(SP)	
  0x4451d8		c3			RET			
					return false
  0x4451d9		c644241800		MOVB $0x0, 0x18(SP)	
  0x4451de		c3			RET			

TEXT runtime.gcBgMarkWorker.func2(SB) /usr/local/go/src/runtime/mgc.go
		systemstack(func() {
  0x4451e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4451e9		483b6110		CMPQ 0x10(CX), SP	
  0x4451ed		0f8690010000		JBE 0x445383		
  0x4451f3		4883ec38		SUBQ $0x38, SP		
  0x4451f7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4451fc		488d6c2430		LEAQ 0x30(SP), BP	
  0x445201		488b4210		MOVQ 0x10(DX), AX	
  0x445205		4889442420		MOVQ AX, 0x20(SP)	
  0x44520a		488b4a08		MOVQ 0x8(DX), CX	
  0x44520e		48894c2418		MOVQ CX, 0x18(SP)	
			casgstatus(gp, _Grunning, _Gwaiting)
  0x445213		48890c24		MOVQ CX, 0(SP)			
  0x445217		48ba0200000004000000	MOVQ $0x400000002, DX		
  0x445221		4889542408		MOVQ DX, 0x8(SP)		
  0x445226		e8751afeff		CALL runtime.casgstatus(SB)	
			switch _p_.gcMarkWorkerMode {
  0x44522b		488b442420		MOVQ 0x20(SP), AX	
  0x445230		8400			TESTB AL, 0(AX)		
  0x445232		488b8860120000		MOVQ 0x1260(AX), CX	
			case gcMarkWorkerDedicatedMode:
  0x445239		4885c9			TESTQ CX, CX		
  0x44523c		0f85e6000000		JNE 0x445328		
				gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x445242		488d8870120000		LEAQ 0x1270(AX), CX		
  0x445249		48894c2428		MOVQ CX, 0x28(SP)		
  0x44524e		48890c24		MOVQ CX, 0(SP)			
  0x445252		48c744240803000000	MOVQ $0x3, 0x8(SP)		
  0x44525b		e8202efdff		CALL runtime.gcDrain(SB)	
				if gp.preempt {
  0x445260		488b442418		MOVQ 0x18(SP), AX	
  0x445265		80b8b100000000		CMPB $0x0, 0xb1(AX)	
  0x44526c		747c			JE 0x4452ea		
					lock(&sched.lock)
  0x44526e		488d053bca0700		LEAQ runtime.sched+16(SB), AX	
  0x445275		48890424		MOVQ AX, 0(SP)			
  0x445279		e86234fcff		CALL runtime.lock(SB)		
					for {
  0x44527e		eb0e			JMP 0x44528e		
	q.tail.set(gp)
  0x445280		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x445281		48891578ca0700		MOVQ DX, runtime.sched+96(SB)	
	sched.runqsize++
  0x445288		ff057aca0700		INCL runtime.sched+104(SB)	
						gp, _ := runqget(_p_)
  0x44528e		488b442420		MOVQ 0x20(SP), AX		
  0x445293		48890424		MOVQ AX, 0(SP)			
  0x445297		e8e4b4feff		CALL runtime.runqget(SB)	
  0x44529c		488b442408		MOVQ 0x8(SP), AX		
						if gp == nil {
  0x4452a1		4885c0			TESTQ AX, AX		
  0x4452a4		7434			JE 0x4452da		
						globrunqput(gp)
  0x4452a6		90			NOPL			
	sched.runq.pushBack(gp)
  0x4452a7		90			NOPL			
	gp.schedlink = 0
  0x4452a8		48c780a000000000000000	MOVQ $0x0, 0xa0(AX)	
	if q.tail != 0 {
  0x4452b3		488b0d46ca0700		MOVQ runtime.sched+96(SB), CX	
  0x4452ba		4885c9			TESTQ CX, CX			
  0x4452bd		740e			JE 0x4452cd			
		q.tail.ptr().schedlink.set(gp)
  0x4452bf		90			NOPL			
  0x4452c0		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4452c1		4889c2			MOVQ AX, DX		
  0x4452c4		488981a0000000		MOVQ AX, 0xa0(CX)	
	q.tail.set(gp)
  0x4452cb		ebb3			JMP 0x445280		
		q.head.set(gp)
  0x4452cd		90			NOPL			
func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
  0x4452ce		4889c2			MOVQ AX, DX			
  0x4452d1		48890520ca0700		MOVQ AX, runtime.sched+88(SB)	
	q.tail.set(gp)
  0x4452d8		eba6			JMP 0x445280		
					unlock(&sched.lock)
  0x4452da		488d05cfc90700		LEAQ runtime.sched+16(SB), AX	
  0x4452e1		48890424		MOVQ AX, 0(SP)			
  0x4452e5		e8a635fcff		CALL runtime.unlock(SB)		
				gcDrain(&_p_.gcw, gcDrainFlushBgCredit)
  0x4452ea		488b442428		MOVQ 0x28(SP), AX		
  0x4452ef		48890424		MOVQ AX, 0(SP)			
  0x4452f3		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4452fc		e87f2dfdff		CALL runtime.gcDrain(SB)	
			casgstatus(gp, _Gwaiting, _Grunning)
  0x445301		488b442418		MOVQ 0x18(SP), AX		
  0x445306		48890424		MOVQ AX, 0(SP)			
  0x44530a		48b80400000002000000	MOVQ $0x200000004, AX		
  0x445314		4889442408		MOVQ AX, 0x8(SP)		
  0x445319		e88219feff		CALL runtime.casgstatus(SB)	
		})
  0x44531e		488b6c2430		MOVQ 0x30(SP), BP	
  0x445323		4883c438		ADDQ $0x38, SP		
  0x445327		c3			RET			
			case gcMarkWorkerFractionalMode:
  0x445328		4883f901		CMPQ $0x1, CX		
  0x44532c		7420			JE 0x44534e		
			case gcMarkWorkerIdleMode:
  0x44532e		4883f902		CMPQ $0x2, CX		
  0x445332		7534			JNE 0x445368		
				gcDrain(&_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x445334		480570120000		ADDQ $0x1270, AX		
  0x44533a		48890424		MOVQ AX, 0(SP)			
  0x44533e		48c744240807000000	MOVQ $0x7, 0x8(SP)		
  0x445347		e8342dfdff		CALL runtime.gcDrain(SB)	
			switch _p_.gcMarkWorkerMode {
  0x44534c		ebb3			JMP 0x445301		
				gcDrain(&_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)
  0x44534e		480570120000		ADDQ $0x1270, AX		
  0x445354		48890424		MOVQ AX, 0(SP)			
  0x445358		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x445361		e81a2dfdff		CALL runtime.gcDrain(SB)	
			switch _p_.gcMarkWorkerMode {
  0x445366		eb99			JMP 0x445301		
				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
  0x445368		488d0566d90200		LEAQ 0x2d966(IP), AX	
  0x44536f		48890424		MOVQ AX, 0(SP)		
  0x445373		48c74424082b000000	MOVQ $0x2b, 0x8(SP)	
  0x44537c		e8ffe0fdff		CALL runtime.throw(SB)	
  0x445381		0f0b			UD2			
		systemstack(func() {
  0x445383		e858240000		CALL runtime.morestack(SB)		
  0x445388		e953feffff		JMP runtime.gcBgMarkWorker.func2(SB)	

TEXT runtime.markroot.func1(SB) /usr/local/go/src/runtime/mgcmark.go
		systemstack(func() {
  0x445390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445399		483b6110		CMPQ 0x10(CX), SP	
  0x44539d		0f86ce000000		JBE 0x445471		
  0x4453a3		4883ec38		SUBQ $0x38, SP		
  0x4453a7		48896c2430		MOVQ BP, 0x30(SP)	
  0x4453ac		488d6c2430		LEAQ 0x30(SP), BP	
			userG := getg().m.curg
  0x4453b1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4453ba		488b4030		MOVQ 0x30(AX), AX	
		systemstack(func() {
  0x4453be		488b4a10		MOVQ 0x10(DX), CX	
  0x4453c2		488b5208		MOVQ 0x8(DX), DX	
			userG := getg().m.curg
  0x4453c6		488b80c0000000		MOVQ 0xc0(AX), AX	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x4453cd		4839c2			CMPQ AX, DX		
  0x4453d0		0f8594000000		JNE 0x44546a		
  0x4453d6		90			NOPL			
	return atomic.Load(&gp.atomicstatus)
  0x4453d7		8b9890000000		MOVL 0x90(AX), BX	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x4453dd		83fb02			CMPL $0x2, BX		
  0x4453e0		0f94c3			SETE BL			
			userG := getg().m.curg
  0x4453e3		4889442420		MOVQ AX, 0x20(SP)	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x4453e8		885c2417		MOVB BL, 0x17(SP)	
  0x4453ec		84db			TESTL BL, BL		
			if selfScan {
  0x4453ee		7540			JNE 0x445430		
			scang(gp, gcw)
  0x4453f0		48891424		MOVQ DX, 0(SP)		
  0x4453f4		48894c2408		MOVQ CX, 0x8(SP)	
  0x4453f9		e8a21afeff		CALL runtime.scang(SB)	
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x4453fe		0fb6442417		MOVZX 0x17(SP), AX	
  0x445403		84c0			TESTL AL, AL		
			if selfScan {
  0x445405		750a			JNE 0x445411		
  0x445407		488b6c2430		MOVQ 0x30(SP), BP	
  0x44540c		4883c438		ADDQ $0x38, SP		
  0x445410		c3			RET			
				casgstatus(userG, _Gwaiting, _Grunning)
  0x445411		488b442420		MOVQ 0x20(SP), AX		
  0x445416		48890424		MOVQ AX, 0(SP)			
  0x44541a		48b80400000002000000	MOVQ $0x200000004, AX		
  0x445424		4889442408		MOVQ AX, 0x8(SP)		
  0x445429		e87218feff		CALL runtime.casgstatus(SB)	
  0x44542e		ebd7			JMP 0x445407			
		systemstack(func() {
  0x445430		4889542418		MOVQ DX, 0x18(SP)	
  0x445435		48894c2428		MOVQ CX, 0x28(SP)	
				casgstatus(userG, _Grunning, _Gwaiting)
  0x44543a		48890424		MOVQ AX, 0(SP)			
  0x44543e		48b90200000004000000	MOVQ $0x400000002, CX		
  0x445448		48894c2408		MOVQ CX, 0x8(SP)		
  0x44544d		e84e18feff		CALL runtime.casgstatus(SB)	
				userG.waitreason = waitReasonGarbageCollectionScan
  0x445452		488b442420		MOVQ 0x20(SP), AX	
  0x445457		c680b000000007		MOVB $0x7, 0xb0(AX)	
			scang(gp, gcw)
  0x44545e		488b4c2428		MOVQ 0x28(SP), CX	
  0x445463		488b542418		MOVQ 0x18(SP), DX	
				userG.waitreason = waitReasonGarbageCollectionScan
  0x445468		eb86			JMP 0x4453f0		
  0x44546a		31db			XORL BX, BX		
			selfScan := gp == userG && readgstatus(userG) == _Grunning
  0x44546c		e972ffffff		JMP 0x4453e3		
		systemstack(func() {
  0x445471		e86a230000		CALL runtime.morestack(SB)	
  0x445476		e915ffffff		JMP runtime.markroot.func1(SB)	

TEXT runtime.gcAssistAlloc.func1(SB) /usr/local/go/src/runtime/mgcmark.go
	systemstack(func() {
  0x445480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445489		483b6110		CMPQ 0x10(CX), SP	
  0x44548d		762e			JBE 0x4454bd		
  0x44548f		4883ec18		SUBQ $0x18, SP		
  0x445493		48896c2410		MOVQ BP, 0x10(SP)	
  0x445498		488d6c2410		LEAQ 0x10(SP), BP	
  0x44549d		488b4210		MOVQ 0x10(DX), AX	
  0x4454a1		488b4a08		MOVQ 0x8(DX), CX	
		gcAssistAlloc1(gp, scanWork)
  0x4454a5		48890c24		MOVQ CX, 0(SP)			
  0x4454a9		4889442408		MOVQ AX, 0x8(SP)		
  0x4454ae		e87d1cfdff		CALL runtime.gcAssistAlloc1(SB)	
	})
  0x4454b3		488b6c2410		MOVQ 0x10(SP), BP	
  0x4454b8		4883c418		ADDQ $0x18, SP		
  0x4454bc		c3			RET			
	systemstack(func() {
  0x4454bd		e81e230000		CALL runtime.morestack(SB)		
  0x4454c2		ebbc			JMP runtime.gcAssistAlloc.func1(SB)	

TEXT runtime.scanstack.func1(SB) /usr/local/go/src/runtime/mgcmark.go
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x4454d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4454d9		483b6110		CMPQ 0x10(CX), SP	
  0x4454dd		763d			JBE 0x44551c		
  0x4454df		4883ec20		SUBQ $0x20, SP		
  0x4454e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4454e8		488d6c2418		LEAQ 0x18(SP), BP	
  0x4454ed		488b4210		MOVQ 0x10(DX), AX	
  0x4454f1		488b4a08		MOVQ 0x8(DX), CX	
		scanframeworker(frame, &state, gcw)
  0x4454f5		488b542428		MOVQ 0x28(SP), DX			
  0x4454fa		48891424		MOVQ DX, 0(SP)				
  0x4454fe		48894c2408		MOVQ CX, 0x8(SP)			
  0x445503		4889442410		MOVQ AX, 0x10(SP)			
  0x445508		e89329fdff		CALL runtime.scanframeworker(SB)	
		return true
  0x44550d		c644243801		MOVB $0x1, 0x38(SP)	
  0x445512		488b6c2418		MOVQ 0x18(SP), BP	
  0x445517		4883c420		ADDQ $0x20, SP		
  0x44551b		c3			RET			
	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
  0x44551c		e8bf220000		CALL runtime.morestack(SB)	
  0x445521		ebad			JMP runtime.scanstack.func1(SB)	

TEXT runtime.getempty.func1(SB) /usr/local/go/src/runtime/mgcwork.go
			systemstack(func() {
  0x445530		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445539		483b6110		CMPQ 0x10(CX), SP	
  0x44553d		7653			JBE 0x445592		
  0x44553f		4883ec30		SUBQ $0x30, SP		
  0x445543		48896c2428		MOVQ BP, 0x28(SP)	
  0x445548		488d6c2428		LEAQ 0x28(SP), BP	
  0x44554d		488b4208		MOVQ 0x8(DX), AX	
  0x445551		4889442420		MOVQ AX, 0x20(SP)	
				s = mheap_.allocManual(workbufAlloc/pageSize, &memstats.gc_sys)
  0x445556		488d0de3100800		LEAQ runtime.mheap_(SB), CX		
  0x44555d		48890c24		MOVQ CX, 0(SP)				
  0x445561		48c744240804000000	MOVQ $0x4, 0x8(SP)			
  0x44556a		488d0d87870900		LEAQ runtime.memstats+152(SB), CX	
  0x445571		48894c2410		MOVQ CX, 0x10(SP)			
  0x445576		e82580fdff		CALL runtime.(*mheap).allocManual(SB)	
  0x44557b		488b442418		MOVQ 0x18(SP), AX			
  0x445580		488b4c2420		MOVQ 0x20(SP), CX			
  0x445585		488901			MOVQ AX, 0(CX)				
			})
  0x445588		488b6c2428		MOVQ 0x28(SP), BP	
  0x44558d		4883c430		ADDQ $0x30, SP		
  0x445591		c3			RET			
			systemstack(func() {
  0x445592		e849220000		CALL runtime.morestack(SB)	
  0x445597		eb97			JMP runtime.getempty.func1(SB)	

TEXT runtime.freeSomeWbufs.func1(SB) /usr/local/go/src/runtime/mgcwork.go
	systemstack(func() {
  0x4455a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4455a9		483b6110		CMPQ 0x10(CX), SP	
  0x4455ad		0f86ca000000		JBE 0x44567d		
  0x4455b3		4883ec40		SUBQ $0x40, SP		
  0x4455b7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4455bc		488d6c2438		LEAQ 0x38(SP), BP	
		gp := getg().m.curg
  0x4455c1		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	
  0x4455ca		488b4030		MOVQ 0x30(AX), AX	
  0x4455ce		488b80c0000000		MOVQ 0xc0(AX), AX	
  0x4455d5		4889442430		MOVQ AX, 0x30(SP)	
	systemstack(func() {
  0x4455da		0fb64a08		MOVZX 0x8(DX), CX	
  0x4455de		884c241f		MOVB CL, 0x1f(SP)	
  0x4455e2		80f900			CMPL $0x0, CL		
  0x4455e5		31d2			XORL DX, DX		
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x4455e7		eb60			JMP 0x445649		
  0x4455e9		4889542420		MOVQ DX, 0x20(SP)	
			span := work.wbufSpans.free.first
  0x4455ee		48895c2428		MOVQ BX, 0x28(SP)	
			work.wbufSpans.free.remove(span)
  0x4455f3		488d05dec90700		LEAQ runtime.work+88(SB), AX		
  0x4455fa		48890424		MOVQ AX, 0(SP)				
  0x4455fe		48895c2408		MOVQ BX, 0x8(SP)			
  0x445603		e8a892fdff		CALL runtime.(*mSpanList).remove(SB)	
			mheap_.freeManual(span, &memstats.gc_sys)
  0x445608		488d0531100800		LEAQ runtime.mheap_(SB), AX		
  0x44560f		48890424		MOVQ AX, 0(SP)				
  0x445613		488b4c2428		MOVQ 0x28(SP), CX			
  0x445618		48894c2408		MOVQ CX, 0x8(SP)			
  0x44561d		488d0dd4860900		LEAQ runtime.memstats+152(SB), CX	
  0x445624		48894c2410		MOVQ CX, 0x10(SP)			
  0x445629		e86289fdff		CALL runtime.(*mheap).freeManual(SB)	
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x44562e		488b442420		MOVQ 0x20(SP), AX	
  0x445633		488d5001		LEAQ 0x1(AX), DX	
  0x445637		0fb644241f		MOVZX 0x1f(SP), AX	
  0x44563c		488b4c2430		MOVQ 0x30(SP), CX	
  0x445641		4889c8			MOVQ CX, AX		
	systemstack(func() {
  0x445644		0fb64c241f		MOVZX 0x1f(SP), CX	
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x445649		4883fa40		CMPQ $0x40, DX		
  0x44564d		7d20			JGE 0x44566f		
	systemstack(func() {
  0x44564f		80f900			CMPL $0x0, CL		
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x445652		7425			JE 0x445679		
  0x445654		0fb698b1000000		MOVZX 0xb1(AX), BX	
  0x44565b		84db			TESTL BL, BL		
  0x44565d		7510			JNE 0x44566f		
			span := work.wbufSpans.free.first
  0x44565f		488b1d72c90700		MOVQ runtime.work+88(SB), BX	
			if span == nil {
  0x445666		4885db			TESTQ BX, BX		
  0x445669		0f857affffff		JNE 0x4455e9		
  0x44566f		488b6c2438		MOVQ 0x38(SP), BP	
  0x445674		4883c440		ADDQ $0x40, SP		
  0x445678		c3			RET			
  0x445679		31db			XORL BX, BX		
		for i := 0; i < batchSize && !(preemptible && gp.preempt); i++ {
  0x44567b		ebde			JMP 0x44565b		
	systemstack(func() {
  0x44567d		e85e210000		CALL runtime.morestack(SB)		
  0x445682		e919ffffff		JMP runtime.freeSomeWbufs.func1(SB)	

TEXT runtime.(*mheap).coalesce.func1(SB) /usr/local/go/src/runtime/mheap.go
	merge := func(other *mspan) {
  0x445690		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445699		483b6110		CMPQ 0x10(CX), SP	
  0x44569d		0f86fb010000		JBE 0x44589e		
  0x4456a3		4883ec20		SUBQ $0x20, SP		
  0x4456a7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4456ac		488d6c2418		LEAQ 0x18(SP), BP	
  0x4456b1		488b4208		MOVQ 0x8(DX), AX	
  0x4456b5		488b4a10		MOVQ 0x10(DX), CX	
  0x4456b9		488b5a18		MOVQ 0x18(DX), BX	
  0x4456bd		488b5220		MOVQ 0x20(DX), DX	
		s.npages += other.npages
  0x4456c1		488b7020		MOVQ 0x20(AX), SI	
  0x4456c5		488b7c2428		MOVQ 0x28(SP), DI	
  0x4456ca		48037720		ADDQ 0x20(DI), SI	
  0x4456ce		48897020		MOVQ SI, 0x20(AX)	
		s.needzero |= other.needzero
  0x4456d2		0fb67064		MOVZX 0x64(AX), SI	
  0x4456d6		440fb64764		MOVZX 0x64(DI), R8	
  0x4456db		4409c6			ORL R8, SI		
  0x4456de		40887064		MOVB SI, 0x64(AX)	
		if other.startAddr < s.startAddr {
  0x4456e2		488b7718		MOVQ 0x18(DI), SI	
  0x4456e6		4c8b4018		MOVQ 0x18(AX), R8	
  0x4456ea		4c39c6			CMPQ R8, SI		
  0x4456ed		0f8343010000		JAE 0x445836		
			s.startAddr = other.startAddr
  0x4456f3		48897018		MOVQ SI, 0x18(AX)	
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x4456f7		4c8b8110030000		MOVQ 0x310(CX), R8	
  0x4456fe		418400			TESTB AL, 0(R8)		
			h.setSpan(s.base(), s)
  0x445701		90			NOPL			
  0x445702		90			NOPL			
	ai := arenaIndex(base)
  0x445703		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445704		90			NOPL			
  0x445705		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x445706		49b90000000000800000	MOVQ $0x800000000000, R9	
  0x445710		4901f1			ADDQ SI, R9			
  0x445713		49c1e91a		SHRQ $0x1a, R9			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445717		4981f900004000		CMPQ $0x400000, R9		
  0x44571e		0f8373010000		JAE 0x445897			
  0x445724		4f8b04c8		MOVQ 0(R8)(R9*8), R8		
  0x445728		418400			TESTB AL, 0(R8)			
  0x44572b		48c1ee0d		SHRQ $0xd, SI			
  0x44572f		4881e6ff1f0000		ANDQ $0x1fff, SI		
  0x445736		498984f000002000	MOVQ AX, 0x200000(R8)(SI*8)	
		needsScavenge = needsScavenge || other.scavenged || s.scavenged
  0x44573e		803b00			CMPB $0x0, 0(BX)	
  0x445741		0f84d6000000		JE 0x44581d		
  0x445747		b801000000		MOVL $0x1, AX		
  0x44574c		8803			MOVB AL, 0(BX)		
		prescavenged += other.released()
  0x44574e		90			NOPL			
	if !s.scavenged {
  0x44574f		807f6700		CMPB $0x0, 0x67(DI)	
  0x445753		0f84bd000000		JE 0x445816		
	start, end := s.physPageBounds()
  0x445759		90			NOPL			
	start := s.base()
  0x44575a		90			NOPL			
	end := start + s.npages<<_PageShift
  0x44575b		488b4720		MOVQ 0x20(DI), AX	
  0x44575f		48c1e00d		SHLQ $0xd, AX		
	return s.startAddr
  0x445763		488b5f18		MOVQ 0x18(DI), BX	
	end := start + s.npages<<_PageShift
  0x445767		4801d8			ADDQ BX, AX		
	if physPageSize > _PageSize {
  0x44576a		488b3537760900		MOVQ runtime.physPageSize(SB), SI	
  0x445771		4881fe00200000		CMPQ $0x2000, SI			
  0x445778		0f8690000000		JBE 0x44580e				
		start = (start + physPageSize - 1) &^ (physPageSize - 1)
  0x44577e		488d1c1e		LEAQ 0(SI)(BX*1), BX	
  0x445782		488d5bff		LEAQ -0x1(BX), BX	
  0x445786		48ffce			DECQ SI			
  0x445789		48f7d6			NOTQ SI			
  0x44578c		4821f3			ANDQ SI, BX		
		end &^= physPageSize - 1
  0x44578f		4821c6			ANDQ AX, SI		
	return end - start
  0x445792		4829de			SUBQ BX, SI		
	merge := func(other *mspan) {
  0x445795		48894c2410		MOVQ CX, 0x10(SP)	
		prescavenged += other.released()
  0x44579a		480132			ADDQ SI, 0(DX)		
		if other.scavenged {
  0x44579d		807f6700		CMPB $0x0, 0x67(DI)	
  0x4457a1		7455			JE 0x4457f8		
			h.scav.removeSpan(other)
  0x4457a3		8401			TESTB AL, 0(CX)				
  0x4457a5		488d4110		LEAQ 0x10(CX), AX			
  0x4457a9		48890424		MOVQ AX, 0(SP)				
  0x4457ad		48897c2408		MOVQ DI, 0x8(SP)			
  0x4457b2		e81909fdff		CALL runtime.(*mTreap).removeSpan(SB)	
		other.state = mSpanDead
  0x4457b7		488b442428		MOVQ 0x28(SP), AX	
  0x4457bc		c6406300		MOVB $0x0, 0x63(AX)	
		h.spanalloc.free(unsafe.Pointer(other))
  0x4457c0		488b4c2410		MOVQ 0x10(SP), CX	
  0x4457c5		8401			TESTB AL, 0(CX)		
  0x4457c7		90			NOPL			
	f.inuse -= f.size
  0x4457c8		488b9130250000		MOVQ 0x2530(CX), DX	
  0x4457cf		482b9100250000		SUBQ 0x2500(CX), DX	
  0x4457d6		48899130250000		MOVQ DX, 0x2530(CX)	
	v.next = f.list
  0x4457dd		488b9118250000		MOVQ 0x2518(CX), DX	
  0x4457e4		488910			MOVQ DX, 0(AX)		
	f.list = v
  0x4457e7		48898118250000		MOVQ AX, 0x2518(CX)	
  0x4457ee		488b6c2418		MOVQ 0x18(SP), BP	
  0x4457f3		4883c420		ADDQ $0x20, SP		
  0x4457f7		c3			RET			
			h.free.removeSpan(other)
  0x4457f8		8401			TESTB AL, 0(CX)				
  0x4457fa		488d4108		LEAQ 0x8(CX), AX			
  0x4457fe		48890424		MOVQ AX, 0(SP)				
  0x445802		48897c2408		MOVQ DI, 0x8(SP)			
  0x445807		e8c408fdff		CALL runtime.(*mTreap).removeSpan(SB)	
  0x44580c		eba9			JMP 0x4457b7				
	start, end := s.physPageBounds()
  0x44580e		4889c6			MOVQ AX, SI		
	if physPageSize > _PageSize {
  0x445811		e97cffffff		JMP 0x445792		
  0x445816		31f6			XORL SI, SI		
		prescavenged += other.released()
  0x445818		e978ffffff		JMP 0x445795		
		needsScavenge = needsScavenge || other.scavenged || s.scavenged
  0x44581d		807f6700		CMPB $0x0, 0x67(DI)	
  0x445821		740a			JE 0x44582d		
  0x445823		b801000000		MOVL $0x1, AX		
  0x445828		e91fffffff		JMP 0x44574c		
  0x44582d		0fb64067		MOVZX 0x67(AX), AX	
  0x445831		e916ffffff		JMP 0x44574c		
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445836		488bb110030000		MOVQ 0x310(CX), SI	
  0x44583d		8406			TESTB AL, 0(SI)		
			h.setSpan(s.base()+s.npages*pageSize-1, s)
  0x44583f		90			NOPL			
  0x445840		90			NOPL			
  0x445841		4c8b4820		MOVQ 0x20(AX), R9	
  0x445845		49c1e10d		SHLQ $0xd, R9		
  0x445849		4f8d1401		LEAQ 0(R9)(R8*1), R10	
  0x44584d		4f8d0408		LEAQ 0(R8)(R9*1), R8	
  0x445851		4d8d40ff		LEAQ -0x1(R8), R8	
	ai := arenaIndex(base)
  0x445855		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445856		90			NOPL			
  0x445857		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x445858		49b9ffffffffff7f0000	MOVQ $0x7fffffffffff, R9	
  0x445862		4d01d1			ADDQ R10, R9			
  0x445865		49c1e91a		SHRQ $0x1a, R9			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445869		4981f900004000		CMPQ $0x400000, R9		
  0x445870		731e			JAE 0x445890			
  0x445872		4a8b34ce		MOVQ 0(SI)(R9*8), SI		
  0x445876		8406			TESTB AL, 0(SI)			
  0x445878		49c1e80d		SHRQ $0xd, R8			
  0x44587c		4981e0ff1f0000		ANDQ $0x1fff, R8		
  0x445883		4a8984c600002000	MOVQ AX, 0x200000(SI)(R8*8)	
		needsScavenge = needsScavenge || other.scavenged || s.scavenged
  0x44588b		e9aefeffff		JMP 0x44573e		
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445890		e88bc6fdff		CALL runtime.panicindex(SB)	
  0x445895		0f0b			UD2				
  0x445897		e884c6fdff		CALL runtime.panicindex(SB)	
  0x44589c		0f0b			UD2				
	merge := func(other *mspan) {
  0x44589e		e83d1f0000		CALL runtime.morestack(SB)		
  0x4458a3		e9e8fdffff		JMP runtime.(*mheap).coalesce.func1(SB)	

TEXT runtime.(*mheap).coalesce.func2(SB) /usr/local/go/src/runtime/mheap.go
	realign := func(a, b, other *mspan) {
  0x4458b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4458b9		483b6110		CMPQ 0x10(CX), SP	
  0x4458bd		0f86ba010000		JBE 0x445a7d		
  0x4458c3		4883ec20		SUBQ $0x20, SP		
  0x4458c7		48896c2418		MOVQ BP, 0x18(SP)	
  0x4458cc		488d6c2418		LEAQ 0x18(SP), BP	
  0x4458d1		488b4208		MOVQ 0x8(DX), AX	
		if pageSize <= physPageSize {
  0x4458d5		48813dc874090000200000	CMPQ $0x2000, runtime.physPageSize(SB)	
  0x4458e0		0f837f010000		JAE 0x445a65				
	realign := func(a, b, other *mspan) {
  0x4458e6		4889442410		MOVQ AX, 0x10(SP)	
		if other.scavenged {
  0x4458eb		488b4c2438		MOVQ 0x38(SP), CX	
  0x4458f0		80796700		CMPB $0x0, 0x67(CX)	
  0x4458f4		0f8452010000		JE 0x445a4c		
			h.scav.removeSpan(other)
  0x4458fa		8400			TESTB AL, 0(AX)				
  0x4458fc		488d5010		LEAQ 0x10(AX), DX			
  0x445900		48891424		MOVQ DX, 0(SP)				
  0x445904		48894c2408		MOVQ CX, 0x8(SP)			
  0x445909		e8c207fdff		CALL runtime.(*mTreap).removeSpan(SB)	
		boundary := b.startAddr
  0x44590e		488b442430		MOVQ 0x30(SP), AX	
  0x445913		488b4818		MOVQ 0x18(AX), CX	
		if a.scavenged {
  0x445917		488b542428		MOVQ 0x28(SP), DX	
  0x44591c		807a6700		CMPB $0x0, 0x67(DX)	
  0x445920		0f8409010000		JE 0x445a2f		
			boundary &^= (physPageSize - 1)
  0x445926		488b1d7b740900		MOVQ runtime.physPageSize(SB), BX	
  0x44592d		48ffcb			DECQ BX					
  0x445930		48f7d3			NOTQ BX					
  0x445933		4821d9			ANDQ BX, CX				
		a.npages = (boundary - a.startAddr) / pageSize
  0x445936		488b5a18		MOVQ 0x18(DX), BX	
  0x44593a		4889ce			MOVQ CX, SI		
  0x44593d		4829d9			SUBQ BX, CX		
  0x445940		48c1e90d		SHRQ $0xd, CX		
  0x445944		48894a20		MOVQ CX, 0x20(DX)	
		b.npages = (b.startAddr + b.npages*pageSize - boundary) / pageSize
  0x445948		488b4820		MOVQ 0x20(AX), CX	
  0x44594c		48c1e10d		SHLQ $0xd, CX		
  0x445950		48034818		ADDQ 0x18(AX), CX	
  0x445954		4829f1			SUBQ SI, CX		
  0x445957		48c1e90d		SHRQ $0xd, CX		
  0x44595b		48894820		MOVQ CX, 0x20(AX)	
		b.startAddr = boundary
  0x44595f		48897018		MOVQ SI, 0x18(AX)	
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445963		488b4c2410		MOVQ 0x10(SP), CX	
  0x445968		488b9910030000		MOVQ 0x310(CX), BX	
  0x44596f		8403			TESTB AL, 0(BX)		
		h.setSpan(boundary-1, a)
  0x445971		90			NOPL			
	ai := arenaIndex(base)
  0x445972		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445973		90			NOPL			
  0x445974		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x445975		48bfffffffffff7f0000	MOVQ $0x7fffffffffff, DI	
  0x44597f		4801f7			ADDQ SI, DI			
  0x445982		48c1ef1a		SHRQ $0x1a, DI			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445986		4881ff00004000		CMPQ $0x400000, DI	
  0x44598d		0f83e3000000		JAE 0x445a76		
  0x445993		488b1cfb		MOVQ 0(BX)(DI*8), BX	
  0x445997		8403			TESTB AL, 0(BX)		
		h.setSpan(boundary-1, a)
  0x445999		488d7eff		LEAQ -0x1(SI), DI	
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x44599d		48c1ef0d		SHRQ $0xd, DI			
  0x4459a1		4881e7ff1f0000		ANDQ $0x1fff, DI		
  0x4459a8		488994fb00002000	MOVQ DX, 0x200000(BX)(DI*8)	
  0x4459b0		488b9110030000		MOVQ 0x310(CX), DX		
  0x4459b7		8402			TESTB AL, 0(DX)			
		h.setSpan(boundary, b)
  0x4459b9		90			NOPL			
	ai := arenaIndex(base)
  0x4459ba		90			NOPL			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x4459bb		90			NOPL			
  0x4459bc		90			NOPL			
	return arenaIdx((p + arenaBaseOffset) / heapArenaBytes)
  0x4459bd		48bb0000000000800000	MOVQ $0x800000000000, BX	
  0x4459c7		4801f3			ADDQ SI, BX			
  0x4459ca		48c1eb1a		SHRQ $0x1a, BX			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x4459ce		4881fb00004000		CMPQ $0x400000, BX		
  0x4459d5		0f8394000000		JAE 0x445a6f			
  0x4459db		488b14da		MOVQ 0(DX)(BX*8), DX		
  0x4459df		8402			TESTB AL, 0(DX)			
  0x4459e1		48c1ee0d		SHRQ $0xd, SI			
  0x4459e5		4881e6ff1f0000		ANDQ $0x1fff, SI		
  0x4459ec		488984f200002000	MOVQ AX, 0x200000(DX)(SI*8)	
		if other.scavenged {
  0x4459f4		488b442438		MOVQ 0x38(SP), AX	
  0x4459f9		80786700		CMPB $0x0, 0x67(AX)	
  0x4459fd		741c			JE 0x445a1b		
			h.scav.insert(other)
  0x4459ff		4883c110		ADDQ $0x10, CX				
  0x445a03		48890c24		MOVQ CX, 0(SP)				
  0x445a07		4889442408		MOVQ AX, 0x8(SP)			
  0x445a0c		e82f02fdff		CALL runtime.(*mTreap).insert(SB)	
  0x445a11		488b6c2418		MOVQ 0x18(SP), BP			
  0x445a16		4883c420		ADDQ $0x20, SP				
  0x445a1a		c3			RET					
			h.free.insert(other)
  0x445a1b		4883c108		ADDQ $0x8, CX				
  0x445a1f		48890c24		MOVQ CX, 0(SP)				
  0x445a23		4889442408		MOVQ AX, 0x8(SP)			
  0x445a28		e81302fdff		CALL runtime.(*mTreap).insert(SB)	
  0x445a2d		ebe2			JMP 0x445a11				
			boundary = (boundary + physPageSize - 1) &^ (physPageSize - 1)
  0x445a2f		488b1d72730900		MOVQ runtime.physPageSize(SB), BX	
  0x445a36		488d0c19		LEAQ 0(CX)(BX*1), CX			
  0x445a3a		488d49ff		LEAQ -0x1(CX), CX			
  0x445a3e		48ffcb			DECQ BX					
  0x445a41		48f7d3			NOTQ BX					
  0x445a44		4821d9			ANDQ BX, CX				
  0x445a47		e9eafeffff		JMP 0x445936				
			h.free.removeSpan(other)
  0x445a4c		8400			TESTB AL, 0(AX)				
  0x445a4e		488d5008		LEAQ 0x8(AX), DX			
  0x445a52		48891424		MOVQ DX, 0(SP)				
  0x445a56		48894c2408		MOVQ CX, 0x8(SP)			
  0x445a5b		e87006fdff		CALL runtime.(*mTreap).removeSpan(SB)	
  0x445a60		e9a9feffff		JMP 0x44590e				
			return
  0x445a65		488b6c2418		MOVQ 0x18(SP), BP	
  0x445a6a		4883c420		ADDQ $0x20, SP		
  0x445a6e		c3			RET			
	h.arenas[ai.l1()][ai.l2()].spans[(base/pageSize)%pagesPerArena] = s
  0x445a6f		e8acc4fdff		CALL runtime.panicindex(SB)	
  0x445a74		0f0b			UD2				
  0x445a76		e8a5c4fdff		CALL runtime.panicindex(SB)	
  0x445a7b		0f0b			UD2				
	realign := func(a, b, other *mspan) {
  0x445a7d		e85e1d0000		CALL runtime.morestack(SB)		
  0x445a82		e929feffff		JMP runtime.(*mheap).coalesce.func2(SB)	

TEXT runtime.(*mheap).alloc.func1(SB) /usr/local/go/src/runtime/mheap.go
	systemstack(func() {
  0x445a90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445a99		483b6110		CMPQ 0x10(CX), SP	
  0x445a9d		7654			JBE 0x445af3		
  0x445a9f		4883ec30		SUBQ $0x30, SP		
  0x445aa3		48896c2428		MOVQ BP, 0x28(SP)	
  0x445aa8		488d6c2428		LEAQ 0x28(SP), BP	
  0x445aad		488b4210		MOVQ 0x10(DX), AX	
  0x445ab1		0fb64a18		MOVZX 0x18(DX), CX	
  0x445ab5		0fb65a19		MOVZX 0x19(DX), BX	
  0x445ab9		488b7220		MOVQ 0x20(DX), SI	
  0x445abd		4889742420		MOVQ SI, 0x20(SP)	
  0x445ac2		488b5208		MOVQ 0x8(DX), DX	
		s = h.alloc_m(npage, spanclass, large)
  0x445ac6		48891424		MOVQ DX, 0(SP)				
  0x445aca		4889442408		MOVQ AX, 0x8(SP)			
  0x445acf		884c2410		MOVB CL, 0x10(SP)			
  0x445ad3		885c2411		MOVB BL, 0x11(SP)			
  0x445ad7		e8c476fdff		CALL runtime.(*mheap).alloc_m(SB)	
  0x445adc		488b442418		MOVQ 0x18(SP), AX			
  0x445ae1		488b4c2420		MOVQ 0x20(SP), CX			
  0x445ae6		488901			MOVQ AX, 0(CX)				
	})
  0x445ae9		488b6c2428		MOVQ 0x28(SP), BP	
  0x445aee		4883c430		ADDQ $0x30, SP		
  0x445af2		c3			RET			
	systemstack(func() {
  0x445af3		e8e81c0000		CALL runtime.morestack(SB)		
  0x445af8		eb96			JMP runtime.(*mheap).alloc.func1(SB)	

TEXT runtime.(*mheap).freeSpan.func1(SB) /usr/local/go/src/runtime/mheap.go
	systemstack(func() {
  0x445b00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445b09		483b6110		CMPQ 0x10(CX), SP	
  0x445b0d		0f8608010000		JBE 0x445c1b		
  0x445b13		4883ec48		SUBQ $0x48, SP		
  0x445b17		48896c2440		MOVQ BP, 0x40(SP)	
  0x445b1c		488d6c2440		LEAQ 0x40(SP), BP	
  0x445b21		488b4208		MOVQ 0x8(DX), AX	
  0x445b25		4889442438		MOVQ AX, 0x38(SP)	
		lock(&h.lock)
  0x445b2a		8400			TESTB AL, 0(AX)		
	systemstack(func() {
  0x445b2c		488b4a10		MOVQ 0x10(DX), CX	
  0x445b30		48894c2428		MOVQ CX, 0x28(SP)	
		mp := getg().m
  0x445b35		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	
  0x445b3e		488b5b30		MOVQ 0x30(BX), BX	
  0x445b42		48895c2430		MOVQ BX, 0x30(SP)	
	systemstack(func() {
  0x445b47		0fb65218		MOVZX 0x18(DX), DX	
  0x445b4b		88542427		MOVB DL, 0x27(SP)	
  0x445b4f		80fa00			CMPL $0x0, DL		
		lock(&h.lock)
  0x445b52		48890424		MOVQ AX, 0(SP)		
  0x445b56		e8852bfcff		CALL runtime.lock(SB)	
		memstats.heap_scan += uint64(mp.mcache.local_scan)
  0x445b5b		488b442430		MOVQ 0x30(SP), AX			
  0x445b60		488b8860010000		MOVQ 0x160(AX), CX			
  0x445b67		488b153a980900		MOVQ runtime.memstats+5960(SB), DX	
  0x445b6e		48035108		ADDQ 0x8(CX), DX			
  0x445b72		4889152f980900		MOVQ DX, runtime.memstats+5960(SB)	
		mp.mcache.local_scan = 0
  0x445b79		488b8860010000		MOVQ 0x160(AX), CX	
  0x445b80		48c7410800000000	MOVQ $0x0, 0x8(CX)	
		memstats.tinyallocs += uint64(mp.mcache.local_tinyallocs)
  0x445b88		488b8860010000		MOVQ 0x160(AX), CX			
  0x445b8f		488b15f2970900		MOVQ runtime.memstats+5928(SB), DX	
  0x445b96		48035120		ADDQ 0x20(CX), DX			
  0x445b9a		488915e7970900		MOVQ DX, runtime.memstats+5928(SB)	
		mp.mcache.local_tinyallocs = 0
  0x445ba1		488b8060010000		MOVQ 0x160(AX), AX	
  0x445ba8		48c7402000000000	MOVQ $0x0, 0x20(AX)	
	systemstack(func() {
  0x445bb0		0fb6442427		MOVZX 0x27(SP), AX	
  0x445bb5		3c00			CMPL $0x0, AL		
		if large {
  0x445bb7		7407			JE 0x445bc0		
			memstats.heap_objects--
  0x445bb9		48ff0df8800900		DECQ runtime.memstats+88(SB)	
		if gcBlackenEnabled != 0 {
  0x445bc0		833d0971090000		CMPL $0x0, runtime.gcBlackenEnabled(SB)	
  0x445bc7		7540			JNE 0x445c09				
		h.freeSpanLocked(s, true, true, 0)
  0x445bc9		488b442438		MOVQ 0x38(SP), AX				
  0x445bce		48890424		MOVQ AX, 0(SP)					
  0x445bd2		488b4c2428		MOVQ 0x28(SP), CX				
  0x445bd7		48894c2408		MOVQ CX, 0x8(SP)				
  0x445bdc		66c74424100101		MOVW $0x101, 0x10(SP)				
  0x445be3		48c744241800000000	MOVQ $0x0, 0x18(SP)				
  0x445bec		e84f84fdff		CALL runtime.(*mheap).freeSpanLocked(SB)	
		unlock(&h.lock)
  0x445bf1		488b442438		MOVQ 0x38(SP), AX	
  0x445bf6		48890424		MOVQ AX, 0(SP)		
  0x445bfa		e8912cfcff		CALL runtime.unlock(SB)	
	})
  0x445bff		488b6c2440		MOVQ 0x40(SP), BP	
  0x445c04		4883c448		ADDQ $0x48, SP		
  0x445c08		c3			RET			
			gcController.revise()
  0x445c09		488d0570750900		LEAQ runtime.gcController(SB), AX		
  0x445c10		48890424		MOVQ AX, 0(SP)					
  0x445c14		e877c7fcff		CALL runtime.(*gcControllerState).revise(SB)	
  0x445c19		ebae			JMP 0x445bc9					
	systemstack(func() {
  0x445c1b		e8c01b0000		CALL runtime.morestack(SB)		
  0x445c20		e9dbfeffff		JMP runtime.(*mheap).freeSpan.func1(SB)	

TEXT runtime.mProf_Malloc.func1(SB) /usr/local/go/src/runtime/mprof.go
	systemstack(func() {
  0x445c30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445c39		483b6110		CMPQ 0x10(CX), SP	
  0x445c3d		762e			JBE 0x445c6d		
  0x445c3f		4883ec18		SUBQ $0x18, SP		
  0x445c43		48896c2410		MOVQ BP, 0x10(SP)	
  0x445c48		488d6c2410		LEAQ 0x10(SP), BP	
  0x445c4d		488b4210		MOVQ 0x10(DX), AX	
  0x445c51		488b4a08		MOVQ 0x8(DX), CX	
		setprofilebucket(p, b)
  0x445c55		48890c24		MOVQ CX, 0(SP)				
  0x445c59		4889442408		MOVQ AX, 0x8(SP)			
  0x445c5e		e83d92fdff		CALL runtime.setprofilebucket(SB)	
	})
  0x445c63		488b6c2410		MOVQ 0x10(SP), BP	
  0x445c68		4883c418		ADDQ $0x18, SP		
  0x445c6c		c3			RET			
	systemstack(func() {
  0x445c6d		e86e1b0000		CALL runtime.morestack(SB)		
  0x445c72		ebbc			JMP runtime.mProf_Malloc.func1(SB)	

TEXT runtime.tracealloc.func1(SB) /usr/local/go/src/runtime/mprof.go
		systemstack(func() {
  0x445c80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445c89		483b6110		CMPQ 0x10(CX), SP	
  0x445c8d		7640			JBE 0x445ccf		
  0x445c8f		4883ec28		SUBQ $0x28, SP		
  0x445c93		48896c2420		MOVQ BP, 0x20(SP)	
  0x445c98		488d6c2420		LEAQ 0x20(SP), BP	
  0x445c9d		488b4210		MOVQ 0x10(DX), AX	
  0x445ca1		488b4a18		MOVQ 0x18(DX), CX	
  0x445ca5		488b5208		MOVQ 0x8(DX), DX	
			traceback(pc, sp, 0, gp)
  0x445ca9		48891424		MOVQ DX, 0(SP)			
  0x445cad		4889442408		MOVQ AX, 0x8(SP)		
  0x445cb2		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x445cbb		48894c2418		MOVQ CX, 0x18(SP)		
  0x445cc0		e8eb9effff		CALL runtime.traceback(SB)	
		})
  0x445cc5		488b6c2420		MOVQ 0x20(SP), BP	
  0x445cca		4883c428		ADDQ $0x28, SP		
  0x445cce		c3			RET			
		systemstack(func() {
  0x445ccf		e80c1b0000		CALL runtime.morestack(SB)		
  0x445cd4		ebaa			JMP runtime.tracealloc.func1(SB)	

TEXT runtime.tracefree.func1(SB) /usr/local/go/src/runtime/mprof.go
	systemstack(func() {
  0x445ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445ce9		483b6110		CMPQ 0x10(CX), SP	
  0x445ced		7640			JBE 0x445d2f		
  0x445cef		4883ec28		SUBQ $0x28, SP		
  0x445cf3		48896c2420		MOVQ BP, 0x20(SP)	
  0x445cf8		488d6c2420		LEAQ 0x20(SP), BP	
  0x445cfd		488b4210		MOVQ 0x10(DX), AX	
  0x445d01		488b4a18		MOVQ 0x18(DX), CX	
  0x445d05		488b5208		MOVQ 0x8(DX), DX	
		traceback(pc, sp, 0, gp)
  0x445d09		48891424		MOVQ DX, 0(SP)			
  0x445d0d		4889442408		MOVQ AX, 0x8(SP)		
  0x445d12		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x445d1b		48894c2418		MOVQ CX, 0x18(SP)		
  0x445d20		e88b9effff		CALL runtime.traceback(SB)	
	})
  0x445d25		488b6c2420		MOVQ 0x20(SP), BP	
  0x445d2a		4883c428		ADDQ $0x28, SP		
  0x445d2e		c3			RET			
	systemstack(func() {
  0x445d2f		e8ac1a0000		CALL runtime.morestack(SB)	
  0x445d34		ebaa			JMP runtime.tracefree.func1(SB)	

TEXT runtime.wbBufFlush.func1(SB) /usr/local/go/src/runtime/mwbbuf.go
	systemstack(func() {
  0x445d40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445d49		483b6110		CMPQ 0x10(CX), SP	
  0x445d4d		7636			JBE 0x445d85		
  0x445d4f		4883ec10		SUBQ $0x10, SP		
  0x445d53		48896c2408		MOVQ BP, 0x8(SP)	
  0x445d58		488d6c2408		LEAQ 0x8(SP), BP	
			wbBufFlush1(getg().m.p.ptr())
  0x445d5d		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX		
  0x445d66		488b4030		MOVQ 0x30(AX), AX		
  0x445d6a		488b80d0000000		MOVQ 0xd0(AX), AX		
  0x445d71		90			NOPL				
  0x445d72		48890424		MOVQ AX, 0(SP)			
  0x445d76		e875affdff		CALL runtime.wbBufFlush1(SB)	
  0x445d7b		488b6c2408		MOVQ 0x8(SP), BP		
  0x445d80		4883c410		ADDQ $0x10, SP			
  0x445d84		c3			RET				
	systemstack(func() {
  0x445d85		e8561a0000		CALL runtime.morestack(SB)		
  0x445d8a		ebb4			JMP runtime.wbBufFlush.func1(SB)	

TEXT runtime.futexwakeup.func1(SB) /usr/local/go/src/runtime/os_linux.go
	systemstack(func() {
  0x445d90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445d99		483b6110		CMPQ 0x10(CX), SP	
  0x445d9d		0f8687000000		JBE 0x445e2a		
  0x445da3		4883ec28		SUBQ $0x28, SP		
  0x445da7		48896c2420		MOVQ BP, 0x20(SP)	
  0x445dac		488d6c2420		LEAQ 0x20(SP), BP	
  0x445db1		48634210		MOVSXD 0x10(DX), AX	
  0x445db5		4889442410		MOVQ AX, 0x10(SP)	
  0x445dba		488b4a08		MOVQ 0x8(DX), CX	
  0x445dbe		48894c2418		MOVQ CX, 0x18(SP)	
		print("futexwakeup addr=", addr, " returned ", ret, "\n")
  0x445dc3		e8f8e0fdff		CALL runtime.printlock(SB)	
  0x445dc8		488d05b1a30200		LEAQ 0x2a3b1(IP), AX		
  0x445dcf		48890424		MOVQ AX, 0(SP)			
  0x445dd3		48c744240811000000	MOVQ $0x11, 0x8(SP)		
  0x445ddc		e80feafdff		CALL runtime.printstring(SB)	
  0x445de1		488b442418		MOVQ 0x18(SP), AX		
  0x445de6		48890424		MOVQ AX, 0(SP)			
  0x445dea		e8c1e9fdff		CALL runtime.printpointer(SB)	
  0x445def		488d0530990200		LEAQ 0x29930(IP), AX		
  0x445df6		48890424		MOVQ AX, 0(SP)			
  0x445dfa		48c74424080a000000	MOVQ $0xa, 0x8(SP)		
  0x445e03		e8e8e9fdff		CALL runtime.printstring(SB)	
  0x445e08		488b442410		MOVQ 0x10(SP), AX		
  0x445e0d		48890424		MOVQ AX, 0(SP)			
  0x445e11		e82ae8fdff		CALL runtime.printint(SB)	
  0x445e16		e835e3fdff		CALL runtime.printnl(SB)	
  0x445e1b		e820e1fdff		CALL runtime.printunlock(SB)	
	})
  0x445e20		488b6c2420		MOVQ 0x20(SP), BP	
  0x445e25		4883c428		ADDQ $0x28, SP		
  0x445e29		c3			RET			
	systemstack(func() {
  0x445e2a		e8b1190000		CALL runtime.morestack(SB)		
  0x445e2f		e95cffffff		JMP runtime.futexwakeup.func1(SB)	

TEXT runtime.sysSigaction.func1(SB) /usr/local/go/src/runtime/os_linux.go
			systemstack(func() {
  0x445e40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445e49		483b6110		CMPQ 0x10(CX), SP	
  0x445e4d		7629			JBE 0x445e78		
  0x445e4f		4883ec18		SUBQ $0x18, SP		
  0x445e53		48896c2410		MOVQ BP, 0x10(SP)	
  0x445e58		488d6c2410		LEAQ 0x10(SP), BP	
				throw("sigaction failed")
  0x445e5d		488d0563a20200		LEAQ 0x2a263(IP), AX	
  0x445e64		48890424		MOVQ AX, 0(SP)		
  0x445e68		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x445e71		e80ad6fdff		CALL runtime.throw(SB)	
  0x445e76		0f0b			UD2			
			systemstack(func() {
  0x445e78		e8031a0000		CALL runtime.morestack_noctxt(SB)	
  0x445e7d		ebc1			JMP runtime.sysSigaction.func1(SB)	

TEXT runtime.newdefer.func1(SB) /usr/local/go/src/runtime/panic.go
			systemstack(func() {
  0x445e80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x445e89		483b6110		CMPQ 0x10(CX), SP	
  0x445e8d		0f86a8010000		JBE 0x44603b		
  0x445e93		4883ec70		SUBQ $0x70, SP		
  0x445e97		48896c2468		MOVQ BP, 0x68(SP)	
  0x445e9c		488d6c2468		LEAQ 0x68(SP), BP	
  0x445ea1		488b4210		MOVQ 0x10(DX), AX	
  0x445ea5		4889442440		MOVQ AX, 0x40(SP)	
  0x445eaa		488b4a08		MOVQ 0x8(DX), CX	
  0x445eae		48894c2450		MOVQ CX, 0x50(SP)	
				lock(&sched.deferlock)
  0x445eb3		488d15a6be0700		LEAQ runtime.sched+192(SB), DX	
  0x445eba		48891424		MOVQ DX, 0(SP)			
  0x445ebe		e81d28fcff		CALL runtime.lock(SB)		
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x445ec3		488b442450		MOVQ 0x50(SP), AX		
  0x445ec8		488b4c2440		MOVQ 0x40(SP), CX		
  0x445ecd		8400			TESTB AL, 0(AX)			
  0x445ecf		4883f905		CMPQ $0x5, CX			
  0x445ed3		0f835b010000		JAE 0x446034			
  0x445ed9		488d1449		LEAQ 0(CX)(CX*2), DX		
  0x445edd		488d1cd0		LEAQ 0(AX)(DX*8), BX		
  0x445ee1		488d5b58		LEAQ 0x58(BX), BX		
  0x445ee5		488b74d068		MOVQ 0x68(AX)(DX*8), SI		
  0x445eea		48d1ee			SHRQ $0x1, SI			
  0x445eed		48397308		CMPQ SI, 0x8(BX)		
  0x445ef1		0f8d23010000		JGE 0x44601a			
  0x445ef7		488d356abe0700		LEAQ runtime.sched+200(SB), SI	
  0x445efe		4c8b04ce		MOVQ 0(SI)(CX*8), R8		
  0x445f02		4d85c0			TESTQ R8, R8			
  0x445f05		0f840f010000		JE 0x44601a			
					sched.deferpool[sc] = d.link
  0x445f0b		4d8b4828		MOVQ 0x28(R8), R9			
  0x445f0f		833d0a6f090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x445f16		0f85dc000000		JNE 0x445ff8				
  0x445f1c		4c890cce		MOVQ R9, 0(SI)(CX*8)			
					d.link = nil
  0x445f20		49c7402800000000	MOVQ $0x0, 0x28(R8)	
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x445f28		488b74d068		MOVQ 0x68(AX)(DX*8), SI			
  0x445f2d		4c8b4cd060		MOVQ 0x60(AX)(DX*8), R9			
  0x445f32		4c8b54d058		MOVQ 0x58(AX)(DX*8), R10		
  0x445f37		4d8d5901		LEAQ 0x1(R9), R11			
  0x445f3b		4939f3			CMPQ SI, R11				
  0x445f3e		7732			JA 0x445f72				
  0x445f40		498d5901		LEAQ 0x1(R9), BX			
  0x445f44		48895cd060		MOVQ BX, 0x60(AX)(DX*8)			
  0x445f49		4b8d3cca		LEAQ 0(R10)(R9*8), DI			
  0x445f4d		833dcc6e090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x445f54		7509			JNE 0x445f5f				
  0x445f56		4f8904ca		MOVQ R8, 0(R10)(R9*8)			
  0x445f5a		e96effffff		JMP 0x445ecd				
			systemstack(func() {
  0x445f5f		4889c2			MOVQ AX, DX		
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x445f62		4c89c0			MOVQ R8, AX			
  0x445f65		e816370000		CALL runtime.gcWriteBarrier(SB)	
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x445f6a		4889d0			MOVQ DX, AX		
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x445f6d		e95bffffff		JMP 0x445ecd		
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x445f72		48895c2460		MOVQ BX, 0x60(SP)	
  0x445f77		4c89442458		MOVQ R8, 0x58(SP)	
  0x445f7c		4889542448		MOVQ DX, 0x48(SP)	
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x445f81		488d0538150100		LEAQ 0x11538(IP), AX			
  0x445f88		48890424		MOVQ AX, 0(SP)				
  0x445f8c		4c89542408		MOVQ R10, 0x8(SP)			
  0x445f91		4c894c2410		MOVQ R9, 0x10(SP)			
  0x445f96		4889742418		MOVQ SI, 0x18(SP)			
  0x445f9b		4c895c2420		MOVQ R11, 0x20(SP)			
  0x445fa0		e8dbfdfeff		CALL runtime.growslice(SB)		
  0x445fa5		488b442428		MOVQ 0x28(SP), AX			
  0x445faa		488b4c2430		MOVQ 0x30(SP), CX			
  0x445faf		488b542438		MOVQ 0x38(SP), DX			
  0x445fb4		488b5c2448		MOVQ 0x48(SP), BX			
  0x445fb9		488b742450		MOVQ 0x50(SP), SI			
  0x445fbe		488954de68		MOVQ DX, 0x68(SI)(BX*8)			
  0x445fc3		833d566e090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x445fca		7520			JNE 0x445fec				
  0x445fcc		488944de58		MOVQ AX, 0x58(SI)(BX*8)			
  0x445fd1		4889da			MOVQ BX, DX				
  0x445fd4		4c8b442458		MOVQ 0x58(SP), R8			
  0x445fd9		4989c9			MOVQ CX, R9				
  0x445fdc		4989c2			MOVQ AX, R10				
  0x445fdf		4889f0			MOVQ SI, AX				
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x445fe2		488b4c2440		MOVQ 0x40(SP), CX	
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x445fe7		e954ffffff		JMP 0x445f40			
  0x445fec		488b7c2460		MOVQ 0x60(SP), DI		
  0x445ff1		e88a360000		CALL runtime.gcWriteBarrier(SB)	
  0x445ff6		ebd9			JMP 0x445fd1			
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x445ff8		488d3cce		LEAQ 0(SI)(CX*8), DI	
			systemstack(func() {
  0x445ffc		4889c6			MOVQ AX, SI		
					sched.deferpool[sc] = d.link
  0x445fff		4c89c8			MOVQ R9, AX			
  0x446002		e879360000		CALL runtime.gcWriteBarrier(SB)	
  0x446007		498d7828		LEAQ 0x28(R8), DI		
					d.link = nil
  0x44600b		31c0			XORL AX, AX			
  0x44600d		e86e360000		CALL runtime.gcWriteBarrier(SB)	
					pp.deferpool[sc] = append(pp.deferpool[sc], d)
  0x446012		4889f0			MOVQ SI, AX		
					sched.deferpool[sc] = d.link
  0x446015		e90effffff		JMP 0x445f28		
				unlock(&sched.deferlock)
  0x44601a		488d053fbd0700		LEAQ runtime.sched+192(SB), AX	
  0x446021		48890424		MOVQ AX, 0(SP)			
  0x446025		e86628fcff		CALL runtime.unlock(SB)		
			})
  0x44602a		488b6c2468		MOVQ 0x68(SP), BP	
  0x44602f		4883c470		ADDQ $0x70, SP		
  0x446033		c3			RET			
				for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
  0x446034		e8e7befdff		CALL runtime.panicindex(SB)	
  0x446039		0f0b			UD2				
			systemstack(func() {
  0x44603b		e8a0170000		CALL runtime.morestack(SB)	
  0x446040		e93bfeffff		JMP runtime.newdefer.func1(SB)	

TEXT runtime.newdefer.func2(SB) /usr/local/go/src/runtime/panic.go
		systemstack(func() {
  0x446050		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446059		483b6110		CMPQ 0x10(CX), SP	
  0x44605d		0f8629010000		JBE 0x44618c		
  0x446063		4883ec30		SUBQ $0x30, SP		
  0x446067		48896c2428		MOVQ BP, 0x28(SP)	
  0x44606c		488d6c2428		LEAQ 0x28(SP), BP	
  0x446071		488b4210		MOVQ 0x10(DX), AX	
  0x446075		48634a08		MOVSXD 0x8(DX), CX	
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x446079		90			NOPL			
	if siz <= minDeferArgs {
  0x44607a		4885c9			TESTQ CX, CX		
  0x44607d		0f87f2000000		JA 0x446175		
  0x446083		b930000000		MOVL $0x30, CX		
		systemstack(func() {
  0x446088		4889442420		MOVQ AX, 0x20(SP)	
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x44608d		90			NOPL			
	if size < _MaxSmallSize {
  0x44608e		4881f900800000		CMPQ $0x8000, CX	
  0x446095		0f83b6000000		JAE 0x446151		
		if size <= smallSizeMax-8 {
  0x44609b		4881f9f8030000		CMPQ $0x3f8, CX		
  0x4460a2		777b			JA 0x44611f		
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x4460a4		4883c107		ADDQ $0x7, CX				
  0x4460a8		48c1e903		SHRQ $0x3, CX				
  0x4460ac		4881f981000000		CMPQ $0x81, CX				
  0x4460b3		0f83cc000000		JAE 0x446185				
  0x4460b9		488d1580900700		LEAQ runtime.size_to_class8(SB), DX	
  0x4460c0		0fb60c11		MOVZX 0(CX)(DX*1), CX			
  0x4460c4		4883f943		CMPQ $0x43, CX				
  0x4460c8		0f83b7000000		JAE 0x446185				
  0x4460ce		488d150b910700		LEAQ runtime.class_to_size(SB), DX	
  0x4460d5		0fb70c4a		MOVZX 0(DX)(CX*2), CX			
			d = (*_defer)(mallocgc(total, deferType, true))
  0x4460d9		48890c24		MOVQ CX, 0(SP)				
  0x4460dd		488b0564b80700		MOVQ runtime.deferType(SB), AX		
  0x4460e4		4889442408		MOVQ AX, 0x8(SP)			
  0x4460e9		c644241001		MOVB $0x1, 0x10(SP)			
  0x4460ee		e81d3bfcff		CALL runtime.mallocgc(SB)		
  0x4460f3		488b442418		MOVQ 0x18(SP), AX			
  0x4460f8		833d216d090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4460ff		7512			JNE 0x446113				
  0x446101		488b4c2420		MOVQ 0x20(SP), CX			
  0x446106		488901			MOVQ AX, 0(CX)				
		})
  0x446109		488b6c2428		MOVQ 0x28(SP), BP	
  0x44610e		4883c430		ADDQ $0x30, SP		
  0x446112		c3			RET			
			d = (*_defer)(mallocgc(total, deferType, true))
  0x446113		488b7c2420		MOVQ 0x20(SP), DI		
  0x446118		e863350000		CALL runtime.gcWriteBarrier(SB)	
  0x44611d		ebea			JMP 0x446109			
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x44611f		4881c17ffcffff		ADDQ $-0x381, CX			
  0x446126		48c1e907		SHRQ $0x7, CX				
  0x44612a		4881f9f9000000		CMPQ $0xf9, CX				
  0x446131		734b			JAE 0x44617e				
  0x446133		488d1546910700		LEAQ runtime.size_to_class128(SB), DX	
  0x44613a		0fb60c0a		MOVZX 0(DX)(CX*1), CX			
  0x44613e		4883f943		CMPQ $0x43, CX				
  0x446142		733a			JAE 0x44617e				
  0x446144		488d1595900700		LEAQ runtime.class_to_size(SB), DX	
  0x44614b		0fb70c4a		MOVZX 0(DX)(CX*2), CX			
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x44614f		eb88			JMP 0x4460d9		
	if size+_PageSize < size {
  0x446151		488d9100200000		LEAQ 0x2000(CX), DX	
  0x446158		4839ca			CMPQ CX, DX		
  0x44615b		0f8278ffffff		JB 0x4460d9		
	return round(size, _PageSize)
  0x446161		90			NOPL			
	return (n + a - 1) &^ (a - 1)
  0x446162		4881c1ff1f0000		ADDQ $0x1fff, CX	
  0x446169		4881e100e0ffff		ANDQ $-0x2000, CX	
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x446170		e964ffffff		JMP 0x4460d9		
	return deferHeaderSize + siz
  0x446175		4883c130		ADDQ $0x30, CX		
			total := roundupsize(totaldefersize(uintptr(siz)))
  0x446179		e90affffff		JMP 0x446088		
			return uintptr(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]])
  0x44617e		e89dbdfdff		CALL runtime.panicindex(SB)	
  0x446183		0f0b			UD2				
			return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
  0x446185		e896bdfdff		CALL runtime.panicindex(SB)	
  0x44618a		0f0b			UD2				
		systemstack(func() {
  0x44618c		e84f160000		CALL runtime.morestack(SB)	
  0x446191		e9bafeffff		JMP runtime.newdefer.func2(SB)	

TEXT runtime.freedefer.func1(SB) /usr/local/go/src/runtime/panic.go
		systemstack(func() {
  0x4461a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4461a9		483b6110		CMPQ 0x10(CX), SP	
  0x4461ad		0f866a010000		JBE 0x44631d		
  0x4461b3		4883ec28		SUBQ $0x28, SP		
  0x4461b7		48896c2420		MOVQ BP, 0x20(SP)	
  0x4461bc		488d6c2420		LEAQ 0x20(SP), BP	
  0x4461c1		488b4a10		MOVQ 0x10(DX), CX	
  0x4461c5		488b5208		MOVQ 0x8(DX), DX	
  0x4461c9		31c0			XORL AX, AX		
  0x4461cb		31db			XORL BX, BX		
			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
  0x4461cd		eb03			JMP 0x4461d2		
			last.link = sched.deferpool[sc]
  0x4461cf		4c89d8			MOVQ R11, AX		
			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
  0x4461d2		8402			TESTB AL, 0(DX)			
  0x4461d4		4883f905		CMPQ $0x5, CX			
  0x4461d8		0f8338010000		JAE 0x446316			
  0x4461de		488d3449		LEAQ 0(CX)(CX*2), SI		
  0x4461e2		4c8b44f260		MOVQ 0x60(DX)(SI*8), R8		
  0x4461e7		4c8b4cf258		MOVQ 0x58(DX)(SI*8), R9		
  0x4461ec		4c8b54f268		MOVQ 0x68(DX)(SI*8), R10	
  0x4461f1		49d1ea			SHRQ $0x1, R10			
  0x4461f4		4d39d0			CMPQ R10, R8			
  0x4461f7		0f8e89000000		JLE 0x446286			
				d := pp.deferpool[sc][n-1]
  0x4461fd		4d8d50ff		LEAQ -0x1(R8), R10		
  0x446201		4d39c2			CMPQ R8, R10			
  0x446204		0f8305010000		JAE 0x44630f			
  0x44620a		4f8b5cc1f8		MOVQ -0x8(R9)(R8*8), R11	
  0x44620f		4b8d3cc1		LEAQ 0(R9)(R8*8), DI		
  0x446213		488d7ff8		LEAQ -0x8(DI), DI		
				pp.deferpool[sc][n-1] = nil
  0x446217		833d026c090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44621e		7557			JNE 0x446277				
  0x446220		4bc744c1f800000000	MOVQ $0x0, -0x8(R9)(R8*8)		
				pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x446229		4c8b44f268		MOVQ 0x68(DX)(SI*8), R8		
  0x44622e		4d85d2			TESTQ R10, R10			
  0x446231		0f8cd1000000		JL 0x446308			
  0x446237		4d39c2			CMPQ R8, R10			
  0x44623a		0f87c8000000		JA 0x446308			
  0x446240		4c8954f260		MOVQ R10, 0x60(DX)(SI*8)	
				if first == nil {
  0x446245		4885db			TESTQ BX, BX		
  0x446248		7425			JE 0x44626f		
					last.link = d
  0x44624a		8400			TESTB AL, 0(AX)				
  0x44624c		833dcd6b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x446253		7509			JNE 0x44625e				
  0x446255		4c895828		MOVQ R11, 0x28(AX)			
  0x446259		e971ffffff		JMP 0x4461cf				
  0x44625e		488d7828		LEAQ 0x28(AX), DI			
  0x446262		4c89d8			MOVQ R11, AX				
  0x446265		e816340000		CALL runtime.gcWriteBarrier(SB)		
  0x44626a		e960ffffff		JMP 0x4461cf				
			sched.deferpool[sc] = first
  0x44626f		4c89db			MOVQ R11, BX		
					first = d
  0x446272		e958ffffff		JMP 0x4461cf		
			last.link = sched.deferpool[sc]
  0x446277		4989c0			MOVQ AX, R8		
				pp.deferpool[sc][n-1] = nil
  0x44627a		31c0			XORL AX, AX			
  0x44627c		e8ff330000		CALL runtime.gcWriteBarrier(SB)	
					last.link = d
  0x446281		4c89c0			MOVQ R8, AX		
				pp.deferpool[sc][n-1] = nil
  0x446284		eba3			JMP 0x446229		
		systemstack(func() {
  0x446286		48894c2408		MOVQ CX, 0x8(SP)	
			sched.deferpool[sc] = first
  0x44628b		48895c2418		MOVQ BX, 0x18(SP)	
			last.link = sched.deferpool[sc]
  0x446290		4889442410		MOVQ AX, 0x10(SP)	
			lock(&sched.deferlock)
  0x446295		488d05c4ba0700		LEAQ runtime.sched+192(SB), AX	
  0x44629c		48890424		MOVQ AX, 0(SP)			
  0x4462a0		e83b24fcff		CALL runtime.lock(SB)		
			last.link = sched.deferpool[sc]
  0x4462a5		488b442410		MOVQ 0x10(SP), AX			
  0x4462aa		8400			TESTB AL, 0(AX)				
  0x4462ac		488b4c2408		MOVQ 0x8(SP), CX			
  0x4462b1		488d15b0ba0700		LEAQ runtime.sched+200(SB), DX		
  0x4462b8		488b1cca		MOVQ 0(DX)(CX*8), BX			
  0x4462bc		833d5d6b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x4462c3		7527			JNE 0x4462ec				
  0x4462c5		48895828		MOVQ BX, 0x28(AX)			
			sched.deferpool[sc] = first
  0x4462c9		488b442418		MOVQ 0x18(SP), AX	
  0x4462ce		488904ca		MOVQ AX, 0(DX)(CX*8)	
			unlock(&sched.deferlock)
  0x4462d2		488d0587ba0700		LEAQ runtime.sched+192(SB), AX	
  0x4462d9		48890424		MOVQ AX, 0(SP)			
  0x4462dd		e8ae25fcff		CALL runtime.unlock(SB)		
		})
  0x4462e2		488b6c2420		MOVQ 0x20(SP), BP	
  0x4462e7		4883c428		ADDQ $0x28, SP		
  0x4462eb		c3			RET			
			last.link = sched.deferpool[sc]
  0x4462ec		488d7828		LEAQ 0x28(AX), DI		
  0x4462f0		4889d8			MOVQ BX, AX			
  0x4462f3		e888330000		CALL runtime.gcWriteBarrier(SB)	
  0x4462f8		488d3cca		LEAQ 0(DX)(CX*8), DI		
			sched.deferpool[sc] = first
  0x4462fc		488b442418		MOVQ 0x18(SP), AX		
  0x446301		e87a330000		CALL runtime.gcWriteBarrier(SB)	
			last.link = sched.deferpool[sc]
  0x446306		ebca			JMP 0x4462d2		
				pp.deferpool[sc] = pp.deferpool[sc][:n-1]
  0x446308		e843bdfdff		CALL runtime.panicslice(SB)	
  0x44630d		0f0b			UD2				
				d := pp.deferpool[sc][n-1]
  0x44630f		e80cbcfdff		CALL runtime.panicindex(SB)	
  0x446314		0f0b			UD2				
			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
  0x446316		e805bcfdff		CALL runtime.panicindex(SB)	
  0x44631b		0f0b			UD2				
		systemstack(func() {
  0x44631d		e8be140000		CALL runtime.morestack(SB)	
  0x446322		e979feffff		JMP runtime.freedefer.func1(SB)	

TEXT runtime.preprintpanics.func1(SB) /usr/local/go/src/runtime/panic.go
	defer func() {
  0x446330		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446339		483b6110		CMPQ 0x10(CX), SP	
  0x44633d		7649			JBE 0x446388		
  0x44633f		4883ec20		SUBQ $0x20, SP		
  0x446343		48896c2418		MOVQ BP, 0x18(SP)	
  0x446348		488d6c2418		LEAQ 0x18(SP), BP	
		if recover() != nil {
  0x44634d		488d442428		LEAQ 0x28(SP), AX		
  0x446352		48890424		MOVQ AX, 0(SP)			
  0x446356		e8d5d0fdff		CALL runtime.gorecover(SB)	
  0x44635b		48837c240800		CMPQ $0x0, 0x8(SP)		
  0x446361		750a			JNE 0x44636d			
  0x446363		488b6c2418		MOVQ 0x18(SP), BP		
  0x446368		4883c420		ADDQ $0x20, SP			
  0x44636c		c3			RET				
			throw("panic while printing panic value")
  0x44636d		488d05bdbb0200		LEAQ 0x2bbbd(IP), AX	
  0x446374		48890424		MOVQ AX, 0(SP)		
  0x446378		48c744240820000000	MOVQ $0x20, 0x8(SP)	
  0x446381		e8fad0fdff		CALL runtime.throw(SB)	
  0x446386		0f0b			UD2			
	defer func() {
  0x446388		e8f3140000		CALL runtime.morestack_noctxt(SB)	
  0x44638d		eba1			JMP runtime.preprintpanics.func1(SB)	

TEXT runtime.throw.func1(SB) /usr/local/go/src/runtime/panic.go
	systemstack(func() {
  0x446390		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446399		483b6110		CMPQ 0x10(CX), SP	
  0x44639d		766a			JBE 0x446409		
  0x44639f		4883ec28		SUBQ $0x28, SP		
  0x4463a3		48896c2420		MOVQ BP, 0x20(SP)	
  0x4463a8		488d6c2420		LEAQ 0x20(SP), BP	
  0x4463ad		488b4208		MOVQ 0x8(DX), AX	
  0x4463b1		4889442418		MOVQ AX, 0x18(SP)	
  0x4463b6		488b4a10		MOVQ 0x10(DX), CX	
  0x4463ba		48894c2410		MOVQ CX, 0x10(SP)	
		print("fatal error: ", s, "\n")
  0x4463bf		e8fcdafdff		CALL runtime.printlock(SB)	
  0x4463c4		488d05a9980200		LEAQ 0x298a9(IP), AX		
  0x4463cb		48890424		MOVQ AX, 0(SP)			
  0x4463cf		48c74424080d000000	MOVQ $0xd, 0x8(SP)		
  0x4463d8		e813e4fdff		CALL runtime.printstring(SB)	
  0x4463dd		488b442418		MOVQ 0x18(SP), AX		
  0x4463e2		48890424		MOVQ AX, 0(SP)			
  0x4463e6		488b442410		MOVQ 0x10(SP), AX		
  0x4463eb		4889442408		MOVQ AX, 0x8(SP)		
  0x4463f0		e8fbe3fdff		CALL runtime.printstring(SB)	
  0x4463f5		e856ddfdff		CALL runtime.printnl(SB)	
  0x4463fa		e841dbfdff		CALL runtime.printunlock(SB)	
	})
  0x4463ff		488b6c2420		MOVQ 0x20(SP), BP	
  0x446404		4883c428		ADDQ $0x28, SP		
  0x446408		c3			RET			
	systemstack(func() {
  0x446409		e8d2130000		CALL runtime.morestack(SB)	
  0x44640e		eb80			JMP runtime.throw.func1(SB)	

TEXT runtime.fatalthrow.func1(SB) /usr/local/go/src/runtime/panic.go
	systemstack(func() {
  0x446410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446419		483b6110		CMPQ 0x10(CX), SP	
  0x44641d		7674			JBE 0x446493		
  0x44641f		4883ec40		SUBQ $0x40, SP		
  0x446423		48896c2438		MOVQ BP, 0x38(SP)	
  0x446428		488d6c2438		LEAQ 0x38(SP), BP	
  0x44642d		488b4210		MOVQ 0x10(DX), AX	
  0x446431		4889442428		MOVQ AX, 0x28(SP)	
  0x446436		488b4a18		MOVQ 0x18(DX), CX	
  0x44643a		48894c2420		MOVQ CX, 0x20(SP)	
  0x44643f		488b5208		MOVQ 0x8(DX), DX	
  0x446443		4889542430		MOVQ DX, 0x30(SP)	
		startpanic_m()
  0x446448		e843d3fdff		CALL runtime.startpanic_m(SB)	
		if dopanic_m(gp, pc, sp) {
  0x44644d		488b442430		MOVQ 0x30(SP), AX		
  0x446452		48890424		MOVQ AX, 0(SP)			
  0x446456		488b442428		MOVQ 0x28(SP), AX		
  0x44645b		4889442408		MOVQ AX, 0x8(SP)		
  0x446460		488b442420		MOVQ 0x20(SP), AX		
  0x446465		4889442410		MOVQ AX, 0x10(SP)		
  0x44646a		e8c1d4fdff		CALL runtime.dopanic_m(SB)	
  0x44646f		807c241800		CMPB $0x0, 0x18(SP)		
  0x446474		7516			JNE 0x44648c			
		exit(2)
  0x446476		c7042402000000		MOVL $0x2, 0(SP)	
  0x44647d		e89e490000		CALL runtime.exit(SB)	
	})
  0x446482		488b6c2438		MOVQ 0x38(SP), BP	
  0x446487		4883c440		ADDQ $0x40, SP		
  0x44648b		c3			RET			
			crash()
  0x44648c		e82feefeff		CALL runtime.crash(SB)	
  0x446491		ebe3			JMP 0x446476		
	systemstack(func() {
  0x446493		e848130000		CALL runtime.morestack(SB)		
  0x446498		e973ffffff		JMP runtime.fatalthrow.func1(SB)	

TEXT runtime.fatalpanic.func1(SB) /usr/local/go/src/runtime/panic.go
	systemstack(func() {
  0x4464a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4464a9		483b6110		CMPQ 0x10(CX), SP	
  0x4464ad		0f86a3000000		JBE 0x446556		
  0x4464b3		4883ec50		SUBQ $0x50, SP		
  0x4464b7		48896c2448		MOVQ BP, 0x48(SP)	
  0x4464bc		488d6c2448		LEAQ 0x48(SP), BP	
  0x4464c1		488b4210		MOVQ 0x10(DX), AX	
  0x4464c5		4889442438		MOVQ AX, 0x38(SP)	
  0x4464ca		488b4a18		MOVQ 0x18(DX), CX	
  0x4464ce		48894c2428		MOVQ CX, 0x28(SP)	
  0x4464d3		488b5a20		MOVQ 0x20(DX), BX	
  0x4464d7		48895c2420		MOVQ BX, 0x20(SP)	
  0x4464dc		488b7228		MOVQ 0x28(DX), SI	
  0x4464e0		4889742440		MOVQ SI, 0x40(SP)	
  0x4464e5		488b5208		MOVQ 0x8(DX), DX	
  0x4464e9		4889542430		MOVQ DX, 0x30(SP)	
		if startpanic_m() && msgs != nil {
  0x4464ee		e89dd2fdff		CALL runtime.startpanic_m(SB)	
  0x4464f3		803c2400		CMPB $0x0, 0(SP)		
  0x4464f7		740a			JE 0x446503			
  0x4464f9		488b442430		MOVQ 0x30(SP), AX		
  0x4464fe		4885c0			TESTQ AX, AX			
  0x446501		7538			JNE 0x44653b			
		docrash = dopanic_m(gp, pc, sp)
  0x446503		488b442438		MOVQ 0x38(SP), AX		
  0x446508		48890424		MOVQ AX, 0(SP)			
  0x44650c		488b442428		MOVQ 0x28(SP), AX		
  0x446511		4889442408		MOVQ AX, 0x8(SP)		
  0x446516		488b442420		MOVQ 0x20(SP), AX		
  0x44651b		4889442410		MOVQ AX, 0x10(SP)		
  0x446520		e80bd4fdff		CALL runtime.dopanic_m(SB)	
  0x446525		0fb6442418		MOVZX 0x18(SP), AX		
  0x44652a		488b4c2440		MOVQ 0x40(SP), CX		
  0x44652f		8801			MOVB AL, 0(CX)			
	})
  0x446531		488b6c2448		MOVQ 0x48(SP), BP	
  0x446536		4883c450		ADDQ $0x50, SP		
  0x44653a		c3			RET			
			atomic.Xadd(&runningPanicDefers, -1)
  0x44653b		b9ffffffff		MOVL $-0x1, CX				
  0x446540		488d15b5670900		LEAQ runtime.runningPanicDefers(SB), DX	
  0x446547		f00fc10a		LOCK XADDL CX, 0(DX)			
			printpanics(msgs)
  0x44654b		48890424		MOVQ AX, 0(SP)			
  0x44654f		e85cc8fdff		CALL runtime.printpanics(SB)	
  0x446554		ebad			JMP 0x446503			
	systemstack(func() {
  0x446556		e885120000		CALL runtime.morestack(SB)		
  0x44655b		e940ffffff		JMP runtime.fatalpanic.func1(SB)	

TEXT runtime.fatalpanic.func2(SB) /usr/local/go/src/runtime/panic.go
	systemstack(func() {
  0x446560		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446569		483b6110		CMPQ 0x10(CX), SP	
  0x44656d		7624			JBE 0x446593		
  0x44656f		4883ec10		SUBQ $0x10, SP		
  0x446573		48896c2408		MOVQ BP, 0x8(SP)	
  0x446578		488d6c2408		LEAQ 0x8(SP), BP	
		exit(2)
  0x44657d		c7042402000000		MOVL $0x2, 0(SP)	
  0x446584		e897480000		CALL runtime.exit(SB)	
	})
  0x446589		488b6c2408		MOVQ 0x8(SP), BP	
  0x44658e		4883c410		ADDQ $0x10, SP		
  0x446592		c3			RET			
	systemstack(func() {
  0x446593		e8e8120000		CALL runtime.morestack_noctxt(SB)	
  0x446598		ebc6			JMP runtime.fatalpanic.func2(SB)	

TEXT runtime.hexdumpWords.func1(SB) /usr/local/go/src/runtime/print.go
	p1 := func(x uintptr) {
  0x4465a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4465a9		483b6110		CMPQ 0x10(CX), SP	
  0x4465ad		767a			JBE 0x446629		
  0x4465af		4883ec30		SUBQ $0x30, SP		
  0x4465b3		48896c2428		MOVQ BP, 0x28(SP)	
  0x4465b8		488d6c2428		LEAQ 0x28(SP), BP	
		var buf [2 * sys.PtrSize]byte
  0x4465bd		0f57c0			XORPS X0, X0		
  0x4465c0		0f11442418		MOVUPS X0, 0x18(SP)	
		for i := len(buf) - 1; i >= 0; i-- {
  0x4465c5		488b442438		MOVQ 0x38(SP), AX	
  0x4465ca		b90f000000		MOVL $0xf, CX		
  0x4465cf		eb0a			JMP 0x4465db		
  0x4465d1		48ffc9			DECQ CX			
			x >>= 4
  0x4465d4		48c1ea04		SHRQ $0x4, DX		
			if x&0xF < 10 {
  0x4465d8		4889d0			MOVQ DX, AX		
		for i := len(buf) - 1; i >= 0; i-- {
  0x4465db		4885c9			TESTQ CX, CX		
  0x4465de		7c1f			JL 0x4465ff		
			if x&0xF < 10 {
  0x4465e0		4889c2			MOVQ AX, DX		
  0x4465e3		4883e00f		ANDQ $0xf, AX		
  0x4465e7		4883f80a		CMPQ $0xa, AX		
  0x4465eb		7309			JAE 0x4465f6		
				buf[i] = byte(x&0xF) + '0'
  0x4465ed		83c030			ADDL $0x30, AX		
  0x4465f0		88440c18		MOVB AL, 0x18(SP)(CX*1)	
  0x4465f4		ebdb			JMP 0x4465d1		
				buf[i] = byte(x&0xF) - 10 + 'a'
  0x4465f6		83c057			ADDL $0x57, AX		
  0x4465f9		88440c18		MOVB AL, 0x18(SP)(CX*1)	
  0x4465fd		ebd2			JMP 0x4465d1		
		gwrite(buf[:])
  0x4465ff		488d442418		LEAQ 0x18(SP), AX	
  0x446604		48890424		MOVQ AX, 0(SP)		
  0x446608		48c744240810000000	MOVQ $0x10, 0x8(SP)	
  0x446611		48c744241010000000	MOVQ $0x10, 0x10(SP)	
  0x44661a		e891d9fdff		CALL runtime.gwrite(SB)	
	}
  0x44661f		488b6c2428		MOVQ 0x28(SP), BP	
  0x446624		4883c430		ADDQ $0x30, SP		
  0x446628		c3			RET			
	p1 := func(x uintptr) {
  0x446629		e852120000		CALL runtime.morestack_noctxt(SB)	
  0x44662e		e96dffffff		JMP runtime.hexdumpWords.func1(SB)	

TEXT runtime.main.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446640		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446649		483b6110		CMPQ 0x10(CX), SP	
  0x44664d		7631			JBE 0x446680		
  0x44664f		4883ec18		SUBQ $0x18, SP		
  0x446653		48896c2410		MOVQ BP, 0x10(SP)	
  0x446658		488d6c2410		LEAQ 0x10(SP), BP	
			newm(sysmon, nil)
  0x44665d		488d054cd30200		LEAQ 0x2d34c(IP), AX	
  0x446664		48890424		MOVQ AX, 0(SP)		
  0x446668		48c744240800000000	MOVQ $0x0, 0x8(SP)	
  0x446671		e8fa23feff		CALL runtime.newm(SB)	
		})
  0x446676		488b6c2410		MOVQ 0x10(SP), BP	
  0x44667b		4883c418		ADDQ $0x18, SP		
  0x44667f		c3			RET			
		systemstack(func() {
  0x446680		e8fb110000		CALL runtime.morestack_noctxt(SB)	
  0x446685		ebb9			JMP runtime.main.func1(SB)		

TEXT runtime.main.func2(SB) /usr/local/go/src/runtime/proc.go
	defer func() {
  0x446690		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446699		483b6110		CMPQ 0x10(CX), SP	
  0x44669d		7626			JBE 0x4466c5		
  0x44669f		4883ec08		SUBQ $0x8, SP		
  0x4466a3		48892c24		MOVQ BP, 0(SP)		
  0x4466a7		488d2c24		LEAQ 0(SP), BP		
		if needUnlock {
  0x4466ab		488b442410		MOVQ 0x10(SP), AX	
  0x4466b0		803800			CMPB $0x0, 0(AX)	
  0x4466b3		7509			JNE 0x4466be		
  0x4466b5		488b2c24		MOVQ 0(SP), BP		
  0x4466b9		4883c408		ADDQ $0x8, SP		
  0x4466bd		c3			RET			
			unlockOSThread()
  0x4466be		e83d6bfeff		CALL runtime.unlockOSThread(SB)	
  0x4466c3		ebf0			JMP 0x4466b5			
	defer func() {
  0x4466c5		e8b6110000		CALL runtime.morestack_noctxt(SB)	
  0x4466ca		ebc4			JMP runtime.main.func2(SB)		

TEXT runtime.goready.func1(SB) /usr/local/go/src/runtime/proc.go
	systemstack(func() {
  0x4466d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4466d9		483b6110		CMPQ 0x10(CX), SP	
  0x4466dd		7633			JBE 0x446712		
  0x4466df		4883ec20		SUBQ $0x20, SP		
  0x4466e3		48896c2418		MOVQ BP, 0x18(SP)	
  0x4466e8		488d6c2418		LEAQ 0x18(SP), BP	
  0x4466ed		488b4210		MOVQ 0x10(DX), AX	
  0x4466f1		488b4a08		MOVQ 0x8(DX), CX	
		ready(gp, traceskip, true)
  0x4466f5		48890c24		MOVQ CX, 0(SP)		
  0x4466f9		4889442408		MOVQ AX, 0x8(SP)	
  0x4466fe		c644241001		MOVB $0x1, 0x10(SP)	
  0x446703		e8e8fcfdff		CALL runtime.ready(SB)	
	})
  0x446708		488b6c2418		MOVQ 0x18(SP), BP	
  0x44670d		4883c420		ADDQ $0x20, SP		
  0x446711		c3			RET			
	systemstack(func() {
  0x446712		e8c9100000		CALL runtime.morestack(SB)	
  0x446717		ebb7			JMP runtime.goready.func1(SB)	

TEXT runtime.casgstatus.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446720		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446729		483b6110		CMPQ 0x10(CX), SP	
  0x44672d		0f8696000000		JBE 0x4467c9		
  0x446733		4883ec28		SUBQ $0x28, SP		
  0x446737		48896c2420		MOVQ BP, 0x20(SP)	
  0x44673c		488d6c2420		LEAQ 0x20(SP), BP	
  0x446741		8b420c			MOVL 0xc(DX), AX	
  0x446744		4889442418		MOVQ AX, 0x18(SP)	
  0x446749		8b4a08			MOVL 0x8(DX), CX	
  0x44674c		48894c2410		MOVQ CX, 0x10(SP)	
			print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n")
  0x446751		e86ad7fdff		CALL runtime.printlock(SB)	
  0x446756		488d058db00200		LEAQ 0x2b08d(IP), AX		
  0x44675d		48890424		MOVQ AX, 0(SP)			
  0x446761		48c74424081c000000	MOVQ $0x1c, 0x8(SP)		
  0x44676a		e881e0fdff		CALL runtime.printstring(SB)	
  0x44676f		488b442410		MOVQ 0x10(SP), AX		
  0x446774		48890424		MOVQ AX, 0(SP)			
  0x446778		e833dffdff		CALL runtime.printhex(SB)	
  0x44677d		488d05848c0200		LEAQ 0x28c84(IP), AX		
  0x446784		48890424		MOVQ AX, 0(SP)			
  0x446788		48c744240808000000	MOVQ $0x8, 0x8(SP)		
  0x446791		e85ae0fdff		CALL runtime.printstring(SB)	
  0x446796		488b442418		MOVQ 0x18(SP), AX		
  0x44679b		48890424		MOVQ AX, 0(SP)			
  0x44679f		e80cdffdff		CALL runtime.printhex(SB)	
  0x4467a4		e8a7d9fdff		CALL runtime.printnl(SB)	
  0x4467a9		e892d7fdff		CALL runtime.printunlock(SB)	
			throw("casgstatus: bad incoming values")
  0x4467ae		488d0586b50200		LEAQ 0x2b586(IP), AX	
  0x4467b5		48890424		MOVQ AX, 0(SP)		
  0x4467b9		48c74424081f000000	MOVQ $0x1f, 0x8(SP)	
  0x4467c2		e8b9ccfdff		CALL runtime.throw(SB)	
  0x4467c7		0f0b			UD2			
		systemstack(func() {
  0x4467c9		e812100000		CALL runtime.morestack(SB)		
  0x4467ce		e94dffffff		JMP runtime.casgstatus.func1(SB)	

TEXT runtime.casgstatus.func2(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x4467e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4467e9		483b6110		CMPQ 0x10(CX), SP	
  0x4467ed		0f86e0000000		JBE 0x4468d3		
  0x4467f3		4883ec30		SUBQ $0x30, SP		
  0x4467f7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4467fc		488d6c2428		LEAQ 0x28(SP), BP	
  0x446801		488b4210		MOVQ 0x10(DX), AX	
  0x446805		8b4a0c			MOVL 0xc(DX), CX	
  0x446808		48894c2420		MOVQ CX, 0x20(SP)	
  0x44680d		8b5208			MOVL 0x8(DX), DX	
  0x446810		4889542418		MOVQ DX, 0x18(SP)	
			print("runtime: casgstatus ", hex(oldval), "->", hex(newval), " gp.status=", hex(gp.atomicstatus), " gp.gcscanvalid=true\n")
  0x446815		8b8090000000		MOVL 0x90(AX), AX		
  0x44681b		4889442410		MOVQ AX, 0x10(SP)		
  0x446820		e89bd6fdff		CALL runtime.printlock(SB)	
  0x446825		488d050d9f0200		LEAQ 0x29f0d(IP), AX		
  0x44682c		48890424		MOVQ AX, 0(SP)			
  0x446830		48c744240814000000	MOVQ $0x14, 0x8(SP)		
  0x446839		e8b2dffdff		CALL runtime.printstring(SB)	
  0x44683e		488b442418		MOVQ 0x18(SP), AX		
  0x446843		48890424		MOVQ AX, 0(SP)			
  0x446847		e864defdff		CALL runtime.printhex(SB)	
  0x44684c		488d054b880200		LEAQ 0x2884b(IP), AX		
  0x446853		48890424		MOVQ AX, 0(SP)			
  0x446857		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x446860		e88bdffdff		CALL runtime.printstring(SB)	
  0x446865		488b442420		MOVQ 0x20(SP), AX		
  0x44686a		48890424		MOVQ AX, 0(SP)			
  0x44686e		e83ddefdff		CALL runtime.printhex(SB)	
  0x446873		488d05bd8f0200		LEAQ 0x28fbd(IP), AX		
  0x44687a		48890424		MOVQ AX, 0(SP)			
  0x44687e		48c74424080b000000	MOVQ $0xb, 0x8(SP)		
  0x446887		e864dffdff		CALL runtime.printstring(SB)	
  0x44688c		488b442410		MOVQ 0x10(SP), AX		
  0x446891		48890424		MOVQ AX, 0(SP)			
  0x446895		e816defdff		CALL runtime.printhex(SB)	
  0x44689a		488d05249f0200		LEAQ 0x29f24(IP), AX		
  0x4468a1		48890424		MOVQ AX, 0(SP)			
  0x4468a5		48c744240815000000	MOVQ $0x15, 0x8(SP)		
  0x4468ae		e83ddffdff		CALL runtime.printstring(SB)	
  0x4468b3		e888d6fdff		CALL runtime.printunlock(SB)	
			throw("casgstatus")
  0x4468b8		488d05f38e0200		LEAQ 0x28ef3(IP), AX	
  0x4468bf		48890424		MOVQ AX, 0(SP)		
  0x4468c3		48c74424080a000000	MOVQ $0xa, 0x8(SP)	
  0x4468cc		e8afcbfdff		CALL runtime.throw(SB)	
  0x4468d1		0f0b			UD2			
		systemstack(func() {
  0x4468d3		e8080f0000		CALL runtime.morestack(SB)		
  0x4468d8		e903ffffff		JMP runtime.casgstatus.func2(SB)	

TEXT runtime.reentersyscall.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x4468e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4468e9		483b6110		CMPQ 0x10(CX), SP	
  0x4468ed		0f86df000000		JBE 0x4469d2		
  0x4468f3		4883ec30		SUBQ $0x30, SP		
  0x4468f7		48896c2428		MOVQ BP, 0x28(SP)	
  0x4468fc		488d6c2428		LEAQ 0x28(SP), BP	
  0x446901		488b4208		MOVQ 0x8(DX), AX	
			print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x446905		488b4870		MOVQ 0x70(AX), CX		
  0x446909		48894c2420		MOVQ CX, 0x20(SP)		
  0x44690e		488b10			MOVQ 0(AX), DX			
  0x446911		4889542418		MOVQ DX, 0x18(SP)		
  0x446916		488b4008		MOVQ 0x8(AX), AX		
  0x44691a		4889442410		MOVQ AX, 0x10(SP)		
  0x44691f		e89cd5fdff		CALL runtime.printlock(SB)	
  0x446924		488d05cda80200		LEAQ 0x2a8cd(IP), AX		
  0x44692b		48890424		MOVQ AX, 0(SP)			
  0x44692f		48c74424081a000000	MOVQ $0x1a, 0x8(SP)		
  0x446938		e8b3defdff		CALL runtime.printstring(SB)	
  0x44693d		488b442420		MOVQ 0x20(SP), AX		
  0x446942		48890424		MOVQ AX, 0(SP)			
  0x446946		e865ddfdff		CALL runtime.printhex(SB)	
  0x44694b		488d0544870200		LEAQ 0x28744(IP), AX		
  0x446952		48890424		MOVQ AX, 0(SP)			
  0x446956		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x44695f		e88cdefdff		CALL runtime.printstring(SB)	
  0x446964		488b442418		MOVQ 0x18(SP), AX		
  0x446969		48890424		MOVQ AX, 0(SP)			
  0x44696d		e83eddfdff		CALL runtime.printhex(SB)	
  0x446972		488d050b870200		LEAQ 0x2870b(IP), AX		
  0x446979		48890424		MOVQ AX, 0(SP)			
  0x44697d		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x446986		e865defdff		CALL runtime.printstring(SB)	
  0x44698b		488b442410		MOVQ 0x10(SP), AX		
  0x446990		48890424		MOVQ AX, 0(SP)			
  0x446994		e817ddfdff		CALL runtime.printhex(SB)	
  0x446999		488d0508870200		LEAQ 0x28708(IP), AX		
  0x4469a0		48890424		MOVQ AX, 0(SP)			
  0x4469a4		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x4469ad		e83edefdff		CALL runtime.printstring(SB)	
  0x4469b2		e889d5fdff		CALL runtime.printunlock(SB)	
			throw("entersyscall")
  0x4469b7		488d0537910200		LEAQ 0x29137(IP), AX	
  0x4469be		48890424		MOVQ AX, 0(SP)		
  0x4469c2		48c74424080c000000	MOVQ $0xc, 0x8(SP)	
  0x4469cb		e8b0cafdff		CALL runtime.throw(SB)	
  0x4469d0		0f0b			UD2			
		systemstack(func() {
  0x4469d2		e8090e0000		CALL runtime.morestack(SB)		
  0x4469d7		e904ffffff		JMP runtime.reentersyscall.func1(SB)	

TEXT runtime.entersyscallblock.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x4469e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x4469e9		483b6110		CMPQ 0x10(CX), SP	
  0x4469ed		0f8617010000		JBE 0x446b0a		
  0x4469f3		4883ec40		SUBQ $0x40, SP		
  0x4469f7		48896c2438		MOVQ BP, 0x38(SP)	
  0x4469fc		488d6c2438		LEAQ 0x38(SP), BP	
  0x446a01		488b4220		MOVQ 0x20(DX), AX	
  0x446a05		488b4a10		MOVQ 0x10(DX), CX	
  0x446a09		48894c2418		MOVQ CX, 0x18(SP)	
  0x446a0e		488b5a18		MOVQ 0x18(DX), BX	
  0x446a12		48895c2410		MOVQ BX, 0x10(SP)	
  0x446a17		488b5208		MOVQ 0x8(DX), DX	
  0x446a1b		4889542420		MOVQ DX, 0x20(SP)	
			print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x446a20		488b30			MOVQ 0(AX), SI			
  0x446a23		4889742428		MOVQ SI, 0x28(SP)		
  0x446a28		488b4008		MOVQ 0x8(AX), AX		
  0x446a2c		4889442430		MOVQ AX, 0x30(SP)		
  0x446a31		e88ad4fdff		CALL runtime.printlock(SB)	
  0x446a36		488d053cb30200		LEAQ 0x2b33c(IP), AX		
  0x446a3d		48890424		MOVQ AX, 0(SP)			
  0x446a41		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x446a4a		e8a1ddfdff		CALL runtime.printstring(SB)	
  0x446a4f		488b442420		MOVQ 0x20(SP), AX		
  0x446a54		48890424		MOVQ AX, 0(SP)			
  0x446a58		e853dcfdff		CALL runtime.printhex(SB)	
  0x446a5d		e89ed6fdff		CALL runtime.printsp(SB)	
  0x446a62		488b442418		MOVQ 0x18(SP), AX		
  0x446a67		48890424		MOVQ AX, 0(SP)			
  0x446a6b		e840dcfdff		CALL runtime.printhex(SB)	
  0x446a70		e88bd6fdff		CALL runtime.printsp(SB)	
  0x446a75		488b442410		MOVQ 0x10(SP), AX		
  0x446a7a		48890424		MOVQ AX, 0(SP)			
  0x446a7e		e82ddcfdff		CALL runtime.printhex(SB)	
  0x446a83		488d050c860200		LEAQ 0x2860c(IP), AX		
  0x446a8a		48890424		MOVQ AX, 0(SP)			
  0x446a8e		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x446a97		e854ddfdff		CALL runtime.printstring(SB)	
  0x446a9c		488b442428		MOVQ 0x28(SP), AX		
  0x446aa1		48890424		MOVQ AX, 0(SP)			
  0x446aa5		e806dcfdff		CALL runtime.printhex(SB)	
  0x446aaa		488d05d3850200		LEAQ 0x285d3(IP), AX		
  0x446ab1		48890424		MOVQ AX, 0(SP)			
  0x446ab5		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x446abe		e82dddfdff		CALL runtime.printstring(SB)	
  0x446ac3		488b442430		MOVQ 0x30(SP), AX		
  0x446ac8		48890424		MOVQ AX, 0(SP)			
  0x446acc		e8dfdbfdff		CALL runtime.printhex(SB)	
  0x446ad1		488d05d0850200		LEAQ 0x285d0(IP), AX		
  0x446ad8		48890424		MOVQ AX, 0(SP)			
  0x446adc		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x446ae5		e806ddfdff		CALL runtime.printstring(SB)	
  0x446aea		e851d4fdff		CALL runtime.printunlock(SB)	
			throw("entersyscallblock")
  0x446aef		488d0579960200		LEAQ 0x29679(IP), AX	
  0x446af6		48890424		MOVQ AX, 0(SP)		
  0x446afa		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x446b03		e878c9fdff		CALL runtime.throw(SB)	
  0x446b08		0f0b			UD2			
		systemstack(func() {
  0x446b0a		e8d10c0000		CALL runtime.morestack(SB)		
  0x446b0f		e9ccfeffff		JMP runtime.entersyscallblock.func1(SB)	

TEXT runtime.entersyscallblock.func2(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446b20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446b29		483b6110		CMPQ 0x10(CX), SP	
  0x446b2d		0f8617010000		JBE 0x446c4a		
  0x446b33		4883ec40		SUBQ $0x40, SP		
  0x446b37		48896c2438		MOVQ BP, 0x38(SP)	
  0x446b3c		488d6c2438		LEAQ 0x38(SP), BP	
  0x446b41		488b4210		MOVQ 0x10(DX), AX	
  0x446b45		488b4a08		MOVQ 0x8(DX), CX	
  0x446b49		48894c2410		MOVQ CX, 0x10(SP)	
			print("entersyscallblock inconsistent ", hex(sp), " ", hex(_g_.sched.sp), " ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
  0x446b4e		488b5038		MOVQ 0x38(AX), DX		
  0x446b52		4889542428		MOVQ DX, 0x28(SP)		
  0x446b57		488b5870		MOVQ 0x70(AX), BX		
  0x446b5b		48895c2420		MOVQ BX, 0x20(SP)		
  0x446b60		488b30			MOVQ 0(AX), SI			
  0x446b63		4889742418		MOVQ SI, 0x18(SP)		
  0x446b68		488b4008		MOVQ 0x8(AX), AX		
  0x446b6c		4889442430		MOVQ AX, 0x30(SP)		
  0x446b71		e84ad3fdff		CALL runtime.printlock(SB)	
  0x446b76		488d05fcb10200		LEAQ 0x2b1fc(IP), AX		
  0x446b7d		48890424		MOVQ AX, 0(SP)			
  0x446b81		48c74424081f000000	MOVQ $0x1f, 0x8(SP)		
  0x446b8a		e861dcfdff		CALL runtime.printstring(SB)	
  0x446b8f		488b442410		MOVQ 0x10(SP), AX		
  0x446b94		48890424		MOVQ AX, 0(SP)			
  0x446b98		e813dbfdff		CALL runtime.printhex(SB)	
  0x446b9d		e85ed5fdff		CALL runtime.printsp(SB)	
  0x446ba2		488b442428		MOVQ 0x28(SP), AX		
  0x446ba7		48890424		MOVQ AX, 0(SP)			
  0x446bab		e800dbfdff		CALL runtime.printhex(SB)	
  0x446bb0		e84bd5fdff		CALL runtime.printsp(SB)	
  0x446bb5		488b442420		MOVQ 0x20(SP), AX		
  0x446bba		48890424		MOVQ AX, 0(SP)			
  0x446bbe		e8eddafdff		CALL runtime.printhex(SB)	
  0x446bc3		488d05cc840200		LEAQ 0x284cc(IP), AX		
  0x446bca		48890424		MOVQ AX, 0(SP)			
  0x446bce		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x446bd7		e814dcfdff		CALL runtime.printstring(SB)	
  0x446bdc		488b442418		MOVQ 0x18(SP), AX		
  0x446be1		48890424		MOVQ AX, 0(SP)			
  0x446be5		e8c6dafdff		CALL runtime.printhex(SB)	
  0x446bea		488d0593840200		LEAQ 0x28493(IP), AX		
  0x446bf1		48890424		MOVQ AX, 0(SP)			
  0x446bf5		48c744240801000000	MOVQ $0x1, 0x8(SP)		
  0x446bfe		e8eddbfdff		CALL runtime.printstring(SB)	
  0x446c03		488b442430		MOVQ 0x30(SP), AX		
  0x446c08		48890424		MOVQ AX, 0(SP)			
  0x446c0c		e89fdafdff		CALL runtime.printhex(SB)	
  0x446c11		488d0590840200		LEAQ 0x28490(IP), AX		
  0x446c18		48890424		MOVQ AX, 0(SP)			
  0x446c1c		48c744240802000000	MOVQ $0x2, 0x8(SP)		
  0x446c25		e8c6dbfdff		CALL runtime.printstring(SB)	
  0x446c2a		e811d3fdff		CALL runtime.printunlock(SB)	
			throw("entersyscallblock")
  0x446c2f		488d0539950200		LEAQ 0x29539(IP), AX	
  0x446c36		48890424		MOVQ AX, 0(SP)		
  0x446c3a		48c744240811000000	MOVQ $0x11, 0x8(SP)	
  0x446c43		e838c8fdff		CALL runtime.throw(SB)	
  0x446c48		0f0b			UD2			
		systemstack(func() {
  0x446c4a		e8910b0000		CALL runtime.morestack(SB)		
  0x446c4f		e9ccfeffff		JMP runtime.entersyscallblock.func2(SB)	

TEXT runtime.exitsyscallfast.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446c60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446c69		483b6110		CMPQ 0x10(CX), SP	
  0x446c6d		0f8687000000		JBE 0x446cfa		
  0x446c73		4883ec28		SUBQ $0x28, SP		
  0x446c77		48896c2420		MOVQ BP, 0x20(SP)	
  0x446c7c		488d6c2420		LEAQ 0x20(SP), BP	
  0x446c81		488b4210		MOVQ 0x10(DX), AX	
  0x446c85		4889442408		MOVQ AX, 0x8(SP)	
  0x446c8a		488b4a18		MOVQ 0x18(DX), CX	
  0x446c8e		48894c2410		MOVQ CX, 0x10(SP)	
  0x446c93		488b5208		MOVQ 0x8(DX), DX	
  0x446c97		4889542418		MOVQ DX, 0x18(SP)	
			ok = exitsyscallfast_pidle()
  0x446c9c		e81f55feff		CALL runtime.exitsyscallfast_pidle(SB)	
  0x446ca1		0fb60424		MOVZX 0(SP), AX				
  0x446ca5		488b4c2418		MOVQ 0x18(SP), CX			
  0x446caa		8801			MOVB AL, 0(CX)				
  0x446cac		84c0			TESTL AL, AL				
			if ok && trace.enabled {
  0x446cae		7440			JE 0x446cf0			
  0x446cb0		803d195f080000		CMPB $0x0, runtime.trace+16(SB)	
  0x446cb7		7437			JE 0x446cf0			
				if oldp != nil {
  0x446cb9		488b442408		MOVQ 0x8(SP), AX	
  0x446cbe		4885c0			TESTQ AX, AX		
  0x446cc1		750c			JNE 0x446ccf		
  0x446cc3		eb1e			JMP 0x446ce3		
						osyield()
  0x446cc5		e826490000		CALL runtime.osyield(SB)	
					for oldp.syscalltick == _g_.m.syscalltick {
  0x446cca		488b442408		MOVQ 0x8(SP), AX	
  0x446ccf		488b4c2410		MOVQ 0x10(SP), CX	
  0x446cd4		488b5130		MOVQ 0x30(CX), DX	
  0x446cd8		8b92a4020000		MOVL 0x2a4(DX), DX	
  0x446cde		39501c			CMPL DX, 0x1c(AX)	
  0x446ce1		74e2			JE 0x446cc5		
				traceGoSysExit(0)
  0x446ce3		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x446ceb		e83066ffff		CALL runtime.traceGoSysExit(SB)	
  0x446cf0		488b6c2420		MOVQ 0x20(SP), BP		
  0x446cf5		4883c428		ADDQ $0x28, SP			
  0x446cf9		c3			RET				
		systemstack(func() {
  0x446cfa		e8e10a0000		CALL runtime.morestack(SB)		
  0x446cff		e95cffffff		JMP runtime.exitsyscallfast.func1(SB)	

TEXT runtime.exitsyscallfast_reacquired.func1(SB) /usr/local/go/src/runtime/proc.go
			systemstack(func() {
  0x446d10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446d19		483b6110		CMPQ 0x10(CX), SP	
  0x446d1d		763e			JBE 0x446d5d		
  0x446d1f		4883ec10		SUBQ $0x10, SP		
  0x446d23		48896c2408		MOVQ BP, 0x8(SP)	
  0x446d28		488d6c2408		LEAQ 0x8(SP), BP	
  0x446d2d		488b4208		MOVQ 0x8(DX), AX	
				traceGoSysBlock(_g_.m.p.ptr())
  0x446d31		488b4030		MOVQ 0x30(AX), AX			
  0x446d35		488b80d0000000		MOVQ 0xd0(AX), AX			
  0x446d3c		90			NOPL					
  0x446d3d		48890424		MOVQ AX, 0(SP)				
  0x446d41		e8ba66ffff		CALL runtime.traceGoSysBlock(SB)	
				traceGoSysExit(0)
  0x446d46		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x446d4e		e8cd65ffff		CALL runtime.traceGoSysExit(SB)	
			})
  0x446d53		488b6c2408		MOVQ 0x8(SP), BP	
  0x446d58		4883c410		ADDQ $0x10, SP		
  0x446d5c		c3			RET			
			systemstack(func() {
  0x446d5d		e87e0a0000		CALL runtime.morestack(SB)				
  0x446d62		ebac			JMP runtime.exitsyscallfast_reacquired.func1(SB)	

TEXT runtime.malg.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446d79		483b6110		CMPQ 0x10(CX), SP	
  0x446d7d		7642			JBE 0x446dc1		
  0x446d7f		4883ec28		SUBQ $0x28, SP		
  0x446d83		48896c2420		MOVQ BP, 0x20(SP)	
  0x446d88		488d6c2420		LEAQ 0x20(SP), BP	
  0x446d8d		488b4210		MOVQ 0x10(DX), AX	
  0x446d91		4889442418		MOVQ AX, 0x18(SP)	
  0x446d96		8b4a08			MOVL 0x8(DX), CX	
			newg.stack = stackalloc(uint32(stacksize))
  0x446d99		890c24			MOVL CX, 0(SP)			
  0x446d9c		e8fffcfeff		CALL runtime.stackalloc(SB)	
  0x446da1		488b442408		MOVQ 0x8(SP), AX		
  0x446da6		488b4c2410		MOVQ 0x10(SP), CX		
  0x446dab		488b542418		MOVQ 0x18(SP), DX		
  0x446db0		488902			MOVQ AX, 0(DX)			
  0x446db3		48894a08		MOVQ CX, 0x8(DX)		
		})
  0x446db7		488b6c2420		MOVQ 0x20(SP), BP	
  0x446dbc		4883c428		ADDQ $0x28, SP		
  0x446dc0		c3			RET			
		systemstack(func() {
  0x446dc1		e81a0a0000		CALL runtime.morestack(SB)	
  0x446dc6		eba8			JMP runtime.malg.func1(SB)	

TEXT runtime.newproc.func1(SB) /usr/local/go/src/runtime/proc.go
	systemstack(func() {
  0x446dd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446dd9		483b6110		CMPQ 0x10(CX), SP	
  0x446ddd		764a			JBE 0x446e29		
  0x446ddf		4883ec30		SUBQ $0x30, SP		
  0x446de3		48896c2428		MOVQ BP, 0x28(SP)	
  0x446de8		488d6c2428		LEAQ 0x28(SP), BP	
  0x446ded		488b4210		MOVQ 0x10(DX), AX	
  0x446df1		8b4a18			MOVL 0x18(DX), CX	
  0x446df4		488b5a20		MOVQ 0x20(DX), BX	
  0x446df8		488b7228		MOVQ 0x28(DX), SI	
  0x446dfc		488b5208		MOVQ 0x8(DX), DX	
		newproc1(fn, (*uint8)(argp), siz, gp, pc)
  0x446e00		488b12			MOVQ 0(DX), DX			
  0x446e03		48891424		MOVQ DX, 0(SP)			
  0x446e07		4889442408		MOVQ AX, 0x8(SP)		
  0x446e0c		894c2410		MOVL CX, 0x10(SP)		
  0x446e10		48895c2418		MOVQ BX, 0x18(SP)		
  0x446e15		4889742420		MOVQ SI, 0x20(SP)		
  0x446e1a		e8b157feff		CALL runtime.newproc1(SB)	
	})
  0x446e1f		488b6c2428		MOVQ 0x28(SP), BP	
  0x446e24		4883c430		ADDQ $0x30, SP		
  0x446e28		c3			RET			
	systemstack(func() {
  0x446e29		e8b2090000		CALL runtime.morestack(SB)	
  0x446e2e		eba0			JMP runtime.newproc.func1(SB)	

TEXT runtime.gfget.func1(SB) /usr/local/go/src/runtime/proc.go
		systemstack(func() {
  0x446e30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446e39		483b6110		CMPQ 0x10(CX), SP	
  0x446e3d		7643			JBE 0x446e82		
  0x446e3f		4883ec28		SUBQ $0x28, SP		
  0x446e43		48896c2420		MOVQ BP, 0x20(SP)	
  0x446e48		488d6c2420		LEAQ 0x20(SP), BP	
  0x446e4d		488b4208		MOVQ 0x8(DX), AX	
  0x446e51		4889442418		MOVQ AX, 0x18(SP)	
			gp.stack = stackalloc(_FixedStack)
  0x446e56		c7042400080000		MOVL $0x800, 0(SP)		
  0x446e5d		e83efcfeff		CALL runtime.stackalloc(SB)	
  0x446e62		488b442408		MOVQ 0x8(SP), AX		
  0x446e67		488b4c2410		MOVQ 0x10(SP), CX		
  0x446e6c		488b542418		MOVQ 0x18(SP), DX		
  0x446e71		488902			MOVQ AX, 0(DX)			
  0x446e74		48894a08		MOVQ CX, 0x8(DX)		
		})
  0x446e78		488b6c2420		MOVQ 0x20(SP), BP	
  0x446e7d		4883c428		ADDQ $0x28, SP		
  0x446e81		c3			RET			
		systemstack(func() {
  0x446e82		e859090000		CALL runtime.morestack(SB)	
  0x446e87		eba7			JMP runtime.gfget.func1(SB)	

TEXT runtime.(*rwmutex).rlock.func1(SB) /usr/local/go/src/runtime/rwmutex.go
		systemstack(func() {
  0x446e90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446e99		483b6110		CMPQ 0x10(CX), SP	
  0x446e9d		0f8699000000		JBE 0x446f3c		
  0x446ea3		4883ec20		SUBQ $0x20, SP		
  0x446ea7		48896c2418		MOVQ BP, 0x18(SP)	
  0x446eac		488d6c2418		LEAQ 0x18(SP), BP	
  0x446eb1		488b4208		MOVQ 0x8(DX), AX	
  0x446eb5		4889442408		MOVQ AX, 0x8(SP)	
			lock(&rw.rLock)
  0x446eba		8400			TESTB AL, 0(AX)		
  0x446ebc		48890424		MOVQ AX, 0(SP)		
  0x446ec0		e81b18fcff		CALL runtime.lock(SB)	
			if rw.readerPass > 0 {
  0x446ec5		488b442408		MOVQ 0x8(SP), AX	
  0x446eca		8b4810			MOVL 0x10(AX), CX	
  0x446ecd		85c9			TESTL CX, CX		
  0x446ecf		7618			JBE 0x446ee9		
				rw.readerPass -= 1
  0x446ed1		ffc9			DECL CX			
  0x446ed3		894810			MOVL CX, 0x10(AX)	
				unlock(&rw.rLock)
  0x446ed6		48890424		MOVQ AX, 0(SP)		
  0x446eda		e8b119fcff		CALL runtime.unlock(SB)	
  0x446edf		488b6c2418		MOVQ 0x18(SP), BP	
  0x446ee4		4883c420		ADDQ $0x20, SP		
  0x446ee8		c3			RET			
				m := getg().m
  0x446ee9		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446ef2		488b4930		MOVQ 0x30(CX), CX	
  0x446ef6		48894c2410		MOVQ CX, 0x10(SP)	
				m.schedlink = rw.readers
  0x446efb		488b5008		MOVQ 0x8(AX), DX	
  0x446eff		48899158010000		MOVQ DX, 0x158(CX)	
				rw.readers.set(m)
  0x446f06		90			NOPL			
func (mp *muintptr) set(m *m) { *mp = muintptr(unsafe.Pointer(m)) }
  0x446f07		48894808		MOVQ CX, 0x8(AX)	
				unlock(&rw.rLock)
  0x446f0b		48890424		MOVQ AX, 0(SP)		
  0x446f0f		e87c19fcff		CALL runtime.unlock(SB)	
				notesleep(&m.park)
  0x446f14		488b442410		MOVQ 0x10(SP), AX		
  0x446f19		488d8848010000		LEAQ 0x148(AX), CX		
  0x446f20		48890c24		MOVQ CX, 0(SP)			
  0x446f24		e8071bfcff		CALL runtime.notesleep(SB)	
				noteclear(&m.park)
  0x446f29		90			NOPL			
	n.key = 0
  0x446f2a		488b442410		MOVQ 0x10(SP), AX	
  0x446f2f		48c7804801000000000000	MOVQ $0x0, 0x148(AX)	
  0x446f3a		eba3			JMP 0x446edf		
		systemstack(func() {
  0x446f3c		e89f080000		CALL runtime.morestack(SB)		
  0x446f41		e94affffff		JMP runtime.(*rwmutex).rlock.func1(SB)	

TEXT runtime.callers.func1(SB) /usr/local/go/src/runtime/traceback.go
	systemstack(func() {
  0x446f50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x446f59		483b6110		CMPQ 0x10(CX), SP	
  0x446f5d		0f868e000000		JBE 0x446ff1		
  0x446f63		4883ec68		SUBQ $0x68, SP		
  0x446f67		48896c2460		MOVQ BP, 0x60(SP)	
  0x446f6c		488d6c2460		LEAQ 0x60(SP), BP	
  0x446f71		488b4210		MOVQ 0x10(DX), AX	
  0x446f75		488b4a18		MOVQ 0x18(DX), CX	
  0x446f79		488b5a20		MOVQ 0x20(DX), BX	
  0x446f7d		488b7240		MOVQ 0x40(DX), SI	
  0x446f81		488b7a08		MOVQ 0x8(DX), DI	
		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x446f85		4c8b4230		MOVQ 0x30(DX), R8	
  0x446f89		488b5228		MOVQ 0x28(DX), DX	
  0x446f8d		4d85c0			TESTQ R8, R8		
  0x446f90		7658			JBE 0x446fea		
	systemstack(func() {
  0x446f92		4889742458		MOVQ SI, 0x58(SP)	
		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x446f97		48893c24		MOVQ DI, 0(SP)			
  0x446f9b		4889442408		MOVQ AX, 0x8(SP)		
  0x446fa0		48c744241000000000	MOVQ $0x0, 0x10(SP)		
  0x446fa9		48894c2418		MOVQ CX, 0x18(SP)		
  0x446fae		48895c2420		MOVQ BX, 0x20(SP)		
  0x446fb3		4889542428		MOVQ DX, 0x28(SP)		
  0x446fb8		4c89442430		MOVQ R8, 0x30(SP)		
  0x446fbd		0f57c0			XORPS X0, X0			
  0x446fc0		0f11442438		MOVUPS X0, 0x38(SP)		
  0x446fc5		48c744244800000000	MOVQ $0x0, 0x48(SP)		
  0x446fce		e8ed67ffff		CALL runtime.gentraceback(SB)	
  0x446fd3		488b442450		MOVQ 0x50(SP), AX		
  0x446fd8		488b4c2458		MOVQ 0x58(SP), CX		
  0x446fdd		488901			MOVQ AX, 0(CX)			
	})
  0x446fe0		488b6c2460		MOVQ 0x60(SP), BP	
  0x446fe5		4883c468		ADDQ $0x68, SP		
  0x446fe9		c3			RET			
		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
  0x446fea		e831affdff		CALL runtime.panicindex(SB)	
  0x446fef		0f0b			UD2				
	systemstack(func() {
  0x446ff1		e8ea070000		CALL runtime.morestack(SB)	
  0x446ff6		e955ffffff		JMP runtime.callers.func1(SB)	

TEXT runtime.tracebackHexdump.func1(SB) /usr/local/go/src/runtime/traceback.go
	hexdumpWords(lo, hi, func(p uintptr) byte {
  0x447000		488b4208		MOVQ 0x8(DX), AX	
  0x447004		488b4a10		MOVQ 0x10(DX), CX	
		case frame.fp:
  0x447008		488b542408		MOVQ 0x8(SP), DX	
  0x44700d		48395030		CMPQ DX, 0x30(AX)	
  0x447011		741d			JE 0x447030		
		case frame.sp:
  0x447013		48395028		CMPQ DX, 0x28(AX)	
  0x447017		7411			JE 0x44702a		
		case bad:
  0x447019		4839d1			CMPQ DX, CX		
  0x44701c		7506			JNE 0x447024		
			return '!'
  0x44701e		c644241021		MOVB $0x21, 0x10(SP)	
  0x447023		c3			RET			
		return 0
  0x447024		c644241000		MOVB $0x0, 0x10(SP)	
  0x447029		c3			RET			
			return '<'
  0x44702a		c64424103c		MOVB $0x3c, 0x10(SP)	
  0x44702f		c3			RET			
			return '>'
  0x447030		c64424103e		MOVB $0x3e, 0x10(SP)	
  0x447035		c3			RET			

TEXT runtime.vdsoParseSymbols.func1(SB) /usr/local/go/src/runtime/vdso_linux.go
	apply := func(symIndex uint32, k vdsoSymbolKey) bool {
  0x447040		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x447049		483b6110		CMPQ 0x10(CX), SP	
  0x44704d		0f867a010000		JBE 0x4471cd		
  0x447053		4883ec60		SUBQ $0x60, SP		
  0x447057		48896c2458		MOVQ BP, 0x58(SP)	
  0x44705c		488d6c2458		LEAQ 0x58(SP), BP	
  0x447061		488b4208		MOVQ 0x8(DX), AX	
		sym := &info.symtab[symIndex]
  0x447065		488b4818		MOVQ 0x18(AX), CX	
  0x447069		8401			TESTB AL, 0(CX)		
  0x44706b		8400			TESTB AL, 0(AX)		
	apply := func(symIndex uint32, k vdsoSymbolKey) bool {
  0x44706d		8b5210			MOVL 0x10(DX), DX	
		sym := &info.symtab[symIndex]
  0x447070		8b5c2468		MOVL 0x68(SP), BX	
  0x447074		488d345b		LEAQ 0(BX)(BX*2), SI	
  0x447078		4889f7			MOVQ SI, DI		
  0x44707b		48c1e603		SHLQ $0x3, SI		
		typ := _ELF_ST_TYPE(sym.st_info)
  0x44707f		90			NOPL			
  0x447080		440fb6443104		MOVZX 0x4(CX)(SI*1), R8	
		bind := _ELF_ST_BIND(sym.st_info)
  0x447086		90			NOPL			
func _ELF_ST_TYPE(val byte) byte { return val & 0xf }
  0x447087		4589c1			MOVL R8, R9		
  0x44708a		4183e00f		ANDL $0xf, R8		
		if typ != _STT_FUNC && typ != _STT_NOTYPE || bind != _STB_GLOBAL && bind != _STB_WEAK || sym.st_shndx == _SHN_UNDEF {
  0x44708e		4180f802		CMPL $0x2, R8		
  0x447092		7418			JE 0x4470ac		
  0x447094		41f6c10f		TESTL $0xf, R9		
  0x447098		7412			JE 0x4470ac		
			return false
  0x44709a		c684249000000000	MOVB $0x0, 0x90(SP)	
  0x4470a2		488b6c2458		MOVQ 0x58(SP), BP	
  0x4470a7		4883c460		ADDQ $0x60, SP		
  0x4470ab		c3			RET			
func _ELF_ST_BIND(val byte) byte { return val >> 4 }
  0x4470ac		41c0e904		SHRL $0x4, R9		
		if typ != _STT_FUNC && typ != _STT_NOTYPE || bind != _STB_GLOBAL && bind != _STB_WEAK || sym.st_shndx == _SHN_UNDEF {
  0x4470b0		4180f901		CMPL $0x1, R9		
  0x4470b4		0f840b010000		JE 0x4471c5		
  0x4470ba		4180f902		CMPL $0x2, R9		
  0x4470be		410f95c0		SETNE R8		
  0x4470c2		4584c0			TESTL R8, R8		
  0x4470c5		75d3			JNE 0x44709a		
  0x4470c7		0fb7743106		MOVZX 0x6(CX)(SI*1), SI	
  0x4470cc		6685f6			TESTW SI, SI		
  0x4470cf		74c9			JE 0x44709a		
	apply := func(symIndex uint32, k vdsoSymbolKey) bool {
  0x4470d1		4889442438		MOVQ AX, 0x38(SP)	
  0x4470d6		89542424		MOVL DX, 0x24(SP)	
		sym := &info.symtab[symIndex]
  0x4470da		48894c2440		MOVQ CX, 0x40(SP)	
  0x4470df		48897c2428		MOVQ DI, 0x28(SP)	
		if k.name != gostringnocopy(&info.symstrings[sym.st_name]) {
  0x4470e4		488b5020		MOVQ 0x20(AX), DX	
  0x4470e8		8402			TESTB AL, 0(DX)		
  0x4470ea		90			NOPL			
  0x4470eb		8b1cf9			MOVL 0(CX)(DI*8), BX	
  0x4470ee		4801da			ADDQ BX, DX		
  0x4470f1		4889542430		MOVQ DX, 0x30(SP)	
	ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}
  0x4470f6		48891424		MOVQ DX, 0(SP)			
  0x4470fa		e8012fffff		CALL runtime.findnull(SB)	
  0x4470ff		488b442408		MOVQ 0x8(SP), AX		
  0x447104		0f57c0			XORPS X0, X0			
  0x447107		0f11442448		MOVUPS X0, 0x48(SP)		
  0x44710c		488b4c2430		MOVQ 0x30(SP), CX		
  0x447111		48894c2448		MOVQ CX, 0x48(SP)		
  0x447116		4889442450		MOVQ AX, 0x50(SP)		
	s := *(*string)(unsafe.Pointer(&ss))
  0x44711b		488b4c2448		MOVQ 0x48(SP), CX	
		if k.name != gostringnocopy(&info.symstrings[sym.st_name]) {
  0x447120		488b542478		MOVQ 0x78(SP), DX	
  0x447125		4839c2			CMPQ AX, DX		
  0x447128		7412			JE 0x44713c		
			return false
  0x44712a		c684249000000000	MOVB $0x0, 0x90(SP)	
  0x447132		488b6c2458		MOVQ 0x58(SP), BP	
  0x447137		4883c460		ADDQ $0x60, SP		
  0x44713b		c3			RET			
		if k.name != gostringnocopy(&info.symstrings[sym.st_name]) {
  0x44713c		488b442470		MOVQ 0x70(SP), AX		
  0x447141		48890424		MOVQ AX, 0(SP)			
  0x447145		48894c2408		MOVQ CX, 0x8(SP)		
  0x44714a		4889542410		MOVQ DX, 0x10(SP)		
  0x44714f		e8ccb0fbff		CALL runtime.memequal(SB)	
  0x447154		807c241800		CMPB $0x0, 0x18(SP)		
  0x447159		74cf			JE 0x44712a			
		if info.versym != nil && version != 0 && int32(info.versym[symIndex]&0x7fff) != version {
  0x44715b		488b442438		MOVQ 0x38(SP), AX	
  0x447160		488b4860		MOVQ 0x60(AX), CX	
  0x447164		4885c9			TESTQ CX, CX		
  0x447167		741a			JE 0x447183		
  0x447169		8b542424		MOVL 0x24(SP), DX	
  0x44716d		85d2			TESTL DX, DX		
  0x44716f		7412			JE 0x447183		
  0x447171		8b5c2468		MOVL 0x68(SP), BX	
  0x447175		0fb70c59		MOVZX 0(CX)(BX*2), CX	
  0x447179		81e1ff7f0000		ANDL $0x7fff, CX	
  0x44717f		39d1			CMPL DX, CX		
  0x447181		7530			JNE 0x4471b3		
		*k.ptr = info.loadOffset + uintptr(sym.st_value)
  0x447183		488b4c2428		MOVQ 0x28(SP), CX	
  0x447188		488b542440		MOVQ 0x40(SP), DX	
  0x44718d		488b4cca08		MOVQ 0x8(DX)(CX*8), CX	
  0x447192		48034810		ADDQ 0x10(AX), CX	
  0x447196		488b842488000000	MOVQ 0x88(SP), AX	
  0x44719e		488908			MOVQ CX, 0(AX)		
		return true
  0x4471a1		c684249000000001	MOVB $0x1, 0x90(SP)	
  0x4471a9		488b6c2458		MOVQ 0x58(SP), BP	
  0x4471ae		4883c460		ADDQ $0x60, SP		
  0x4471b2		c3			RET			
			return false
  0x4471b3		c684249000000000	MOVB $0x0, 0x90(SP)	
  0x4471bb		488b6c2458		MOVQ 0x58(SP), BP	
  0x4471c0		4883c460		ADDQ $0x60, SP		
  0x4471c4		c3			RET			
  0x4471c5		4531c0			XORL R8, R8		
		if typ != _STT_FUNC && typ != _STT_NOTYPE || bind != _STB_GLOBAL && bind != _STB_WEAK || sym.st_shndx == _SHN_UNDEF {
  0x4471c8		e9f5feffff		JMP 0x4470c2		
	apply := func(symIndex uint32, k vdsoSymbolKey) bool {
  0x4471cd		e80e060000		CALL runtime.morestack(SB)		
  0x4471d2		e969feffff		JMP runtime.vdsoParseSymbols.func1(SB)	

TEXT runtime.init.ializers(SB) /usr/local/go/src/runtime/float.go
var inf = float64frombits(0x7FF0000000000000)
  0x4471e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4471e9		483b6110		CMPQ 0x10(CX), SP			
  0x4471ed		0f865e010000		JBE 0x447351				
  0x4471f3		4883ec20		SUBQ $0x20, SP				
  0x4471f7		48896c2418		MOVQ BP, 0x18(SP)			
  0x4471fc		488d6c2418		LEAQ 0x18(SP), BP			
  0x447201		48b8000000000000f07f	MOVQ $0x7ff0000000000000, AX		
  0x44720b		48890424		MOVQ AX, 0(SP)				
  0x44720f		e89c00fcff		CALL runtime.float64frombits(SB)	
  0x447214		f20f10442408		MOVSD_XMM 0x8(SP), X0			
  0x44721a		f20f1105565b0900	MOVSD_XMM X0, runtime.inf(SB)		
	uint16Type *_type = (*eface)(unsafe.Pointer(&uint16Eface))._type
  0x447222		488b05378a0700		MOVQ runtime.uint16Eface(SB), AX	
  0x447229		833df05b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x447230		0f850a010000		JNE 0x447340				
  0x447236		4889056ba70700		MOVQ AX, runtime.uint16Type(SB)		
	uint32Type *_type = (*eface)(unsafe.Pointer(&uint32Eface))._type
  0x44723d		488b052c8a0700		MOVQ runtime.uint32Eface(SB), AX	
  0x447244		833dd55b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44724b		0f85de000000		JNE 0x44732f				
  0x447251		48890558a70700		MOVQ AX, runtime.uint32Type(SB)		
	uint64Type *_type = (*eface)(unsafe.Pointer(&uint64Eface))._type
  0x447258		488b05218a0700		MOVQ runtime.uint64Eface(SB), AX	
  0x44725f		833dba5b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x447266		0f85b2000000		JNE 0x44731e				
  0x44726c		48890545a70700		MOVQ AX, runtime.uint64Type(SB)		
	stringType *_type = (*eface)(unsafe.Pointer(&stringEface))._type
  0x447273		488b05d6890700		MOVQ runtime.stringEface(SB), AX	
  0x44727a		833d9f5b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x447281		0f8586000000		JNE 0x44730d				
  0x447287		4889050aa70700		MOVQ AX, runtime.stringType(SB)		
	sliceType  *_type = (*eface)(unsafe.Pointer(&sliceEface))._type
  0x44728e		488b053b890700		MOVQ runtime.sliceEface(SB), AX		
  0x447295		833d845b090000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44729c		7561			JNE 0x4472ff				
  0x44729e		488905eba60700		MOVQ AX, runtime.sliceType(SB)		
	chansendpc = funcPC(chansend)
  0x4472a5		488d05747c0100		LEAQ 0x17c74(IP), AX		
  0x4472ac		48890424		MOVQ AX, 0(SP)			
  0x4472b0		488d05d9c40200		LEAQ 0x2c4d9(IP), AX		
  0x4472b7		4889442408		MOVQ AX, 0x8(SP)		
  0x4472bc		e88fe7fdff		CALL runtime.funcPC(SB)		
  0x4472c1		488b442410		MOVQ 0x10(SP), AX		
  0x4472c6		4889057b5a0900		MOVQ AX, runtime.chansendpc(SB)	
	chanrecvpc = funcPC(chanrecv)
  0x4472cd		488d05ec7b0100		LEAQ 0x17bec(IP), AX		
  0x4472d4		48890424		MOVQ AX, 0(SP)			
  0x4472d8		488d05a9c40200		LEAQ 0x2c4a9(IP), AX		
  0x4472df		4889442408		MOVQ AX, 0x8(SP)		
  0x4472e4		e867e7fdff		CALL runtime.funcPC(SB)		
  0x4472e9		488b442410		MOVQ 0x10(SP), AX		
  0x4472ee		4889054b5a0900		MOVQ AX, runtime.chanrecvpc(SB)	
  0x4472f5		488b6c2418		MOVQ 0x18(SP), BP		
  0x4472fa		4883c420		ADDQ $0x20, SP			
  0x4472fe		c3			RET				
	sliceType  *_type = (*eface)(unsafe.Pointer(&sliceEface))._type
  0x4472ff		488d3d8aa60700		LEAQ runtime.sliceType(SB), DI	
  0x447306		e875230000		CALL runtime.gcWriteBarrier(SB)	
  0x44730b		eb98			JMP 0x4472a5			
	stringType *_type = (*eface)(unsafe.Pointer(&stringEface))._type
  0x44730d		488d3d84a60700		LEAQ runtime.stringType(SB), DI	
  0x447314		e867230000		CALL runtime.gcWriteBarrier(SB)	
  0x447319		e970ffffff		JMP 0x44728e			
	uint64Type *_type = (*eface)(unsafe.Pointer(&uint64Eface))._type
  0x44731e		488d3d93a60700		LEAQ runtime.uint64Type(SB), DI	
  0x447325		e856230000		CALL runtime.gcWriteBarrier(SB)	
  0x44732a		e944ffffff		JMP 0x447273			
	uint32Type *_type = (*eface)(unsafe.Pointer(&uint32Eface))._type
  0x44732f		488d3d7aa60700		LEAQ runtime.uint32Type(SB), DI	
  0x447336		e845230000		CALL runtime.gcWriteBarrier(SB)	
  0x44733b		e918ffffff		JMP 0x447258			
	uint16Type *_type = (*eface)(unsafe.Pointer(&uint16Eface))._type
  0x447340		488d3d61a60700		LEAQ runtime.uint16Type(SB), DI	
  0x447347		e834230000		CALL runtime.gcWriteBarrier(SB)	
  0x44734c		e9ecfeffff		JMP 0x44723d			
var inf = float64frombits(0x7FF0000000000000)
  0x447351		e82a050000		CALL runtime.morestack_noctxt(SB)	
  0x447356		e985feffff		JMP runtime.init.ializers(SB)		

TEXT runtime.init(SB) <autogenerated>

  0x447360		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447369		483b6110		CMPQ 0x10(CX), SP			
  0x44736d		766e			JBE 0x4473dd				
  0x44736f		4883ec08		SUBQ $0x8, SP				
  0x447373		48892c24		MOVQ BP, 0(SP)				
  0x447377		488d2c24		LEAQ 0(SP), BP				
  0x44737b		0fb60529590900		MOVZX runtime.initdone.(SB), AX		
  0x447382		80f801			CMPL $0x1, AL				
  0x447385		7609			JBE 0x447390				
  0x447387		488b2c24		MOVQ 0(SP), BP				
  0x44738b		4883c408		ADDQ $0x8, SP				
  0x44738f		c3			RET					
  0x447390		7507			JNE 0x447399				
  0x447392		e859aefdff		CALL runtime.throwinit(SB)		
  0x447397		0f0b			UD2					
  0x447399		c6050b59090001		MOVB $0x1, runtime.initdone.(SB)	
  0x4473a0		e8bbabfbff		CALL internal/bytealg.init(SB)		
  0x4473a5		e836feffff		CALL runtime.init.ializers(SB)		
  0x4473aa		e8a1e6fbff		CALL runtime.init.0(SB)			
  0x4473af		e86c27fdff		CALL runtime.init.1(SB)			
  0x4473b4		e82741fdff		CALL runtime.init.2(SB)			
  0x4473b9		e80294fdff		CALL runtime.init.3(SB)			
  0x4473be		e8edb1fdff		CALL runtime.init.4(SB)			
  0x4473c3		e818dcfdff		CALL runtime.init.5(SB)			
  0x4473c8		e8e3d0feff		CALL runtime.init.6(SB)			
  0x4473cd		c605d758090002		MOVB $0x2, runtime.initdone.(SB)	
  0x4473d4		488b2c24		MOVQ 0(SP), BP				
  0x4473d8		4883c408		ADDQ $0x8, SP				
  0x4473dc		c3			RET					
  0x4473dd		e89e040000		CALL runtime.morestack_noctxt(SB)	
  0x4473e2		e979ffffff		JMP runtime.init(SB)			

TEXT runtime.skipPleaseUseCallersFrames(SB) /usr/local/go/src/runtime/asm.s

  0x4473f0		90			NOPL			
  0x4473f1		90			NOPL			
  0x4473f2		90			NOPL			
  0x4473f3		90			NOPL			
  0x4473f4		90			NOPL			
  0x4473f5		90			NOPL			
  0x4473f6		90			NOPL			
  0x4473f7		90			NOPL			
  0x4473f8		90			NOPL			
  0x4473f9		90			NOPL			
  0x4473fa		90			NOPL			
  0x4473fb		90			NOPL			
  0x4473fc		90			NOPL			
  0x4473fd		90			NOPL			
  0x4473fe		90			NOPL			
  0x4473ff		90			NOPL			
  0x447400		90			NOPL			
  0x447401		90			NOPL			
  0x447402		90			NOPL			
  0x447403		90			NOPL			
  0x447404		90			NOPL			
  0x447405		90			NOPL			
  0x447406		90			NOPL			
  0x447407		90			NOPL			
  0x447408		90			NOPL			
  0x447409		90			NOPL			
  0x44740a		90			NOPL			
  0x44740b		90			NOPL			
  0x44740c		90			NOPL			
  0x44740d		90			NOPL			
  0x44740e		90			NOPL			
  0x44740f		90			NOPL			
  0x447410		90			NOPL			
  0x447411		90			NOPL			
  0x447412		90			NOPL			
  0x447413		90			NOPL			
  0x447414		90			NOPL			
  0x447415		90			NOPL			
  0x447416		90			NOPL			
  0x447417		90			NOPL			
  0x447418		90			NOPL			
  0x447419		90			NOPL			
  0x44741a		90			NOPL			
  0x44741b		90			NOPL			
  0x44741c		90			NOPL			
  0x44741d		90			NOPL			
  0x44741e		90			NOPL			
  0x44741f		90			NOPL			
  0x447420		90			NOPL			
  0x447421		90			NOPL			
  0x447422		90			NOPL			
  0x447423		90			NOPL			
  0x447424		90			NOPL			
  0x447425		90			NOPL			
  0x447426		90			NOPL			
  0x447427		90			NOPL			
  0x447428		90			NOPL			
  0x447429		90			NOPL			
  0x44742a		90			NOPL			
  0x44742b		90			NOPL			
  0x44742c		90			NOPL			
  0x44742d		90			NOPL			
  0x44742e		90			NOPL			
  0x44742f		90			NOPL			
  0x447430		90			NOPL			
  0x447431		90			NOPL			
  0x447432		90			NOPL			
  0x447433		90			NOPL			
  0x447434		90			NOPL			
  0x447435		90			NOPL			
  0x447436		90			NOPL			
  0x447437		90			NOPL			
  0x447438		90			NOPL			
  0x447439		90			NOPL			
  0x44743a		90			NOPL			
  0x44743b		90			NOPL			
  0x44743c		90			NOPL			
  0x44743d		90			NOPL			
  0x44743e		90			NOPL			
  0x44743f		90			NOPL			
  0x447440		90			NOPL			
  0x447441		90			NOPL			
  0x447442		90			NOPL			
  0x447443		90			NOPL			
  0x447444		90			NOPL			
  0x447445		90			NOPL			
  0x447446		90			NOPL			
  0x447447		90			NOPL			
  0x447448		90			NOPL			
  0x447449		90			NOPL			
  0x44744a		90			NOPL			
  0x44744b		90			NOPL			
  0x44744c		90			NOPL			
  0x44744d		90			NOPL			
  0x44744e		90			NOPL			
  0x44744f		90			NOPL			
  0x447450		90			NOPL			
  0x447451		90			NOPL			
  0x447452		90			NOPL			
  0x447453		90			NOPL			
  0x447454		90			NOPL			
  0x447455		90			NOPL			
  0x447456		90			NOPL			
  0x447457		90			NOPL			
  0x447458		90			NOPL			
  0x447459		90			NOPL			
  0x44745a		90			NOPL			
  0x44745b		90			NOPL			
  0x44745c		90			NOPL			
  0x44745d		90			NOPL			
  0x44745e		90			NOPL			
  0x44745f		90			NOPL			
  0x447460		90			NOPL			
  0x447461		90			NOPL			
  0x447462		90			NOPL			
  0x447463		90			NOPL			
  0x447464		90			NOPL			
  0x447465		90			NOPL			
  0x447466		90			NOPL			
  0x447467		90			NOPL			
  0x447468		90			NOPL			
  0x447469		90			NOPL			
  0x44746a		90			NOPL			
  0x44746b		90			NOPL			
  0x44746c		90			NOPL			
  0x44746d		90			NOPL			
  0x44746e		90			NOPL			
  0x44746f		90			NOPL			
  0x447470		90			NOPL			
  0x447471		90			NOPL			
  0x447472		90			NOPL			
  0x447473		90			NOPL			
  0x447474		90			NOPL			
  0x447475		90			NOPL			
  0x447476		90			NOPL			
  0x447477		90			NOPL			
  0x447478		90			NOPL			
  0x447479		90			NOPL			
  0x44747a		90			NOPL			
  0x44747b		90			NOPL			
  0x44747c		90			NOPL			
  0x44747d		90			NOPL			
  0x44747e		90			NOPL			
  0x44747f		90			NOPL			
  0x447480		90			NOPL			
  0x447481		90			NOPL			
  0x447482		90			NOPL			
  0x447483		90			NOPL			
  0x447484		90			NOPL			
  0x447485		90			NOPL			
  0x447486		90			NOPL			
  0x447487		90			NOPL			
  0x447488		90			NOPL			
  0x447489		90			NOPL			
  0x44748a		90			NOPL			
  0x44748b		90			NOPL			
  0x44748c		90			NOPL			
  0x44748d		90			NOPL			
  0x44748e		90			NOPL			
  0x44748f		90			NOPL			
  0x447490		90			NOPL			
  0x447491		90			NOPL			
  0x447492		90			NOPL			
  0x447493		90			NOPL			
  0x447494		90			NOPL			
  0x447495		90			NOPL			
  0x447496		90			NOPL			
  0x447497		90			NOPL			
  0x447498		90			NOPL			
  0x447499		90			NOPL			
  0x44749a		90			NOPL			
  0x44749b		90			NOPL			
  0x44749c		90			NOPL			
  0x44749d		90			NOPL			
  0x44749e		90			NOPL			
  0x44749f		90			NOPL			
  0x4474a0		90			NOPL			
  0x4474a1		90			NOPL			
  0x4474a2		90			NOPL			
  0x4474a3		90			NOPL			
  0x4474a4		90			NOPL			
  0x4474a5		90			NOPL			
  0x4474a6		90			NOPL			
  0x4474a7		90			NOPL			
  0x4474a8		90			NOPL			
  0x4474a9		90			NOPL			
  0x4474aa		90			NOPL			
  0x4474ab		90			NOPL			
  0x4474ac		90			NOPL			
  0x4474ad		90			NOPL			
  0x4474ae		90			NOPL			
  0x4474af		90			NOPL			
  0x4474b0		90			NOPL			
  0x4474b1		90			NOPL			
  0x4474b2		90			NOPL			
  0x4474b3		90			NOPL			
  0x4474b4		90			NOPL			
  0x4474b5		90			NOPL			
  0x4474b6		90			NOPL			
  0x4474b7		90			NOPL			
  0x4474b8		90			NOPL			
  0x4474b9		90			NOPL			
  0x4474ba		90			NOPL			
  0x4474bb		90			NOPL			
  0x4474bc		90			NOPL			
  0x4474bd		90			NOPL			
  0x4474be		90			NOPL			
  0x4474bf		90			NOPL			
  0x4474c0		90			NOPL			
  0x4474c1		90			NOPL			
  0x4474c2		90			NOPL			
  0x4474c3		90			NOPL			
  0x4474c4		90			NOPL			
  0x4474c5		90			NOPL			
  0x4474c6		90			NOPL			
  0x4474c7		90			NOPL			
  0x4474c8		90			NOPL			
  0x4474c9		90			NOPL			
  0x4474ca		90			NOPL			
  0x4474cb		90			NOPL			
  0x4474cc		90			NOPL			
  0x4474cd		90			NOPL			
  0x4474ce		90			NOPL			
  0x4474cf		90			NOPL			
  0x4474d0		90			NOPL			
  0x4474d1		90			NOPL			
  0x4474d2		90			NOPL			
  0x4474d3		90			NOPL			
  0x4474d4		90			NOPL			
  0x4474d5		90			NOPL			
  0x4474d6		90			NOPL			
  0x4474d7		90			NOPL			
  0x4474d8		90			NOPL			
  0x4474d9		90			NOPL			
  0x4474da		90			NOPL			
  0x4474db		90			NOPL			
  0x4474dc		90			NOPL			
  0x4474dd		90			NOPL			
  0x4474de		90			NOPL			
  0x4474df		90			NOPL			
  0x4474e0		90			NOPL			
  0x4474e1		90			NOPL			
  0x4474e2		90			NOPL			
  0x4474e3		90			NOPL			
  0x4474e4		90			NOPL			
  0x4474e5		90			NOPL			
  0x4474e6		90			NOPL			
  0x4474e7		90			NOPL			
  0x4474e8		90			NOPL			
  0x4474e9		90			NOPL			
  0x4474ea		90			NOPL			
  0x4474eb		90			NOPL			
  0x4474ec		90			NOPL			
  0x4474ed		90			NOPL			
  0x4474ee		90			NOPL			
  0x4474ef		90			NOPL			

TEXT _rt0_amd64(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4474f0		488b3c24		MOVQ 0(SP), DI		

  0x4474f4		488d742408		LEAQ 0x8(SP), SI	

  0x4474f9		e902000000		JMP runtime.rt0_go(SB)	

TEXT runtime.rt0_go(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447500		4889f8			MOVQ DI, AX		

  0x447503		4889f3			MOVQ SI, BX		

  0x447506		4883ec27		SUBQ $0x27, SP		

  0x44750a		4883e4f0		ANDQ $-0x10, SP		

  0x44750e		4889442410		MOVQ AX, 0x10(SP)	

  0x447513		48895c2418		MOVQ BX, 0x18(SP)	

  0x447518		488d3de1a80700		LEAQ runtime.g0(SB), DI	

  0x44751f		488d9c246800ffff	LEAQ 0xffff0068(SP), BX	

  0x447527		48895f10		MOVQ BX, 0x10(DI)	

  0x44752b		48895f18		MOVQ BX, 0x18(DI)	

  0x44752f		48891f			MOVQ BX, 0(DI)		

  0x447532		48896708		MOVQ SP, 0x8(DI)	

  0x447536		b800000000		MOVL $0x0, AX		

  0x44753b		0fa2			CPUID			

  0x44753d		89c6			MOVL AX, SI		

  0x44753f		83f800			CMPL $0x0, AX		

  0x447542		7433			JE 0x447577		

  0x447544		81fb47656e75		CMPL $0x756e6547, BX	

  0x44754a		751e			JNE 0x44756a		

  0x44754c		81fa696e6549		CMPL $0x49656e69, DX	

  0x447552		7516			JNE 0x44756a		

  0x447554		81f96e74656c		CMPL $0x6c65746e, CX	

  0x44755a		750e			JNE 0x44756a		

  0x44755c		c6054957090001		MOVB $0x1, runtime.isIntel(SB)	

  0x447563		c6054657090001		MOVB $0x1, runtime.lfenceBeforeRdtsc(SB)	

  0x44756a		b801000000		MOVL $0x1, AX		

  0x44756f		0fa2			CPUID			

  0x447571		890581570900		MOVL AX, runtime.processorVersionInfo(SB)	

  0x447577		488b054aa30700		MOVQ _cgo_init(SB), AX	

  0x44757e		4885c0			TESTQ AX, AX		

  0x447581		7426			JE 0x4475a9		

  0x447583		4889f9			MOVQ DI, CX		

  0x447586		488d35431a0000		LEAQ setg_gcc(SB), SI	

  0x44758d		ffd0			CALL AX			

  0x44758f		488d0d6aa80700		LEAQ runtime.g0(SB), CX	

  0x447596		488b01			MOVQ 0(CX), AX		

  0x447599		480570030000		ADDQ $0x370, AX		

  0x44759f		48894110		MOVQ AX, 0x10(CX)	

  0x4475a3		48894118		MOVQ AX, 0x18(CX)	

  0x4475a7		eb2d			JMP 0x4475d6		

  0x4475a9		488d3d38ae0700		LEAQ runtime.m0+136(SB), DI	

  0x4475b0		e8eb3f0000		CALL runtime.settls(SB)	

  0x4475b5		6448c70425f8ffffff23010000	MOVQ $0x123, FS:0xfffffff8	

  0x4475c2		488b051fae0700		MOVQ runtime.m0+136(SB), AX	

  0x4475c9		483d23010000		CMPQ $0x123, AX		

  0x4475cf		7405			JE 0x4475d6		

  0x4475d1		e80a1a0000		CALL runtime.abort(SB)	

  0x4475d6		488d0d23a80700		LEAQ runtime.g0(SB), CX	

  0x4475dd		6448890c25f8ffffff	MOVQ CX, FS:0xfffffff8	

  0x4475e6		488d0573ad0700		LEAQ runtime.m0(SB), AX	

  0x4475ed		488908			MOVQ CX, 0(AX)		

  0x4475f0		48894130		MOVQ AX, 0x30(CX)	

  0x4475f4		fc			CLD			

  0x4475f5		e896a2feff		CALL runtime.check(SB)	

  0x4475fa		8b442410		MOVL 0x10(SP), AX	

  0x4475fe		890424			MOVL AX, 0(SP)		

  0x447601		488b442418		MOVQ 0x18(SP), AX	

  0x447606		4889442408		MOVQ AX, 0x8(SP)	

  0x44760b		e8209dfeff		CALL runtime.args(SB)	

  0x447610		e8bba4fdff		CALL runtime.osinit(SB)	

  0x447615		e886e8fdff		CALL runtime.schedinit(SB)	

  0x44761a		488d0507570300		LEAQ runtime.mainPC(SB), AX	

  0x447621		50			PUSHL AX		

  0x447622		6a00			PUSHL $0x0		

  0x447624		e8274ffeff		CALL runtime.newproc(SB)	

  0x447629		58			POPL AX			

  0x44762a		58			POPL AX			

  0x44762b		e81003feff		CALL runtime.mstart(SB)	

  0x447630		e8ab190000		CALL runtime.abort(SB)	

  0x447635		c3			RET			

  0x447636		488d0543210000		LEAQ runtime.debugCallV1(SB), AX	

  0x44763d		c3			RET			

TEXT runtime.asminit(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447640		c3			RET			

TEXT runtime.gogo(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447650		4883ec18		SUBQ $0x18, SP		
  0x447654		48896c2410		MOVQ BP, 0x10(SP)	
  0x447659		488d6c2410		LEAQ 0x10(SP), BP	

  0x44765e		488b5c2420		MOVQ 0x20(SP), BX	

  0x447663		488b5310		MOVQ 0x10(BX), DX	

  0x447667		488b0a			MOVQ 0(DX), CX		

  0x44766a		6448891425f8ffffff	MOVQ DX, FS:0xfffffff8	

  0x447673		488b23			MOVQ 0(BX), SP		

  0x447676		488b4320		MOVQ 0x20(BX), AX	

  0x44767a		488b5318		MOVQ 0x18(BX), DX	

  0x44767e		488b6b30		MOVQ 0x30(BX), BP	

  0x447682		48c70300000000		MOVQ $0x0, 0(BX)	

  0x447689		48c7432000000000	MOVQ $0x0, 0x20(BX)	

  0x447691		48c7431800000000	MOVQ $0x0, 0x18(BX)	

  0x447699		48c7433000000000	MOVQ $0x0, 0x30(BX)	

  0x4476a1		488b5b08		MOVQ 0x8(BX), BX	

  0x4476a5		ffe3			JMP BX			

TEXT runtime.mcall(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4476b0		488b7c2408		MOVQ 0x8(SP), DI	

  0x4476b5		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x4476be		488b1c24		MOVQ 0(SP), BX		

  0x4476c2		48895840		MOVQ BX, 0x40(AX)	

  0x4476c6		488d5c2408		LEAQ 0x8(SP), BX	

  0x4476cb		48895838		MOVQ BX, 0x38(AX)	

  0x4476cf		48894048		MOVQ AX, 0x48(AX)	

  0x4476d3		48896868		MOVQ BP, 0x68(AX)	

  0x4476d7		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	

  0x4476e0		488b5b30		MOVQ 0x30(BX), BX	

  0x4476e4		488b33			MOVQ 0(BX), SI		

  0x4476e7		4839c6			CMPQ AX, SI		

  0x4476ea		7509			JNE 0x4476f5		

  0x4476ec		488d056de3fdff		LEAQ 0xfffde36d(IP), AX	

  0x4476f3		ffe0			JMP AX			

  0x4476f5		6448893425f8ffffff	MOVQ SI, FS:0xfffffff8	

  0x4476fe		488b6638		MOVQ 0x38(SI), SP	

  0x447702		50			PUSHL AX		

  0x447703		4889fa			MOVQ DI, DX		

  0x447706		488b3f			MOVQ 0(DI), DI		

  0x447709		ffd7			CALL DI			

  0x44770b		58			POPL AX			

  0x44770c		488d058de3fdff		LEAQ 0xfffde38d(IP), AX	

  0x447713		ffe0			JMP AX			

  0x447715		c3			RET			

TEXT runtime.systemstack_switch(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447720		c3			RET			

TEXT runtime.systemstack(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447730		488b7c2408		MOVQ 0x8(SP), DI	

  0x447735		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44773e		488b5830		MOVQ 0x30(AX), BX	

  0x447742		483b4350		CMPQ 0x50(BX), AX	

  0x447746		7478			JE 0x4477c0		

  0x447748		488b13			MOVQ 0(BX), DX		

  0x44774b		4839d0			CMPQ DX, AX		

  0x44774e		7470			JE 0x4477c0		

  0x447750		483b83c0000000		CMPQ 0xc0(BX), AX	

  0x447757		756f			JNE 0x4477c8		

  0x447759		488d35c0ffffff		LEAQ 0xffffffc0(IP), SI	

  0x447760		48897040		MOVQ SI, 0x40(AX)	

  0x447764		48896038		MOVQ SP, 0x38(AX)	

  0x447768		48894048		MOVQ AX, 0x48(AX)	

  0x44776c		48896868		MOVQ BP, 0x68(AX)	

  0x447770		6448891425f8ffffff	MOVQ DX, FS:0xfffffff8	

  0x447779		488b5a38		MOVQ 0x38(DX), BX	

  0x44777d		4883eb08		SUBQ $0x8, BX		

  0x447781		488d15b801feff		LEAQ 0xfffe01b8(IP), DX	

  0x447788		488913			MOVQ DX, 0(BX)		

  0x44778b		4889dc			MOVQ BX, SP		

  0x44778e		4889fa			MOVQ DI, DX		

  0x447791		488b3f			MOVQ 0(DI), DI		

  0x447794		ffd7			CALL DI			

  0x447796		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44779f		488b5830		MOVQ 0x30(AX), BX	

  0x4477a3		488b83c0000000		MOVQ 0xc0(BX), AX	

  0x4477aa		6448890425f8ffffff	MOVQ AX, FS:0xfffffff8	

  0x4477b3		488b6038		MOVQ 0x38(AX), SP	

  0x4477b7		48c7403800000000	MOVQ $0x0, 0x38(AX)	

  0x4477bf		c3			RET			

  0x4477c0		4889fa			MOVQ DI, DX		

  0x4477c3		488b3f			MOVQ 0(DI), DI		

  0x4477c6		ffe7			JMP DI			

  0x4477c8		488d05f128ffff		LEAQ 0xffff28f1(IP), AX	

  0x4477cf		ffd0			CALL AX			

  0x4477d1		cd03			INT $0x3		

TEXT runtime.morestack(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4477e0		64488b1c25f8ffffff	MOVQ FS:0xfffffff8, BX	

  0x4477e9		488b5b30		MOVQ 0x30(BX), BX	

  0x4477ed		488b33			MOVQ 0(BX), SI		

  0x4477f0		6448393425f8ffffff	CMPQ SI, FS:0xfffffff8	

  0x4477f9		750a			JNE 0x447805		

  0x4477fb		e830e3fdff		CALL runtime.badmorestackg0(SB)	

  0x447800		e8db170000		CALL runtime.abort(SB)	

  0x447805		488b7350		MOVQ 0x50(BX), SI	

  0x447809		6448393425f8ffffff	CMPQ SI, FS:0xfffffff8	

  0x447812		750a			JNE 0x44781e		

  0x447814		e857e3fdff		CALL runtime.badmorestackgsignal(SB)	

  0x447819		e8c2170000		CALL runtime.abort(SB)	

  0x44781e		488b442408		MOVQ 0x8(SP), AX	

  0x447823		48894310		MOVQ AX, 0x10(BX)	

  0x447827		488d442410		LEAQ 0x10(SP), AX	

  0x44782c		48894308		MOVQ AX, 0x8(BX)	

  0x447830		64488b3425f8ffffff	MOVQ FS:0xfffffff8, SI	

  0x447839		48897318		MOVQ SI, 0x18(BX)	

  0x44783d		488b0424		MOVQ 0(SP), AX		

  0x447841		48894640		MOVQ AX, 0x40(SI)	

  0x447845		48897648		MOVQ SI, 0x48(SI)	

  0x447849		488d442408		LEAQ 0x8(SP), AX	

  0x44784e		48894638		MOVQ AX, 0x38(SI)	

  0x447852		48896e68		MOVQ BP, 0x68(SI)	

  0x447856		48895650		MOVQ DX, 0x50(SI)	

  0x44785a		488b1b			MOVQ 0(BX), BX		

  0x44785d		6448891c25f8ffffff	MOVQ BX, FS:0xfffffff8	

  0x447866		488b6338		MOVQ 0x38(BX), SP	

  0x44786a		e87105ffff		CALL runtime.newstack(SB)	

  0x44786f		e86c170000		CALL runtime.abort(SB)	

  0x447874		c3			RET			

TEXT runtime.morestack_noctxt(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447880		ba00000000		MOVL $0x0, DX		

  0x447885		e956ffffff		JMP runtime.morestack(SB)	

TEXT runtime.reflectcall(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447890		8b4c2420		MOVL 0x20(SP), CX	

  0x447894		4883f920		CMPQ $0x20, CX			
  0x447898		7709			JA 0x4478a3			
  0x44789a		488d05ff010000		LEAQ runtime.call32(SB), AX	
  0x4478a1		ffe0			JMP AX				

  0x4478a3		4883f940		CMPQ $0x40, CX			
  0x4478a7		7709			JA 0x4478b2			
  0x4478a9		488d0570020000		LEAQ runtime.call64(SB), AX	
  0x4478b0		ffe0			JMP AX				

  0x4478b2		4881f980000000		CMPQ $0x80, CX			
  0x4478b9		7709			JA 0x4478c4			
  0x4478bb		488d05de020000		LEAQ runtime.call128(SB), AX	
  0x4478c2		ffe0			JMP AX				

  0x4478c4		4881f900010000		CMPQ $0x100, CX			
  0x4478cb		7709			JA 0x4478d6			
  0x4478cd		488d057c030000		LEAQ runtime.call256(SB), AX	
  0x4478d4		ffe0			JMP AX				

  0x4478d6		4881f900020000		CMPQ $0x200, CX			
  0x4478dd		7709			JA 0x4478e8			
  0x4478df		488d051a040000		LEAQ runtime.call512(SB), AX	
  0x4478e6		ffe0			JMP AX				

  0x4478e8		4881f900040000		CMPQ $0x400, CX			
  0x4478ef		7709			JA 0x4478fa			
  0x4478f1		488d05b8040000		LEAQ runtime.call1024(SB), AX	
  0x4478f8		ffe0			JMP AX				

  0x4478fa		4881f900080000		CMPQ $0x800, CX			
  0x447901		7709			JA 0x44790c			
  0x447903		488d0556050000		LEAQ runtime.call2048(SB), AX	
  0x44790a		ffe0			JMP AX				

  0x44790c		4881f900100000		CMPQ $0x1000, CX		
  0x447913		7709			JA 0x44791e			
  0x447915		488d05f4050000		LEAQ runtime.call4096(SB), AX	
  0x44791c		ffe0			JMP AX				

  0x44791e		4881f900200000		CMPQ $0x2000, CX		
  0x447925		7709			JA 0x447930			
  0x447927		488d05b2060000		LEAQ runtime.call8192(SB), AX	
  0x44792e		ffe0			JMP AX				

  0x447930		4881f900400000		CMPQ $0x4000, CX		
  0x447937		7709			JA 0x447942			
  0x447939		488d0570070000		LEAQ runtime.call16384(SB), AX	
  0x447940		ffe0			JMP AX				

  0x447942		4881f900800000		CMPQ $0x8000, CX		
  0x447949		7709			JA 0x447954			
  0x44794b		488d052e080000		LEAQ runtime.call32768(SB), AX	
  0x447952		ffe0			JMP AX				

  0x447954		4881f900000100		CMPQ $0x10000, CX		
  0x44795b		7709			JA 0x447966			
  0x44795d		488d05ec080000		LEAQ runtime.call65536(SB), AX	
  0x447964		ffe0			JMP AX				

  0x447966		4881f900000200		CMPQ $0x20000, CX		
  0x44796d		7709			JA 0x447978			
  0x44796f		488d05aa090000		LEAQ runtime.call131072(SB), AX	
  0x447976		ffe0			JMP AX				

  0x447978		4881f900000400		CMPQ $0x40000, CX		
  0x44797f		7709			JA 0x44798a			
  0x447981		488d05680a0000		LEAQ runtime.call262144(SB), AX	
  0x447988		ffe0			JMP AX				

  0x44798a		4881f900000800		CMPQ $0x80000, CX		
  0x447991		7709			JA 0x44799c			
  0x447993		488d05260b0000		LEAQ runtime.call524288(SB), AX	
  0x44799a		ffe0			JMP AX				

  0x44799c		4881f900001000		CMPQ $0x100000, CX			
  0x4479a3		7709			JA 0x4479ae				
  0x4479a5		488d05e40b0000		LEAQ runtime.call1048576(SB), AX	
  0x4479ac		ffe0			JMP AX					

  0x4479ae		4881f900002000		CMPQ $0x200000, CX			
  0x4479b5		7709			JA 0x4479c0				
  0x4479b7		488d05a20c0000		LEAQ runtime.call2097152(SB), AX	
  0x4479be		ffe0			JMP AX					

  0x4479c0		4881f900004000		CMPQ $0x400000, CX			
  0x4479c7		7709			JA 0x4479d2				
  0x4479c9		488d05600d0000		LEAQ runtime.call4194304(SB), AX	
  0x4479d0		ffe0			JMP AX					

  0x4479d2		4881f900008000		CMPQ $0x800000, CX			
  0x4479d9		7709			JA 0x4479e4				
  0x4479db		488d051e0e0000		LEAQ runtime.call8388608(SB), AX	
  0x4479e2		ffe0			JMP AX					

  0x4479e4		4881f900000001		CMPQ $0x1000000, CX			
  0x4479eb		7709			JA 0x4479f6				
  0x4479ed		488d05dc0e0000		LEAQ runtime.call16777216(SB), AX	
  0x4479f4		ffe0			JMP AX					

  0x4479f6		4881f900000002		CMPQ $0x2000000, CX			
  0x4479fd		7709			JA 0x447a08				
  0x4479ff		488d059a0f0000		LEAQ runtime.call33554432(SB), AX	
  0x447a06		ffe0			JMP AX					

  0x447a08		4881f900000004		CMPQ $0x4000000, CX			
  0x447a0f		7709			JA 0x447a1a				
  0x447a11		488d0558100000		LEAQ runtime.call67108864(SB), AX	
  0x447a18		ffe0			JMP AX					

  0x447a1a		4881f900000008		CMPQ $0x8000000, CX			
  0x447a21		7709			JA 0x447a2c				
  0x447a23		488d0516110000		LEAQ runtime.call134217728(SB), AX	
  0x447a2a		ffe0			JMP AX					

  0x447a2c		4881f900000010		CMPQ $0x10000000, CX			
  0x447a33		7709			JA 0x447a3e				
  0x447a35		488d05d4110000		LEAQ runtime.call268435456(SB), AX	
  0x447a3c		ffe0			JMP AX					

  0x447a3e		4881f900000020		CMPQ $0x20000000, CX			
  0x447a45		7709			JA 0x447a50				
  0x447a47		488d0592120000		LEAQ runtime.call536870912(SB), AX	
  0x447a4e		ffe0			JMP AX					

  0x447a50		4881f900000040		CMPQ $0x40000000, CX			
  0x447a57		7709			JA 0x447a62				
  0x447a59		488d0550130000		LEAQ runtime.call1073741824(SB), AX	
  0x447a60		ffe0			JMP AX					

  0x447a62		488d0577e0fdff		LEAQ 0xfffde077(IP), AX	

  0x447a69		ffe0			JMP AX			

TEXT callRet(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447a70		4883ec28		SUBQ $0x28, SP		
  0x447a74		48896c2420		MOVQ BP, 0x20(SP)	
  0x447a79		488d6c2420		LEAQ 0x20(SP), BP	

  0x447a7e		48891424		MOVQ DX, 0(SP)		

  0x447a82		48897c2408		MOVQ DI, 0x8(SP)	

  0x447a87		4889742410		MOVQ SI, 0x10(SP)	

  0x447a8c		48894c2418		MOVQ CX, 0x18(SP)	

  0x447a91		e8ca5bfcff		CALL runtime.reflectcallmove(SB)	

  0x447a96		488b6c2420		MOVQ 0x20(SP), BP	
  0x447a9b		4883c428		ADDQ $0x28, SP		
  0x447a9f		c3			RET			

TEXT runtime.call32(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447aa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447aa9		483b6110		CMPQ 0x10(CX), SP			
  0x447aad		7659			JBE 0x447b08				
  0x447aaf		4883ec28		SUBQ $0x28, SP				
  0x447ab3		48896c2420		MOVQ BP, 0x20(SP)			
  0x447ab8		488d6c2420		LEAQ 0x20(SP), BP			
  0x447abd		488b5920		MOVQ 0x20(CX), BX			
  0x447ac1		4885db			TESTQ BX, BX				
  0x447ac4		7549			JNE 0x447b0f				
  0x447ac6		488b742440		MOVQ 0x40(SP), SI			
  0x447acb		8b4c2448		MOVL 0x48(SP), CX			
  0x447acf		4889e7			MOVQ SP, DI				
  0x447ad2		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447ad4		488b542438		MOVQ 0x38(SP), DX			
  0x447ad9		ff12			CALL 0(DX)				
  0x447adb		488b542430		MOVQ 0x30(SP), DX			
  0x447ae0		488b7c2440		MOVQ 0x40(SP), DI			
  0x447ae5		8b4c2448		MOVL 0x48(SP), CX			
  0x447ae9		8b5c244c		MOVL 0x4c(SP), BX			
  0x447aed		4889e6			MOVQ SP, SI				
  0x447af0		4801df			ADDQ BX, DI				
  0x447af3		4801de			ADDQ BX, SI				
  0x447af6		4829d9			SUBQ BX, CX				
  0x447af9		e872ffffff		CALL callRet(SB)			
  0x447afe		488b6c2420		MOVQ 0x20(SP), BP			
  0x447b03		4883c428		ADDQ $0x28, SP				
  0x447b07		c3			RET					
  0x447b08		e873fdffff		CALL runtime.morestack_noctxt(SB)	
  0x447b0d		eb91			JMP runtime.call32(SB)			
  0x447b0f		488d7c2430		LEAQ 0x30(SP), DI			
  0x447b14		48393b			CMPQ DI, 0(BX)				
  0x447b17		75ad			JNE 0x447ac6				
  0x447b19		488923			MOVQ SP, 0(BX)				
  0x447b1c		eba8			JMP 0x447ac6				

TEXT runtime.call64(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447b20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447b29		483b6110		CMPQ 0x10(CX), SP			
  0x447b2d		7659			JBE 0x447b88				
  0x447b2f		4883ec48		SUBQ $0x48, SP				
  0x447b33		48896c2440		MOVQ BP, 0x40(SP)			
  0x447b38		488d6c2440		LEAQ 0x40(SP), BP			
  0x447b3d		488b5920		MOVQ 0x20(CX), BX			
  0x447b41		4885db			TESTQ BX, BX				
  0x447b44		7549			JNE 0x447b8f				
  0x447b46		488b742460		MOVQ 0x60(SP), SI			
  0x447b4b		8b4c2468		MOVL 0x68(SP), CX			
  0x447b4f		4889e7			MOVQ SP, DI				
  0x447b52		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447b54		488b542458		MOVQ 0x58(SP), DX			
  0x447b59		ff12			CALL 0(DX)				
  0x447b5b		488b542450		MOVQ 0x50(SP), DX			
  0x447b60		488b7c2460		MOVQ 0x60(SP), DI			
  0x447b65		8b4c2468		MOVL 0x68(SP), CX			
  0x447b69		8b5c246c		MOVL 0x6c(SP), BX			
  0x447b6d		4889e6			MOVQ SP, SI				
  0x447b70		4801df			ADDQ BX, DI				
  0x447b73		4801de			ADDQ BX, SI				
  0x447b76		4829d9			SUBQ BX, CX				
  0x447b79		e8f2feffff		CALL callRet(SB)			
  0x447b7e		488b6c2440		MOVQ 0x40(SP), BP			
  0x447b83		4883c448		ADDQ $0x48, SP				
  0x447b87		c3			RET					
  0x447b88		e8f3fcffff		CALL runtime.morestack_noctxt(SB)	
  0x447b8d		eb91			JMP runtime.call64(SB)			
  0x447b8f		488d7c2450		LEAQ 0x50(SP), DI			
  0x447b94		48393b			CMPQ DI, 0(BX)				
  0x447b97		75ad			JNE 0x447b46				
  0x447b99		488923			MOVQ SP, 0(BX)				
  0x447b9c		eba8			JMP 0x447b46				

TEXT runtime.call128(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447ba0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447ba9		488d4424f8		LEAQ -0x8(SP), AX			
  0x447bae		483b4110		CMPQ 0x10(CX), AX			
  0x447bb2		767d			JBE 0x447c31				
  0x447bb4		4881ec88000000		SUBQ $0x88, SP				
  0x447bbb		4889ac2480000000	MOVQ BP, 0x80(SP)			
  0x447bc3		488dac2480000000	LEAQ 0x80(SP), BP			
  0x447bcb		488b5920		MOVQ 0x20(CX), BX			
  0x447bcf		4885db			TESTQ BX, BX				
  0x447bd2		7567			JNE 0x447c3b				
  0x447bd4		488bb424a0000000	MOVQ 0xa0(SP), SI			
  0x447bdc		8b8c24a8000000		MOVL 0xa8(SP), CX			
  0x447be3		4889e7			MOVQ SP, DI				
  0x447be6		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447be8		488b942498000000	MOVQ 0x98(SP), DX			
  0x447bf0		ff12			CALL 0(DX)				
  0x447bf2		488b942490000000	MOVQ 0x90(SP), DX			
  0x447bfa		488bbc24a0000000	MOVQ 0xa0(SP), DI			
  0x447c02		8b8c24a8000000		MOVL 0xa8(SP), CX			
  0x447c09		8b9c24ac000000		MOVL 0xac(SP), BX			
  0x447c10		4889e6			MOVQ SP, SI				
  0x447c13		4801df			ADDQ BX, DI				
  0x447c16		4801de			ADDQ BX, SI				
  0x447c19		4829d9			SUBQ BX, CX				
  0x447c1c		e84ffeffff		CALL callRet(SB)			
  0x447c21		488bac2480000000	MOVQ 0x80(SP), BP			
  0x447c29		4881c488000000		ADDQ $0x88, SP				
  0x447c30		c3			RET					
  0x447c31		e84afcffff		CALL runtime.morestack_noctxt(SB)	
  0x447c36		e965ffffff		JMP runtime.call128(SB)			
  0x447c3b		488dbc2490000000	LEAQ 0x90(SP), DI			
  0x447c43		48393b			CMPQ DI, 0(BX)				
  0x447c46		758c			JNE 0x447bd4				
  0x447c48		488923			MOVQ SP, 0(BX)				
  0x447c4b		eb87			JMP 0x447bd4				

TEXT runtime.call256(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447c50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447c59		488d842478ffffff	LEAQ 0xffffff78(SP), AX			
  0x447c61		483b4110		CMPQ 0x10(CX), AX			
  0x447c65		767d			JBE 0x447ce4				
  0x447c67		4881ec08010000		SUBQ $0x108, SP				
  0x447c6e		4889ac2400010000	MOVQ BP, 0x100(SP)			
  0x447c76		488dac2400010000	LEAQ 0x100(SP), BP			
  0x447c7e		488b5920		MOVQ 0x20(CX), BX			
  0x447c82		4885db			TESTQ BX, BX				
  0x447c85		7567			JNE 0x447cee				
  0x447c87		488bb42420010000	MOVQ 0x120(SP), SI			
  0x447c8f		8b8c2428010000		MOVL 0x128(SP), CX			
  0x447c96		4889e7			MOVQ SP, DI				
  0x447c99		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447c9b		488b942418010000	MOVQ 0x118(SP), DX			
  0x447ca3		ff12			CALL 0(DX)				
  0x447ca5		488b942410010000	MOVQ 0x110(SP), DX			
  0x447cad		488bbc2420010000	MOVQ 0x120(SP), DI			
  0x447cb5		8b8c2428010000		MOVL 0x128(SP), CX			
  0x447cbc		8b9c242c010000		MOVL 0x12c(SP), BX			
  0x447cc3		4889e6			MOVQ SP, SI				
  0x447cc6		4801df			ADDQ BX, DI				
  0x447cc9		4801de			ADDQ BX, SI				
  0x447ccc		4829d9			SUBQ BX, CX				
  0x447ccf		e89cfdffff		CALL callRet(SB)			
  0x447cd4		488bac2400010000	MOVQ 0x100(SP), BP			
  0x447cdc		4881c408010000		ADDQ $0x108, SP				
  0x447ce3		c3			RET					
  0x447ce4		e897fbffff		CALL runtime.morestack_noctxt(SB)	
  0x447ce9		e962ffffff		JMP runtime.call256(SB)			
  0x447cee		488dbc2410010000	LEAQ 0x110(SP), DI			
  0x447cf6		48393b			CMPQ DI, 0(BX)				
  0x447cf9		758c			JNE 0x447c87				
  0x447cfb		488923			MOVQ SP, 0(BX)				
  0x447cfe		eb87			JMP 0x447c87				

TEXT runtime.call512(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447d00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447d09		488d842478feffff	LEAQ 0xfffffe78(SP), AX			
  0x447d11		483b4110		CMPQ 0x10(CX), AX			
  0x447d15		767d			JBE 0x447d94				
  0x447d17		4881ec08020000		SUBQ $0x208, SP				
  0x447d1e		4889ac2400020000	MOVQ BP, 0x200(SP)			
  0x447d26		488dac2400020000	LEAQ 0x200(SP), BP			
  0x447d2e		488b5920		MOVQ 0x20(CX), BX			
  0x447d32		4885db			TESTQ BX, BX				
  0x447d35		7567			JNE 0x447d9e				
  0x447d37		488bb42420020000	MOVQ 0x220(SP), SI			
  0x447d3f		8b8c2428020000		MOVL 0x228(SP), CX			
  0x447d46		4889e7			MOVQ SP, DI				
  0x447d49		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447d4b		488b942418020000	MOVQ 0x218(SP), DX			
  0x447d53		ff12			CALL 0(DX)				
  0x447d55		488b942410020000	MOVQ 0x210(SP), DX			
  0x447d5d		488bbc2420020000	MOVQ 0x220(SP), DI			
  0x447d65		8b8c2428020000		MOVL 0x228(SP), CX			
  0x447d6c		8b9c242c020000		MOVL 0x22c(SP), BX			
  0x447d73		4889e6			MOVQ SP, SI				
  0x447d76		4801df			ADDQ BX, DI				
  0x447d79		4801de			ADDQ BX, SI				
  0x447d7c		4829d9			SUBQ BX, CX				
  0x447d7f		e8ecfcffff		CALL callRet(SB)			
  0x447d84		488bac2400020000	MOVQ 0x200(SP), BP			
  0x447d8c		4881c408020000		ADDQ $0x208, SP				
  0x447d93		c3			RET					
  0x447d94		e8e7faffff		CALL runtime.morestack_noctxt(SB)	
  0x447d99		e962ffffff		JMP runtime.call512(SB)			
  0x447d9e		488dbc2410020000	LEAQ 0x210(SP), DI			
  0x447da6		48393b			CMPQ DI, 0(BX)				
  0x447da9		758c			JNE 0x447d37				
  0x447dab		488923			MOVQ SP, 0(BX)				
  0x447dae		eb87			JMP 0x447d37				

TEXT runtime.call1024(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447db0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447db9		488d842478fcffff	LEAQ 0xfffffc78(SP), AX			
  0x447dc1		483b4110		CMPQ 0x10(CX), AX			
  0x447dc5		767d			JBE 0x447e44				
  0x447dc7		4881ec08040000		SUBQ $0x408, SP				
  0x447dce		4889ac2400040000	MOVQ BP, 0x400(SP)			
  0x447dd6		488dac2400040000	LEAQ 0x400(SP), BP			
  0x447dde		488b5920		MOVQ 0x20(CX), BX			
  0x447de2		4885db			TESTQ BX, BX				
  0x447de5		7567			JNE 0x447e4e				
  0x447de7		488bb42420040000	MOVQ 0x420(SP), SI			
  0x447def		8b8c2428040000		MOVL 0x428(SP), CX			
  0x447df6		4889e7			MOVQ SP, DI				
  0x447df9		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447dfb		488b942418040000	MOVQ 0x418(SP), DX			
  0x447e03		ff12			CALL 0(DX)				
  0x447e05		488b942410040000	MOVQ 0x410(SP), DX			
  0x447e0d		488bbc2420040000	MOVQ 0x420(SP), DI			
  0x447e15		8b8c2428040000		MOVL 0x428(SP), CX			
  0x447e1c		8b9c242c040000		MOVL 0x42c(SP), BX			
  0x447e23		4889e6			MOVQ SP, SI				
  0x447e26		4801df			ADDQ BX, DI				
  0x447e29		4801de			ADDQ BX, SI				
  0x447e2c		4829d9			SUBQ BX, CX				
  0x447e2f		e83cfcffff		CALL callRet(SB)			
  0x447e34		488bac2400040000	MOVQ 0x400(SP), BP			
  0x447e3c		4881c408040000		ADDQ $0x408, SP				
  0x447e43		c3			RET					
  0x447e44		e837faffff		CALL runtime.morestack_noctxt(SB)	
  0x447e49		e962ffffff		JMP runtime.call1024(SB)		
  0x447e4e		488dbc2410040000	LEAQ 0x410(SP), DI			
  0x447e56		48393b			CMPQ DI, 0(BX)				
  0x447e59		758c			JNE 0x447de7				
  0x447e5b		488923			MOVQ SP, 0(BX)				
  0x447e5e		eb87			JMP 0x447de7				

TEXT runtime.call2048(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447e60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447e69		488d842478f8ffff	LEAQ 0xfffff878(SP), AX			
  0x447e71		483b4110		CMPQ 0x10(CX), AX			
  0x447e75		767d			JBE 0x447ef4				
  0x447e77		4881ec08080000		SUBQ $0x808, SP				
  0x447e7e		4889ac2400080000	MOVQ BP, 0x800(SP)			
  0x447e86		488dac2400080000	LEAQ 0x800(SP), BP			
  0x447e8e		488b5920		MOVQ 0x20(CX), BX			
  0x447e92		4885db			TESTQ BX, BX				
  0x447e95		7567			JNE 0x447efe				
  0x447e97		488bb42420080000	MOVQ 0x820(SP), SI			
  0x447e9f		8b8c2428080000		MOVL 0x828(SP), CX			
  0x447ea6		4889e7			MOVQ SP, DI				
  0x447ea9		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447eab		488b942418080000	MOVQ 0x818(SP), DX			
  0x447eb3		ff12			CALL 0(DX)				
  0x447eb5		488b942410080000	MOVQ 0x810(SP), DX			
  0x447ebd		488bbc2420080000	MOVQ 0x820(SP), DI			
  0x447ec5		8b8c2428080000		MOVL 0x828(SP), CX			
  0x447ecc		8b9c242c080000		MOVL 0x82c(SP), BX			
  0x447ed3		4889e6			MOVQ SP, SI				
  0x447ed6		4801df			ADDQ BX, DI				
  0x447ed9		4801de			ADDQ BX, SI				
  0x447edc		4829d9			SUBQ BX, CX				
  0x447edf		e88cfbffff		CALL callRet(SB)			
  0x447ee4		488bac2400080000	MOVQ 0x800(SP), BP			
  0x447eec		4881c408080000		ADDQ $0x808, SP				
  0x447ef3		c3			RET					
  0x447ef4		e887f9ffff		CALL runtime.morestack_noctxt(SB)	
  0x447ef9		e962ffffff		JMP runtime.call2048(SB)		
  0x447efe		488dbc2410080000	LEAQ 0x810(SP), DI			
  0x447f06		48393b			CMPQ DI, 0(BX)				
  0x447f09		758c			JNE 0x447e97				
  0x447f0b		488923			MOVQ SP, 0(BX)				
  0x447f0e		eb87			JMP 0x447e97				

TEXT runtime.call4096(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447f10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447f19		488b7110		MOVQ 0x10(CX), SI			
  0x447f1d		4881fedefaffff		CMPQ $-0x522, SI			
  0x447f24		0f8490000000		JE 0x447fba				
  0x447f2a		488d842470030000	LEAQ 0x370(SP), AX			
  0x447f32		4829f0			SUBQ SI, AX				
  0x447f35		483df8120000		CMPQ $0x12f8, AX			
  0x447f3b		767d			JBE 0x447fba				
  0x447f3d		4881ec08100000		SUBQ $0x1008, SP			
  0x447f44		4889ac2400100000	MOVQ BP, 0x1000(SP)			
  0x447f4c		488dac2400100000	LEAQ 0x1000(SP), BP			
  0x447f54		488b5920		MOVQ 0x20(CX), BX			
  0x447f58		4885db			TESTQ BX, BX				
  0x447f5b		7567			JNE 0x447fc4				
  0x447f5d		488bb42420100000	MOVQ 0x1020(SP), SI			
  0x447f65		8b8c2428100000		MOVL 0x1028(SP), CX			
  0x447f6c		4889e7			MOVQ SP, DI				
  0x447f6f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x447f71		488b942418100000	MOVQ 0x1018(SP), DX			
  0x447f79		ff12			CALL 0(DX)				
  0x447f7b		488b942410100000	MOVQ 0x1010(SP), DX			
  0x447f83		488bbc2420100000	MOVQ 0x1020(SP), DI			
  0x447f8b		8b8c2428100000		MOVL 0x1028(SP), CX			
  0x447f92		8b9c242c100000		MOVL 0x102c(SP), BX			
  0x447f99		4889e6			MOVQ SP, SI				
  0x447f9c		4801df			ADDQ BX, DI				
  0x447f9f		4801de			ADDQ BX, SI				
  0x447fa2		4829d9			SUBQ BX, CX				
  0x447fa5		e8c6faffff		CALL callRet(SB)			
  0x447faa		488bac2400100000	MOVQ 0x1000(SP), BP			
  0x447fb2		4881c408100000		ADDQ $0x1008, SP			
  0x447fb9		c3			RET					
  0x447fba		e8c1f8ffff		CALL runtime.morestack_noctxt(SB)	
  0x447fbf		e94cffffff		JMP runtime.call4096(SB)		
  0x447fc4		488dbc2410100000	LEAQ 0x1010(SP), DI			
  0x447fcc		48393b			CMPQ DI, 0(BX)				
  0x447fcf		758c			JNE 0x447f5d				
  0x447fd1		488923			MOVQ SP, 0(BX)				
  0x447fd4		eb87			JMP 0x447f5d				

TEXT runtime.call8192(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x447fe0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x447fe9		488b7110		MOVQ 0x10(CX), SI			
  0x447fed		4881fedefaffff		CMPQ $-0x522, SI			
  0x447ff4		0f8490000000		JE 0x44808a				
  0x447ffa		488d842470030000	LEAQ 0x370(SP), AX			
  0x448002		4829f0			SUBQ SI, AX				
  0x448005		483df8220000		CMPQ $0x22f8, AX			
  0x44800b		767d			JBE 0x44808a				
  0x44800d		4881ec08200000		SUBQ $0x2008, SP			
  0x448014		4889ac2400200000	MOVQ BP, 0x2000(SP)			
  0x44801c		488dac2400200000	LEAQ 0x2000(SP), BP			
  0x448024		488b5920		MOVQ 0x20(CX), BX			
  0x448028		4885db			TESTQ BX, BX				
  0x44802b		7567			JNE 0x448094				
  0x44802d		488bb42420200000	MOVQ 0x2020(SP), SI			
  0x448035		8b8c2428200000		MOVL 0x2028(SP), CX			
  0x44803c		4889e7			MOVQ SP, DI				
  0x44803f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448041		488b942418200000	MOVQ 0x2018(SP), DX			
  0x448049		ff12			CALL 0(DX)				
  0x44804b		488b942410200000	MOVQ 0x2010(SP), DX			
  0x448053		488bbc2420200000	MOVQ 0x2020(SP), DI			
  0x44805b		8b8c2428200000		MOVL 0x2028(SP), CX			
  0x448062		8b9c242c200000		MOVL 0x202c(SP), BX			
  0x448069		4889e6			MOVQ SP, SI				
  0x44806c		4801df			ADDQ BX, DI				
  0x44806f		4801de			ADDQ BX, SI				
  0x448072		4829d9			SUBQ BX, CX				
  0x448075		e8f6f9ffff		CALL callRet(SB)			
  0x44807a		488bac2400200000	MOVQ 0x2000(SP), BP			
  0x448082		4881c408200000		ADDQ $0x2008, SP			
  0x448089		c3			RET					
  0x44808a		e8f1f7ffff		CALL runtime.morestack_noctxt(SB)	
  0x44808f		e94cffffff		JMP runtime.call8192(SB)		
  0x448094		488dbc2410200000	LEAQ 0x2010(SP), DI			
  0x44809c		48393b			CMPQ DI, 0(BX)				
  0x44809f		758c			JNE 0x44802d				
  0x4480a1		488923			MOVQ SP, 0(BX)				
  0x4480a4		eb87			JMP 0x44802d				

TEXT runtime.call16384(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4480b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4480b9		488b7110		MOVQ 0x10(CX), SI			
  0x4480bd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4480c4		0f8490000000		JE 0x44815a				
  0x4480ca		488d842470030000	LEAQ 0x370(SP), AX			
  0x4480d2		4829f0			SUBQ SI, AX				
  0x4480d5		483df8420000		CMPQ $0x42f8, AX			
  0x4480db		767d			JBE 0x44815a				
  0x4480dd		4881ec08400000		SUBQ $0x4008, SP			
  0x4480e4		4889ac2400400000	MOVQ BP, 0x4000(SP)			
  0x4480ec		488dac2400400000	LEAQ 0x4000(SP), BP			
  0x4480f4		488b5920		MOVQ 0x20(CX), BX			
  0x4480f8		4885db			TESTQ BX, BX				
  0x4480fb		7567			JNE 0x448164				
  0x4480fd		488bb42420400000	MOVQ 0x4020(SP), SI			
  0x448105		8b8c2428400000		MOVL 0x4028(SP), CX			
  0x44810c		4889e7			MOVQ SP, DI				
  0x44810f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448111		488b942418400000	MOVQ 0x4018(SP), DX			
  0x448119		ff12			CALL 0(DX)				
  0x44811b		488b942410400000	MOVQ 0x4010(SP), DX			
  0x448123		488bbc2420400000	MOVQ 0x4020(SP), DI			
  0x44812b		8b8c2428400000		MOVL 0x4028(SP), CX			
  0x448132		8b9c242c400000		MOVL 0x402c(SP), BX			
  0x448139		4889e6			MOVQ SP, SI				
  0x44813c		4801df			ADDQ BX, DI				
  0x44813f		4801de			ADDQ BX, SI				
  0x448142		4829d9			SUBQ BX, CX				
  0x448145		e826f9ffff		CALL callRet(SB)			
  0x44814a		488bac2400400000	MOVQ 0x4000(SP), BP			
  0x448152		4881c408400000		ADDQ $0x4008, SP			
  0x448159		c3			RET					
  0x44815a		e821f7ffff		CALL runtime.morestack_noctxt(SB)	
  0x44815f		e94cffffff		JMP runtime.call16384(SB)		
  0x448164		488dbc2410400000	LEAQ 0x4010(SP), DI			
  0x44816c		48393b			CMPQ DI, 0(BX)				
  0x44816f		758c			JNE 0x4480fd				
  0x448171		488923			MOVQ SP, 0(BX)				
  0x448174		eb87			JMP 0x4480fd				

TEXT runtime.call32768(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448180		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448189		488b7110		MOVQ 0x10(CX), SI			
  0x44818d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448194		0f8490000000		JE 0x44822a				
  0x44819a		488d842470030000	LEAQ 0x370(SP), AX			
  0x4481a2		4829f0			SUBQ SI, AX				
  0x4481a5		483df8820000		CMPQ $0x82f8, AX			
  0x4481ab		767d			JBE 0x44822a				
  0x4481ad		4881ec08800000		SUBQ $0x8008, SP			
  0x4481b4		4889ac2400800000	MOVQ BP, 0x8000(SP)			
  0x4481bc		488dac2400800000	LEAQ 0x8000(SP), BP			
  0x4481c4		488b5920		MOVQ 0x20(CX), BX			
  0x4481c8		4885db			TESTQ BX, BX				
  0x4481cb		7567			JNE 0x448234				
  0x4481cd		488bb42420800000	MOVQ 0x8020(SP), SI			
  0x4481d5		8b8c2428800000		MOVL 0x8028(SP), CX			
  0x4481dc		4889e7			MOVQ SP, DI				
  0x4481df		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4481e1		488b942418800000	MOVQ 0x8018(SP), DX			
  0x4481e9		ff12			CALL 0(DX)				
  0x4481eb		488b942410800000	MOVQ 0x8010(SP), DX			
  0x4481f3		488bbc2420800000	MOVQ 0x8020(SP), DI			
  0x4481fb		8b8c2428800000		MOVL 0x8028(SP), CX			
  0x448202		8b9c242c800000		MOVL 0x802c(SP), BX			
  0x448209		4889e6			MOVQ SP, SI				
  0x44820c		4801df			ADDQ BX, DI				
  0x44820f		4801de			ADDQ BX, SI				
  0x448212		4829d9			SUBQ BX, CX				
  0x448215		e856f8ffff		CALL callRet(SB)			
  0x44821a		488bac2400800000	MOVQ 0x8000(SP), BP			
  0x448222		4881c408800000		ADDQ $0x8008, SP			
  0x448229		c3			RET					
  0x44822a		e851f6ffff		CALL runtime.morestack_noctxt(SB)	
  0x44822f		e94cffffff		JMP runtime.call32768(SB)		
  0x448234		488dbc2410800000	LEAQ 0x8010(SP), DI			
  0x44823c		48393b			CMPQ DI, 0(BX)				
  0x44823f		758c			JNE 0x4481cd				
  0x448241		488923			MOVQ SP, 0(BX)				
  0x448244		eb87			JMP 0x4481cd				

TEXT runtime.call65536(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448250		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448259		488b7110		MOVQ 0x10(CX), SI			
  0x44825d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448264		0f8490000000		JE 0x4482fa				
  0x44826a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448272		4829f0			SUBQ SI, AX				
  0x448275		483df8020100		CMPQ $0x102f8, AX			
  0x44827b		767d			JBE 0x4482fa				
  0x44827d		4881ec08000100		SUBQ $0x10008, SP			
  0x448284		4889ac2400000100	MOVQ BP, 0x10000(SP)			
  0x44828c		488dac2400000100	LEAQ 0x10000(SP), BP			
  0x448294		488b5920		MOVQ 0x20(CX), BX			
  0x448298		4885db			TESTQ BX, BX				
  0x44829b		7567			JNE 0x448304				
  0x44829d		488bb42420000100	MOVQ 0x10020(SP), SI			
  0x4482a5		8b8c2428000100		MOVL 0x10028(SP), CX			
  0x4482ac		4889e7			MOVQ SP, DI				
  0x4482af		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4482b1		488b942418000100	MOVQ 0x10018(SP), DX			
  0x4482b9		ff12			CALL 0(DX)				
  0x4482bb		488b942410000100	MOVQ 0x10010(SP), DX			
  0x4482c3		488bbc2420000100	MOVQ 0x10020(SP), DI			
  0x4482cb		8b8c2428000100		MOVL 0x10028(SP), CX			
  0x4482d2		8b9c242c000100		MOVL 0x1002c(SP), BX			
  0x4482d9		4889e6			MOVQ SP, SI				
  0x4482dc		4801df			ADDQ BX, DI				
  0x4482df		4801de			ADDQ BX, SI				
  0x4482e2		4829d9			SUBQ BX, CX				
  0x4482e5		e886f7ffff		CALL callRet(SB)			
  0x4482ea		488bac2400000100	MOVQ 0x10000(SP), BP			
  0x4482f2		4881c408000100		ADDQ $0x10008, SP			
  0x4482f9		c3			RET					
  0x4482fa		e881f5ffff		CALL runtime.morestack_noctxt(SB)	
  0x4482ff		e94cffffff		JMP runtime.call65536(SB)		
  0x448304		488dbc2410000100	LEAQ 0x10010(SP), DI			
  0x44830c		48393b			CMPQ DI, 0(BX)				
  0x44830f		758c			JNE 0x44829d				
  0x448311		488923			MOVQ SP, 0(BX)				
  0x448314		eb87			JMP 0x44829d				

TEXT runtime.call131072(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448320		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448329		488b7110		MOVQ 0x10(CX), SI			
  0x44832d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448334		0f8490000000		JE 0x4483ca				
  0x44833a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448342		4829f0			SUBQ SI, AX				
  0x448345		483df8020200		CMPQ $0x202f8, AX			
  0x44834b		767d			JBE 0x4483ca				
  0x44834d		4881ec08000200		SUBQ $0x20008, SP			
  0x448354		4889ac2400000200	MOVQ BP, 0x20000(SP)			
  0x44835c		488dac2400000200	LEAQ 0x20000(SP), BP			
  0x448364		488b5920		MOVQ 0x20(CX), BX			
  0x448368		4885db			TESTQ BX, BX				
  0x44836b		7567			JNE 0x4483d4				
  0x44836d		488bb42420000200	MOVQ 0x20020(SP), SI			
  0x448375		8b8c2428000200		MOVL 0x20028(SP), CX			
  0x44837c		4889e7			MOVQ SP, DI				
  0x44837f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448381		488b942418000200	MOVQ 0x20018(SP), DX			
  0x448389		ff12			CALL 0(DX)				
  0x44838b		488b942410000200	MOVQ 0x20010(SP), DX			
  0x448393		488bbc2420000200	MOVQ 0x20020(SP), DI			
  0x44839b		8b8c2428000200		MOVL 0x20028(SP), CX			
  0x4483a2		8b9c242c000200		MOVL 0x2002c(SP), BX			
  0x4483a9		4889e6			MOVQ SP, SI				
  0x4483ac		4801df			ADDQ BX, DI				
  0x4483af		4801de			ADDQ BX, SI				
  0x4483b2		4829d9			SUBQ BX, CX				
  0x4483b5		e8b6f6ffff		CALL callRet(SB)			
  0x4483ba		488bac2400000200	MOVQ 0x20000(SP), BP			
  0x4483c2		4881c408000200		ADDQ $0x20008, SP			
  0x4483c9		c3			RET					
  0x4483ca		e8b1f4ffff		CALL runtime.morestack_noctxt(SB)	
  0x4483cf		e94cffffff		JMP runtime.call131072(SB)		
  0x4483d4		488dbc2410000200	LEAQ 0x20010(SP), DI			
  0x4483dc		48393b			CMPQ DI, 0(BX)				
  0x4483df		758c			JNE 0x44836d				
  0x4483e1		488923			MOVQ SP, 0(BX)				
  0x4483e4		eb87			JMP 0x44836d				

TEXT runtime.call262144(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4483f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4483f9		488b7110		MOVQ 0x10(CX), SI			
  0x4483fd		4881fedefaffff		CMPQ $-0x522, SI			
  0x448404		0f8490000000		JE 0x44849a				
  0x44840a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448412		4829f0			SUBQ SI, AX				
  0x448415		483df8020400		CMPQ $0x402f8, AX			
  0x44841b		767d			JBE 0x44849a				
  0x44841d		4881ec08000400		SUBQ $0x40008, SP			
  0x448424		4889ac2400000400	MOVQ BP, 0x40000(SP)			
  0x44842c		488dac2400000400	LEAQ 0x40000(SP), BP			
  0x448434		488b5920		MOVQ 0x20(CX), BX			
  0x448438		4885db			TESTQ BX, BX				
  0x44843b		7567			JNE 0x4484a4				
  0x44843d		488bb42420000400	MOVQ 0x40020(SP), SI			
  0x448445		8b8c2428000400		MOVL 0x40028(SP), CX			
  0x44844c		4889e7			MOVQ SP, DI				
  0x44844f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448451		488b942418000400	MOVQ 0x40018(SP), DX			
  0x448459		ff12			CALL 0(DX)				
  0x44845b		488b942410000400	MOVQ 0x40010(SP), DX			
  0x448463		488bbc2420000400	MOVQ 0x40020(SP), DI			
  0x44846b		8b8c2428000400		MOVL 0x40028(SP), CX			
  0x448472		8b9c242c000400		MOVL 0x4002c(SP), BX			
  0x448479		4889e6			MOVQ SP, SI				
  0x44847c		4801df			ADDQ BX, DI				
  0x44847f		4801de			ADDQ BX, SI				
  0x448482		4829d9			SUBQ BX, CX				
  0x448485		e8e6f5ffff		CALL callRet(SB)			
  0x44848a		488bac2400000400	MOVQ 0x40000(SP), BP			
  0x448492		4881c408000400		ADDQ $0x40008, SP			
  0x448499		c3			RET					
  0x44849a		e8e1f3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44849f		e94cffffff		JMP runtime.call262144(SB)		
  0x4484a4		488dbc2410000400	LEAQ 0x40010(SP), DI			
  0x4484ac		48393b			CMPQ DI, 0(BX)				
  0x4484af		758c			JNE 0x44843d				
  0x4484b1		488923			MOVQ SP, 0(BX)				
  0x4484b4		eb87			JMP 0x44843d				

TEXT runtime.call524288(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4484c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4484c9		488b7110		MOVQ 0x10(CX), SI			
  0x4484cd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4484d4		0f8490000000		JE 0x44856a				
  0x4484da		488d842470030000	LEAQ 0x370(SP), AX			
  0x4484e2		4829f0			SUBQ SI, AX				
  0x4484e5		483df8020800		CMPQ $0x802f8, AX			
  0x4484eb		767d			JBE 0x44856a				
  0x4484ed		4881ec08000800		SUBQ $0x80008, SP			
  0x4484f4		4889ac2400000800	MOVQ BP, 0x80000(SP)			
  0x4484fc		488dac2400000800	LEAQ 0x80000(SP), BP			
  0x448504		488b5920		MOVQ 0x20(CX), BX			
  0x448508		4885db			TESTQ BX, BX				
  0x44850b		7567			JNE 0x448574				
  0x44850d		488bb42420000800	MOVQ 0x80020(SP), SI			
  0x448515		8b8c2428000800		MOVL 0x80028(SP), CX			
  0x44851c		4889e7			MOVQ SP, DI				
  0x44851f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448521		488b942418000800	MOVQ 0x80018(SP), DX			
  0x448529		ff12			CALL 0(DX)				
  0x44852b		488b942410000800	MOVQ 0x80010(SP), DX			
  0x448533		488bbc2420000800	MOVQ 0x80020(SP), DI			
  0x44853b		8b8c2428000800		MOVL 0x80028(SP), CX			
  0x448542		8b9c242c000800		MOVL 0x8002c(SP), BX			
  0x448549		4889e6			MOVQ SP, SI				
  0x44854c		4801df			ADDQ BX, DI				
  0x44854f		4801de			ADDQ BX, SI				
  0x448552		4829d9			SUBQ BX, CX				
  0x448555		e816f5ffff		CALL callRet(SB)			
  0x44855a		488bac2400000800	MOVQ 0x80000(SP), BP			
  0x448562		4881c408000800		ADDQ $0x80008, SP			
  0x448569		c3			RET					
  0x44856a		e811f3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44856f		e94cffffff		JMP runtime.call524288(SB)		
  0x448574		488dbc2410000800	LEAQ 0x80010(SP), DI			
  0x44857c		48393b			CMPQ DI, 0(BX)				
  0x44857f		758c			JNE 0x44850d				
  0x448581		488923			MOVQ SP, 0(BX)				
  0x448584		eb87			JMP 0x44850d				

TEXT runtime.call1048576(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448590		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448599		488b7110		MOVQ 0x10(CX), SI			
  0x44859d		4881fedefaffff		CMPQ $-0x522, SI			
  0x4485a4		0f8490000000		JE 0x44863a				
  0x4485aa		488d842470030000	LEAQ 0x370(SP), AX			
  0x4485b2		4829f0			SUBQ SI, AX				
  0x4485b5		483df8021000		CMPQ $0x1002f8, AX			
  0x4485bb		767d			JBE 0x44863a				
  0x4485bd		4881ec08001000		SUBQ $0x100008, SP			
  0x4485c4		4889ac2400001000	MOVQ BP, 0x100000(SP)			
  0x4485cc		488dac2400001000	LEAQ 0x100000(SP), BP			
  0x4485d4		488b5920		MOVQ 0x20(CX), BX			
  0x4485d8		4885db			TESTQ BX, BX				
  0x4485db		7567			JNE 0x448644				
  0x4485dd		488bb42420001000	MOVQ 0x100020(SP), SI			
  0x4485e5		8b8c2428001000		MOVL 0x100028(SP), CX			
  0x4485ec		4889e7			MOVQ SP, DI				
  0x4485ef		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4485f1		488b942418001000	MOVQ 0x100018(SP), DX			
  0x4485f9		ff12			CALL 0(DX)				
  0x4485fb		488b942410001000	MOVQ 0x100010(SP), DX			
  0x448603		488bbc2420001000	MOVQ 0x100020(SP), DI			
  0x44860b		8b8c2428001000		MOVL 0x100028(SP), CX			
  0x448612		8b9c242c001000		MOVL 0x10002c(SP), BX			
  0x448619		4889e6			MOVQ SP, SI				
  0x44861c		4801df			ADDQ BX, DI				
  0x44861f		4801de			ADDQ BX, SI				
  0x448622		4829d9			SUBQ BX, CX				
  0x448625		e846f4ffff		CALL callRet(SB)			
  0x44862a		488bac2400001000	MOVQ 0x100000(SP), BP			
  0x448632		4881c408001000		ADDQ $0x100008, SP			
  0x448639		c3			RET					
  0x44863a		e841f2ffff		CALL runtime.morestack_noctxt(SB)	
  0x44863f		e94cffffff		JMP runtime.call1048576(SB)		
  0x448644		488dbc2410001000	LEAQ 0x100010(SP), DI			
  0x44864c		48393b			CMPQ DI, 0(BX)				
  0x44864f		758c			JNE 0x4485dd				
  0x448651		488923			MOVQ SP, 0(BX)				
  0x448654		eb87			JMP 0x4485dd				

TEXT runtime.call2097152(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448660		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448669		488b7110		MOVQ 0x10(CX), SI			
  0x44866d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448674		0f8490000000		JE 0x44870a				
  0x44867a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448682		4829f0			SUBQ SI, AX				
  0x448685		483df8022000		CMPQ $0x2002f8, AX			
  0x44868b		767d			JBE 0x44870a				
  0x44868d		4881ec08002000		SUBQ $0x200008, SP			
  0x448694		4889ac2400002000	MOVQ BP, 0x200000(SP)			
  0x44869c		488dac2400002000	LEAQ 0x200000(SP), BP			
  0x4486a4		488b5920		MOVQ 0x20(CX), BX			
  0x4486a8		4885db			TESTQ BX, BX				
  0x4486ab		7567			JNE 0x448714				
  0x4486ad		488bb42420002000	MOVQ 0x200020(SP), SI			
  0x4486b5		8b8c2428002000		MOVL 0x200028(SP), CX			
  0x4486bc		4889e7			MOVQ SP, DI				
  0x4486bf		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x4486c1		488b942418002000	MOVQ 0x200018(SP), DX			
  0x4486c9		ff12			CALL 0(DX)				
  0x4486cb		488b942410002000	MOVQ 0x200010(SP), DX			
  0x4486d3		488bbc2420002000	MOVQ 0x200020(SP), DI			
  0x4486db		8b8c2428002000		MOVL 0x200028(SP), CX			
  0x4486e2		8b9c242c002000		MOVL 0x20002c(SP), BX			
  0x4486e9		4889e6			MOVQ SP, SI				
  0x4486ec		4801df			ADDQ BX, DI				
  0x4486ef		4801de			ADDQ BX, SI				
  0x4486f2		4829d9			SUBQ BX, CX				
  0x4486f5		e876f3ffff		CALL callRet(SB)			
  0x4486fa		488bac2400002000	MOVQ 0x200000(SP), BP			
  0x448702		4881c408002000		ADDQ $0x200008, SP			
  0x448709		c3			RET					
  0x44870a		e871f1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44870f		e94cffffff		JMP runtime.call2097152(SB)		
  0x448714		488dbc2410002000	LEAQ 0x200010(SP), DI			
  0x44871c		48393b			CMPQ DI, 0(BX)				
  0x44871f		758c			JNE 0x4486ad				
  0x448721		488923			MOVQ SP, 0(BX)				
  0x448724		eb87			JMP 0x4486ad				

TEXT runtime.call4194304(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448730		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448739		488b7110		MOVQ 0x10(CX), SI			
  0x44873d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448744		0f8490000000		JE 0x4487da				
  0x44874a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448752		4829f0			SUBQ SI, AX				
  0x448755		483df8024000		CMPQ $0x4002f8, AX			
  0x44875b		767d			JBE 0x4487da				
  0x44875d		4881ec08004000		SUBQ $0x400008, SP			
  0x448764		4889ac2400004000	MOVQ BP, 0x400000(SP)			
  0x44876c		488dac2400004000	LEAQ 0x400000(SP), BP			
  0x448774		488b5920		MOVQ 0x20(CX), BX			
  0x448778		4885db			TESTQ BX, BX				
  0x44877b		7567			JNE 0x4487e4				
  0x44877d		488bb42420004000	MOVQ 0x400020(SP), SI			
  0x448785		8b8c2428004000		MOVL 0x400028(SP), CX			
  0x44878c		4889e7			MOVQ SP, DI				
  0x44878f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448791		488b942418004000	MOVQ 0x400018(SP), DX			
  0x448799		ff12			CALL 0(DX)				
  0x44879b		488b942410004000	MOVQ 0x400010(SP), DX			
  0x4487a3		488bbc2420004000	MOVQ 0x400020(SP), DI			
  0x4487ab		8b8c2428004000		MOVL 0x400028(SP), CX			
  0x4487b2		8b9c242c004000		MOVL 0x40002c(SP), BX			
  0x4487b9		4889e6			MOVQ SP, SI				
  0x4487bc		4801df			ADDQ BX, DI				
  0x4487bf		4801de			ADDQ BX, SI				
  0x4487c2		4829d9			SUBQ BX, CX				
  0x4487c5		e8a6f2ffff		CALL callRet(SB)			
  0x4487ca		488bac2400004000	MOVQ 0x400000(SP), BP			
  0x4487d2		4881c408004000		ADDQ $0x400008, SP			
  0x4487d9		c3			RET					
  0x4487da		e8a1f0ffff		CALL runtime.morestack_noctxt(SB)	
  0x4487df		e94cffffff		JMP runtime.call4194304(SB)		
  0x4487e4		488dbc2410004000	LEAQ 0x400010(SP), DI			
  0x4487ec		48393b			CMPQ DI, 0(BX)				
  0x4487ef		758c			JNE 0x44877d				
  0x4487f1		488923			MOVQ SP, 0(BX)				
  0x4487f4		eb87			JMP 0x44877d				

TEXT runtime.call8388608(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448800		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448809		488b7110		MOVQ 0x10(CX), SI			
  0x44880d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448814		0f8490000000		JE 0x4488aa				
  0x44881a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448822		4829f0			SUBQ SI, AX				
  0x448825		483df8028000		CMPQ $0x8002f8, AX			
  0x44882b		767d			JBE 0x4488aa				
  0x44882d		4881ec08008000		SUBQ $0x800008, SP			
  0x448834		4889ac2400008000	MOVQ BP, 0x800000(SP)			
  0x44883c		488dac2400008000	LEAQ 0x800000(SP), BP			
  0x448844		488b5920		MOVQ 0x20(CX), BX			
  0x448848		4885db			TESTQ BX, BX				
  0x44884b		7567			JNE 0x4488b4				
  0x44884d		488bb42420008000	MOVQ 0x800020(SP), SI			
  0x448855		8b8c2428008000		MOVL 0x800028(SP), CX			
  0x44885c		4889e7			MOVQ SP, DI				
  0x44885f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448861		488b942418008000	MOVQ 0x800018(SP), DX			
  0x448869		ff12			CALL 0(DX)				
  0x44886b		488b942410008000	MOVQ 0x800010(SP), DX			
  0x448873		488bbc2420008000	MOVQ 0x800020(SP), DI			
  0x44887b		8b8c2428008000		MOVL 0x800028(SP), CX			
  0x448882		8b9c242c008000		MOVL 0x80002c(SP), BX			
  0x448889		4889e6			MOVQ SP, SI				
  0x44888c		4801df			ADDQ BX, DI				
  0x44888f		4801de			ADDQ BX, SI				
  0x448892		4829d9			SUBQ BX, CX				
  0x448895		e8d6f1ffff		CALL callRet(SB)			
  0x44889a		488bac2400008000	MOVQ 0x800000(SP), BP			
  0x4488a2		4881c408008000		ADDQ $0x800008, SP			
  0x4488a9		c3			RET					
  0x4488aa		e8d1efffff		CALL runtime.morestack_noctxt(SB)	
  0x4488af		e94cffffff		JMP runtime.call8388608(SB)		
  0x4488b4		488dbc2410008000	LEAQ 0x800010(SP), DI			
  0x4488bc		48393b			CMPQ DI, 0(BX)				
  0x4488bf		758c			JNE 0x44884d				
  0x4488c1		488923			MOVQ SP, 0(BX)				
  0x4488c4		eb87			JMP 0x44884d				

TEXT runtime.call16777216(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4488d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4488d9		488b7110		MOVQ 0x10(CX), SI			
  0x4488dd		4881fedefaffff		CMPQ $-0x522, SI			
  0x4488e4		0f8490000000		JE 0x44897a				
  0x4488ea		488d842470030000	LEAQ 0x370(SP), AX			
  0x4488f2		4829f0			SUBQ SI, AX				
  0x4488f5		483df8020001		CMPQ $0x10002f8, AX			
  0x4488fb		767d			JBE 0x44897a				
  0x4488fd		4881ec08000001		SUBQ $0x1000008, SP			
  0x448904		4889ac2400000001	MOVQ BP, 0x1000000(SP)			
  0x44890c		488dac2400000001	LEAQ 0x1000000(SP), BP			
  0x448914		488b5920		MOVQ 0x20(CX), BX			
  0x448918		4885db			TESTQ BX, BX				
  0x44891b		7567			JNE 0x448984				
  0x44891d		488bb42420000001	MOVQ 0x1000020(SP), SI			
  0x448925		8b8c2428000001		MOVL 0x1000028(SP), CX			
  0x44892c		4889e7			MOVQ SP, DI				
  0x44892f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448931		488b942418000001	MOVQ 0x1000018(SP), DX			
  0x448939		ff12			CALL 0(DX)				
  0x44893b		488b942410000001	MOVQ 0x1000010(SP), DX			
  0x448943		488bbc2420000001	MOVQ 0x1000020(SP), DI			
  0x44894b		8b8c2428000001		MOVL 0x1000028(SP), CX			
  0x448952		8b9c242c000001		MOVL 0x100002c(SP), BX			
  0x448959		4889e6			MOVQ SP, SI				
  0x44895c		4801df			ADDQ BX, DI				
  0x44895f		4801de			ADDQ BX, SI				
  0x448962		4829d9			SUBQ BX, CX				
  0x448965		e806f1ffff		CALL callRet(SB)			
  0x44896a		488bac2400000001	MOVQ 0x1000000(SP), BP			
  0x448972		4881c408000001		ADDQ $0x1000008, SP			
  0x448979		c3			RET					
  0x44897a		e801efffff		CALL runtime.morestack_noctxt(SB)	
  0x44897f		e94cffffff		JMP runtime.call16777216(SB)		
  0x448984		488dbc2410000001	LEAQ 0x1000010(SP), DI			
  0x44898c		48393b			CMPQ DI, 0(BX)				
  0x44898f		758c			JNE 0x44891d				
  0x448991		488923			MOVQ SP, 0(BX)				
  0x448994		eb87			JMP 0x44891d				

TEXT runtime.call33554432(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4489a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x4489a9		488b7110		MOVQ 0x10(CX), SI			
  0x4489ad		4881fedefaffff		CMPQ $-0x522, SI			
  0x4489b4		0f8490000000		JE 0x448a4a				
  0x4489ba		488d842470030000	LEAQ 0x370(SP), AX			
  0x4489c2		4829f0			SUBQ SI, AX				
  0x4489c5		483df8020002		CMPQ $0x20002f8, AX			
  0x4489cb		767d			JBE 0x448a4a				
  0x4489cd		4881ec08000002		SUBQ $0x2000008, SP			
  0x4489d4		4889ac2400000002	MOVQ BP, 0x2000000(SP)			
  0x4489dc		488dac2400000002	LEAQ 0x2000000(SP), BP			
  0x4489e4		488b5920		MOVQ 0x20(CX), BX			
  0x4489e8		4885db			TESTQ BX, BX				
  0x4489eb		7567			JNE 0x448a54				
  0x4489ed		488bb42420000002	MOVQ 0x2000020(SP), SI			
  0x4489f5		8b8c2428000002		MOVL 0x2000028(SP), CX			
  0x4489fc		4889e7			MOVQ SP, DI				
  0x4489ff		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448a01		488b942418000002	MOVQ 0x2000018(SP), DX			
  0x448a09		ff12			CALL 0(DX)				
  0x448a0b		488b942410000002	MOVQ 0x2000010(SP), DX			
  0x448a13		488bbc2420000002	MOVQ 0x2000020(SP), DI			
  0x448a1b		8b8c2428000002		MOVL 0x2000028(SP), CX			
  0x448a22		8b9c242c000002		MOVL 0x200002c(SP), BX			
  0x448a29		4889e6			MOVQ SP, SI				
  0x448a2c		4801df			ADDQ BX, DI				
  0x448a2f		4801de			ADDQ BX, SI				
  0x448a32		4829d9			SUBQ BX, CX				
  0x448a35		e836f0ffff		CALL callRet(SB)			
  0x448a3a		488bac2400000002	MOVQ 0x2000000(SP), BP			
  0x448a42		4881c408000002		ADDQ $0x2000008, SP			
  0x448a49		c3			RET					
  0x448a4a		e831eeffff		CALL runtime.morestack_noctxt(SB)	
  0x448a4f		e94cffffff		JMP runtime.call33554432(SB)		
  0x448a54		488dbc2410000002	LEAQ 0x2000010(SP), DI			
  0x448a5c		48393b			CMPQ DI, 0(BX)				
  0x448a5f		758c			JNE 0x4489ed				
  0x448a61		488923			MOVQ SP, 0(BX)				
  0x448a64		eb87			JMP 0x4489ed				

TEXT runtime.call67108864(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448a70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448a79		488b7110		MOVQ 0x10(CX), SI			
  0x448a7d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448a84		0f8490000000		JE 0x448b1a				
  0x448a8a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448a92		4829f0			SUBQ SI, AX				
  0x448a95		483df8020004		CMPQ $0x40002f8, AX			
  0x448a9b		767d			JBE 0x448b1a				
  0x448a9d		4881ec08000004		SUBQ $0x4000008, SP			
  0x448aa4		4889ac2400000004	MOVQ BP, 0x4000000(SP)			
  0x448aac		488dac2400000004	LEAQ 0x4000000(SP), BP			
  0x448ab4		488b5920		MOVQ 0x20(CX), BX			
  0x448ab8		4885db			TESTQ BX, BX				
  0x448abb		7567			JNE 0x448b24				
  0x448abd		488bb42420000004	MOVQ 0x4000020(SP), SI			
  0x448ac5		8b8c2428000004		MOVL 0x4000028(SP), CX			
  0x448acc		4889e7			MOVQ SP, DI				
  0x448acf		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448ad1		488b942418000004	MOVQ 0x4000018(SP), DX			
  0x448ad9		ff12			CALL 0(DX)				
  0x448adb		488b942410000004	MOVQ 0x4000010(SP), DX			
  0x448ae3		488bbc2420000004	MOVQ 0x4000020(SP), DI			
  0x448aeb		8b8c2428000004		MOVL 0x4000028(SP), CX			
  0x448af2		8b9c242c000004		MOVL 0x400002c(SP), BX			
  0x448af9		4889e6			MOVQ SP, SI				
  0x448afc		4801df			ADDQ BX, DI				
  0x448aff		4801de			ADDQ BX, SI				
  0x448b02		4829d9			SUBQ BX, CX				
  0x448b05		e866efffff		CALL callRet(SB)			
  0x448b0a		488bac2400000004	MOVQ 0x4000000(SP), BP			
  0x448b12		4881c408000004		ADDQ $0x4000008, SP			
  0x448b19		c3			RET					
  0x448b1a		e861edffff		CALL runtime.morestack_noctxt(SB)	
  0x448b1f		e94cffffff		JMP runtime.call67108864(SB)		
  0x448b24		488dbc2410000004	LEAQ 0x4000010(SP), DI			
  0x448b2c		48393b			CMPQ DI, 0(BX)				
  0x448b2f		758c			JNE 0x448abd				
  0x448b31		488923			MOVQ SP, 0(BX)				
  0x448b34		eb87			JMP 0x448abd				

TEXT runtime.call134217728(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448b40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448b49		488b7110		MOVQ 0x10(CX), SI			
  0x448b4d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448b54		0f8490000000		JE 0x448bea				
  0x448b5a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448b62		4829f0			SUBQ SI, AX				
  0x448b65		483df8020008		CMPQ $0x80002f8, AX			
  0x448b6b		767d			JBE 0x448bea				
  0x448b6d		4881ec08000008		SUBQ $0x8000008, SP			
  0x448b74		4889ac2400000008	MOVQ BP, 0x8000000(SP)			
  0x448b7c		488dac2400000008	LEAQ 0x8000000(SP), BP			
  0x448b84		488b5920		MOVQ 0x20(CX), BX			
  0x448b88		4885db			TESTQ BX, BX				
  0x448b8b		7567			JNE 0x448bf4				
  0x448b8d		488bb42420000008	MOVQ 0x8000020(SP), SI			
  0x448b95		8b8c2428000008		MOVL 0x8000028(SP), CX			
  0x448b9c		4889e7			MOVQ SP, DI				
  0x448b9f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448ba1		488b942418000008	MOVQ 0x8000018(SP), DX			
  0x448ba9		ff12			CALL 0(DX)				
  0x448bab		488b942410000008	MOVQ 0x8000010(SP), DX			
  0x448bb3		488bbc2420000008	MOVQ 0x8000020(SP), DI			
  0x448bbb		8b8c2428000008		MOVL 0x8000028(SP), CX			
  0x448bc2		8b9c242c000008		MOVL 0x800002c(SP), BX			
  0x448bc9		4889e6			MOVQ SP, SI				
  0x448bcc		4801df			ADDQ BX, DI				
  0x448bcf		4801de			ADDQ BX, SI				
  0x448bd2		4829d9			SUBQ BX, CX				
  0x448bd5		e896eeffff		CALL callRet(SB)			
  0x448bda		488bac2400000008	MOVQ 0x8000000(SP), BP			
  0x448be2		4881c408000008		ADDQ $0x8000008, SP			
  0x448be9		c3			RET					
  0x448bea		e891ecffff		CALL runtime.morestack_noctxt(SB)	
  0x448bef		e94cffffff		JMP runtime.call134217728(SB)		
  0x448bf4		488dbc2410000008	LEAQ 0x8000010(SP), DI			
  0x448bfc		48393b			CMPQ DI, 0(BX)				
  0x448bff		758c			JNE 0x448b8d				
  0x448c01		488923			MOVQ SP, 0(BX)				
  0x448c04		eb87			JMP 0x448b8d				

TEXT runtime.call268435456(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448c10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448c19		488b7110		MOVQ 0x10(CX), SI			
  0x448c1d		4881fedefaffff		CMPQ $-0x522, SI			
  0x448c24		0f8490000000		JE 0x448cba				
  0x448c2a		488d842470030000	LEAQ 0x370(SP), AX			
  0x448c32		4829f0			SUBQ SI, AX				
  0x448c35		483df8020010		CMPQ $0x100002f8, AX			
  0x448c3b		767d			JBE 0x448cba				
  0x448c3d		4881ec08000010		SUBQ $0x10000008, SP			
  0x448c44		4889ac2400000010	MOVQ BP, 0x10000000(SP)			
  0x448c4c		488dac2400000010	LEAQ 0x10000000(SP), BP			
  0x448c54		488b5920		MOVQ 0x20(CX), BX			
  0x448c58		4885db			TESTQ BX, BX				
  0x448c5b		7567			JNE 0x448cc4				
  0x448c5d		488bb42420000010	MOVQ 0x10000020(SP), SI			
  0x448c65		8b8c2428000010		MOVL 0x10000028(SP), CX			
  0x448c6c		4889e7			MOVQ SP, DI				
  0x448c6f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448c71		488b942418000010	MOVQ 0x10000018(SP), DX			
  0x448c79		ff12			CALL 0(DX)				
  0x448c7b		488b942410000010	MOVQ 0x10000010(SP), DX			
  0x448c83		488bbc2420000010	MOVQ 0x10000020(SP), DI			
  0x448c8b		8b8c2428000010		MOVL 0x10000028(SP), CX			
  0x448c92		8b9c242c000010		MOVL 0x1000002c(SP), BX			
  0x448c99		4889e6			MOVQ SP, SI				
  0x448c9c		4801df			ADDQ BX, DI				
  0x448c9f		4801de			ADDQ BX, SI				
  0x448ca2		4829d9			SUBQ BX, CX				
  0x448ca5		e8c6edffff		CALL callRet(SB)			
  0x448caa		488bac2400000010	MOVQ 0x10000000(SP), BP			
  0x448cb2		4881c408000010		ADDQ $0x10000008, SP			
  0x448cb9		c3			RET					
  0x448cba		e8c1ebffff		CALL runtime.morestack_noctxt(SB)	
  0x448cbf		e94cffffff		JMP runtime.call268435456(SB)		
  0x448cc4		488dbc2410000010	LEAQ 0x10000010(SP), DI			
  0x448ccc		48393b			CMPQ DI, 0(BX)				
  0x448ccf		758c			JNE 0x448c5d				
  0x448cd1		488923			MOVQ SP, 0(BX)				
  0x448cd4		eb87			JMP 0x448c5d				

TEXT runtime.call536870912(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448ce9		488b7110		MOVQ 0x10(CX), SI			
  0x448ced		4881fedefaffff		CMPQ $-0x522, SI			
  0x448cf4		0f8490000000		JE 0x448d8a				
  0x448cfa		488d842470030000	LEAQ 0x370(SP), AX			
  0x448d02		4829f0			SUBQ SI, AX				
  0x448d05		483df8020020		CMPQ $0x200002f8, AX			
  0x448d0b		767d			JBE 0x448d8a				
  0x448d0d		4881ec08000020		SUBQ $0x20000008, SP			
  0x448d14		4889ac2400000020	MOVQ BP, 0x20000000(SP)			
  0x448d1c		488dac2400000020	LEAQ 0x20000000(SP), BP			
  0x448d24		488b5920		MOVQ 0x20(CX), BX			
  0x448d28		4885db			TESTQ BX, BX				
  0x448d2b		7567			JNE 0x448d94				
  0x448d2d		488bb42420000020	MOVQ 0x20000020(SP), SI			
  0x448d35		8b8c2428000020		MOVL 0x20000028(SP), CX			
  0x448d3c		4889e7			MOVQ SP, DI				
  0x448d3f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448d41		488b942418000020	MOVQ 0x20000018(SP), DX			
  0x448d49		ff12			CALL 0(DX)				
  0x448d4b		488b942410000020	MOVQ 0x20000010(SP), DX			
  0x448d53		488bbc2420000020	MOVQ 0x20000020(SP), DI			
  0x448d5b		8b8c2428000020		MOVL 0x20000028(SP), CX			
  0x448d62		8b9c242c000020		MOVL 0x2000002c(SP), BX			
  0x448d69		4889e6			MOVQ SP, SI				
  0x448d6c		4801df			ADDQ BX, DI				
  0x448d6f		4801de			ADDQ BX, SI				
  0x448d72		4829d9			SUBQ BX, CX				
  0x448d75		e8f6ecffff		CALL callRet(SB)			
  0x448d7a		488bac2400000020	MOVQ 0x20000000(SP), BP			
  0x448d82		4881c408000020		ADDQ $0x20000008, SP			
  0x448d89		c3			RET					
  0x448d8a		e8f1eaffff		CALL runtime.morestack_noctxt(SB)	
  0x448d8f		e94cffffff		JMP runtime.call536870912(SB)		
  0x448d94		488dbc2410000020	LEAQ 0x20000010(SP), DI			
  0x448d9c		48393b			CMPQ DI, 0(BX)				
  0x448d9f		758c			JNE 0x448d2d				
  0x448da1		488923			MOVQ SP, 0(BX)				
  0x448da4		eb87			JMP 0x448d2d				

TEXT runtime.call1073741824(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448db0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x448db9		488b7110		MOVQ 0x10(CX), SI			
  0x448dbd		4881fedefaffff		CMPQ $-0x522, SI			
  0x448dc4		0f8490000000		JE 0x448e5a				
  0x448dca		488d842470030000	LEAQ 0x370(SP), AX			
  0x448dd2		4829f0			SUBQ SI, AX				
  0x448dd5		483df8020040		CMPQ $0x400002f8, AX			
  0x448ddb		767d			JBE 0x448e5a				
  0x448ddd		4881ec08000040		SUBQ $0x40000008, SP			
  0x448de4		4889ac2400000040	MOVQ BP, 0x40000000(SP)			
  0x448dec		488dac2400000040	LEAQ 0x40000000(SP), BP			
  0x448df4		488b5920		MOVQ 0x20(CX), BX			
  0x448df8		4885db			TESTQ BX, BX				
  0x448dfb		7567			JNE 0x448e64				
  0x448dfd		488bb42420000040	MOVQ 0x40000020(SP), SI			
  0x448e05		8b8c2428000040		MOVL 0x40000028(SP), CX			
  0x448e0c		4889e7			MOVQ SP, DI				
  0x448e0f		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)		
  0x448e11		488b942418000040	MOVQ 0x40000018(SP), DX			
  0x448e19		ff12			CALL 0(DX)				
  0x448e1b		488b942410000040	MOVQ 0x40000010(SP), DX			
  0x448e23		488bbc2420000040	MOVQ 0x40000020(SP), DI			
  0x448e2b		8b8c2428000040		MOVL 0x40000028(SP), CX			
  0x448e32		8b9c242c000040		MOVL 0x4000002c(SP), BX			
  0x448e39		4889e6			MOVQ SP, SI				
  0x448e3c		4801df			ADDQ BX, DI				
  0x448e3f		4801de			ADDQ BX, SI				
  0x448e42		4829d9			SUBQ BX, CX				
  0x448e45		e826ecffff		CALL callRet(SB)			
  0x448e4a		488bac2400000040	MOVQ 0x40000000(SP), BP			
  0x448e52		4881c408000040		ADDQ $0x40000008, SP			
  0x448e59		c3			RET					
  0x448e5a		e821eaffff		CALL runtime.morestack_noctxt(SB)	
  0x448e5f		e94cffffff		JMP runtime.call1073741824(SB)		
  0x448e64		488dbc2410000040	LEAQ 0x40000010(SP), DI			
  0x448e6c		48393b			CMPQ DI, 0(BX)				
  0x448e6f		758c			JNE 0x448dfd				
  0x448e71		488923			MOVQ SP, 0(BX)				
  0x448e74		eb87			JMP 0x448dfd				

TEXT runtime.procyield(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448e80		8b442408		MOVL 0x8(SP), AX	

  0x448e84		f390			PAUSE			

  0x448e86		83e801			SUBL $0x1, AX		

  0x448e89		75f9			JNE 0x448e84		

  0x448e8b		c3			RET			

TEXT runtime.publicationBarrier(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448e90		c3			RET			

TEXT runtime.jmpdefer(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448ea0		488b542408		MOVQ 0x8(SP), DX	

  0x448ea5		488b5c2410		MOVQ 0x10(SP), BX	

  0x448eaa		488d63f8		LEAQ -0x8(BX), SP	

  0x448eae		488b6c24f8		MOVQ -0x8(SP), BP	

  0x448eb3		48832c2405		SUBQ $0x5, 0(SP)	

  0x448eb8		488b1a			MOVQ 0(DX), BX		

  0x448ebb		ffe3			JMP BX			

TEXT gosave(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448ec0		644c8b0425f8ffffff	MOVQ FS:0xfffffff8, R8	

  0x448ec9		4c8b0c24		MOVQ 0(SP), R9		

  0x448ecd		4d894840		MOVQ R9, 0x40(R8)	

  0x448ed1		4c8d4c2408		LEAQ 0x8(SP), R9	

  0x448ed6		4d894838		MOVQ R9, 0x38(R8)	

  0x448eda		49c7405800000000	MOVQ $0x0, 0x58(R8)	

  0x448ee2		49896868		MOVQ BP, 0x68(R8)	

  0x448ee6		4d8b4850		MOVQ 0x50(R8), R9	

  0x448eea		4d85c9			TESTQ R9, R9		

  0x448eed		7405			JE 0x448ef4		

  0x448eef		e8bcccfdff		CALL runtime.badctxt(SB)	

  0x448ef4		c3			RET			

TEXT runtime.asmcgocall(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448f00		488b442408		MOVQ 0x8(SP), AX	

  0x448f05		488b5c2410		MOVQ 0x10(SP), BX	

  0x448f0a		4889e2			MOVQ SP, DX		

  0x448f0d		644c8b0425f8ffffff	MOVQ FS:0xfffffff8, R8	

  0x448f16		4983f800		CMPQ $0x0, R8		

  0x448f1a		7473			JE 0x448f8f		

  0x448f1c		4d8b4030		MOVQ 0x30(R8), R8	

  0x448f20		498b30			MOVQ 0(R8), SI		

  0x448f23		64488b3c25f8ffffff	MOVQ FS:0xfffffff8, DI	

  0x448f2c		4839fe			CMPQ DI, SI		

  0x448f2f		745e			JE 0x448f8f		

  0x448f31		498b7050		MOVQ 0x50(R8), SI	

  0x448f35		4839fe			CMPQ DI, SI		

  0x448f38		7455			JE 0x448f8f		

  0x448f3a		498b30			MOVQ 0(R8), SI		

  0x448f3d		e87effffff		CALL gosave(SB)		

  0x448f42		6448893425f8ffffff	MOVQ SI, FS:0xfffffff8	

  0x448f4b		488b6638		MOVQ 0x38(SI), SP	

  0x448f4f		4883ec40		SUBQ $0x40, SP		

  0x448f53		4883e4f0		ANDQ $-0x10, SP		

  0x448f57		48897c2430		MOVQ DI, 0x30(SP)	

  0x448f5c		488b7f08		MOVQ 0x8(DI), DI	

  0x448f60		4829d7			SUBQ DX, DI		

  0x448f63		48897c2428		MOVQ DI, 0x28(SP)	

  0x448f68		4889df			MOVQ BX, DI		

  0x448f6b		4889d9			MOVQ BX, CX		

  0x448f6e		ffd0			CALL AX			

  0x448f70		488b7c2430		MOVQ 0x30(SP), DI	

  0x448f75		488b7708		MOVQ 0x8(DI), SI	

  0x448f79		482b742428		SUBQ 0x28(SP), SI	

  0x448f7e		6448893c25f8ffffff	MOVQ DI, FS:0xfffffff8	

  0x448f87		4889f4			MOVQ SI, SP		

  0x448f8a		89442418		MOVL AX, 0x18(SP)	

  0x448f8e		c3			RET			

  0x448f8f		4883ec40		SUBQ $0x40, SP		

  0x448f93		4883e4f0		ANDQ $-0x10, SP		

  0x448f97		48c744243000000000	MOVQ $0x0, 0x30(SP)	

  0x448fa0		4889542428		MOVQ DX, 0x28(SP)	

  0x448fa5		4889df			MOVQ BX, DI		

  0x448fa8		4889d9			MOVQ BX, CX		

  0x448fab		ffd0			CALL AX			

  0x448fad		488b742428		MOVQ 0x28(SP), SI	

  0x448fb2		4889f4			MOVQ SI, SP		

  0x448fb5		89442418		MOVL AX, 0x18(SP)	

  0x448fb9		c3			RET			

TEXT runtime.setg(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448fc0		488b5c2408		MOVQ 0x8(SP), BX	

  0x448fc5		6448891c25f8ffffff	MOVQ BX, FS:0xfffffff8	

  0x448fce		c3			RET			

TEXT setg_gcc(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448fd0		6448893c25f8ffffff	MOVQ DI, FS:0xfffffff8	

  0x448fd9		c3			RET			

TEXT runtime.abort(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448fe0		cd03			INT $0x3		

  0x448fe2		ebfe			JMP 0x448fe2		

TEXT runtime.stackcheck(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x448ff0		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x448ff9		48396008		CMPQ SP, 0x8(AX)	

  0x448ffd		7705			JA 0x449004		

  0x448fff		e8dcffffff		CALL runtime.abort(SB)	

  0x449004		483b20			CMPQ 0(AX), SP		

  0x449007		7705			JA 0x44900e		

  0x449009		e8d2ffffff		CALL runtime.abort(SB)	

  0x44900e		c3			RET			

TEXT runtime.cputicks(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449010		803d993c090001		CMPB $0x1, runtime.lfenceBeforeRdtsc(SB)	

  0x449017		7505			JNE 0x44901e		

  0x449019		0faee8			LFENCE			

  0x44901c		eb03			JMP 0x449021		

  0x44901e		0faef0			MFENCE			

  0x449021		0f31			RDTSC			

  0x449023		48c1e220		SHLQ $0x20, DX		

  0x449027		4801d0			ADDQ DX, AX		

  0x44902a		4889442408		MOVQ AX, 0x8(SP)	

  0x44902f		c3			RET			

TEXT runtime.aeshash(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449030		488b442408		MOVQ 0x8(SP), AX	

  0x449035		488b4c2418		MOVQ 0x18(SP), CX	

  0x44903a		488d542420		LEAQ 0x20(SP), DX	

  0x44903f		e92c000000		JMP runtime.aeshashbody(SB)	

TEXT runtime.aeshashstr(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449050		488b442408		MOVQ 0x8(SP), AX	

  0x449055		488b4808		MOVQ 0x8(AX), CX	

  0x449059		488b00			MOVQ 0(AX), AX		

  0x44905c		488d542418		LEAQ 0x18(SP), DX	

  0x449061		e90a000000		JMP runtime.aeshashbody(SB)	

TEXT runtime.aeshashbody(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449070		f30f7e442410		MOVQ 0x10(SP), X0	

  0x449076		660fc4c104		PINSRW $0x4, CX, X0	

  0x44907b		f30f70c000		PSHUFHW $0x0, X0, X0	

  0x449080		660f6fc8		MOVDQA X0, X1		

  0x449084		660fef05343f0900	PXOR runtime.aeskeysched(SB), X0	

  0x44908c		660f38dcc0		AESENC X0, X0		

  0x449091		4883f910		CMPQ $0x10, CX		

  0x449095		7224			JB 0x4490bb		

  0x449097		747f			JE 0x449118		

  0x449099		4883f920		CMPQ $0x20, CX		

  0x44909d		767f			JBE 0x44911e		

  0x44909f		4883f940		CMPQ $0x40, CX		

  0x4490a3		0f86bb000000		JBE 0x449164		

  0x4490a9		4881f980000000		CMPQ $0x80, CX		

  0x4490b0		0f864f010000		JBE 0x449205		

  0x4490b6		e9d1020000		JMP 0x44938c		

  0x4490bb		4885c9			TESTQ CX, CX		

  0x4490be		744e			JE 0x44910e		

  0x4490c0		4883c010		ADDQ $0x10, AX		

  0x4490c4		66a9f00f		TESTW $0xff0, AX	

  0x4490c8		742c			JE 0x4490f6		

  0x4490ca		f30f6f48f0		MOVDQU -0x10(AX), X1	

  0x4490cf		4801c9			ADDQ CX, CX		

  0x4490d2		488d05a7500300		LEAQ masks(SB), AX	

  0x4490d9		660fdb0cc8		PAND 0(AX)(CX*8), X1	

  0x4490de		660fefc8		PXOR X0, X1		

  0x4490e2		660f38dcc9		AESENC X1, X1		

  0x4490e7		660f38dcc9		AESENC X1, X1		

  0x4490ec		660f38dcc9		AESENC X1, X1		

  0x4490f1		660fd60a		MOVQ X1, 0(DX)		

  0x4490f5		c3			RET			

  0x4490f6		f30f6f4c08e0		MOVDQU -0x20(AX)(CX*1), X1	

  0x4490fc		4801c9			ADDQ CX, CX		

  0x4490ff		488d057a510300		LEAQ shifts(SB), AX	

  0x449106		660f38000cc8		PSHUFB 0(AX)(CX*8), X1	

  0x44910c		ebd0			JMP 0x4490de		

  0x44910e		660f38dcc0		AESENC X0, X0		

  0x449113		660fd602		MOVQ X0, 0(DX)		

  0x449117		c3			RET			

  0x449118		f30f6f08		MOVDQU 0(AX), X1	

  0x44911c		ebc0			JMP 0x4490de		

  0x44911e		660fef0daa3e0900	PXOR runtime.aeskeysched+16(SB), X1	

  0x449126		660f38dcc9		AESENC X1, X1		

  0x44912b		f30f6f10		MOVDQU 0(AX), X2	

  0x44912f		f30f6f5c08f0		MOVDQU -0x10(AX)(CX*1), X3	

  0x449135		660fefd0		PXOR X0, X2		

  0x449139		660fefd9		PXOR X1, X3		

  0x44913d		660f38dcd2		AESENC X2, X2		

  0x449142		660f38dcdb		AESENC X3, X3		

  0x449147		660f38dcd2		AESENC X2, X2		

  0x44914c		660f38dcdb		AESENC X3, X3		

  0x449151		660f38dcd2		AESENC X2, X2		

  0x449156		660f38dcdb		AESENC X3, X3		

  0x44915b		660fefd3		PXOR X3, X2		

  0x44915f		660fd612		MOVQ X2, 0(DX)		

  0x449163		c3			RET			

  0x449164		660f6fd1		MOVDQA X1, X2		

  0x449168		660f6fd9		MOVDQA X1, X3		

  0x44916c		660fef0d5c3e0900	PXOR runtime.aeskeysched+16(SB), X1	

  0x449174		660fef15643e0900	PXOR runtime.aeskeysched+32(SB), X2	

  0x44917c		660fef1d6c3e0900	PXOR runtime.aeskeysched+48(SB), X3	

  0x449184		660f38dcc9		AESENC X1, X1		

  0x449189		660f38dcd2		AESENC X2, X2		

  0x44918e		660f38dcdb		AESENC X3, X3		

  0x449193		f30f6f20		MOVDQU 0(AX), X4	

  0x449197		f30f6f6810		MOVDQU 0x10(AX), X5	

  0x44919c		f30f6f7408e0		MOVDQU -0x20(AX)(CX*1), X6	

  0x4491a2		f30f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X7	

  0x4491a8		660fefe0		PXOR X0, X4		

  0x4491ac		660fefe9		PXOR X1, X5		

  0x4491b0		660feff2		PXOR X2, X6		

  0x4491b4		660feffb		PXOR X3, X7		

  0x4491b8		660f38dce4		AESENC X4, X4		

  0x4491bd		660f38dced		AESENC X5, X5		

  0x4491c2		660f38dcf6		AESENC X6, X6		

  0x4491c7		660f38dcff		AESENC X7, X7		

  0x4491cc		660f38dce4		AESENC X4, X4		

  0x4491d1		660f38dced		AESENC X5, X5		

  0x4491d6		660f38dcf6		AESENC X6, X6		

  0x4491db		660f38dcff		AESENC X7, X7		

  0x4491e0		660f38dce4		AESENC X4, X4		

  0x4491e5		660f38dced		AESENC X5, X5		

  0x4491ea		660f38dcf6		AESENC X6, X6		

  0x4491ef		660f38dcff		AESENC X7, X7		

  0x4491f4		660fefe6		PXOR X6, X4		

  0x4491f8		660fefef		PXOR X7, X5		

  0x4491fc		660fefe5		PXOR X5, X4		

  0x449200		660fd622		MOVQ X4, 0(DX)		

  0x449204		c3			RET			

  0x449205		660f6fd1		MOVDQA X1, X2		

  0x449209		660f6fd9		MOVDQA X1, X3		

  0x44920d		660f6fe1		MOVDQA X1, X4		

  0x449211		660f6fe9		MOVDQA X1, X5		

  0x449215		660f6ff1		MOVDQA X1, X6		

  0x449219		660f6ff9		MOVDQA X1, X7		

  0x44921d		660fef0dab3d0900	PXOR runtime.aeskeysched+16(SB), X1	

  0x449225		660fef15b33d0900	PXOR runtime.aeskeysched+32(SB), X2	

  0x44922d		660fef1dbb3d0900	PXOR runtime.aeskeysched+48(SB), X3	

  0x449235		660fef25c33d0900	PXOR runtime.aeskeysched+64(SB), X4	

  0x44923d		660fef2dcb3d0900	PXOR runtime.aeskeysched+80(SB), X5	

  0x449245		660fef35d33d0900	PXOR runtime.aeskeysched+96(SB), X6	

  0x44924d		660fef3ddb3d0900	PXOR runtime.aeskeysched+112(SB), X7	

  0x449255		660f38dcc9		AESENC X1, X1		

  0x44925a		660f38dcd2		AESENC X2, X2		

  0x44925f		660f38dcdb		AESENC X3, X3		

  0x449264		660f38dce4		AESENC X4, X4		

  0x449269		660f38dced		AESENC X5, X5		

  0x44926e		660f38dcf6		AESENC X6, X6		

  0x449273		660f38dcff		AESENC X7, X7		

  0x449278		f3440f6f00		MOVDQU 0(AX), X8	

  0x44927d		f3440f6f4810		MOVDQU 0x10(AX), X9	

  0x449283		f3440f6f5020		MOVDQU 0x20(AX), X10	

  0x449289		f3440f6f5830		MOVDQU 0x30(AX), X11	

  0x44928f		f3440f6f6408c0		MOVDQU -0x40(AX)(CX*1), X12	

  0x449296		f3440f6f6c08d0		MOVDQU -0x30(AX)(CX*1), X13	

  0x44929d		f3440f6f7408e0		MOVDQU -0x20(AX)(CX*1), X14	

  0x4492a4		f3440f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X15	

  0x4492ab		66440fefc0		PXOR X0, X8		

  0x4492b0		66440fefc9		PXOR X1, X9		

  0x4492b5		66440fefd2		PXOR X2, X10		

  0x4492ba		66440fefdb		PXOR X3, X11		

  0x4492bf		66440fefe4		PXOR X4, X12		

  0x4492c4		66440fefed		PXOR X5, X13		

  0x4492c9		66440feff6		PXOR X6, X14		

  0x4492ce		66440fefff		PXOR X7, X15		

  0x4492d3		66450f38dcc0		AESENC X8, X8		

  0x4492d9		66450f38dcc9		AESENC X9, X9		

  0x4492df		66450f38dcd2		AESENC X10, X10		

  0x4492e5		66450f38dcdb		AESENC X11, X11		

  0x4492eb		66450f38dce4		AESENC X12, X12		

  0x4492f1		66450f38dced		AESENC X13, X13		

  0x4492f7		66450f38dcf6		AESENC X14, X14		

  0x4492fd		66450f38dcff		AESENC X15, X15		

  0x449303		66450f38dcc0		AESENC X8, X8		

  0x449309		66450f38dcc9		AESENC X9, X9		

  0x44930f		66450f38dcd2		AESENC X10, X10		

  0x449315		66450f38dcdb		AESENC X11, X11		

  0x44931b		66450f38dce4		AESENC X12, X12		

  0x449321		66450f38dced		AESENC X13, X13		

  0x449327		66450f38dcf6		AESENC X14, X14		

  0x44932d		66450f38dcff		AESENC X15, X15		

  0x449333		66450f38dcc0		AESENC X8, X8		

  0x449339		66450f38dcc9		AESENC X9, X9		

  0x44933f		66450f38dcd2		AESENC X10, X10		

  0x449345		66450f38dcdb		AESENC X11, X11		

  0x44934b		66450f38dce4		AESENC X12, X12		

  0x449351		66450f38dced		AESENC X13, X13		

  0x449357		66450f38dcf6		AESENC X14, X14		

  0x44935d		66450f38dcff		AESENC X15, X15		

  0x449363		66450fefc4		PXOR X12, X8		

  0x449368		66450fefcd		PXOR X13, X9		

  0x44936d		66450fefd6		PXOR X14, X10		

  0x449372		66450fefdf		PXOR X15, X11		

  0x449377		66450fefc2		PXOR X10, X8		

  0x44937c		66450fefcb		PXOR X11, X9		

  0x449381		66450fefc1		PXOR X9, X8		

  0x449386		66440fd602		MOVQ X8, 0(DX)		

  0x44938b		c3			RET			

  0x44938c		660f6fd1		MOVDQA X1, X2		

  0x449390		660f6fd9		MOVDQA X1, X3		

  0x449394		660f6fe1		MOVDQA X1, X4		

  0x449398		660f6fe9		MOVDQA X1, X5		

  0x44939c		660f6ff1		MOVDQA X1, X6		

  0x4493a0		660f6ff9		MOVDQA X1, X7		

  0x4493a4		660fef0d243c0900	PXOR runtime.aeskeysched+16(SB), X1	

  0x4493ac		660fef152c3c0900	PXOR runtime.aeskeysched+32(SB), X2	

  0x4493b4		660fef1d343c0900	PXOR runtime.aeskeysched+48(SB), X3	

  0x4493bc		660fef253c3c0900	PXOR runtime.aeskeysched+64(SB), X4	

  0x4493c4		660fef2d443c0900	PXOR runtime.aeskeysched+80(SB), X5	

  0x4493cc		660fef354c3c0900	PXOR runtime.aeskeysched+96(SB), X6	

  0x4493d4		660fef3d543c0900	PXOR runtime.aeskeysched+112(SB), X7	

  0x4493dc		660f38dcc9		AESENC X1, X1		

  0x4493e1		660f38dcd2		AESENC X2, X2		

  0x4493e6		660f38dcdb		AESENC X3, X3		

  0x4493eb		660f38dce4		AESENC X4, X4		

  0x4493f0		660f38dced		AESENC X5, X5		

  0x4493f5		660f38dcf6		AESENC X6, X6		

  0x4493fa		660f38dcff		AESENC X7, X7		

  0x4493ff		f3440f6f440880		MOVDQU -0x80(AX)(CX*1), X8	

  0x449406		f3440f6f4c0890		MOVDQU -0x70(AX)(CX*1), X9	

  0x44940d		f3440f6f5408a0		MOVDQU -0x60(AX)(CX*1), X10	

  0x449414		f3440f6f5c08b0		MOVDQU -0x50(AX)(CX*1), X11	

  0x44941b		f3440f6f6408c0		MOVDQU -0x40(AX)(CX*1), X12	

  0x449422		f3440f6f6c08d0		MOVDQU -0x30(AX)(CX*1), X13	

  0x449429		f3440f6f7408e0		MOVDQU -0x20(AX)(CX*1), X14	

  0x449430		f3440f6f7c08f0		MOVDQU -0x10(AX)(CX*1), X15	

  0x449437		66440fefc0		PXOR X0, X8		

  0x44943c		66440fefc9		PXOR X1, X9		

  0x449441		66440fefd2		PXOR X2, X10		

  0x449446		66440fefdb		PXOR X3, X11		

  0x44944b		66440fefe4		PXOR X4, X12		

  0x449450		66440fefed		PXOR X5, X13		

  0x449455		66440feff6		PXOR X6, X14		

  0x44945a		66440fefff		PXOR X7, X15		

  0x44945f		48ffc9			DECQ CX			

  0x449462		48c1e907		SHRQ $0x7, CX		

  0x449466		66450f38dcc0		AESENC X8, X8		

  0x44946c		66450f38dcc9		AESENC X9, X9		

  0x449472		66450f38dcd2		AESENC X10, X10		

  0x449478		66450f38dcdb		AESENC X11, X11		

  0x44947e		66450f38dce4		AESENC X12, X12		

  0x449484		66450f38dced		AESENC X13, X13		

  0x44948a		66450f38dcf6		AESENC X14, X14		

  0x449490		66450f38dcff		AESENC X15, X15		

  0x449496		f30f6f00		MOVDQU 0(AX), X0	

  0x44949a		f30f6f4810		MOVDQU 0x10(AX), X1	

  0x44949f		f30f6f5020		MOVDQU 0x20(AX), X2	

  0x4494a4		f30f6f5830		MOVDQU 0x30(AX), X3	

  0x4494a9		66440f38dcc0		AESENC X0, X8		

  0x4494af		66440f38dcc9		AESENC X1, X9		

  0x4494b5		66440f38dcd2		AESENC X2, X10		

  0x4494bb		66440f38dcdb		AESENC X3, X11		

  0x4494c1		f30f6f6040		MOVDQU 0x40(AX), X4	

  0x4494c6		f30f6f6850		MOVDQU 0x50(AX), X5	

  0x4494cb		f30f6f7060		MOVDQU 0x60(AX), X6	

  0x4494d0		f30f6f7870		MOVDQU 0x70(AX), X7	

  0x4494d5		66440f38dce4		AESENC X4, X12		

  0x4494db		66440f38dced		AESENC X5, X13		

  0x4494e1		66440f38dcf6		AESENC X6, X14		

  0x4494e7		66440f38dcff		AESENC X7, X15		

  0x4494ed		480580000000		ADDQ $0x80, AX		

  0x4494f3		48ffc9			DECQ CX			

  0x4494f6		0f856affffff		JNE 0x449466		

  0x4494fc		66450f38dcc0		AESENC X8, X8		

  0x449502		66450f38dcc9		AESENC X9, X9		

  0x449508		66450f38dcd2		AESENC X10, X10		

  0x44950e		66450f38dcdb		AESENC X11, X11		

  0x449514		66450f38dce4		AESENC X12, X12		

  0x44951a		66450f38dced		AESENC X13, X13		

  0x449520		66450f38dcf6		AESENC X14, X14		

  0x449526		66450f38dcff		AESENC X15, X15		

  0x44952c		66450f38dcc0		AESENC X8, X8		

  0x449532		66450f38dcc9		AESENC X9, X9		

  0x449538		66450f38dcd2		AESENC X10, X10		

  0x44953e		66450f38dcdb		AESENC X11, X11		

  0x449544		66450f38dce4		AESENC X12, X12		

  0x44954a		66450f38dced		AESENC X13, X13		

  0x449550		66450f38dcf6		AESENC X14, X14		

  0x449556		66450f38dcff		AESENC X15, X15		

  0x44955c		66450f38dcc0		AESENC X8, X8		

  0x449562		66450f38dcc9		AESENC X9, X9		

  0x449568		66450f38dcd2		AESENC X10, X10		

  0x44956e		66450f38dcdb		AESENC X11, X11		

  0x449574		66450f38dce4		AESENC X12, X12		

  0x44957a		66450f38dced		AESENC X13, X13		

  0x449580		66450f38dcf6		AESENC X14, X14		

  0x449586		66450f38dcff		AESENC X15, X15		

  0x44958c		66450fefc4		PXOR X12, X8		

  0x449591		66450fefcd		PXOR X13, X9		

  0x449596		66450fefd6		PXOR X14, X10		

  0x44959b		66450fefdf		PXOR X15, X11		

  0x4495a0		66450fefc2		PXOR X10, X8		

  0x4495a5		66450fefcb		PXOR X11, X9		

  0x4495aa		66450fefc1		PXOR X9, X8		

  0x4495af		66440fd602		MOVQ X8, 0(DX)		

  0x4495b4		c3			RET			

TEXT runtime.aeshash32(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x4495c0		488b442408		MOVQ 0x8(SP), AX	

  0x4495c5		f30f7e442410		MOVQ 0x10(SP), X0	

  0x4495cb		660f3a220002		PINSRD $0x2, 0(AX), X0	

  0x4495d1		660f38dc05e6390900	AESENC runtime.aeskeysched(SB), X0	

  0x4495da		660f38dc05ed390900	AESENC runtime.aeskeysched+16(SB), X0	

  0x4495e3		660f38dc05f4390900	AESENC runtime.aeskeysched+32(SB), X0	

  0x4495ec		660fd6442418		MOVQ X0, 0x18(SP)	

  0x4495f2		c3			RET			

TEXT runtime.aeshash64(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449600		488b442408		MOVQ 0x8(SP), AX	

  0x449605		f30f7e442410		MOVQ 0x10(SP), X0	

  0x44960b		66480f3a220001		PINSRQ $0x1, 0(AX), X0	

  0x449612		660f38dc05a5390900	AESENC runtime.aeskeysched(SB), X0	

  0x44961b		660f38dc05ac390900	AESENC runtime.aeskeysched+16(SB), X0	

  0x449624		660f38dc05b3390900	AESENC runtime.aeskeysched+32(SB), X0	

  0x44962d		660fd6442418		MOVQ X0, 0x18(SP)	

  0x449633		c3			RET			

TEXT runtime.checkASM(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449640		488d05394b0300		LEAQ masks(SB), AX	

  0x449647		488d1d324c0300		LEAQ shifts(SB), BX	

  0x44964e		4809d8			ORQ BX, AX		

  0x449651		48a90f000000		TESTQ $0xf, AX		

  0x449657		0f94442408		SETE 0x8(SP)		

  0x44965c		c3			RET			

TEXT runtime.return0(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449660		b800000000		MOVL $0x0, AX		

  0x449665		c3			RET			

TEXT runtime.goexit(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449670		90			NOPL			

  0x449671		e87a1dfeff		CALL runtime.goexit1(SB)	

  0x449676		90			NOPL			

TEXT runtime.gcWriteBarrier(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449680		4881ec80000000		SUBQ $0x80, SP		
  0x449687		48896c2478		MOVQ BP, 0x78(SP)	
  0x44968c		488d6c2478		LEAQ 0x78(SP), BP	

  0x449691		4c89742468		MOVQ R14, 0x68(SP)	

  0x449696		4c896c2470		MOVQ R13, 0x70(SP)	

  0x44969b		644c8b2c25f8ffffff	MOVQ FS:0xfffffff8, R13	

  0x4496a4		4d8b6d30		MOVQ 0x30(R13), R13	

  0x4496a8		4d8badd0000000		MOVQ 0xd0(R13), R13	

  0x4496af		4d8bb520130000		MOVQ 0x1320(R13), R14	

  0x4496b6		4d8d7610		LEAQ 0x10(R14), R14	

  0x4496ba		4d89b520130000		MOVQ R14, 0x1320(R13)	

  0x4496c1		4d3bb528130000		CMPQ 0x1328(R13), R14	

  0x4496c8		498946f0		MOVQ AX, -0x10(R14)	

  0x4496cc		4c8b2f			MOVQ 0(DI), R13		

  0x4496cf		4d896ef8		MOVQ R13, -0x8(R14)	

  0x4496d3		741a			JE 0x4496ef		

  0x4496d5		4c8b742468		MOVQ 0x68(SP), R14	

  0x4496da		4c8b6c2470		MOVQ 0x70(SP), R13	

  0x4496df		488907			MOVQ AX, 0(DI)		

  0x4496e2		488b6c2478		MOVQ 0x78(SP), BP	
  0x4496e7		4881c480000000		ADDQ $0x80, SP		
  0x4496ee		c3			RET			

  0x4496ef		48893c24		MOVQ DI, 0(SP)		

  0x4496f3		4889442408		MOVQ AX, 0x8(SP)	

  0x4496f8		48895c2410		MOVQ BX, 0x10(SP)	

  0x4496fd		48894c2418		MOVQ CX, 0x18(SP)	

  0x449702		4889542420		MOVQ DX, 0x20(SP)	

  0x449707		4889742428		MOVQ SI, 0x28(SP)	

  0x44970c		48896c2430		MOVQ BP, 0x30(SP)	

  0x449711		4c89442438		MOVQ R8, 0x38(SP)	

  0x449716		4c894c2440		MOVQ R9, 0x40(SP)	

  0x44971b		4c89542448		MOVQ R10, 0x48(SP)	

  0x449720		4c895c2450		MOVQ R11, 0x50(SP)	

  0x449725		4c89642458		MOVQ R12, 0x58(SP)	

  0x44972a		4c897c2460		MOVQ R15, 0x60(SP)	

  0x44972f		e8cc74fdff		CALL runtime.wbBufFlush(SB)	

  0x449734		488b3c24		MOVQ 0(SP), DI		

  0x449738		488b442408		MOVQ 0x8(SP), AX	

  0x44973d		488b5c2410		MOVQ 0x10(SP), BX	

  0x449742		488b4c2418		MOVQ 0x18(SP), CX	

  0x449747		488b542420		MOVQ 0x20(SP), DX	

  0x44974c		488b742428		MOVQ 0x28(SP), SI	

  0x449751		488b6c2430		MOVQ 0x30(SP), BP	

  0x449756		4c8b442438		MOVQ 0x38(SP), R8	

  0x44975b		4c8b4c2440		MOVQ 0x40(SP), R9	

  0x449760		4c8b542448		MOVQ 0x48(SP), R10	

  0x449765		4c8b5c2450		MOVQ 0x50(SP), R11	

  0x44976a		4c8b642458		MOVQ 0x58(SP), R12	

  0x44976f		4c8b7c2460		MOVQ 0x60(SP), R15	

  0x449774		e95cffffff		JMP 0x4496d5		

TEXT runtime.debugCallV1(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449780		4881eca0000000		SUBQ $0xa0, SP		
  0x449787		4889ac2498000000	MOVQ BP, 0x98(SP)	
  0x44978f		488dac2498000000	LEAQ 0x98(SP), BP	

  0x449797		4c897c2420		MOVQ R15, 0x20(SP)	

  0x44979c		4c89742428		MOVQ R14, 0x28(SP)	

  0x4497a1		4c896c2430		MOVQ R13, 0x30(SP)	

  0x4497a6		4c89642438		MOVQ R12, 0x38(SP)	

  0x4497ab		4c895c2440		MOVQ R11, 0x40(SP)	

  0x4497b0		4c89542448		MOVQ R10, 0x48(SP)	

  0x4497b5		4c894c2450		MOVQ R9, 0x50(SP)	

  0x4497ba		4c89442458		MOVQ R8, 0x58(SP)	

  0x4497bf		48897c2460		MOVQ DI, 0x60(SP)	

  0x4497c4		4889742468		MOVQ SI, 0x68(SP)	

  0x4497c9		48896c2470		MOVQ BP, 0x70(SP)	

  0x4497ce		48895c2478		MOVQ BX, 0x78(SP)	

  0x4497d3		4889942480000000	MOVQ DX, 0x80(SP)	

  0x4497db		488b942490000000	MOVQ 0x90(SP), DX	

  0x4497e3		48898c2488000000	MOVQ CX, 0x88(SP)	

  0x4497eb		4889842490000000	MOVQ AX, 0x90(SP)	

  0x4497f3		4889542418		MOVQ DX, 0x18(SP)	

  0x4497f8		488b8424a0000000	MOVQ 0xa0(SP), AX	

  0x449800		48890424		MOVQ AX, 0(SP)		

  0x449804		e8d7c6fbff		CALL runtime.debugCallCheck(SB)	

  0x449809		488b442408		MOVQ 0x8(SP), AX	

  0x44980e		4885c0			TESTQ AX, AX		

  0x449811		741b			JE 0x44982e		

  0x449813		48890424		MOVQ AX, 0(SP)		

  0x449817		488b442410		MOVQ 0x10(SP), AX	

  0x44981c		4889442408		MOVQ AX, 0x8(SP)	

  0x449821		48c7c008000000		MOVQ $0x8, AX		

  0x449828		cc			INT $0x3		

  0x449829		e96f010000		JMP 0x44999d		

  0x44982e		488b442418		MOVQ 0x18(SP), AX	

  0x449833		4883f820		CMPQ $0x20, AX			
  0x449837		7715			JA 0x44984e			
  0x449839		488d05d0010000		LEAQ debugCall32(SB), AX	
  0x449840		48890424		MOVQ AX, 0(SP)			
  0x449844		e877c7fbff		CALL runtime.debugCallWrap(SB)	
  0x449849		e94f010000		JMP 0x44999d			

  0x44984e		4883f840		CMPQ $0x40, AX			
  0x449852		7715			JA 0x449869			
  0x449854		488d0505020000		LEAQ debugCall64(SB), AX	
  0x44985b		48890424		MOVQ AX, 0(SP)			
  0x44985f		e85cc7fbff		CALL runtime.debugCallWrap(SB)	
  0x449864		e934010000		JMP 0x44999d			

  0x449869		483d80000000		CMPQ $0x80, AX			
  0x44986f		7715			JA 0x449886			
  0x449871		488d0538020000		LEAQ debugCall128(SB), AX	
  0x449878		48890424		MOVQ AX, 0(SP)			
  0x44987c		e83fc7fbff		CALL runtime.debugCallWrap(SB)	
  0x449881		e917010000		JMP 0x44999d			

  0x449886		483d00010000		CMPQ $0x100, AX			
  0x44988c		7715			JA 0x4498a3			
  0x44988e		488d058b020000		LEAQ debugCall256(SB), AX	
  0x449895		48890424		MOVQ AX, 0(SP)			
  0x449899		e822c7fbff		CALL runtime.debugCallWrap(SB)	
  0x44989e		e9fa000000		JMP 0x44999d			

  0x4498a3		483d00020000		CMPQ $0x200, AX			
  0x4498a9		7715			JA 0x4498c0			
  0x4498ab		488d05de020000		LEAQ debugCall512(SB), AX	
  0x4498b2		48890424		MOVQ AX, 0(SP)			
  0x4498b6		e805c7fbff		CALL runtime.debugCallWrap(SB)	
  0x4498bb		e9dd000000		JMP 0x44999d			

  0x4498c0		483d00040000		CMPQ $0x400, AX			
  0x4498c6		7715			JA 0x4498dd			
  0x4498c8		488d0531030000		LEAQ debugCall1024(SB), AX	
  0x4498cf		48890424		MOVQ AX, 0(SP)			
  0x4498d3		e8e8c6fbff		CALL runtime.debugCallWrap(SB)	
  0x4498d8		e9c0000000		JMP 0x44999d			

  0x4498dd		483d00080000		CMPQ $0x800, AX			
  0x4498e3		7715			JA 0x4498fa			
  0x4498e5		488d0584030000		LEAQ debugCall2048(SB), AX	
  0x4498ec		48890424		MOVQ AX, 0(SP)			
  0x4498f0		e8cbc6fbff		CALL runtime.debugCallWrap(SB)	
  0x4498f5		e9a3000000		JMP 0x44999d			

  0x4498fa		483d00100000		CMPQ $0x1000, AX		
  0x449900		7715			JA 0x449917			
  0x449902		488d05d7030000		LEAQ debugCall4096(SB), AX	
  0x449909		48890424		MOVQ AX, 0(SP)			
  0x44990d		e8aec6fbff		CALL runtime.debugCallWrap(SB)	
  0x449912		e986000000		JMP 0x44999d			

  0x449917		483d00200000		CMPQ $0x2000, AX		
  0x44991d		7712			JA 0x449931			
  0x44991f		488d054a040000		LEAQ debugCall8192(SB), AX	
  0x449926		48890424		MOVQ AX, 0(SP)			
  0x44992a		e891c6fbff		CALL runtime.debugCallWrap(SB)	
  0x44992f		eb6c			JMP 0x44999d			

  0x449931		483d00400000		CMPQ $0x4000, AX		
  0x449937		7712			JA 0x44994b			
  0x449939		488d05c0040000		LEAQ debugCall16384(SB), AX	
  0x449940		48890424		MOVQ AX, 0(SP)			
  0x449944		e877c6fbff		CALL runtime.debugCallWrap(SB)	
  0x449949		eb52			JMP 0x44999d			

  0x44994b		483d00800000		CMPQ $0x8000, AX		
  0x449951		7712			JA 0x449965			
  0x449953		488d0536050000		LEAQ debugCall32768(SB), AX	
  0x44995a		48890424		MOVQ AX, 0(SP)			
  0x44995e		e85dc6fbff		CALL runtime.debugCallWrap(SB)	
  0x449963		eb38			JMP 0x44999d			

  0x449965		483d00000100		CMPQ $0x10000, AX		
  0x44996b		7712			JA 0x44997f			
  0x44996d		488d05ac050000		LEAQ debugCall65536(SB), AX	
  0x449974		48890424		MOVQ AX, 0(SP)			
  0x449978		e843c6fbff		CALL runtime.debugCallWrap(SB)	
  0x44997d		eb1e			JMP 0x44999d			

  0x44997f		488d05ba360300		LEAQ debugCallFrameTooLarge(SB), AX	

  0x449986		48890424		MOVQ AX, 0(SP)		

  0x44998a		48c744240814000000	MOVQ $0x14, 0x8(SP)	

  0x449993		48c7c008000000		MOVQ $0x8, AX		

  0x44999a		cc			INT $0x3		

  0x44999b		eb00			JMP 0x44999d		

  0x44999d		48c7c010000000		MOVQ $0x10, AX		

  0x4499a4		cc			INT $0x3		

  0x4499a5		488b842490000000	MOVQ 0x90(SP), AX	

  0x4499ad		488b8c2488000000	MOVQ 0x88(SP), CX	

  0x4499b5		488b942480000000	MOVQ 0x80(SP), DX	

  0x4499bd		488b5c2478		MOVQ 0x78(SP), BX	

  0x4499c2		488b6c2470		MOVQ 0x70(SP), BP	

  0x4499c7		488b742468		MOVQ 0x68(SP), SI	

  0x4499cc		488b7c2460		MOVQ 0x60(SP), DI	

  0x4499d1		4c8b442458		MOVQ 0x58(SP), R8	

  0x4499d6		4c8b4c2450		MOVQ 0x50(SP), R9	

  0x4499db		4c8b542448		MOVQ 0x48(SP), R10	

  0x4499e0		4c8b5c2440		MOVQ 0x40(SP), R11	

  0x4499e5		4c8b642438		MOVQ 0x38(SP), R12	

  0x4499ea		4c8b6c2430		MOVQ 0x30(SP), R13	

  0x4499ef		4c8b742428		MOVQ 0x28(SP), R14	

  0x4499f4		4c8b7c2420		MOVQ 0x20(SP), R15	

  0x4499f9		488bac2498000000	MOVQ 0x98(SP), BP	
  0x449a01		4881c4a0000000		ADDQ $0xa0, SP		
  0x449a08		c3			RET			

TEXT debugCall32(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449a10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x449a19		4883ec28		SUBQ $0x28, SP		
  0x449a1d		48896c2420		MOVQ BP, 0x20(SP)	
  0x449a22		488d6c2420		LEAQ 0x20(SP), BP	
  0x449a27		488b5920		MOVQ 0x20(CX), BX	
  0x449a2b		4885db			TESTQ BX, BX		
  0x449a2e		751a			JNE 0x449a4a		
  0x449a30		48c7c000000000		MOVQ $0x0, AX		
  0x449a37		cc			INT $0x3		
  0x449a38		48c7c001000000		MOVQ $0x1, AX		
  0x449a3f		cc			INT $0x3		
  0x449a40		488b6c2420		MOVQ 0x20(SP), BP	
  0x449a45		4883c428		ADDQ $0x28, SP		
  0x449a49		c3			RET			
  0x449a4a		488d7c2430		LEAQ 0x30(SP), DI	
  0x449a4f		48393b			CMPQ DI, 0(BX)		
  0x449a52		75dc			JNE 0x449a30		
  0x449a54		488923			MOVQ SP, 0(BX)		
  0x449a57		ebd7			JMP 0x449a30		

TEXT debugCall64(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449a60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x449a69		4883ec48		SUBQ $0x48, SP		
  0x449a6d		48896c2440		MOVQ BP, 0x40(SP)	
  0x449a72		488d6c2440		LEAQ 0x40(SP), BP	
  0x449a77		488b5920		MOVQ 0x20(CX), BX	
  0x449a7b		4885db			TESTQ BX, BX		
  0x449a7e		751a			JNE 0x449a9a		
  0x449a80		48c7c000000000		MOVQ $0x0, AX		
  0x449a87		cc			INT $0x3		
  0x449a88		48c7c001000000		MOVQ $0x1, AX		
  0x449a8f		cc			INT $0x3		
  0x449a90		488b6c2440		MOVQ 0x40(SP), BP	
  0x449a95		4883c448		ADDQ $0x48, SP		
  0x449a99		c3			RET			
  0x449a9a		488d7c2450		LEAQ 0x50(SP), DI	
  0x449a9f		48393b			CMPQ DI, 0(BX)		
  0x449aa2		75dc			JNE 0x449a80		
  0x449aa4		488923			MOVQ SP, 0(BX)		
  0x449aa7		ebd7			JMP 0x449a80		

TEXT debugCall128(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449ab0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449ab9		488d4424f8		LEAQ -0x8(SP), AX			
  0x449abe		483b4110		CMPQ 0x10(CX), AX			
  0x449ac2		7640			JBE 0x449b04				
  0x449ac4		4881ec88000000		SUBQ $0x88, SP				
  0x449acb		4889ac2480000000	MOVQ BP, 0x80(SP)			
  0x449ad3		488dac2480000000	LEAQ 0x80(SP), BP			
  0x449adb		488b5920		MOVQ 0x20(CX), BX			
  0x449adf		4885db			TESTQ BX, BX				
  0x449ae2		7527			JNE 0x449b0b				
  0x449ae4		48c7c000000000		MOVQ $0x0, AX				
  0x449aeb		cc			INT $0x3				
  0x449aec		48c7c001000000		MOVQ $0x1, AX				
  0x449af3		cc			INT $0x3				
  0x449af4		488bac2480000000	MOVQ 0x80(SP), BP			
  0x449afc		4881c488000000		ADDQ $0x88, SP				
  0x449b03		c3			RET					
  0x449b04		e877ddffff		CALL runtime.morestack_noctxt(SB)	
  0x449b09		eba5			JMP debugCall128(SB)			
  0x449b0b		488dbc2490000000	LEAQ 0x90(SP), DI			
  0x449b13		48393b			CMPQ DI, 0(BX)				
  0x449b16		75cc			JNE 0x449ae4				
  0x449b18		488923			MOVQ SP, 0(BX)				
  0x449b1b		ebc7			JMP 0x449ae4				

TEXT debugCall256(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449b20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449b29		488d842478ffffff	LEAQ 0xffffff78(SP), AX			
  0x449b31		483b4110		CMPQ 0x10(CX), AX			
  0x449b35		7640			JBE 0x449b77				
  0x449b37		4881ec08010000		SUBQ $0x108, SP				
  0x449b3e		4889ac2400010000	MOVQ BP, 0x100(SP)			
  0x449b46		488dac2400010000	LEAQ 0x100(SP), BP			
  0x449b4e		488b5920		MOVQ 0x20(CX), BX			
  0x449b52		4885db			TESTQ BX, BX				
  0x449b55		7527			JNE 0x449b7e				
  0x449b57		48c7c000000000		MOVQ $0x0, AX				
  0x449b5e		cc			INT $0x3				
  0x449b5f		48c7c001000000		MOVQ $0x1, AX				
  0x449b66		cc			INT $0x3				
  0x449b67		488bac2400010000	MOVQ 0x100(SP), BP			
  0x449b6f		4881c408010000		ADDQ $0x108, SP				
  0x449b76		c3			RET					
  0x449b77		e804ddffff		CALL runtime.morestack_noctxt(SB)	
  0x449b7c		eba2			JMP debugCall256(SB)			
  0x449b7e		488dbc2410010000	LEAQ 0x110(SP), DI			
  0x449b86		48393b			CMPQ DI, 0(BX)				
  0x449b89		75cc			JNE 0x449b57				
  0x449b8b		488923			MOVQ SP, 0(BX)				
  0x449b8e		ebc7			JMP 0x449b57				

TEXT debugCall512(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449b90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449b99		488d842478feffff	LEAQ 0xfffffe78(SP), AX			
  0x449ba1		483b4110		CMPQ 0x10(CX), AX			
  0x449ba5		7640			JBE 0x449be7				
  0x449ba7		4881ec08020000		SUBQ $0x208, SP				
  0x449bae		4889ac2400020000	MOVQ BP, 0x200(SP)			
  0x449bb6		488dac2400020000	LEAQ 0x200(SP), BP			
  0x449bbe		488b5920		MOVQ 0x20(CX), BX			
  0x449bc2		4885db			TESTQ BX, BX				
  0x449bc5		7527			JNE 0x449bee				
  0x449bc7		48c7c000000000		MOVQ $0x0, AX				
  0x449bce		cc			INT $0x3				
  0x449bcf		48c7c001000000		MOVQ $0x1, AX				
  0x449bd6		cc			INT $0x3				
  0x449bd7		488bac2400020000	MOVQ 0x200(SP), BP			
  0x449bdf		4881c408020000		ADDQ $0x208, SP				
  0x449be6		c3			RET					
  0x449be7		e894dcffff		CALL runtime.morestack_noctxt(SB)	
  0x449bec		eba2			JMP debugCall512(SB)			
  0x449bee		488dbc2410020000	LEAQ 0x210(SP), DI			
  0x449bf6		48393b			CMPQ DI, 0(BX)				
  0x449bf9		75cc			JNE 0x449bc7				
  0x449bfb		488923			MOVQ SP, 0(BX)				
  0x449bfe		ebc7			JMP 0x449bc7				

TEXT debugCall1024(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449c00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449c09		488d842478fcffff	LEAQ 0xfffffc78(SP), AX			
  0x449c11		483b4110		CMPQ 0x10(CX), AX			
  0x449c15		7640			JBE 0x449c57				
  0x449c17		4881ec08040000		SUBQ $0x408, SP				
  0x449c1e		4889ac2400040000	MOVQ BP, 0x400(SP)			
  0x449c26		488dac2400040000	LEAQ 0x400(SP), BP			
  0x449c2e		488b5920		MOVQ 0x20(CX), BX			
  0x449c32		4885db			TESTQ BX, BX				
  0x449c35		7527			JNE 0x449c5e				
  0x449c37		48c7c000000000		MOVQ $0x0, AX				
  0x449c3e		cc			INT $0x3				
  0x449c3f		48c7c001000000		MOVQ $0x1, AX				
  0x449c46		cc			INT $0x3				
  0x449c47		488bac2400040000	MOVQ 0x400(SP), BP			
  0x449c4f		4881c408040000		ADDQ $0x408, SP				
  0x449c56		c3			RET					
  0x449c57		e824dcffff		CALL runtime.morestack_noctxt(SB)	
  0x449c5c		eba2			JMP debugCall1024(SB)			
  0x449c5e		488dbc2410040000	LEAQ 0x410(SP), DI			
  0x449c66		48393b			CMPQ DI, 0(BX)				
  0x449c69		75cc			JNE 0x449c37				
  0x449c6b		488923			MOVQ SP, 0(BX)				
  0x449c6e		ebc7			JMP 0x449c37				

TEXT debugCall2048(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449c70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449c79		488d842478f8ffff	LEAQ 0xfffff878(SP), AX			
  0x449c81		483b4110		CMPQ 0x10(CX), AX			
  0x449c85		7640			JBE 0x449cc7				
  0x449c87		4881ec08080000		SUBQ $0x808, SP				
  0x449c8e		4889ac2400080000	MOVQ BP, 0x800(SP)			
  0x449c96		488dac2400080000	LEAQ 0x800(SP), BP			
  0x449c9e		488b5920		MOVQ 0x20(CX), BX			
  0x449ca2		4885db			TESTQ BX, BX				
  0x449ca5		7527			JNE 0x449cce				
  0x449ca7		48c7c000000000		MOVQ $0x0, AX				
  0x449cae		cc			INT $0x3				
  0x449caf		48c7c001000000		MOVQ $0x1, AX				
  0x449cb6		cc			INT $0x3				
  0x449cb7		488bac2400080000	MOVQ 0x800(SP), BP			
  0x449cbf		4881c408080000		ADDQ $0x808, SP				
  0x449cc6		c3			RET					
  0x449cc7		e8b4dbffff		CALL runtime.morestack_noctxt(SB)	
  0x449ccc		eba2			JMP debugCall2048(SB)			
  0x449cce		488dbc2410080000	LEAQ 0x810(SP), DI			
  0x449cd6		48393b			CMPQ DI, 0(BX)				
  0x449cd9		75cc			JNE 0x449ca7				
  0x449cdb		488923			MOVQ SP, 0(BX)				
  0x449cde		ebc7			JMP 0x449ca7				

TEXT debugCall4096(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449ce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449ce9		488b7110		MOVQ 0x10(CX), SI			
  0x449ced		4881fedefaffff		CMPQ $-0x522, SI			
  0x449cf4		7453			JE 0x449d49				
  0x449cf6		488d842470030000	LEAQ 0x370(SP), AX			
  0x449cfe		4829f0			SUBQ SI, AX				
  0x449d01		483df8120000		CMPQ $0x12f8, AX			
  0x449d07		7640			JBE 0x449d49				
  0x449d09		4881ec08100000		SUBQ $0x1008, SP			
  0x449d10		4889ac2400100000	MOVQ BP, 0x1000(SP)			
  0x449d18		488dac2400100000	LEAQ 0x1000(SP), BP			
  0x449d20		488b5920		MOVQ 0x20(CX), BX			
  0x449d24		4885db			TESTQ BX, BX				
  0x449d27		7527			JNE 0x449d50				
  0x449d29		48c7c000000000		MOVQ $0x0, AX				
  0x449d30		cc			INT $0x3				
  0x449d31		48c7c001000000		MOVQ $0x1, AX				
  0x449d38		cc			INT $0x3				
  0x449d39		488bac2400100000	MOVQ 0x1000(SP), BP			
  0x449d41		4881c408100000		ADDQ $0x1008, SP			
  0x449d48		c3			RET					
  0x449d49		e832dbffff		CALL runtime.morestack_noctxt(SB)	
  0x449d4e		eb90			JMP debugCall4096(SB)			
  0x449d50		488dbc2410100000	LEAQ 0x1010(SP), DI			
  0x449d58		48393b			CMPQ DI, 0(BX)				
  0x449d5b		75cc			JNE 0x449d29				
  0x449d5d		488923			MOVQ SP, 0(BX)				
  0x449d60		ebc7			JMP 0x449d29				

TEXT debugCall8192(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449d70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449d79		488b7110		MOVQ 0x10(CX), SI			
  0x449d7d		4881fedefaffff		CMPQ $-0x522, SI			
  0x449d84		7453			JE 0x449dd9				
  0x449d86		488d842470030000	LEAQ 0x370(SP), AX			
  0x449d8e		4829f0			SUBQ SI, AX				
  0x449d91		483df8220000		CMPQ $0x22f8, AX			
  0x449d97		7640			JBE 0x449dd9				
  0x449d99		4881ec08200000		SUBQ $0x2008, SP			
  0x449da0		4889ac2400200000	MOVQ BP, 0x2000(SP)			
  0x449da8		488dac2400200000	LEAQ 0x2000(SP), BP			
  0x449db0		488b5920		MOVQ 0x20(CX), BX			
  0x449db4		4885db			TESTQ BX, BX				
  0x449db7		7527			JNE 0x449de0				
  0x449db9		48c7c000000000		MOVQ $0x0, AX				
  0x449dc0		cc			INT $0x3				
  0x449dc1		48c7c001000000		MOVQ $0x1, AX				
  0x449dc8		cc			INT $0x3				
  0x449dc9		488bac2400200000	MOVQ 0x2000(SP), BP			
  0x449dd1		4881c408200000		ADDQ $0x2008, SP			
  0x449dd8		c3			RET					
  0x449dd9		e8a2daffff		CALL runtime.morestack_noctxt(SB)	
  0x449dde		eb90			JMP debugCall8192(SB)			
  0x449de0		488dbc2410200000	LEAQ 0x2010(SP), DI			
  0x449de8		48393b			CMPQ DI, 0(BX)				
  0x449deb		75cc			JNE 0x449db9				
  0x449ded		488923			MOVQ SP, 0(BX)				
  0x449df0		ebc7			JMP 0x449db9				

TEXT debugCall16384(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449e00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449e09		488b7110		MOVQ 0x10(CX), SI			
  0x449e0d		4881fedefaffff		CMPQ $-0x522, SI			
  0x449e14		7453			JE 0x449e69				
  0x449e16		488d842470030000	LEAQ 0x370(SP), AX			
  0x449e1e		4829f0			SUBQ SI, AX				
  0x449e21		483df8420000		CMPQ $0x42f8, AX			
  0x449e27		7640			JBE 0x449e69				
  0x449e29		4881ec08400000		SUBQ $0x4008, SP			
  0x449e30		4889ac2400400000	MOVQ BP, 0x4000(SP)			
  0x449e38		488dac2400400000	LEAQ 0x4000(SP), BP			
  0x449e40		488b5920		MOVQ 0x20(CX), BX			
  0x449e44		4885db			TESTQ BX, BX				
  0x449e47		7527			JNE 0x449e70				
  0x449e49		48c7c000000000		MOVQ $0x0, AX				
  0x449e50		cc			INT $0x3				
  0x449e51		48c7c001000000		MOVQ $0x1, AX				
  0x449e58		cc			INT $0x3				
  0x449e59		488bac2400400000	MOVQ 0x4000(SP), BP			
  0x449e61		4881c408400000		ADDQ $0x4008, SP			
  0x449e68		c3			RET					
  0x449e69		e812daffff		CALL runtime.morestack_noctxt(SB)	
  0x449e6e		eb90			JMP debugCall16384(SB)			
  0x449e70		488dbc2410400000	LEAQ 0x4010(SP), DI			
  0x449e78		48393b			CMPQ DI, 0(BX)				
  0x449e7b		75cc			JNE 0x449e49				
  0x449e7d		488923			MOVQ SP, 0(BX)				
  0x449e80		ebc7			JMP 0x449e49				

TEXT debugCall32768(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449e90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449e99		488b7110		MOVQ 0x10(CX), SI			
  0x449e9d		4881fedefaffff		CMPQ $-0x522, SI			
  0x449ea4		7453			JE 0x449ef9				
  0x449ea6		488d842470030000	LEAQ 0x370(SP), AX			
  0x449eae		4829f0			SUBQ SI, AX				
  0x449eb1		483df8820000		CMPQ $0x82f8, AX			
  0x449eb7		7640			JBE 0x449ef9				
  0x449eb9		4881ec08800000		SUBQ $0x8008, SP			
  0x449ec0		4889ac2400800000	MOVQ BP, 0x8000(SP)			
  0x449ec8		488dac2400800000	LEAQ 0x8000(SP), BP			
  0x449ed0		488b5920		MOVQ 0x20(CX), BX			
  0x449ed4		4885db			TESTQ BX, BX				
  0x449ed7		7527			JNE 0x449f00				
  0x449ed9		48c7c000000000		MOVQ $0x0, AX				
  0x449ee0		cc			INT $0x3				
  0x449ee1		48c7c001000000		MOVQ $0x1, AX				
  0x449ee8		cc			INT $0x3				
  0x449ee9		488bac2400800000	MOVQ 0x8000(SP), BP			
  0x449ef1		4881c408800000		ADDQ $0x8008, SP			
  0x449ef8		c3			RET					
  0x449ef9		e882d9ffff		CALL runtime.morestack_noctxt(SB)	
  0x449efe		eb90			JMP debugCall32768(SB)			
  0x449f00		488dbc2410800000	LEAQ 0x8010(SP), DI			
  0x449f08		48393b			CMPQ DI, 0(BX)				
  0x449f0b		75cc			JNE 0x449ed9				
  0x449f0d		488923			MOVQ SP, 0(BX)				
  0x449f10		ebc7			JMP 0x449ed9				

TEXT debugCall65536(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449f20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x449f29		488b7110		MOVQ 0x10(CX), SI			
  0x449f2d		4881fedefaffff		CMPQ $-0x522, SI			
  0x449f34		7453			JE 0x449f89				
  0x449f36		488d842470030000	LEAQ 0x370(SP), AX			
  0x449f3e		4829f0			SUBQ SI, AX				
  0x449f41		483df8020100		CMPQ $0x102f8, AX			
  0x449f47		7640			JBE 0x449f89				
  0x449f49		4881ec08000100		SUBQ $0x10008, SP			
  0x449f50		4889ac2400000100	MOVQ BP, 0x10000(SP)			
  0x449f58		488dac2400000100	LEAQ 0x10000(SP), BP			
  0x449f60		488b5920		MOVQ 0x20(CX), BX			
  0x449f64		4885db			TESTQ BX, BX				
  0x449f67		7527			JNE 0x449f90				
  0x449f69		48c7c000000000		MOVQ $0x0, AX				
  0x449f70		cc			INT $0x3				
  0x449f71		48c7c001000000		MOVQ $0x1, AX				
  0x449f78		cc			INT $0x3				
  0x449f79		488bac2400000100	MOVQ 0x10000(SP), BP			
  0x449f81		4881c408000100		ADDQ $0x10008, SP			
  0x449f88		c3			RET					
  0x449f89		e8f2d8ffff		CALL runtime.morestack_noctxt(SB)	
  0x449f8e		eb90			JMP debugCall65536(SB)			
  0x449f90		488dbc2410000100	LEAQ 0x10010(SP), DI			
  0x449f98		48393b			CMPQ DI, 0(BX)				
  0x449f9b		75cc			JNE 0x449f69				
  0x449f9d		488923			MOVQ SP, 0(BX)				
  0x449fa0		ebc7			JMP 0x449f69				

TEXT runtime.debugCallPanicked(SB) /usr/local/go/src/runtime/asm_amd64.s

  0x449fb0		4883ec18		SUBQ $0x18, SP		
  0x449fb4		48896c2410		MOVQ BP, 0x10(SP)	
  0x449fb9		488d6c2410		LEAQ 0x10(SP), BP	

  0x449fbe		488b442420		MOVQ 0x20(SP), AX	

  0x449fc3		48890424		MOVQ AX, 0(SP)		

  0x449fc7		488b442428		MOVQ 0x28(SP), AX	

  0x449fcc		4889442408		MOVQ AX, 0x8(SP)	

  0x449fd1		48c7c002000000		MOVQ $0x2, AX		

  0x449fd8		cc			INT $0x3		

  0x449fd9		488b6c2410		MOVQ 0x10(SP), BP	
  0x449fde		4883c418		ADDQ $0x18, SP		
  0x449fe2		c3			RET			

TEXT runtime.duffzero(SB) /usr/local/go/src/runtime/duff_amd64.s

  0x449ff0		0f1107			MOVUPS X0, 0(DI)	

  0x449ff3		0f114710		MOVUPS X0, 0x10(DI)	

  0x449ff7		0f114720		MOVUPS X0, 0x20(DI)	

  0x449ffb		0f114730		MOVUPS X0, 0x30(DI)	

  0x449fff		488d7f40		LEAQ 0x40(DI), DI	

  0x44a003		0f1107			MOVUPS X0, 0(DI)	

  0x44a006		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a00a		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a00e		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a012		488d7f40		LEAQ 0x40(DI), DI	

  0x44a016		0f1107			MOVUPS X0, 0(DI)	

  0x44a019		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a01d		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a021		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a025		488d7f40		LEAQ 0x40(DI), DI	

  0x44a029		0f1107			MOVUPS X0, 0(DI)	

  0x44a02c		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a030		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a034		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a038		488d7f40		LEAQ 0x40(DI), DI	

  0x44a03c		0f1107			MOVUPS X0, 0(DI)	

  0x44a03f		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a043		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a047		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a04b		488d7f40		LEAQ 0x40(DI), DI	

  0x44a04f		0f1107			MOVUPS X0, 0(DI)	

  0x44a052		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a056		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a05a		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a05e		488d7f40		LEAQ 0x40(DI), DI	

  0x44a062		0f1107			MOVUPS X0, 0(DI)	

  0x44a065		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a069		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a06d		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a071		488d7f40		LEAQ 0x40(DI), DI	

  0x44a075		0f1107			MOVUPS X0, 0(DI)	

  0x44a078		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a07c		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a080		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a084		488d7f40		LEAQ 0x40(DI), DI	

  0x44a088		0f1107			MOVUPS X0, 0(DI)	

  0x44a08b		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a08f		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a093		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a097		488d7f40		LEAQ 0x40(DI), DI	

  0x44a09b		0f1107			MOVUPS X0, 0(DI)	

  0x44a09e		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a0a2		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a0a6		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a0aa		488d7f40		LEAQ 0x40(DI), DI	

  0x44a0ae		0f1107			MOVUPS X0, 0(DI)	

  0x44a0b1		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a0b5		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a0b9		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a0bd		488d7f40		LEAQ 0x40(DI), DI	

  0x44a0c1		0f1107			MOVUPS X0, 0(DI)	

  0x44a0c4		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a0c8		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a0cc		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a0d0		488d7f40		LEAQ 0x40(DI), DI	

  0x44a0d4		0f1107			MOVUPS X0, 0(DI)	

  0x44a0d7		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a0db		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a0df		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a0e3		488d7f40		LEAQ 0x40(DI), DI	

  0x44a0e7		0f1107			MOVUPS X0, 0(DI)	

  0x44a0ea		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a0ee		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a0f2		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a0f6		488d7f40		LEAQ 0x40(DI), DI	

  0x44a0fa		0f1107			MOVUPS X0, 0(DI)	

  0x44a0fd		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a101		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a105		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a109		488d7f40		LEAQ 0x40(DI), DI	

  0x44a10d		0f1107			MOVUPS X0, 0(DI)	

  0x44a110		0f114710		MOVUPS X0, 0x10(DI)	

  0x44a114		0f114720		MOVUPS X0, 0x20(DI)	

  0x44a118		0f114730		MOVUPS X0, 0x30(DI)	

  0x44a11c		488d7f40		LEAQ 0x40(DI), DI	

  0x44a120		c3			RET			

TEXT runtime.duffcopy(SB) /usr/local/go/src/runtime/duff_amd64.s

  0x44a130		0f1006			MOVUPS 0(SI), X0	

  0x44a133		4883c610		ADDQ $0x10, SI		

  0x44a137		0f1107			MOVUPS X0, 0(DI)	

  0x44a13a		4883c710		ADDQ $0x10, DI		

  0x44a13e		0f1006			MOVUPS 0(SI), X0	

  0x44a141		4883c610		ADDQ $0x10, SI		

  0x44a145		0f1107			MOVUPS X0, 0(DI)	

  0x44a148		4883c710		ADDQ $0x10, DI		

  0x44a14c		0f1006			MOVUPS 0(SI), X0	

  0x44a14f		4883c610		ADDQ $0x10, SI		

  0x44a153		0f1107			MOVUPS X0, 0(DI)	

  0x44a156		4883c710		ADDQ $0x10, DI		

  0x44a15a		0f1006			MOVUPS 0(SI), X0	

  0x44a15d		4883c610		ADDQ $0x10, SI		

  0x44a161		0f1107			MOVUPS X0, 0(DI)	

  0x44a164		4883c710		ADDQ $0x10, DI		

  0x44a168		0f1006			MOVUPS 0(SI), X0	

  0x44a16b		4883c610		ADDQ $0x10, SI		

  0x44a16f		0f1107			MOVUPS X0, 0(DI)	

  0x44a172		4883c710		ADDQ $0x10, DI		

  0x44a176		0f1006			MOVUPS 0(SI), X0	

  0x44a179		4883c610		ADDQ $0x10, SI		

  0x44a17d		0f1107			MOVUPS X0, 0(DI)	

  0x44a180		4883c710		ADDQ $0x10, DI		

  0x44a184		0f1006			MOVUPS 0(SI), X0	

  0x44a187		4883c610		ADDQ $0x10, SI		

  0x44a18b		0f1107			MOVUPS X0, 0(DI)	

  0x44a18e		4883c710		ADDQ $0x10, DI		

  0x44a192		0f1006			MOVUPS 0(SI), X0	

  0x44a195		4883c610		ADDQ $0x10, SI		

  0x44a199		0f1107			MOVUPS X0, 0(DI)	

  0x44a19c		4883c710		ADDQ $0x10, DI		

  0x44a1a0		0f1006			MOVUPS 0(SI), X0	

  0x44a1a3		4883c610		ADDQ $0x10, SI		

  0x44a1a7		0f1107			MOVUPS X0, 0(DI)	

  0x44a1aa		4883c710		ADDQ $0x10, DI		

  0x44a1ae		0f1006			MOVUPS 0(SI), X0	

  0x44a1b1		4883c610		ADDQ $0x10, SI		

  0x44a1b5		0f1107			MOVUPS X0, 0(DI)	

  0x44a1b8		4883c710		ADDQ $0x10, DI		

  0x44a1bc		0f1006			MOVUPS 0(SI), X0	

  0x44a1bf		4883c610		ADDQ $0x10, SI		

  0x44a1c3		0f1107			MOVUPS X0, 0(DI)	

  0x44a1c6		4883c710		ADDQ $0x10, DI		

  0x44a1ca		0f1006			MOVUPS 0(SI), X0	

  0x44a1cd		4883c610		ADDQ $0x10, SI		

  0x44a1d1		0f1107			MOVUPS X0, 0(DI)	

  0x44a1d4		4883c710		ADDQ $0x10, DI		

  0x44a1d8		0f1006			MOVUPS 0(SI), X0	

  0x44a1db		4883c610		ADDQ $0x10, SI		

  0x44a1df		0f1107			MOVUPS X0, 0(DI)	

  0x44a1e2		4883c710		ADDQ $0x10, DI		

  0x44a1e6		0f1006			MOVUPS 0(SI), X0	

  0x44a1e9		4883c610		ADDQ $0x10, SI		

  0x44a1ed		0f1107			MOVUPS X0, 0(DI)	

  0x44a1f0		4883c710		ADDQ $0x10, DI		

  0x44a1f4		0f1006			MOVUPS 0(SI), X0	

  0x44a1f7		4883c610		ADDQ $0x10, SI		

  0x44a1fb		0f1107			MOVUPS X0, 0(DI)	

  0x44a1fe		4883c710		ADDQ $0x10, DI		

  0x44a202		0f1006			MOVUPS 0(SI), X0	

  0x44a205		4883c610		ADDQ $0x10, SI		

  0x44a209		0f1107			MOVUPS X0, 0(DI)	

  0x44a20c		4883c710		ADDQ $0x10, DI		

  0x44a210		0f1006			MOVUPS 0(SI), X0	

  0x44a213		4883c610		ADDQ $0x10, SI		

  0x44a217		0f1107			MOVUPS X0, 0(DI)	

  0x44a21a		4883c710		ADDQ $0x10, DI		

  0x44a21e		0f1006			MOVUPS 0(SI), X0	

  0x44a221		4883c610		ADDQ $0x10, SI		

  0x44a225		0f1107			MOVUPS X0, 0(DI)	

  0x44a228		4883c710		ADDQ $0x10, DI		

  0x44a22c		0f1006			MOVUPS 0(SI), X0	

  0x44a22f		4883c610		ADDQ $0x10, SI		

  0x44a233		0f1107			MOVUPS X0, 0(DI)	

  0x44a236		4883c710		ADDQ $0x10, DI		

  0x44a23a		0f1006			MOVUPS 0(SI), X0	

  0x44a23d		4883c610		ADDQ $0x10, SI		

  0x44a241		0f1107			MOVUPS X0, 0(DI)	

  0x44a244		4883c710		ADDQ $0x10, DI		

  0x44a248		0f1006			MOVUPS 0(SI), X0	

  0x44a24b		4883c610		ADDQ $0x10, SI		

  0x44a24f		0f1107			MOVUPS X0, 0(DI)	

  0x44a252		4883c710		ADDQ $0x10, DI		

  0x44a256		0f1006			MOVUPS 0(SI), X0	

  0x44a259		4883c610		ADDQ $0x10, SI		

  0x44a25d		0f1107			MOVUPS X0, 0(DI)	

  0x44a260		4883c710		ADDQ $0x10, DI		

  0x44a264		0f1006			MOVUPS 0(SI), X0	

  0x44a267		4883c610		ADDQ $0x10, SI		

  0x44a26b		0f1107			MOVUPS X0, 0(DI)	

  0x44a26e		4883c710		ADDQ $0x10, DI		

  0x44a272		0f1006			MOVUPS 0(SI), X0	

  0x44a275		4883c610		ADDQ $0x10, SI		

  0x44a279		0f1107			MOVUPS X0, 0(DI)	

  0x44a27c		4883c710		ADDQ $0x10, DI		

  0x44a280		0f1006			MOVUPS 0(SI), X0	

  0x44a283		4883c610		ADDQ $0x10, SI		

  0x44a287		0f1107			MOVUPS X0, 0(DI)	

  0x44a28a		4883c710		ADDQ $0x10, DI		

  0x44a28e		0f1006			MOVUPS 0(SI), X0	

  0x44a291		4883c610		ADDQ $0x10, SI		

  0x44a295		0f1107			MOVUPS X0, 0(DI)	

  0x44a298		4883c710		ADDQ $0x10, DI		

  0x44a29c		0f1006			MOVUPS 0(SI), X0	

  0x44a29f		4883c610		ADDQ $0x10, SI		

  0x44a2a3		0f1107			MOVUPS X0, 0(DI)	

  0x44a2a6		4883c710		ADDQ $0x10, DI		

  0x44a2aa		0f1006			MOVUPS 0(SI), X0	

  0x44a2ad		4883c610		ADDQ $0x10, SI		

  0x44a2b1		0f1107			MOVUPS X0, 0(DI)	

  0x44a2b4		4883c710		ADDQ $0x10, DI		

  0x44a2b8		0f1006			MOVUPS 0(SI), X0	

  0x44a2bb		4883c610		ADDQ $0x10, SI		

  0x44a2bf		0f1107			MOVUPS X0, 0(DI)	

  0x44a2c2		4883c710		ADDQ $0x10, DI		

  0x44a2c6		0f1006			MOVUPS 0(SI), X0	

  0x44a2c9		4883c610		ADDQ $0x10, SI		

  0x44a2cd		0f1107			MOVUPS X0, 0(DI)	

  0x44a2d0		4883c710		ADDQ $0x10, DI		

  0x44a2d4		0f1006			MOVUPS 0(SI), X0	

  0x44a2d7		4883c610		ADDQ $0x10, SI		

  0x44a2db		0f1107			MOVUPS X0, 0(DI)	

  0x44a2de		4883c710		ADDQ $0x10, DI		

  0x44a2e2		0f1006			MOVUPS 0(SI), X0	

  0x44a2e5		4883c610		ADDQ $0x10, SI		

  0x44a2e9		0f1107			MOVUPS X0, 0(DI)	

  0x44a2ec		4883c710		ADDQ $0x10, DI		

  0x44a2f0		0f1006			MOVUPS 0(SI), X0	

  0x44a2f3		4883c610		ADDQ $0x10, SI		

  0x44a2f7		0f1107			MOVUPS X0, 0(DI)	

  0x44a2fa		4883c710		ADDQ $0x10, DI		

  0x44a2fe		0f1006			MOVUPS 0(SI), X0	

  0x44a301		4883c610		ADDQ $0x10, SI		

  0x44a305		0f1107			MOVUPS X0, 0(DI)	

  0x44a308		4883c710		ADDQ $0x10, DI		

  0x44a30c		0f1006			MOVUPS 0(SI), X0	

  0x44a30f		4883c610		ADDQ $0x10, SI		

  0x44a313		0f1107			MOVUPS X0, 0(DI)	

  0x44a316		4883c710		ADDQ $0x10, DI		

  0x44a31a		0f1006			MOVUPS 0(SI), X0	

  0x44a31d		4883c610		ADDQ $0x10, SI		

  0x44a321		0f1107			MOVUPS X0, 0(DI)	

  0x44a324		4883c710		ADDQ $0x10, DI		

  0x44a328		0f1006			MOVUPS 0(SI), X0	

  0x44a32b		4883c610		ADDQ $0x10, SI		

  0x44a32f		0f1107			MOVUPS X0, 0(DI)	

  0x44a332		4883c710		ADDQ $0x10, DI		

  0x44a336		0f1006			MOVUPS 0(SI), X0	

  0x44a339		4883c610		ADDQ $0x10, SI		

  0x44a33d		0f1107			MOVUPS X0, 0(DI)	

  0x44a340		4883c710		ADDQ $0x10, DI		

  0x44a344		0f1006			MOVUPS 0(SI), X0	

  0x44a347		4883c610		ADDQ $0x10, SI		

  0x44a34b		0f1107			MOVUPS X0, 0(DI)	

  0x44a34e		4883c710		ADDQ $0x10, DI		

  0x44a352		0f1006			MOVUPS 0(SI), X0	

  0x44a355		4883c610		ADDQ $0x10, SI		

  0x44a359		0f1107			MOVUPS X0, 0(DI)	

  0x44a35c		4883c710		ADDQ $0x10, DI		

  0x44a360		0f1006			MOVUPS 0(SI), X0	

  0x44a363		4883c610		ADDQ $0x10, SI		

  0x44a367		0f1107			MOVUPS X0, 0(DI)	

  0x44a36a		4883c710		ADDQ $0x10, DI		

  0x44a36e		0f1006			MOVUPS 0(SI), X0	

  0x44a371		4883c610		ADDQ $0x10, SI		

  0x44a375		0f1107			MOVUPS X0, 0(DI)	

  0x44a378		4883c710		ADDQ $0x10, DI		

  0x44a37c		0f1006			MOVUPS 0(SI), X0	

  0x44a37f		4883c610		ADDQ $0x10, SI		

  0x44a383		0f1107			MOVUPS X0, 0(DI)	

  0x44a386		4883c710		ADDQ $0x10, DI		

  0x44a38a		0f1006			MOVUPS 0(SI), X0	

  0x44a38d		4883c610		ADDQ $0x10, SI		

  0x44a391		0f1107			MOVUPS X0, 0(DI)	

  0x44a394		4883c710		ADDQ $0x10, DI		

  0x44a398		0f1006			MOVUPS 0(SI), X0	

  0x44a39b		4883c610		ADDQ $0x10, SI		

  0x44a39f		0f1107			MOVUPS X0, 0(DI)	

  0x44a3a2		4883c710		ADDQ $0x10, DI		

  0x44a3a6		0f1006			MOVUPS 0(SI), X0	

  0x44a3a9		4883c610		ADDQ $0x10, SI		

  0x44a3ad		0f1107			MOVUPS X0, 0(DI)	

  0x44a3b0		4883c710		ADDQ $0x10, DI		

  0x44a3b4		0f1006			MOVUPS 0(SI), X0	

  0x44a3b7		4883c610		ADDQ $0x10, SI		

  0x44a3bb		0f1107			MOVUPS X0, 0(DI)	

  0x44a3be		4883c710		ADDQ $0x10, DI		

  0x44a3c2		0f1006			MOVUPS 0(SI), X0	

  0x44a3c5		4883c610		ADDQ $0x10, SI		

  0x44a3c9		0f1107			MOVUPS X0, 0(DI)	

  0x44a3cc		4883c710		ADDQ $0x10, DI		

  0x44a3d0		0f1006			MOVUPS 0(SI), X0	

  0x44a3d3		4883c610		ADDQ $0x10, SI		

  0x44a3d7		0f1107			MOVUPS X0, 0(DI)	

  0x44a3da		4883c710		ADDQ $0x10, DI		

  0x44a3de		0f1006			MOVUPS 0(SI), X0	

  0x44a3e1		4883c610		ADDQ $0x10, SI		

  0x44a3e5		0f1107			MOVUPS X0, 0(DI)	

  0x44a3e8		4883c710		ADDQ $0x10, DI		

  0x44a3ec		0f1006			MOVUPS 0(SI), X0	

  0x44a3ef		4883c610		ADDQ $0x10, SI		

  0x44a3f3		0f1107			MOVUPS X0, 0(DI)	

  0x44a3f6		4883c710		ADDQ $0x10, DI		

  0x44a3fa		0f1006			MOVUPS 0(SI), X0	

  0x44a3fd		4883c610		ADDQ $0x10, SI		

  0x44a401		0f1107			MOVUPS X0, 0(DI)	

  0x44a404		4883c710		ADDQ $0x10, DI		

  0x44a408		0f1006			MOVUPS 0(SI), X0	

  0x44a40b		4883c610		ADDQ $0x10, SI		

  0x44a40f		0f1107			MOVUPS X0, 0(DI)	

  0x44a412		4883c710		ADDQ $0x10, DI		

  0x44a416		0f1006			MOVUPS 0(SI), X0	

  0x44a419		4883c610		ADDQ $0x10, SI		

  0x44a41d		0f1107			MOVUPS X0, 0(DI)	

  0x44a420		4883c710		ADDQ $0x10, DI		

  0x44a424		0f1006			MOVUPS 0(SI), X0	

  0x44a427		4883c610		ADDQ $0x10, SI		

  0x44a42b		0f1107			MOVUPS X0, 0(DI)	

  0x44a42e		4883c710		ADDQ $0x10, DI		

  0x44a432		0f1006			MOVUPS 0(SI), X0	

  0x44a435		4883c610		ADDQ $0x10, SI		

  0x44a439		0f1107			MOVUPS X0, 0(DI)	

  0x44a43c		4883c710		ADDQ $0x10, DI		

  0x44a440		0f1006			MOVUPS 0(SI), X0	

  0x44a443		4883c610		ADDQ $0x10, SI		

  0x44a447		0f1107			MOVUPS X0, 0(DI)	

  0x44a44a		4883c710		ADDQ $0x10, DI		

  0x44a44e		0f1006			MOVUPS 0(SI), X0	

  0x44a451		4883c610		ADDQ $0x10, SI		

  0x44a455		0f1107			MOVUPS X0, 0(DI)	

  0x44a458		4883c710		ADDQ $0x10, DI		

  0x44a45c		0f1006			MOVUPS 0(SI), X0	

  0x44a45f		4883c610		ADDQ $0x10, SI		

  0x44a463		0f1107			MOVUPS X0, 0(DI)	

  0x44a466		4883c710		ADDQ $0x10, DI		

  0x44a46a		0f1006			MOVUPS 0(SI), X0	

  0x44a46d		4883c610		ADDQ $0x10, SI		

  0x44a471		0f1107			MOVUPS X0, 0(DI)	

  0x44a474		4883c710		ADDQ $0x10, DI		

  0x44a478		0f1006			MOVUPS 0(SI), X0	

  0x44a47b		4883c610		ADDQ $0x10, SI		

  0x44a47f		0f1107			MOVUPS X0, 0(DI)	

  0x44a482		4883c710		ADDQ $0x10, DI		

  0x44a486		0f1006			MOVUPS 0(SI), X0	

  0x44a489		4883c610		ADDQ $0x10, SI		

  0x44a48d		0f1107			MOVUPS X0, 0(DI)	

  0x44a490		4883c710		ADDQ $0x10, DI		

  0x44a494		0f1006			MOVUPS 0(SI), X0	

  0x44a497		4883c610		ADDQ $0x10, SI		

  0x44a49b		0f1107			MOVUPS X0, 0(DI)	

  0x44a49e		4883c710		ADDQ $0x10, DI		

  0x44a4a2		0f1006			MOVUPS 0(SI), X0	

  0x44a4a5		4883c610		ADDQ $0x10, SI		

  0x44a4a9		0f1107			MOVUPS X0, 0(DI)	

  0x44a4ac		4883c710		ADDQ $0x10, DI		

  0x44a4b0		c3			RET			

TEXT runtime.memclrNoHeapPointers(SB) /usr/local/go/src/runtime/memclr_amd64.s

  0x44a4c0		488b7c2408		MOVQ 0x8(SP), DI	

  0x44a4c5		488b5c2410		MOVQ 0x10(SP), BX	

  0x44a4ca		4831c0			XORQ AX, AX		

  0x44a4cd		4885db			TESTQ BX, BX		

  0x44a4d0		0f84a8010000		JE 0x44a67e		

  0x44a4d6		4883fb02		CMPQ $0x2, BX		

  0x44a4da		0f8697010000		JBE 0x44a677		

  0x44a4e0		4883fb04		CMPQ $0x4, BX		

  0x44a4e4		0f8695010000		JBE 0x44a67f		

  0x44a4ea		4883fb08		CMPQ $0x8, BX		

  0x44a4ee		0f8294010000		JB 0x44a688		

  0x44a4f4		0f8495010000		JE 0x44a68f		

  0x44a4fa		4883fb10		CMPQ $0x10, BX		

  0x44a4fe		0f868f010000		JBE 0x44a693		

  0x44a504		660fefc0		PXOR X0, X0		

  0x44a508		4883fb20		CMPQ $0x20, BX		

  0x44a50c		0f868a010000		JBE 0x44a69c		

  0x44a512		4883fb40		CMPQ $0x40, BX		

  0x44a516		0f868b010000		JBE 0x44a6a7		

  0x44a51c		4881fb80000000		CMPQ $0x80, BX		

  0x44a523		0f8694010000		JBE 0x44a6bd		

  0x44a529		4881fb00010000		CMPQ $0x100, BX		

  0x44a530		0f86b3010000		JBE 0x44a6e9		

  0x44a536		803d462b090001		CMPB $0x1, internal/cpu.X86+67(SB)	

  0x44a53d		0f8483000000		JE 0x44a5c6		

  0x44a543		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a547		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x44a54c		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x44a551		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x44a556		f30f7f4740		MOVDQU X0, 0x40(DI)	

  0x44a55b		f30f7f4750		MOVDQU X0, 0x50(DI)	

  0x44a560		f30f7f4760		MOVDQU X0, 0x60(DI)	

  0x44a565		f30f7f4770		MOVDQU X0, 0x70(DI)	

  0x44a56a		f30f7f8780000000	MOVDQU X0, 0x80(DI)	

  0x44a572		f30f7f8790000000	MOVDQU X0, 0x90(DI)	

  0x44a57a		f30f7f87a0000000	MOVDQU X0, 0xa0(DI)	

  0x44a582		f30f7f87b0000000	MOVDQU X0, 0xb0(DI)	

  0x44a58a		f30f7f87c0000000	MOVDQU X0, 0xc0(DI)	

  0x44a592		f30f7f87d0000000	MOVDQU X0, 0xd0(DI)	

  0x44a59a		f30f7f87e0000000	MOVDQU X0, 0xe0(DI)	

  0x44a5a2		f30f7f87f0000000	MOVDQU X0, 0xf0(DI)	

  0x44a5aa		4881eb00010000		SUBQ $0x100, BX		

  0x44a5b1		4881c700010000		ADDQ $0x100, DI		

  0x44a5b8		4881fb00010000		CMPQ $0x100, BX		

  0x44a5bf		7382			JAE 0x44a543		

  0x44a5c1		e907ffffff		JMP 0x44a4cd		

  0x44a5c6		c5fdef			OUTL AX, DX		
  0x44a5c9		c04881fb		RORB $0xfb, -0x7f(AX)	

  0x44a5cd		0000			ADDB AL, 0(AX)		
  0x44a5cf		0002			ADDB AL, 0(DX)		

  0x44a5d1		7346			JAE 0x44a619		

  0x44a5d3		c5fe7f07		VMOVDQU X0, 0(DI)	

  0x44a5d7		c5fe7f4720		VMOVDQU X0, 0x20(DI)	

  0x44a5dc		c5fe7f4740		VMOVDQU X0, 0x40(DI)	

  0x44a5e1		c5fe7f4760		VMOVDQU X0, 0x60(DI)	

  0x44a5e6		4881eb80000000		SUBQ $0x80, BX		

  0x44a5ed		4881c780000000		ADDQ $0x80, DI		

  0x44a5f4		4881fb80000000		CMPQ $0x80, BX		

  0x44a5fb		73d6			JAE 0x44a5d3		

  0x44a5fd		c5fe7f441fe0		VMOVDQU X0, -0x20(DI)(BX*1)	

  0x44a603		c5fe7f441fc0		VMOVDQU X0, -0x40(DI)(BX*1)	

  0x44a609		c5fe7f441fa0		VMOVDQU X0, -0x60(DI)(BX*1)	

  0x44a60f		c5fe7f441f80		VMOVDQU X0, -0x80(DI)(BX*1)	

  0x44a615		c5f877			VZEROUPPER		

  0x44a618		c3			RET			

  0x44a619		c5fe7f07		VMOVDQU X0, 0(DI)	

  0x44a61d		4889fe			MOVQ DI, SI		

  0x44a620		4883c720		ADDQ $0x20, DI		

  0x44a624		4883e7e0		ANDQ $-0x20, DI		

  0x44a628		4829fe			SUBQ DI, SI		

  0x44a62b		4801f3			ADDQ SI, BX		

  0x44a62e		c5fde707		VMOVNTDQ X0, 0(DI)	

  0x44a632		c5fde74720		VMOVNTDQ X0, 0x20(DI)	

  0x44a637		c5fde74740		VMOVNTDQ X0, 0x40(DI)	

  0x44a63c		c5fde74760		VMOVNTDQ X0, 0x60(DI)	

  0x44a641		4881eb80000000		SUBQ $0x80, BX		

  0x44a648		4881c780000000		ADDQ $0x80, DI		

  0x44a64f		4881fb80000000		CMPQ $0x80, BX		

  0x44a656		73d6			JAE 0x44a62e		

  0x44a658		0faef8			SFENCE			

  0x44a65b		c5fe7f441fe0		VMOVDQU X0, -0x20(DI)(BX*1)	

  0x44a661		c5fe7f441fc0		VMOVDQU X0, -0x40(DI)(BX*1)	

  0x44a667		c5fe7f441fa0		VMOVDQU X0, -0x60(DI)(BX*1)	

  0x44a66d		c5fe7f441f80		VMOVDQU X0, -0x80(DI)(BX*1)	

  0x44a673		c5f877			VZEROUPPER		

  0x44a676		c3			RET			

  0x44a677		8807			MOVB AL, 0(DI)		

  0x44a679		88441fff		MOVB AL, -0x1(DI)(BX*1)	

  0x44a67d		c3			RET			

  0x44a67e		c3			RET			

  0x44a67f		668907			MOVW AX, 0(DI)		

  0x44a682		6689441ffe		MOVW AX, -0x2(DI)(BX*1)	

  0x44a687		c3			RET			

  0x44a688		8907			MOVL AX, 0(DI)		

  0x44a68a		89441ffc		MOVL AX, -0x4(DI)(BX*1)	

  0x44a68e		c3			RET			

  0x44a68f		488907			MOVQ AX, 0(DI)		

  0x44a692		c3			RET			

  0x44a693		488907			MOVQ AX, 0(DI)		

  0x44a696		4889441ff8		MOVQ AX, -0x8(DI)(BX*1)	

  0x44a69b		c3			RET			

  0x44a69c		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a6a0		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x44a6a6		c3			RET			

  0x44a6a7		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a6ab		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x44a6b0		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x44a6b6		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x44a6bc		c3			RET			

  0x44a6bd		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a6c1		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x44a6c6		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x44a6cb		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x44a6d0		f30f7f441fc0		MOVDQU X0, -0x40(DI)(BX*1)	

  0x44a6d6		f30f7f441fd0		MOVDQU X0, -0x30(DI)(BX*1)	

  0x44a6dc		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x44a6e2		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x44a6e8		c3			RET			

  0x44a6e9		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a6ed		f30f7f4710		MOVDQU X0, 0x10(DI)	

  0x44a6f2		f30f7f4720		MOVDQU X0, 0x20(DI)	

  0x44a6f7		f30f7f4730		MOVDQU X0, 0x30(DI)	

  0x44a6fc		f30f7f4740		MOVDQU X0, 0x40(DI)	

  0x44a701		f30f7f4750		MOVDQU X0, 0x50(DI)	

  0x44a706		f30f7f4760		MOVDQU X0, 0x60(DI)	

  0x44a70b		f30f7f4770		MOVDQU X0, 0x70(DI)	

  0x44a710		f30f7f441f80		MOVDQU X0, -0x80(DI)(BX*1)	

  0x44a716		f30f7f441f90		MOVDQU X0, -0x70(DI)(BX*1)	

  0x44a71c		f30f7f441fa0		MOVDQU X0, -0x60(DI)(BX*1)	

  0x44a722		f30f7f441fb0		MOVDQU X0, -0x50(DI)(BX*1)	

  0x44a728		f30f7f441fc0		MOVDQU X0, -0x40(DI)(BX*1)	

  0x44a72e		f30f7f441fd0		MOVDQU X0, -0x30(DI)(BX*1)	

  0x44a734		f30f7f441fe0		MOVDQU X0, -0x20(DI)(BX*1)	

  0x44a73a		f30f7f441ff0		MOVDQU X0, -0x10(DI)(BX*1)	

  0x44a740		c3			RET			

TEXT runtime.memmove(SB) /usr/local/go/src/runtime/memmove_amd64.s

  0x44a750		488b7c2408		MOVQ 0x8(SP), DI	

  0x44a755		488b742410		MOVQ 0x10(SP), SI	

  0x44a75a		488b5c2418		MOVQ 0x18(SP), BX	

  0x44a75f		4885db			TESTQ BX, BX		

  0x44a762		0f84f7000000		JE 0x44a85f		

  0x44a768		4883fb02		CMPQ $0x2, BX		

  0x44a76c		0f86e0000000		JBE 0x44a852		

  0x44a772		4883fb04		CMPQ $0x4, BX		

  0x44a776		0f82e9000000		JB 0x44a865		

  0x44a77c		0f86de000000		JBE 0x44a860		

  0x44a782		4883fb08		CMPQ $0x8, BX		

  0x44a786		0f82e6000000		JB 0x44a872		

  0x44a78c		0f84ed000000		JE 0x44a87f		

  0x44a792		4883fb10		CMPQ $0x10, BX		

  0x44a796		0f86ea000000		JBE 0x44a886		

  0x44a79c		4883fb20		CMPQ $0x20, BX		

  0x44a7a0		0f86f1000000		JBE 0x44a897		

  0x44a7a6		4883fb40		CMPQ $0x40, BX		

  0x44a7aa		0f86fc000000		JBE 0x44a8ac		

  0x44a7b0		4881fb80000000		CMPQ $0x80, BX		

  0x44a7b7		0f861a010000		JBE 0x44a8d7		

  0x44a7bd		4881fb00010000		CMPQ $0x100, BX		

  0x44a7c4		0f8664010000		JBE 0x44a92e		

  0x44a7ca		f605e324090001		TESTB $0x1, runtime.useAVXmemmove(SB)	

  0x44a7d1		0f851b030000		JNE 0x44aaf2		

  0x44a7d7		4839fe			CMPQ DI, SI		

  0x44a7da		763a			JBE 0x44a816		

  0x44a7dc		4881fb00080000		CMPQ $0x800, BX		

  0x44a7e3		0f8604020000		JBE 0x44a9ed		

  0x44a7e9		803d9628090001		CMPB $0x1, internal/cpu.X86+70(SB)	

  0x44a7f0		7511			JNE 0x44a803		

  0x44a7f2		89f0			MOVL SI, AX		

  0x44a7f4		09f8			ORL DI, AX		

  0x44a7f6		a907000000		TESTL $0x7, AX		

  0x44a7fb		7406			JE 0x44a803		

  0x44a7fd		4889d9			MOVQ BX, CX		

  0x44a800		f3a4			REP; MOVSB DS:0(SI), ES:0(DI)	

  0x44a802		c3			RET			

  0x44a803		4889d9			MOVQ BX, CX		

  0x44a806		48c1e903		SHRQ $0x3, CX		

  0x44a80a		4883e307		ANDQ $0x7, BX		

  0x44a80e		f348a5			REP; MOVSQ DS:0(SI), ES:0(DI)	

  0x44a811		e949ffffff		JMP 0x44a75f		

  0x44a816		4889f1			MOVQ SI, CX		

  0x44a819		4801d9			ADDQ BX, CX		

  0x44a81c		4839f9			CMPQ DI, CX		

  0x44a81f		76bb			JBE 0x44a7dc		

  0x44a821		4801df			ADDQ BX, DI		

  0x44a824		4801de			ADDQ BX, SI		

  0x44a827		fd			STD			

  0x44a828		4889d9			MOVQ BX, CX		

  0x44a82b		48c1e903		SHRQ $0x3, CX		

  0x44a82f		4883e307		ANDQ $0x7, BX		

  0x44a833		4883ef08		SUBQ $0x8, DI		

  0x44a837		4883ee08		SUBQ $0x8, SI		

  0x44a83b		f348a5			REP; MOVSQ DS:0(SI), ES:0(DI)	

  0x44a83e		fc			CLD			

  0x44a83f		4883c708		ADDQ $0x8, DI		

  0x44a843		4883c608		ADDQ $0x8, SI		

  0x44a847		4829df			SUBQ BX, DI		

  0x44a84a		4829de			SUBQ BX, SI		

  0x44a84d		e90dffffff		JMP 0x44a75f		

  0x44a852		8a06			MOVB 0(SI), AL		

  0x44a854		8a4c1eff		MOVB -0x1(SI)(BX*1), CL	

  0x44a858		8807			MOVB AL, 0(DI)		

  0x44a85a		884c1fff		MOVB CL, -0x1(DI)(BX*1)	

  0x44a85e		c3			RET			

  0x44a85f		c3			RET			

  0x44a860		8b06			MOVL 0(SI), AX		

  0x44a862		8907			MOVL AX, 0(DI)		

  0x44a864		c3			RET			

  0x44a865		668b06			MOVW 0(SI), AX		

  0x44a868		8a4e02			MOVB 0x2(SI), CL	

  0x44a86b		668907			MOVW AX, 0(DI)		

  0x44a86e		884f02			MOVB CL, 0x2(DI)	

  0x44a871		c3			RET			

  0x44a872		8b06			MOVL 0(SI), AX		

  0x44a874		8b4c1efc		MOVL -0x4(SI)(BX*1), CX	

  0x44a878		8907			MOVL AX, 0(DI)		

  0x44a87a		894c1ffc		MOVL CX, -0x4(DI)(BX*1)	

  0x44a87e		c3			RET			

  0x44a87f		488b06			MOVQ 0(SI), AX		

  0x44a882		488907			MOVQ AX, 0(DI)		

  0x44a885		c3			RET			

  0x44a886		488b06			MOVQ 0(SI), AX		

  0x44a889		488b4c1ef8		MOVQ -0x8(SI)(BX*1), CX	

  0x44a88e		488907			MOVQ AX, 0(DI)		

  0x44a891		48894c1ff8		MOVQ CX, -0x8(DI)(BX*1)	

  0x44a896		c3			RET			

  0x44a897		f30f6f06		MOVDQU 0(SI), X0	

  0x44a89b		f30f6f4c1ef0		MOVDQU -0x10(SI)(BX*1), X1	

  0x44a8a1		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a8a5		f30f7f4c1ff0		MOVDQU X1, -0x10(DI)(BX*1)	

  0x44a8ab		c3			RET			

  0x44a8ac		f30f6f06		MOVDQU 0(SI), X0	

  0x44a8b0		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x44a8b5		f30f6f541ee0		MOVDQU -0x20(SI)(BX*1), X2	

  0x44a8bb		f30f6f5c1ef0		MOVDQU -0x10(SI)(BX*1), X3	

  0x44a8c1		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a8c5		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44a8ca		f30f7f541fe0		MOVDQU X2, -0x20(DI)(BX*1)	

  0x44a8d0		f30f7f5c1ff0		MOVDQU X3, -0x10(DI)(BX*1)	

  0x44a8d6		c3			RET			

  0x44a8d7		f30f6f06		MOVDQU 0(SI), X0	

  0x44a8db		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x44a8e0		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x44a8e5		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x44a8ea		f30f6f641ec0		MOVDQU -0x40(SI)(BX*1), X4	

  0x44a8f0		f30f6f6c1ed0		MOVDQU -0x30(SI)(BX*1), X5	

  0x44a8f6		f30f6f741ee0		MOVDQU -0x20(SI)(BX*1), X6	

  0x44a8fc		f30f6f7c1ef0		MOVDQU -0x10(SI)(BX*1), X7	

  0x44a902		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a906		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44a90b		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x44a910		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x44a915		f30f7f641fc0		MOVDQU X4, -0x40(DI)(BX*1)	

  0x44a91b		f30f7f6c1fd0		MOVDQU X5, -0x30(DI)(BX*1)	

  0x44a921		f30f7f741fe0		MOVDQU X6, -0x20(DI)(BX*1)	

  0x44a927		f30f7f7c1ff0		MOVDQU X7, -0x10(DI)(BX*1)	

  0x44a92d		c3			RET			

  0x44a92e		f30f6f06		MOVDQU 0(SI), X0	

  0x44a932		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x44a937		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x44a93c		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x44a941		f30f6f6640		MOVDQU 0x40(SI), X4	

  0x44a946		f30f6f6e50		MOVDQU 0x50(SI), X5	

  0x44a94b		f30f6f7660		MOVDQU 0x60(SI), X6	

  0x44a950		f30f6f7e70		MOVDQU 0x70(SI), X7	

  0x44a955		f3440f6f441e80		MOVDQU -0x80(SI)(BX*1), X8	

  0x44a95c		f3440f6f4c1e90		MOVDQU -0x70(SI)(BX*1), X9	

  0x44a963		f3440f6f541ea0		MOVDQU -0x60(SI)(BX*1), X10	

  0x44a96a		f3440f6f5c1eb0		MOVDQU -0x50(SI)(BX*1), X11	

  0x44a971		f3440f6f641ec0		MOVDQU -0x40(SI)(BX*1), X12	

  0x44a978		f3440f6f6c1ed0		MOVDQU -0x30(SI)(BX*1), X13	

  0x44a97f		f3440f6f741ee0		MOVDQU -0x20(SI)(BX*1), X14	

  0x44a986		f3440f6f7c1ef0		MOVDQU -0x10(SI)(BX*1), X15	

  0x44a98d		f30f7f07		MOVDQU X0, 0(DI)	

  0x44a991		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44a996		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x44a99b		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x44a9a0		f30f7f6740		MOVDQU X4, 0x40(DI)	

  0x44a9a5		f30f7f6f50		MOVDQU X5, 0x50(DI)	

  0x44a9aa		f30f7f7760		MOVDQU X6, 0x60(DI)	

  0x44a9af		f30f7f7f70		MOVDQU X7, 0x70(DI)	

  0x44a9b4		f3440f7f441f80		MOVDQU X8, -0x80(DI)(BX*1)	

  0x44a9bb		f3440f7f4c1f90		MOVDQU X9, -0x70(DI)(BX*1)	

  0x44a9c2		f3440f7f541fa0		MOVDQU X10, -0x60(DI)(BX*1)	

  0x44a9c9		f3440f7f5c1fb0		MOVDQU X11, -0x50(DI)(BX*1)	

  0x44a9d0		f3440f7f641fc0		MOVDQU X12, -0x40(DI)(BX*1)	

  0x44a9d7		f3440f7f6c1fd0		MOVDQU X13, -0x30(DI)(BX*1)	

  0x44a9de		f3440f7f741fe0		MOVDQU X14, -0x20(DI)(BX*1)	

  0x44a9e5		f3440f7f7c1ff0		MOVDQU X15, -0x10(DI)(BX*1)	

  0x44a9ec		c3			RET			

  0x44a9ed		4881eb00010000		SUBQ $0x100, BX		

  0x44a9f4		f30f6f06		MOVDQU 0(SI), X0	

  0x44a9f8		f30f6f4e10		MOVDQU 0x10(SI), X1	

  0x44a9fd		f30f6f5620		MOVDQU 0x20(SI), X2	

  0x44aa02		f30f6f5e30		MOVDQU 0x30(SI), X3	

  0x44aa07		f30f6f6640		MOVDQU 0x40(SI), X4	

  0x44aa0c		f30f6f6e50		MOVDQU 0x50(SI), X5	

  0x44aa11		f30f6f7660		MOVDQU 0x60(SI), X6	

  0x44aa16		f30f6f7e70		MOVDQU 0x70(SI), X7	

  0x44aa1b		f3440f6f8680000000	MOVDQU 0x80(SI), X8	

  0x44aa24		f3440f6f8e90000000	MOVDQU 0x90(SI), X9	

  0x44aa2d		f3440f6f96a0000000	MOVDQU 0xa0(SI), X10	

  0x44aa36		f3440f6f9eb0000000	MOVDQU 0xb0(SI), X11	

  0x44aa3f		f3440f6fa6c0000000	MOVDQU 0xc0(SI), X12	

  0x44aa48		f3440f6faed0000000	MOVDQU 0xd0(SI), X13	

  0x44aa51		f3440f6fb6e0000000	MOVDQU 0xe0(SI), X14	

  0x44aa5a		f3440f6fbef0000000	MOVDQU 0xf0(SI), X15	

  0x44aa63		f30f7f07		MOVDQU X0, 0(DI)	

  0x44aa67		f30f7f4f10		MOVDQU X1, 0x10(DI)	

  0x44aa6c		f30f7f5720		MOVDQU X2, 0x20(DI)	

  0x44aa71		f30f7f5f30		MOVDQU X3, 0x30(DI)	

  0x44aa76		f30f7f6740		MOVDQU X4, 0x40(DI)	

  0x44aa7b		f30f7f6f50		MOVDQU X5, 0x50(DI)	

  0x44aa80		f30f7f7760		MOVDQU X6, 0x60(DI)	

  0x44aa85		f30f7f7f70		MOVDQU X7, 0x70(DI)	

  0x44aa8a		f3440f7f8780000000	MOVDQU X8, 0x80(DI)	

  0x44aa93		f3440f7f8f90000000	MOVDQU X9, 0x90(DI)	

  0x44aa9c		f3440f7f97a0000000	MOVDQU X10, 0xa0(DI)	

  0x44aaa5		f3440f7f9fb0000000	MOVDQU X11, 0xb0(DI)	

  0x44aaae		f3440f7fa7c0000000	MOVDQU X12, 0xc0(DI)	

  0x44aab7		f3440f7fafd0000000	MOVDQU X13, 0xd0(DI)	

  0x44aac0		f3440f7fb7e0000000	MOVDQU X14, 0xe0(DI)	

  0x44aac9		f3440f7fbff0000000	MOVDQU X15, 0xf0(DI)	

  0x44aad2		4881fb00010000		CMPQ $0x100, BX		

  0x44aad9		488db600010000		LEAQ 0x100(SI), SI	

  0x44aae0		488dbf00010000		LEAQ 0x100(DI), DI	

  0x44aae7		0f8d00ffffff		JGE 0x44a9ed		

  0x44aaed		e96dfcffff		JMP 0x44a75f		

  0x44aaf2		4889f9			MOVQ DI, CX		

  0x44aaf5		4829f1			SUBQ SI, CX		

  0x44aaf8		4839d9			CMPQ BX, CX		

  0x44aafb		0f82ac010000		JB 0x44acad		

  0x44ab01		4881fb00001000		CMPQ $0x100000, BX	

  0x44ab08		0f83c3000000		JAE 0x44abd1		

  0x44ab0e		488d0c1e		LEAQ 0(SI)(BX*1), CX	

  0x44ab12		4989fa			MOVQ DI, R10		

  0x44ab15		f30f6f6980		MOVDQU -0x80(CX), X5	

  0x44ab1a		f30f6f7190		MOVDQU -0x70(CX), X6	

  0x44ab1f		48c7c080000000		MOVQ $0x80, AX		

  0x44ab26		4883e7e0		ANDQ $-0x20, DI		

  0x44ab2a		4883c720		ADDQ $0x20, DI		

  0x44ab2e		f30f6f79a0		MOVDQU -0x60(CX), X7	

  0x44ab33		f3440f6f41b0		MOVDQU -0x50(CX), X8	

  0x44ab39		4989fb			MOVQ DI, R11		

  0x44ab3c		4d29d3			SUBQ R10, R11		

  0x44ab3f		f3440f6f49c0		MOVDQU -0x40(CX), X9	

  0x44ab45		f3440f6f51d0		MOVDQU -0x30(CX), X10	

  0x44ab4b		4c29db			SUBQ R11, BX		

  0x44ab4e		f3440f6f59e0		MOVDQU -0x20(CX), X11	

  0x44ab54		f3440f6f61f0		MOVDQU -0x10(CX), X12	

  0x44ab5a		c5fe6f26		VMOVDQU 0(SI), X4	

  0x44ab5e		4c01de			ADDQ R11, SI		

  0x44ab61		4829c3			SUBQ AX, BX		

  0x44ab64		c5fe6f06		VMOVDQU 0(SI), X0	

  0x44ab68		c5fe6f4e20		VMOVDQU 0x20(SI), X1	

  0x44ab6d		c5fe6f5640		VMOVDQU 0x40(SI), X2	

  0x44ab72		c5fe6f5e60		VMOVDQU 0x60(SI), X3	

  0x44ab77		4801c6			ADDQ AX, SI		

  0x44ab7a		c5fd7f07		VMOVDQA X0, 0(DI)	

  0x44ab7e		c5fd7f4f20		VMOVDQA X1, 0x20(DI)	

  0x44ab83		c5fd7f5740		VMOVDQA X2, 0x40(DI)	

  0x44ab88		c5fd7f5f60		VMOVDQA X3, 0x60(DI)	

  0x44ab8d		4801c7			ADDQ AX, DI		

  0x44ab90		4829c3			SUBQ AX, BX		

  0x44ab93		77cf			JA 0x44ab64		

  0x44ab95		4801c3			ADDQ AX, BX		

  0x44ab98		4801fb			ADDQ DI, BX		

  0x44ab9b		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x44aba0		c5f877			VZEROUPPER		

  0x44aba3		f30f7f6b80		MOVDQU X5, -0x80(BX)	

  0x44aba8		f30f7f7390		MOVDQU X6, -0x70(BX)	

  0x44abad		f30f7f7ba0		MOVDQU X7, -0x60(BX)	

  0x44abb2		f3440f7f43b0		MOVDQU X8, -0x50(BX)	

  0x44abb8		f3440f7f4bc0		MOVDQU X9, -0x40(BX)	

  0x44abbe		f3440f7f53d0		MOVDQU X10, -0x30(BX)	

  0x44abc4		f3440f7f5be0		MOVDQU X11, -0x20(BX)	

  0x44abca		f3440f7f63f0		MOVDQU X12, -0x10(BX)	

  0x44abd0		c3			RET			

  0x44abd1		488d0c1e		LEAQ 0(SI)(BX*1), CX	

  0x44abd5		f30f6f6c1e80		MOVDQU -0x80(SI)(BX*1), X5	

  0x44abdb		f30f6f7190		MOVDQU -0x70(CX), X6	

  0x44abe0		f30f6f79a0		MOVDQU -0x60(CX), X7	

  0x44abe5		f3440f6f41b0		MOVDQU -0x50(CX), X8	

  0x44abeb		f3440f6f49c0		MOVDQU -0x40(CX), X9	

  0x44abf1		f3440f6f51d0		MOVDQU -0x30(CX), X10	

  0x44abf7		f3440f6f59e0		MOVDQU -0x20(CX), X11	

  0x44abfd		f3440f6f61f0		MOVDQU -0x10(CX), X12	

  0x44ac03		c5fe6f26		VMOVDQU 0(SI), X4	

  0x44ac07		4989f8			MOVQ DI, R8		

  0x44ac0a		4883e7e0		ANDQ $-0x20, DI		

  0x44ac0e		4883c720		ADDQ $0x20, DI		

  0x44ac12		4989fa			MOVQ DI, R10		

  0x44ac15		4d29c2			SUBQ R8, R10		

  0x44ac18		4c29d3			SUBQ R10, BX		

  0x44ac1b		4c01d6			ADDQ R10, SI		

  0x44ac1e		488d0c1f		LEAQ 0(DI)(BX*1), CX	

  0x44ac22		4881eb80000000		SUBQ $0x80, BX		

  0x44ac29		0f1886c0010000		PREFETCHNTA 0x1c0(SI)	

  0x44ac30		0f188680020000		PREFETCHNTA 0x280(SI)	

  0x44ac37		c5fe6f06		VMOVDQU 0(SI), X0	

  0x44ac3b		c5fe6f4e20		VMOVDQU 0x20(SI), X1	

  0x44ac40		c5fe6f5640		VMOVDQU 0x40(SI), X2	

  0x44ac45		c5fe6f5e60		VMOVDQU 0x60(SI), X3	

  0x44ac4a		4881c680000000		ADDQ $0x80, SI		

  0x44ac51		c5fde707		VMOVNTDQ X0, 0(DI)	

  0x44ac55		c5fde74f20		VMOVNTDQ X1, 0x20(DI)	

  0x44ac5a		c5fde75740		VMOVNTDQ X2, 0x40(DI)	

  0x44ac5f		c5fde75f60		VMOVNTDQ X3, 0x60(DI)	

  0x44ac64		4881c780000000		ADDQ $0x80, DI		

  0x44ac6b		4881eb80000000		SUBQ $0x80, BX		

  0x44ac72		77b5			JA 0x44ac29		

  0x44ac74		0faef8			SFENCE			

  0x44ac77		c4c17e7f20		VMOVDQU X4, 0(AX)	

  0x44ac7c		c5f877			VZEROUPPER		

  0x44ac7f		f30f7f6980		MOVDQU X5, -0x80(CX)	

  0x44ac84		f30f7f7190		MOVDQU X6, -0x70(CX)	

  0x44ac89		f30f7f79a0		MOVDQU X7, -0x60(CX)	

  0x44ac8e		f3440f7f41b0		MOVDQU X8, -0x50(CX)	

  0x44ac94		f3440f7f49c0		MOVDQU X9, -0x40(CX)	

  0x44ac9a		f3440f7f51d0		MOVDQU X10, -0x30(CX)	

  0x44aca0		f3440f7f59e0		MOVDQU X11, -0x20(CX)	

  0x44aca6		f3440f7f61f0		MOVDQU X12, -0x10(CX)	

  0x44acac		c3			RET			

  0x44acad		4889f8			MOVQ DI, AX		

  0x44acb0		f30f6f2e		MOVDQU 0(SI), X5	

  0x44acb4		f30f6f7610		MOVDQU 0x10(SI), X6	

  0x44acb9		4801df			ADDQ BX, DI		

  0x44acbc		f30f6f7e20		MOVDQU 0x20(SI), X7	

  0x44acc1		f3440f6f4630		MOVDQU 0x30(SI), X8	

  0x44acc7		4c8d57e0		LEAQ -0x20(DI), R10	

  0x44accb		4989fb			MOVQ DI, R11		

  0x44acce		f3440f6f4e40		MOVDQU 0x40(SI), X9	

  0x44acd4		f3440f6f5650		MOVDQU 0x50(SI), X10	

  0x44acda		4983e31f		ANDQ $0x1f, R11		

  0x44acde		f3440f6f5e60		MOVDQU 0x60(SI), X11	

  0x44ace4		f3440f6f6670		MOVDQU 0x70(SI), X12	

  0x44acea		4c31df			XORQ R11, DI		

  0x44aced		4801de			ADDQ BX, SI		

  0x44acf0		c5fe6f66e0		VMOVDQU -0x20(SI), X4	

  0x44acf5		4c29de			SUBQ R11, SI		

  0x44acf8		4c29db			SUBQ R11, BX		

  0x44acfb		4881fb00001000		CMPQ $0x100000, BX	

  0x44ad02		777b			JA 0x44ad7f		

  0x44ad04		4881eb80000000		SUBQ $0x80, BX		

  0x44ad0b		c5fe6f46e0		VMOVDQU -0x20(SI), X0	

  0x44ad10		c5fe6f4ec0		VMOVDQU -0x40(SI), X1	

  0x44ad15		c5fe6f56a0		VMOVDQU -0x60(SI), X2	

  0x44ad1a		c5fe6f5e80		VMOVDQU -0x80(SI), X3	

  0x44ad1f		4881ee80000000		SUBQ $0x80, SI		

  0x44ad26		c5fd7f47e0		VMOVDQA X0, -0x20(DI)	

  0x44ad2b		c5fd7f4fc0		VMOVDQA X1, -0x40(DI)	

  0x44ad30		c5fd7f57a0		VMOVDQA X2, -0x60(DI)	

  0x44ad35		c5fd7f5f80		VMOVDQA X3, -0x80(DI)	

  0x44ad3a		4881ef80000000		SUBQ $0x80, DI		

  0x44ad41		4881eb80000000		SUBQ $0x80, BX		

  0x44ad48		77c1			JA 0x44ad0b		

  0x44ad4a		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x44ad4f		c5f877			VZEROUPPER		

  0x44ad52		f30f7f28		MOVDQU X5, 0(AX)	

  0x44ad56		f30f7f7010		MOVDQU X6, 0x10(AX)	

  0x44ad5b		f30f7f7820		MOVDQU X7, 0x20(AX)	

  0x44ad60		f3440f7f4030		MOVDQU X8, 0x30(AX)	

  0x44ad66		f3440f7f4840		MOVDQU X9, 0x40(AX)	

  0x44ad6c		f3440f7f5050		MOVDQU X10, 0x50(AX)	

  0x44ad72		f3440f7f5860		MOVDQU X11, 0x60(AX)	

  0x44ad78		f3440f7f6070		MOVDQU X12, 0x70(AX)	

  0x44ad7e		c3			RET			

  0x44ad7f		4881eb80000000		SUBQ $0x80, BX		

  0x44ad86		0f188640feffff		PREFETCHNTA 0xfffffe40(SI)	

  0x44ad8d		0f188680fdffff		PREFETCHNTA 0xfffffd80(SI)	

  0x44ad94		c5fe6f46e0		VMOVDQU -0x20(SI), X0	

  0x44ad99		c5fe6f4ec0		VMOVDQU -0x40(SI), X1	

  0x44ad9e		c5fe6f56a0		VMOVDQU -0x60(SI), X2	

  0x44ada3		c5fe6f5e80		VMOVDQU -0x80(SI), X3	

  0x44ada8		4881ee80000000		SUBQ $0x80, SI		

  0x44adaf		c5fde747e0		VMOVNTDQ X0, -0x20(DI)	

  0x44adb4		c5fde74fc0		VMOVNTDQ X1, -0x40(DI)	

  0x44adb9		c5fde757a0		VMOVNTDQ X2, -0x60(DI)	

  0x44adbe		c5fde75f80		VMOVNTDQ X3, -0x80(DI)	

  0x44adc3		4881ef80000000		SUBQ $0x80, DI		

  0x44adca		4881eb80000000		SUBQ $0x80, BX		

  0x44add1		77b3			JA 0x44ad86		

  0x44add3		0faef8			SFENCE			

  0x44add6		c4c17e7f22		VMOVDQU X4, 0(DX)	

  0x44addb		c5f877			VZEROUPPER		

  0x44adde		f30f7f28		MOVDQU X5, 0(AX)	

  0x44ade2		f30f7f7010		MOVDQU X6, 0x10(AX)	

  0x44ade7		f30f7f7820		MOVDQU X7, 0x20(AX)	

  0x44adec		f3440f7f4030		MOVDQU X8, 0x30(AX)	

  0x44adf2		f3440f7f4840		MOVDQU X9, 0x40(AX)	

  0x44adf8		f3440f7f5050		MOVDQU X10, 0x50(AX)	

  0x44adfe		f3440f7f5860		MOVDQU X11, 0x60(AX)	

  0x44ae04		f3440f7f6070		MOVDQU X12, 0x70(AX)	

  0x44ae0a		c3			RET			

TEXT _rt0_amd64_linux(SB) /usr/local/go/src/runtime/rt0_linux_amd64.s

  0x44ae10		e9dbc6ffff		JMP _rt0_amd64(SB)	

TEXT runtime.exit(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44ae20		8b7c2408		MOVL 0x8(SP), DI	

  0x44ae24		b8e7000000		MOVL $0xe7, AX		

  0x44ae29		0f05			SYSCALL			

  0x44ae2b		c3			RET			

TEXT runtime.exitThread(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44ae30		488b442408		MOVQ 0x8(SP), AX	

  0x44ae35		c70000000000		MOVL $0x0, 0(AX)	

  0x44ae3b		bf00000000		MOVL $0x0, DI		

  0x44ae40		b83c000000		MOVL $0x3c, AX		

  0x44ae45		0f05			SYSCALL			

  0x44ae47		cd03			INT $0x3		

  0x44ae49		ebfe			JMP 0x44ae49		

TEXT runtime.open(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44ae50		bf9cffffff		MOVL $-0x64, DI		

  0x44ae55		488b742408		MOVQ 0x8(SP), SI	

  0x44ae5a		8b542410		MOVL 0x10(SP), DX	

  0x44ae5e		448b542414		MOVL 0x14(SP), R10	

  0x44ae63		b801010000		MOVL $0x101, AX		

  0x44ae68		0f05			SYSCALL			

  0x44ae6a		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44ae70		7605			JBE 0x44ae77		

  0x44ae72		b8ffffffff		MOVL $-0x1, AX		

  0x44ae77		89442418		MOVL AX, 0x18(SP)	

  0x44ae7b		c3			RET			

TEXT runtime.closefd(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44ae80		8b7c2408		MOVL 0x8(SP), DI	

  0x44ae84		b803000000		MOVL $0x3, AX		

  0x44ae89		0f05			SYSCALL			

  0x44ae8b		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44ae91		7605			JBE 0x44ae98		

  0x44ae93		b8ffffffff		MOVL $-0x1, AX		

  0x44ae98		89442410		MOVL AX, 0x10(SP)	

  0x44ae9c		c3			RET			

TEXT runtime.write(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44aea0		488b7c2408		MOVQ 0x8(SP), DI	

  0x44aea5		488b742410		MOVQ 0x10(SP), SI	

  0x44aeaa		8b542418		MOVL 0x18(SP), DX	

  0x44aeae		b801000000		MOVL $0x1, AX		

  0x44aeb3		0f05			SYSCALL			

  0x44aeb5		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44aebb		7605			JBE 0x44aec2		

  0x44aebd		b8ffffffff		MOVL $-0x1, AX		

  0x44aec2		89442420		MOVL AX, 0x20(SP)	

  0x44aec6		c3			RET			

TEXT runtime.read(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44aed0		8b7c2408		MOVL 0x8(SP), DI	

  0x44aed4		488b742410		MOVQ 0x10(SP), SI	

  0x44aed9		8b542418		MOVL 0x18(SP), DX	

  0x44aedd		b800000000		MOVL $0x0, AX		

  0x44aee2		0f05			SYSCALL			

  0x44aee4		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44aeea		7605			JBE 0x44aef1		

  0x44aeec		b8ffffffff		MOVL $-0x1, AX		

  0x44aef1		89442420		MOVL AX, 0x20(SP)	

  0x44aef5		c3			RET			

TEXT runtime.usleep(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44af00		4883ec18		SUBQ $0x18, SP		
  0x44af04		48896c2410		MOVQ BP, 0x10(SP)	
  0x44af09		488d6c2410		LEAQ 0x10(SP), BP	

  0x44af0e		ba00000000		MOVL $0x0, DX		

  0x44af13		8b442420		MOVL 0x20(SP), AX	

  0x44af17		b940420f00		MOVL $0xf4240, CX	

  0x44af1c		f7f1			DIVL CX			

  0x44af1e		48890424		MOVQ AX, 0(SP)		

  0x44af22		b8e8030000		MOVL $0x3e8, AX		

  0x44af27		f7e2			MULL DX			

  0x44af29		4889442408		MOVQ AX, 0x8(SP)	

  0x44af2e		4889e7			MOVQ SP, DI		

  0x44af31		be00000000		MOVL $0x0, SI		

  0x44af36		b823000000		MOVL $0x23, AX		

  0x44af3b		0f05			SYSCALL			

  0x44af3d		488b6c2410		MOVQ 0x10(SP), BP	
  0x44af42		4883c418		ADDQ $0x18, SP		
  0x44af46		c3			RET			

TEXT runtime.gettid(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44af50		b8ba000000		MOVL $0xba, AX		

  0x44af55		0f05			SYSCALL			

  0x44af57		89442408		MOVL AX, 0x8(SP)	

  0x44af5b		c3			RET			

TEXT runtime.raise(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44af60		b827000000		MOVL $0x27, AX		

  0x44af65		0f05			SYSCALL			

  0x44af67		4189c4			MOVL AX, R12		

  0x44af6a		b8ba000000		MOVL $0xba, AX		

  0x44af6f		0f05			SYSCALL			

  0x44af71		89c6			MOVL AX, SI		

  0x44af73		4489e7			MOVL R12, DI		

  0x44af76		8b542408		MOVL 0x8(SP), DX	

  0x44af7a		b8ea000000		MOVL $0xea, AX		

  0x44af7f		0f05			SYSCALL			

  0x44af81		c3			RET			

TEXT runtime.raiseproc(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44af90		b827000000		MOVL $0x27, AX		

  0x44af95		0f05			SYSCALL			

  0x44af97		89c7			MOVL AX, DI		

  0x44af99		8b742408		MOVL 0x8(SP), SI	

  0x44af9d		b83e000000		MOVL $0x3e, AX		

  0x44afa2		0f05			SYSCALL			

  0x44afa4		c3			RET			

TEXT runtime.setitimer(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44afb0		8b7c2408		MOVL 0x8(SP), DI	

  0x44afb4		488b742410		MOVQ 0x10(SP), SI	

  0x44afb9		488b542418		MOVQ 0x18(SP), DX	

  0x44afbe		b826000000		MOVL $0x26, AX		

  0x44afc3		0f05			SYSCALL			

  0x44afc5		c3			RET			

TEXT runtime.mincore(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44afd0		488b7c2408		MOVQ 0x8(SP), DI	

  0x44afd5		488b742410		MOVQ 0x10(SP), SI	

  0x44afda		488b542418		MOVQ 0x18(SP), DX	

  0x44afdf		b81b000000		MOVL $0x1b, AX		

  0x44afe4		0f05			SYSCALL			

  0x44afe6		89442420		MOVL AX, 0x20(SP)	

  0x44afea		c3			RET			

TEXT runtime.walltime(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44aff0		4889e5			MOVQ SP, BP		

  0x44aff3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44affc		488b5830		MOVQ 0x30(AX), BX	

  0x44b000		488b1424		MOVQ 0(SP), DX		

  0x44b004		48899338030000		MOVQ DX, 0x338(BX)	

  0x44b00b		488d1424		LEAQ 0(SP), DX		

  0x44b00f		48899330030000		MOVQ DX, 0x330(BX)	

  0x44b016		483b83c0000000		CMPQ 0xc0(BX), AX	

  0x44b01d		7507			JNE 0x44b026		

  0x44b01f		488b13			MOVQ 0(BX), DX		

  0x44b022		488b6238		MOVQ 0x38(DX), SP	

  0x44b026		4883ec10		SUBQ $0x10, SP		

  0x44b02a		4883e4f0		ANDQ $-0x10, SP		

  0x44b02e		488b05d31d0900		MOVQ runtime.vdsoClockgettimeSym(SB), AX	

  0x44b035		4883f800		CMPQ $0x0, AX		

  0x44b039		742c			JE 0x44b067		

  0x44b03b		bf00000000		MOVL $0x0, DI		

  0x44b040		488d3424		LEAQ 0(SP), SI		

  0x44b044		ffd0			CALL AX			

  0x44b046		488b0424		MOVQ 0(SP), AX		

  0x44b04a		488b542408		MOVQ 0x8(SP), DX	

  0x44b04f		4889ec			MOVQ BP, SP		

  0x44b052		48c7833003000000000000	MOVQ $0x0, 0x330(BX)	

  0x44b05d		4889442408		MOVQ AX, 0x8(SP)	

  0x44b062		89542410		MOVL DX, 0x10(SP)	

  0x44b066		c3			RET			

  0x44b067		488d3c24		LEAQ 0(SP), DI		

  0x44b06b		48c7c600000000		MOVQ $0x0, SI		

  0x44b072		488b05e73f0700		MOVQ runtime.vdsoGettimeofdaySym(SB), AX	

  0x44b079		ffd0			CALL AX			

  0x44b07b		488b0424		MOVQ 0(SP), AX		

  0x44b07f		8b542408		MOVL 0x8(SP), DX	

  0x44b083		4869d2e8030000		IMULQ $0x3e8, DX, DX	

  0x44b08a		4889ec			MOVQ BP, SP		

  0x44b08d		48c7833003000000000000	MOVQ $0x0, 0x330(BX)	

  0x44b098		4889442408		MOVQ AX, 0x8(SP)	

  0x44b09d		89542410		MOVL DX, 0x10(SP)	

  0x44b0a1		c3			RET			

TEXT runtime.nanotime(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b0b0		4889e5			MOVQ SP, BP		

  0x44b0b3		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44b0bc		488b5830		MOVQ 0x30(AX), BX	

  0x44b0c0		488b1424		MOVQ 0(SP), DX		

  0x44b0c4		48899338030000		MOVQ DX, 0x338(BX)	

  0x44b0cb		488d1424		LEAQ 0(SP), DX		

  0x44b0cf		48899330030000		MOVQ DX, 0x330(BX)	

  0x44b0d6		483b83c0000000		CMPQ 0xc0(BX), AX	

  0x44b0dd		7507			JNE 0x44b0e6		

  0x44b0df		488b13			MOVQ 0(BX), DX		

  0x44b0e2		488b6238		MOVQ 0x38(DX), SP	

  0x44b0e6		4883ec10		SUBQ $0x10, SP		

  0x44b0ea		4883e4f0		ANDQ $-0x10, SP		

  0x44b0ee		488b05131d0900		MOVQ runtime.vdsoClockgettimeSym(SB), AX	

  0x44b0f5		4883f800		CMPQ $0x0, AX		

  0x44b0f9		7432			JE 0x44b12d		

  0x44b0fb		bf01000000		MOVL $0x1, DI		

  0x44b100		488d3424		LEAQ 0(SP), SI		

  0x44b104		ffd0			CALL AX			

  0x44b106		488b0424		MOVQ 0(SP), AX		

  0x44b10a		488b542408		MOVQ 0x8(SP), DX	

  0x44b10f		4889ec			MOVQ BP, SP		

  0x44b112		48c7833003000000000000	MOVQ $0x0, 0x330(BX)	

  0x44b11d		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	

  0x44b124		4801d0			ADDQ DX, AX		

  0x44b127		4889442408		MOVQ AX, 0x8(SP)	

  0x44b12c		c3			RET			

  0x44b12d		488d3c24		LEAQ 0(SP), DI		

  0x44b131		48c7c600000000		MOVQ $0x0, SI		

  0x44b138		488b05213f0700		MOVQ runtime.vdsoGettimeofdaySym(SB), AX	

  0x44b13f		ffd0			CALL AX			

  0x44b141		488b0424		MOVQ 0(SP), AX		

  0x44b145		8b542408		MOVL 0x8(SP), DX	

  0x44b149		4889ec			MOVQ BP, SP		

  0x44b14c		48c7833003000000000000	MOVQ $0x0, 0x330(BX)	

  0x44b157		4869d2e8030000		IMULQ $0x3e8, DX, DX	

  0x44b15e		4869c000ca9a3b		IMULQ $0x3b9aca00, AX, AX	

  0x44b165		4801d0			ADDQ DX, AX		

  0x44b168		4889442408		MOVQ AX, 0x8(SP)	

  0x44b16d		c3			RET			

TEXT runtime.rtsigprocmask(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b170		8b7c2408		MOVL 0x8(SP), DI	

  0x44b174		488b742410		MOVQ 0x10(SP), SI	

  0x44b179		488b542418		MOVQ 0x18(SP), DX	

  0x44b17e		448b542420		MOVL 0x20(SP), R10	

  0x44b183		b80e000000		MOVL $0xe, AX		

  0x44b188		0f05			SYSCALL			

  0x44b18a		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44b190		760b			JBE 0x44b19d		

  0x44b192		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x44b19d		c3			RET			

TEXT runtime.rt_sigaction(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b1a0		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b1a5		488b742410		MOVQ 0x10(SP), SI	

  0x44b1aa		488b542418		MOVQ 0x18(SP), DX	

  0x44b1af		4c8b542420		MOVQ 0x20(SP), R10	

  0x44b1b4		b80d000000		MOVL $0xd, AX		

  0x44b1b9		0f05			SYSCALL			

  0x44b1bb		89442428		MOVL AX, 0x28(SP)	

  0x44b1bf		c3			RET			

TEXT runtime.callCgoSigaction(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b1c0		4883ec18		SUBQ $0x18, SP		
  0x44b1c4		48896c2410		MOVQ BP, 0x10(SP)	
  0x44b1c9		488d6c2410		LEAQ 0x10(SP), BP	

  0x44b1ce		488b7c2420		MOVQ 0x20(SP), DI	

  0x44b1d3		488b742428		MOVQ 0x28(SP), SI	

  0x44b1d8		488b542430		MOVQ 0x30(SP), DX	

  0x44b1dd		488b0504670700		MOVQ _cgo_sigaction(SB), AX	

  0x44b1e4		4889e3			MOVQ SP, BX		

  0x44b1e7		4883e4f0		ANDQ $-0x10, SP		

  0x44b1eb		ffd0			CALL AX			

  0x44b1ed		4889dc			MOVQ BX, SP		

  0x44b1f0		89442438		MOVL AX, 0x38(SP)	

  0x44b1f4		488b6c2410		MOVQ 0x10(SP), BP	
  0x44b1f9		4883c418		ADDQ $0x18, SP		
  0x44b1fd		c3			RET			

TEXT runtime.sigfwd(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b200		488b442408		MOVQ 0x8(SP), AX	

  0x44b205		8b7c2410		MOVL 0x10(SP), DI	

  0x44b209		488b742418		MOVQ 0x18(SP), SI	

  0x44b20e		488b542420		MOVQ 0x20(SP), DX	

  0x44b213		55			PUSHL BP		

  0x44b214		4889e5			MOVQ SP, BP		

  0x44b217		4883e4f0		ANDQ $-0x10, SP		

  0x44b21b		ffd0			CALL AX			

  0x44b21d		4889ec			MOVQ BP, SP		

  0x44b220		5d			POPL BP			

  0x44b221		c3			RET			

TEXT runtime.sigtramp(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b230		4883ec50		SUBQ $0x50, SP		
  0x44b234		48896c2448		MOVQ BP, 0x48(SP)	
  0x44b239		488d6c2448		LEAQ 0x48(SP), BP	

  0x44b23e		48895c2440		MOVQ BX, 0x40(SP)	

  0x44b243		48896c2438		MOVQ BP, 0x38(SP)	

  0x44b248		4c89642430		MOVQ R12, 0x30(SP)	

  0x44b24d		4c896c2428		MOVQ R13, 0x28(SP)	

  0x44b252		4c89742420		MOVQ R14, 0x20(SP)	

  0x44b257		4c897c2418		MOVQ R15, 0x18(SP)	

  0x44b25c		4889542410		MOVQ DX, 0x10(SP)	

  0x44b261		4889742408		MOVQ SI, 0x8(SP)	

  0x44b266		48893c24		MOVQ DI, 0(SP)		

  0x44b26a		488d052f95feff		LEAQ 0xfffe952f(IP), AX	

  0x44b271		ffd0			CALL AX			

  0x44b273		4c8b7c2418		MOVQ 0x18(SP), R15	

  0x44b278		4c8b742420		MOVQ 0x20(SP), R14	

  0x44b27d		4c8b6c2428		MOVQ 0x28(SP), R13	

  0x44b282		4c8b642430		MOVQ 0x30(SP), R12	

  0x44b287		488b6c2438		MOVQ 0x38(SP), BP	

  0x44b28c		488b5c2440		MOVQ 0x40(SP), BX	

  0x44b291		488b6c2448		MOVQ 0x48(SP), BP	
  0x44b296		4883c450		ADDQ $0x50, SP		
  0x44b29a		c3			RET			

TEXT runtime.cgoSigtramp(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b2a0		488b0599660700		MOVQ runtime.cgoTraceback(SB), AX	

  0x44b2a7		4885c0			TESTQ AX, AX		

  0x44b2aa		746f			JE 0x44b31b		

  0x44b2ac		488b050d660700		MOVQ 0x7660d(IP), AX	

  0x44b2b3		4885c0			TESTQ AX, AX		

  0x44b2b6		7463			JE 0x44b31b		

  0x44b2b8		64488b0425f8ffffff	MOVQ FS:0xfffffff8, AX	

  0x44b2c1		4885c0			TESTQ AX, AX		

  0x44b2c4		745a			JE 0x44b320		

  0x44b2c6		488b4030		MOVQ 0x30(AX), AX	

  0x44b2ca		4885c0			TESTQ AX, AX		

  0x44b2cd		744c			JE 0x44b31b		

  0x44b2cf		8b8838010000		MOVL 0x138(AX), CX	

  0x44b2d5		85c9			TESTL CX, CX		

  0x44b2d7		7442			JE 0x44b31b		

  0x44b2d9		488b88c0000000		MOVQ 0xc0(AX), CX	

  0x44b2e0		4885c9			TESTQ CX, CX		

  0x44b2e3		7436			JE 0x44b31b		

  0x44b2e5		488b4970		MOVQ 0x70(CX), CX	

  0x44b2e9		4885c9			TESTQ CX, CX		

  0x44b2ec		742d			JE 0x44b31b		

  0x44b2ee		4c8b8040010000		MOVQ 0x140(AX), R8	

  0x44b2f5		4d85c0			TESTQ R8, R8		

  0x44b2f8		7421			JE 0x44b31b		

  0x44b2fa		8b883c010000		MOVL 0x13c(AX), CX	

  0x44b300		85c9			TESTL CX, CX		

  0x44b302		7517			JNE 0x44b31b		

  0x44b304		488b0d35660700		MOVQ runtime.cgoTraceback(SB), CX	

  0x44b30b		4c8d0d1effffff		LEAQ 0xffffff1e(IP), R9	

  0x44b312		488b05a7650700		MOVQ 0x765a7(IP), AX	

  0x44b319		ffe0			JMP AX			

  0x44b31b		e910ffffff		JMP runtime.sigtramp(SB)	

  0x44b320		83ff1b			CMPL $0x1b, DI		

  0x44b323		75f6			JNE 0x44b31b		

  0x44b325		b800000000		MOVL $0x0, AX		

  0x44b32a		b901000000		MOVL $0x1, CX		

  0x44b32f		4c8d1dca190900		LEAQ runtime.sigprofCallersUse(SB), R11	

  0x44b336		f0410fb10b		LOCK CMPXCHGL CX, 0(R11)	

  0x44b33b		75de			JNE 0x44b31b		

  0x44b33d		488b0dfc650700		MOVQ runtime.cgoTraceback(SB), CX	

  0x44b344		4c8d05d51e0900		LEAQ runtime.sigprofCallers(SB), R8	

  0x44b34b		4c8d0d6e25feff		LEAQ 0xfffe256e(IP), R9	

  0x44b352		488b0567650700		MOVQ 0x76567(IP), AX	

  0x44b359		ffe0			JMP AX			

TEXT runtime.sigreturn(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b360		48c7c00f000000		MOVQ $0xf, AX		

  0x44b367		0f05			SYSCALL			

  0x44b369		cd03			INT $0x3		

TEXT runtime.sysMmap(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b370		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b375		488b742410		MOVQ 0x10(SP), SI	

  0x44b37a		8b542418		MOVL 0x18(SP), DX	

  0x44b37e		448b54241c		MOVL 0x1c(SP), R10	

  0x44b383		448b442420		MOVL 0x20(SP), R8	

  0x44b388		448b4c2424		MOVL 0x24(SP), R9	

  0x44b38d		b809000000		MOVL $0x9, AX		

  0x44b392		0f05			SYSCALL			

  0x44b394		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44b39a		7615			JBE 0x44b3b1		

  0x44b39c		48f7d0			NOTQ AX			

  0x44b39f		48ffc0			INCQ AX			

  0x44b3a2		48c744242800000000	MOVQ $0x0, 0x28(SP)	

  0x44b3ab		4889442430		MOVQ AX, 0x30(SP)	

  0x44b3b0		c3			RET			

  0x44b3b1		4889442428		MOVQ AX, 0x28(SP)	

  0x44b3b6		48c744243000000000	MOVQ $0x0, 0x30(SP)	

  0x44b3bf		c3			RET			

TEXT runtime.callCgoMmap(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b3c0		4883ec18		SUBQ $0x18, SP		
  0x44b3c4		48896c2410		MOVQ BP, 0x10(SP)	
  0x44b3c9		488d6c2410		LEAQ 0x10(SP), BP	

  0x44b3ce		488b7c2420		MOVQ 0x20(SP), DI	

  0x44b3d3		488b742428		MOVQ 0x28(SP), SI	

  0x44b3d8		8b542430		MOVL 0x30(SP), DX	

  0x44b3dc		8b4c2434		MOVL 0x34(SP), CX	

  0x44b3e0		448b442438		MOVL 0x38(SP), R8	

  0x44b3e5		448b4c243c		MOVL 0x3c(SP), R9	

  0x44b3ea		488b05df640700		MOVQ _cgo_mmap(SB), AX	

  0x44b3f1		4889e3			MOVQ SP, BX		

  0x44b3f4		4883e4f0		ANDQ $-0x10, SP		

  0x44b3f8		48891c24		MOVQ BX, 0(SP)		

  0x44b3fc		ffd0			CALL AX			

  0x44b3fe		488b2424		MOVQ 0(SP), SP		

  0x44b402		4889442440		MOVQ AX, 0x40(SP)	

  0x44b407		488b6c2410		MOVQ 0x10(SP), BP	
  0x44b40c		4883c418		ADDQ $0x18, SP		
  0x44b410		c3			RET			

TEXT runtime.sysMunmap(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b420		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b425		488b742410		MOVQ 0x10(SP), SI	

  0x44b42a		48c7c00b000000		MOVQ $0xb, AX		

  0x44b431		0f05			SYSCALL			

  0x44b433		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44b439		760b			JBE 0x44b446		

  0x44b43b		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x44b446		c3			RET			

TEXT runtime.callCgoMunmap(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b450		4883ec18		SUBQ $0x18, SP		
  0x44b454		48896c2410		MOVQ BP, 0x10(SP)	
  0x44b459		488d6c2410		LEAQ 0x10(SP), BP	

  0x44b45e		488b7c2420		MOVQ 0x20(SP), DI	

  0x44b463		488b742428		MOVQ 0x28(SP), SI	

  0x44b468		488b0569640700		MOVQ _cgo_munmap(SB), AX	

  0x44b46f		4889e3			MOVQ SP, BX		

  0x44b472		4883e4f0		ANDQ $-0x10, SP		

  0x44b476		48891c24		MOVQ BX, 0(SP)		

  0x44b47a		ffd0			CALL AX			

  0x44b47c		488b2424		MOVQ 0(SP), SP		

  0x44b480		488b6c2410		MOVQ 0x10(SP), BP	
  0x44b485		4883c418		ADDQ $0x18, SP		
  0x44b489		c3			RET			

TEXT runtime.madvise(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b490		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b495		488b742410		MOVQ 0x10(SP), SI	

  0x44b49a		8b542418		MOVL 0x18(SP), DX	

  0x44b49e		48c7c01c000000		MOVQ $0x1c, AX		

  0x44b4a5		0f05			SYSCALL			

  0x44b4a7		89442420		MOVL AX, 0x20(SP)	

  0x44b4ab		c3			RET			

TEXT runtime.futex(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b4b0		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b4b5		8b742410		MOVL 0x10(SP), SI	

  0x44b4b9		8b542414		MOVL 0x14(SP), DX	

  0x44b4bd		4c8b542418		MOVQ 0x18(SP), R10	

  0x44b4c2		4c8b442420		MOVQ 0x20(SP), R8	

  0x44b4c7		448b4c2428		MOVL 0x28(SP), R9	

  0x44b4cc		b8ca000000		MOVL $0xca, AX		

  0x44b4d1		0f05			SYSCALL			

  0x44b4d3		89442430		MOVL AX, 0x30(SP)	

  0x44b4d7		c3			RET			

TEXT runtime.clone(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b4e0		8b7c2408		MOVL 0x8(SP), DI	

  0x44b4e4		488b742410		MOVQ 0x10(SP), SI	

  0x44b4e9		48c7c200000000		MOVQ $0x0, DX		

  0x44b4f0		49c7c200000000		MOVQ $0x0, R10		

  0x44b4f7		4c8b442418		MOVQ 0x18(SP), R8	

  0x44b4fc		4c8b4c2420		MOVQ 0x20(SP), R9	

  0x44b501		4c8b642428		MOVQ 0x28(SP), R12	

  0x44b506		b838000000		MOVL $0x38, AX		

  0x44b50b		0f05			SYSCALL			

  0x44b50d		4883f800		CMPQ $0x0, AX		

  0x44b511		7405			JE 0x44b518		

  0x44b513		89442430		MOVL AX, 0x30(SP)	

  0x44b517		c3			RET			

  0x44b518		4889f4			MOVQ SI, SP		

  0x44b51b		4983f800		CMPQ $0x0, R8		

  0x44b51f		742f			JE 0x44b550		

  0x44b521		4983f900		CMPQ $0x0, R9		

  0x44b525		7429			JE 0x44b550		

  0x44b527		b8ba000000		MOVL $0xba, AX		

  0x44b52c		0f05			SYSCALL			

  0x44b52e		49894048		MOVQ AX, 0x48(R8)	

  0x44b532		498db888000000		LEAQ 0x88(R8), DI	

  0x44b539		e862000000		CALL runtime.settls(SB)	

  0x44b53e		4d894130		MOVQ R8, 0x30(R9)	

  0x44b542		644c890c25f8ffffff	MOVQ R9, FS:0xfffffff8	

  0x44b54b		e8a0daffff		CALL runtime.stackcheck(SB)	

  0x44b550		41ffd4			CALL R12		

  0x44b553		bf6f000000		MOVL $0x6f, DI		

  0x44b558		b83c000000		MOVL $0x3c, AX		

  0x44b55d		0f05			SYSCALL			

  0x44b55f		ebf2			JMP 0x44b553		

TEXT runtime.sigaltstack(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b570		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b575		488b742410		MOVQ 0x10(SP), SI	

  0x44b57a		48c7c083000000		MOVQ $0x83, AX		

  0x44b581		0f05			SYSCALL			

  0x44b583		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44b589		760b			JBE 0x44b596		

  0x44b58b		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x44b596		c3			RET			

TEXT runtime.settls(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b5a0		4883ec28		SUBQ $0x28, SP		
  0x44b5a4		48896c2420		MOVQ BP, 0x20(SP)	
  0x44b5a9		488d6c2420		LEAQ 0x20(SP), BP	

  0x44b5ae		4883c708		ADDQ $0x8, DI		

  0x44b5b2		4889fe			MOVQ DI, SI		

  0x44b5b5		48c7c702100000		MOVQ $0x1002, DI	

  0x44b5bc		48c7c09e000000		MOVQ $0x9e, AX		

  0x44b5c3		0f05			SYSCALL			

  0x44b5c5		483d01f0ffff		CMPQ $-0xfff, AX	

  0x44b5cb		760b			JBE 0x44b5d8		

  0x44b5cd		c70425f1000000f1000000	MOVL $0xf1, 0xf1	

  0x44b5d8		488b6c2420		MOVQ 0x20(SP), BP	
  0x44b5dd		4883c428		ADDQ $0x28, SP		
  0x44b5e1		c3			RET			

TEXT runtime.osyield(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b5f0		b818000000		MOVL $0x18, AX		

  0x44b5f5		0f05			SYSCALL			

  0x44b5f7		c3			RET			

TEXT runtime.sched_getaffinity(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b600		488b7c2408		MOVQ 0x8(SP), DI	

  0x44b605		488b742410		MOVQ 0x10(SP), SI	

  0x44b60a		488b542418		MOVQ 0x18(SP), DX	

  0x44b60f		b8cc000000		MOVL $0xcc, AX		

  0x44b614		0f05			SYSCALL			

  0x44b616		89442420		MOVL AX, 0x20(SP)	

  0x44b61a		c3			RET			

TEXT runtime.epollwait(SB) /usr/local/go/src/runtime/sys_linux_amd64.s

  0x44b620		8b7c2408		MOVL 0x8(SP), DI	

  0x44b624		488b742410		MOVQ 0x10(SP), SI	

  0x44b629		8b542418		MOVL 0x18(SP), DX	

  0x44b62d		448b54241c		MOVL 0x1c(SP), R10	

  0x44b632		49c7c000000000		MOVQ $0x0, R8		

  0x44b639		b819010000		MOVL $0x119, AX		

  0x44b63e		0f05			SYSCALL			

  0x44b640		89442420		MOVL AX, 0x20(SP)	

  0x44b644		c3			RET			

TEXT type..hash.runtime.uncommontype(SB) <autogenerated>

  0x44b650		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b659		483b6110		CMPQ 0x10(CX), SP			
  0x44b65d		7643			JBE 0x44b6a2				
  0x44b65f		4883ec28		SUBQ $0x28, SP				
  0x44b663		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b668		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b66d		488b442430		MOVQ 0x30(SP), AX			
  0x44b672		48890424		MOVQ AX, 0(SP)				
  0x44b676		488b442438		MOVQ 0x38(SP), AX			
  0x44b67b		4889442408		MOVQ AX, 0x8(SP)			
  0x44b680		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44b689		e832bcfbff		CALL runtime.memhash(SB)		
  0x44b68e		488b442418		MOVQ 0x18(SP), AX			
  0x44b693		4889442440		MOVQ AX, 0x40(SP)			
  0x44b698		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b69d		4883c428		ADDQ $0x28, SP				
  0x44b6a1		c3			RET					
  0x44b6a2		e8d9c1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b6a7		eba7			JMP type..hash.runtime.uncommontype(SB)	

TEXT type..eq.runtime.uncommontype(SB) <autogenerated>

  0x44b6b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b6b9		483b6110		CMPQ 0x10(CX), SP			
  0x44b6bd		7642			JBE 0x44b701				
  0x44b6bf		4883ec28		SUBQ $0x28, SP				
  0x44b6c3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b6c8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b6cd		488b442430		MOVQ 0x30(SP), AX			
  0x44b6d2		48890424		MOVQ AX, 0(SP)				
  0x44b6d6		488b442438		MOVQ 0x38(SP), AX			
  0x44b6db		4889442408		MOVQ AX, 0x8(SP)			
  0x44b6e0		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44b6e9		e8326bfbff		CALL runtime.memequal(SB)		
  0x44b6ee		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b6f3		88442440		MOVB AL, 0x40(SP)			
  0x44b6f7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b6fc		4883c428		ADDQ $0x28, SP				
  0x44b700		c3			RET					
  0x44b701		e87ac1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b706		eba8			JMP type..eq.runtime.uncommontype(SB)	

TEXT type..hash.runtime._panic(SB) <autogenerated>

  0x44b710		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b719		483b6110		CMPQ 0x10(CX), SP			
  0x44b71d		0f8684000000		JBE 0x44b7a7				
  0x44b723		4883ec28		SUBQ $0x28, SP				
  0x44b727		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b72c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b731		488b442430		MOVQ 0x30(SP), AX			
  0x44b736		48890424		MOVQ AX, 0(SP)				
  0x44b73a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b73f		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b744		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44b74d		e86ebbfbff		CALL runtime.memhash(SB)		
  0x44b752		488b442418		MOVQ 0x18(SP), AX			
  0x44b757		488b4c2430		MOVQ 0x30(SP), CX			
  0x44b75c		488d5108		LEAQ 0x8(CX), DX			
  0x44b760		48891424		MOVQ DX, 0(SP)				
  0x44b764		4889442408		MOVQ AX, 0x8(SP)			
  0x44b769		e80274fbff		CALL runtime.nilinterhash(SB)		
  0x44b76e		488b442410		MOVQ 0x10(SP), AX			
  0x44b773		488b4c2430		MOVQ 0x30(SP), CX			
  0x44b778		4883c118		ADDQ $0x18, CX				
  0x44b77c		48890c24		MOVQ CX, 0(SP)				
  0x44b780		4889442408		MOVQ AX, 0x8(SP)			
  0x44b785		48c74424100a000000	MOVQ $0xa, 0x10(SP)			
  0x44b78e		e82dbbfbff		CALL runtime.memhash(SB)		
  0x44b793		488b442418		MOVQ 0x18(SP), AX			
  0x44b798		4889442440		MOVQ AX, 0x40(SP)			
  0x44b79d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b7a2		4883c428		ADDQ $0x28, SP				
  0x44b7a6		c3			RET					
  0x44b7a7		e8d4c0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b7ac		e95fffffff		JMP type..hash.runtime._panic(SB)	

TEXT type..eq.runtime._panic(SB) <autogenerated>

  0x44b7c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b7c9		483b6110		CMPQ 0x10(CX), SP			
  0x44b7cd		0f8696000000		JBE 0x44b869				
  0x44b7d3		4883ec28		SUBQ $0x28, SP				
  0x44b7d7		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b7dc		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b7e1		488b442438		MOVQ 0x38(SP), AX			
  0x44b7e6		488b08			MOVQ 0(AX), CX				
  0x44b7e9		488b542430		MOVQ 0x30(SP), DX			
  0x44b7ee		48390a			CMPQ CX, 0(DX)				
  0x44b7f1		7572			JNE 0x44b865				
  0x44b7f3		488b4a10		MOVQ 0x10(DX), CX			
  0x44b7f7		488b5810		MOVQ 0x10(AX), BX			
  0x44b7fb		488b7208		MOVQ 0x8(DX), SI			
  0x44b7ff		48397008		CMPQ SI, 0x8(AX)			
  0x44b803		743c			JE 0x44b841				
  0x44b805		31c9			XORL CX, CX				
  0x44b807		84c9			TESTL CL, CL				
  0x44b809		7510			JNE 0x44b81b				
  0x44b80b		31c0			XORL AX, AX				
  0x44b80d		88442440		MOVB AL, 0x40(SP)			
  0x44b811		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b816		4883c428		ADDQ $0x28, SP				
  0x44b81a		c3			RET					
  0x44b81b		488d4a18		LEAQ 0x18(DX), CX			
  0x44b81f		48890c24		MOVQ CX, 0(SP)				
  0x44b823		4883c018		ADDQ $0x18, AX				
  0x44b827		4889442408		MOVQ AX, 0x8(SP)			
  0x44b82c		48c74424100a000000	MOVQ $0xa, 0x10(SP)			
  0x44b835		e8e669fbff		CALL runtime.memequal(SB)		
  0x44b83a		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b83f		ebcc			JMP 0x44b80d				
  0x44b841		48893424		MOVQ SI, 0(SP)				
  0x44b845		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b84a		48895c2410		MOVQ BX, 0x10(SP)			
  0x44b84f		e87c77fbff		CALL runtime.efaceeq(SB)		
  0x44b854		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44b859		488b442438		MOVQ 0x38(SP), AX			
  0x44b85e		488b542430		MOVQ 0x30(SP), DX			
  0x44b863		eba2			JMP 0x44b807				
  0x44b865		31c9			XORL CX, CX				
  0x44b867		eb9e			JMP 0x44b807				
  0x44b869		e812c0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44b86e		e94dffffff		JMP type..eq.runtime._panic(SB)		

TEXT type..hash.runtime._defer(SB) <autogenerated>

  0x44b880		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b889		483b6110		CMPQ 0x10(CX), SP			
  0x44b88d		7668			JBE 0x44b8f7				
  0x44b88f		4883ec28		SUBQ $0x28, SP				
  0x44b893		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b898		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b89d		488b442430		MOVQ 0x30(SP), AX			
  0x44b8a2		48890424		MOVQ AX, 0(SP)				
  0x44b8a6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b8ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b8b0		48c744241005000000	MOVQ $0x5, 0x10(SP)			
  0x44b8b9		e802bafbff		CALL runtime.memhash(SB)		
  0x44b8be		488b442418		MOVQ 0x18(SP), AX			
  0x44b8c3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44b8c8		4883c108		ADDQ $0x8, CX				
  0x44b8cc		48890c24		MOVQ CX, 0(SP)				
  0x44b8d0		4889442408		MOVQ AX, 0x8(SP)			
  0x44b8d5		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x44b8de		e8ddb9fbff		CALL runtime.memhash(SB)		
  0x44b8e3		488b442418		MOVQ 0x18(SP), AX			
  0x44b8e8		4889442440		MOVQ AX, 0x40(SP)			
  0x44b8ed		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b8f2		4883c428		ADDQ $0x28, SP				
  0x44b8f6		c3			RET					
  0x44b8f7		e884bfffff		CALL runtime.morestack_noctxt(SB)	
  0x44b8fc		eb82			JMP type..hash.runtime._defer(SB)	

TEXT type..eq.runtime._defer(SB) <autogenerated>

  0x44b900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b909		483b6110		CMPQ 0x10(CX), SP			
  0x44b90d		7661			JBE 0x44b970				
  0x44b90f		4883ec28		SUBQ $0x28, SP				
  0x44b913		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b918		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b91d		488b442438		MOVQ 0x38(SP), AX			
  0x44b922		8b08			MOVL 0(AX), CX				
  0x44b924		488b542430		MOVQ 0x30(SP), DX			
  0x44b929		390a			CMPL CX, 0(DX)				
  0x44b92b		753f			JNE 0x44b96c				
  0x44b92d		0fb64804		MOVZX 0x4(AX), CX			
  0x44b931		384a04			CMPB CL, 0x4(DX)			
  0x44b934		7410			JE 0x44b946				
  0x44b936		31c0			XORL AX, AX				
  0x44b938		88442440		MOVB AL, 0x40(SP)			
  0x44b93c		488b6c2420		MOVQ 0x20(SP), BP			
  0x44b941		4883c428		ADDQ $0x28, SP				
  0x44b945		c3			RET					
  0x44b946		488d4a08		LEAQ 0x8(DX), CX			
  0x44b94a		48890c24		MOVQ CX, 0(SP)				
  0x44b94e		4883c008		ADDQ $0x8, AX				
  0x44b952		4889442408		MOVQ AX, 0x8(SP)			
  0x44b957		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x44b960		e8bb68fbff		CALL runtime.memequal(SB)		
  0x44b965		0fb6442418		MOVZX 0x18(SP), AX			
  0x44b96a		ebcc			JMP 0x44b938				
  0x44b96c		31c0			XORL AX, AX				
  0x44b96e		ebc8			JMP 0x44b938				
  0x44b970		e80bbfffff		CALL runtime.morestack_noctxt(SB)	
  0x44b975		eb89			JMP type..eq.runtime._defer(SB)		

TEXT type..hash.runtime.sysmontick(SB) <autogenerated>

  0x44b980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44b989		483b6110		CMPQ 0x10(CX), SP			
  0x44b98d		0f868d000000		JBE 0x44ba20				
  0x44b993		4883ec28		SUBQ $0x28, SP				
  0x44b997		48896c2420		MOVQ BP, 0x20(SP)			
  0x44b99c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44b9a1		488b442430		MOVQ 0x30(SP), AX			
  0x44b9a6		48890424		MOVQ AX, 0(SP)				
  0x44b9aa		488b4c2438		MOVQ 0x38(SP), CX			
  0x44b9af		48894c2408		MOVQ CX, 0x8(SP)			
  0x44b9b4		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44b9bd		e8feb8fbff		CALL runtime.memhash(SB)		
  0x44b9c2		488b442418		MOVQ 0x18(SP), AX			
  0x44b9c7		488b4c2430		MOVQ 0x30(SP), CX			
  0x44b9cc		488d5108		LEAQ 0x8(CX), DX			
  0x44b9d0		48891424		MOVQ DX, 0(SP)				
  0x44b9d4		4889442408		MOVQ AX, 0x8(SP)			
  0x44b9d9		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44b9e2		e8d9b8fbff		CALL runtime.memhash(SB)		
  0x44b9e7		488b442418		MOVQ 0x18(SP), AX			
  0x44b9ec		488b4c2430		MOVQ 0x30(SP), CX			
  0x44b9f1		4883c118		ADDQ $0x18, CX				
  0x44b9f5		48890c24		MOVQ CX, 0(SP)				
  0x44b9f9		4889442408		MOVQ AX, 0x8(SP)			
  0x44b9fe		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44ba07		e8b4b8fbff		CALL runtime.memhash(SB)		
  0x44ba0c		488b442418		MOVQ 0x18(SP), AX			
  0x44ba11		4889442440		MOVQ AX, 0x40(SP)			
  0x44ba16		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ba1b		4883c428		ADDQ $0x28, SP				
  0x44ba1f		c3			RET					
  0x44ba20		e85bbeffff		CALL runtime.morestack_noctxt(SB)	
  0x44ba25		e956ffffff		JMP type..hash.runtime.sysmontick(SB)	

TEXT type..eq.runtime.sysmontick(SB) <autogenerated>

  0x44ba30		488b442410		MOVQ 0x10(SP), AX	
  0x44ba35		8b08			MOVL 0(AX), CX		
  0x44ba37		488b542408		MOVQ 0x8(SP), DX	
  0x44ba3c		390a			CMPL CX, 0(DX)		
  0x44ba3e		752a			JNE 0x44ba6a		
  0x44ba40		488b4a08		MOVQ 0x8(DX), CX	
  0x44ba44		48394808		CMPQ CX, 0x8(AX)	
  0x44ba48		751c			JNE 0x44ba66		
  0x44ba4a		8b4810			MOVL 0x10(AX), CX	
  0x44ba4d		394a10			CMPL CX, 0x10(DX)	
  0x44ba50		7510			JNE 0x44ba62		
  0x44ba52		488b4a18		MOVQ 0x18(DX), CX	
  0x44ba56		48394818		CMPQ CX, 0x18(AX)	
  0x44ba5a		0f94c0			SETE AL			
  0x44ba5d		88442418		MOVB AL, 0x18(SP)	
  0x44ba61		c3			RET			
  0x44ba62		31c0			XORL AX, AX		
  0x44ba64		ebf7			JMP 0x44ba5d		
  0x44ba66		31c0			XORL AX, AX		
  0x44ba68		ebf3			JMP 0x44ba5d		
  0x44ba6a		31c0			XORL AX, AX		
  0x44ba6c		ebef			JMP 0x44ba5d		

TEXT type..hash.runtime.special(SB) <autogenerated>

  0x44ba70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ba79		483b6110		CMPQ 0x10(CX), SP			
  0x44ba7d		7643			JBE 0x44bac2				
  0x44ba7f		4883ec28		SUBQ $0x28, SP				
  0x44ba83		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ba88		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ba8d		488b442430		MOVQ 0x30(SP), AX			
  0x44ba92		48890424		MOVQ AX, 0(SP)				
  0x44ba96		488b442438		MOVQ 0x38(SP), AX			
  0x44ba9b		4889442408		MOVQ AX, 0x8(SP)			
  0x44baa0		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x44baa9		e812b8fbff		CALL runtime.memhash(SB)		
  0x44baae		488b442418		MOVQ 0x18(SP), AX			
  0x44bab3		4889442440		MOVQ AX, 0x40(SP)			
  0x44bab8		488b6c2420		MOVQ 0x20(SP), BP			
  0x44babd		4883c428		ADDQ $0x28, SP				
  0x44bac1		c3			RET					
  0x44bac2		e8b9bdffff		CALL runtime.morestack_noctxt(SB)	
  0x44bac7		eba7			JMP type..hash.runtime.special(SB)	

TEXT type..eq.runtime.special(SB) <autogenerated>

  0x44bad0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bad9		483b6110		CMPQ 0x10(CX), SP			
  0x44badd		7642			JBE 0x44bb21				
  0x44badf		4883ec28		SUBQ $0x28, SP				
  0x44bae3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bae8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44baed		488b442430		MOVQ 0x30(SP), AX			
  0x44baf2		48890424		MOVQ AX, 0(SP)				
  0x44baf6		488b442438		MOVQ 0x38(SP), AX			
  0x44bafb		4889442408		MOVQ AX, 0x8(SP)			
  0x44bb00		48c74424100b000000	MOVQ $0xb, 0x10(SP)			
  0x44bb09		e81267fbff		CALL runtime.memequal(SB)		
  0x44bb0e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44bb13		88442440		MOVB AL, 0x40(SP)			
  0x44bb17		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bb1c		4883c428		ADDQ $0x28, SP				
  0x44bb20		c3			RET					
  0x44bb21		e85abdffff		CALL runtime.morestack_noctxt(SB)	
  0x44bb26		eba8			JMP type..eq.runtime.special(SB)	

TEXT type..hash.runtime.markBits(SB) <autogenerated>

  0x44bb30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bb39		483b6110		CMPQ 0x10(CX), SP			
  0x44bb3d		7668			JBE 0x44bba7				
  0x44bb3f		4883ec28		SUBQ $0x28, SP				
  0x44bb43		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bb48		488d6c2420		LEAQ 0x20(SP), BP			
  0x44bb4d		488b442430		MOVQ 0x30(SP), AX			
  0x44bb52		48890424		MOVQ AX, 0(SP)				
  0x44bb56		488b4c2438		MOVQ 0x38(SP), CX			
  0x44bb5b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44bb60		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44bb69		e852b7fbff		CALL runtime.memhash(SB)		
  0x44bb6e		488b442418		MOVQ 0x18(SP), AX			
  0x44bb73		488b4c2430		MOVQ 0x30(SP), CX			
  0x44bb78		4883c110		ADDQ $0x10, CX				
  0x44bb7c		48890c24		MOVQ CX, 0(SP)				
  0x44bb80		4889442408		MOVQ AX, 0x8(SP)			
  0x44bb85		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44bb8e		e82db7fbff		CALL runtime.memhash(SB)		
  0x44bb93		488b442418		MOVQ 0x18(SP), AX			
  0x44bb98		4889442440		MOVQ AX, 0x40(SP)			
  0x44bb9d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bba2		4883c428		ADDQ $0x28, SP				
  0x44bba6		c3			RET					
  0x44bba7		e8d4bcffff		CALL runtime.morestack_noctxt(SB)	
  0x44bbac		eb82			JMP type..hash.runtime.markBits(SB)	

TEXT type..eq.runtime.markBits(SB) <autogenerated>

  0x44bbb0		488b442410		MOVQ 0x10(SP), AX	
  0x44bbb5		488b08			MOVQ 0(AX), CX		
  0x44bbb8		488b542408		MOVQ 0x8(SP), DX	
  0x44bbbd		48390a			CMPQ CX, 0(DX)		
  0x44bbc0		751d			JNE 0x44bbdf		
  0x44bbc2		0fb64808		MOVZX 0x8(AX), CX	
  0x44bbc6		384a08			CMPB CL, 0x8(DX)	
  0x44bbc9		7510			JNE 0x44bbdb		
  0x44bbcb		488b4010		MOVQ 0x10(AX), AX	
  0x44bbcf		48394210		CMPQ AX, 0x10(DX)	
  0x44bbd3		0f94c0			SETE AL			
  0x44bbd6		88442418		MOVB AL, 0x18(SP)	
  0x44bbda		c3			RET			
  0x44bbdb		31c0			XORL AX, AX		
  0x44bbdd		ebf7			JMP 0x44bbd6		
  0x44bbdf		31c0			XORL AX, AX		
  0x44bbe1		ebf3			JMP 0x44bbd6		

TEXT type..hash.runtime.mcache(SB) <autogenerated>

  0x44bbf0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bbf9		483b6110		CMPQ 0x10(CX), SP			
  0x44bbfd		7668			JBE 0x44bc67				
  0x44bbff		4883ec28		SUBQ $0x28, SP				
  0x44bc03		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bc08		488d6c2420		LEAQ 0x20(SP), BP			
  0x44bc0d		488b442430		MOVQ 0x30(SP), AX			
  0x44bc12		48890424		MOVQ AX, 0(SP)				
  0x44bc16		488b4c2438		MOVQ 0x38(SP), CX			
  0x44bc1b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44bc20		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44bc29		e892b6fbff		CALL runtime.memhash(SB)		
  0x44bc2e		488b442418		MOVQ 0x18(SP), AX			
  0x44bc33		488b4c2430		MOVQ 0x30(SP), CX			
  0x44bc38		4883c108		ADDQ $0x8, CX				
  0x44bc3c		48890c24		MOVQ CX, 0(SP)				
  0x44bc40		4889442408		MOVQ AX, 0x8(SP)			
  0x44bc45		48c7442410bc060000	MOVQ $0x6bc, 0x10(SP)			
  0x44bc4e		e86db6fbff		CALL runtime.memhash(SB)		
  0x44bc53		488b442418		MOVQ 0x18(SP), AX			
  0x44bc58		4889442440		MOVQ AX, 0x40(SP)			
  0x44bc5d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bc62		4883c428		ADDQ $0x28, SP				
  0x44bc66		c3			RET					
  0x44bc67		e814bcffff		CALL runtime.morestack_noctxt(SB)	
  0x44bc6c		eb82			JMP type..hash.runtime.mcache(SB)	

TEXT type..eq.runtime.mcache(SB) <autogenerated>

  0x44bc70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bc79		483b6110		CMPQ 0x10(CX), SP			
  0x44bc7d		7654			JBE 0x44bcd3				
  0x44bc7f		4883ec28		SUBQ $0x28, SP				
  0x44bc83		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bc88		488d6c2420		LEAQ 0x20(SP), BP			
  0x44bc8d		488b442438		MOVQ 0x38(SP), AX			
  0x44bc92		8b08			MOVL 0(AX), CX				
  0x44bc94		488b542430		MOVQ 0x30(SP), DX			
  0x44bc99		390a			CMPL CX, 0(DX)				
  0x44bc9b		7410			JE 0x44bcad				
  0x44bc9d		31c0			XORL AX, AX				
  0x44bc9f		88442440		MOVB AL, 0x40(SP)			
  0x44bca3		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bca8		4883c428		ADDQ $0x28, SP				
  0x44bcac		c3			RET					
  0x44bcad		488d4a08		LEAQ 0x8(DX), CX			
  0x44bcb1		48890c24		MOVQ CX, 0(SP)				
  0x44bcb5		4883c008		ADDQ $0x8, AX				
  0x44bcb9		4889442408		MOVQ AX, 0x8(SP)			
  0x44bcbe		48c7442410bc060000	MOVQ $0x6bc, 0x10(SP)			
  0x44bcc7		e85465fbff		CALL runtime.memequal(SB)		
  0x44bccc		0fb6442418		MOVZX 0x18(SP), AX			
  0x44bcd1		ebcc			JMP 0x44bc9f				
  0x44bcd3		e8a8bbffff		CALL runtime.morestack_noctxt(SB)	
  0x44bcd8		eb96			JMP type..eq.runtime.mcache(SB)		

TEXT type..hash.struct { runtime.gList; runtime.n int32 }(SB) <autogenerated>

  0x44bce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX						
  0x44bce9		483b6110		CMPQ 0x10(CX), SP						
  0x44bced		7643			JBE 0x44bd32							
  0x44bcef		4883ec28		SUBQ $0x28, SP							
  0x44bcf3		48896c2420		MOVQ BP, 0x20(SP)						
  0x44bcf8		488d6c2420		LEAQ 0x20(SP), BP						
  0x44bcfd		488b442430		MOVQ 0x30(SP), AX						
  0x44bd02		48890424		MOVQ AX, 0(SP)							
  0x44bd06		488b442438		MOVQ 0x38(SP), AX						
  0x44bd0b		4889442408		MOVQ AX, 0x8(SP)						
  0x44bd10		48c74424100c000000	MOVQ $0xc, 0x10(SP)						
  0x44bd19		e8a2b5fbff		CALL runtime.memhash(SB)					
  0x44bd1e		488b442418		MOVQ 0x18(SP), AX						
  0x44bd23		4889442440		MOVQ AX, 0x40(SP)						
  0x44bd28		488b6c2420		MOVQ 0x20(SP), BP						
  0x44bd2d		4883c428		ADDQ $0x28, SP							
  0x44bd31		c3			RET								
  0x44bd32		e849bbffff		CALL runtime.morestack_noctxt(SB)				
  0x44bd37		eba7			JMP type..hash.struct { runtime.gList; runtime.n int32 }(SB)	

TEXT type..eq.struct { runtime.gList; runtime.n int32 }(SB) <autogenerated>

  0x44bd40		488b442410		MOVQ 0x10(SP), AX	
  0x44bd45		488b08			MOVQ 0(AX), CX		
  0x44bd48		488b542408		MOVQ 0x8(SP), DX	
  0x44bd4d		48390a			CMPQ CX, 0(DX)		
  0x44bd50		750e			JNE 0x44bd60		
  0x44bd52		8b4008			MOVL 0x8(AX), AX	
  0x44bd55		394208			CMPL AX, 0x8(DX)	
  0x44bd58		0f94c0			SETE AL			
  0x44bd5b		88442418		MOVB AL, 0x18(SP)	
  0x44bd5f		c3			RET			
  0x44bd60		31c0			XORL AX, AX		
  0x44bd62		ebf7			JMP 0x44bd5b		

TEXT type..hash.runtime.gcWork(SB) <autogenerated>

  0x44bd70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bd79		483b6110		CMPQ 0x10(CX), SP			
  0x44bd7d		0f868d000000		JBE 0x44be10				
  0x44bd83		4883ec28		SUBQ $0x28, SP				
  0x44bd87		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bd8c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44bd91		488b442430		MOVQ 0x30(SP), AX			
  0x44bd96		48890424		MOVQ AX, 0(SP)				
  0x44bd9a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44bd9f		48894c2408		MOVQ CX, 0x8(SP)			
  0x44bda4		48c744241021000000	MOVQ $0x21, 0x10(SP)			
  0x44bdad		e80eb5fbff		CALL runtime.memhash(SB)		
  0x44bdb2		488b442418		MOVQ 0x18(SP), AX			
  0x44bdb7		488b4c2430		MOVQ 0x30(SP), CX			
  0x44bdbc		488d5124		LEAQ 0x24(CX), DX			
  0x44bdc0		48891424		MOVQ DX, 0(SP)				
  0x44bdc4		4889442408		MOVQ AX, 0x8(SP)			
  0x44bdc9		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44bdd2		e8e9b4fbff		CALL runtime.memhash(SB)		
  0x44bdd7		488b442418		MOVQ 0x18(SP), AX			
  0x44bddc		488b4c2430		MOVQ 0x30(SP), CX			
  0x44bde1		4883c130		ADDQ $0x30, CX				
  0x44bde5		48890c24		MOVQ CX, 0(SP)				
  0x44bde9		4889442408		MOVQ AX, 0x8(SP)			
  0x44bdee		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x44bdf7		e8c4b4fbff		CALL runtime.memhash(SB)		
  0x44bdfc		488b442418		MOVQ 0x18(SP), AX			
  0x44be01		4889442440		MOVQ AX, 0x40(SP)			
  0x44be06		488b6c2420		MOVQ 0x20(SP), BP			
  0x44be0b		4883c428		ADDQ $0x28, SP				
  0x44be0f		c3			RET					
  0x44be10		e86bbaffff		CALL runtime.morestack_noctxt(SB)	
  0x44be15		e956ffffff		JMP type..hash.runtime.gcWork(SB)	

TEXT type..eq.runtime.gcWork(SB) <autogenerated>

  0x44be20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44be29		483b6110		CMPQ 0x10(CX), SP			
  0x44be2d		0f868e000000		JBE 0x44bec1				
  0x44be33		4883ec28		SUBQ $0x28, SP				
  0x44be37		48896c2420		MOVQ BP, 0x20(SP)			
  0x44be3c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44be41		488b442430		MOVQ 0x30(SP), AX			
  0x44be46		48890424		MOVQ AX, 0(SP)				
  0x44be4a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44be4f		48894c2408		MOVQ CX, 0x8(SP)			
  0x44be54		48c744241021000000	MOVQ $0x21, 0x10(SP)			
  0x44be5d		e8be63fbff		CALL runtime.memequal(SB)		
  0x44be62		807c241800		CMPB $0x0, 0x18(SP)			
  0x44be67		7454			JE 0x44bebd				
  0x44be69		488b442438		MOVQ 0x38(SP), AX			
  0x44be6e		8b4824			MOVL 0x24(AX), CX			
  0x44be71		488b542430		MOVQ 0x30(SP), DX			
  0x44be76		394a24			CMPL CX, 0x24(DX)			
  0x44be79		753e			JNE 0x44beb9				
  0x44be7b		8b4828			MOVL 0x28(AX), CX			
  0x44be7e		394a28			CMPL CX, 0x28(DX)			
  0x44be81		7410			JE 0x44be93				
  0x44be83		31c0			XORL AX, AX				
  0x44be85		88442440		MOVB AL, 0x40(SP)			
  0x44be89		488b6c2420		MOVQ 0x20(SP), BP			
  0x44be8e		4883c428		ADDQ $0x28, SP				
  0x44be92		c3			RET					
  0x44be93		488d4a30		LEAQ 0x30(DX), CX			
  0x44be97		48890c24		MOVQ CX, 0(SP)				
  0x44be9b		4883c030		ADDQ $0x30, AX				
  0x44be9f		4889442408		MOVQ AX, 0x8(SP)			
  0x44bea4		48c744241080000000	MOVQ $0x80, 0x10(SP)			
  0x44bead		e86e63fbff		CALL runtime.memequal(SB)		
  0x44beb2		0fb6442418		MOVZX 0x18(SP), AX			
  0x44beb7		ebcc			JMP 0x44be85				
  0x44beb9		31c0			XORL AX, AX				
  0x44bebb		ebc8			JMP 0x44be85				
  0x44bebd		31c0			XORL AX, AX				
  0x44bebf		ebc4			JMP 0x44be85				
  0x44bec1		e8bab9ffff		CALL runtime.morestack_noctxt(SB)	
  0x44bec6		e955ffffff		JMP type..eq.runtime.gcWork(SB)		

TEXT type..hash.runtime.wbBuf(SB) <autogenerated>

  0x44bed0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bed9		483b6110		CMPQ 0x10(CX), SP			
  0x44bedd		7643			JBE 0x44bf22				
  0x44bedf		4883ec28		SUBQ $0x28, SP				
  0x44bee3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bee8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44beed		488b442430		MOVQ 0x30(SP), AX			
  0x44bef2		48890424		MOVQ AX, 0(SP)				
  0x44bef6		488b442438		MOVQ 0x38(SP), AX			
  0x44befb		4889442408		MOVQ AX, 0x8(SP)			
  0x44bf00		48c744241014100000	MOVQ $0x1014, 0x10(SP)			
  0x44bf09		e8b2b3fbff		CALL runtime.memhash(SB)		
  0x44bf0e		488b442418		MOVQ 0x18(SP), AX			
  0x44bf13		4889442440		MOVQ AX, 0x40(SP)			
  0x44bf18		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bf1d		4883c428		ADDQ $0x28, SP				
  0x44bf21		c3			RET					
  0x44bf22		e859b9ffff		CALL runtime.morestack_noctxt(SB)	
  0x44bf27		eba7			JMP type..hash.runtime.wbBuf(SB)	

TEXT type..eq.runtime.wbBuf(SB) <autogenerated>

  0x44bf30		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44bf39		483b6110		CMPQ 0x10(CX), SP			
  0x44bf3d		7642			JBE 0x44bf81				
  0x44bf3f		4883ec28		SUBQ $0x28, SP				
  0x44bf43		48896c2420		MOVQ BP, 0x20(SP)			
  0x44bf48		488d6c2420		LEAQ 0x20(SP), BP			
  0x44bf4d		488b442430		MOVQ 0x30(SP), AX			
  0x44bf52		48890424		MOVQ AX, 0(SP)				
  0x44bf56		488b442438		MOVQ 0x38(SP), AX			
  0x44bf5b		4889442408		MOVQ AX, 0x8(SP)			
  0x44bf60		48c744241014100000	MOVQ $0x1014, 0x10(SP)			
  0x44bf69		e8b262fbff		CALL runtime.memequal(SB)		
  0x44bf6e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44bf73		88442440		MOVB AL, 0x40(SP)			
  0x44bf77		488b6c2420		MOVQ 0x20(SP), BP			
  0x44bf7c		4883c428		ADDQ $0x28, SP				
  0x44bf80		c3			RET					
  0x44bf81		e8fab8ffff		CALL runtime.morestack_noctxt(SB)	
  0x44bf86		eba8			JMP type..eq.runtime.wbBuf(SB)		

TEXT runtime.(*waitReason).String(SB) <autogenerated>

  0x44bf90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44bf99		4883ec08		SUBQ $0x8, SP		
  0x44bf9d		48892c24		MOVQ BP, 0(SP)		
  0x44bfa1		488d2c24		LEAQ 0(SP), BP		
  0x44bfa5		488b5920		MOVQ 0x20(CX), BX	
  0x44bfa9		4885db			TESTQ BX, BX		
  0x44bfac		7563			JNE 0x44c011		
  0x44bfae		488b442410		MOVQ 0x10(SP), AX	
  0x44bfb3		4885c0			TESTQ AX, AX		
  0x44bfb6		7452			JE 0x44c00a		
  0x44bfb8		0fb600			MOVZX 0(AX), AX		
  0x44bfbb		90			NOPL			
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x44bfbc		84c0			TESTL AL, AL		
  0x44bfbe		731f			JAE 0x44bfdf		
  0x44bfc0		488d056b450200		LEAQ 0x2456b(IP), AX	
  0x44bfc7		b913000000		MOVL $0x13, CX		

  0x44bfcc		4889442418		MOVQ AX, 0x18(SP)	
  0x44bfd1		48894c2420		MOVQ CX, 0x20(SP)	
  0x44bfd6		488b2c24		MOVQ 0(SP), BP		
  0x44bfda		4883c408		ADDQ $0x8, SP		
  0x44bfde		c3			RET			
	if w < 0 || w >= waitReason(len(waitReasonStrings)) {
  0x44bfdf		80f818			CMPL $0x18, AL		
  0x44bfe2		73dc			JAE 0x44bfc0		
	return waitReasonStrings[w]
  0x44bfe4		4883f818		CMPQ $0x18, AX				
  0x44bfe8		7319			JAE 0x44c003				
  0x44bfea		48c1e004		SHLQ $0x4, AX				
  0x44bfee		488d150b410700		LEAQ runtime.waitReasonStrings(SB), DX	
  0x44bff5		488b1c02		MOVQ 0(DX)(AX*1), BX			
  0x44bff9		488b4c0208		MOVQ 0x8(DX)(AX*1), CX			

  0x44bffe		4889d8			MOVQ BX, AX		
  0x44c001		ebc9			JMP 0x44bfcc		
	return waitReasonStrings[w]
  0x44c003		e8185ffdff		CALL runtime.panicindex(SB)	
  0x44c008		0f0b			UD2				

  0x44c00a		e8a1aefbff		CALL runtime.panicwrap(SB)	
  0x44c00f		0f0b			UD2				
  0x44c011		488d7c2410		LEAQ 0x10(SP), DI		
  0x44c016		48393b			CMPQ DI, 0(BX)			
  0x44c019		7593			JNE 0x44bfae			
  0x44c01b		488923			MOVQ SP, 0(BX)			
  0x44c01e		eb8e			JMP 0x44bfae			

TEXT type..hash.runtime.sudog(SB) <autogenerated>

  0x44c020		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c029		483b6110		CMPQ 0x10(CX), SP			
  0x44c02d		0f868d000000		JBE 0x44c0c0				
  0x44c033		4883ec28		SUBQ $0x28, SP				
  0x44c037		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c03c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c041		488b442430		MOVQ 0x30(SP), AX			
  0x44c046		48890424		MOVQ AX, 0(SP)				
  0x44c04a		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c04f		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c054		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44c05d		e85eb2fbff		CALL runtime.memhash(SB)		
  0x44c062		488b442418		MOVQ 0x18(SP), AX			
  0x44c067		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c06c		488d5110		LEAQ 0x10(CX), DX			
  0x44c070		48891424		MOVQ DX, 0(SP)				
  0x44c074		4889442408		MOVQ AX, 0x8(SP)			
  0x44c079		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x44c082		e839b2fbff		CALL runtime.memhash(SB)		
  0x44c087		488b442418		MOVQ 0x18(SP), AX			
  0x44c08c		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c091		4883c140		ADDQ $0x40, CX				
  0x44c095		48890c24		MOVQ CX, 0(SP)				
  0x44c099		4889442408		MOVQ AX, 0x8(SP)			
  0x44c09e		48c744241020000000	MOVQ $0x20, 0x10(SP)			
  0x44c0a7		e814b2fbff		CALL runtime.memhash(SB)		
  0x44c0ac		488b442418		MOVQ 0x18(SP), AX			
  0x44c0b1		4889442440		MOVQ AX, 0x40(SP)			
  0x44c0b6		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c0bb		4883c428		ADDQ $0x28, SP				
  0x44c0bf		c3			RET					
  0x44c0c0		e8bbb7ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c0c5		e956ffffff		JMP type..hash.runtime.sudog(SB)	

TEXT type..eq.runtime.sudog(SB) <autogenerated>

  0x44c0d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c0d9		483b6110		CMPQ 0x10(CX), SP			
  0x44c0dd		0f8699000000		JBE 0x44c17c				
  0x44c0e3		4883ec28		SUBQ $0x28, SP				
  0x44c0e7		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c0ec		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c0f1		488b442438		MOVQ 0x38(SP), AX			
  0x44c0f6		488b08			MOVQ 0(AX), CX				
  0x44c0f9		488b542430		MOVQ 0x30(SP), DX			
  0x44c0fe		48390a			CMPQ CX, 0(DX)				
  0x44c101		7575			JNE 0x44c178				
  0x44c103		0fb64808		MOVZX 0x8(AX), CX			
  0x44c107		384a08			CMPB CL, 0x8(DX)			
  0x44c10a		743c			JE 0x44c148				
  0x44c10c		31c9			XORL CX, CX				
  0x44c10e		84c9			TESTL CL, CL				
  0x44c110		7510			JNE 0x44c122				
  0x44c112		31c0			XORL AX, AX				
  0x44c114		88442440		MOVB AL, 0x40(SP)			
  0x44c118		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c11d		4883c428		ADDQ $0x28, SP				
  0x44c121		c3			RET					
  0x44c122		488d4a40		LEAQ 0x40(DX), CX			
  0x44c126		48890c24		MOVQ CX, 0(SP)				
  0x44c12a		4883c040		ADDQ $0x40, AX				
  0x44c12e		4889442408		MOVQ AX, 0x8(SP)			
  0x44c133		48c744241020000000	MOVQ $0x20, 0x10(SP)			
  0x44c13c		e8df60fbff		CALL runtime.memequal(SB)		
  0x44c141		0fb6442418		MOVZX 0x18(SP), AX			
  0x44c146		ebcc			JMP 0x44c114				
  0x44c148		488d4a10		LEAQ 0x10(DX), CX			
  0x44c14c		48890c24		MOVQ CX, 0(SP)				
  0x44c150		488d4810		LEAQ 0x10(AX), CX			
  0x44c154		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c159		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x44c162		e8b960fbff		CALL runtime.memequal(SB)		
  0x44c167		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44c16c		488b442438		MOVQ 0x38(SP), AX			
  0x44c171		488b542430		MOVQ 0x30(SP), DX			
  0x44c176		eb96			JMP 0x44c10e				
  0x44c178		31c9			XORL CX, CX				
  0x44c17a		eb92			JMP 0x44c10e				
  0x44c17c		e8ffb6ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c181		e94affffff		JMP type..eq.runtime.sudog(SB)		

TEXT type..hash.runtime.hchan(SB) <autogenerated>

  0x44c190		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c199		483b6110		CMPQ 0x10(CX), SP			
  0x44c19d		7668			JBE 0x44c207				
  0x44c19f		4883ec28		SUBQ $0x28, SP				
  0x44c1a3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c1a8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c1ad		488b442430		MOVQ 0x30(SP), AX			
  0x44c1b2		48890424		MOVQ AX, 0(SP)				
  0x44c1b6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c1bb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c1c0		48c74424101a000000	MOVQ $0x1a, 0x10(SP)			
  0x44c1c9		e8f2b0fbff		CALL runtime.memhash(SB)		
  0x44c1ce		488b442418		MOVQ 0x18(SP), AX			
  0x44c1d3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c1d8		4883c11c		ADDQ $0x1c, CX				
  0x44c1dc		48890c24		MOVQ CX, 0(SP)				
  0x44c1e0		4889442408		MOVQ AX, 0x8(SP)			
  0x44c1e5		48c744241044000000	MOVQ $0x44, 0x10(SP)			
  0x44c1ee		e8cdb0fbff		CALL runtime.memhash(SB)		
  0x44c1f3		488b442418		MOVQ 0x18(SP), AX			
  0x44c1f8		4889442440		MOVQ AX, 0x40(SP)			
  0x44c1fd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c202		4883c428		ADDQ $0x28, SP				
  0x44c206		c3			RET					
  0x44c207		e874b6ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c20c		eb82			JMP type..hash.runtime.hchan(SB)	

TEXT type..eq.runtime.hchan(SB) <autogenerated>

  0x44c210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c219		483b6110		CMPQ 0x10(CX), SP			
  0x44c21d		7676			JBE 0x44c295				
  0x44c21f		4883ec28		SUBQ $0x28, SP				
  0x44c223		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c228		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c22d		488b442430		MOVQ 0x30(SP), AX			
  0x44c232		48890424		MOVQ AX, 0(SP)				
  0x44c236		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c23b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c240		48c74424101a000000	MOVQ $0x1a, 0x10(SP)			
  0x44c249		e8d25ffbff		CALL runtime.memequal(SB)		
  0x44c24e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44c253		7510			JNE 0x44c265				
  0x44c255		31c0			XORL AX, AX				
  0x44c257		88442440		MOVB AL, 0x40(SP)			
  0x44c25b		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c260		4883c428		ADDQ $0x28, SP				
  0x44c264		c3			RET					
  0x44c265		488b442430		MOVQ 0x30(SP), AX			
  0x44c26a		4883c01c		ADDQ $0x1c, AX				
  0x44c26e		48890424		MOVQ AX, 0(SP)				
  0x44c272		488b442438		MOVQ 0x38(SP), AX			
  0x44c277		4883c01c		ADDQ $0x1c, AX				
  0x44c27b		4889442408		MOVQ AX, 0x8(SP)			
  0x44c280		48c744241044000000	MOVQ $0x44, 0x10(SP)			
  0x44c289		e8925ffbff		CALL runtime.memequal(SB)		
  0x44c28e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44c293		ebc2			JMP 0x44c257				
  0x44c295		e8e6b5ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c29a		e971ffffff		JMP type..eq.runtime.hchan(SB)		

TEXT type..hash.[6]string(SB) <autogenerated>

  0x44c2a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c2a9		483b6110		CMPQ 0x10(CX), SP			
  0x44c2ad		7658			JBE 0x44c307				
  0x44c2af		4883ec28		SUBQ $0x28, SP				
  0x44c2b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c2b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c2bd		31c0			XORL AX, AX				
  0x44c2bf		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c2c4		eb2c			JMP 0x44c2f2				
  0x44c2c6		4889442418		MOVQ AX, 0x18(SP)			
  0x44c2cb		48c1e004		SHLQ $0x4, AX				
  0x44c2cf		488b5c2430		MOVQ 0x30(SP), BX			
  0x44c2d4		4801d8			ADDQ BX, AX				
  0x44c2d7		48890424		MOVQ AX, 0(SP)				
  0x44c2db		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c2e0		e89b63fbff		CALL runtime.strhash(SB)		
  0x44c2e5		488b4c2410		MOVQ 0x10(SP), CX			
  0x44c2ea		488b442418		MOVQ 0x18(SP), AX			
  0x44c2ef		48ffc0			INCQ AX					
  0x44c2f2		4883f806		CMPQ $0x6, AX				
  0x44c2f6		7cce			JL 0x44c2c6				
  0x44c2f8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44c2fd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c302		4883c428		ADDQ $0x28, SP				
  0x44c306		c3			RET					
  0x44c307		e874b5ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c30c		eb92			JMP type..hash.[6]string(SB)		

TEXT type..eq.[6]string(SB) <autogenerated>

  0x44c310		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c319		483b6110		CMPQ 0x10(CX), SP			
  0x44c31d		0f8695000000		JBE 0x44c3b8				
  0x44c323		4883ec30		SUBQ $0x30, SP				
  0x44c327		48896c2428		MOVQ BP, 0x28(SP)			
  0x44c32c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44c331		488b442438		MOVQ 0x38(SP), AX			
  0x44c336		488b4c2440		MOVQ 0x40(SP), CX			
  0x44c33b		31d2			XORL DX, DX				
  0x44c33d		eb19			JMP 0x44c358				
  0x44c33f		488b5c2420		MOVQ 0x20(SP), BX			
  0x44c344		488d5301		LEAQ 0x1(BX), DX			
  0x44c348		488b5c2438		MOVQ 0x38(SP), BX			
  0x44c34d		488b742440		MOVQ 0x40(SP), SI			
  0x44c352		4889d8			MOVQ BX, AX				
  0x44c355		4889f1			MOVQ SI, CX				
  0x44c358		4883fa06		CMPQ $0x6, DX				
  0x44c35c		7d4b			JGE 0x44c3a9				
  0x44c35e		4889d3			MOVQ DX, BX				
  0x44c361		48c1e204		SHLQ $0x4, DX				
  0x44c365		488b340a		MOVQ 0(DX)(CX*1), SI			
  0x44c369		488b3c02		MOVQ 0(DX)(AX*1), DI			
  0x44c36d		4c8b441008		MOVQ 0x8(AX)(DX*1), R8			
  0x44c372		4801ca			ADDQ CX, DX				
  0x44c375		4c394208		CMPQ R8, 0x8(DX)			
  0x44c379		751f			JNE 0x44c39a				
  0x44c37b		48895c2420		MOVQ BX, 0x20(SP)			
  0x44c380		48893c24		MOVQ DI, 0(SP)				
  0x44c384		4889742408		MOVQ SI, 0x8(SP)			
  0x44c389		4c89442410		MOVQ R8, 0x10(SP)			
  0x44c38e		e88d5efbff		CALL runtime.memequal(SB)		
  0x44c393		807c241800		CMPB $0x0, 0x18(SP)			
  0x44c398		75a5			JNE 0x44c33f				
  0x44c39a		c644244800		MOVB $0x0, 0x48(SP)			
  0x44c39f		488b6c2428		MOVQ 0x28(SP), BP			
  0x44c3a4		4883c430		ADDQ $0x30, SP				
  0x44c3a8		c3			RET					
  0x44c3a9		c644244801		MOVB $0x1, 0x48(SP)			
  0x44c3ae		488b6c2428		MOVQ 0x28(SP), BP			
  0x44c3b3		4883c430		ADDQ $0x30, SP				
  0x44c3b7		c3			RET					
  0x44c3b8		e8c3b4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c3bd		e94effffff		JMP type..eq.[6]string(SB)		

TEXT type..hash.[9]string(SB) <autogenerated>

  0x44c3d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c3d9		483b6110		CMPQ 0x10(CX), SP			
  0x44c3dd		7658			JBE 0x44c437				
  0x44c3df		4883ec28		SUBQ $0x28, SP				
  0x44c3e3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c3e8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c3ed		31c0			XORL AX, AX				
  0x44c3ef		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c3f4		eb2c			JMP 0x44c422				
  0x44c3f6		4889442418		MOVQ AX, 0x18(SP)			
  0x44c3fb		48c1e004		SHLQ $0x4, AX				
  0x44c3ff		488b5c2430		MOVQ 0x30(SP), BX			
  0x44c404		4801d8			ADDQ BX, AX				
  0x44c407		48890424		MOVQ AX, 0(SP)				
  0x44c40b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c410		e86b62fbff		CALL runtime.strhash(SB)		
  0x44c415		488b4c2410		MOVQ 0x10(SP), CX			
  0x44c41a		488b442418		MOVQ 0x18(SP), AX			
  0x44c41f		48ffc0			INCQ AX					
  0x44c422		4883f809		CMPQ $0x9, AX				
  0x44c426		7cce			JL 0x44c3f6				
  0x44c428		48894c2440		MOVQ CX, 0x40(SP)			
  0x44c42d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c432		4883c428		ADDQ $0x28, SP				
  0x44c436		c3			RET					
  0x44c437		e844b4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c43c		eb92			JMP type..hash.[9]string(SB)		

TEXT type..eq.[9]string(SB) <autogenerated>

  0x44c440		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c449		483b6110		CMPQ 0x10(CX), SP			
  0x44c44d		0f8695000000		JBE 0x44c4e8				
  0x44c453		4883ec30		SUBQ $0x30, SP				
  0x44c457		48896c2428		MOVQ BP, 0x28(SP)			
  0x44c45c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44c461		488b442438		MOVQ 0x38(SP), AX			
  0x44c466		488b4c2440		MOVQ 0x40(SP), CX			
  0x44c46b		31d2			XORL DX, DX				
  0x44c46d		eb19			JMP 0x44c488				
  0x44c46f		488b5c2420		MOVQ 0x20(SP), BX			
  0x44c474		488d5301		LEAQ 0x1(BX), DX			
  0x44c478		488b5c2438		MOVQ 0x38(SP), BX			
  0x44c47d		488b742440		MOVQ 0x40(SP), SI			
  0x44c482		4889d8			MOVQ BX, AX				
  0x44c485		4889f1			MOVQ SI, CX				
  0x44c488		4883fa09		CMPQ $0x9, DX				
  0x44c48c		7d4b			JGE 0x44c4d9				
  0x44c48e		4889d3			MOVQ DX, BX				
  0x44c491		48c1e204		SHLQ $0x4, DX				
  0x44c495		488b340a		MOVQ 0(DX)(CX*1), SI			
  0x44c499		488b3c02		MOVQ 0(DX)(AX*1), DI			
  0x44c49d		4c8b441008		MOVQ 0x8(AX)(DX*1), R8			
  0x44c4a2		4801ca			ADDQ CX, DX				
  0x44c4a5		4c394208		CMPQ R8, 0x8(DX)			
  0x44c4a9		751f			JNE 0x44c4ca				
  0x44c4ab		48895c2420		MOVQ BX, 0x20(SP)			
  0x44c4b0		48893c24		MOVQ DI, 0(SP)				
  0x44c4b4		4889742408		MOVQ SI, 0x8(SP)			
  0x44c4b9		4c89442410		MOVQ R8, 0x10(SP)			
  0x44c4be		e85d5dfbff		CALL runtime.memequal(SB)		
  0x44c4c3		807c241800		CMPB $0x0, 0x18(SP)			
  0x44c4c8		75a5			JNE 0x44c46f				
  0x44c4ca		c644244800		MOVB $0x0, 0x48(SP)			
  0x44c4cf		488b6c2428		MOVQ 0x28(SP), BP			
  0x44c4d4		4883c430		ADDQ $0x30, SP				
  0x44c4d8		c3			RET					
  0x44c4d9		c644244801		MOVB $0x1, 0x48(SP)			
  0x44c4de		488b6c2428		MOVQ 0x28(SP), BP			
  0x44c4e3		4883c430		ADDQ $0x30, SP				
  0x44c4e7		c3			RET					
  0x44c4e8		e893b3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c4ed		e94effffff		JMP type..eq.[9]string(SB)		

TEXT type..hash.runtime.bitvector(SB) <autogenerated>

  0x44c500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c509		483b6110		CMPQ 0x10(CX), SP			
  0x44c50d		7668			JBE 0x44c577				
  0x44c50f		4883ec28		SUBQ $0x28, SP				
  0x44c513		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c518		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c51d		488b442430		MOVQ 0x30(SP), AX			
  0x44c522		48890424		MOVQ AX, 0(SP)				
  0x44c526		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c52b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c530		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44c539		e882adfbff		CALL runtime.memhash(SB)		
  0x44c53e		488b442418		MOVQ 0x18(SP), AX			
  0x44c543		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c548		4883c108		ADDQ $0x8, CX				
  0x44c54c		48890c24		MOVQ CX, 0(SP)				
  0x44c550		4889442408		MOVQ AX, 0x8(SP)			
  0x44c555		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44c55e		e85dadfbff		CALL runtime.memhash(SB)		
  0x44c563		488b442418		MOVQ 0x18(SP), AX			
  0x44c568		4889442440		MOVQ AX, 0x40(SP)			
  0x44c56d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c572		4883c428		ADDQ $0x28, SP				
  0x44c576		c3			RET					
  0x44c577		e804b3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c57c		eb82			JMP type..hash.runtime.bitvector(SB)	

TEXT type..eq.runtime.bitvector(SB) <autogenerated>

  0x44c580		488b442410		MOVQ 0x10(SP), AX	
  0x44c585		8b08			MOVL 0(AX), CX		
  0x44c587		488b542408		MOVQ 0x8(SP), DX	
  0x44c58c		390a			CMPL CX, 0(DX)		
  0x44c58e		7510			JNE 0x44c5a0		
  0x44c590		488b4008		MOVQ 0x8(AX), AX	
  0x44c594		48394208		CMPQ AX, 0x8(DX)	
  0x44c598		0f94c0			SETE AL			
  0x44c59b		88442418		MOVB AL, 0x18(SP)	
  0x44c59f		c3			RET			
  0x44c5a0		31c0			XORL AX, AX		
  0x44c5a2		ebf7			JMP 0x44c59b		

TEXT type..hash.runtime.itab(SB) <autogenerated>

  0x44c5b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c5b9		483b6110		CMPQ 0x10(CX), SP			
  0x44c5bd		7668			JBE 0x44c627				
  0x44c5bf		4883ec28		SUBQ $0x28, SP				
  0x44c5c3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c5c8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c5cd		488b442430		MOVQ 0x30(SP), AX			
  0x44c5d2		48890424		MOVQ AX, 0(SP)				
  0x44c5d6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c5db		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c5e0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44c5e9		e8d2acfbff		CALL runtime.memhash(SB)		
  0x44c5ee		488b442418		MOVQ 0x18(SP), AX			
  0x44c5f3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c5f8		4883c118		ADDQ $0x18, CX				
  0x44c5fc		48890c24		MOVQ CX, 0(SP)				
  0x44c600		4889442408		MOVQ AX, 0x8(SP)			
  0x44c605		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44c60e		e8adacfbff		CALL runtime.memhash(SB)		
  0x44c613		488b442418		MOVQ 0x18(SP), AX			
  0x44c618		4889442440		MOVQ AX, 0x40(SP)			
  0x44c61d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c622		4883c428		ADDQ $0x28, SP				
  0x44c626		c3			RET					
  0x44c627		e854b2ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c62c		eb82			JMP type..hash.runtime.itab(SB)		

TEXT type..eq.runtime.itab(SB) <autogenerated>

  0x44c630		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c639		483b6110		CMPQ 0x10(CX), SP			
  0x44c63d		765d			JBE 0x44c69c				
  0x44c63f		4883ec28		SUBQ $0x28, SP				
  0x44c643		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c648		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c64d		488b442430		MOVQ 0x30(SP), AX			
  0x44c652		48890424		MOVQ AX, 0(SP)				
  0x44c656		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c65b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c660		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44c669		e8b25bfbff		CALL runtime.memequal(SB)		
  0x44c66e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44c673		7423			JE 0x44c698				
  0x44c675		488b442438		MOVQ 0x38(SP), AX			
  0x44c67a		488b4018		MOVQ 0x18(AX), AX			
  0x44c67e		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c683		48394118		CMPQ AX, 0x18(CX)			
  0x44c687		0f94c0			SETE AL					
  0x44c68a		88442440		MOVB AL, 0x40(SP)			
  0x44c68e		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c693		4883c428		ADDQ $0x28, SP				
  0x44c697		c3			RET					
  0x44c698		31c0			XORL AX, AX				
  0x44c69a		ebee			JMP 0x44c68a				
  0x44c69c		e8dfb1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c6a1		eb8d			JMP type..eq.runtime.itab(SB)		

TEXT type..hash.runtime._func(SB) <autogenerated>

  0x44c6b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c6b9		483b6110		CMPQ 0x10(CX), SP			
  0x44c6bd		7668			JBE 0x44c727				
  0x44c6bf		4883ec28		SUBQ $0x28, SP				
  0x44c6c3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c6c8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c6cd		488b442430		MOVQ 0x30(SP), AX			
  0x44c6d2		48890424		MOVQ AX, 0(SP)				
  0x44c6d6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c6db		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c6e0		48c744241025000000	MOVQ $0x25, 0x10(SP)			
  0x44c6e9		e8d2abfbff		CALL runtime.memhash(SB)		
  0x44c6ee		488b442418		MOVQ 0x18(SP), AX			
  0x44c6f3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c6f8		4883c127		ADDQ $0x27, CX				
  0x44c6fc		48890c24		MOVQ CX, 0(SP)				
  0x44c700		4889442408		MOVQ AX, 0x8(SP)			
  0x44c705		48c744241001000000	MOVQ $0x1, 0x10(SP)			
  0x44c70e		e8adabfbff		CALL runtime.memhash(SB)		
  0x44c713		488b442418		MOVQ 0x18(SP), AX			
  0x44c718		4889442440		MOVQ AX, 0x40(SP)			
  0x44c71d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c722		4883c428		ADDQ $0x28, SP				
  0x44c726		c3			RET					
  0x44c727		e854b1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c72c		eb82			JMP type..hash.runtime._func(SB)	

TEXT type..eq.runtime._func(SB) <autogenerated>

  0x44c730		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c739		483b6110		CMPQ 0x10(CX), SP			
  0x44c73d		765c			JBE 0x44c79b				
  0x44c73f		4883ec28		SUBQ $0x28, SP				
  0x44c743		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c748		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c74d		488b442430		MOVQ 0x30(SP), AX			
  0x44c752		48890424		MOVQ AX, 0(SP)				
  0x44c756		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c75b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c760		48c744241025000000	MOVQ $0x25, 0x10(SP)			
  0x44c769		e8b25afbff		CALL runtime.memequal(SB)		
  0x44c76e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44c773		7422			JE 0x44c797				
  0x44c775		488b442438		MOVQ 0x38(SP), AX			
  0x44c77a		0fb64027		MOVZX 0x27(AX), AX			
  0x44c77e		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c783		384127			CMPB AL, 0x27(CX)			
  0x44c786		0f94c0			SETE AL					
  0x44c789		88442440		MOVB AL, 0x40(SP)			
  0x44c78d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c792		4883c428		ADDQ $0x28, SP				
  0x44c796		c3			RET					
  0x44c797		31c0			XORL AX, AX				
  0x44c799		ebee			JMP 0x44c789				
  0x44c79b		e8e0b0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c7a0		eb8e			JMP type..eq.runtime._func(SB)		

TEXT type..hash.runtime.modulehash(SB) <autogenerated>

  0x44c7b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c7b9		483b6110		CMPQ 0x10(CX), SP			
  0x44c7bd		767b			JBE 0x44c83a				
  0x44c7bf		4883ec28		SUBQ $0x28, SP				
  0x44c7c3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c7c8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c7cd		488b442430		MOVQ 0x30(SP), AX			
  0x44c7d2		48890424		MOVQ AX, 0(SP)				
  0x44c7d6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44c7db		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c7e0		e89b5efbff		CALL runtime.strhash(SB)		
  0x44c7e5		488b442410		MOVQ 0x10(SP), AX			
  0x44c7ea		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c7ef		488d5110		LEAQ 0x10(CX), DX			
  0x44c7f3		48891424		MOVQ DX, 0(SP)				
  0x44c7f7		4889442408		MOVQ AX, 0x8(SP)			
  0x44c7fc		e87f5efbff		CALL runtime.strhash(SB)		
  0x44c801		488b442410		MOVQ 0x10(SP), AX			
  0x44c806		488b4c2430		MOVQ 0x30(SP), CX			
  0x44c80b		4883c120		ADDQ $0x20, CX				
  0x44c80f		48890c24		MOVQ CX, 0(SP)				
  0x44c813		4889442408		MOVQ AX, 0x8(SP)			
  0x44c818		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44c821		e89aaafbff		CALL runtime.memhash(SB)		
  0x44c826		488b442418		MOVQ 0x18(SP), AX			
  0x44c82b		4889442440		MOVQ AX, 0x40(SP)			
  0x44c830		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c835		4883c428		ADDQ $0x28, SP				
  0x44c839		c3			RET					
  0x44c83a		e841b0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44c83f		e96cffffff		JMP type..hash.runtime.modulehash(SB)	

TEXT type..eq.runtime.modulehash(SB) <autogenerated>

  0x44c850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c859		483b6110		CMPQ 0x10(CX), SP			
  0x44c85d		0f86b2000000		JBE 0x44c915				
  0x44c863		4883ec28		SUBQ $0x28, SP				
  0x44c867		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c86c		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c871		488b442430		MOVQ 0x30(SP), AX			
  0x44c876		488b08			MOVQ 0(AX), CX				
  0x44c879		488b5008		MOVQ 0x8(AX), DX			
  0x44c87d		488b5c2438		MOVQ 0x38(SP), BX			
  0x44c882		488b33			MOVQ 0(BX), SI				
  0x44c885		48395308		CMPQ DX, 0x8(BX)			
  0x44c889		7463			JE 0x44c8ee				
  0x44c88b		31c9			XORL CX, CX				
  0x44c88d		84c9			TESTL CL, CL				
  0x44c88f		7459			JE 0x44c8ea				
  0x44c891		488b4b10		MOVQ 0x10(BX), CX			
  0x44c895		488b5018		MOVQ 0x18(AX), DX			
  0x44c899		488b7010		MOVQ 0x10(AX), SI			
  0x44c89d		48395318		CMPQ DX, 0x18(BX)			
  0x44c8a1		7423			JE 0x44c8c6				
  0x44c8a3		31c9			XORL CX, CX				
  0x44c8a5		84c9			TESTL CL, CL				
  0x44c8a7		7419			JE 0x44c8c2				
  0x44c8a9		488b4b20		MOVQ 0x20(BX), CX			
  0x44c8ad		48394820		CMPQ CX, 0x20(AX)			
  0x44c8b1		0f94c0			SETE AL					
  0x44c8b4		88442440		MOVB AL, 0x40(SP)			
  0x44c8b8		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c8bd		4883c428		ADDQ $0x28, SP				
  0x44c8c1		c3			RET					
  0x44c8c2		31c0			XORL AX, AX				
  0x44c8c4		ebee			JMP 0x44c8b4				
  0x44c8c6		48893424		MOVQ SI, 0(SP)				
  0x44c8ca		48894c2408		MOVQ CX, 0x8(SP)			
  0x44c8cf		4889542410		MOVQ DX, 0x10(SP)			
  0x44c8d4		e84759fbff		CALL runtime.memequal(SB)		
  0x44c8d9		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44c8de		488b442430		MOVQ 0x30(SP), AX			
  0x44c8e3		488b5c2438		MOVQ 0x38(SP), BX			
  0x44c8e8		ebbb			JMP 0x44c8a5				
  0x44c8ea		31c9			XORL CX, CX				
  0x44c8ec		ebb7			JMP 0x44c8a5				
  0x44c8ee		48890c24		MOVQ CX, 0(SP)				
  0x44c8f2		4889742408		MOVQ SI, 0x8(SP)			
  0x44c8f7		4889542410		MOVQ DX, 0x10(SP)			
  0x44c8fc		e81f59fbff		CALL runtime.memequal(SB)		
  0x44c901		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44c906		488b442430		MOVQ 0x30(SP), AX			
  0x44c90b		488b5c2438		MOVQ 0x38(SP), BX			
  0x44c910		e978ffffff		JMP 0x44c88d				
  0x44c915		e866afffff		CALL runtime.morestack_noctxt(SB)	
  0x44c91a		e931ffffff		JMP type..eq.runtime.modulehash(SB)	

TEXT type..hash.runtime.treapNode(SB) <autogenerated>

  0x44c920		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c929		483b6110		CMPQ 0x10(CX), SP			
  0x44c92d		7643			JBE 0x44c972				
  0x44c92f		4883ec28		SUBQ $0x28, SP				
  0x44c933		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c938		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c93d		488b442430		MOVQ 0x30(SP), AX			
  0x44c942		48890424		MOVQ AX, 0(SP)				
  0x44c946		488b442438		MOVQ 0x38(SP), AX			
  0x44c94b		4889442408		MOVQ AX, 0x8(SP)			
  0x44c950		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x44c959		e862a9fbff		CALL runtime.memhash(SB)		
  0x44c95e		488b442418		MOVQ 0x18(SP), AX			
  0x44c963		4889442440		MOVQ AX, 0x40(SP)			
  0x44c968		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c96d		4883c428		ADDQ $0x28, SP				
  0x44c971		c3			RET					
  0x44c972		e809afffff		CALL runtime.morestack_noctxt(SB)	
  0x44c977		eba7			JMP type..hash.runtime.treapNode(SB)	

TEXT type..eq.runtime.treapNode(SB) <autogenerated>

  0x44c980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c989		483b6110		CMPQ 0x10(CX), SP			
  0x44c98d		7642			JBE 0x44c9d1				
  0x44c98f		4883ec28		SUBQ $0x28, SP				
  0x44c993		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c998		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c99d		488b442430		MOVQ 0x30(SP), AX			
  0x44c9a2		48890424		MOVQ AX, 0(SP)				
  0x44c9a6		488b442438		MOVQ 0x38(SP), AX			
  0x44c9ab		4889442408		MOVQ AX, 0x8(SP)			
  0x44c9b0		48c74424102c000000	MOVQ $0x2c, 0x10(SP)			
  0x44c9b9		e86258fbff		CALL runtime.memequal(SB)		
  0x44c9be		0fb6442418		MOVZX 0x18(SP), AX			
  0x44c9c3		88442440		MOVB AL, 0x40(SP)			
  0x44c9c7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44c9cc		4883c428		ADDQ $0x28, SP				
  0x44c9d0		c3			RET					
  0x44c9d1		e8aaaeffff		CALL runtime.morestack_noctxt(SB)	
  0x44c9d6		eba8			JMP type..eq.runtime.treapNode(SB)	

TEXT type..hash.runtime.gcSweepBuf(SB) <autogenerated>

  0x44c9e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44c9e9		483b6110		CMPQ 0x10(CX), SP			
  0x44c9ed		7643			JBE 0x44ca32				
  0x44c9ef		4883ec28		SUBQ $0x28, SP				
  0x44c9f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44c9f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44c9fd		488b442430		MOVQ 0x30(SP), AX			
  0x44ca02		48890424		MOVQ AX, 0(SP)				
  0x44ca06		488b442438		MOVQ 0x38(SP), AX			
  0x44ca0b		4889442408		MOVQ AX, 0x8(SP)			
  0x44ca10		48c744241024000000	MOVQ $0x24, 0x10(SP)			
  0x44ca19		e8a2a8fbff		CALL runtime.memhash(SB)		
  0x44ca1e		488b442418		MOVQ 0x18(SP), AX			
  0x44ca23		4889442440		MOVQ AX, 0x40(SP)			
  0x44ca28		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ca2d		4883c428		ADDQ $0x28, SP				
  0x44ca31		c3			RET					
  0x44ca32		e849aeffff		CALL runtime.morestack_noctxt(SB)	
  0x44ca37		eba7			JMP type..hash.runtime.gcSweepBuf(SB)	

TEXT type..eq.runtime.gcSweepBuf(SB) <autogenerated>

  0x44ca40		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ca49		483b6110		CMPQ 0x10(CX), SP			
  0x44ca4d		7642			JBE 0x44ca91				
  0x44ca4f		4883ec28		SUBQ $0x28, SP				
  0x44ca53		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ca58		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ca5d		488b442430		MOVQ 0x30(SP), AX			
  0x44ca62		48890424		MOVQ AX, 0(SP)				
  0x44ca66		488b442438		MOVQ 0x38(SP), AX			
  0x44ca6b		4889442408		MOVQ AX, 0x8(SP)			
  0x44ca70		48c744241024000000	MOVQ $0x24, 0x10(SP)			
  0x44ca79		e8a257fbff		CALL runtime.memequal(SB)		
  0x44ca7e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44ca83		88442440		MOVB AL, 0x40(SP)			
  0x44ca87		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ca8c		4883c428		ADDQ $0x28, SP				
  0x44ca90		c3			RET					
  0x44ca91		e8eaadffff		CALL runtime.morestack_noctxt(SB)	
  0x44ca96		eba8			JMP type..eq.runtime.gcSweepBuf(SB)	

TEXT type..hash.[2]runtime.gcSweepBuf(SB) <autogenerated>

  0x44caa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44caa9		483b6110		CMPQ 0x10(CX), SP				
  0x44caad		7659			JBE 0x44cb08					
  0x44caaf		4883ec28		SUBQ $0x28, SP					
  0x44cab3		48896c2420		MOVQ BP, 0x20(SP)				
  0x44cab8		488d6c2420		LEAQ 0x20(SP), BP				
  0x44cabd		31c0			XORL AX, AX					
  0x44cabf		488b4c2438		MOVQ 0x38(SP), CX				
  0x44cac4		eb2d			JMP 0x44caf3					
  0x44cac6		4889442418		MOVQ AX, 0x18(SP)				
  0x44cacb		488d1480		LEAQ 0(AX)(AX*4), DX				
  0x44cacf		488b5c2430		MOVQ 0x30(SP), BX				
  0x44cad4		488d14d3		LEAQ 0(BX)(DX*8), DX				
  0x44cad8		48891424		MOVQ DX, 0(SP)					
  0x44cadc		48894c2408		MOVQ CX, 0x8(SP)				
  0x44cae1		e8fafeffff		CALL type..hash.runtime.gcSweepBuf(SB)		
  0x44cae6		488b4c2410		MOVQ 0x10(SP), CX				
  0x44caeb		488b442418		MOVQ 0x18(SP), AX				
  0x44caf0		48ffc0			INCQ AX						
  0x44caf3		4883f802		CMPQ $0x2, AX					
  0x44caf7		7ccd			JL 0x44cac6					
  0x44caf9		48894c2440		MOVQ CX, 0x40(SP)				
  0x44cafe		488b6c2420		MOVQ 0x20(SP), BP				
  0x44cb03		4883c428		ADDQ $0x28, SP					
  0x44cb07		c3			RET						
  0x44cb08		e873adffff		CALL runtime.morestack_noctxt(SB)		
  0x44cb0d		eb91			JMP type..hash.[2]runtime.gcSweepBuf(SB)	

TEXT type..eq.[2]runtime.gcSweepBuf(SB) <autogenerated>

  0x44cb10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44cb19		483b6110		CMPQ 0x10(CX), SP			
  0x44cb1d		766f			JBE 0x44cb8e				
  0x44cb1f		4883ec28		SUBQ $0x28, SP				
  0x44cb23		48896c2420		MOVQ BP, 0x20(SP)			
  0x44cb28		488d6c2420		LEAQ 0x20(SP), BP			
  0x44cb2d		31c0			XORL AX, AX				
  0x44cb2f		eb09			JMP 0x44cb3a				
  0x44cb31		488b4c2418		MOVQ 0x18(SP), CX			
  0x44cb36		488d4101		LEAQ 0x1(CX), AX			
  0x44cb3a		4883f802		CMPQ $0x2, AX				
  0x44cb3e		7d3f			JGE 0x44cb7f				
  0x44cb40		4889442418		MOVQ AX, 0x18(SP)			
  0x44cb45		488d0c80		LEAQ 0(AX)(AX*4), CX			
  0x44cb49		488b542430		MOVQ 0x30(SP), DX			
  0x44cb4e		488d1cca		LEAQ 0(DX)(CX*8), BX			
  0x44cb52		48891c24		MOVQ BX, 0(SP)				
  0x44cb56		488b5c2438		MOVQ 0x38(SP), BX			
  0x44cb5b		488d0ccb		LEAQ 0(BX)(CX*8), CX			
  0x44cb5f		48894c2408		MOVQ CX, 0x8(SP)			
  0x44cb64		e8d7feffff		CALL type..eq.runtime.gcSweepBuf(SB)	
  0x44cb69		807c241000		CMPB $0x0, 0x10(SP)			
  0x44cb6e		75c1			JNE 0x44cb31				
  0x44cb70		c644244000		MOVB $0x0, 0x40(SP)			
  0x44cb75		488b6c2420		MOVQ 0x20(SP), BP			
  0x44cb7a		4883c428		ADDQ $0x28, SP				
  0x44cb7e		c3			RET					
  0x44cb7f		c644244001		MOVB $0x1, 0x40(SP)			
  0x44cb84		488b6c2420		MOVQ 0x20(SP), BP			
  0x44cb89		4883c428		ADDQ $0x28, SP				
  0x44cb8d		c3			RET					
  0x44cb8e		e8edacffff		CALL runtime.morestack_noctxt(SB)	
  0x44cb93		e978ffffff		JMP type..eq.[2]runtime.gcSweepBuf(SB)	

TEXT type..hash.runtime.arenaHint(SB) <autogenerated>

  0x44cba0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44cba9		483b6110		CMPQ 0x10(CX), SP			
  0x44cbad		7668			JBE 0x44cc17				
  0x44cbaf		4883ec28		SUBQ $0x28, SP				
  0x44cbb3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44cbb8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44cbbd		488b442430		MOVQ 0x30(SP), AX			
  0x44cbc2		48890424		MOVQ AX, 0(SP)				
  0x44cbc6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44cbcb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44cbd0		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44cbd9		e8e2a6fbff		CALL runtime.memhash(SB)		
  0x44cbde		488b442418		MOVQ 0x18(SP), AX			
  0x44cbe3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44cbe8		4883c110		ADDQ $0x10, CX				
  0x44cbec		48890c24		MOVQ CX, 0(SP)				
  0x44cbf0		4889442408		MOVQ AX, 0x8(SP)			
  0x44cbf5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44cbfe		e8bda6fbff		CALL runtime.memhash(SB)		
  0x44cc03		488b442418		MOVQ 0x18(SP), AX			
  0x44cc08		4889442440		MOVQ AX, 0x40(SP)			
  0x44cc0d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44cc12		4883c428		ADDQ $0x28, SP				
  0x44cc16		c3			RET					
  0x44cc17		e864acffff		CALL runtime.morestack_noctxt(SB)	
  0x44cc1c		eb82			JMP type..hash.runtime.arenaHint(SB)	

TEXT type..eq.runtime.arenaHint(SB) <autogenerated>

  0x44cc20		488b442410		MOVQ 0x10(SP), AX	
  0x44cc25		488b08			MOVQ 0(AX), CX		
  0x44cc28		488b542408		MOVQ 0x8(SP), DX	
  0x44cc2d		48390a			CMPQ CX, 0(DX)		
  0x44cc30		751d			JNE 0x44cc4f		
  0x44cc32		0fb64808		MOVZX 0x8(AX), CX	
  0x44cc36		384a08			CMPB CL, 0x8(DX)	
  0x44cc39		7510			JNE 0x44cc4b		
  0x44cc3b		488b4010		MOVQ 0x10(AX), AX	
  0x44cc3f		48394210		CMPQ AX, 0x10(DX)	
  0x44cc43		0f94c0			SETE AL			
  0x44cc46		88442418		MOVB AL, 0x18(SP)	
  0x44cc4a		c3			RET			
  0x44cc4b		31c0			XORL AX, AX		
  0x44cc4d		ebf7			JMP 0x44cc46		
  0x44cc4f		31c0			XORL AX, AX		
  0x44cc51		ebf3			JMP 0x44cc46		

TEXT type..hash.runtime.mcentral(SB) <autogenerated>

  0x44cc60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44cc69		483b6110		CMPQ 0x10(CX), SP			
  0x44cc6d		7668			JBE 0x44ccd7				
  0x44cc6f		4883ec28		SUBQ $0x28, SP				
  0x44cc73		48896c2420		MOVQ BP, 0x20(SP)			
  0x44cc78		488d6c2420		LEAQ 0x20(SP), BP			
  0x44cc7d		488b442430		MOVQ 0x30(SP), AX			
  0x44cc82		48890424		MOVQ AX, 0(SP)				
  0x44cc86		488b4c2438		MOVQ 0x38(SP), CX			
  0x44cc8b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44cc90		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44cc99		e822a6fbff		CALL runtime.memhash(SB)		
  0x44cc9e		488b442418		MOVQ 0x18(SP), AX			
  0x44cca3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44cca8		4883c110		ADDQ $0x10, CX				
  0x44ccac		48890c24		MOVQ CX, 0(SP)				
  0x44ccb0		4889442408		MOVQ AX, 0x8(SP)			
  0x44ccb5		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x44ccbe		e8fda5fbff		CALL runtime.memhash(SB)		
  0x44ccc3		488b442418		MOVQ 0x18(SP), AX			
  0x44ccc8		4889442440		MOVQ AX, 0x40(SP)			
  0x44cccd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ccd2		4883c428		ADDQ $0x28, SP				
  0x44ccd6		c3			RET					
  0x44ccd7		e8a4abffff		CALL runtime.morestack_noctxt(SB)	
  0x44ccdc		eb82			JMP type..hash.runtime.mcentral(SB)	

TEXT type..eq.runtime.mcentral(SB) <autogenerated>

  0x44cce0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44cce9		483b6110		CMPQ 0x10(CX), SP			
  0x44cced		7663			JBE 0x44cd52				
  0x44ccef		4883ec28		SUBQ $0x28, SP				
  0x44ccf3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ccf8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ccfd		488b442438		MOVQ 0x38(SP), AX			
  0x44cd02		488b08			MOVQ 0(AX), CX				
  0x44cd05		488b542430		MOVQ 0x30(SP), DX			
  0x44cd0a		48390a			CMPQ CX, 0(DX)				
  0x44cd0d		753f			JNE 0x44cd4e				
  0x44cd0f		0fb64808		MOVZX 0x8(AX), CX			
  0x44cd13		384a08			CMPB CL, 0x8(DX)			
  0x44cd16		7410			JE 0x44cd28				
  0x44cd18		31c0			XORL AX, AX				
  0x44cd1a		88442440		MOVB AL, 0x40(SP)			
  0x44cd1e		488b6c2420		MOVQ 0x20(SP), BP			
  0x44cd23		4883c428		ADDQ $0x28, SP				
  0x44cd27		c3			RET					
  0x44cd28		488d4a10		LEAQ 0x10(DX), CX			
  0x44cd2c		48890c24		MOVQ CX, 0(SP)				
  0x44cd30		4883c010		ADDQ $0x10, AX				
  0x44cd34		4889442408		MOVQ AX, 0x8(SP)			
  0x44cd39		48c744241028000000	MOVQ $0x28, 0x10(SP)			
  0x44cd42		e8d954fbff		CALL runtime.memequal(SB)		
  0x44cd47		0fb6442418		MOVZX 0x18(SP), AX			
  0x44cd4c		ebcc			JMP 0x44cd1a				
  0x44cd4e		31c0			XORL AX, AX				
  0x44cd50		ebc8			JMP 0x44cd1a				
  0x44cd52		e829abffff		CALL runtime.morestack_noctxt(SB)	
  0x44cd57		eb87			JMP type..eq.runtime.mcentral(SB)	

TEXT type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x44cd60		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44cd69		483b6110		CMPQ 0x10(CX), SP									
  0x44cd6d		765f			JBE 0x44cdce										
  0x44cd6f		4883ec28		SUBQ $0x28, SP										
  0x44cd73		48896c2420		MOVQ BP, 0x20(SP)									
  0x44cd78		488d6c2420		LEAQ 0x20(SP), BP									
  0x44cd7d		488b442430		MOVQ 0x30(SP), AX									
  0x44cd82		48890424		MOVQ AX, 0(SP)										
  0x44cd86		488b4c2438		MOVQ 0x38(SP), CX									
  0x44cd8b		48894c2408		MOVQ CX, 0x8(SP)									
  0x44cd90		e8cbfeffff		CALL type..hash.runtime.mcentral(SB)							
  0x44cd95		488b442410		MOVQ 0x10(SP), AX									
  0x44cd9a		488b4c2430		MOVQ 0x30(SP), CX									
  0x44cd9f		4883c138		ADDQ $0x38, CX										
  0x44cda3		48890c24		MOVQ CX, 0(SP)										
  0x44cda7		4889442408		MOVQ AX, 0x8(SP)									
  0x44cdac		48c744241008000000	MOVQ $0x8, 0x10(SP)									
  0x44cdb5		e806a5fbff		CALL runtime.memhash(SB)								
  0x44cdba		488b442418		MOVQ 0x18(SP), AX									
  0x44cdbf		4889442440		MOVQ AX, 0x40(SP)									
  0x44cdc4		488b6c2420		MOVQ 0x20(SP), BP									
  0x44cdc9		4883c428		ADDQ $0x28, SP										
  0x44cdcd		c3			RET											
  0x44cdce		e8adaaffff		CALL runtime.morestack_noctxt(SB)							
  0x44cdd3		eb8b			JMP type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x44cde0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44cde9		483b6110		CMPQ 0x10(CX), SP									
  0x44cded		7654			JBE 0x44ce43										
  0x44cdef		4883ec20		SUBQ $0x20, SP										
  0x44cdf3		48896c2418		MOVQ BP, 0x18(SP)									
  0x44cdf8		488d6c2418		LEAQ 0x18(SP), BP									
  0x44cdfd		488b442428		MOVQ 0x28(SP), AX									
  0x44ce02		48890424		MOVQ AX, 0(SP)										
  0x44ce06		488b4c2430		MOVQ 0x30(SP), CX									
  0x44ce0b		48894c2408		MOVQ CX, 0x8(SP)									
  0x44ce10		e8cbfeffff		CALL type..eq.runtime.mcentral(SB)							
  0x44ce15		807c241000		CMPB $0x0, 0x10(SP)									
  0x44ce1a		7423			JE 0x44ce3f										
  0x44ce1c		488b442430		MOVQ 0x30(SP), AX									
  0x44ce21		488b4038		MOVQ 0x38(AX), AX									
  0x44ce25		488b4c2428		MOVQ 0x28(SP), CX									
  0x44ce2a		48394138		CMPQ AX, 0x38(CX)									
  0x44ce2e		0f94c0			SETE AL											
  0x44ce31		88442438		MOVB AL, 0x38(SP)									
  0x44ce35		488b6c2418		MOVQ 0x18(SP), BP									
  0x44ce3a		4883c420		ADDQ $0x20, SP										
  0x44ce3e		c3			RET											
  0x44ce3f		31c0			XORL AX, AX										
  0x44ce41		ebee			JMP 0x44ce31										
  0x44ce43		e838aaffff		CALL runtime.morestack_noctxt(SB)							
  0x44ce48		eb96			JMP type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x44ce50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x44ce59		483b6110		CMPQ 0x10(CX), SP										
  0x44ce5d		765a			JBE 0x44ceb9											
  0x44ce5f		4883ec28		SUBQ $0x28, SP											
  0x44ce63		48896c2420		MOVQ BP, 0x20(SP)										
  0x44ce68		488d6c2420		LEAQ 0x20(SP), BP										
  0x44ce6d		31c0			XORL AX, AX											
  0x44ce6f		488b4c2438		MOVQ 0x38(SP), CX										
  0x44ce74		eb2c			JMP 0x44cea2											
  0x44ce76		4889442418		MOVQ AX, 0x18(SP)										
  0x44ce7b		48c1e006		SHLQ $0x6, AX											
  0x44ce7f		488b5c2430		MOVQ 0x30(SP), BX										
  0x44ce84		4801d8			ADDQ BX, AX											
  0x44ce87		48890424		MOVQ AX, 0(SP)											
  0x44ce8b		48894c2408		MOVQ CX, 0x8(SP)										
  0x44ce90		e8cbfeffff		CALL type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)		
  0x44ce95		488b4c2410		MOVQ 0x10(SP), CX										
  0x44ce9a		488b442418		MOVQ 0x18(SP), AX										
  0x44ce9f		48ffc0			INCQ AX												
  0x44cea2		483d86000000		CMPQ $0x86, AX											
  0x44cea8		7ccc			JL 0x44ce76											
  0x44ceaa		48894c2440		MOVQ CX, 0x40(SP)										
  0x44ceaf		488b6c2420		MOVQ 0x20(SP), BP										
  0x44ceb4		4883c428		ADDQ $0x28, SP											
  0x44ceb8		c3			RET												
  0x44ceb9		e8c2a9ffff		CALL runtime.morestack_noctxt(SB)								
  0x44cebe		eb90			JMP type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB) <autogenerated>

  0x44cec0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x44cec9		483b6110		CMPQ 0x10(CX), SP										
  0x44cecd		7670			JBE 0x44cf3f											
  0x44cecf		4883ec28		SUBQ $0x28, SP											
  0x44ced3		48896c2420		MOVQ BP, 0x20(SP)										
  0x44ced8		488d6c2420		LEAQ 0x20(SP), BP										
  0x44cedd		31c0			XORL AX, AX											
  0x44cedf		eb09			JMP 0x44ceea											
  0x44cee1		488b4c2418		MOVQ 0x18(SP), CX										
  0x44cee6		488d4101		LEAQ 0x1(CX), AX										
  0x44ceea		483d86000000		CMPQ $0x86, AX											
  0x44cef0		7d3e			JGE 0x44cf30											
  0x44cef2		4889442418		MOVQ AX, 0x18(SP)										
  0x44cef7		48c1e006		SHLQ $0x6, AX											
  0x44cefb		488b542430		MOVQ 0x30(SP), DX										
  0x44cf00		488d1c10		LEAQ 0(AX)(DX*1), BX										
  0x44cf04		48891c24		MOVQ BX, 0(SP)											
  0x44cf08		488b5c2438		MOVQ 0x38(SP), BX										
  0x44cf0d		4801d8			ADDQ BX, AX											
  0x44cf10		4889442408		MOVQ AX, 0x8(SP)										
  0x44cf15		e8c6feffff		CALL type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)		
  0x44cf1a		807c241000		CMPB $0x0, 0x10(SP)										
  0x44cf1f		75c0			JNE 0x44cee1											
  0x44cf21		c644244000		MOVB $0x0, 0x40(SP)										
  0x44cf26		488b6c2420		MOVQ 0x20(SP), BP										
  0x44cf2b		4883c428		ADDQ $0x28, SP											
  0x44cf2f		c3			RET												
  0x44cf30		c644244001		MOVB $0x1, 0x40(SP)										
  0x44cf35		488b6c2420		MOVQ 0x20(SP), BP										
  0x44cf3a		4883c428		ADDQ $0x28, SP											
  0x44cf3e		c3			RET												
  0x44cf3f		e83ca9ffff		CALL runtime.morestack_noctxt(SB)								
  0x44cf44		e977ffffff		JMP type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [8]uint8 }(SB)	

TEXT type..hash.runtime.specialfinalizer(SB) <autogenerated>

  0x44cf50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44cf59		483b6110		CMPQ 0x10(CX), SP				
  0x44cf5d		765f			JBE 0x44cfbe					
  0x44cf5f		4883ec28		SUBQ $0x28, SP					
  0x44cf63		48896c2420		MOVQ BP, 0x20(SP)				
  0x44cf68		488d6c2420		LEAQ 0x20(SP), BP				
  0x44cf6d		488b442430		MOVQ 0x30(SP), AX				
  0x44cf72		48890424		MOVQ AX, 0(SP)					
  0x44cf76		488b4c2438		MOVQ 0x38(SP), CX				
  0x44cf7b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44cf80		e8ebeaffff		CALL type..hash.runtime.special(SB)		
  0x44cf85		488b442410		MOVQ 0x10(SP), AX				
  0x44cf8a		488b4c2430		MOVQ 0x30(SP), CX				
  0x44cf8f		4883c110		ADDQ $0x10, CX					
  0x44cf93		48890c24		MOVQ CX, 0(SP)					
  0x44cf97		4889442408		MOVQ AX, 0x8(SP)				
  0x44cf9c		48c744241020000000	MOVQ $0x20, 0x10(SP)				
  0x44cfa5		e816a3fbff		CALL runtime.memhash(SB)			
  0x44cfaa		488b442418		MOVQ 0x18(SP), AX				
  0x44cfaf		4889442440		MOVQ AX, 0x40(SP)				
  0x44cfb4		488b6c2420		MOVQ 0x20(SP), BP				
  0x44cfb9		4883c428		ADDQ $0x28, SP					
  0x44cfbd		c3			RET						
  0x44cfbe		e8bda8ffff		CALL runtime.morestack_noctxt(SB)		
  0x44cfc3		eb8b			JMP type..hash.runtime.specialfinalizer(SB)	

TEXT type..eq.runtime.specialfinalizer(SB) <autogenerated>

  0x44cfd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44cfd9		483b6110		CMPQ 0x10(CX), SP				
  0x44cfdd		7671			JBE 0x44d050					
  0x44cfdf		4883ec28		SUBQ $0x28, SP					
  0x44cfe3		48896c2420		MOVQ BP, 0x20(SP)				
  0x44cfe8		488d6c2420		LEAQ 0x20(SP), BP				
  0x44cfed		488b442438		MOVQ 0x38(SP), AX				
  0x44cff2		488b08			MOVQ 0(AX), CX					
  0x44cff5		488b542430		MOVQ 0x30(SP), DX				
  0x44cffa		48390a			CMPQ CX, 0(DX)					
  0x44cffd		754d			JNE 0x44d04c					
  0x44cfff		0fb74808		MOVZX 0x8(AX), CX				
  0x44d003		66394a08		CMPW CX, 0x8(DX)				
  0x44d007		753f			JNE 0x44d048					
  0x44d009		0fb6480a		MOVZX 0xa(AX), CX				
  0x44d00d		384a0a			CMPB CL, 0xa(DX)				
  0x44d010		7410			JE 0x44d022					
  0x44d012		31c0			XORL AX, AX					
  0x44d014		88442440		MOVB AL, 0x40(SP)				
  0x44d018		488b6c2420		MOVQ 0x20(SP), BP				
  0x44d01d		4883c428		ADDQ $0x28, SP					
  0x44d021		c3			RET						
  0x44d022		488d4a10		LEAQ 0x10(DX), CX				
  0x44d026		48890c24		MOVQ CX, 0(SP)					
  0x44d02a		4883c010		ADDQ $0x10, AX					
  0x44d02e		4889442408		MOVQ AX, 0x8(SP)				
  0x44d033		48c744241020000000	MOVQ $0x20, 0x10(SP)				
  0x44d03c		e8df51fbff		CALL runtime.memequal(SB)			
  0x44d041		0fb6442418		MOVZX 0x18(SP), AX				
  0x44d046		ebcc			JMP 0x44d014					
  0x44d048		31c0			XORL AX, AX					
  0x44d04a		ebc8			JMP 0x44d014					
  0x44d04c		31c0			XORL AX, AX					
  0x44d04e		ebc4			JMP 0x44d014					
  0x44d050		e82ba8ffff		CALL runtime.morestack_noctxt(SB)		
  0x44d055		e976ffffff		JMP type..eq.runtime.specialfinalizer(SB)	

TEXT type..hash.runtime.rwmutex(SB) <autogenerated>

  0x44d060		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d069		483b6110		CMPQ 0x10(CX), SP			
  0x44d06d		7668			JBE 0x44d0d7				
  0x44d06f		4883ec28		SUBQ $0x28, SP				
  0x44d073		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d078		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d07d		488b442430		MOVQ 0x30(SP), AX			
  0x44d082		48890424		MOVQ AX, 0(SP)				
  0x44d086		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d08b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d090		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44d099		e822a2fbff		CALL runtime.memhash(SB)		
  0x44d09e		488b442418		MOVQ 0x18(SP), AX			
  0x44d0a3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d0a8		4883c118		ADDQ $0x18, CX				
  0x44d0ac		48890c24		MOVQ CX, 0(SP)				
  0x44d0b0		4889442408		MOVQ AX, 0x8(SP)			
  0x44d0b5		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x44d0be		e8fda1fbff		CALL runtime.memhash(SB)		
  0x44d0c3		488b442418		MOVQ 0x18(SP), AX			
  0x44d0c8		4889442440		MOVQ AX, 0x40(SP)			
  0x44d0cd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d0d2		4883c428		ADDQ $0x28, SP				
  0x44d0d6		c3			RET					
  0x44d0d7		e8a4a7ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d0dc		eb82			JMP type..hash.runtime.rwmutex(SB)	

TEXT type..eq.runtime.rwmutex(SB) <autogenerated>

  0x44d0e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d0e9		483b6110		CMPQ 0x10(CX), SP			
  0x44d0ed		7676			JBE 0x44d165				
  0x44d0ef		4883ec28		SUBQ $0x28, SP				
  0x44d0f3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d0f8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d0fd		488b442430		MOVQ 0x30(SP), AX			
  0x44d102		48890424		MOVQ AX, 0(SP)				
  0x44d106		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d10b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d110		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44d119		e80251fbff		CALL runtime.memequal(SB)		
  0x44d11e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44d123		7510			JNE 0x44d135				
  0x44d125		31c0			XORL AX, AX				
  0x44d127		88442440		MOVB AL, 0x40(SP)			
  0x44d12b		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d130		4883c428		ADDQ $0x28, SP				
  0x44d134		c3			RET					
  0x44d135		488b442430		MOVQ 0x30(SP), AX			
  0x44d13a		4883c018		ADDQ $0x18, AX				
  0x44d13e		48890424		MOVQ AX, 0(SP)				
  0x44d142		488b442438		MOVQ 0x38(SP), AX			
  0x44d147		4883c018		ADDQ $0x18, AX				
  0x44d14b		4889442408		MOVQ AX, 0x8(SP)			
  0x44d150		48c744241018000000	MOVQ $0x18, 0x10(SP)			
  0x44d159		e8c250fbff		CALL runtime.memequal(SB)		
  0x44d15e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44d163		ebc2			JMP 0x44d127				
  0x44d165		e816a7ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d16a		e971ffffff		JMP type..eq.runtime.rwmutex(SB)	

TEXT type..hash.runtime.siginfo(SB) <autogenerated>

  0x44d170		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d179		483b6110		CMPQ 0x10(CX), SP			
  0x44d17d		7668			JBE 0x44d1e7				
  0x44d17f		4883ec28		SUBQ $0x28, SP				
  0x44d183		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d188		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d18d		488b442430		MOVQ 0x30(SP), AX			
  0x44d192		48890424		MOVQ AX, 0(SP)				
  0x44d196		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d19b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d1a0		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44d1a9		e812a1fbff		CALL runtime.memhash(SB)		
  0x44d1ae		488b442418		MOVQ 0x18(SP), AX			
  0x44d1b3		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d1b8		4883c110		ADDQ $0x10, CX				
  0x44d1bc		48890c24		MOVQ CX, 0(SP)				
  0x44d1c0		4889442408		MOVQ AX, 0x8(SP)			
  0x44d1c5		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44d1ce		e8eda0fbff		CALL runtime.memhash(SB)		
  0x44d1d3		488b442418		MOVQ 0x18(SP), AX			
  0x44d1d8		4889442440		MOVQ AX, 0x40(SP)			
  0x44d1dd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d1e2		4883c428		ADDQ $0x28, SP				
  0x44d1e6		c3			RET					
  0x44d1e7		e894a6ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d1ec		eb82			JMP type..hash.runtime.siginfo(SB)	

TEXT type..eq.runtime.siginfo(SB) <autogenerated>

  0x44d1f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d1f9		483b6110		CMPQ 0x10(CX), SP			
  0x44d1fd		765d			JBE 0x44d25c				
  0x44d1ff		4883ec28		SUBQ $0x28, SP				
  0x44d203		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d208		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d20d		488b442430		MOVQ 0x30(SP), AX			
  0x44d212		48890424		MOVQ AX, 0(SP)				
  0x44d216		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d21b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d220		48c74424100c000000	MOVQ $0xc, 0x10(SP)			
  0x44d229		e8f24ffbff		CALL runtime.memequal(SB)		
  0x44d22e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44d233		7423			JE 0x44d258				
  0x44d235		488b442438		MOVQ 0x38(SP), AX			
  0x44d23a		488b4010		MOVQ 0x10(AX), AX			
  0x44d23e		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d243		48394110		CMPQ AX, 0x10(CX)			
  0x44d247		0f94c0			SETE AL					
  0x44d24a		88442440		MOVB AL, 0x40(SP)			
  0x44d24e		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d253		4883c428		ADDQ $0x28, SP				
  0x44d257		c3			RET					
  0x44d258		31c0			XORL AX, AX				
  0x44d25a		ebee			JMP 0x44d24a				
  0x44d25c		e81fa6ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d261		eb8d			JMP type..eq.runtime.siginfo(SB)	

TEXT type..hash.[2]string(SB) <autogenerated>

  0x44d270		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d279		483b6110		CMPQ 0x10(CX), SP			
  0x44d27d		7658			JBE 0x44d2d7				
  0x44d27f		4883ec28		SUBQ $0x28, SP				
  0x44d283		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d288		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d28d		31c0			XORL AX, AX				
  0x44d28f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d294		eb2c			JMP 0x44d2c2				
  0x44d296		4889442418		MOVQ AX, 0x18(SP)			
  0x44d29b		48c1e004		SHLQ $0x4, AX				
  0x44d29f		488b5c2430		MOVQ 0x30(SP), BX			
  0x44d2a4		4801d8			ADDQ BX, AX				
  0x44d2a7		48890424		MOVQ AX, 0(SP)				
  0x44d2ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d2b0		e8cb53fbff		CALL runtime.strhash(SB)		
  0x44d2b5		488b4c2410		MOVQ 0x10(SP), CX			
  0x44d2ba		488b442418		MOVQ 0x18(SP), AX			
  0x44d2bf		48ffc0			INCQ AX					
  0x44d2c2		4883f802		CMPQ $0x2, AX				
  0x44d2c6		7cce			JL 0x44d296				
  0x44d2c8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44d2cd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d2d2		4883c428		ADDQ $0x28, SP				
  0x44d2d6		c3			RET					
  0x44d2d7		e8a4a5ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d2dc		eb92			JMP type..hash.[2]string(SB)		

TEXT type..eq.[2]string(SB) <autogenerated>

  0x44d2e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d2e9		483b6110		CMPQ 0x10(CX), SP			
  0x44d2ed		0f8695000000		JBE 0x44d388				
  0x44d2f3		4883ec30		SUBQ $0x30, SP				
  0x44d2f7		48896c2428		MOVQ BP, 0x28(SP)			
  0x44d2fc		488d6c2428		LEAQ 0x28(SP), BP			
  0x44d301		488b442438		MOVQ 0x38(SP), AX			
  0x44d306		488b4c2440		MOVQ 0x40(SP), CX			
  0x44d30b		31d2			XORL DX, DX				
  0x44d30d		eb19			JMP 0x44d328				
  0x44d30f		488b5c2420		MOVQ 0x20(SP), BX			
  0x44d314		488d5301		LEAQ 0x1(BX), DX			
  0x44d318		488b5c2438		MOVQ 0x38(SP), BX			
  0x44d31d		488b742440		MOVQ 0x40(SP), SI			
  0x44d322		4889d8			MOVQ BX, AX				
  0x44d325		4889f1			MOVQ SI, CX				
  0x44d328		4883fa02		CMPQ $0x2, DX				
  0x44d32c		7d4b			JGE 0x44d379				
  0x44d32e		4889d3			MOVQ DX, BX				
  0x44d331		48c1e204		SHLQ $0x4, DX				
  0x44d335		488b340a		MOVQ 0(DX)(CX*1), SI			
  0x44d339		488b3c02		MOVQ 0(DX)(AX*1), DI			
  0x44d33d		4c8b441008		MOVQ 0x8(AX)(DX*1), R8			
  0x44d342		4801ca			ADDQ CX, DX				
  0x44d345		4c394208		CMPQ R8, 0x8(DX)			
  0x44d349		751f			JNE 0x44d36a				
  0x44d34b		48895c2420		MOVQ BX, 0x20(SP)			
  0x44d350		48893c24		MOVQ DI, 0(SP)				
  0x44d354		4889742408		MOVQ SI, 0x8(SP)			
  0x44d359		4c89442410		MOVQ R8, 0x10(SP)			
  0x44d35e		e8bd4efbff		CALL runtime.memequal(SB)		
  0x44d363		807c241800		CMPB $0x0, 0x18(SP)			
  0x44d368		75a5			JNE 0x44d30f				
  0x44d36a		c644244800		MOVB $0x0, 0x48(SP)			
  0x44d36f		488b6c2428		MOVQ 0x28(SP), BP			
  0x44d374		4883c430		ADDQ $0x30, SP				
  0x44d378		c3			RET					
  0x44d379		c644244801		MOVB $0x1, 0x48(SP)			
  0x44d37e		488b6c2428		MOVQ 0x28(SP), BP			
  0x44d383		4883c430		ADDQ $0x30, SP				
  0x44d387		c3			RET					
  0x44d388		e8f3a4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d38d		e94effffff		JMP type..eq.[2]string(SB)		

TEXT type..hash.[4]string(SB) <autogenerated>

  0x44d3a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d3a9		483b6110		CMPQ 0x10(CX), SP			
  0x44d3ad		7658			JBE 0x44d407				
  0x44d3af		4883ec28		SUBQ $0x28, SP				
  0x44d3b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d3b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d3bd		31c0			XORL AX, AX				
  0x44d3bf		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d3c4		eb2c			JMP 0x44d3f2				
  0x44d3c6		4889442418		MOVQ AX, 0x18(SP)			
  0x44d3cb		48c1e004		SHLQ $0x4, AX				
  0x44d3cf		488b5c2430		MOVQ 0x30(SP), BX			
  0x44d3d4		4801d8			ADDQ BX, AX				
  0x44d3d7		48890424		MOVQ AX, 0(SP)				
  0x44d3db		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d3e0		e89b52fbff		CALL runtime.strhash(SB)		
  0x44d3e5		488b4c2410		MOVQ 0x10(SP), CX			
  0x44d3ea		488b442418		MOVQ 0x18(SP), AX			
  0x44d3ef		48ffc0			INCQ AX					
  0x44d3f2		4883f804		CMPQ $0x4, AX				
  0x44d3f6		7cce			JL 0x44d3c6				
  0x44d3f8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44d3fd		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d402		4883c428		ADDQ $0x28, SP				
  0x44d406		c3			RET					
  0x44d407		e874a4ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d40c		eb92			JMP type..hash.[4]string(SB)		

TEXT type..eq.[4]string(SB) <autogenerated>

  0x44d410		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d419		483b6110		CMPQ 0x10(CX), SP			
  0x44d41d		0f8695000000		JBE 0x44d4b8				
  0x44d423		4883ec30		SUBQ $0x30, SP				
  0x44d427		48896c2428		MOVQ BP, 0x28(SP)			
  0x44d42c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44d431		488b442438		MOVQ 0x38(SP), AX			
  0x44d436		488b4c2440		MOVQ 0x40(SP), CX			
  0x44d43b		31d2			XORL DX, DX				
  0x44d43d		eb19			JMP 0x44d458				
  0x44d43f		488b5c2420		MOVQ 0x20(SP), BX			
  0x44d444		488d5301		LEAQ 0x1(BX), DX			
  0x44d448		488b5c2438		MOVQ 0x38(SP), BX			
  0x44d44d		488b742440		MOVQ 0x40(SP), SI			
  0x44d452		4889d8			MOVQ BX, AX				
  0x44d455		4889f1			MOVQ SI, CX				
  0x44d458		4883fa04		CMPQ $0x4, DX				
  0x44d45c		7d4b			JGE 0x44d4a9				
  0x44d45e		4889d3			MOVQ DX, BX				
  0x44d461		48c1e204		SHLQ $0x4, DX				
  0x44d465		488b340a		MOVQ 0(DX)(CX*1), SI			
  0x44d469		488b3c02		MOVQ 0(DX)(AX*1), DI			
  0x44d46d		4c8b441008		MOVQ 0x8(AX)(DX*1), R8			
  0x44d472		4801ca			ADDQ CX, DX				
  0x44d475		4c394208		CMPQ R8, 0x8(DX)			
  0x44d479		751f			JNE 0x44d49a				
  0x44d47b		48895c2420		MOVQ BX, 0x20(SP)			
  0x44d480		48893c24		MOVQ DI, 0(SP)				
  0x44d484		4889742408		MOVQ SI, 0x8(SP)			
  0x44d489		4c89442410		MOVQ R8, 0x10(SP)			
  0x44d48e		e88d4dfbff		CALL runtime.memequal(SB)		
  0x44d493		807c241800		CMPB $0x0, 0x18(SP)			
  0x44d498		75a5			JNE 0x44d43f				
  0x44d49a		c644244800		MOVB $0x0, 0x48(SP)			
  0x44d49f		488b6c2428		MOVQ 0x28(SP), BP			
  0x44d4a4		4883c430		ADDQ $0x30, SP				
  0x44d4a8		c3			RET					
  0x44d4a9		c644244801		MOVB $0x1, 0x48(SP)			
  0x44d4ae		488b6c2428		MOVQ 0x28(SP), BP			
  0x44d4b3		4883c430		ADDQ $0x30, SP				
  0x44d4b7		c3			RET					
  0x44d4b8		e8c3a3ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d4bd		e94effffff		JMP type..eq.[4]string(SB)		

TEXT runtime.(*itabTableType).add-fm(SB) /usr/local/go/src/runtime/iface.go
func (t *itabTableType) add(m *itab) {
  0x44d4d0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d4d9		483b6110		CMPQ 0x10(CX), SP			
  0x44d4dd		762f			JBE 0x44d50e				
  0x44d4df		4883ec18		SUBQ $0x18, SP				
  0x44d4e3		48896c2410		MOVQ BP, 0x10(SP)			
  0x44d4e8		488d6c2410		LEAQ 0x10(SP), BP			
  0x44d4ed		488b4208		MOVQ 0x8(DX), AX			
  0x44d4f1		48890424		MOVQ AX, 0(SP)				
  0x44d4f5		488b442420		MOVQ 0x20(SP), AX			
  0x44d4fa		4889442408		MOVQ AX, 0x8(SP)			
  0x44d4ff		e8eca6fbff		CALL runtime.(*itabTableType).add(SB)	
  0x44d504		488b6c2410		MOVQ 0x10(SP), BP			
  0x44d509		4883c418		ADDQ $0x18, SP				
  0x44d50d		c3			RET					
  0x44d50e		e8cda2ffff		CALL runtime.morestack(SB)		
  0x44d513		ebbb			JMP runtime.(*itabTableType).add-fm(SB)	

TEXT type..hash.runtime.TypeAssertionError(SB) <autogenerated>

  0x44d520		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44d529		483b6110		CMPQ 0x10(CX), SP				
  0x44d52d		765f			JBE 0x44d58e					
  0x44d52f		4883ec28		SUBQ $0x28, SP					
  0x44d533		48896c2420		MOVQ BP, 0x20(SP)				
  0x44d538		488d6c2420		LEAQ 0x20(SP), BP				
  0x44d53d		488b442430		MOVQ 0x30(SP), AX				
  0x44d542		48890424		MOVQ AX, 0(SP)					
  0x44d546		488b4c2438		MOVQ 0x38(SP), CX				
  0x44d54b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44d550		48c744241018000000	MOVQ $0x18, 0x10(SP)				
  0x44d559		e8629dfbff		CALL runtime.memhash(SB)			
  0x44d55e		488b442418		MOVQ 0x18(SP), AX				
  0x44d563		488b4c2430		MOVQ 0x30(SP), CX				
  0x44d568		4883c118		ADDQ $0x18, CX					
  0x44d56c		48890c24		MOVQ CX, 0(SP)					
  0x44d570		4889442408		MOVQ AX, 0x8(SP)				
  0x44d575		e80651fbff		CALL runtime.strhash(SB)			
  0x44d57a		488b442410		MOVQ 0x10(SP), AX				
  0x44d57f		4889442440		MOVQ AX, 0x40(SP)				
  0x44d584		488b6c2420		MOVQ 0x20(SP), BP				
  0x44d589		4883c428		ADDQ $0x28, SP					
  0x44d58d		c3			RET						
  0x44d58e		e8eda2ffff		CALL runtime.morestack_noctxt(SB)		
  0x44d593		eb8b			JMP type..hash.runtime.TypeAssertionError(SB)	

TEXT type..eq.runtime.TypeAssertionError(SB) <autogenerated>

  0x44d5a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44d5a9		483b6110		CMPQ 0x10(CX), SP				
  0x44d5ad		0f8680000000		JBE 0x44d633					
  0x44d5b3		4883ec28		SUBQ $0x28, SP					
  0x44d5b7		48896c2420		MOVQ BP, 0x20(SP)				
  0x44d5bc		488d6c2420		LEAQ 0x20(SP), BP				
  0x44d5c1		488b442430		MOVQ 0x30(SP), AX				
  0x44d5c6		48890424		MOVQ AX, 0(SP)					
  0x44d5ca		488b4c2438		MOVQ 0x38(SP), CX				
  0x44d5cf		48894c2408		MOVQ CX, 0x8(SP)				
  0x44d5d4		48c744241018000000	MOVQ $0x18, 0x10(SP)				
  0x44d5dd		e83e4cfbff		CALL runtime.memequal(SB)			
  0x44d5e2		807c241800		CMPB $0x0, 0x18(SP)				
  0x44d5e7		7446			JE 0x44d62f					
  0x44d5e9		488b442438		MOVQ 0x38(SP), AX				
  0x44d5ee		488b4818		MOVQ 0x18(AX), CX				
  0x44d5f2		488b542430		MOVQ 0x30(SP), DX				
  0x44d5f7		488b5a20		MOVQ 0x20(DX), BX				
  0x44d5fb		488b5218		MOVQ 0x18(DX), DX				
  0x44d5ff		48395820		CMPQ BX, 0x20(AX)				
  0x44d603		7410			JE 0x44d615					
  0x44d605		31c0			XORL AX, AX					
  0x44d607		88442440		MOVB AL, 0x40(SP)				
  0x44d60b		488b6c2420		MOVQ 0x20(SP), BP				
  0x44d610		4883c428		ADDQ $0x28, SP					
  0x44d614		c3			RET						
  0x44d615		48891424		MOVQ DX, 0(SP)					
  0x44d619		48894c2408		MOVQ CX, 0x8(SP)				
  0x44d61e		48895c2410		MOVQ BX, 0x10(SP)				
  0x44d623		e8f84bfbff		CALL runtime.memequal(SB)			
  0x44d628		0fb6442418		MOVZX 0x18(SP), AX				
  0x44d62d		ebd8			JMP 0x44d607					
  0x44d62f		31c0			XORL AX, AX					
  0x44d631		ebd4			JMP 0x44d607					
  0x44d633		e848a2ffff		CALL runtime.morestack_noctxt(SB)		
  0x44d638		e963ffffff		JMP type..eq.runtime.TypeAssertionError(SB)	

TEXT type..hash.runtime.cpuProfile(SB) <autogenerated>

  0x44d640		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d649		483b6110		CMPQ 0x10(CX), SP			
  0x44d64d		7668			JBE 0x44d6b7				
  0x44d64f		4883ec28		SUBQ $0x28, SP				
  0x44d653		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d658		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d65d		488b442430		MOVQ 0x30(SP), AX			
  0x44d662		48890424		MOVQ AX, 0(SP)				
  0x44d666		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d66b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d670		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44d679		e8429cfbff		CALL runtime.memhash(SB)		
  0x44d67e		488b442418		MOVQ 0x18(SP), AX			
  0x44d683		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d688		4883c110		ADDQ $0x10, CX				
  0x44d68c		48890c24		MOVQ CX, 0(SP)				
  0x44d690		4889442408		MOVQ AX, 0x8(SP)			
  0x44d695		48c7442410581f0000	MOVQ $0x1f58, 0x10(SP)			
  0x44d69e		e81d9cfbff		CALL runtime.memhash(SB)		
  0x44d6a3		488b442418		MOVQ 0x18(SP), AX			
  0x44d6a8		4889442440		MOVQ AX, 0x40(SP)			
  0x44d6ad		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d6b2		4883c428		ADDQ $0x28, SP				
  0x44d6b6		c3			RET					
  0x44d6b7		e8c4a1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d6bc		eb82			JMP type..hash.runtime.cpuProfile(SB)	

TEXT type..eq.runtime.cpuProfile(SB) <autogenerated>

  0x44d6c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d6c9		483b6110		CMPQ 0x10(CX), SP			
  0x44d6cd		7663			JBE 0x44d732				
  0x44d6cf		4883ec28		SUBQ $0x28, SP				
  0x44d6d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d6d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d6dd		488b442438		MOVQ 0x38(SP), AX			
  0x44d6e2		488b08			MOVQ 0(AX), CX				
  0x44d6e5		488b542430		MOVQ 0x30(SP), DX			
  0x44d6ea		48390a			CMPQ CX, 0(DX)				
  0x44d6ed		753f			JNE 0x44d72e				
  0x44d6ef		0fb64808		MOVZX 0x8(AX), CX			
  0x44d6f3		384a08			CMPB CL, 0x8(DX)			
  0x44d6f6		7410			JE 0x44d708				
  0x44d6f8		31c0			XORL AX, AX				
  0x44d6fa		88442440		MOVB AL, 0x40(SP)			
  0x44d6fe		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d703		4883c428		ADDQ $0x28, SP				
  0x44d707		c3			RET					
  0x44d708		488d4a10		LEAQ 0x10(DX), CX			
  0x44d70c		48890c24		MOVQ CX, 0(SP)				
  0x44d710		4883c010		ADDQ $0x10, AX				
  0x44d714		4889442408		MOVQ AX, 0x8(SP)			
  0x44d719		48c7442410581f0000	MOVQ $0x1f58, 0x10(SP)			
  0x44d722		e8f94afbff		CALL runtime.memequal(SB)		
  0x44d727		0fb6442418		MOVZX 0x18(SP), AX			
  0x44d72c		ebcc			JMP 0x44d6fa				
  0x44d72e		31c0			XORL AX, AX				
  0x44d730		ebc8			JMP 0x44d6fa				
  0x44d732		e849a1ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d737		eb87			JMP type..eq.runtime.cpuProfile(SB)	

TEXT type..hash.runtime.dbgVar(SB) <autogenerated>

  0x44d740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d749		483b6110		CMPQ 0x10(CX), SP			
  0x44d74d		765f			JBE 0x44d7ae				
  0x44d74f		4883ec28		SUBQ $0x28, SP				
  0x44d753		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d758		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d75d		488b442430		MOVQ 0x30(SP), AX			
  0x44d762		48890424		MOVQ AX, 0(SP)				
  0x44d766		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d76b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d770		e80b4ffbff		CALL runtime.strhash(SB)		
  0x44d775		488b442410		MOVQ 0x10(SP), AX			
  0x44d77a		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d77f		4883c110		ADDQ $0x10, CX				
  0x44d783		48890c24		MOVQ CX, 0(SP)				
  0x44d787		4889442408		MOVQ AX, 0x8(SP)			
  0x44d78c		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44d795		e8269bfbff		CALL runtime.memhash(SB)		
  0x44d79a		488b442418		MOVQ 0x18(SP), AX			
  0x44d79f		4889442440		MOVQ AX, 0x40(SP)			
  0x44d7a4		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d7a9		4883c428		ADDQ $0x28, SP				
  0x44d7ad		c3			RET					
  0x44d7ae		e8cda0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d7b3		eb8b			JMP type..hash.runtime.dbgVar(SB)	

TEXT type..eq.runtime.dbgVar(SB) <autogenerated>

  0x44d7c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d7c9		483b6110		CMPQ 0x10(CX), SP			
  0x44d7cd		766f			JBE 0x44d83e				
  0x44d7cf		4883ec28		SUBQ $0x28, SP				
  0x44d7d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d7d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d7dd		488b442430		MOVQ 0x30(SP), AX			
  0x44d7e2		488b08			MOVQ 0(AX), CX				
  0x44d7e5		488b5008		MOVQ 0x8(AX), DX			
  0x44d7e9		488b5c2438		MOVQ 0x38(SP), BX			
  0x44d7ee		488b33			MOVQ 0(BX), SI				
  0x44d7f1		48395308		CMPQ DX, 0x8(BX)			
  0x44d7f5		7423			JE 0x44d81a				
  0x44d7f7		31c9			XORL CX, CX				
  0x44d7f9		84c9			TESTL CL, CL				
  0x44d7fb		7419			JE 0x44d816				
  0x44d7fd		488b4b10		MOVQ 0x10(BX), CX			
  0x44d801		48394810		CMPQ CX, 0x10(AX)			
  0x44d805		0f94c0			SETE AL					
  0x44d808		88442440		MOVB AL, 0x40(SP)			
  0x44d80c		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d811		4883c428		ADDQ $0x28, SP				
  0x44d815		c3			RET					
  0x44d816		31c0			XORL AX, AX				
  0x44d818		ebee			JMP 0x44d808				
  0x44d81a		48890c24		MOVQ CX, 0(SP)				
  0x44d81e		4889742408		MOVQ SI, 0x8(SP)			
  0x44d823		4889542410		MOVQ DX, 0x10(SP)			
  0x44d828		e8f349fbff		CALL runtime.memequal(SB)		
  0x44d82d		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44d832		488b442430		MOVQ 0x30(SP), AX			
  0x44d837		488b5c2438		MOVQ 0x38(SP), BX			
  0x44d83c		ebbb			JMP 0x44d7f9				
  0x44d83e		e83da0ffff		CALL runtime.morestack_noctxt(SB)	
  0x44d843		e978ffffff		JMP type..eq.runtime.dbgVar(SB)		

TEXT runtime.(*errorString).Error(SB) <autogenerated>

  0x44d850		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44d859		483b6110		CMPQ 0x10(CX), SP	
  0x44d85d		767a			JBE 0x44d8d9		
  0x44d85f		4883ec40		SUBQ $0x40, SP		
  0x44d863		48896c2438		MOVQ BP, 0x38(SP)	
  0x44d868		488d6c2438		LEAQ 0x38(SP), BP	
  0x44d86d		488b5920		MOVQ 0x20(CX), BX	
  0x44d871		4885db			TESTQ BX, BX		
  0x44d874		756d			JNE 0x44d8e3		
  0x44d876		488b442448		MOVQ 0x48(SP), AX	
  0x44d87b		4885c0			TESTQ AX, AX		
  0x44d87e		7452			JE 0x44d8d2		
  0x44d880		488b4808		MOVQ 0x8(AX), CX	
  0x44d884		488b00			MOVQ 0(AX), AX		
  0x44d887		90			NOPL			
	return "runtime error: " + string(e)
  0x44d888		48c7042400000000	MOVQ $0x0, 0(SP)		
  0x44d890		488d1535260200		LEAQ 0x22635(IP), DX		
  0x44d897		4889542408		MOVQ DX, 0x8(SP)		
  0x44d89c		48c74424100f000000	MOVQ $0xf, 0x10(SP)		
  0x44d8a5		4889442418		MOVQ AX, 0x18(SP)		
  0x44d8aa		48894c2420		MOVQ CX, 0x20(SP)		
  0x44d8af		e82cc1feff		CALL runtime.concatstring2(SB)	
  0x44d8b4		488b442428		MOVQ 0x28(SP), AX		
  0x44d8b9		488b4c2430		MOVQ 0x30(SP), CX		

  0x44d8be		4889442450		MOVQ AX, 0x50(SP)			
  0x44d8c3		48894c2458		MOVQ CX, 0x58(SP)			
  0x44d8c8		488b6c2438		MOVQ 0x38(SP), BP			
  0x44d8cd		4883c440		ADDQ $0x40, SP				
  0x44d8d1		c3			RET					
  0x44d8d2		e8d995fbff		CALL runtime.panicwrap(SB)		
  0x44d8d7		0f0b			UD2					
  0x44d8d9		e8a29fffff		CALL runtime.morestack_noctxt(SB)	
  0x44d8de		e96dffffff		JMP runtime.(*errorString).Error(SB)	
  0x44d8e3		488d7c2448		LEAQ 0x48(SP), DI			
  0x44d8e8		48393b			CMPQ DI, 0(BX)				
  0x44d8eb		7589			JNE 0x44d876				
  0x44d8ed		488923			MOVQ SP, 0(BX)				
  0x44d8f0		eb84			JMP 0x44d876				

TEXT type..hash.runtime.finblock(SB) <autogenerated>

  0x44d900		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d909		483b6110		CMPQ 0x10(CX), SP			
  0x44d90d		7668			JBE 0x44d977				
  0x44d90f		4883ec28		SUBQ $0x28, SP				
  0x44d913		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d918		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d91d		488b442430		MOVQ 0x30(SP), AX			
  0x44d922		48890424		MOVQ AX, 0(SP)				
  0x44d926		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d92b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d930		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44d939		e88299fbff		CALL runtime.memhash(SB)		
  0x44d93e		488b442418		MOVQ 0x18(SP), AX			
  0x44d943		488b4c2430		MOVQ 0x30(SP), CX			
  0x44d948		4883c118		ADDQ $0x18, CX				
  0x44d94c		48890c24		MOVQ CX, 0(SP)				
  0x44d950		4889442408		MOVQ AX, 0x8(SP)			
  0x44d955		48c7442410c80f0000	MOVQ $0xfc8, 0x10(SP)			
  0x44d95e		e85d99fbff		CALL runtime.memhash(SB)		
  0x44d963		488b442418		MOVQ 0x18(SP), AX			
  0x44d968		4889442440		MOVQ AX, 0x40(SP)			
  0x44d96d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d972		4883c428		ADDQ $0x28, SP				
  0x44d976		c3			RET					
  0x44d977		e8049fffff		CALL runtime.morestack_noctxt(SB)	
  0x44d97c		eb82			JMP type..hash.runtime.finblock(SB)	

TEXT type..eq.runtime.finblock(SB) <autogenerated>

  0x44d980		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44d989		483b6110		CMPQ 0x10(CX), SP			
  0x44d98d		7676			JBE 0x44da05				
  0x44d98f		4883ec28		SUBQ $0x28, SP				
  0x44d993		48896c2420		MOVQ BP, 0x20(SP)			
  0x44d998		488d6c2420		LEAQ 0x20(SP), BP			
  0x44d99d		488b442430		MOVQ 0x30(SP), AX			
  0x44d9a2		48890424		MOVQ AX, 0(SP)				
  0x44d9a6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44d9ab		48894c2408		MOVQ CX, 0x8(SP)			
  0x44d9b0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44d9b9		e86248fbff		CALL runtime.memequal(SB)		
  0x44d9be		807c241800		CMPB $0x0, 0x18(SP)			
  0x44d9c3		7510			JNE 0x44d9d5				
  0x44d9c5		31c0			XORL AX, AX				
  0x44d9c7		88442440		MOVB AL, 0x40(SP)			
  0x44d9cb		488b6c2420		MOVQ 0x20(SP), BP			
  0x44d9d0		4883c428		ADDQ $0x28, SP				
  0x44d9d4		c3			RET					
  0x44d9d5		488b442430		MOVQ 0x30(SP), AX			
  0x44d9da		4883c018		ADDQ $0x18, AX				
  0x44d9de		48890424		MOVQ AX, 0(SP)				
  0x44d9e2		488b442438		MOVQ 0x38(SP), AX			
  0x44d9e7		4883c018		ADDQ $0x18, AX				
  0x44d9eb		4889442408		MOVQ AX, 0x8(SP)			
  0x44d9f0		48c7442410c80f0000	MOVQ $0xfc8, 0x10(SP)			
  0x44d9f9		e82248fbff		CALL runtime.memequal(SB)		
  0x44d9fe		0fb6442418		MOVZX 0x18(SP), AX			
  0x44da03		ebc2			JMP 0x44d9c7				
  0x44da05		e8769effff		CALL runtime.morestack_noctxt(SB)	
  0x44da0a		e971ffffff		JMP type..eq.runtime.finblock(SB)	

TEXT type..hash.runtime.forcegcstate(SB) <autogenerated>

  0x44da10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44da19		483b6110		CMPQ 0x10(CX), SP			
  0x44da1d		7643			JBE 0x44da62				
  0x44da1f		4883ec28		SUBQ $0x28, SP				
  0x44da23		48896c2420		MOVQ BP, 0x20(SP)			
  0x44da28		488d6c2420		LEAQ 0x20(SP), BP			
  0x44da2d		488b442430		MOVQ 0x30(SP), AX			
  0x44da32		48890424		MOVQ AX, 0(SP)				
  0x44da36		488b442438		MOVQ 0x38(SP), AX			
  0x44da3b		4889442408		MOVQ AX, 0x8(SP)			
  0x44da40		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44da49		e87298fbff		CALL runtime.memhash(SB)		
  0x44da4e		488b442418		MOVQ 0x18(SP), AX			
  0x44da53		4889442440		MOVQ AX, 0x40(SP)			
  0x44da58		488b6c2420		MOVQ 0x20(SP), BP			
  0x44da5d		4883c428		ADDQ $0x28, SP				
  0x44da61		c3			RET					
  0x44da62		e8199effff		CALL runtime.morestack_noctxt(SB)	
  0x44da67		eba7			JMP type..hash.runtime.forcegcstate(SB)	

TEXT type..eq.runtime.forcegcstate(SB) <autogenerated>

  0x44da70		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44da79		483b6110		CMPQ 0x10(CX), SP			
  0x44da7d		7642			JBE 0x44dac1				
  0x44da7f		4883ec28		SUBQ $0x28, SP				
  0x44da83		48896c2420		MOVQ BP, 0x20(SP)			
  0x44da88		488d6c2420		LEAQ 0x20(SP), BP			
  0x44da8d		488b442430		MOVQ 0x30(SP), AX			
  0x44da92		48890424		MOVQ AX, 0(SP)				
  0x44da96		488b442438		MOVQ 0x38(SP), AX			
  0x44da9b		4889442408		MOVQ AX, 0x8(SP)			
  0x44daa0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44daa9		e87247fbff		CALL runtime.memequal(SB)		
  0x44daae		0fb6442418		MOVZX 0x18(SP), AX			
  0x44dab3		88442440		MOVB AL, 0x40(SP)			
  0x44dab7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44dabc		4883c428		ADDQ $0x28, SP				
  0x44dac0		c3			RET					
  0x44dac1		e8ba9dffff		CALL runtime.morestack_noctxt(SB)	
  0x44dac6		eba8			JMP type..eq.runtime.forcegcstate(SB)	

TEXT type..hash.runtime.gcControllerState(SB) <autogenerated>

  0x44dad0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44dad9		483b6110		CMPQ 0x10(CX), SP				
  0x44dadd		0f8697000000		JBE 0x44db7a					
  0x44dae3		4883ec28		SUBQ $0x28, SP					
  0x44dae7		48896c2420		MOVQ BP, 0x20(SP)				
  0x44daec		488d6c2420		LEAQ 0x20(SP), BP				
  0x44daf1		488b442430		MOVQ 0x30(SP), AX				
  0x44daf6		48890424		MOVQ AX, 0(SP)					
  0x44dafa		488b4c2438		MOVQ 0x38(SP), CX				
  0x44daff		48894c2408		MOVQ CX, 0x8(SP)				
  0x44db04		48c744241040000000	MOVQ $0x40, 0x10(SP)				
  0x44db0d		e8ae97fbff		CALL runtime.memhash(SB)			
  0x44db12		488b442418		MOVQ 0x18(SP), AX				
  0x44db17		488b4c2430		MOVQ 0x30(SP), CX				
  0x44db1c		488d5140		LEAQ 0x40(CX), DX				
  0x44db20		48891424		MOVQ DX, 0(SP)					
  0x44db24		4889442408		MOVQ AX, 0x8(SP)				
  0x44db29		e8d24cfbff		CALL runtime.f64hash(SB)			
  0x44db2e		488b442410		MOVQ 0x10(SP), AX				
  0x44db33		488b4c2430		MOVQ 0x30(SP), CX				
  0x44db38		488d5148		LEAQ 0x48(CX), DX				
  0x44db3c		48891424		MOVQ DX, 0(SP)					
  0x44db40		4889442408		MOVQ AX, 0x8(SP)				
  0x44db45		e8b64cfbff		CALL runtime.f64hash(SB)			
  0x44db4a		488b442410		MOVQ 0x10(SP), AX				
  0x44db4f		488b4c2430		MOVQ 0x30(SP), CX				
  0x44db54		4883c150		ADDQ $0x50, CX					
  0x44db58		48890c24		MOVQ CX, 0(SP)					
  0x44db5c		4889442408		MOVQ AX, 0x8(SP)				
  0x44db61		e89a4cfbff		CALL runtime.f64hash(SB)			
  0x44db66		488b442410		MOVQ 0x10(SP), AX				
  0x44db6b		4889442440		MOVQ AX, 0x40(SP)				
  0x44db70		488b6c2420		MOVQ 0x20(SP), BP				
  0x44db75		4883c428		ADDQ $0x28, SP					
  0x44db79		c3			RET						
  0x44db7a		e8019dffff		CALL runtime.morestack_noctxt(SB)		
  0x44db7f		e94cffffff		JMP type..hash.runtime.gcControllerState(SB)	

TEXT type..eq.runtime.gcControllerState(SB) <autogenerated>

  0x44db90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44db99		483b6110		CMPQ 0x10(CX), SP				
  0x44db9d		0f8694000000		JBE 0x44dc37					
  0x44dba3		4883ec28		SUBQ $0x28, SP					
  0x44dba7		48896c2420		MOVQ BP, 0x20(SP)				
  0x44dbac		488d6c2420		LEAQ 0x20(SP), BP				
  0x44dbb1		488b442430		MOVQ 0x30(SP), AX				
  0x44dbb6		48890424		MOVQ AX, 0(SP)					
  0x44dbba		488b4c2438		MOVQ 0x38(SP), CX				
  0x44dbbf		48894c2408		MOVQ CX, 0x8(SP)				
  0x44dbc4		48c744241040000000	MOVQ $0x40, 0x10(SP)				
  0x44dbcd		e84e46fbff		CALL runtime.memequal(SB)			
  0x44dbd2		807c241800		CMPB $0x0, 0x18(SP)				
  0x44dbd7		745a			JE 0x44dc33					
  0x44dbd9		488b442430		MOVQ 0x30(SP), AX				
  0x44dbde		f20f104040		MOVSD_XMM 0x40(AX), X0				
  0x44dbe3		488b4c2438		MOVQ 0x38(SP), CX				
  0x44dbe8		f20f104940		MOVSD_XMM 0x40(CX), X1				
  0x44dbed		660f2ec1		UCOMISD X1, X0					
  0x44dbf1		753c			JNE 0x44dc2f					
  0x44dbf3		7a3a			JP 0x44dc2f					
  0x44dbf5		f20f104148		MOVSD_XMM 0x48(CX), X0				
  0x44dbfa		f20f104848		MOVSD_XMM 0x48(AX), X1				
  0x44dbff		660f2ec8		UCOMISD X0, X1					
  0x44dc03		7526			JNE 0x44dc2b					
  0x44dc05		7a24			JP 0x44dc2b					
  0x44dc07		f20f104150		MOVSD_XMM 0x50(CX), X0				
  0x44dc0c		f20f104850		MOVSD_XMM 0x50(AX), X1				
  0x44dc11		660f2ec1		UCOMISD X1, X0					
  0x44dc15		0f94c1			SETE CL						
  0x44dc18		0f9bc0			SETNP AL					
  0x44dc1b		21c1			ANDL AX, CX					
  0x44dc1d		884c2440		MOVB CL, 0x40(SP)				
  0x44dc21		488b6c2420		MOVQ 0x20(SP), BP				
  0x44dc26		4883c428		ADDQ $0x28, SP					
  0x44dc2a		c3			RET						
  0x44dc2b		31c9			XORL CX, CX					
  0x44dc2d		ebee			JMP 0x44dc1d					
  0x44dc2f		31c9			XORL CX, CX					
  0x44dc31		ebea			JMP 0x44dc1d					
  0x44dc33		31c9			XORL CX, CX					
  0x44dc35		ebe6			JMP 0x44dc1d					
  0x44dc37		e8449cffff		CALL runtime.morestack_noctxt(SB)		
  0x44dc3c		e94fffffff		JMP type..eq.runtime.gcControllerState(SB)	

TEXT type..hash.runtime.gcTrigger(SB) <autogenerated>

  0x44dc50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44dc59		483b6110		CMPQ 0x10(CX), SP			
  0x44dc5d		7643			JBE 0x44dca2				
  0x44dc5f		4883ec28		SUBQ $0x28, SP				
  0x44dc63		48896c2420		MOVQ BP, 0x20(SP)			
  0x44dc68		488d6c2420		LEAQ 0x20(SP), BP			
  0x44dc6d		488b442430		MOVQ 0x30(SP), AX			
  0x44dc72		48890424		MOVQ AX, 0(SP)				
  0x44dc76		488b442438		MOVQ 0x38(SP), AX			
  0x44dc7b		4889442408		MOVQ AX, 0x8(SP)			
  0x44dc80		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44dc89		e83296fbff		CALL runtime.memhash(SB)		
  0x44dc8e		488b442418		MOVQ 0x18(SP), AX			
  0x44dc93		4889442440		MOVQ AX, 0x40(SP)			
  0x44dc98		488b6c2420		MOVQ 0x20(SP), BP			
  0x44dc9d		4883c428		ADDQ $0x28, SP				
  0x44dca1		c3			RET					
  0x44dca2		e8d99bffff		CALL runtime.morestack_noctxt(SB)	
  0x44dca7		eba7			JMP type..hash.runtime.gcTrigger(SB)	

TEXT type..eq.runtime.gcTrigger(SB) <autogenerated>

  0x44dcb0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44dcb9		483b6110		CMPQ 0x10(CX), SP			
  0x44dcbd		7642			JBE 0x44dd01				
  0x44dcbf		4883ec28		SUBQ $0x28, SP				
  0x44dcc3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44dcc8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44dccd		488b442430		MOVQ 0x30(SP), AX			
  0x44dcd2		48890424		MOVQ AX, 0(SP)				
  0x44dcd6		488b442438		MOVQ 0x38(SP), AX			
  0x44dcdb		4889442408		MOVQ AX, 0x8(SP)			
  0x44dce0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44dce9		e83245fbff		CALL runtime.memequal(SB)		
  0x44dcee		0fb6442418		MOVZX 0x18(SP), AX			
  0x44dcf3		88442440		MOVB AL, 0x40(SP)			
  0x44dcf7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44dcfc		4883c428		ADDQ $0x28, SP				
  0x44dd00		c3			RET					
  0x44dd01		e87a9bffff		CALL runtime.morestack_noctxt(SB)	
  0x44dd06		eba8			JMP type..eq.runtime.gcTrigger(SB)	

TEXT type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44dd10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX										
  0x44dd19		483b6110		CMPQ 0x10(CX), SP										
  0x44dd1d		7668			JBE 0x44dd87											
  0x44dd1f		4883ec28		SUBQ $0x28, SP											
  0x44dd23		48896c2420		MOVQ BP, 0x20(SP)										
  0x44dd28		488d6c2420		LEAQ 0x20(SP), BP										
  0x44dd2d		488b442430		MOVQ 0x30(SP), AX										
  0x44dd32		48890424		MOVQ AX, 0(SP)											
  0x44dd36		488b4c2438		MOVQ 0x38(SP), CX										
  0x44dd3b		48894c2408		MOVQ CX, 0x8(SP)										
  0x44dd40		48c744241004000000	MOVQ $0x4, 0x10(SP)										
  0x44dd49		e87295fbff		CALL runtime.memhash(SB)									
  0x44dd4e		488b442418		MOVQ 0x18(SP), AX										
  0x44dd53		488b4c2430		MOVQ 0x30(SP), CX										
  0x44dd58		4883c108		ADDQ $0x8, CX											
  0x44dd5c		48890c24		MOVQ CX, 0(SP)											
  0x44dd60		4889442408		MOVQ AX, 0x8(SP)										
  0x44dd65		48c744241010000000	MOVQ $0x10, 0x10(SP)										
  0x44dd6e		e84d95fbff		CALL runtime.memhash(SB)									
  0x44dd73		488b442418		MOVQ 0x18(SP), AX										
  0x44dd78		4889442440		MOVQ AX, 0x40(SP)										
  0x44dd7d		488b6c2420		MOVQ 0x20(SP), BP										
  0x44dd82		4883c428		ADDQ $0x28, SP											
  0x44dd86		c3			RET												
  0x44dd87		e8f49affff		CALL runtime.morestack_noctxt(SB)								
  0x44dd8c		eb82			JMP type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	

TEXT type..eq.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44dd90		488b442410		MOVQ 0x10(SP), AX	
  0x44dd95		8b08			MOVL 0(AX), CX		
  0x44dd97		488b542408		MOVQ 0x8(SP), DX	
  0x44dd9c		390a			CMPL CX, 0(DX)		
  0x44dd9e		751e			JNE 0x44ddbe		
  0x44dda0		488b4808		MOVQ 0x8(AX), CX	
  0x44dda4		48394a08		CMPQ CX, 0x8(DX)	
  0x44dda8		7510			JNE 0x44ddba		
  0x44ddaa		488b4a10		MOVQ 0x10(DX), CX	
  0x44ddae		48394810		CMPQ CX, 0x10(AX)	
  0x44ddb2		0f94c0			SETE AL			
  0x44ddb5		88442418		MOVB AL, 0x18(SP)	
  0x44ddb9		c3			RET			
  0x44ddba		31c0			XORL AX, AX		
  0x44ddbc		ebf7			JMP 0x44ddb5		
  0x44ddbe		31c0			XORL AX, AX		
  0x44ddc0		ebf3			JMP 0x44ddb5		

TEXT type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44ddd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44ddd9		483b6110		CMPQ 0x10(CX), SP											
  0x44dddd		7659			JBE 0x44de38												
  0x44dddf		4883ec28		SUBQ $0x28, SP												
  0x44dde3		48896c2420		MOVQ BP, 0x20(SP)											
  0x44dde8		488d6c2420		LEAQ 0x20(SP), BP											
  0x44dded		31c0			XORL AX, AX												
  0x44ddef		488b4c2438		MOVQ 0x38(SP), CX											
  0x44ddf4		eb2d			JMP 0x44de23												
  0x44ddf6		4889442418		MOVQ AX, 0x18(SP)											
  0x44ddfb		488d1440		LEAQ 0(AX)(AX*2), DX											
  0x44ddff		488b5c2430		MOVQ 0x30(SP), BX											
  0x44de04		488d14d3		LEAQ 0(BX)(DX*8), DX											
  0x44de08		48891424		MOVQ DX, 0(SP)												
  0x44de0c		48894c2408		MOVQ CX, 0x8(SP)											
  0x44de11		e8fafeffff		CALL type..hash.struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44de16		488b4c2410		MOVQ 0x10(SP), CX											
  0x44de1b		488b442418		MOVQ 0x18(SP), AX											
  0x44de20		48ffc0			INCQ AX													
  0x44de23		4883f843		CMPQ $0x43, AX												
  0x44de27		7ccd			JL 0x44ddf6												
  0x44de29		48894c2440		MOVQ CX, 0x40(SP)											
  0x44de2e		488b6c2420		MOVQ 0x20(SP), BP											
  0x44de33		4883c428		ADDQ $0x28, SP												
  0x44de37		c3			RET													
  0x44de38		e8439affff		CALL runtime.morestack_noctxt(SB)									
  0x44de3d		eb91			JMP type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	

TEXT type..eq.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB) <autogenerated>

  0x44de40		488b442408		MOVQ 0x8(SP), AX	
  0x44de45		488b4c2410		MOVQ 0x10(SP), CX	
  0x44de4a		31d2			XORL DX, DX		
  0x44de4c		eb03			JMP 0x44de51		
  0x44de4e		48ffc2			INCQ DX			
  0x44de51		4883fa43		CMPQ $0x43, DX		
  0x44de55		7d32			JGE 0x44de89		
  0x44de57		488d1c52		LEAQ 0(DX)(DX*2), BX	
  0x44de5b		8b34d8			MOVL 0(AX)(BX*8), SI	
  0x44de5e		8b3cd9			MOVL 0(CX)(BX*8), DI	
  0x44de61		39fe			CMPL DI, SI		
  0x44de63		751e			JNE 0x44de83		
  0x44de65		488b74d808		MOVQ 0x8(AX)(BX*8), SI	
  0x44de6a		488b7cd908		MOVQ 0x8(CX)(BX*8), DI	
  0x44de6f		4839fe			CMPQ DI, SI		
  0x44de72		750f			JNE 0x44de83		
  0x44de74		488b74d910		MOVQ 0x10(CX)(BX*8), SI	
  0x44de79		488b5cd810		MOVQ 0x10(AX)(BX*8), BX	
  0x44de7e		4839de			CMPQ BX, SI		
  0x44de81		74cb			JE 0x44de4e		
  0x44de83		c644241800		MOVB $0x0, 0x18(SP)	
  0x44de88		c3			RET			
  0x44de89		c644241801		MOVB $0x1, 0x18(SP)	
  0x44de8e		c3			RET			

TEXT type..hash.runtime.mstats(SB) <autogenerated>

  0x44de90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44de99		483b6110		CMPQ 0x10(CX), SP											
  0x44de9d		0f8618010000		JBE 0x44dfbb												
  0x44dea3		4883ec28		SUBQ $0x28, SP												
  0x44dea7		48896c2420		MOVQ BP, 0x20(SP)											
  0x44deac		488d6c2420		LEAQ 0x20(SP), BP											
  0x44deb1		488b442430		MOVQ 0x30(SP), AX											
  0x44deb6		48890424		MOVQ AX, 0(SP)												
  0x44deba		488b4c2438		MOVQ 0x38(SP), CX											
  0x44debf		48894c2408		MOVQ CX, 0x8(SP)											
  0x44dec4		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)											
  0x44decd		e8ee93fbff		CALL runtime.memhash(SB)										
  0x44ded2		488b442418		MOVQ 0x18(SP), AX											
  0x44ded7		488b4c2430		MOVQ 0x30(SP), CX											
  0x44dedc		488d91c8100000		LEAQ 0x10c8(CX), DX											
  0x44dee3		48891424		MOVQ DX, 0(SP)												
  0x44dee7		4889442408		MOVQ AX, 0x8(SP)											
  0x44deec		e80f49fbff		CALL runtime.f64hash(SB)										
  0x44def1		488b442410		MOVQ 0x10(SP), AX											
  0x44def6		488b4c2430		MOVQ 0x30(SP), CX											
  0x44defb		488d91d0100000		LEAQ 0x10d0(CX), DX											
  0x44df02		48891424		MOVQ DX, 0(SP)												
  0x44df06		4889442408		MOVQ AX, 0x8(SP)											
  0x44df0b		48c744241002000000	MOVQ $0x2, 0x10(SP)											
  0x44df14		e8a793fbff		CALL runtime.memhash(SB)										
  0x44df19		488b442418		MOVQ 0x18(SP), AX											
  0x44df1e		488b4c2430		MOVQ 0x30(SP), CX											
  0x44df23		488d91d8100000		LEAQ 0x10d8(CX), DX											
  0x44df2a		48891424		MOVQ DX, 0(SP)												
  0x44df2e		4889442408		MOVQ AX, 0x8(SP)											
  0x44df33		e898feffff		CALL type..hash.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44df38		488b442410		MOVQ 0x10(SP), AX											
  0x44df3d		488b4c2430		MOVQ 0x30(SP), CX											
  0x44df42		488d9120170000		LEAQ 0x1720(CX), DX											
  0x44df49		48891424		MOVQ DX, 0(SP)												
  0x44df4d		4889442408		MOVQ AX, 0x8(SP)											
  0x44df52		48c744241010000000	MOVQ $0x10, 0x10(SP)											
  0x44df5b		e86093fbff		CALL runtime.memhash(SB)										
  0x44df60		488b442418		MOVQ 0x18(SP), AX											
  0x44df65		488b4c2430		MOVQ 0x30(SP), CX											
  0x44df6a		488d9130170000		LEAQ 0x1730(CX), DX											
  0x44df71		48891424		MOVQ DX, 0(SP)												
  0x44df75		4889442408		MOVQ AX, 0x8(SP)											
  0x44df7a		e88148fbff		CALL runtime.f64hash(SB)										
  0x44df7f		488b442410		MOVQ 0x10(SP), AX											
  0x44df84		488b4c2430		MOVQ 0x30(SP), CX											
  0x44df89		4881c138170000		ADDQ $0x1738, CX											
  0x44df90		48890c24		MOVQ CX, 0(SP)												
  0x44df94		4889442408		MOVQ AX, 0x8(SP)											
  0x44df99		48c744241020000000	MOVQ $0x20, 0x10(SP)											
  0x44dfa2		e81993fbff		CALL runtime.memhash(SB)										
  0x44dfa7		488b442418		MOVQ 0x18(SP), AX											
  0x44dfac		4889442440		MOVQ AX, 0x40(SP)											
  0x44dfb1		488b6c2420		MOVQ 0x20(SP), BP											
  0x44dfb6		4883c428		ADDQ $0x28, SP												
  0x44dfba		c3			RET													
  0x44dfbb		e8c098ffff		CALL runtime.morestack_noctxt(SB)									
  0x44dfc0		e9cbfeffff		JMP type..hash.runtime.mstats(SB)									

TEXT type..eq.runtime.mstats(SB) <autogenerated>

  0x44dfd0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44dfd9		483b6110		CMPQ 0x10(CX), SP											
  0x44dfdd		0f865e010000		JBE 0x44e141												
  0x44dfe3		4883ec28		SUBQ $0x28, SP												
  0x44dfe7		48896c2420		MOVQ BP, 0x20(SP)											
  0x44dfec		488d6c2420		LEAQ 0x20(SP), BP											
  0x44dff1		488b442430		MOVQ 0x30(SP), AX											
  0x44dff6		48890424		MOVQ AX, 0(SP)												
  0x44dffa		488b4c2438		MOVQ 0x38(SP), CX											
  0x44dfff		48894c2408		MOVQ CX, 0x8(SP)											
  0x44e004		48c7442410c8100000	MOVQ $0x10c8, 0x10(SP)											
  0x44e00d		e80e42fbff		CALL runtime.memequal(SB)										
  0x44e012		807c241800		CMPB $0x0, 0x18(SP)											
  0x44e017		0f8413010000		JE 0x44e130												
  0x44e01d		488b442430		MOVQ 0x30(SP), AX											
  0x44e022		f20f1080c8100000	MOVSD_XMM 0x10c8(AX), X0										
  0x44e02a		488b4c2438		MOVQ 0x38(SP), CX											
  0x44e02f		f20f1089c8100000	MOVSD_XMM 0x10c8(CX), X1										
  0x44e037		660f2ec8		UCOMISD X0, X1												
  0x44e03b		0f85e8000000		JNE 0x44e129												
  0x44e041		0f8ae2000000		JP 0x44e129												
  0x44e047		0fb690d0100000		MOVZX 0x10d0(AX), DX											
  0x44e04e		3891d0100000		CMPB DL, 0x10d0(CX)											
  0x44e054		0f85c8000000		JNE 0x44e122												
  0x44e05a		0fb690d1100000		MOVZX 0x10d1(AX), DX											
  0x44e061		3891d1100000		CMPB DL, 0x10d1(CX)											
  0x44e067		0f8485000000		JE 0x44e0f2												
  0x44e06d		31d2			XORL DX, DX												
  0x44e06f		84d2			TESTL DL, DL												
  0x44e071		747b			JE 0x44e0ee												
  0x44e073		488b9120170000		MOVQ 0x1720(CX), DX											
  0x44e07a		48399020170000		CMPQ DX, 0x1720(AX)											
  0x44e081		7567			JNE 0x44e0ea												
  0x44e083		488b9128170000		MOVQ 0x1728(CX), DX											
  0x44e08a		48399028170000		CMPQ DX, 0x1728(AX)											
  0x44e091		7553			JNE 0x44e0e6												
  0x44e093		f20f108130170000	MOVSD_XMM 0x1730(CX), X0										
  0x44e09b		f20f108830170000	MOVSD_XMM 0x1730(AX), X1										
  0x44e0a3		660f2ec1		UCOMISD X1, X0												
  0x44e0a7		7502			JNE 0x44e0ab												
  0x44e0a9		7b10			JNP 0x44e0bb												
  0x44e0ab		31c0			XORL AX, AX												
  0x44e0ad		88442440		MOVB AL, 0x40(SP)											
  0x44e0b1		488b6c2420		MOVQ 0x20(SP), BP											
  0x44e0b6		4883c428		ADDQ $0x28, SP												
  0x44e0ba		c3			RET													
  0x44e0bb		480538170000		ADDQ $0x1738, AX											
  0x44e0c1		48890424		MOVQ AX, 0(SP)												
  0x44e0c5		488d8138170000		LEAQ 0x1738(CX), AX											
  0x44e0cc		4889442408		MOVQ AX, 0x8(SP)											
  0x44e0d1		48c744241020000000	MOVQ $0x20, 0x10(SP)											
  0x44e0da		e84141fbff		CALL runtime.memequal(SB)										
  0x44e0df		0fb6442418		MOVZX 0x18(SP), AX											
  0x44e0e4		ebc7			JMP 0x44e0ad												
  0x44e0e6		31c0			XORL AX, AX												
  0x44e0e8		ebc3			JMP 0x44e0ad												
  0x44e0ea		31c0			XORL AX, AX												
  0x44e0ec		ebbf			JMP 0x44e0ad												
  0x44e0ee		31c0			XORL AX, AX												
  0x44e0f0		ebbb			JMP 0x44e0ad												
  0x44e0f2		488d90d8100000		LEAQ 0x10d8(AX), DX											
  0x44e0f9		48891424		MOVQ DX, 0(SP)												
  0x44e0fd		488d91d8100000		LEAQ 0x10d8(CX), DX											
  0x44e104		4889542408		MOVQ DX, 0x8(SP)											
  0x44e109		e832fdffff		CALL type..eq.[67]struct { runtime.size uint32; runtime.nmalloc uint64; runtime.nfree uint64 }(SB)	
  0x44e10e		0fb6542410		MOVZX 0x10(SP), DX											
  0x44e113		488b442430		MOVQ 0x30(SP), AX											
  0x44e118		488b4c2438		MOVQ 0x38(SP), CX											
  0x44e11d		e94dffffff		JMP 0x44e06f												
  0x44e122		31d2			XORL DX, DX												
  0x44e124		e946ffffff		JMP 0x44e06f												
  0x44e129		31d2			XORL DX, DX												
  0x44e12b		e93fffffff		JMP 0x44e06f												
  0x44e130		488b442430		MOVQ 0x30(SP), AX											
  0x44e135		488b4c2438		MOVQ 0x38(SP), CX											
  0x44e13a		31d2			XORL DX, DX												
  0x44e13c		e92effffff		JMP 0x44e06f												
  0x44e141		e83a97ffff		CALL runtime.morestack_noctxt(SB)									
  0x44e146		e985feffff		JMP type..eq.runtime.mstats(SB)										

TEXT runtime.(*plainError).Error(SB) <autogenerated>

  0x44e150		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x44e159		4883ec08		SUBQ $0x8, SP			
  0x44e15d		48892c24		MOVQ BP, 0(SP)			
  0x44e161		488d2c24		LEAQ 0(SP), BP			
  0x44e165		488b5920		MOVQ 0x20(CX), BX		
  0x44e169		4885db			TESTQ BX, BX			
  0x44e16c		752c			JNE 0x44e19a			
  0x44e16e		488b442410		MOVQ 0x10(SP), AX		
  0x44e173		4885c0			TESTQ AX, AX			
  0x44e176		741b			JE 0x44e193			
  0x44e178		488b4808		MOVQ 0x8(AX), CX		
  0x44e17c		90			NOPL				
  0x44e17d		488b00			MOVQ 0(AX), AX			
  0x44e180		4889442418		MOVQ AX, 0x18(SP)		
  0x44e185		48894c2420		MOVQ CX, 0x20(SP)		
  0x44e18a		488b2c24		MOVQ 0(SP), BP			
  0x44e18e		4883c408		ADDQ $0x8, SP			
  0x44e192		c3			RET				
  0x44e193		e8188dfbff		CALL runtime.panicwrap(SB)	
  0x44e198		0f0b			UD2				
  0x44e19a		488d7c2410		LEAQ 0x10(SP), DI		
  0x44e19f		48393b			CMPQ DI, 0(BX)			
  0x44e1a2		75ca			JNE 0x44e16e			
  0x44e1a4		488923			MOVQ SP, 0(BX)			
  0x44e1a7		ebc5			JMP 0x44e16e			

TEXT type..hash.struct { runtime.user bool; runtime.runnable runtime.gQueue; runtime.n int32 }(SB) <autogenerated>

  0x44e1b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX											
  0x44e1b9		483b6110		CMPQ 0x10(CX), SP											
  0x44e1bd		7668			JBE 0x44e227												
  0x44e1bf		4883ec28		SUBQ $0x28, SP												
  0x44e1c3		48896c2420		MOVQ BP, 0x20(SP)											
  0x44e1c8		488d6c2420		LEAQ 0x20(SP), BP											
  0x44e1cd		488b442430		MOVQ 0x30(SP), AX											
  0x44e1d2		48890424		MOVQ AX, 0(SP)												
  0x44e1d6		488b4c2438		MOVQ 0x38(SP), CX											
  0x44e1db		48894c2408		MOVQ CX, 0x8(SP)											
  0x44e1e0		48c744241001000000	MOVQ $0x1, 0x10(SP)											
  0x44e1e9		e8d290fbff		CALL runtime.memhash(SB)										
  0x44e1ee		488b442418		MOVQ 0x18(SP), AX											
  0x44e1f3		488b4c2430		MOVQ 0x30(SP), CX											
  0x44e1f8		4883c108		ADDQ $0x8, CX												
  0x44e1fc		48890c24		MOVQ CX, 0(SP)												
  0x44e200		4889442408		MOVQ AX, 0x8(SP)											
  0x44e205		48c744241014000000	MOVQ $0x14, 0x10(SP)											
  0x44e20e		e8ad90fbff		CALL runtime.memhash(SB)										
  0x44e213		488b442418		MOVQ 0x18(SP), AX											
  0x44e218		4889442440		MOVQ AX, 0x40(SP)											
  0x44e21d		488b6c2420		MOVQ 0x20(SP), BP											
  0x44e222		4883c428		ADDQ $0x28, SP												
  0x44e226		c3			RET													
  0x44e227		e85496ffff		CALL runtime.morestack_noctxt(SB)									
  0x44e22c		eb82			JMP type..hash.struct { runtime.user bool; runtime.runnable runtime.gQueue; runtime.n int32 }(SB)	

TEXT type..eq.struct { runtime.user bool; runtime.runnable runtime.gQueue; runtime.n int32 }(SB) <autogenerated>

  0x44e230		488b442410		MOVQ 0x10(SP), AX	
  0x44e235		0fb608			MOVZX 0(AX), CX		
  0x44e238		488b542408		MOVQ 0x8(SP), DX	
  0x44e23d		380a			CMPB CL, 0(DX)		
  0x44e23f		752f			JNE 0x44e270		
  0x44e241		488b4808		MOVQ 0x8(AX), CX	
  0x44e245		48394a08		CMPQ CX, 0x8(DX)	
  0x44e249		7521			JNE 0x44e26c		
  0x44e24b		488b4810		MOVQ 0x10(AX), CX	
  0x44e24f		48394a10		CMPQ CX, 0x10(DX)	
  0x44e253		0f94c1			SETE CL			
  0x44e256		84c9			TESTL CL, CL		
  0x44e258		740e			JE 0x44e268		
  0x44e25a		8b4018			MOVL 0x18(AX), AX	
  0x44e25d		394218			CMPL AX, 0x18(DX)	
  0x44e260		0f94c0			SETE AL			
  0x44e263		88442418		MOVB AL, 0x18(SP)	
  0x44e267		c3			RET			
  0x44e268		31c0			XORL AX, AX		
  0x44e26a		ebf7			JMP 0x44e263		
  0x44e26c		31c9			XORL CX, CX		
  0x44e26e		ebe6			JMP 0x44e256		
  0x44e270		31c0			XORL AX, AX		
  0x44e272		ebef			JMP 0x44e263		

TEXT type..hash.struct { runtime.lock runtime.mutex; runtime.stack runtime.gList; runtime.noStack runtime.gList; runtime.n int32 }(SB) <autogenerated>

  0x44e280		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44e289		483b6110		CMPQ 0x10(CX), SP															
  0x44e28d		7643			JBE 0x44e2d2																
  0x44e28f		4883ec28		SUBQ $0x28, SP																
  0x44e293		48896c2420		MOVQ BP, 0x20(SP)															
  0x44e298		488d6c2420		LEAQ 0x20(SP), BP															
  0x44e29d		488b442430		MOVQ 0x30(SP), AX															
  0x44e2a2		48890424		MOVQ AX, 0(SP)																
  0x44e2a6		488b442438		MOVQ 0x38(SP), AX															
  0x44e2ab		4889442408		MOVQ AX, 0x8(SP)															
  0x44e2b0		48c74424101c000000	MOVQ $0x1c, 0x10(SP)															
  0x44e2b9		e80290fbff		CALL runtime.memhash(SB)														
  0x44e2be		488b442418		MOVQ 0x18(SP), AX															
  0x44e2c3		4889442440		MOVQ AX, 0x40(SP)															
  0x44e2c8		488b6c2420		MOVQ 0x20(SP), BP															
  0x44e2cd		4883c428		ADDQ $0x28, SP																
  0x44e2d1		c3			RET																	
  0x44e2d2		e8a995ffff		CALL runtime.morestack_noctxt(SB)													
  0x44e2d7		eba7			JMP type..hash.struct { runtime.lock runtime.mutex; runtime.stack runtime.gList; runtime.noStack runtime.gList; runtime.n int32 }(SB)	

TEXT type..eq.struct { runtime.lock runtime.mutex; runtime.stack runtime.gList; runtime.noStack runtime.gList; runtime.n int32 }(SB) <autogenerated>

  0x44e2e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44e2e9		483b6110		CMPQ 0x10(CX), SP															
  0x44e2ed		7642			JBE 0x44e331																
  0x44e2ef		4883ec28		SUBQ $0x28, SP																
  0x44e2f3		48896c2420		MOVQ BP, 0x20(SP)															
  0x44e2f8		488d6c2420		LEAQ 0x20(SP), BP															
  0x44e2fd		488b442430		MOVQ 0x30(SP), AX															
  0x44e302		48890424		MOVQ AX, 0(SP)																
  0x44e306		488b442438		MOVQ 0x38(SP), AX															
  0x44e30b		4889442408		MOVQ AX, 0x8(SP)															
  0x44e310		48c74424101c000000	MOVQ $0x1c, 0x10(SP)															
  0x44e319		e8023ffbff		CALL runtime.memequal(SB)														
  0x44e31e		0fb6442418		MOVZX 0x18(SP), AX															
  0x44e323		88442440		MOVB AL, 0x40(SP)															
  0x44e327		488b6c2420		MOVQ 0x20(SP), BP															
  0x44e32c		4883c428		ADDQ $0x28, SP																
  0x44e330		c3			RET																	
  0x44e331		e84a95ffff		CALL runtime.morestack_noctxt(SB)													
  0x44e336		eba8			JMP type..eq.struct { runtime.lock runtime.mutex; runtime.stack runtime.gList; runtime.noStack runtime.gList; runtime.n int32 }(SB)	

TEXT type..hash.runtime.semaRoot(SB) <autogenerated>

  0x44e340		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e349		483b6110		CMPQ 0x10(CX), SP			
  0x44e34d		7643			JBE 0x44e392				
  0x44e34f		4883ec28		SUBQ $0x28, SP				
  0x44e353		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e358		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e35d		488b442430		MOVQ 0x30(SP), AX			
  0x44e362		48890424		MOVQ AX, 0(SP)				
  0x44e366		488b442438		MOVQ 0x38(SP), AX			
  0x44e36b		4889442408		MOVQ AX, 0x8(SP)			
  0x44e370		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44e379		e8428ffbff		CALL runtime.memhash(SB)		
  0x44e37e		488b442418		MOVQ 0x18(SP), AX			
  0x44e383		4889442440		MOVQ AX, 0x40(SP)			
  0x44e388		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e38d		4883c428		ADDQ $0x28, SP				
  0x44e391		c3			RET					
  0x44e392		e8e994ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e397		eba7			JMP type..hash.runtime.semaRoot(SB)	

TEXT type..eq.runtime.semaRoot(SB) <autogenerated>

  0x44e3a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e3a9		483b6110		CMPQ 0x10(CX), SP			
  0x44e3ad		7642			JBE 0x44e3f1				
  0x44e3af		4883ec28		SUBQ $0x28, SP				
  0x44e3b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e3b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e3bd		488b442430		MOVQ 0x30(SP), AX			
  0x44e3c2		48890424		MOVQ AX, 0(SP)				
  0x44e3c6		488b442438		MOVQ 0x38(SP), AX			
  0x44e3cb		4889442408		MOVQ AX, 0x8(SP)			
  0x44e3d0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44e3d9		e8423efbff		CALL runtime.memequal(SB)		
  0x44e3de		0fb6442418		MOVZX 0x18(SP), AX			
  0x44e3e3		88442440		MOVB AL, 0x40(SP)			
  0x44e3e7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e3ec		4883c428		ADDQ $0x28, SP				
  0x44e3f0		c3			RET					
  0x44e3f1		e88a94ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e3f6		eba8			JMP type..eq.runtime.semaRoot(SB)	

TEXT type..hash.runtime.sigTabT(SB) <autogenerated>

  0x44e400		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e409		483b6110		CMPQ 0x10(CX), SP			
  0x44e40d		765f			JBE 0x44e46e				
  0x44e40f		4883ec28		SUBQ $0x28, SP				
  0x44e413		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e418		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e41d		488b442430		MOVQ 0x30(SP), AX			
  0x44e422		48890424		MOVQ AX, 0(SP)				
  0x44e426		488b4c2438		MOVQ 0x38(SP), CX			
  0x44e42b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e430		48c744241004000000	MOVQ $0x4, 0x10(SP)			
  0x44e439		e8828efbff		CALL runtime.memhash(SB)		
  0x44e43e		488b442418		MOVQ 0x18(SP), AX			
  0x44e443		488b4c2430		MOVQ 0x30(SP), CX			
  0x44e448		4883c108		ADDQ $0x8, CX				
  0x44e44c		48890c24		MOVQ CX, 0(SP)				
  0x44e450		4889442408		MOVQ AX, 0x8(SP)			
  0x44e455		e82642fbff		CALL runtime.strhash(SB)		
  0x44e45a		488b442410		MOVQ 0x10(SP), AX			
  0x44e45f		4889442440		MOVQ AX, 0x40(SP)			
  0x44e464		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e469		4883c428		ADDQ $0x28, SP				
  0x44e46d		c3			RET					
  0x44e46e		e80d94ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e473		eb8b			JMP type..hash.runtime.sigTabT(SB)	

TEXT type..eq.runtime.sigTabT(SB) <autogenerated>

  0x44e480		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e489		483b6110		CMPQ 0x10(CX), SP			
  0x44e48d		765e			JBE 0x44e4ed				
  0x44e48f		4883ec28		SUBQ $0x28, SP				
  0x44e493		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e498		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e49d		488b442438		MOVQ 0x38(SP), AX			
  0x44e4a2		8b08			MOVL 0(AX), CX				
  0x44e4a4		488b542430		MOVQ 0x30(SP), DX			
  0x44e4a9		390a			CMPL CX, 0(DX)				
  0x44e4ab		753c			JNE 0x44e4e9				
  0x44e4ad		488b4808		MOVQ 0x8(AX), CX			
  0x44e4b1		488b5a10		MOVQ 0x10(DX), BX			
  0x44e4b5		488b5208		MOVQ 0x8(DX), DX			
  0x44e4b9		48395810		CMPQ BX, 0x10(AX)			
  0x44e4bd		7410			JE 0x44e4cf				
  0x44e4bf		31c0			XORL AX, AX				
  0x44e4c1		88442440		MOVB AL, 0x40(SP)			
  0x44e4c5		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e4ca		4883c428		ADDQ $0x28, SP				
  0x44e4ce		c3			RET					
  0x44e4cf		48891424		MOVQ DX, 0(SP)				
  0x44e4d3		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e4d8		48895c2410		MOVQ BX, 0x10(SP)			
  0x44e4dd		e83e3dfbff		CALL runtime.memequal(SB)		
  0x44e4e2		0fb6442418		MOVZX 0x18(SP), AX			
  0x44e4e7		ebd8			JMP 0x44e4c1				
  0x44e4e9		31c0			XORL AX, AX				
  0x44e4eb		ebd4			JMP 0x44e4c1				
  0x44e4ed		e88e93ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e4f2		eb8c			JMP type..eq.runtime.sigTabT(SB)	

TEXT type..hash.runtime.stackmap(SB) <autogenerated>

  0x44e500		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e509		483b6110		CMPQ 0x10(CX), SP			
  0x44e50d		7643			JBE 0x44e552				
  0x44e50f		4883ec28		SUBQ $0x28, SP				
  0x44e513		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e518		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e51d		488b442430		MOVQ 0x30(SP), AX			
  0x44e522		48890424		MOVQ AX, 0(SP)				
  0x44e526		488b442438		MOVQ 0x38(SP), AX			
  0x44e52b		4889442408		MOVQ AX, 0x8(SP)			
  0x44e530		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44e539		e8828dfbff		CALL runtime.memhash(SB)		
  0x44e53e		488b442418		MOVQ 0x18(SP), AX			
  0x44e543		4889442440		MOVQ AX, 0x40(SP)			
  0x44e548		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e54d		4883c428		ADDQ $0x28, SP				
  0x44e551		c3			RET					
  0x44e552		e82993ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e557		eba7			JMP type..hash.runtime.stackmap(SB)	

TEXT type..eq.runtime.stackmap(SB) <autogenerated>

  0x44e560		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e569		483b6110		CMPQ 0x10(CX), SP			
  0x44e56d		7642			JBE 0x44e5b1				
  0x44e56f		4883ec28		SUBQ $0x28, SP				
  0x44e573		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e578		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e57d		488b442430		MOVQ 0x30(SP), AX			
  0x44e582		48890424		MOVQ AX, 0(SP)				
  0x44e586		488b442438		MOVQ 0x38(SP), AX			
  0x44e58b		4889442408		MOVQ AX, 0x8(SP)			
  0x44e590		48c744241009000000	MOVQ $0x9, 0x10(SP)			
  0x44e599		e8823cfbff		CALL runtime.memequal(SB)		
  0x44e59e		0fb6442418		MOVZX 0x18(SP), AX			
  0x44e5a3		88442440		MOVB AL, 0x40(SP)			
  0x44e5a7		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e5ac		4883c428		ADDQ $0x28, SP				
  0x44e5b0		c3			RET					
  0x44e5b1		e8ca92ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e5b6		eba8			JMP type..eq.runtime.stackmap(SB)	

TEXT type..hash.runtime.sweepdata(SB) <autogenerated>

  0x44e5c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e5c9		483b6110		CMPQ 0x10(CX), SP			
  0x44e5cd		7668			JBE 0x44e637				
  0x44e5cf		4883ec28		SUBQ $0x28, SP				
  0x44e5d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e5d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e5dd		488b442430		MOVQ 0x30(SP), AX			
  0x44e5e2		48890424		MOVQ AX, 0(SP)				
  0x44e5e6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44e5eb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e5f0		48c744241012000000	MOVQ $0x12, 0x10(SP)			
  0x44e5f9		e8c28cfbff		CALL runtime.memhash(SB)		
  0x44e5fe		488b442418		MOVQ 0x18(SP), AX			
  0x44e603		488b4c2430		MOVQ 0x30(SP), CX			
  0x44e608		4883c114		ADDQ $0x14, CX				
  0x44e60c		48890c24		MOVQ CX, 0(SP)				
  0x44e610		4889442408		MOVQ AX, 0x8(SP)			
  0x44e615		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44e61e		e89d8cfbff		CALL runtime.memhash(SB)		
  0x44e623		488b442418		MOVQ 0x18(SP), AX			
  0x44e628		4889442440		MOVQ AX, 0x40(SP)			
  0x44e62d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e632		4883c428		ADDQ $0x28, SP				
  0x44e636		c3			RET					
  0x44e637		e84492ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e63c		eb82			JMP type..hash.runtime.sweepdata(SB)	

TEXT type..eq.runtime.sweepdata(SB) <autogenerated>

  0x44e640		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e649		483b6110		CMPQ 0x10(CX), SP			
  0x44e64d		7667			JBE 0x44e6b6				
  0x44e64f		4883ec28		SUBQ $0x28, SP				
  0x44e653		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e658		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e65d		488b442430		MOVQ 0x30(SP), AX			
  0x44e662		48890424		MOVQ AX, 0(SP)				
  0x44e666		488b4c2438		MOVQ 0x38(SP), CX			
  0x44e66b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e670		48c744241012000000	MOVQ $0x12, 0x10(SP)			
  0x44e679		e8a23bfbff		CALL runtime.memequal(SB)		
  0x44e67e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44e683		742d			JE 0x44e6b2				
  0x44e685		488b442438		MOVQ 0x38(SP), AX			
  0x44e68a		8b4814			MOVL 0x14(AX), CX			
  0x44e68d		488b542430		MOVQ 0x30(SP), DX			
  0x44e692		394a14			CMPL CX, 0x14(DX)			
  0x44e695		7517			JNE 0x44e6ae				
  0x44e697		8b4a18			MOVL 0x18(DX), CX			
  0x44e69a		394818			CMPL CX, 0x18(AX)			
  0x44e69d		0f94c0			SETE AL					
  0x44e6a0		88442440		MOVB AL, 0x40(SP)			
  0x44e6a4		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e6a9		4883c428		ADDQ $0x28, SP				
  0x44e6ad		c3			RET					
  0x44e6ae		31c0			XORL AX, AX				
  0x44e6b0		ebee			JMP 0x44e6a0				
  0x44e6b2		31c0			XORL AX, AX				
  0x44e6b4		ebea			JMP 0x44e6a0				
  0x44e6b6		e8c591ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e6bb		eb83			JMP type..eq.runtime.sweepdata(SB)	

TEXT type..hash.runtime.traceStack(SB) <autogenerated>

  0x44e6c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e6c9		483b6110		CMPQ 0x10(CX), SP			
  0x44e6cd		7668			JBE 0x44e737				
  0x44e6cf		4883ec28		SUBQ $0x28, SP				
  0x44e6d3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e6d8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e6dd		488b442430		MOVQ 0x30(SP), AX			
  0x44e6e2		48890424		MOVQ AX, 0(SP)				
  0x44e6e6		488b4c2438		MOVQ 0x38(SP), CX			
  0x44e6eb		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e6f0		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44e6f9		e8c28bfbff		CALL runtime.memhash(SB)		
  0x44e6fe		488b442418		MOVQ 0x18(SP), AX			
  0x44e703		488b4c2430		MOVQ 0x30(SP), CX			
  0x44e708		4883c118		ADDQ $0x18, CX				
  0x44e70c		48890c24		MOVQ CX, 0(SP)				
  0x44e710		4889442408		MOVQ AX, 0x8(SP)			
  0x44e715		48c744241008000000	MOVQ $0x8, 0x10(SP)			
  0x44e71e		e89d8bfbff		CALL runtime.memhash(SB)		
  0x44e723		488b442418		MOVQ 0x18(SP), AX			
  0x44e728		4889442440		MOVQ AX, 0x40(SP)			
  0x44e72d		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e732		4883c428		ADDQ $0x28, SP				
  0x44e736		c3			RET					
  0x44e737		e84491ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e73c		eb82			JMP type..hash.runtime.traceStack(SB)	

TEXT type..eq.runtime.traceStack(SB) <autogenerated>

  0x44e740		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e749		483b6110		CMPQ 0x10(CX), SP			
  0x44e74d		7665			JBE 0x44e7b4				
  0x44e74f		4883ec28		SUBQ $0x28, SP				
  0x44e753		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e758		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e75d		488b442430		MOVQ 0x30(SP), AX			
  0x44e762		48890424		MOVQ AX, 0(SP)				
  0x44e766		488b4c2438		MOVQ 0x38(SP), CX			
  0x44e76b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e770		48c744241014000000	MOVQ $0x14, 0x10(SP)			
  0x44e779		e8a23afbff		CALL runtime.memequal(SB)		
  0x44e77e		807c241800		CMPB $0x0, 0x18(SP)			
  0x44e783		742b			JE 0x44e7b0				
  0x44e785		488b442438		MOVQ 0x38(SP), AX			
  0x44e78a		488b4018		MOVQ 0x18(AX), AX			
  0x44e78e		488b4c2430		MOVQ 0x30(SP), CX			
  0x44e793		48394118		CMPQ AX, 0x18(CX)			
  0x44e797		7513			JNE 0x44e7ac				
  0x44e799		b801000000		MOVL $0x1, AX				
  0x44e79e		88442440		MOVB AL, 0x40(SP)			
  0x44e7a2		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e7a7		4883c428		ADDQ $0x28, SP				
  0x44e7ab		c3			RET					
  0x44e7ac		31c0			XORL AX, AX				
  0x44e7ae		ebee			JMP 0x44e79e				
  0x44e7b0		31c0			XORL AX, AX				
  0x44e7b2		ebea			JMP 0x44e79e				
  0x44e7b4		e8c790ffff		CALL runtime.morestack_noctxt(SB)	
  0x44e7b9		eb85			JMP type..eq.runtime.traceStack(SB)	

TEXT type..hash.runtime.traceStackTable(SB) <autogenerated>

  0x44e7c0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44e7c9		483b6110		CMPQ 0x10(CX), SP				
  0x44e7cd		7668			JBE 0x44e837					
  0x44e7cf		4883ec28		SUBQ $0x28, SP					
  0x44e7d3		48896c2420		MOVQ BP, 0x20(SP)				
  0x44e7d8		488d6c2420		LEAQ 0x20(SP), BP				
  0x44e7dd		488b442430		MOVQ 0x30(SP), AX				
  0x44e7e2		48890424		MOVQ AX, 0(SP)					
  0x44e7e6		488b4c2438		MOVQ 0x38(SP), CX				
  0x44e7eb		48894c2408		MOVQ CX, 0x8(SP)				
  0x44e7f0		48c74424100c000000	MOVQ $0xc, 0x10(SP)				
  0x44e7f9		e8c28afbff		CALL runtime.memhash(SB)			
  0x44e7fe		488b442418		MOVQ 0x18(SP), AX				
  0x44e803		488b4c2430		MOVQ 0x30(SP), CX				
  0x44e808		4883c110		ADDQ $0x10, CX					
  0x44e80c		48890c24		MOVQ CX, 0(SP)					
  0x44e810		4889442408		MOVQ AX, 0x8(SP)				
  0x44e815		48c744241010000100	MOVQ $0x10010, 0x10(SP)				
  0x44e81e		e89d8afbff		CALL runtime.memhash(SB)			
  0x44e823		488b442418		MOVQ 0x18(SP), AX				
  0x44e828		4889442440		MOVQ AX, 0x40(SP)				
  0x44e82d		488b6c2420		MOVQ 0x20(SP), BP				
  0x44e832		4883c428		ADDQ $0x28, SP					
  0x44e836		c3			RET						
  0x44e837		e84490ffff		CALL runtime.morestack_noctxt(SB)		
  0x44e83c		eb82			JMP type..hash.runtime.traceStackTable(SB)	

TEXT type..eq.runtime.traceStackTable(SB) <autogenerated>

  0x44e840		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44e849		483b6110		CMPQ 0x10(CX), SP				
  0x44e84d		0f8683000000		JBE 0x44e8d6					
  0x44e853		4883ec28		SUBQ $0x28, SP					
  0x44e857		48896c2420		MOVQ BP, 0x20(SP)				
  0x44e85c		488d6c2420		LEAQ 0x20(SP), BP				
  0x44e861		488b442438		MOVQ 0x38(SP), AX				
  0x44e866		488b08			MOVQ 0(AX), CX					
  0x44e869		488b542430		MOVQ 0x30(SP), DX				
  0x44e86e		48390a			CMPQ CX, 0(DX)					
  0x44e871		755f			JNE 0x44e8d2					
  0x44e873		8b4808			MOVL 0x8(AX), CX				
  0x44e876		394a08			CMPL CX, 0x8(DX)				
  0x44e879		7553			JNE 0x44e8ce					
  0x44e87b		488b4810		MOVQ 0x10(AX), CX				
  0x44e87f		48394a10		CMPQ CX, 0x10(DX)				
  0x44e883		7545			JNE 0x44e8ca					
  0x44e885		488b4a18		MOVQ 0x18(DX), CX				
  0x44e889		48394818		CMPQ CX, 0x18(AX)				
  0x44e88d		0f94c1			SETE CL						
  0x44e890		84c9			TESTL CL, CL					
  0x44e892		7510			JNE 0x44e8a4					
  0x44e894		31c0			XORL AX, AX					
  0x44e896		88442440		MOVB AL, 0x40(SP)				
  0x44e89a		488b6c2420		MOVQ 0x20(SP), BP				
  0x44e89f		4883c428		ADDQ $0x28, SP					
  0x44e8a3		c3			RET						
  0x44e8a4		488d4a20		LEAQ 0x20(DX), CX				
  0x44e8a8		48890c24		MOVQ CX, 0(SP)					
  0x44e8ac		4883c020		ADDQ $0x20, AX					
  0x44e8b0		4889442408		MOVQ AX, 0x8(SP)				
  0x44e8b5		48c744241000000100	MOVQ $0x10000, 0x10(SP)				
  0x44e8be		e85d39fbff		CALL runtime.memequal(SB)			
  0x44e8c3		0fb6442418		MOVZX 0x18(SP), AX				
  0x44e8c8		ebcc			JMP 0x44e896					
  0x44e8ca		31c9			XORL CX, CX					
  0x44e8cc		ebc2			JMP 0x44e890					
  0x44e8ce		31c0			XORL AX, AX					
  0x44e8d0		ebc4			JMP 0x44e896					
  0x44e8d2		31c0			XORL AX, AX					
  0x44e8d4		ebc0			JMP 0x44e896					
  0x44e8d6		e8a58fffff		CALL runtime.morestack_noctxt(SB)		
  0x44e8db		e960ffffff		JMP type..eq.runtime.traceStackTable(SB)	

TEXT type..hash.runtime.vdsoSymbolKey(SB) <autogenerated>

  0x44e8e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44e8e9		483b6110		CMPQ 0x10(CX), SP				
  0x44e8ed		765f			JBE 0x44e94e					
  0x44e8ef		4883ec28		SUBQ $0x28, SP					
  0x44e8f3		48896c2420		MOVQ BP, 0x20(SP)				
  0x44e8f8		488d6c2420		LEAQ 0x20(SP), BP				
  0x44e8fd		488b442430		MOVQ 0x30(SP), AX				
  0x44e902		48890424		MOVQ AX, 0(SP)					
  0x44e906		488b4c2438		MOVQ 0x38(SP), CX				
  0x44e90b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44e910		e86b3dfbff		CALL runtime.strhash(SB)			
  0x44e915		488b442410		MOVQ 0x10(SP), AX				
  0x44e91a		488b4c2430		MOVQ 0x30(SP), CX				
  0x44e91f		4883c110		ADDQ $0x10, CX					
  0x44e923		48890c24		MOVQ CX, 0(SP)					
  0x44e927		4889442408		MOVQ AX, 0x8(SP)				
  0x44e92c		48c744241010000000	MOVQ $0x10, 0x10(SP)				
  0x44e935		e88689fbff		CALL runtime.memhash(SB)			
  0x44e93a		488b442418		MOVQ 0x18(SP), AX				
  0x44e93f		4889442440		MOVQ AX, 0x40(SP)				
  0x44e944		488b6c2420		MOVQ 0x20(SP), BP				
  0x44e949		4883c428		ADDQ $0x28, SP					
  0x44e94d		c3			RET						
  0x44e94e		e82d8fffff		CALL runtime.morestack_noctxt(SB)		
  0x44e953		eb8b			JMP type..hash.runtime.vdsoSymbolKey(SB)	

TEXT type..eq.runtime.vdsoSymbolKey(SB) <autogenerated>

  0x44e960		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44e969		483b6110		CMPQ 0x10(CX), SP			
  0x44e96d		767f			JBE 0x44e9ee				
  0x44e96f		4883ec28		SUBQ $0x28, SP				
  0x44e973		48896c2420		MOVQ BP, 0x20(SP)			
  0x44e978		488d6c2420		LEAQ 0x20(SP), BP			
  0x44e97d		488b442438		MOVQ 0x38(SP), AX			
  0x44e982		488b08			MOVQ 0(AX), CX				
  0x44e985		488b542430		MOVQ 0x30(SP), DX			
  0x44e98a		488b1a			MOVQ 0(DX), BX				
  0x44e98d		488b7208		MOVQ 0x8(DX), SI			
  0x44e991		48397008		CMPQ SI, 0x8(AX)			
  0x44e995		7433			JE 0x44e9ca				
  0x44e997		31c9			XORL CX, CX				
  0x44e999		84c9			TESTL CL, CL				
  0x44e99b		7510			JNE 0x44e9ad				
  0x44e99d		31c0			XORL AX, AX				
  0x44e99f		88442440		MOVB AL, 0x40(SP)			
  0x44e9a3		488b6c2420		MOVQ 0x20(SP), BP			
  0x44e9a8		4883c428		ADDQ $0x28, SP				
  0x44e9ac		c3			RET					
  0x44e9ad		488d4a10		LEAQ 0x10(DX), CX			
  0x44e9b1		48890c24		MOVQ CX, 0(SP)				
  0x44e9b5		4883c010		ADDQ $0x10, AX				
  0x44e9b9		4889442408		MOVQ AX, 0x8(SP)			
  0x44e9be		e8ad43fbff		CALL runtime.memequal128(SB)		
  0x44e9c3		0fb6442410		MOVZX 0x10(SP), AX			
  0x44e9c8		ebd5			JMP 0x44e99f				
  0x44e9ca		48891c24		MOVQ BX, 0(SP)				
  0x44e9ce		48894c2408		MOVQ CX, 0x8(SP)			
  0x44e9d3		4889742410		MOVQ SI, 0x10(SP)			
  0x44e9d8		e84338fbff		CALL runtime.memequal(SB)		
  0x44e9dd		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44e9e2		488b442438		MOVQ 0x38(SP), AX			
  0x44e9e7		488b542430		MOVQ 0x30(SP), DX			
  0x44e9ec		ebab			JMP 0x44e999				
  0x44e9ee		e88d8effff		CALL runtime.morestack_noctxt(SB)	
  0x44e9f3		e968ffffff		JMP type..eq.runtime.vdsoSymbolKey(SB)	

TEXT type..hash.runtime.vdsoVersionKey(SB) <autogenerated>

  0x44ea00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44ea09		483b6110		CMPQ 0x10(CX), SP				
  0x44ea0d		765f			JBE 0x44ea6e					
  0x44ea0f		4883ec28		SUBQ $0x28, SP					
  0x44ea13		48896c2420		MOVQ BP, 0x20(SP)				
  0x44ea18		488d6c2420		LEAQ 0x20(SP), BP				
  0x44ea1d		488b442430		MOVQ 0x30(SP), AX				
  0x44ea22		48890424		MOVQ AX, 0(SP)					
  0x44ea26		488b4c2438		MOVQ 0x38(SP), CX				
  0x44ea2b		48894c2408		MOVQ CX, 0x8(SP)				
  0x44ea30		e84b3cfbff		CALL runtime.strhash(SB)			
  0x44ea35		488b442410		MOVQ 0x10(SP), AX				
  0x44ea3a		488b4c2430		MOVQ 0x30(SP), CX				
  0x44ea3f		4883c110		ADDQ $0x10, CX					
  0x44ea43		48890c24		MOVQ CX, 0(SP)					
  0x44ea47		4889442408		MOVQ AX, 0x8(SP)				
  0x44ea4c		48c744241004000000	MOVQ $0x4, 0x10(SP)				
  0x44ea55		e86688fbff		CALL runtime.memhash(SB)			
  0x44ea5a		488b442418		MOVQ 0x18(SP), AX				
  0x44ea5f		4889442440		MOVQ AX, 0x40(SP)				
  0x44ea64		488b6c2420		MOVQ 0x20(SP), BP				
  0x44ea69		4883c428		ADDQ $0x28, SP					
  0x44ea6d		c3			RET						
  0x44ea6e		e80d8effff		CALL runtime.morestack_noctxt(SB)		
  0x44ea73		eb8b			JMP type..hash.runtime.vdsoVersionKey(SB)	

TEXT type..eq.runtime.vdsoVersionKey(SB) <autogenerated>

  0x44ea80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ea89		483b6110		CMPQ 0x10(CX), SP			
  0x44ea8d		766d			JBE 0x44eafc				
  0x44ea8f		4883ec28		SUBQ $0x28, SP				
  0x44ea93		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ea98		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ea9d		488b442430		MOVQ 0x30(SP), AX			
  0x44eaa2		488b08			MOVQ 0(AX), CX				
  0x44eaa5		488b5008		MOVQ 0x8(AX), DX			
  0x44eaa9		488b5c2438		MOVQ 0x38(SP), BX			
  0x44eaae		488b33			MOVQ 0(BX), SI				
  0x44eab1		48395308		CMPQ DX, 0x8(BX)			
  0x44eab5		7421			JE 0x44ead8				
  0x44eab7		31c9			XORL CX, CX				
  0x44eab9		84c9			TESTL CL, CL				
  0x44eabb		7417			JE 0x44ead4				
  0x44eabd		8b4b10			MOVL 0x10(BX), CX			
  0x44eac0		394810			CMPL CX, 0x10(AX)			
  0x44eac3		0f94c0			SETE AL					
  0x44eac6		88442440		MOVB AL, 0x40(SP)			
  0x44eaca		488b6c2420		MOVQ 0x20(SP), BP			
  0x44eacf		4883c428		ADDQ $0x28, SP				
  0x44ead3		c3			RET					
  0x44ead4		31c0			XORL AX, AX				
  0x44ead6		ebee			JMP 0x44eac6				
  0x44ead8		48890c24		MOVQ CX, 0(SP)				
  0x44eadc		4889742408		MOVQ SI, 0x8(SP)			
  0x44eae1		4889542410		MOVQ DX, 0x10(SP)			
  0x44eae6		e83537fbff		CALL runtime.memequal(SB)		
  0x44eaeb		0fb64c2418		MOVZX 0x18(SP), CX			
  0x44eaf0		488b442430		MOVQ 0x30(SP), AX			
  0x44eaf5		488b5c2438		MOVQ 0x38(SP), BX			
  0x44eafa		ebbd			JMP 0x44eab9				
  0x44eafc		e87f8dffff		CALL runtime.morestack_noctxt(SB)	
  0x44eb01		e97affffff		JMP type..eq.runtime.vdsoVersionKey(SB)	

TEXT type..hash.[16]runtime.dbgVar(SB) <autogenerated>

  0x44eb10		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44eb19		483b6110		CMPQ 0x10(CX), SP			
  0x44eb1d		7659			JBE 0x44eb78				
  0x44eb1f		4883ec28		SUBQ $0x28, SP				
  0x44eb23		48896c2420		MOVQ BP, 0x20(SP)			
  0x44eb28		488d6c2420		LEAQ 0x20(SP), BP			
  0x44eb2d		31c0			XORL AX, AX				
  0x44eb2f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44eb34		eb2d			JMP 0x44eb63				
  0x44eb36		4889442418		MOVQ AX, 0x18(SP)			
  0x44eb3b		488d1440		LEAQ 0(AX)(AX*2), DX			
  0x44eb3f		488b5c2430		MOVQ 0x30(SP), BX			
  0x44eb44		488d14d3		LEAQ 0(BX)(DX*8), DX			
  0x44eb48		48891424		MOVQ DX, 0(SP)				
  0x44eb4c		48894c2408		MOVQ CX, 0x8(SP)			
  0x44eb51		e8eaebffff		CALL type..hash.runtime.dbgVar(SB)	
  0x44eb56		488b4c2410		MOVQ 0x10(SP), CX			
  0x44eb5b		488b442418		MOVQ 0x18(SP), AX			
  0x44eb60		48ffc0			INCQ AX					
  0x44eb63		4883f810		CMPQ $0x10, AX				
  0x44eb67		7ccd			JL 0x44eb36				
  0x44eb69		48894c2440		MOVQ CX, 0x40(SP)			
  0x44eb6e		488b6c2420		MOVQ 0x20(SP), BP			
  0x44eb73		4883c428		ADDQ $0x28, SP				
  0x44eb77		c3			RET					
  0x44eb78		e8038dffff		CALL runtime.morestack_noctxt(SB)	
  0x44eb7d		eb91			JMP type..hash.[16]runtime.dbgVar(SB)	

TEXT type..eq.[16]runtime.dbgVar(SB) <autogenerated>

  0x44eb80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44eb89		483b6110		CMPQ 0x10(CX), SP			
  0x44eb8d		0f86b2000000		JBE 0x44ec45				
  0x44eb93		4883ec38		SUBQ $0x38, SP				
  0x44eb97		48896c2430		MOVQ BP, 0x30(SP)			
  0x44eb9c		488d6c2430		LEAQ 0x30(SP), BP			
  0x44eba1		488b442448		MOVQ 0x48(SP), AX			
  0x44eba6		488b4c2440		MOVQ 0x40(SP), CX			
  0x44ebab		31d2			XORL DX, DX				
  0x44ebad		eb03			JMP 0x44ebb2				
  0x44ebaf		48ffc2			INCQ DX					
  0x44ebb2		4883fa10		CMPQ $0x10, DX				
  0x44ebb6		7d7e			JGE 0x44ec36				
  0x44ebb8		488d1c52		LEAQ 0(DX)(DX*2), BX			
  0x44ebbc		488b74d908		MOVQ 0x8(CX)(BX*8), SI			
  0x44ebc1		488b3cd9		MOVQ 0(CX)(BX*8), DI			
  0x44ebc5		4c8b04d8		MOVQ 0(AX)(BX*8), R8			
  0x44ebc9		4c8d0cd8		LEAQ 0(AX)(BX*8), R9			
  0x44ebcd		49397108		CMPQ SI, 0x8(R9)			
  0x44ebd1		7428			JE 0x44ebfb				
  0x44ebd3		be01000000		MOVL $0x1, SI				
  0x44ebd8		4084f6			TESTL SI, SI				
  0x44ebdb		750f			JNE 0x44ebec				
  0x44ebdd		488b74d910		MOVQ 0x10(CX)(BX*8), SI			
  0x44ebe2		488b5cd810		MOVQ 0x10(AX)(BX*8), BX			
  0x44ebe7		4839de			CMPQ BX, SI				
  0x44ebea		74c3			JE 0x44ebaf				
  0x44ebec		c644245000		MOVB $0x0, 0x50(SP)			
  0x44ebf1		488b6c2430		MOVQ 0x30(SP), BP			
  0x44ebf6		4883c438		ADDQ $0x38, SP				
  0x44ebfa		c3			RET					
  0x44ebfb		4889542420		MOVQ DX, 0x20(SP)			
  0x44ec00		48895c2428		MOVQ BX, 0x28(SP)			
  0x44ec05		48893c24		MOVQ DI, 0(SP)				
  0x44ec09		4c89442408		MOVQ R8, 0x8(SP)			
  0x44ec0e		4889742410		MOVQ SI, 0x10(SP)			
  0x44ec13		e80836fbff		CALL runtime.memequal(SB)		
  0x44ec18		0fb6742418		MOVZX 0x18(SP), SI			
  0x44ec1d		83f601			XORL $0x1, SI				
  0x44ec20		488b442448		MOVQ 0x48(SP), AX			
  0x44ec25		488b4c2440		MOVQ 0x40(SP), CX			
  0x44ec2a		488b542420		MOVQ 0x20(SP), DX			
  0x44ec2f		488b5c2428		MOVQ 0x28(SP), BX			
  0x44ec34		eba2			JMP 0x44ebd8				
  0x44ec36		c644245001		MOVB $0x1, 0x50(SP)			
  0x44ec3b		488b6c2430		MOVQ 0x30(SP), BP			
  0x44ec40		4883c438		ADDQ $0x38, SP				
  0x44ec44		c3			RET					
  0x44ec45		e8368cffff		CALL runtime.morestack_noctxt(SB)	
  0x44ec4a		e931ffffff		JMP type..eq.[16]runtime.dbgVar(SB)	

TEXT type..hash.[24]string(SB) <autogenerated>

  0x44ec50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ec59		483b6110		CMPQ 0x10(CX), SP			
  0x44ec5d		7658			JBE 0x44ecb7				
  0x44ec5f		4883ec28		SUBQ $0x28, SP				
  0x44ec63		48896c2420		MOVQ BP, 0x20(SP)			
  0x44ec68		488d6c2420		LEAQ 0x20(SP), BP			
  0x44ec6d		31c0			XORL AX, AX				
  0x44ec6f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44ec74		eb2c			JMP 0x44eca2				
  0x44ec76		4889442418		MOVQ AX, 0x18(SP)			
  0x44ec7b		48c1e004		SHLQ $0x4, AX				
  0x44ec7f		488b5c2430		MOVQ 0x30(SP), BX			
  0x44ec84		4801d8			ADDQ BX, AX				
  0x44ec87		48890424		MOVQ AX, 0(SP)				
  0x44ec8b		48894c2408		MOVQ CX, 0x8(SP)			
  0x44ec90		e8eb39fbff		CALL runtime.strhash(SB)		
  0x44ec95		488b4c2410		MOVQ 0x10(SP), CX			
  0x44ec9a		488b442418		MOVQ 0x18(SP), AX			
  0x44ec9f		48ffc0			INCQ AX					
  0x44eca2		4883f818		CMPQ $0x18, AX				
  0x44eca6		7cce			JL 0x44ec76				
  0x44eca8		48894c2440		MOVQ CX, 0x40(SP)			
  0x44ecad		488b6c2420		MOVQ 0x20(SP), BP			
  0x44ecb2		4883c428		ADDQ $0x28, SP				
  0x44ecb6		c3			RET					
  0x44ecb7		e8c48bffff		CALL runtime.morestack_noctxt(SB)	
  0x44ecbc		eb92			JMP type..hash.[24]string(SB)		

TEXT type..eq.[24]string(SB) <autogenerated>

  0x44ecc0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44ecc9		483b6110		CMPQ 0x10(CX), SP			
  0x44eccd		0f8695000000		JBE 0x44ed68				
  0x44ecd3		4883ec30		SUBQ $0x30, SP				
  0x44ecd7		48896c2428		MOVQ BP, 0x28(SP)			
  0x44ecdc		488d6c2428		LEAQ 0x28(SP), BP			
  0x44ece1		488b442438		MOVQ 0x38(SP), AX			
  0x44ece6		488b4c2440		MOVQ 0x40(SP), CX			
  0x44eceb		31d2			XORL DX, DX				
  0x44eced		eb19			JMP 0x44ed08				
  0x44ecef		488b5c2420		MOVQ 0x20(SP), BX			
  0x44ecf4		488d5301		LEAQ 0x1(BX), DX			
  0x44ecf8		488b5c2438		MOVQ 0x38(SP), BX			
  0x44ecfd		488b742440		MOVQ 0x40(SP), SI			
  0x44ed02		4889d8			MOVQ BX, AX				
  0x44ed05		4889f1			MOVQ SI, CX				
  0x44ed08		4883fa18		CMPQ $0x18, DX				
  0x44ed0c		7d4b			JGE 0x44ed59				
  0x44ed0e		4889d3			MOVQ DX, BX				
  0x44ed11		48c1e204		SHLQ $0x4, DX				
  0x44ed15		488b340a		MOVQ 0(DX)(CX*1), SI			
  0x44ed19		488b3c02		MOVQ 0(DX)(AX*1), DI			
  0x44ed1d		4c8b441008		MOVQ 0x8(AX)(DX*1), R8			
  0x44ed22		4801ca			ADDQ CX, DX				
  0x44ed25		4c394208		CMPQ R8, 0x8(DX)			
  0x44ed29		751f			JNE 0x44ed4a				
  0x44ed2b		48895c2420		MOVQ BX, 0x20(SP)			
  0x44ed30		48893c24		MOVQ DI, 0(SP)				
  0x44ed34		4889742408		MOVQ SI, 0x8(SP)			
  0x44ed39		4c89442410		MOVQ R8, 0x10(SP)			
  0x44ed3e		e8dd34fbff		CALL runtime.memequal(SB)		
  0x44ed43		807c241800		CMPB $0x0, 0x18(SP)			
  0x44ed48		75a5			JNE 0x44ecef				
  0x44ed4a		c644244800		MOVB $0x0, 0x48(SP)			
  0x44ed4f		488b6c2428		MOVQ 0x28(SP), BP			
  0x44ed54		4883c430		ADDQ $0x30, SP				
  0x44ed58		c3			RET					
  0x44ed59		c644244801		MOVB $0x1, 0x48(SP)			
  0x44ed5e		488b6c2428		MOVQ 0x28(SP), BP			
  0x44ed63		4883c430		ADDQ $0x30, SP				
  0x44ed67		c3			RET					
  0x44ed68		e8138bffff		CALL runtime.morestack_noctxt(SB)	
  0x44ed6d		e94effffff		JMP type..eq.[24]string(SB)		

TEXT type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44ed80		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44ed89		483b6110		CMPQ 0x10(CX), SP									
  0x44ed8d		765f			JBE 0x44edee										
  0x44ed8f		4883ec28		SUBQ $0x28, SP										
  0x44ed93		48896c2420		MOVQ BP, 0x20(SP)									
  0x44ed98		488d6c2420		LEAQ 0x20(SP), BP									
  0x44ed9d		488b442430		MOVQ 0x30(SP), AX									
  0x44eda2		48890424		MOVQ AX, 0(SP)										
  0x44eda6		488b4c2438		MOVQ 0x38(SP), CX									
  0x44edab		48894c2408		MOVQ CX, 0x8(SP)									
  0x44edb0		e88bf5ffff		CALL type..hash.runtime.semaRoot(SB)							
  0x44edb5		488b442410		MOVQ 0x10(SP), AX									
  0x44edba		488b4c2430		MOVQ 0x30(SP), CX									
  0x44edbf		4883c118		ADDQ $0x18, CX										
  0x44edc3		48890c24		MOVQ CX, 0(SP)										
  0x44edc7		4889442408		MOVQ AX, 0x8(SP)									
  0x44edcc		48c744241028000000	MOVQ $0x28, 0x10(SP)									
  0x44edd5		e8e684fbff		CALL runtime.memhash(SB)								
  0x44edda		488b442418		MOVQ 0x18(SP), AX									
  0x44eddf		4889442440		MOVQ AX, 0x40(SP)									
  0x44ede4		488b6c2420		MOVQ 0x20(SP), BP									
  0x44ede9		4883c428		ADDQ $0x28, SP										
  0x44eded		c3			RET											
  0x44edee		e88d8affff		CALL runtime.morestack_noctxt(SB)							
  0x44edf3		eb8b			JMP type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..eq.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44ee00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44ee09		483b6110		CMPQ 0x10(CX), SP									
  0x44ee0d		7670			JBE 0x44ee7f										
  0x44ee0f		4883ec28		SUBQ $0x28, SP										
  0x44ee13		48896c2420		MOVQ BP, 0x20(SP)									
  0x44ee18		488d6c2420		LEAQ 0x20(SP), BP									
  0x44ee1d		488b442438		MOVQ 0x38(SP), AX									
  0x44ee22		488b08			MOVQ 0(AX), CX										
  0x44ee25		488b542430		MOVQ 0x30(SP), DX									
  0x44ee2a		48390a			CMPQ CX, 0(DX)										
  0x44ee2d		754c			JNE 0x44ee7b										
  0x44ee2f		488b4808		MOVQ 0x8(AX), CX									
  0x44ee33		48394a08		CMPQ CX, 0x8(DX)									
  0x44ee37		753e			JNE 0x44ee77										
  0x44ee39		8b4810			MOVL 0x10(AX), CX									
  0x44ee3c		394a10			CMPL CX, 0x10(DX)									
  0x44ee3f		7410			JE 0x44ee51										
  0x44ee41		31c0			XORL AX, AX										
  0x44ee43		88442440		MOVB AL, 0x40(SP)									
  0x44ee47		488b6c2420		MOVQ 0x20(SP), BP									
  0x44ee4c		4883c428		ADDQ $0x28, SP										
  0x44ee50		c3			RET											
  0x44ee51		488d4a18		LEAQ 0x18(DX), CX									
  0x44ee55		48890c24		MOVQ CX, 0(SP)										
  0x44ee59		4883c018		ADDQ $0x18, AX										
  0x44ee5d		4889442408		MOVQ AX, 0x8(SP)									
  0x44ee62		48c744241028000000	MOVQ $0x28, 0x10(SP)									
  0x44ee6b		e8b033fbff		CALL runtime.memequal(SB)								
  0x44ee70		0fb6442418		MOVZX 0x18(SP), AX									
  0x44ee75		ebcc			JMP 0x44ee43										
  0x44ee77		31c0			XORL AX, AX										
  0x44ee79		ebc8			JMP 0x44ee43										
  0x44ee7b		31c0			XORL AX, AX										
  0x44ee7d		ebc4			JMP 0x44ee43										
  0x44ee7f		e8fc89ffff		CALL runtime.morestack_noctxt(SB)							
  0x44ee84		e977ffffff		JMP type..eq.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..hash.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44ee90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44ee99		483b6110		CMPQ 0x10(CX), SP									
  0x44ee9d		765a			JBE 0x44eef9										
  0x44ee9f		4883ec28		SUBQ $0x28, SP										
  0x44eea3		48896c2420		MOVQ BP, 0x20(SP)									
  0x44eea8		488d6c2420		LEAQ 0x20(SP), BP									
  0x44eead		31c0			XORL AX, AX										
  0x44eeaf		488b4c2438		MOVQ 0x38(SP), CX									
  0x44eeb4		eb2c			JMP 0x44eee2										
  0x44eeb6		4889442418		MOVQ AX, 0x18(SP)									
  0x44eebb		48c1e006		SHLQ $0x6, AX										
  0x44eebf		488b5c2430		MOVQ 0x30(SP), BX									
  0x44eec4		4801d8			ADDQ BX, AX										
  0x44eec7		48890424		MOVQ AX, 0(SP)										
  0x44eecb		48894c2408		MOVQ CX, 0x8(SP)									
  0x44eed0		e8abfeffff		CALL type..hash.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	
  0x44eed5		488b4c2410		MOVQ 0x10(SP), CX									
  0x44eeda		488b442418		MOVQ 0x18(SP), AX									
  0x44eedf		48ffc0			INCQ AX											
  0x44eee2		483dfb000000		CMPQ $0xfb, AX										
  0x44eee8		7ccc			JL 0x44eeb6										
  0x44eeea		48894c2440		MOVQ CX, 0x40(SP)									
  0x44eeef		488b6c2420		MOVQ 0x20(SP), BP									
  0x44eef4		4883c428		ADDQ $0x28, SP										
  0x44eef8		c3			RET											
  0x44eef9		e88289ffff		CALL runtime.morestack_noctxt(SB)							
  0x44eefe		eb90			JMP type..hash.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..eq.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB) <autogenerated>

  0x44ef00		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX									
  0x44ef09		483b6110		CMPQ 0x10(CX), SP									
  0x44ef0d		7670			JBE 0x44ef7f										
  0x44ef0f		4883ec28		SUBQ $0x28, SP										
  0x44ef13		48896c2420		MOVQ BP, 0x20(SP)									
  0x44ef18		488d6c2420		LEAQ 0x20(SP), BP									
  0x44ef1d		31c0			XORL AX, AX										
  0x44ef1f		eb09			JMP 0x44ef2a										
  0x44ef21		488b4c2418		MOVQ 0x18(SP), CX									
  0x44ef26		488d4101		LEAQ 0x1(CX), AX									
  0x44ef2a		483dfb000000		CMPQ $0xfb, AX										
  0x44ef30		7d3e			JGE 0x44ef70										
  0x44ef32		4889442418		MOVQ AX, 0x18(SP)									
  0x44ef37		48c1e006		SHLQ $0x6, AX										
  0x44ef3b		488b542430		MOVQ 0x30(SP), DX									
  0x44ef40		488d1c10		LEAQ 0(AX)(DX*1), BX									
  0x44ef44		48891c24		MOVQ BX, 0(SP)										
  0x44ef48		488b5c2438		MOVQ 0x38(SP), BX									
  0x44ef4d		4801d8			ADDQ BX, AX										
  0x44ef50		4889442408		MOVQ AX, 0x8(SP)									
  0x44ef55		e8a6feffff		CALL type..eq.struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	
  0x44ef5a		807c241000		CMPB $0x0, 0x10(SP)									
  0x44ef5f		75c0			JNE 0x44ef21										
  0x44ef61		c644244000		MOVB $0x0, 0x40(SP)									
  0x44ef66		488b6c2420		MOVQ 0x20(SP), BP									
  0x44ef6b		4883c428		ADDQ $0x28, SP										
  0x44ef6f		c3			RET											
  0x44ef70		c644244001		MOVB $0x1, 0x40(SP)									
  0x44ef75		488b6c2420		MOVQ 0x20(SP), BP									
  0x44ef7a		4883c428		ADDQ $0x28, SP										
  0x44ef7e		c3			RET											
  0x44ef7f		e8fc88ffff		CALL runtime.morestack_noctxt(SB)							
  0x44ef84		e977ffffff		JMP type..eq.[251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 }(SB)	

TEXT type..hash.[2]runtime.vdsoSymbolKey(SB) <autogenerated>

  0x44ef90		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44ef99		483b6110		CMPQ 0x10(CX), SP				
  0x44ef9d		7658			JBE 0x44eff7					
  0x44ef9f		4883ec28		SUBQ $0x28, SP					
  0x44efa3		48896c2420		MOVQ BP, 0x20(SP)				
  0x44efa8		488d6c2420		LEAQ 0x20(SP), BP				
  0x44efad		31c0			XORL AX, AX					
  0x44efaf		488b4c2438		MOVQ 0x38(SP), CX				
  0x44efb4		eb2c			JMP 0x44efe2					
  0x44efb6		4889442418		MOVQ AX, 0x18(SP)				
  0x44efbb		48c1e005		SHLQ $0x5, AX					
  0x44efbf		488b5c2430		MOVQ 0x30(SP), BX				
  0x44efc4		4801d8			ADDQ BX, AX					
  0x44efc7		48890424		MOVQ AX, 0(SP)					
  0x44efcb		48894c2408		MOVQ CX, 0x8(SP)				
  0x44efd0		e80bf9ffff		CALL type..hash.runtime.vdsoSymbolKey(SB)	
  0x44efd5		488b4c2410		MOVQ 0x10(SP), CX				
  0x44efda		488b442418		MOVQ 0x18(SP), AX				
  0x44efdf		48ffc0			INCQ AX						
  0x44efe2		4883f802		CMPQ $0x2, AX					
  0x44efe6		7cce			JL 0x44efb6					
  0x44efe8		48894c2440		MOVQ CX, 0x40(SP)				
  0x44efed		488b6c2420		MOVQ 0x20(SP), BP				
  0x44eff2		4883c428		ADDQ $0x28, SP					
  0x44eff6		c3			RET						
  0x44eff7		e88488ffff		CALL runtime.morestack_noctxt(SB)		
  0x44effc		eb92			JMP type..hash.[2]runtime.vdsoSymbolKey(SB)	

TEXT type..eq.[2]runtime.vdsoSymbolKey(SB) <autogenerated>

  0x44f000		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX				
  0x44f009		483b6110		CMPQ 0x10(CX), SP				
  0x44f00d		0f86d2000000		JBE 0x44f0e5					
  0x44f013		4883ec38		SUBQ $0x38, SP					
  0x44f017		48896c2430		MOVQ BP, 0x30(SP)				
  0x44f01c		488d6c2430		LEAQ 0x30(SP), BP				
  0x44f021		488b442440		MOVQ 0x40(SP), AX				
  0x44f026		488b4c2448		MOVQ 0x48(SP), CX				
  0x44f02b		31d2			XORL DX, DX					
  0x44f02d		eb04			JMP 0x44f033					
  0x44f02f		488d5301		LEAQ 0x1(BX), DX				
  0x44f033		4883fa02		CMPQ $0x2, DX					
  0x44f037		0f8d99000000		JGE 0x44f0d6					
  0x44f03d		4889d3			MOVQ DX, BX					
  0x44f040		48c1e205		SHLQ $0x5, DX					
  0x44f044		488b3402		MOVQ 0(DX)(AX*1), SI				
  0x44f048		488b3c0a		MOVQ 0(DX)(CX*1), DI				
  0x44f04c		4c8b441008		MOVQ 0x8(AX)(DX*1), R8				
  0x44f051		4c8d0c0a		LEAQ 0(DX)(CX*1), R9				
  0x44f055		4d394108		CMPQ R8, 0x8(R9)				
  0x44f059		7440			JE 0x44f09b					
  0x44f05b		be01000000		MOVL $0x1, SI					
  0x44f060		4084f6			TESTL SI, SI					
  0x44f063		7527			JNE 0x44f08c					
  0x44f065		8b740210		MOVL 0x10(DX)(AX*1), SI				
  0x44f069		8b7c0a10		MOVL 0x10(DX)(CX*1), DI				
  0x44f06d		39f7			CMPL SI, DI					
  0x44f06f		751b			JNE 0x44f08c					
  0x44f071		8b740214		MOVL 0x14(DX)(AX*1), SI				
  0x44f075		8b7c0a14		MOVL 0x14(DX)(CX*1), DI				
  0x44f079		39fe			CMPL DI, SI					
  0x44f07b		750f			JNE 0x44f08c					
  0x44f07d		488b740218		MOVQ 0x18(DX)(AX*1), SI				
  0x44f082		488b540a18		MOVQ 0x18(DX)(CX*1), DX				
  0x44f087		4839d6			CMPQ DX, SI					
  0x44f08a		74a3			JE 0x44f02f					
  0x44f08c		c644245000		MOVB $0x0, 0x50(SP)				
  0x44f091		488b6c2430		MOVQ 0x30(SP), BP				
  0x44f096		4883c438		ADDQ $0x38, SP					
  0x44f09a		c3			RET						
  0x44f09b		48895c2428		MOVQ BX, 0x28(SP)				
  0x44f0a0		4889542420		MOVQ DX, 0x20(SP)				
  0x44f0a5		48893424		MOVQ SI, 0(SP)					
  0x44f0a9		48897c2408		MOVQ DI, 0x8(SP)				
  0x44f0ae		4c89442410		MOVQ R8, 0x10(SP)				
  0x44f0b3		e86831fbff		CALL runtime.memequal(SB)			
  0x44f0b8		0fb6742418		MOVZX 0x18(SP), SI				
  0x44f0bd		83f601			XORL $0x1, SI					
  0x44f0c0		488b442440		MOVQ 0x40(SP), AX				
  0x44f0c5		488b4c2448		MOVQ 0x48(SP), CX				
  0x44f0ca		488b542420		MOVQ 0x20(SP), DX				
  0x44f0cf		488b5c2428		MOVQ 0x28(SP), BX				
  0x44f0d4		eb8a			JMP 0x44f060					
  0x44f0d6		c644245001		MOVB $0x1, 0x50(SP)				
  0x44f0db		488b6c2430		MOVQ 0x30(SP), BP				
  0x44f0e0		4883c438		ADDQ $0x38, SP					
  0x44f0e4		c3			RET						
  0x44f0e5		e89687ffff		CALL runtime.morestack_noctxt(SB)		
  0x44f0ea		e911ffffff		JMP type..eq.[2]runtime.vdsoSymbolKey(SB)	

TEXT type..hash.[33]float64(SB) <autogenerated>

  0x44f0f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44f0f9		483b6110		CMPQ 0x10(CX), SP			
  0x44f0fd		7655			JBE 0x44f154				
  0x44f0ff		4883ec28		SUBQ $0x28, SP				
  0x44f103		48896c2420		MOVQ BP, 0x20(SP)			
  0x44f108		488d6c2420		LEAQ 0x20(SP), BP			
  0x44f10d		31c0			XORL AX, AX				
  0x44f10f		488b4c2438		MOVQ 0x38(SP), CX			
  0x44f114		eb29			JMP 0x44f13f				
  0x44f116		4889442418		MOVQ AX, 0x18(SP)			
  0x44f11b		488b542430		MOVQ 0x30(SP), DX			
  0x44f120		488d1cc2		LEAQ 0(DX)(AX*8), BX			
  0x44f124		48891c24		MOVQ BX, 0(SP)				
  0x44f128		48894c2408		MOVQ CX, 0x8(SP)			
  0x44f12d		e8ce36fbff		CALL runtime.f64hash(SB)		
  0x44f132		488b4c2410		MOVQ 0x10(SP), CX			
  0x44f137		488b442418		MOVQ 0x18(SP), AX			
  0x44f13c		48ffc0			INCQ AX					
  0x44f13f		4883f821		CMPQ $0x21, AX				
  0x44f143		7cd1			JL 0x44f116				
  0x44f145		48894c2440		MOVQ CX, 0x40(SP)			
  0x44f14a		488b6c2420		MOVQ 0x20(SP), BP			
  0x44f14f		4883c428		ADDQ $0x28, SP				
  0x44f153		c3			RET					
  0x44f154		e82787ffff		CALL runtime.morestack_noctxt(SB)	
  0x44f159		eb95			JMP type..hash.[33]float64(SB)		

TEXT type..eq.[33]float64(SB) <autogenerated>

  0x44f160		488b442408		MOVQ 0x8(SP), AX		
  0x44f165		488b4c2410		MOVQ 0x10(SP), CX		
  0x44f16a		31d2			XORL DX, DX			
  0x44f16c		eb03			JMP 0x44f171			
  0x44f16e		48ffc2			INCQ DX				
  0x44f171		4883fa21		CMPQ $0x21, DX			
  0x44f175		7d18			JGE 0x44f18f			
  0x44f177		f20f1004d0		MOVSD_XMM 0(AX)(DX*8), X0	
  0x44f17c		f20f100cd1		MOVSD_XMM 0(CX)(DX*8), X1	
  0x44f181		660f2ec1		UCOMISD X1, X0			
  0x44f185		7502			JNE 0x44f189			
  0x44f187		7be5			JNP 0x44f16e			
  0x44f189		c644241800		MOVB $0x0, 0x18(SP)		
  0x44f18e		c3			RET				
  0x44f18f		c644241801		MOVB $0x1, 0x18(SP)		
  0x44f194		c3			RET				

TEXT type..hash.[65]runtime.sigTabT(SB) <autogenerated>

  0x44f1a0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44f1a9		483b6110		CMPQ 0x10(CX), SP			
  0x44f1ad		7659			JBE 0x44f208				
  0x44f1af		4883ec28		SUBQ $0x28, SP				
  0x44f1b3		48896c2420		MOVQ BP, 0x20(SP)			
  0x44f1b8		488d6c2420		LEAQ 0x20(SP), BP			
  0x44f1bd		31c0			XORL AX, AX				
  0x44f1bf		488b4c2438		MOVQ 0x38(SP), CX			
  0x44f1c4		eb2d			JMP 0x44f1f3				
  0x44f1c6		4889442418		MOVQ AX, 0x18(SP)			
  0x44f1cb		488d1440		LEAQ 0(AX)(AX*2), DX			
  0x44f1cf		488b5c2430		MOVQ 0x30(SP), BX			
  0x44f1d4		488d14d3		LEAQ 0(BX)(DX*8), DX			
  0x44f1d8		48891424		MOVQ DX, 0(SP)				
  0x44f1dc		48894c2408		MOVQ CX, 0x8(SP)			
  0x44f1e1		e81af2ffff		CALL type..hash.runtime.sigTabT(SB)	
  0x44f1e6		488b4c2410		MOVQ 0x10(SP), CX			
  0x44f1eb		488b442418		MOVQ 0x18(SP), AX			
  0x44f1f0		48ffc0			INCQ AX					
  0x44f1f3		4883f841		CMPQ $0x41, AX				
  0x44f1f7		7ccd			JL 0x44f1c6				
  0x44f1f9		48894c2440		MOVQ CX, 0x40(SP)			
  0x44f1fe		488b6c2420		MOVQ 0x20(SP), BP			
  0x44f203		4883c428		ADDQ $0x28, SP				
  0x44f207		c3			RET					
  0x44f208		e87386ffff		CALL runtime.morestack_noctxt(SB)	
  0x44f20d		eb91			JMP type..hash.[65]runtime.sigTabT(SB)	

TEXT type..eq.[65]runtime.sigTabT(SB) <autogenerated>

  0x44f210		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44f219		483b6110		CMPQ 0x10(CX), SP			
  0x44f21d		0f86ab000000		JBE 0x44f2ce				
  0x44f223		4883ec30		SUBQ $0x30, SP				
  0x44f227		48896c2428		MOVQ BP, 0x28(SP)			
  0x44f22c		488d6c2428		LEAQ 0x28(SP), BP			
  0x44f231		488b442440		MOVQ 0x40(SP), AX			
  0x44f236		488b4c2438		MOVQ 0x38(SP), CX			
  0x44f23b		31d2			XORL DX, DX				
  0x44f23d		eb03			JMP 0x44f242				
  0x44f23f		48ffc2			INCQ DX					
  0x44f242		4883fa41		CMPQ $0x41, DX				
  0x44f246		7d77			JGE 0x44f2bf				
  0x44f248		488d1c52		LEAQ 0(DX)(DX*2), BX			
  0x44f24c		8b34d9			MOVL 0(CX)(BX*8), SI			
  0x44f24f		8b3cd8			MOVL 0(AX)(BX*8), DI			
  0x44f252		4c8d04d8		LEAQ 0(AX)(BX*8), R8			
  0x44f256		39fe			CMPL DI, SI				
  0x44f258		7418			JE 0x44f272				
  0x44f25a		bb01000000		MOVL $0x1, BX				
  0x44f25f		84db			TESTL BL, BL				
  0x44f261		74dc			JE 0x44f23f				
  0x44f263		c644244800		MOVB $0x0, 0x48(SP)			
  0x44f268		488b6c2428		MOVQ 0x28(SP), BP			
  0x44f26d		4883c430		ADDQ $0x30, SP				
  0x44f271		c3			RET					
  0x44f272		488b74d908		MOVQ 0x8(CX)(BX*8), SI			
  0x44f277		488b7cd910		MOVQ 0x10(CX)(BX*8), DI			
  0x44f27c		488b5cd808		MOVQ 0x8(AX)(BX*8), BX			
  0x44f281		49397810		CMPQ DI, 0x10(R8)			
  0x44f285		7407			JE 0x44f28e				
  0x44f287		bb01000000		MOVL $0x1, BX				
  0x44f28c		ebd1			JMP 0x44f25f				
  0x44f28e		4889542420		MOVQ DX, 0x20(SP)			
  0x44f293		48893424		MOVQ SI, 0(SP)				
  0x44f297		48895c2408		MOVQ BX, 0x8(SP)			
  0x44f29c		48897c2410		MOVQ DI, 0x10(SP)			
  0x44f2a1		e87a2ffbff		CALL runtime.memequal(SB)		
  0x44f2a6		0fb65c2418		MOVZX 0x18(SP), BX			
  0x44f2ab		83f301			XORL $0x1, BX				
  0x44f2ae		488b442440		MOVQ 0x40(SP), AX			
  0x44f2b3		488b4c2438		MOVQ 0x38(SP), CX			
  0x44f2b8		488b542420		MOVQ 0x20(SP), DX			
  0x44f2bd		eba0			JMP 0x44f25f				
  0x44f2bf		c644244801		MOVB $0x1, 0x48(SP)			
  0x44f2c4		488b6c2428		MOVQ 0x28(SP), BP			
  0x44f2c9		4883c430		ADDQ $0x30, SP				
  0x44f2cd		c3			RET					
  0x44f2ce		e8ad85ffff		CALL runtime.morestack_noctxt(SB)	
  0x44f2d3		e938ffffff		JMP type..eq.[65]runtime.sigTabT(SB)	

TEXT type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(SB) <autogenerated>

  0x44f2e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX								
  0x44f2e9		483b6110		CMPQ 0x10(CX), SP								
  0x44f2ed		7643			JBE 0x44f332									
  0x44f2ef		4883ec28		SUBQ $0x28, SP									
  0x44f2f3		48896c2420		MOVQ BP, 0x20(SP)								
  0x44f2f8		488d6c2420		LEAQ 0x20(SP), BP								
  0x44f2fd		488b442430		MOVQ 0x30(SP), AX								
  0x44f302		48890424		MOVQ AX, 0(SP)									
  0x44f306		488b442438		MOVQ 0x38(SP), AX								
  0x44f30b		4889442408		MOVQ AX, 0x8(SP)								
  0x44f310		48c744241005000000	MOVQ $0x5, 0x10(SP)								
  0x44f319		e8a27ffbff		CALL runtime.memhash(SB)							
  0x44f31e		488b442418		MOVQ 0x18(SP), AX								
  0x44f323		4889442440		MOVQ AX, 0x40(SP)								
  0x44f328		488b6c2420		MOVQ 0x20(SP), BP								
  0x44f32d		4883c428		ADDQ $0x28, SP									
  0x44f331		c3			RET										
  0x44f332		e84985ffff		CALL runtime.morestack_noctxt(SB)						
  0x44f337		eba7			JMP type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(SB)	

TEXT type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(SB) <autogenerated>

  0x44f340		488b442410		MOVQ 0x10(SP), AX	
  0x44f345		8b08			MOVL 0(AX), CX		
  0x44f347		488b542408		MOVQ 0x8(SP), DX	
  0x44f34c		390a			CMPL CX, 0(DX)		
  0x44f34e		750f			JNE 0x44f35f		
  0x44f350		0fb64004		MOVZX 0x4(AX), AX	
  0x44f354		384204			CMPB AL, 0x4(DX)	
  0x44f357		0f94c0			SETE AL			
  0x44f35a		88442418		MOVB AL, 0x18(SP)	
  0x44f35e		c3			RET			
  0x44f35f		31c0			XORL AX, AX		
  0x44f361		ebf7			JMP 0x44f35a		

TEXT type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB) <autogenerated>

  0x44f370		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44f379		483b6110		CMPQ 0x10(CX), SP															
  0x44f37d		7668			JBE 0x44f3e7																
  0x44f37f		4883ec28		SUBQ $0x28, SP																
  0x44f383		48896c2420		MOVQ BP, 0x20(SP)															
  0x44f388		488d6c2420		LEAQ 0x20(SP), BP															
  0x44f38d		488b442430		MOVQ 0x30(SP), AX															
  0x44f392		48890424		MOVQ AX, 0(SP)																
  0x44f396		488b4c2438		MOVQ 0x38(SP), CX															
  0x44f39b		48894c2408		MOVQ CX, 0x8(SP)															
  0x44f3a0		48c744241006000000	MOVQ $0x6, 0x10(SP)															
  0x44f3a9		e8127ffbff		CALL runtime.memhash(SB)														
  0x44f3ae		488b442418		MOVQ 0x18(SP), AX															
  0x44f3b3		488b4c2430		MOVQ 0x30(SP), CX															
  0x44f3b8		4883c108		ADDQ $0x8, CX																
  0x44f3bc		48890c24		MOVQ CX, 0(SP)																
  0x44f3c0		4889442408		MOVQ AX, 0x8(SP)															
  0x44f3c5		48c744241008000000	MOVQ $0x8, 0x10(SP)															
  0x44f3ce		e8ed7efbff		CALL runtime.memhash(SB)														
  0x44f3d3		488b442418		MOVQ 0x18(SP), AX															
  0x44f3d8		4889442440		MOVQ AX, 0x40(SP)															
  0x44f3dd		488b6c2420		MOVQ 0x20(SP), BP															
  0x44f3e2		4883c428		ADDQ $0x28, SP																
  0x44f3e6		c3			RET																	
  0x44f3e7		e89484ffff		CALL runtime.morestack_noctxt(SB)													
  0x44f3ec		eb82			JMP type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB)	

TEXT type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB) <autogenerated>

  0x44f3f0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX															
  0x44f3f9		483b6110		CMPQ 0x10(CX), SP															
  0x44f3fd		765d			JBE 0x44f45c																
  0x44f3ff		4883ec28		SUBQ $0x28, SP																
  0x44f403		48896c2420		MOVQ BP, 0x20(SP)															
  0x44f408		488d6c2420		LEAQ 0x20(SP), BP															
  0x44f40d		488b442430		MOVQ 0x30(SP), AX															
  0x44f412		48890424		MOVQ AX, 0(SP)																
  0x44f416		488b4c2438		MOVQ 0x38(SP), CX															
  0x44f41b		48894c2408		MOVQ CX, 0x8(SP)															
  0x44f420		48c744241006000000	MOVQ $0x6, 0x10(SP)															
  0x44f429		e8f22dfbff		CALL runtime.memequal(SB)														
  0x44f42e		807c241800		CMPB $0x0, 0x18(SP)															
  0x44f433		7423			JE 0x44f458																
  0x44f435		488b442438		MOVQ 0x38(SP), AX															
  0x44f43a		488b4008		MOVQ 0x8(AX), AX															
  0x44f43e		488b4c2430		MOVQ 0x30(SP), CX															
  0x44f443		48394108		CMPQ AX, 0x8(CX)															
  0x44f447		0f94c0			SETE AL																	
  0x44f44a		88442440		MOVB AL, 0x40(SP)															
  0x44f44e		488b6c2420		MOVQ 0x20(SP), BP															
  0x44f453		4883c428		ADDQ $0x28, SP																
  0x44f457		c3			RET																	
  0x44f458		31c0			XORL AX, AX																
  0x44f45a		ebee			JMP 0x44f44a																
  0x44f45c		e81f84ffff		CALL runtime.morestack_noctxt(SB)													
  0x44f461		eb8d			JMP type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(SB)	

TEXT type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB) <autogenerated>

  0x44f470		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																																																																																																																																																												
  0x44f479		483b6110		CMPQ 0x10(CX), SP																																																																																																																																																												
  0x44f47d		0f864c010000		JBE 0x44f5cf																																																																																																																																																													
  0x44f483		4883ec28		SUBQ $0x28, SP																																																																																																																																																													
  0x44f487		48896c2420		MOVQ BP, 0x20(SP)																																																																																																																																																												
  0x44f48c		488d6c2420		LEAQ 0x20(SP), BP																																																																																																																																																												
  0x44f491		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f496		48890424		MOVQ AX, 0(SP)																																																																																																																																																													
  0x44f49a		488b4c2438		MOVQ 0x38(SP), CX																																																																																																																																																												
  0x44f49f		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																												
  0x44f4a4		48c744241010000000	MOVQ $0x10, 0x10(SP)																																																																																																																																																												
  0x44f4ad		e80e7efbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f4b2		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f4b7		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f4bc		488d5110		LEAQ 0x10(CX), DX																																																																																																																																																												
  0x44f4c0		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f4c4		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f4c9		e89226fbff		CALL type..hash.internal/cpu.CacheLinePad(SB)																																																																																																																																																									
  0x44f4ce		488b442410		MOVQ 0x10(SP), AX																																																																																																																																																												
  0x44f4d3		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f4d8		488d5150		LEAQ 0x50(CX), DX																																																																																																																																																												
  0x44f4dc		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f4e0		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f4e5		48c744241028000000	MOVQ $0x28, 0x10(SP)																																																																																																																																																												
  0x44f4ee		e8cd7dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f4f3		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f4f8		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f4fd		488d9180000000		LEAQ 0x80(CX), DX																																																																																																																																																												
  0x44f504		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f508		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f50d		48c744241014000000	MOVQ $0x14, 0x10(SP)																																																																																																																																																												
  0x44f516		e8a57dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f51b		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f520		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f525		488d9198000000		LEAQ 0x98(CX), DX																																																																																																																																																												
  0x44f52c		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f530		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f535		48c74424104c000000	MOVQ $0x4c, 0x10(SP)																																																																																																																																																												
  0x44f53e		e87d7dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f543		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f548		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f54d		488d91e8000000		LEAQ 0xe8(CX), DX																																																																																																																																																												
  0x44f554		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f558		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f55d		48c744241009000000	MOVQ $0x9, 0x10(SP)																																																																																																																																																												
  0x44f566		e8557dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f56b		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f570		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f575		488d91f8000000		LEAQ 0xf8(CX), DX																																																																																																																																																												
  0x44f57c		48891424		MOVQ DX, 0(SP)																																																																																																																																																													
  0x44f580		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f585		48c744241044000000	MOVQ $0x44, 0x10(SP)																																																																																																																																																												
  0x44f58e		e82d7dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f593		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f598		488b4c2430		MOVQ 0x30(SP), CX																																																																																																																																																												
  0x44f59d		4881c140010000		ADDQ $0x140, CX																																																																																																																																																													
  0x44f5a4		48890c24		MOVQ CX, 0(SP)																																																																																																																																																													
  0x44f5a8		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f5ad		48c744241050000000	MOVQ $0x50, 0x10(SP)																																																																																																																																																												
  0x44f5b6		e8057dfbff		CALL runtime.memhash(SB)																																																																																																																																																											
  0x44f5bb		488b442418		MOVQ 0x18(SP), AX																																																																																																																																																												
  0x44f5c0		4889442440		MOVQ AX, 0x40(SP)																																																																																																																																																												
  0x44f5c5		488b6c2420		MOVQ 0x20(SP), BP																																																																																																																																																												
  0x44f5ca		4883c428		ADDQ $0x28, SP																																																																																																																																																													
  0x44f5ce		c3			RET																																																																																																																																																														
  0x44f5cf		e8ac82ffff		CALL runtime.morestack_noctxt(SB)																																																																																																																																																										
  0x44f5d4		e997feffff		JMP type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB)	

TEXT type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB) <autogenerated>

  0x44f5e0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																																																																																																																																																												
  0x44f5e9		483b6110		CMPQ 0x10(CX), SP																																																																																																																																																												
  0x44f5ed		0f86b2010000		JBE 0x44f7a5																																																																																																																																																													
  0x44f5f3		4883ec28		SUBQ $0x28, SP																																																																																																																																																													
  0x44f5f7		48896c2420		MOVQ BP, 0x20(SP)																																																																																																																																																												
  0x44f5fc		488d6c2420		LEAQ 0x20(SP), BP																																																																																																																																																												
  0x44f601		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f606		488b08			MOVQ 0(AX), CX																																																																																																																																																													
  0x44f609		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																												
  0x44f60e		48390a			CMPQ CX, 0(DX)																																																																																																																																																													
  0x44f611		0f8587010000		JNE 0x44f79e																																																																																																																																																													
  0x44f617		488b4808		MOVQ 0x8(AX), CX																																																																																																																																																												
  0x44f61b		48394a08		CMPQ CX, 0x8(DX)																																																																																																																																																												
  0x44f61f		0f8572010000		JNE 0x44f797																																																																																																																																																													
  0x44f625		b901000000		MOVL $0x1, CX																																																																																																																																																													
  0x44f62a		84c9			TESTL CL, CL																																																																																																																																																													
  0x44f62c		0f8532010000		JNE 0x44f764																																																																																																																																																													
  0x44f632		31c9			XORL CX, CX																																																																																																																																																													
  0x44f634		84c9			TESTL CL, CL																																																																																																																																																													
  0x44f636		0f85ef000000		JNE 0x44f72b																																																																																																																																																													
  0x44f63c		31c9			XORL CX, CX																																																																																																																																																													
  0x44f63e		84c9			TESTL CL, CL																																																																																																																																																													
  0x44f640		0f85ac000000		JNE 0x44f6f2																																																																																																																																																													
  0x44f646		31c9			XORL CX, CX																																																																																																																																																													
  0x44f648		84c9			TESTL CL, CL																																																																																																																																																													
  0x44f64a		0f849e000000		JE 0x44f6ee																																																																																																																																																													
  0x44f650		488b8ae8000000		MOVQ 0xe8(DX), CX																																																																																																																																																												
  0x44f657		483988e8000000		CMPQ CX, 0xe8(AX)																																																																																																																																																												
  0x44f65e		0f8586000000		JNE 0x44f6ea																																																																																																																																																													
  0x44f664		0fb68af0000000		MOVZX 0xf0(DX), CX																																																																																																																																																												
  0x44f66b		3888f0000000		CMPB CL, 0xf0(AX)																																																																																																																																																												
  0x44f671		7441			JE 0x44f6b4																																																																																																																																																													
  0x44f673		31c9			XORL CX, CX																																																																																																																																																													
  0x44f675		84c9			TESTL CL, CL																																																																																																																																																													
  0x44f677		7510			JNE 0x44f689																																																																																																																																																													
  0x44f679		31c0			XORL AX, AX																																																																																																																																																													
  0x44f67b		88442440		MOVB AL, 0x40(SP)																																																																																																																																																												
  0x44f67f		488b6c2420		MOVQ 0x20(SP), BP																																																																																																																																																												
  0x44f684		4883c428		ADDQ $0x28, SP																																																																																																																																																													
  0x44f688		c3			RET																																																																																																																																																														
  0x44f689		480540010000		ADDQ $0x140, AX																																																																																																																																																													
  0x44f68f		48890424		MOVQ AX, 0(SP)																																																																																																																																																													
  0x44f693		488d8240010000		LEAQ 0x140(DX), AX																																																																																																																																																												
  0x44f69a		4889442408		MOVQ AX, 0x8(SP)																																																																																																																																																												
  0x44f69f		48c744241050000000	MOVQ $0x50, 0x10(SP)																																																																																																																																																												
  0x44f6a8		e8732bfbff		CALL runtime.memequal(SB)																																																																																																																																																											
  0x44f6ad		0fb6442418		MOVZX 0x18(SP), AX																																																																																																																																																												
  0x44f6b2		ebc7			JMP 0x44f67b																																																																																																																																																													
  0x44f6b4		488d88f8000000		LEAQ 0xf8(AX), CX																																																																																																																																																												
  0x44f6bb		48890c24		MOVQ CX, 0(SP)																																																																																																																																																													
  0x44f6bf		488d8af8000000		LEAQ 0xf8(DX), CX																																																																																																																																																												
  0x44f6c6		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																												
  0x44f6cb		48c744241044000000	MOVQ $0x44, 0x10(SP)																																																																																																																																																												
  0x44f6d4		e8472bfbff		CALL runtime.memequal(SB)																																																																																																																																																											
  0x44f6d9		0fb64c2418		MOVZX 0x18(SP), CX																																																																																																																																																												
  0x44f6de		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f6e3		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																												
  0x44f6e8		eb8b			JMP 0x44f675																																																																																																																																																													
  0x44f6ea		31c9			XORL CX, CX																																																																																																																																																													
  0x44f6ec		eb87			JMP 0x44f675																																																																																																																																																													
  0x44f6ee		31c9			XORL CX, CX																																																																																																																																																													
  0x44f6f0		eb83			JMP 0x44f675																																																																																																																																																													
  0x44f6f2		488d8898000000		LEAQ 0x98(AX), CX																																																																																																																																																												
  0x44f6f9		48890c24		MOVQ CX, 0(SP)																																																																																																																																																													
  0x44f6fd		488d8a98000000		LEAQ 0x98(DX), CX																																																																																																																																																												
  0x44f704		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																												
  0x44f709		48c74424104c000000	MOVQ $0x4c, 0x10(SP)																																																																																																																																																												
  0x44f712		e8092bfbff		CALL runtime.memequal(SB)																																																																																																																																																											
  0x44f717		0fb64c2418		MOVZX 0x18(SP), CX																																																																																																																																																												
  0x44f71c		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f721		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																												
  0x44f726		e91dffffff		JMP 0x44f648																																																																																																																																																													
  0x44f72b		488d8880000000		LEAQ 0x80(AX), CX																																																																																																																																																												
  0x44f732		48890c24		MOVQ CX, 0(SP)																																																																																																																																																													
  0x44f736		488d8a80000000		LEAQ 0x80(DX), CX																																																																																																																																																												
  0x44f73d		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																												
  0x44f742		48c744241014000000	MOVQ $0x14, 0x10(SP)																																																																																																																																																												
  0x44f74b		e8d02afbff		CALL runtime.memequal(SB)																																																																																																																																																											
  0x44f750		0fb64c2418		MOVZX 0x18(SP), CX																																																																																																																																																												
  0x44f755		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f75a		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																												
  0x44f75f		e9dafeffff		JMP 0x44f63e																																																																																																																																																													
  0x44f764		488d4850		LEAQ 0x50(AX), CX																																																																																																																																																												
  0x44f768		48890c24		MOVQ CX, 0(SP)																																																																																																																																																													
  0x44f76c		488d4a50		LEAQ 0x50(DX), CX																																																																																																																																																												
  0x44f770		48894c2408		MOVQ CX, 0x8(SP)																																																																																																																																																												
  0x44f775		48c744241028000000	MOVQ $0x28, 0x10(SP)																																																																																																																																																												
  0x44f77e		e89d2afbff		CALL runtime.memequal(SB)																																																																																																																																																											
  0x44f783		0fb64c2418		MOVZX 0x18(SP), CX																																																																																																																																																												
  0x44f788		488b442430		MOVQ 0x30(SP), AX																																																																																																																																																												
  0x44f78d		488b542438		MOVQ 0x38(SP), DX																																																																																																																																																												
  0x44f792		e99dfeffff		JMP 0x44f634																																																																																																																																																													
  0x44f797		31c9			XORL CX, CX																																																																																																																																																													
  0x44f799		e98cfeffff		JMP 0x44f62a																																																																																																																																																													
  0x44f79e		31c9			XORL CX, CX																																																																																																																																																													
  0x44f7a0		e985feffff		JMP 0x44f62a																																																																																																																																																													
  0x44f7a5		e8d680ffff		CALL runtime.morestack_noctxt(SB)																																																																																																																																																										
  0x44f7aa		e931feffff		JMP type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(SB)	

TEXT type..hash.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB) <autogenerated>

  0x44f7b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																				
  0x44f7b9		483b6110		CMPQ 0x10(CX), SP																				
  0x44f7bd		7668			JBE 0x44f827																					
  0x44f7bf		4883ec28		SUBQ $0x28, SP																					
  0x44f7c3		48896c2420		MOVQ BP, 0x20(SP)																				
  0x44f7c8		488d6c2420		LEAQ 0x20(SP), BP																				
  0x44f7cd		488b442430		MOVQ 0x30(SP), AX																				
  0x44f7d2		48890424		MOVQ AX, 0(SP)																					
  0x44f7d6		488b4c2438		MOVQ 0x38(SP), CX																				
  0x44f7db		48894c2408		MOVQ CX, 0x8(SP)																				
  0x44f7e0		48c744241011000000	MOVQ $0x11, 0x10(SP)																				
  0x44f7e9		e8d27afbff		CALL runtime.memhash(SB)																			
  0x44f7ee		488b442418		MOVQ 0x18(SP), AX																				
  0x44f7f3		488b4c2430		MOVQ 0x30(SP), CX																				
  0x44f7f8		4883c118		ADDQ $0x18, CX																					
  0x44f7fc		48890c24		MOVQ CX, 0(SP)																					
  0x44f800		4889442408		MOVQ AX, 0x8(SP)																				
  0x44f805		48c74424100c000000	MOVQ $0xc, 0x10(SP)																				
  0x44f80e		e8ad7afbff		CALL runtime.memhash(SB)																			
  0x44f813		488b442418		MOVQ 0x18(SP), AX																				
  0x44f818		4889442440		MOVQ AX, 0x40(SP)																				
  0x44f81d		488b6c2420		MOVQ 0x20(SP), BP																				
  0x44f822		4883c428		ADDQ $0x28, SP																					
  0x44f826		c3			RET																						
  0x44f827		e85480ffff		CALL runtime.morestack_noctxt(SB)																		
  0x44f82c		eb82			JMP type..hash.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB)	

TEXT type..eq.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB) <autogenerated>

  0x44f830		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																				
  0x44f839		483b6110		CMPQ 0x10(CX), SP																				
  0x44f83d		7669			JBE 0x44f8a8																					
  0x44f83f		4883ec28		SUBQ $0x28, SP																					
  0x44f843		48896c2420		MOVQ BP, 0x20(SP)																				
  0x44f848		488d6c2420		LEAQ 0x20(SP), BP																				
  0x44f84d		488b442430		MOVQ 0x30(SP), AX																				
  0x44f852		48890424		MOVQ AX, 0(SP)																					
  0x44f856		488b4c2438		MOVQ 0x38(SP), CX																				
  0x44f85b		48894c2408		MOVQ CX, 0x8(SP)																				
  0x44f860		48c744241011000000	MOVQ $0x11, 0x10(SP)																				
  0x44f869		e8b229fbff		CALL runtime.memequal(SB)																			
  0x44f86e		807c241800		CMPB $0x0, 0x18(SP)																				
  0x44f873		742f			JE 0x44f8a4																					
  0x44f875		488b442438		MOVQ 0x38(SP), AX																				
  0x44f87a		488b4818		MOVQ 0x18(AX), CX																				
  0x44f87e		488b542430		MOVQ 0x30(SP), DX																				
  0x44f883		48394a18		CMPQ CX, 0x18(DX)																				
  0x44f887		7517			JNE 0x44f8a0																					
  0x44f889		8b4020			MOVL 0x20(AX), AX																				
  0x44f88c		394220			CMPL AX, 0x20(DX)																				
  0x44f88f		0f94c0			SETE AL																						
  0x44f892		88442440		MOVB AL, 0x40(SP)																				
  0x44f896		488b6c2420		MOVQ 0x20(SP), BP																				
  0x44f89b		4883c428		ADDQ $0x28, SP																					
  0x44f89f		c3			RET																						
  0x44f8a0		31c0			XORL AX, AX																					
  0x44f8a2		ebee			JMP 0x44f892																					
  0x44f8a4		31c0			XORL AX, AX																					
  0x44f8a6		ebea			JMP 0x44f892																					
  0x44f8a8		e8d37fffff		CALL runtime.morestack_noctxt(SB)																		
  0x44f8ad		eb81			JMP type..eq.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }(SB)	

TEXT type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB) <autogenerated>

  0x44f8b0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																											
  0x44f8b9		483b6110		CMPQ 0x10(CX), SP																											
  0x44f8bd		7643			JBE 0x44f902																												
  0x44f8bf		4883ec28		SUBQ $0x28, SP																												
  0x44f8c3		48896c2420		MOVQ BP, 0x20(SP)																											
  0x44f8c8		488d6c2420		LEAQ 0x20(SP), BP																											
  0x44f8cd		488b442430		MOVQ 0x30(SP), AX																											
  0x44f8d2		48890424		MOVQ AX, 0(SP)																												
  0x44f8d6		488b442438		MOVQ 0x38(SP), AX																											
  0x44f8db		4889442408		MOVQ AX, 0x8(SP)																											
  0x44f8e0		48c744241041000000	MOVQ $0x41, 0x10(SP)																											
  0x44f8e9		e8d279fbff		CALL runtime.memhash(SB)																										
  0x44f8ee		488b442418		MOVQ 0x18(SP), AX																											
  0x44f8f3		4889442440		MOVQ AX, 0x40(SP)																											
  0x44f8f8		488b6c2420		MOVQ 0x20(SP), BP																											
  0x44f8fd		4883c428		ADDQ $0x28, SP																												
  0x44f901		c3			RET																													
  0x44f902		e8797fffff		CALL runtime.morestack_noctxt(SB)																									
  0x44f907		eba7			JMP type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB)	

TEXT type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB) <autogenerated>

  0x44f910		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX																										
  0x44f919		483b6110		CMPQ 0x10(CX), SP																										
  0x44f91d		7642			JBE 0x44f961																											
  0x44f91f		4883ec28		SUBQ $0x28, SP																											
  0x44f923		48896c2420		MOVQ BP, 0x20(SP)																										
  0x44f928		488d6c2420		LEAQ 0x20(SP), BP																										
  0x44f92d		488b442430		MOVQ 0x30(SP), AX																										
  0x44f932		48890424		MOVQ AX, 0(SP)																											
  0x44f936		488b442438		MOVQ 0x38(SP), AX																										
  0x44f93b		4889442408		MOVQ AX, 0x8(SP)																										
  0x44f940		48c744241041000000	MOVQ $0x41, 0x10(SP)																										
  0x44f949		e8d228fbff		CALL runtime.memequal(SB)																									
  0x44f94e		0fb6442418		MOVZX 0x18(SP), AX																										
  0x44f953		88442440		MOVB AL, 0x40(SP)																										
  0x44f957		488b6c2420		MOVQ 0x20(SP), BP																										
  0x44f95c		4883c428		ADDQ $0x28, SP																											
  0x44f960		c3			RET																												
  0x44f961		e81a7fffff		CALL runtime.morestack_noctxt(SB)																								
  0x44f966		eba8			JMP type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool }(SB)	

TEXT main.test(SB) /home/ty-l1/go1/basic/assemble/closure/closure.go
func test(x int) func() {
  0x44f970		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX		
  0x44f979		483b6110		CMPQ 0x10(CX), SP		
  0x44f97d		0f86c3000000		JBE 0x44fa46			
  0x44f983		4883ec30		SUBQ $0x30, SP			
  0x44f987		48896c2428		MOVQ BP, 0x28(SP)		
  0x44f98c		488d6c2428		LEAQ 0x28(SP), BP		
  0x44f991		48c744244000000000	MOVQ $0x0, 0x40(SP)		
  0x44f99a		488d059fb10000		LEAQ 0xb19f(IP), AX		
  0x44f9a1		48890424		MOVQ AX, 0(SP)			
  0x44f9a5		e8a6adfbff		CALL runtime.newobject(SB)	
  0x44f9aa		488b442408		MOVQ 0x8(SP), AX		
  0x44f9af		4889442420		MOVQ AX, 0x20(SP)		
  0x44f9b4		488b4c2438		MOVQ 0x38(SP), CX		
  0x44f9b9		488908			MOVQ CX, 0(AX)			
	println(&x)
  0x44f9bc		488b442420		MOVQ 0x20(SP), AX		
  0x44f9c1		4889442418		MOVQ AX, 0x18(SP)		
  0x44f9c6		e8f544fdff		CALL runtime.printlock(SB)	
  0x44f9cb		488b442418		MOVQ 0x18(SP), AX		
  0x44f9d0		48890424		MOVQ AX, 0(SP)			
  0x44f9d4		e8d74dfdff		CALL runtime.printpointer(SB)	
  0x44f9d9		e87247fdff		CALL runtime.printnl(SB)	
  0x44f9de		e85d45fdff		CALL runtime.printunlock(SB)	
	return func() {
  0x44f9e3		488d0516110100		LEAQ 0x11116(IP), AX			
  0x44f9ea		48890424		MOVQ AX, 0(SP)				
  0x44f9ee		e85dadfbff		CALL runtime.newobject(SB)		
  0x44f9f3		488b442408		MOVQ 0x8(SP), AX			
  0x44f9f8		4889442410		MOVQ AX, 0x10(SP)			
  0x44f9fd		488d0d9c000000		LEAQ main.test.func1(SB), CX		
  0x44fa04		488908			MOVQ CX, 0(AX)				
  0x44fa07		488b442410		MOVQ 0x10(SP), AX			
  0x44fa0c		8400			TESTB AL, 0(AX)				
  0x44fa0e		488b4c2420		MOVQ 0x20(SP), CX			
  0x44fa13		488d7808		LEAQ 0x8(AX), DI			
  0x44fa17		833d02d4080000		CMPL $0x0, runtime.writeBarrier(SB)	
  0x44fa1e		7402			JE 0x44fa22				
  0x44fa20		eb1a			JMP 0x44fa3c				
  0x44fa22		48894808		MOVQ CX, 0x8(AX)			
  0x44fa26		eb00			JMP 0x44fa28				
  0x44fa28		488b442410		MOVQ 0x10(SP), AX			
  0x44fa2d		4889442440		MOVQ AX, 0x40(SP)			
  0x44fa32		488b6c2428		MOVQ 0x28(SP), BP			
  0x44fa37		4883c430		ADDQ $0x30, SP				
  0x44fa3b		c3			RET					
  0x44fa3c		4889c8			MOVQ CX, AX				
  0x44fa3f		e83c9cffff		CALL runtime.gcWriteBarrier(SB)		
  0x44fa44		ebe2			JMP 0x44fa28				
func test(x int) func() {
  0x44fa46		e8357effff		CALL runtime.morestack_noctxt(SB)	
  0x44fa4b		e920ffffff		JMP main.test(SB)			

TEXT main.main(SB) /home/ty-l1/go1/basic/assemble/closure/closure.go
func main() {
  0x44fa50		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44fa59		483b6110		CMPQ 0x10(CX), SP	
  0x44fa5d		7634			JBE 0x44fa93		
  0x44fa5f		4883ec20		SUBQ $0x20, SP		
  0x44fa63		48896c2418		MOVQ BP, 0x18(SP)	
  0x44fa68		488d6c2418		LEAQ 0x18(SP), BP	
	f := test(123)
  0x44fa6d		48c704247b000000	MOVQ $0x7b, 0(SP)	
  0x44fa75		e8f6feffff		CALL main.test(SB)	
  0x44fa7a		488b542408		MOVQ 0x8(SP), DX	
  0x44fa7f		4889542410		MOVQ DX, 0x10(SP)	
	f()
  0x44fa84		488b02			MOVQ 0(DX), AX		
  0x44fa87		ffd0			CALL AX			
}
  0x44fa89		488b6c2418		MOVQ 0x18(SP), BP	
  0x44fa8e		4883c420		ADDQ $0x20, SP		
  0x44fa92		c3			RET			
func main() {
  0x44fa93		e8e87dffff		CALL runtime.morestack_noctxt(SB)	
  0x44fa98		ebb6			JMP main.main(SB)			

TEXT main.test.func1(SB) /home/ty-l1/go1/basic/assemble/closure/closure.go
	return func() {
  0x44faa0		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX	
  0x44faa9		483b6110		CMPQ 0x10(CX), SP	
  0x44faad		765e			JBE 0x44fb0d		
  0x44faaf		4883ec28		SUBQ $0x28, SP		
  0x44fab3		48896c2420		MOVQ BP, 0x20(SP)	
  0x44fab8		488d6c2420		LEAQ 0x20(SP), BP	
  0x44fabd		488b4208		MOVQ 0x8(DX), AX	
  0x44fac1		4889442418		MOVQ AX, 0x18(SP)	
		println(&x, x)
  0x44fac6		4889442410		MOVQ AX, 0x10(SP)		
  0x44facb		e8f043fdff		CALL runtime.printlock(SB)	
  0x44fad0		488b442410		MOVQ 0x10(SP), AX		
  0x44fad5		48890424		MOVQ AX, 0(SP)			
  0x44fad9		e8d24cfdff		CALL runtime.printpointer(SB)	
  0x44fade		e81d46fdff		CALL runtime.printsp(SB)	
  0x44fae3		488b442418		MOVQ 0x18(SP), AX		
  0x44fae8		488b00			MOVQ 0(AX), AX			
  0x44faeb		4889442408		MOVQ AX, 0x8(SP)		
  0x44faf0		48890424		MOVQ AX, 0(SP)			
  0x44faf4		e8474bfdff		CALL runtime.printint(SB)	
  0x44faf9		e85246fdff		CALL runtime.printnl(SB)	
  0x44fafe		e83d44fdff		CALL runtime.printunlock(SB)	
	}
  0x44fb03		488b6c2420		MOVQ 0x20(SP), BP	
  0x44fb08		4883c428		ADDQ $0x28, SP		
  0x44fb0c		c3			RET			
	return func() {
  0x44fb0d		e8ce7cffff		CALL runtime.morestack(SB)	
  0x44fb12		eb8c			JMP main.test.func1(SB)		

TEXT main.init(SB) <autogenerated>

  0x44fb20		64488b0c25f8ffffff	MOVQ FS:0xfffffff8, CX			
  0x44fb29		483b6110		CMPQ 0x10(CX), SP			
  0x44fb2d		7649			JBE 0x44fb78				
  0x44fb2f		4883ec08		SUBQ $0x8, SP				
  0x44fb33		48892c24		MOVQ BP, 0(SP)				
  0x44fb37		488d2c24		LEAQ 0(SP), BP				
  0x44fb3b		803d60d1080001		CMPB $0x1, main.initdone.(SB)		
  0x44fb42		7702			JA 0x44fb46				
  0x44fb44		eb09			JMP 0x44fb4f				
  0x44fb46		488b2c24		MOVQ 0(SP), BP				
  0x44fb4a		4883c408		ADDQ $0x8, SP				
  0x44fb4e		c3			RET					
  0x44fb4f		803d4cd1080001		CMPB $0x1, main.initdone.(SB)		
  0x44fb56		7402			JE 0x44fb5a				
  0x44fb58		eb07			JMP 0x44fb61				
  0x44fb5a		e89126fdff		CALL runtime.throwinit(SB)		
  0x44fb5f		0f0b			UD2					
  0x44fb61		c6053ad1080001		MOVB $0x1, main.initdone.(SB)		
  0x44fb68		c60533d1080002		MOVB $0x2, main.initdone.(SB)		
  0x44fb6f		488b2c24		MOVQ 0(SP), BP				
  0x44fb73		4883c408		ADDQ $0x8, SP				
  0x44fb77		c3			RET					
  0x44fb78		e8037dffff		CALL runtime.morestack_noctxt(SB)	
  0x44fb7d		eba1			JMP main.init(SB)			
